<html>
<head>
<title>string_arrow.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
string_arrow.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Union</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">lib</span><span class="s0">,</span>
    <span class="s1">missing </span><span class="s0">as </span><span class="s1">libmissing</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.compat </span><span class="s0">import </span><span class="s1">pa_version_under7p0</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_bool_dtype</span><span class="s0">,</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_object_dtype</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
    <span class="s1">is_string_dtype</span><span class="s0">,</span>
    <span class="s1">pandas_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">isna</span>

<span class="s0">from </span><span class="s1">pandas.core.arrays._arrow_string_mixins </span><span class="s0">import </span><span class="s1">ArrowStringArrayMixin</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.arrow </span><span class="s0">import </span><span class="s1">ArrowExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.boolean </span><span class="s0">import </span><span class="s1">BooleanDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.integer </span><span class="s0">import </span><span class="s1">Int64Dtype</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.numeric </span><span class="s0">import </span><span class="s1">NumericDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BaseStringArray</span><span class="s0">,</span>
    <span class="s1">StringDtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.strings.object_array </span><span class="s0">import </span><span class="s1">ObjectStringArrayMixin</span>

<span class="s0">if not </span><span class="s1">pa_version_under7p0:</span>
    <span class="s0">import </span><span class="s1">pyarrow </span><span class="s0">as </span><span class="s1">pa</span>
    <span class="s0">import </span><span class="s1">pyarrow.compute </span><span class="s0">as </span><span class="s1">pc</span>

    <span class="s0">from </span><span class="s1">pandas.core.arrays.arrow._arrow_utils </span><span class="s0">import </span><span class="s1">fallback_performancewarning</span>


<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">AxisInt</span><span class="s0">,</span>
        <span class="s1">Dtype</span><span class="s0">,</span>
        <span class="s1">Scalar</span><span class="s0">,</span>
        <span class="s1">npt</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s1">ArrowStringScalarOrNAT = Union[str</span><span class="s0">, </span><span class="s1">libmissing.NAType]</span>


<span class="s0">def </span><span class="s1">_chk_pyarrow_available() -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s0">if </span><span class="s1">pa_version_under7p0:</span>
        <span class="s1">msg = </span><span class="s2">&quot;pyarrow&gt;=7.0.0 is required for PyArrow backed ArrowExtensionArray.&quot;</span>
        <span class="s0">raise </span><span class="s1">ImportError(msg)</span>


<span class="s3"># TODO: Inherit directly from BaseStringArrayMethods. Currently we inherit from</span>
<span class="s3"># ObjectStringArrayMixin because we want to have the object-dtype based methods as</span>
<span class="s3"># fallback for the ones that pyarrow doesn't yet support</span>


<span class="s0">class </span><span class="s1">ArrowStringArray(ObjectStringArrayMixin</span><span class="s0">, </span><span class="s1">ArrowExtensionArray</span><span class="s0">, </span><span class="s1">BaseStringArray):</span>
    <span class="s4">&quot;&quot;&quot; 
    Extension array for string data in a ``pyarrow.ChunkedArray``. 
 
    .. versionadded:: 1.2.0 
 
    .. warning:: 
 
       ArrowStringArray is considered experimental. The implementation and 
       parts of the API may change without warning. 
 
    Parameters 
    ---------- 
    values : pyarrow.Array or pyarrow.ChunkedArray 
        The array of data. 
 
    Attributes 
    ---------- 
    None 
 
    Methods 
    ------- 
    None 
 
    See Also 
    -------- 
    :func:`pandas.array` 
        The recommended function for creating a ArrowStringArray. 
    Series.str 
        The string methods are available on Series backed by 
        a ArrowStringArray. 
 
    Notes 
    ----- 
    ArrowStringArray returns a BooleanArray for comparison methods. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.array(['This is', 'some text', None, 'data.'], dtype=&quot;string[pyarrow]&quot;) 
    &lt;ArrowStringArray&gt; 
    ['This is', 'some text', &lt;NA&gt;, 'data.'] 
    Length: 4, dtype: string 
    &quot;&quot;&quot;</span>

    <span class="s3"># error: Incompatible types in assignment (expression has type &quot;StringDtype&quot;,</span>
    <span class="s3"># base class &quot;ArrowExtensionArray&quot; defined the type as &quot;ArrowDtype&quot;)</span>
    <span class="s1">_dtype: StringDtype  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">_storage = </span><span class="s2">&quot;pyarrow&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(values)</span>
        <span class="s1">self._dtype = StringDtype(storage=self._storage)</span>

        <span class="s0">if not </span><span class="s1">pa.types.is_string(self._pa_array.type) </span><span class="s0">and not </span><span class="s1">(</span>
            <span class="s1">pa.types.is_dictionary(self._pa_array.type)</span>
            <span class="s0">and </span><span class="s1">pa.types.is_string(self._pa_array.type.value_type)</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;ArrowStringArray requires a PyArrow (chunked) array of string type&quot;</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot; 
        Length of this array. 
 
        Returns 
        ------- 
        length : int 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">len(self._pa_array)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_from_sequence(cls</span><span class="s0">, </span><span class="s1">scalars</span><span class="s0">, </span><span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">copy: bool = </span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">from </span><span class="s1">pandas.core.arrays.masked </span><span class="s0">import </span><span class="s1">BaseMaskedArray</span>

        <span class="s1">_chk_pyarrow_available()</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">and not </span><span class="s1">(isinstance(dtype</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">dtype == </span><span class="s2">&quot;string&quot;</span><span class="s1">):</span>
            <span class="s1">dtype = pandas_dtype(dtype)</span>
            <span class="s0">assert </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">StringDtype) </span><span class="s0">and </span><span class="s1">dtype.storage </span><span class="s0">in </span><span class="s1">(</span>
                <span class="s2">&quot;pyarrow&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;pyarrow_numpy&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(scalars</span><span class="s0">, </span><span class="s1">BaseMaskedArray):</span>
            <span class="s3"># avoid costly conversion to object dtype in ensure_string_array and</span>
            <span class="s3"># numerical issues with Float32Dtype</span>
            <span class="s1">na_values = scalars._mask</span>
            <span class="s1">result = scalars._data</span>
            <span class="s1">result = lib.ensure_string_array(result</span><span class="s0">, </span><span class="s1">copy=copy</span><span class="s0">, </span><span class="s1">convert_na_value=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">cls(pa.array(result</span><span class="s0">, </span><span class="s1">mask=na_values</span><span class="s0">, </span><span class="s1">type=pa.string()))</span>
        <span class="s0">elif </span><span class="s1">isinstance(scalars</span><span class="s0">, </span><span class="s1">(pa.Array</span><span class="s0">, </span><span class="s1">pa.ChunkedArray)):</span>
            <span class="s0">return </span><span class="s1">cls(pc.cast(scalars</span><span class="s0">, </span><span class="s1">pa.string()))</span>

        <span class="s3"># convert non-na-likes to str</span>
        <span class="s1">result = lib.ensure_string_array(scalars</span><span class="s0">, </span><span class="s1">copy=copy)</span>
        <span class="s0">return </span><span class="s1">cls(pa.array(result</span><span class="s0">, </span><span class="s1">type=pa.string()</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">))</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_from_sequence_of_strings(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">strings</span><span class="s0">, </span><span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">copy: bool = </span><span class="s0">False</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">cls._from_sequence(strings</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; StringDtype:  </span><span class="s3"># type: ignore[override]</span>
        <span class="s4">&quot;&quot;&quot; 
        An instance of 'string[pyarrow]'. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._dtype</span>

    <span class="s0">def </span><span class="s1">insert(self</span><span class="s0">, </span><span class="s1">loc: int</span><span class="s0">, </span><span class="s1">item) -&gt; ArrowStringArray:</span>
        <span class="s0">if not </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">item </span><span class="s0">is not </span><span class="s1">libmissing.NA:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Scalar must be NA or str&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">super().insert(loc</span><span class="s0">, </span><span class="s1">item)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_result_converter(cls</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(values)</span>

    <span class="s0">def </span><span class="s1">_maybe_convert_setitem_value(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s4">&quot;&quot;&quot;Maybe convert value to be pyarrow compatible.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">is_scalar(value):</span>
            <span class="s0">if </span><span class="s1">isna(value):</span>
                <span class="s1">value = </span><span class="s0">None</span>
            <span class="s0">elif not </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Scalar must be NA or str&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">value = np.array(value</span><span class="s0">, </span><span class="s1">dtype=object</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">value[isna(value)] = </span><span class="s0">None</span>
            <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">value:</span>
                <span class="s0">if not </span><span class="s1">(v </span><span class="s0">is None or </span><span class="s1">isinstance(v</span><span class="s0">, </span><span class="s1">str)):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Scalar must be NA or str&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">super()._maybe_convert_setitem_value(value)</span>

    <span class="s0">def </span><span class="s1">isin(self</span><span class="s0">, </span><span class="s1">values) -&gt; npt.NDArray[np.bool_]:</span>
        <span class="s1">value_set = [</span>
            <span class="s1">pa_scalar.as_py()</span>
            <span class="s0">for </span><span class="s1">pa_scalar </span><span class="s0">in </span><span class="s1">[pa.scalar(value</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">values]</span>
            <span class="s0">if </span><span class="s1">pa_scalar.type </span><span class="s0">in </span><span class="s1">(pa.string()</span><span class="s0">, </span><span class="s1">pa.null())</span>
        <span class="s1">]</span>

        <span class="s3"># short-circuit to return all False array.</span>
        <span class="s0">if not </span><span class="s1">len(value_set):</span>
            <span class="s0">return </span><span class="s1">np.zeros(len(self)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

        <span class="s1">result = pc.is_in(self._pa_array</span><span class="s0">, </span><span class="s1">value_set=pa.array(value_set))</span>
        <span class="s3"># pyarrow 2.0.0 returned nulls, so we explicily specify dtype to convert nulls</span>
        <span class="s3"># to False</span>
        <span class="s0">return </span><span class="s1">np.array(result</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>

    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">dtype = pandas_dtype(dtype)</span>

        <span class="s0">if </span><span class="s1">dtype == self.dtype:</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s0">return </span><span class="s1">self.copy()</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">elif </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">NumericDtype):</span>
            <span class="s1">data = self._pa_array.cast(pa.from_numpy_dtype(dtype.numpy_dtype))</span>
            <span class="s0">return </span><span class="s1">dtype.__from_arrow__(data)</span>
        <span class="s0">elif </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">np.dtype) </span><span class="s0">and </span><span class="s1">np.issubdtype(dtype</span><span class="s0">, </span><span class="s1">np.floating):</span>
            <span class="s0">return </span><span class="s1">self.to_numpy(dtype=dtype</span><span class="s0">, </span><span class="s1">na_value=np.nan)</span>

        <span class="s0">return </span><span class="s1">super().astype(dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_data(self):</span>
        <span class="s3"># dask accesses ._data directlys</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s2">._data is a deprecated and will be removed &quot;</span>
            <span class="s2">&quot;in a future version, use ._pa_array instead&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._pa_array</span>

    <span class="s3"># ------------------------------------------------------------------------</span>
    <span class="s3"># String methods interface</span>

    <span class="s3"># error: Incompatible types in assignment (expression has type &quot;NAType&quot;,</span>
    <span class="s3"># base class &quot;ObjectStringArrayMixin&quot; defined the type as &quot;float&quot;)</span>
    <span class="s1">_str_na_value = libmissing.NA  </span><span class="s3"># type: ignore[assignment]</span>

    <span class="s0">def </span><span class="s1">_str_map(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">na_value=</span><span class="s0">None, </span><span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">convert: bool = </span><span class="s0">True</span>
    <span class="s1">):</span>
        <span class="s3"># TODO: de-duplicate with StringArray method. This method is moreless copy and</span>
        <span class="s3"># paste.</span>

        <span class="s0">from </span><span class="s1">pandas.arrays </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">BooleanArray</span><span class="s0">,</span>
            <span class="s1">IntegerArray</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dtype = self.dtype</span>
        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">na_value = self.dtype.na_value</span>

        <span class="s1">mask = isna(self)</span>
        <span class="s1">arr = np.asarray(self)</span>

        <span class="s0">if </span><span class="s1">is_integer_dtype(dtype) </span><span class="s0">or </span><span class="s1">is_bool_dtype(dtype):</span>
            <span class="s1">constructor: type[IntegerArray] | type[BooleanArray]</span>
            <span class="s0">if </span><span class="s1">is_integer_dtype(dtype):</span>
                <span class="s1">constructor = IntegerArray</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">constructor = BooleanArray</span>

            <span class="s1">na_value_is_na = isna(na_value)</span>
            <span class="s0">if </span><span class="s1">na_value_is_na:</span>
                <span class="s1">na_value = </span><span class="s5">1</span>
            <span class="s1">result = lib.map_infer_mask(</span>
                <span class="s1">arr</span><span class="s0">,</span>
                <span class="s1">f</span><span class="s0">,</span>
                <span class="s1">mask.view(</span><span class="s2">&quot;uint8&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">convert=</span><span class="s0">False,</span>
                <span class="s1">na_value=na_value</span><span class="s0">,</span>
                <span class="s3"># error: Argument 1 to &quot;dtype&quot; has incompatible type</span>
                <span class="s3"># &quot;Union[ExtensionDtype, str, dtype[Any], Type[object]]&quot;; expected</span>
                <span class="s3"># &quot;Type[object]&quot;</span>
                <span class="s1">dtype=np.dtype(dtype)</span><span class="s0">,  </span><span class="s3"># type: ignore[arg-type]</span>
            <span class="s1">)</span>

            <span class="s0">if not </span><span class="s1">na_value_is_na:</span>
                <span class="s1">mask[:] = </span><span class="s0">False</span>

            <span class="s0">return </span><span class="s1">constructor(result</span><span class="s0">, </span><span class="s1">mask)</span>

        <span class="s0">elif </span><span class="s1">is_string_dtype(dtype) </span><span class="s0">and not </span><span class="s1">is_object_dtype(dtype):</span>
            <span class="s3"># i.e. StringDtype</span>
            <span class="s1">result = lib.map_infer_mask(</span>
                <span class="s1">arr</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">mask.view(</span><span class="s2">&quot;uint8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">convert=</span><span class="s0">False, </span><span class="s1">na_value=na_value</span>
            <span class="s1">)</span>
            <span class="s1">result = pa.array(result</span><span class="s0">, </span><span class="s1">mask=mask</span><span class="s0">, </span><span class="s1">type=pa.string()</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">type(self)(result)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># This is when the result type is object. We reach this when</span>
            <span class="s3"># -&gt; We know the result type is truly object (e.g. .encode returns bytes</span>
            <span class="s3">#    or .findall returns a list).</span>
            <span class="s3"># -&gt; We don't know the result type. E.g. `.get` can return anything.</span>
            <span class="s0">return </span><span class="s1">lib.map_infer_mask(arr</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">mask.view(</span><span class="s2">&quot;uint8&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_str_contains(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">case: bool = </span><span class="s0">True, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">na=np.nan</span><span class="s0">, </span><span class="s1">regex: bool = </span><span class="s0">True</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">flags:</span>
            <span class="s1">fallback_performancewarning()</span>
            <span class="s0">return </span><span class="s1">super()._str_contains(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">regex)</span>

        <span class="s0">if </span><span class="s1">regex:</span>
            <span class="s1">result = pc.match_substring_regex(self._pa_array</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">ignore_case=</span><span class="s0">not </span><span class="s1">case)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = pc.match_substring(self._pa_array</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">ignore_case=</span><span class="s0">not </span><span class="s1">case)</span>
        <span class="s1">result = self._result_converter(result</span><span class="s0">, </span><span class="s1">na=na)</span>
        <span class="s0">if not </span><span class="s1">isna(na):</span>
            <span class="s1">result[isna(result)] = bool(na)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_str_startswith(self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">result = pc.starts_with(self._pa_array</span><span class="s0">, </span><span class="s1">pattern=pat)</span>
        <span class="s0">if not </span><span class="s1">isna(na):</span>
            <span class="s1">result = result.fill_null(na)</span>
        <span class="s1">result = self._result_converter(result)</span>
        <span class="s0">if not </span><span class="s1">isna(na):</span>
            <span class="s1">result[isna(result)] = bool(na)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_str_endswith(self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">result = pc.ends_with(self._pa_array</span><span class="s0">, </span><span class="s1">pattern=pat)</span>
        <span class="s0">if not </span><span class="s1">isna(na):</span>
            <span class="s1">result = result.fill_null(na)</span>
        <span class="s1">result = self._result_converter(result)</span>
        <span class="s0">if not </span><span class="s1">isna(na):</span>
            <span class="s1">result[isna(result)] = bool(na)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_str_replace(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">pat: str | re.Pattern</span><span class="s0">,</span>
        <span class="s1">repl: str | Callable</span><span class="s0">,</span>
        <span class="s1">n: int = -</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">case: bool = </span><span class="s0">True,</span>
        <span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">regex: bool = </span><span class="s0">True,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">isinstance(pat</span><span class="s0">, </span><span class="s1">re.Pattern) </span><span class="s0">or </span><span class="s1">callable(repl) </span><span class="s0">or not </span><span class="s1">case </span><span class="s0">or </span><span class="s1">flags:</span>
            <span class="s1">fallback_performancewarning()</span>
            <span class="s0">return </span><span class="s1">super()._str_replace(pat</span><span class="s0">, </span><span class="s1">repl</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">regex)</span>

        <span class="s1">func = pc.replace_substring_regex </span><span class="s0">if </span><span class="s1">regex </span><span class="s0">else </span><span class="s1">pc.replace_substring</span>
        <span class="s1">result = func(self._pa_array</span><span class="s0">, </span><span class="s1">pattern=pat</span><span class="s0">, </span><span class="s1">replacement=repl</span><span class="s0">, </span><span class="s1">max_replacements=n)</span>
        <span class="s0">return </span><span class="s1">type(self)(result)</span>

    <span class="s0">def </span><span class="s1">_str_match(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">case: bool = </span><span class="s0">True, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">na: Scalar | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">pat.startswith(</span><span class="s2">&quot;^&quot;</span><span class="s1">):</span>
            <span class="s1">pat = </span><span class="s2">f&quot;^</span><span class="s0">{</span><span class="s1">pat</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s0">return </span><span class="s1">self._str_contains(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">regex=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_fullmatch(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">case: bool = </span><span class="s0">True, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">na: Scalar | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">pat.endswith(</span><span class="s2">&quot;$&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">pat.endswith(</span><span class="s2">&quot;//$&quot;</span><span class="s1">):</span>
            <span class="s1">pat = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">pat</span><span class="s0">}</span><span class="s2">$&quot;</span>
        <span class="s0">return </span><span class="s1">self._str_match(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na)</span>

    <span class="s0">def </span><span class="s1">_str_isalnum(self):</span>
        <span class="s1">result = pc.utf8_is_alnum(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_isalpha(self):</span>
        <span class="s1">result = pc.utf8_is_alpha(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_isdecimal(self):</span>
        <span class="s1">result = pc.utf8_is_decimal(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_isdigit(self):</span>
        <span class="s1">result = pc.utf8_is_digit(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_islower(self):</span>
        <span class="s1">result = pc.utf8_is_lower(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_isnumeric(self):</span>
        <span class="s1">result = pc.utf8_is_numeric(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_isspace(self):</span>
        <span class="s1">result = pc.utf8_is_space(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_istitle(self):</span>
        <span class="s1">result = pc.utf8_is_title(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_isupper(self):</span>
        <span class="s1">result = pc.utf8_is_upper(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">self._result_converter(result)</span>

    <span class="s0">def </span><span class="s1">_str_len(self):</span>
        <span class="s1">result = pc.utf8_length(self._pa_array)</span>
        <span class="s0">return </span><span class="s1">Int64Dtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_lower(self):</span>
        <span class="s0">return </span><span class="s1">type(self)(pc.utf8_lower(self._pa_array))</span>

    <span class="s0">def </span><span class="s1">_str_upper(self):</span>
        <span class="s0">return </span><span class="s1">type(self)(pc.utf8_upper(self._pa_array))</span>

    <span class="s0">def </span><span class="s1">_str_strip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">to_strip </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_trim_whitespace(self._pa_array)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_trim(self._pa_array</span><span class="s0">, </span><span class="s1">characters=to_strip)</span>
        <span class="s0">return </span><span class="s1">type(self)(result)</span>

    <span class="s0">def </span><span class="s1">_str_lstrip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">to_strip </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_ltrim_whitespace(self._pa_array)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_ltrim(self._pa_array</span><span class="s0">, </span><span class="s1">characters=to_strip)</span>
        <span class="s0">return </span><span class="s1">type(self)(result)</span>

    <span class="s0">def </span><span class="s1">_str_rstrip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">to_strip </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_rtrim_whitespace(self._pa_array)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_rtrim(self._pa_array</span><span class="s0">, </span><span class="s1">characters=to_strip)</span>
        <span class="s0">return </span><span class="s1">type(self)(result)</span>

    <span class="s0">def </span><span class="s1">_reduce(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">keepdims: bool = </span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">result = self._reduce_calc(name</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">keepdims=keepdims</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;argmin&quot;</span><span class="s0">, </span><span class="s2">&quot;argmax&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">pa.Array):</span>
            <span class="s0">return </span><span class="s1">self._convert_int_dtype(result)</span>
        <span class="s0">elif </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">pa.Array):</span>
            <span class="s0">return </span><span class="s1">type(self)(result)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_convert_int_dtype(self</span><span class="s0">, </span><span class="s1">result):</span>
        <span class="s0">return </span><span class="s1">Int64Dtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_rank(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">axis: AxisInt = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">method: str = </span><span class="s2">&quot;average&quot;</span><span class="s0">,</span>
        <span class="s1">na_option: str = </span><span class="s2">&quot;keep&quot;</span><span class="s0">,</span>
        <span class="s1">ascending: bool = </span><span class="s0">True,</span>
        <span class="s1">pct: bool = </span><span class="s0">False,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        See Series.rank.__doc__. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._convert_int_dtype(</span>
            <span class="s1">self._rank_calc(</span>
                <span class="s1">axis=axis</span><span class="s0">,</span>
                <span class="s1">method=method</span><span class="s0">,</span>
                <span class="s1">na_option=na_option</span><span class="s0">,</span>
                <span class="s1">ascending=ascending</span><span class="s0">,</span>
                <span class="s1">pct=pct</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">ArrowStringArrayNumpySemantics(ArrowStringArray):</span>
    <span class="s1">_storage = </span><span class="s2">&quot;pyarrow_numpy&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">_chk_pyarrow_available()</span>

        <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">(pa.Array</span><span class="s0">, </span><span class="s1">pa.ChunkedArray)) </span><span class="s0">and </span><span class="s1">pa.types.is_large_string(</span>
            <span class="s1">values.type</span>
        <span class="s1">):</span>
            <span class="s1">values = pc.cast(values</span><span class="s0">, </span><span class="s1">pa.string())</span>
        <span class="s1">super().__init__(values)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_result_converter(cls</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">isna(na):</span>
            <span class="s1">values = values.fill_null(bool(na))</span>
        <span class="s0">return </span><span class="s1">ArrowExtensionArray(values).to_numpy(na_value=np.nan)</span>

    <span class="s0">def </span><span class="s1">__getattribute__(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s3"># ArrowStringArray and we both inherit from ArrowExtensionArray, which</span>
        <span class="s3"># creates inheritance problems (Diamond inheritance)</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s0">in </span><span class="s1">ArrowStringArrayMixin.__dict__ </span><span class="s0">and </span><span class="s1">item </span><span class="s0">not in </span><span class="s1">(</span>
            <span class="s2">&quot;_pa_array&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;__dict__&quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s0">return </span><span class="s1">partial(getattr(ArrowStringArrayMixin</span><span class="s0">, </span><span class="s1">item)</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s0">return </span><span class="s1">super().__getattribute__(item)</span>

    <span class="s0">def </span><span class="s1">_str_map(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">na_value=</span><span class="s0">None, </span><span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">convert: bool = </span><span class="s0">True</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dtype = self.dtype</span>
        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">na_value = self.dtype.na_value</span>

        <span class="s1">mask = isna(self)</span>
        <span class="s1">arr = np.asarray(self)</span>

        <span class="s0">if </span><span class="s1">is_integer_dtype(dtype) </span><span class="s0">or </span><span class="s1">is_bool_dtype(dtype):</span>
            <span class="s0">if </span><span class="s1">is_integer_dtype(dtype):</span>
                <span class="s1">na_value = np.nan</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">na_value = </span><span class="s0">False</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">result = lib.map_infer_mask(</span>
                    <span class="s1">arr</span><span class="s0">,</span>
                    <span class="s1">f</span><span class="s0">,</span>
                    <span class="s1">mask.view(</span><span class="s2">&quot;uint8&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">convert=</span><span class="s0">False,</span>
                    <span class="s1">na_value=na_value</span><span class="s0">,</span>
                    <span class="s1">dtype=np.dtype(dtype)</span><span class="s0">,  </span><span class="s3"># type: ignore[arg-type]</span>
                <span class="s1">)</span>
                <span class="s0">return </span><span class="s1">result</span>

            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">result = lib.map_infer_mask(</span>
                    <span class="s1">arr</span><span class="s0">,</span>
                    <span class="s1">f</span><span class="s0">,</span>
                    <span class="s1">mask.view(</span><span class="s2">&quot;uint8&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">convert=</span><span class="s0">False,</span>
                    <span class="s1">na_value=na_value</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">convert </span><span class="s0">and </span><span class="s1">result.dtype == object:</span>
                    <span class="s1">result = lib.maybe_convert_objects(result)</span>
                <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">elif </span><span class="s1">is_string_dtype(dtype) </span><span class="s0">and not </span><span class="s1">is_object_dtype(dtype):</span>
            <span class="s3"># i.e. StringDtype</span>
            <span class="s1">result = lib.map_infer_mask(</span>
                <span class="s1">arr</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">mask.view(</span><span class="s2">&quot;uint8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">convert=</span><span class="s0">False, </span><span class="s1">na_value=na_value</span>
            <span class="s1">)</span>
            <span class="s1">result = pa.array(result</span><span class="s0">, </span><span class="s1">mask=mask</span><span class="s0">, </span><span class="s1">type=pa.string()</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">type(self)(result)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># This is when the result type is object. We reach this when</span>
            <span class="s3"># -&gt; We know the result type is truly object (e.g. .encode returns bytes</span>
            <span class="s3">#    or .findall returns a list).</span>
            <span class="s3"># -&gt; We don't know the result type. E.g. `.get` can return anything.</span>
            <span class="s0">return </span><span class="s1">lib.map_infer_mask(arr</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">mask.view(</span><span class="s2">&quot;uint8&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_convert_int_dtype(self</span><span class="s0">, </span><span class="s1">result):</span>
        <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">pa.Array):</span>
            <span class="s1">result = result.to_numpy(zero_copy_only=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">elif not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">result = result.to_numpy()</span>
        <span class="s0">if </span><span class="s1">result.dtype == np.int32:</span>
            <span class="s1">result = result.astype(np.int64)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_str_count(self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">flags:</span>
            <span class="s0">return </span><span class="s1">super()._str_count(pat</span><span class="s0">, </span><span class="s1">flags)</span>
        <span class="s1">result = pc.count_substring_regex(self._pa_array</span><span class="s0">, </span><span class="s1">pat).to_numpy()</span>
        <span class="s0">return </span><span class="s1">self._convert_int_dtype(result)</span>

    <span class="s0">def </span><span class="s1">_str_len(self):</span>
        <span class="s1">result = pc.utf8_length(self._pa_array).to_numpy()</span>
        <span class="s0">return </span><span class="s1">self._convert_int_dtype(result)</span>

    <span class="s0">def </span><span class="s1">_str_find(self</span><span class="s0">, </span><span class="s1">sub: str</span><span class="s0">, </span><span class="s1">start: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">end: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">start != </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">end </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">slices = pc.utf8_slice_codeunits(self._pa_array</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop=end)</span>
            <span class="s1">result = pc.find_substring(slices</span><span class="s0">, </span><span class="s1">sub)</span>
            <span class="s1">not_found = pc.equal(result</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">offset_result = pc.add(result</span><span class="s0">, </span><span class="s1">end - start)</span>
            <span class="s1">result = pc.if_else(not_found</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">offset_result)</span>
        <span class="s0">elif </span><span class="s1">start == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">end </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">slices = self._pa_array</span>
            <span class="s1">result = pc.find_substring(slices</span><span class="s0">, </span><span class="s1">sub)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super()._str_find(sub</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>
        <span class="s0">return </span><span class="s1">self._convert_int_dtype(result.to_numpy())</span>

    <span class="s0">def </span><span class="s1">_cmp_method(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s1">result = super()._cmp_method(other</span><span class="s0">, </span><span class="s1">op)</span>
        <span class="s0">return </span><span class="s1">result.to_numpy(np.bool_</span><span class="s0">, </span><span class="s1">na_value=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">value_counts(self</span><span class="s0">, </span><span class="s1">dropna: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

        <span class="s1">result = super().value_counts(dropna)</span>
        <span class="s0">return </span><span class="s1">Series(</span>
            <span class="s1">result._values.to_numpy()</span><span class="s0">, </span><span class="s1">index=result.index</span><span class="s0">, </span><span class="s1">name=result.name</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_reduce(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">keepdims: bool = </span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;any&quot;</span><span class="s0">, </span><span class="s2">&quot;all&quot;</span><span class="s1">]:</span>
            <span class="s0">if not </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">name == </span><span class="s2">&quot;all&quot;</span><span class="s1">:</span>
                <span class="s1">nas = pc.invert(pc.is_null(self._pa_array))</span>
                <span class="s1">arr = pc.and_kleene(nas</span><span class="s0">, </span><span class="s1">pc.not_equal(self._pa_array</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">arr = pc.not_equal(self._pa_array</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">ArrowExtensionArray(arr)._reduce(</span>
                <span class="s1">name</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">keepdims=keepdims</span><span class="s0">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super()._reduce(name</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">keepdims=keepdims</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">insert(self</span><span class="s0">, </span><span class="s1">loc: int</span><span class="s0">, </span><span class="s1">item) -&gt; ArrowStringArrayNumpySemantics:</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s0">is </span><span class="s1">np.nan:</span>
            <span class="s1">item = libmissing.NA</span>
        <span class="s0">return </span><span class="s1">super().insert(loc</span><span class="s0">, </span><span class="s1">item)  </span><span class="s3"># type: ignore[return-value]</span>
</pre>
</body>
</html>