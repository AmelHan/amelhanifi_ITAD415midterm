<html>
<head>
<title>demo.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
demo.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">string</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">asdict</span><span class="s0">, </span><span class="s1">dataclass</span><span class="s0">, </span><span class="s1">field</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span><span class="s0">, </span><span class="s1">Callable</span><span class="s0">, </span><span class="s1">cast</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>

<span class="s0">from </span><span class="s1">dask.dataframe._compat </span><span class="s0">import </span><span class="s1">PANDAS_GE_220</span>
<span class="s0">from </span><span class="s1">dask.dataframe._pyarrow </span><span class="s0">import </span><span class="s1">is_object_string_dtype</span>
<span class="s0">from </span><span class="s1">dask.dataframe.core </span><span class="s0">import </span><span class="s1">tokenize</span>
<span class="s0">from </span><span class="s1">dask.dataframe.io.io </span><span class="s0">import </span><span class="s1">from_map</span>
<span class="s0">from </span><span class="s1">dask.dataframe.io.utils </span><span class="s0">import </span><span class="s1">DataFrameIOFunction</span>
<span class="s0">from </span><span class="s1">dask.utils </span><span class="s0">import </span><span class="s1">random_state_data</span>

<span class="s1">__all__ = [</span>
    <span class="s2">&quot;make_timeseries&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;with_spec&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ColumnSpec&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RangeIndexSpec&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DatetimeIndexSpec&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DatasetSpec&quot;</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s1">default_int_args: dict[str</span><span class="s0">, </span><span class="s1">tuple[tuple[Any</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">, </span><span class="s1">dict[str</span><span class="s0">, </span><span class="s1">Any]]] = {</span>
    <span class="s2">&quot;poisson&quot;</span><span class="s1">: (()</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;lam&quot;</span><span class="s1">: </span><span class="s3">1000</span><span class="s1">})</span><span class="s0">,</span>
    <span class="s2">&quot;normal&quot;</span><span class="s1">: (()</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;scale&quot;</span><span class="s1">: </span><span class="s3">1000</span><span class="s1">})</span><span class="s0">,</span>
    <span class="s2">&quot;uniform&quot;</span><span class="s1">: (()</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;high&quot;</span><span class="s1">: </span><span class="s3">1000</span><span class="s1">})</span><span class="s0">,</span>
    <span class="s2">&quot;binomial&quot;</span><span class="s1">: ((</span><span class="s3">1000</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s2">&quot;random&quot;</span><span class="s1">: ((</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;high&quot;</span><span class="s1">: </span><span class="s3">1000</span><span class="s1">})</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">ColumnSpec:</span>
    <span class="s4">&quot;&quot;&quot;Encapsulates properties of a family of columns with the same dtype. 
    Different method can be specified for integer dtype (&quot;poisson&quot;, &quot;uniform&quot;, 
    &quot;binomial&quot;, etc.) 
 
    Notes 
    ----- 
    This API is still experimental, and will likely change in the future&quot;&quot;&quot;</span>

    <span class="s1">prefix: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s2">&quot;&quot;&quot;Column prefix. If not specified, will default to str(dtype)&quot;&quot;&quot;</span>

    <span class="s1">dtype: str | type | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s2">&quot;&quot;&quot;Column data type. Only supports numpy dtypes&quot;&quot;&quot;</span>

    <span class="s1">number: int = </span><span class="s3">1</span>
    <span class="s2">&quot;&quot;&quot;How many columns to create with these properties. Default 1. 
    If more than one columns are specified, they will be numbered: &quot;int1&quot;, &quot;int2&quot;, etc.&quot;&quot;&quot;</span>

    <span class="s1">nunique: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None  </span><span class="s5"># number of unique categories</span>
    <span class="s2">&quot;&quot;&quot;For a &quot;category&quot; column, how many unique categories to generate&quot;&quot;&quot;</span>

    <span class="s1">choices: list = field(default_factory=list)</span>
    <span class="s2">&quot;&quot;&quot;For a &quot;category&quot; or str column, list of possible values&quot;&quot;&quot;</span>

    <span class="s1">low: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s2">&quot;&quot;&quot;Start value for an int column. Optional if random=True, since ``randint`` doesn't accept 
    high and low.&quot;&quot;&quot;</span>

    <span class="s1">high: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s2">&quot;&quot;&quot;For an int column, high end of range&quot;&quot;&quot;</span>

    <span class="s1">length: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s2">&quot;&quot;&quot;For a str or &quot;category&quot; column with random=True, how large a string to generate&quot;&quot;&quot;</span>

    <span class="s1">random: bool = </span><span class="s0">False</span>
    <span class="s2">&quot;&quot;&quot;For an int column, whether to use ``randint``. For a string column produces a random string 
    of specified ``length``&quot;&quot;&quot;</span>

    <span class="s1">method: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s2">&quot;&quot;&quot;For an int column, method to use when generating the value, such as &quot;poisson&quot;, &quot;uniform&quot;, &quot;binomial&quot;. 
    Default &quot;poisson&quot;. Delegates to the same method of ``RandomState``&quot;&quot;&quot;</span>

    <span class="s1">args: tuple[Any</span><span class="s0">, </span><span class="s1">...] = field(default_factory=tuple)</span>
    <span class="s2">&quot;&quot;&quot;Args to pass into the method&quot;&quot;&quot;</span>

    <span class="s1">kwargs: dict[str</span><span class="s0">, </span><span class="s1">Any] = field(default_factory=dict)</span>
    <span class="s2">&quot;&quot;&quot;Any other kwargs to pass into the method&quot;&quot;&quot;</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">RangeIndexSpec:</span>
    <span class="s4">&quot;&quot;&quot;Properties of the dataframe RangeIndex 
 
    Notes 
    ----- 
    This API is still experimental, and will likely change in the future&quot;&quot;&quot;</span>

    <span class="s1">dtype: str | type = int</span>
    <span class="s2">&quot;&quot;&quot;Index dtype&quot;&quot;&quot;</span>

    <span class="s1">step: int = </span><span class="s3">1</span>
    <span class="s2">&quot;&quot;&quot;Step for a RangeIndex&quot;&quot;&quot;</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">DatetimeIndexSpec:</span>
    <span class="s4">&quot;&quot;&quot;Properties of the dataframe DatetimeIndex 
 
    Notes 
    ----- 
    This API is still experimental, and will likely change in the future&quot;&quot;&quot;</span>

    <span class="s1">dtype: str | type = int</span>
    <span class="s2">&quot;&quot;&quot;Index dtype&quot;&quot;&quot;</span>

    <span class="s1">start: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s2">&quot;&quot;&quot;First value of the index&quot;&quot;&quot;</span>

    <span class="s1">freq: str = </span><span class="s2">&quot;1H&quot;</span>
    <span class="s2">&quot;&quot;&quot;Frequency for the index (&quot;1H&quot;, &quot;1D&quot;, etc.)&quot;&quot;&quot;</span>

    <span class="s1">partition_freq: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s2">&quot;&quot;&quot;Partition frequency (&quot;1D&quot;, &quot;1M&quot;, etc.)&quot;&quot;&quot;</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">DatasetSpec:</span>
    <span class="s4">&quot;&quot;&quot;Defines a dataset with random data, such as which columns and data types to generate 
 
    Notes 
    ----- 
    This API is still experimental, and will likely change in the future&quot;&quot;&quot;</span>

    <span class="s1">npartitions: int = </span><span class="s3">1</span>
    <span class="s2">&quot;&quot;&quot;How many partitions generate in the dataframe. If the dataframe has a DatetimeIndex, specify 
    its ``partition_freq`` instead&quot;&quot;&quot;</span>

    <span class="s1">nrecords: int = </span><span class="s3">1000</span>
    <span class="s2">&quot;&quot;&quot;Total number of records to generate&quot;&quot;&quot;</span>

    <span class="s1">index_spec: RangeIndexSpec | DatetimeIndexSpec = field(</span>
        <span class="s1">default_factory=RangeIndexSpec</span>
    <span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;Properties of the index&quot;&quot;&quot;</span>

    <span class="s1">column_specs: list[ColumnSpec] = field(default_factory=list)</span>
    <span class="s2">&quot;&quot;&quot;List of column definitions&quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">make_float(n</span><span class="s0">, </span><span class="s1">rstate</span><span class="s0">, </span><span class="s1">random=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
    <span class="s1">kwargs.pop(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">kwargs.pop(</span><span class="s2">&quot;args&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">random:</span>
        <span class="s0">return </span><span class="s1">rstate.random(size=n</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">return </span><span class="s1">rstate.rand(n) * </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">make_int(</span>
    <span class="s1">n: int</span><span class="s0">,</span>
    <span class="s1">rstate: Any</span><span class="s0">,</span>
    <span class="s1">random: bool = </span><span class="s0">False,</span>
    <span class="s1">dtype: str | type = int</span><span class="s0">,</span>
    <span class="s1">method: str | Callable = </span><span class="s2">&quot;poisson&quot;</span><span class="s0">,</span>
    <span class="s1">args: tuple[Any</span><span class="s0">, </span><span class="s1">...] = ()</span><span class="s0">,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s0">def </span><span class="s1">_with_defaults(_method):</span>
        <span class="s1">handler_args</span><span class="s0">, </span><span class="s1">handler_kwargs = default_int_args.get(_method</span><span class="s0">, </span><span class="s1">(()</span><span class="s0">, </span><span class="s1">{}))</span>
        <span class="s1">handler_kwargs = handler_kwargs.copy()</span>
        <span class="s1">handler_kwargs.update(**kwargs)</span>
        <span class="s1">handler_args = args </span><span class="s0">if </span><span class="s1">args </span><span class="s0">else </span><span class="s1">handler_args</span>
        <span class="s0">return </span><span class="s1">handler_args</span><span class="s0">, </span><span class="s1">handler_kwargs</span>

    <span class="s0">if </span><span class="s1">random:</span>
        <span class="s1">handler_args</span><span class="s0">, </span><span class="s1">handler_kwargs = _with_defaults(</span><span class="s2">&quot;random&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s2">&quot;low&quot; </span><span class="s0">in </span><span class="s1">handler_kwargs:</span>
            <span class="s1">handler_args = ()</span>
        <span class="s1">data = rstate.randint(*handler_args</span><span class="s0">, </span><span class="s1">size=n</span><span class="s0">, </span><span class="s1">**handler_kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(method</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s5"># &quot;poisson&quot;, &quot;binomial&quot;, etc.</span>
            <span class="s1">handler_args</span><span class="s0">, </span><span class="s1">handler_kwargs = _with_defaults(method)</span>
            <span class="s1">handler = getattr(rstate</span><span class="s0">, </span><span class="s1">method)</span>
            <span class="s1">data = handler(*handler_args</span><span class="s0">, </span><span class="s1">size=n</span><span class="s0">, </span><span class="s1">**handler_kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># method is a Callable</span>
            <span class="s1">data = method(*args</span><span class="s0">, </span><span class="s1">state=rstate</span><span class="s0">, </span><span class="s1">size=n</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">return </span><span class="s1">data</span>


<span class="s1">names = [</span>
    <span class="s2">&quot;Alice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Bob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Charlie&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Dan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Edith&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Frank&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;George&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Hannah&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Ingrid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Jerry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Kevin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Laura&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Michael&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Norbert&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Oliver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Patricia&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Quinn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Ray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Sarah&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Tim&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Ursula&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Victor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Wendy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Xavier&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Yvonne&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Zelda&quot;</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s0">def </span><span class="s1">make_random_string(n</span><span class="s0">, </span><span class="s1">rstate</span><span class="s0">, </span><span class="s1">length: int = </span><span class="s3">25</span><span class="s1">) -&gt; list[str]:</span>
    <span class="s1">choices = list(string.ascii_letters + string.digits + string.punctuation + </span><span class="s2">&quot; &quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">[</span><span class="s2">&quot;&quot;</span><span class="s1">.join(rstate.choice(choices</span><span class="s0">, </span><span class="s1">size=length)) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(n)]</span>


<span class="s0">def </span><span class="s1">make_string(n</span><span class="s0">, </span><span class="s1">rstate</span><span class="s0">, </span><span class="s1">choices=</span><span class="s0">None, </span><span class="s1">random=</span><span class="s0">False, </span><span class="s1">length=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s1">kwargs.pop(</span><span class="s2">&quot;args&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">random:</span>
        <span class="s0">return </span><span class="s1">make_random_string(n</span><span class="s0">, </span><span class="s1">rstate</span><span class="s0">, </span><span class="s1">length=length)</span>
    <span class="s1">choices = choices </span><span class="s0">or </span><span class="s1">names</span>
    <span class="s0">return </span><span class="s1">rstate.choice(choices</span><span class="s0">, </span><span class="s1">size=n)</span>


<span class="s0">def </span><span class="s1">make_categorical(n</span><span class="s0">, </span><span class="s1">rstate</span><span class="s0">, </span><span class="s1">choices=</span><span class="s0">None, </span><span class="s1">nunique=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s1">kwargs.pop(</span><span class="s2">&quot;args&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">nunique </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">cat_len = len(str(nunique))</span>
        <span class="s1">choices = [str(x + </span><span class="s3">1</span><span class="s1">).zfill(cat_len) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(nunique)]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">choices = choices </span><span class="s0">or </span><span class="s1">names</span>
    <span class="s0">return </span><span class="s1">pd.Categorical.from_codes(rstate.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">len(choices)</span><span class="s0">, </span><span class="s1">size=n)</span><span class="s0">, </span><span class="s1">choices)</span>


<span class="s1">make: dict[type | str</span><span class="s0">, </span><span class="s1">Callable] = {</span>
    <span class="s1">float: make_float</span><span class="s0">,</span>
    <span class="s1">int: make_int</span><span class="s0">,</span>
    <span class="s1">str: make_string</span><span class="s0">,</span>
    <span class="s1">object: make_string</span><span class="s0">,</span>
    <span class="s2">&quot;string[python]&quot;</span><span class="s1">: make_string</span><span class="s0">,</span>
    <span class="s2">&quot;string[pyarrow]&quot;</span><span class="s1">: make_string</span><span class="s0">,</span>
    <span class="s2">&quot;category&quot;</span><span class="s1">: make_categorical</span><span class="s0">,</span>
    <span class="s2">&quot;int8&quot;</span><span class="s1">: make_int</span><span class="s0">,</span>
    <span class="s2">&quot;int16&quot;</span><span class="s1">: make_int</span><span class="s0">,</span>
    <span class="s2">&quot;int32&quot;</span><span class="s1">: make_int</span><span class="s0">,</span>
    <span class="s2">&quot;int64&quot;</span><span class="s1">: make_int</span><span class="s0">,</span>
    <span class="s2">&quot;float8&quot;</span><span class="s1">: make_float</span><span class="s0">,</span>
    <span class="s2">&quot;float16&quot;</span><span class="s1">: make_float</span><span class="s0">,</span>
    <span class="s2">&quot;float32&quot;</span><span class="s1">: make_float</span><span class="s0">,</span>
    <span class="s2">&quot;float64&quot;</span><span class="s1">: make_float</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s0">class </span><span class="s1">MakeDataframePart(DataFrameIOFunction):</span>
    <span class="s4">&quot;&quot;&quot; 
    Wrapper Class for ``make_dataframe_part`` 
    Makes a timeseries partition. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">index_dtype</span><span class="s0">, </span><span class="s1">dtypes</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">columns=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.index_dtype = index_dtype</span>
        <span class="s1">self._columns = columns </span><span class="s0">or </span><span class="s1">list(dtypes.keys())</span>
        <span class="s1">self.dtypes = dtypes</span>
        <span class="s1">self.kwargs = kwargs</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">columns(self):</span>
        <span class="s0">return </span><span class="s1">self._columns</span>

    <span class="s0">def </span><span class="s1">project_columns(self</span><span class="s0">, </span><span class="s1">columns):</span>
        <span class="s4">&quot;&quot;&quot;Return a new MakeTimeseriesPart object with 
        a sub-column projection. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">columns == self.columns:</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">return </span><span class="s1">MakeDataframePart(</span>
            <span class="s1">self.index_dtype</span><span class="s0">,</span>
            <span class="s1">self.dtypes</span><span class="s0">,</span>
            <span class="s1">self.kwargs</span><span class="s0">,</span>
            <span class="s1">columns=columns</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">part):</span>
        <span class="s1">divisions</span><span class="s0">, </span><span class="s1">state_data = part</span>
        <span class="s0">return </span><span class="s1">make_dataframe_part(</span>
            <span class="s1">self.index_dtype</span><span class="s0">,</span>
            <span class="s1">divisions[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">divisions[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">self.dtypes</span><span class="s0">,</span>
            <span class="s1">self.columns</span><span class="s0">,</span>
            <span class="s1">state_data</span><span class="s0">,</span>
            <span class="s1">self.kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">make_dataframe_part(index_dtype</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">dtypes</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">state_data</span><span class="s0">, </span><span class="s1">kwargs):</span>
    <span class="s1">state = np.random.RandomState(state_data)</span>
    <span class="s0">if </span><span class="s1">pd.api.types.is_datetime64_any_dtype(index_dtype):</span>
        <span class="s5"># FIXME: tzinfo would be lost in pd.date_range</span>
        <span class="s1">index = pd.date_range(</span>
            <span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=kwargs.get(</span><span class="s2">&quot;freq&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;timestamp&quot;</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">pd.api.types.is_integer_dtype(index_dtype):</span>
        <span class="s1">step = kwargs.get(</span><span class="s2">&quot;freq&quot;</span><span class="s1">)</span>
        <span class="s1">index = pd.RangeIndex(start=start</span><span class="s0">, </span><span class="s1">stop=end + step</span><span class="s0">, </span><span class="s1">step=step).astype(</span>
            <span class="s1">index_dtype</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;Unhandled index dtype: </span><span class="s0">{</span><span class="s1">index_dtype</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
    <span class="s1">df = make_partition(columns</span><span class="s0">, </span><span class="s1">dtypes</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">state)</span>
    <span class="s0">while </span><span class="s1">df.index[-</span><span class="s3">1</span><span class="s1">] &gt;= end:</span>
        <span class="s1">df = df.iloc[:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">df</span>


<span class="s0">def </span><span class="s1">same_astype(a: str | type</span><span class="s0">, </span><span class="s1">b: str | type):</span>
    <span class="s4">&quot;&quot;&quot;Same as pandas.api.types.is_dtype_equal, but also returns True for str / object&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">pd.api.types.is_dtype_equal(a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">or </span><span class="s1">(</span>
        <span class="s1">is_object_string_dtype(a) </span><span class="s0">and </span><span class="s1">is_object_string_dtype(b)</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">make_partition(columns: list</span><span class="s0">, </span><span class="s1">dtypes: dict[str</span><span class="s0">, </span><span class="s1">type | str]</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">state):</span>
    <span class="s1">data = {}</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dtypes.items():</span>
        <span class="s1">kws = {</span>
            <span class="s1">kk.rsplit(</span><span class="s2">&quot;_&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]: v</span>
            <span class="s0">for </span><span class="s1">kk</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items()</span>
            <span class="s0">if </span><span class="s1">kk.rsplit(</span><span class="s2">&quot;_&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] == k</span>
        <span class="s1">}</span>
        <span class="s5"># Note: we compute data for all dtypes in order, not just those in the output</span>
        <span class="s5"># columns. This ensures the same output given the same state_data, regardless</span>
        <span class="s5"># of whether there is any column projection.</span>
        <span class="s5"># cf. https://github.com/dask/dask/pull/9538#issuecomment-1267461887</span>
        <span class="s1">result = make[dt](len(index)</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">**kws)</span>
        <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">columns:</span>
            <span class="s1">data[k] = result</span>
    <span class="s1">df = pd.DataFrame(data</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=columns)</span>
    <span class="s1">update_dtypes = {</span>
        <span class="s1">k: v</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">dtypes.items()</span>
        <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">columns </span><span class="s0">and not </span><span class="s1">same_astype(v</span><span class="s0">, </span><span class="s1">df[k].dtype)</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">update_dtypes:</span>
        <span class="s1">df = df.astype(update_dtypes</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">df</span>


<span class="s1">_ME = </span><span class="s2">&quot;ME&quot; </span><span class="s0">if </span><span class="s1">PANDAS_GE_220 </span><span class="s0">else </span><span class="s2">&quot;M&quot;</span>


<span class="s0">def </span><span class="s1">make_timeseries(</span>
    <span class="s1">start=</span><span class="s2">&quot;2000-01-01&quot;</span><span class="s0">,</span>
    <span class="s1">end=</span><span class="s2">&quot;2000-12-31&quot;</span><span class="s0">,</span>
    <span class="s1">dtypes=</span><span class="s0">None,</span>
    <span class="s1">freq=</span><span class="s2">&quot;10s&quot;</span><span class="s0">,</span>
    <span class="s1">partition_freq=</span><span class="s2">f&quot;1</span><span class="s0">{</span><span class="s1">_ME</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
    <span class="s1">seed=</span><span class="s0">None,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Create timeseries dataframe with random data 
 
    Parameters 
    ---------- 
    start: datetime (or datetime-like string) 
        Start of time series 
    end: datetime (or datetime-like string) 
        End of time series 
    dtypes: dict (optional) 
        Mapping of column names to types. 
        Valid types include {float, int, str, 'category'} 
    freq: string 
        String like '2s' or '1H' or '12W' for the time series frequency 
    partition_freq: string 
        String like '1M' or '2Y' to divide the dataframe into partitions 
    seed: int (optional) 
        Randomstate seed 
    kwargs: 
        Keywords to pass down to individual column creation functions. 
        Keywords should be prefixed by the column name and then an underscore. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import dask.dataframe as dd 
    &gt;&gt;&gt; df = dd.demo.make_timeseries('2000', '2010', 
    ...                              {'value': float, 'name': str, 'id': int}, 
    ...                              freq='2H', partition_freq='1D', seed=1) 
    &gt;&gt;&gt; df.head()  # doctest: +SKIP 
                           id      name     value 
    2000-01-01 00:00:00   969     Jerry -0.309014 
    2000-01-01 02:00:00  1010       Ray -0.760675 
    2000-01-01 04:00:00  1016  Patricia -0.063261 
    2000-01-01 06:00:00   960   Charlie  0.788245 
    2000-01-01 08:00:00  1031     Kevin  0.466002 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">dtypes </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtypes = {</span><span class="s2">&quot;name&quot;</span><span class="s1">: str</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s1">: int</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">: float</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: float}</span>

    <span class="s1">divisions = list(pd.date_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=partition_freq))</span>
    <span class="s1">npartitions = len(divisions) - </span><span class="s3">1</span>
    <span class="s0">if </span><span class="s1">seed </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s5"># Get random integer seed for each partition. We can</span>
        <span class="s5"># call `random_state_data` in `MakeDataframePart`</span>
        <span class="s1">state_data = np.random.randint(</span><span class="s3">2e9</span><span class="s0">, </span><span class="s1">size=npartitions)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">state_data = random_state_data(npartitions</span><span class="s0">, </span><span class="s1">seed)</span>

    <span class="s5"># Build parts</span>
    <span class="s1">parts = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(divisions) - </span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">parts.append((divisions[i : i + </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">state_data[i]))</span>

    <span class="s1">kwargs[</span><span class="s2">&quot;freq&quot;</span><span class="s1">] = freq</span>
    <span class="s1">index_dtype = </span><span class="s2">&quot;datetime64[ns]&quot;</span>
    <span class="s1">meta_start</span><span class="s0">, </span><span class="s1">meta_end = list(pd.date_range(start=</span><span class="s2">&quot;2000&quot;</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s1">))</span>

    <span class="s5"># Construct the output collection with from_map</span>
    <span class="s0">return </span><span class="s1">from_map(</span>
        <span class="s1">MakeDataframePart(index_dtype</span><span class="s0">, </span><span class="s1">dtypes</span><span class="s0">, </span><span class="s1">kwargs)</span><span class="s0">,</span>
        <span class="s1">parts</span><span class="s0">,</span>
        <span class="s1">meta=make_dataframe_part(</span>
            <span class="s1">index_dtype</span><span class="s0">,</span>
            <span class="s1">meta_start</span><span class="s0">,</span>
            <span class="s1">meta_end</span><span class="s0">,</span>
            <span class="s1">dtypes</span><span class="s0">,</span>
            <span class="s1">list(dtypes.keys())</span><span class="s0">,</span>
            <span class="s1">state_data[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">kwargs</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">divisions=divisions</span><span class="s0">,</span>
        <span class="s1">label=</span><span class="s2">&quot;make-timeseries&quot;</span><span class="s0">,</span>
        <span class="s1">token=tokenize(start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">dtypes</span><span class="s0">, </span><span class="s1">freq</span><span class="s0">, </span><span class="s1">partition_freq</span><span class="s0">, </span><span class="s1">state_data)</span><span class="s0">,</span>
        <span class="s1">enforce_metadata=</span><span class="s0">False,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">with_spec(spec: DatasetSpec</span><span class="s0">, </span><span class="s1">seed: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Generate a random dataset according to provided spec 
 
    Parameters 
    ---------- 
    spec : DatasetSpec 
        Specify all the parameters of the dataset 
    seed: int (optional) 
        Randomstate seed 
 
    Notes 
    ----- 
    This API is still experimental, and will likely change in the future 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from dask.dataframe.io.demo import ColumnSpec, DatasetSpec, with_spec 
    &gt;&gt;&gt; ddf = with_spec( 
    ...     DatasetSpec( 
    ...         npartitions=10, 
    ...         nrecords=10_000, 
    ...         column_specs=[ 
    ...             ColumnSpec(dtype=int, number=2, prefix=&quot;p&quot;), 
    ...             ColumnSpec(dtype=int, number=2, prefix=&quot;n&quot;, method=&quot;normal&quot;), 
    ...             ColumnSpec(dtype=float, number=2, prefix=&quot;f&quot;), 
    ...             ColumnSpec(dtype=str, prefix=&quot;s&quot;, number=2, random=True, length=10), 
    ...             ColumnSpec(dtype=&quot;category&quot;, prefix=&quot;c&quot;, choices=[&quot;Y&quot;, &quot;N&quot;]), 
    ...         ], 
    ...     ), seed=42) 
    &gt;&gt;&gt; ddf.head(10)  # doctest: +SKIP 
         p1    p2    n1    n2        f1        f2          s1          s2 c1 
    0  1002   972  -811    20  0.640846 -0.176875  L#h98#}J`?  _8C607/:6e  N 
    1   985   982 -1663  -777  0.790257  0.792796  u:XI3,omoZ  w~@ /d)'-@  N 
    2   947   970   799  -269  0.740869 -0.118413  O$dnwCuq\\  !WtSe+(;#9  Y 
    3  1003   983  1133   521 -0.987459  0.278154  j+Qr_2{XG&amp;  &amp;XV7cy$y1T  Y 
    4  1017  1049   826     5 -0.875667 -0.744359  \4bJ3E-{:o  {+jC).?vK+  Y 
    5   984  1017  -492  -399  0.748181  0.293761  ~zUNHNgD&quot;!  yuEkXeVot|  Y 
    6   992  1027  -856    67 -0.125132 -0.234529  j.7z;o]Gc9  g|Fi5*}Y92  Y 
    7  1011   974   762 -1223  0.471696  0.937935  yT?j~N/-u]  JhEB[W-}^$  N 
    8   984   974   856    74  0.109963  0.367864  _j&quot;&amp;@ i&amp;;/  OYXQ)w{hoH  N 
    9  1030  1001  -792  -262  0.435587 -0.647970  Pmrwl{{|.K  3UTqM$86Sg  N 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(spec.column_specs) == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">spec.column_specs = [</span>
            <span class="s1">ColumnSpec(prefix=</span><span class="s2">&quot;i&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s1">low=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">high=</span><span class="s3">1_000_000</span><span class="s0">, </span><span class="s1">random=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">ColumnSpec(prefix=</span><span class="s2">&quot;f&quot;</span><span class="s0">, </span><span class="s1">dtype=float</span><span class="s0">, </span><span class="s1">random=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">ColumnSpec(prefix=</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;category&quot;</span><span class="s0">, </span><span class="s1">choices=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">ColumnSpec(prefix=</span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s1">dtype=str)</span><span class="s0">,</span>
        <span class="s1">]</span>

    <span class="s1">columns = []</span>
    <span class="s1">dtypes = {}</span>
    <span class="s1">partition_freq: str | int | </span><span class="s0">None</span>
    <span class="s1">step: str | int</span>
    <span class="s0">if </span><span class="s1">isinstance(spec.index_spec</span><span class="s0">, </span><span class="s1">DatetimeIndexSpec):</span>
        <span class="s1">start = pd.Timestamp(spec.index_spec.start)</span>
        <span class="s1">step = spec.index_spec.freq</span>
        <span class="s1">partition_freq = spec.index_spec.partition_freq</span>
        <span class="s1">end = pd.Timestamp(spec.index_spec.start) + spec.nrecords * pd.Timedelta(step)</span>
        <span class="s1">divisions = list(pd.date_range(start=start</span><span class="s0">, </span><span class="s1">end=end</span><span class="s0">, </span><span class="s1">freq=partition_freq))</span>
        <span class="s0">if </span><span class="s1">divisions[-</span><span class="s3">1</span><span class="s1">] &lt; end:</span>
            <span class="s1">divisions.append(end)</span>
        <span class="s1">meta_start</span><span class="s0">, </span><span class="s1">meta_end = start</span><span class="s0">, </span><span class="s1">start + pd.Timedelta(step)</span>
    <span class="s0">elif </span><span class="s1">isinstance(spec.index_spec</span><span class="s0">, </span><span class="s1">RangeIndexSpec):</span>
        <span class="s1">step = spec.index_spec.step</span>
        <span class="s1">partition_freq = spec.nrecords * step // spec.npartitions</span>
        <span class="s1">end = spec.nrecords * step - </span><span class="s3">1</span>
        <span class="s1">divisions = list(pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">stop=end</span><span class="s0">, </span><span class="s1">step=partition_freq))</span>
        <span class="s0">if </span><span class="s1">divisions[-</span><span class="s3">1</span><span class="s1">] &lt; (end + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">divisions.append(end + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">meta_start</span><span class="s0">, </span><span class="s1">meta_end = </span><span class="s3">0</span><span class="s0">, </span><span class="s1">step</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Unhandled index: </span><span class="s0">{</span><span class="s1">spec.index_spec</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s1">kwargs: dict[str</span><span class="s0">, </span><span class="s1">Any] = {</span><span class="s2">&quot;freq&quot;</span><span class="s1">: step}</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">spec.column_specs:</span>
        <span class="s0">if </span><span class="s1">col.prefix:</span>
            <span class="s1">prefix = col.prefix</span>
        <span class="s0">elif </span><span class="s1">isinstance(col.dtype</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">prefix = re.sub(</span><span class="s2">r&quot;[^a-zA-Z0-9]&quot;</span><span class="s0">, </span><span class="s2">&quot;_&quot;</span><span class="s0">, </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">col.dtype</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">).rstrip(</span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">hasattr(col.dtype</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s1">prefix = col.dtype.name  </span><span class="s5"># type: ignore[union-attr]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">prefix = col.dtype.__name__  </span><span class="s5"># type: ignore[union-attr]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(col.number):</span>
            <span class="s1">col_n = i + </span><span class="s3">1</span>
            <span class="s0">while </span><span class="s1">(col_name := </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">prefix</span><span class="s0">}{</span><span class="s1">col_n</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">) </span><span class="s0">in </span><span class="s1">dtypes:</span>
                <span class="s1">col_n = col_n + </span><span class="s3">1</span>
            <span class="s1">columns.append(col_name)</span>
            <span class="s1">dtypes[col_name] = col.dtype</span>
            <span class="s1">kwargs.update(</span>
                <span class="s1">{</span>
                    <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">col_name</span><span class="s0">}</span><span class="s2">_</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">: v</span>
                    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">asdict(col).items()</span>
                    <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">{</span><span class="s2">&quot;prefix&quot;</span><span class="s0">, </span><span class="s2">&quot;number&quot;</span><span class="s0">, </span><span class="s2">&quot;kwargs&quot;</span><span class="s1">} </span><span class="s0">and </span><span class="s1">v </span><span class="s0">not in </span><span class="s1">(</span><span class="s0">None, </span><span class="s1">[])</span>
                <span class="s1">}</span>
            <span class="s1">)</span>
            <span class="s5"># set untyped kwargs, if any</span>
            <span class="s0">for </span><span class="s1">kw_name</span><span class="s0">, </span><span class="s1">kw_val </span><span class="s0">in </span><span class="s1">col.kwargs.items():</span>
                <span class="s1">kwargs[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">col_name</span><span class="s0">}</span><span class="s2">_</span><span class="s0">{</span><span class="s1">kw_name</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">] = kw_val</span>

    <span class="s1">npartitions = len(divisions) - </span><span class="s3">1</span>
    <span class="s0">if </span><span class="s1">seed </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">state_data = cast(list[Any]</span><span class="s0">, </span><span class="s1">np.random.randint(int(</span><span class="s3">2e9</span><span class="s1">)</span><span class="s0">, </span><span class="s1">size=npartitions))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">state_data = random_state_data(npartitions</span><span class="s0">, </span><span class="s1">seed)</span>

    <span class="s1">parts = [(divisions[i : i + </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">state_data[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(npartitions)]</span>

    <span class="s0">return </span><span class="s1">from_map(</span>
        <span class="s1">MakeDataframePart(spec.index_spec.dtype</span><span class="s0">, </span><span class="s1">dtypes</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">columns=columns)</span><span class="s0">,</span>
        <span class="s1">parts</span><span class="s0">,</span>
        <span class="s1">meta=make_dataframe_part(</span>
            <span class="s1">spec.index_spec.dtype</span><span class="s0">,</span>
            <span class="s1">meta_start</span><span class="s0">,</span>
            <span class="s1">meta_end</span><span class="s0">,</span>
            <span class="s1">dtypes</span><span class="s0">,</span>
            <span class="s1">columns</span><span class="s0">,</span>
            <span class="s1">state_data[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">kwargs</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">divisions=divisions</span><span class="s0">,</span>
        <span class="s1">label=</span><span class="s2">&quot;make-random&quot;</span><span class="s0">,</span>
        <span class="s1">token=tokenize(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">spec.nrecords</span><span class="s0">, </span><span class="s1">dtypes</span><span class="s0">, </span><span class="s1">step</span><span class="s0">, </span><span class="s1">partition_freq</span><span class="s0">, </span><span class="s1">state_data)</span><span class="s0">,</span>
        <span class="s1">enforce_metadata=</span><span class="s0">False,</span>
    <span class="s1">)</span>
</pre>
</body>
</html>