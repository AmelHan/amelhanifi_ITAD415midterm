<html>
<head>
<title>_mio4.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mio4.py</font>
</center></td></tr></table>
<pre><span class="s0">''' Classes for read / write of matlab (TM) 4 files 
'''</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">scipy.sparse</span>

<span class="s2">from </span><span class="s1">._miobase </span><span class="s2">import </span><span class="s1">(MatFileReader</span><span class="s2">, </span><span class="s1">docfiller</span><span class="s2">, </span><span class="s1">matdims</span><span class="s2">, </span><span class="s1">read_dtype</span><span class="s2">,</span>
                      <span class="s1">convert_dtypes</span><span class="s2">, </span><span class="s1">arr_to_chars</span><span class="s2">, </span><span class="s1">arr_dtype_number)</span>

<span class="s2">from </span><span class="s1">._mio_utils </span><span class="s2">import </span><span class="s1">squeeze_element</span><span class="s2">, </span><span class="s1">chars_to_strings</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>


<span class="s1">__all__ = [</span>
    <span class="s3">'MatFile4Reader'</span><span class="s2">, </span><span class="s3">'MatFile4Writer'</span><span class="s2">, </span><span class="s3">'SYS_LITTLE_ENDIAN'</span><span class="s2">,</span>
    <span class="s3">'VarHeader4'</span><span class="s2">, </span><span class="s3">'VarReader4'</span><span class="s2">, </span><span class="s3">'VarWriter4'</span><span class="s2">, </span><span class="s3">'arr_to_2d'</span><span class="s2">, </span><span class="s3">'mclass_info'</span><span class="s2">,</span>
    <span class="s3">'mdtypes_template'</span><span class="s2">, </span><span class="s3">'miDOUBLE'</span><span class="s2">, </span><span class="s3">'miINT16'</span><span class="s2">, </span><span class="s3">'miINT32'</span><span class="s2">, </span><span class="s3">'miSINGLE'</span><span class="s2">,</span>
    <span class="s3">'miUINT16'</span><span class="s2">, </span><span class="s3">'miUINT8'</span><span class="s2">, </span><span class="s3">'mxCHAR_CLASS'</span><span class="s2">, </span><span class="s3">'mxFULL_CLASS'</span><span class="s2">, </span><span class="s3">'mxSPARSE_CLASS'</span><span class="s2">,</span>
    <span class="s3">'np_to_mtypes'</span><span class="s2">, </span><span class="s3">'order_codes'</span>
<span class="s1">]</span>


<span class="s1">SYS_LITTLE_ENDIAN = sys.byteorder == </span><span class="s3">'little'</span>

<span class="s1">miDOUBLE = </span><span class="s4">0</span>
<span class="s1">miSINGLE = </span><span class="s4">1</span>
<span class="s1">miINT32 = </span><span class="s4">2</span>
<span class="s1">miINT16 = </span><span class="s4">3</span>
<span class="s1">miUINT16 = </span><span class="s4">4</span>
<span class="s1">miUINT8 = </span><span class="s4">5</span>

<span class="s1">mdtypes_template = {</span>
    <span class="s1">miDOUBLE: </span><span class="s3">'f8'</span><span class="s2">,</span>
    <span class="s1">miSINGLE: </span><span class="s3">'f4'</span><span class="s2">,</span>
    <span class="s1">miINT32: </span><span class="s3">'i4'</span><span class="s2">,</span>
    <span class="s1">miINT16: </span><span class="s3">'i2'</span><span class="s2">,</span>
    <span class="s1">miUINT16: </span><span class="s3">'u2'</span><span class="s2">,</span>
    <span class="s1">miUINT8: </span><span class="s3">'u1'</span><span class="s2">,</span>
    <span class="s3">'header'</span><span class="s1">: [(</span><span class="s3">'mopt'</span><span class="s2">, </span><span class="s3">'i4'</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">(</span><span class="s3">'mrows'</span><span class="s2">, </span><span class="s3">'i4'</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">(</span><span class="s3">'ncols'</span><span class="s2">, </span><span class="s3">'i4'</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">(</span><span class="s3">'imagf'</span><span class="s2">, </span><span class="s3">'i4'</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">(</span><span class="s3">'namlen'</span><span class="s2">, </span><span class="s3">'i4'</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s3">'U1'</span><span class="s1">: </span><span class="s3">'U1'</span><span class="s2">,</span>
    <span class="s1">}</span>

<span class="s1">np_to_mtypes = {</span>
    <span class="s3">'f8'</span><span class="s1">: miDOUBLE</span><span class="s2">,</span>
    <span class="s3">'c32'</span><span class="s1">: miDOUBLE</span><span class="s2">,</span>
    <span class="s3">'c24'</span><span class="s1">: miDOUBLE</span><span class="s2">,</span>
    <span class="s3">'c16'</span><span class="s1">: miDOUBLE</span><span class="s2">,</span>
    <span class="s3">'f4'</span><span class="s1">: miSINGLE</span><span class="s2">,</span>
    <span class="s3">'c8'</span><span class="s1">: miSINGLE</span><span class="s2">,</span>
    <span class="s3">'i4'</span><span class="s1">: miINT32</span><span class="s2">,</span>
    <span class="s3">'i2'</span><span class="s1">: miINT16</span><span class="s2">,</span>
    <span class="s3">'u2'</span><span class="s1">: miUINT16</span><span class="s2">,</span>
    <span class="s3">'u1'</span><span class="s1">: miUINT8</span><span class="s2">,</span>
    <span class="s3">'S1'</span><span class="s1">: miUINT8</span><span class="s2">,</span>
    <span class="s1">}</span>

<span class="s5"># matrix classes</span>
<span class="s1">mxFULL_CLASS = </span><span class="s4">0</span>
<span class="s1">mxCHAR_CLASS = </span><span class="s4">1</span>
<span class="s1">mxSPARSE_CLASS = </span><span class="s4">2</span>

<span class="s1">order_codes = {</span>
    <span class="s4">0</span><span class="s1">: </span><span class="s3">'&lt;'</span><span class="s2">,</span>
    <span class="s4">1</span><span class="s1">: </span><span class="s3">'&gt;'</span><span class="s2">,</span>
    <span class="s4">2</span><span class="s1">: </span><span class="s3">'VAX D-float'</span><span class="s2">,  </span><span class="s5"># !</span>
    <span class="s4">3</span><span class="s1">: </span><span class="s3">'VAX G-float'</span><span class="s2">,</span>
    <span class="s4">4</span><span class="s1">: </span><span class="s3">'Cray'</span><span class="s2">,  </span><span class="s5"># !!</span>
    <span class="s1">}</span>

<span class="s1">mclass_info = {</span>
    <span class="s1">mxFULL_CLASS: </span><span class="s3">'double'</span><span class="s2">,</span>
    <span class="s1">mxCHAR_CLASS: </span><span class="s3">'char'</span><span class="s2">,</span>
    <span class="s1">mxSPARSE_CLASS: </span><span class="s3">'sparse'</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">class </span><span class="s1">VarHeader4:</span>
    <span class="s5"># Mat4 variables never logical or global</span>
    <span class="s1">is_logical = </span><span class="s2">False</span>
    <span class="s1">is_global = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">name</span><span class="s2">,</span>
                 <span class="s1">dtype</span><span class="s2">,</span>
                 <span class="s1">mclass</span><span class="s2">,</span>
                 <span class="s1">dims</span><span class="s2">,</span>
                 <span class="s1">is_complex):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.dtype = dtype</span>
        <span class="s1">self.mclass = mclass</span>
        <span class="s1">self.dims = dims</span>
        <span class="s1">self.is_complex = is_complex</span>


<span class="s2">class </span><span class="s1">VarReader4:</span>
    <span class="s0">''' Class to read matlab 4 variables '''</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file_reader):</span>
        <span class="s1">self.file_reader = file_reader</span>
        <span class="s1">self.mat_stream = file_reader.mat_stream</span>
        <span class="s1">self.dtypes = file_reader.dtypes</span>
        <span class="s1">self.chars_as_strings = file_reader.chars_as_strings</span>
        <span class="s1">self.squeeze_me = file_reader.squeeze_me</span>

    <span class="s2">def </span><span class="s1">read_header(self):</span>
        <span class="s0">''' Read and return header for variable '''</span>
        <span class="s1">data = read_dtype(self.mat_stream</span><span class="s2">, </span><span class="s1">self.dtypes[</span><span class="s3">'header'</span><span class="s1">])</span>
        <span class="s1">name = self.mat_stream.read(int(data[</span><span class="s3">'namlen'</span><span class="s1">])).strip(</span><span class="s6">b'</span><span class="s2">\x00</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">data[</span><span class="s3">'mopt'</span><span class="s1">] &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">data[</span><span class="s3">'mopt'</span><span class="s1">] &gt; </span><span class="s4">5000</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Mat 4 mopt wrong format, byteswapping problem?'</span><span class="s1">)</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">rest = divmod(data[</span><span class="s3">'mopt'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">)  </span><span class="s5"># order code</span>
        <span class="s2">if </span><span class="s1">M </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;We do not support byte ordering '%s'; returned &quot;</span>
                          <span class="s3">&quot;data may be corrupt&quot; </span><span class="s1">% order_codes[M]</span><span class="s2">,</span>
                          <span class="s1">UserWarning)</span>
        <span class="s1">O</span><span class="s2">, </span><span class="s1">rest = divmod(rest</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)  </span><span class="s5"># unused, should be 0</span>
        <span class="s2">if </span><span class="s1">O != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'O in MOPT integer should be 0, wrong format?'</span><span class="s1">)</span>
        <span class="s1">P</span><span class="s2">, </span><span class="s1">rest = divmod(rest</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)  </span><span class="s5"># data type code e.g miDOUBLE (see above)</span>
        <span class="s1">T = rest  </span><span class="s5"># matrix type code e.g., mxFULL_CLASS (see above)</span>
        <span class="s1">dims = (data[</span><span class="s3">'mrows'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s3">'ncols'</span><span class="s1">])</span>
        <span class="s1">is_complex = data[</span><span class="s3">'imagf'</span><span class="s1">] == </span><span class="s4">1</span>
        <span class="s1">dtype = self.dtypes[P]</span>
        <span class="s2">return </span><span class="s1">VarHeader4(</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">T</span><span class="s2">,</span>
            <span class="s1">dims</span><span class="s2">,</span>
            <span class="s1">is_complex)</span>

    <span class="s2">def </span><span class="s1">array_from_header(self</span><span class="s2">, </span><span class="s1">hdr</span><span class="s2">, </span><span class="s1">process=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">mclass = hdr.mclass</span>
        <span class="s2">if </span><span class="s1">mclass == mxFULL_CLASS:</span>
            <span class="s1">arr = self.read_full_array(hdr)</span>
        <span class="s2">elif </span><span class="s1">mclass == mxCHAR_CLASS:</span>
            <span class="s1">arr = self.read_char_array(hdr)</span>
            <span class="s2">if </span><span class="s1">process </span><span class="s2">and </span><span class="s1">self.chars_as_strings:</span>
                <span class="s1">arr = chars_to_strings(arr)</span>
        <span class="s2">elif </span><span class="s1">mclass == mxSPARSE_CLASS:</span>
            <span class="s5"># no current processing (below) makes sense for sparse</span>
            <span class="s2">return </span><span class="s1">self.read_sparse_array(hdr)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'No reader for class code %s' </span><span class="s1">% mclass)</span>
        <span class="s2">if </span><span class="s1">process </span><span class="s2">and </span><span class="s1">self.squeeze_me:</span>
            <span class="s2">return </span><span class="s1">squeeze_element(arr)</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s2">def </span><span class="s1">read_sub_array(self</span><span class="s2">, </span><span class="s1">hdr</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">''' Mat4 read using header `hdr` dtype and dims 
 
        Parameters 
        ---------- 
        hdr : object 
           object with attributes ``dtype``, ``dims``. dtype is assumed to be 
           the correct endianness 
        copy : bool, optional 
           copies array before return if True (default True) 
           (buffer is usually read only) 
 
        Returns 
        ------- 
        arr : ndarray 
            of dtype given by `hdr` ``dtype`` and shape given by `hdr` ``dims`` 
        '''</span>
        <span class="s1">dt = hdr.dtype</span>
        <span class="s1">dims = hdr.dims</span>
        <span class="s1">num_bytes = dt.itemsize</span>
        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dims:</span>
            <span class="s1">num_bytes *= d</span>
        <span class="s1">buffer = self.mat_stream.read(int(num_bytes))</span>
        <span class="s2">if </span><span class="s1">len(buffer) != num_bytes:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Not enough bytes to read matrix '%s'; is this &quot;</span>
                             <span class="s3">&quot;a badly-formed file? Consider listing matrices &quot;</span>
                             <span class="s3">&quot;with `whosmat` and loading named matrices with &quot;</span>
                             <span class="s3">&quot;`variable_names` kwarg to `loadmat`&quot; </span><span class="s1">% hdr.name)</span>
        <span class="s1">arr = np.ndarray(shape=dims</span><span class="s2">,</span>
                         <span class="s1">dtype=dt</span><span class="s2">,</span>
                         <span class="s1">buffer=buffer</span><span class="s2">,</span>
                         <span class="s1">order=</span><span class="s3">'F'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">copy:</span>
            <span class="s1">arr = arr.copy()</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s2">def </span><span class="s1">read_full_array(self</span><span class="s2">, </span><span class="s1">hdr):</span>
        <span class="s0">''' Full (rather than sparse) matrix getter 
 
        Read matrix (array) can be real or complex 
 
        Parameters 
        ---------- 
        hdr : ``VarHeader4`` instance 
 
        Returns 
        ------- 
        arr : ndarray 
            complex array if ``hdr.is_complex`` is True, otherwise a real 
            numeric array 
        '''</span>
        <span class="s2">if </span><span class="s1">hdr.is_complex:</span>
            <span class="s5"># avoid array copy to save memory</span>
            <span class="s1">res = self.read_sub_array(hdr</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">res_j = self.read_sub_array(hdr</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">res + (res_j * </span><span class="s4">1j</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.read_sub_array(hdr)</span>

    <span class="s2">def </span><span class="s1">read_char_array(self</span><span class="s2">, </span><span class="s1">hdr):</span>
        <span class="s0">''' latin-1 text matrix (char matrix) reader 
 
        Parameters 
        ---------- 
        hdr : ``VarHeader4`` instance 
 
        Returns 
        ------- 
        arr : ndarray 
            with dtype 'U1', shape given by `hdr` ``dims`` 
        '''</span>
        <span class="s1">arr = self.read_sub_array(hdr).astype(np.uint8)</span>
        <span class="s1">S = arr.tobytes().decode(</span><span class="s3">'latin-1'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">np.ndarray(shape=hdr.dims</span><span class="s2">,</span>
                          <span class="s1">dtype=np.dtype(</span><span class="s3">'U1'</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">buffer=np.array(S)).copy()</span>

    <span class="s2">def </span><span class="s1">read_sparse_array(self</span><span class="s2">, </span><span class="s1">hdr):</span>
        <span class="s0">''' Read and return sparse matrix type 
 
        Parameters 
        ---------- 
        hdr : ``VarHeader4`` instance 
 
        Returns 
        ------- 
        arr : ``scipy.sparse.coo_matrix`` 
            with dtype ``float`` and shape read from the sparse matrix data 
 
        Notes 
        ----- 
        MATLAB 4 real sparse arrays are saved in a N+1 by 3 array format, where 
        N is the number of non-zero values. Column 1 values [0:N] are the 
        (1-based) row indices of the each non-zero value, column 2 [0:N] are the 
        column indices, column 3 [0:N] are the (real) values. The last values 
        [-1,0:2] of the rows, column indices are shape[0] and shape[1] 
        respectively of the output matrix. The last value for the values column 
        is a padding 0. mrows and ncols values from the header give the shape of 
        the stored matrix, here [N+1, 3]. Complex data are saved as a 4 column 
        matrix, where the fourth column contains the imaginary component; the 
        last value is again 0. Complex sparse data do *not* have the header 
        ``imagf`` field set to True; the fact that the data are complex is only 
        detectable because there are 4 storage columns. 
        '''</span>
        <span class="s1">res = self.read_sub_array(hdr)</span>
        <span class="s1">tmp = res[:-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">:]</span>
        <span class="s5"># All numbers are float64 in Matlab, but SciPy sparse expects int shape</span>
        <span class="s1">dims = (int(res[-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">int(res[-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s1">I = np.ascontiguousarray(tmp[:</span><span class="s2">,</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span><span class="s1">dtype=</span><span class="s3">'intc'</span><span class="s1">)  </span><span class="s5"># fixes byte order also</span>
        <span class="s1">J = np.ascontiguousarray(tmp[:</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span><span class="s1">dtype=</span><span class="s3">'intc'</span><span class="s1">)</span>
        <span class="s1">I -= </span><span class="s4">1  </span><span class="s5"># for 1-based indexing</span>
        <span class="s1">J -= </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">res.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s1">V = np.ascontiguousarray(tmp[:</span><span class="s2">,</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span><span class="s1">dtype=</span><span class="s3">'float'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">V = np.ascontiguousarray(tmp[:</span><span class="s2">,</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span><span class="s1">dtype=</span><span class="s3">'complex'</span><span class="s1">)</span>
            <span class="s1">V.imag = tmp[:</span><span class="s2">,</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">scipy.sparse.coo_matrix((V</span><span class="s2">,</span><span class="s1">(I</span><span class="s2">,</span><span class="s1">J))</span><span class="s2">, </span><span class="s1">dims)</span>

    <span class="s2">def </span><span class="s1">shape_from_header(self</span><span class="s2">, </span><span class="s1">hdr):</span>
        <span class="s0">'''Read the shape of the array described by the header. 
        The file position after this call is unspecified. 
        '''</span>
        <span class="s1">mclass = hdr.mclass</span>
        <span class="s2">if </span><span class="s1">mclass == mxFULL_CLASS:</span>
            <span class="s1">shape = tuple(map(int</span><span class="s2">, </span><span class="s1">hdr.dims))</span>
        <span class="s2">elif </span><span class="s1">mclass == mxCHAR_CLASS:</span>
            <span class="s1">shape = tuple(map(int</span><span class="s2">, </span><span class="s1">hdr.dims))</span>
            <span class="s2">if </span><span class="s1">self.chars_as_strings:</span>
                <span class="s1">shape = shape[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">mclass == mxSPARSE_CLASS:</span>
            <span class="s1">dt = hdr.dtype</span>
            <span class="s1">dims = hdr.dims</span>

            <span class="s2">if not </span><span class="s1">(len(dims) == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">dims[</span><span class="s4">0</span><span class="s1">] &gt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">dims[</span><span class="s4">1</span><span class="s1">] &gt;= </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">()</span>

            <span class="s5"># Read only the row and column counts</span>
            <span class="s1">self.mat_stream.seek(dt.itemsize * (dims[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">rows = np.ndarray(shape=()</span><span class="s2">, </span><span class="s1">dtype=dt</span><span class="s2">,</span>
                              <span class="s1">buffer=self.mat_stream.read(dt.itemsize))</span>
            <span class="s1">self.mat_stream.seek(dt.itemsize * (dims[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">cols = np.ndarray(shape=()</span><span class="s2">, </span><span class="s1">dtype=dt</span><span class="s2">,</span>
                              <span class="s1">buffer=self.mat_stream.read(dt.itemsize))</span>

            <span class="s1">shape = (int(rows)</span><span class="s2">, </span><span class="s1">int(cols))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'No reader for class code %s' </span><span class="s1">% mclass)</span>

        <span class="s2">if </span><span class="s1">self.squeeze_me:</span>
            <span class="s1">shape = tuple([x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">shape </span><span class="s2">if </span><span class="s1">x != </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">shape</span>


<span class="s2">class </span><span class="s1">MatFile4Reader(MatFileReader):</span>
    <span class="s0">''' Reader for Mat4 files '''</span>
    <span class="s1">@docfiller</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">mat_stream</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">''' Initialize matlab 4 file reader 
 
    %(matstream_arg)s 
    %(load_args)s 
        '''</span>
        <span class="s1">super().__init__(mat_stream</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._matrix_reader = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">guess_byte_order(self):</span>
        <span class="s1">self.mat_stream.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">mopt = read_dtype(self.mat_stream</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s3">'i4'</span><span class="s1">))</span>
        <span class="s1">self.mat_stream.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">mopt == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">'&lt;'</span>
        <span class="s2">if </span><span class="s1">mopt &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">mopt &gt; </span><span class="s4">5000</span><span class="s1">:</span>
            <span class="s5"># Number must have been byteswapped</span>
            <span class="s2">return </span><span class="s1">SYS_LITTLE_ENDIAN </span><span class="s2">and </span><span class="s3">'&gt;' </span><span class="s2">or </span><span class="s3">'&lt;'</span>
        <span class="s5"># Not byteswapped</span>
        <span class="s2">return </span><span class="s1">SYS_LITTLE_ENDIAN </span><span class="s2">and </span><span class="s3">'&lt;' </span><span class="s2">or </span><span class="s3">'&gt;'</span>

    <span class="s2">def </span><span class="s1">initialize_read(self):</span>
        <span class="s0">''' Run when beginning read of variables 
 
        Sets up readers from parameters in `self` 
        '''</span>
        <span class="s1">self.dtypes = convert_dtypes(mdtypes_template</span><span class="s2">, </span><span class="s1">self.byte_order)</span>
        <span class="s1">self._matrix_reader = VarReader4(self)</span>

    <span class="s2">def </span><span class="s1">read_var_header(self):</span>
        <span class="s0">''' Read and return header, next position 
 
        Parameters 
        ---------- 
        None 
 
        Returns 
        ------- 
        header : object 
           object that can be passed to self.read_var_array, and that 
           has attributes ``name`` and ``is_global`` 
        next_position : int 
           position in stream of next variable 
        '''</span>
        <span class="s1">hdr = self._matrix_reader.read_header()</span>
        <span class="s1">n = reduce(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: x*y</span><span class="s2">, </span><span class="s1">hdr.dims</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># fast product</span>
        <span class="s1">remaining_bytes = hdr.dtype.itemsize * n</span>
        <span class="s2">if </span><span class="s1">hdr.is_complex </span><span class="s2">and not </span><span class="s1">hdr.mclass == mxSPARSE_CLASS:</span>
            <span class="s1">remaining_bytes *= </span><span class="s4">2</span>
        <span class="s1">next_position = self.mat_stream.tell() + remaining_bytes</span>
        <span class="s2">return </span><span class="s1">hdr</span><span class="s2">, </span><span class="s1">next_position</span>

    <span class="s2">def </span><span class="s1">read_var_array(self</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">process=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">''' Read array, given `header` 
 
        Parameters 
        ---------- 
        header : header object 
           object with fields defining variable header 
        process : {True, False}, optional 
           If True, apply recursive post-processing during loading of array. 
 
        Returns 
        ------- 
        arr : array 
           array with post-processing applied or not according to 
           `process`. 
        '''</span>
        <span class="s2">return </span><span class="s1">self._matrix_reader.array_from_header(header</span><span class="s2">, </span><span class="s1">process)</span>

    <span class="s2">def </span><span class="s1">get_variables(self</span><span class="s2">, </span><span class="s1">variable_names=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">''' get variables from stream as dictionary 
 
        Parameters 
        ---------- 
        variable_names : None or str or sequence of str, optional 
            variable name, or sequence of variable names to get from Mat file / 
            file stream. If None, then get all variables in file. 
        '''</span>
        <span class="s2">if </span><span class="s1">isinstance(variable_names</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">variable_names = [variable_names]</span>
        <span class="s2">elif </span><span class="s1">variable_names </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">variable_names = list(variable_names)</span>
        <span class="s1">self.mat_stream.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s5"># set up variable reader</span>
        <span class="s1">self.initialize_read()</span>
        <span class="s1">mdict = {}</span>
        <span class="s2">while not </span><span class="s1">self.end_of_stream():</span>
            <span class="s1">hdr</span><span class="s2">, </span><span class="s1">next_position = self.read_var_header()</span>
            <span class="s1">name = </span><span class="s3">'None' </span><span class="s2">if </span><span class="s1">hdr.name </span><span class="s2">is None else </span><span class="s1">hdr.name.decode(</span><span class="s3">'latin1'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">variable_names </span><span class="s2">is not None and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">variable_names:</span>
                <span class="s1">self.mat_stream.seek(next_position)</span>
                <span class="s2">continue</span>
            <span class="s1">mdict[name] = self.read_var_array(hdr)</span>
            <span class="s1">self.mat_stream.seek(next_position)</span>
            <span class="s2">if </span><span class="s1">variable_names </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">variable_names.remove(name)</span>
                <span class="s2">if </span><span class="s1">len(variable_names) == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">mdict</span>

    <span class="s2">def </span><span class="s1">list_variables(self):</span>
        <span class="s0">''' list variables from stream '''</span>
        <span class="s1">self.mat_stream.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s5"># set up variable reader</span>
        <span class="s1">self.initialize_read()</span>
        <span class="s1">vars = []</span>
        <span class="s2">while not </span><span class="s1">self.end_of_stream():</span>
            <span class="s1">hdr</span><span class="s2">, </span><span class="s1">next_position = self.read_var_header()</span>
            <span class="s1">name = </span><span class="s3">'None' </span><span class="s2">if </span><span class="s1">hdr.name </span><span class="s2">is None else </span><span class="s1">hdr.name.decode(</span><span class="s3">'latin1'</span><span class="s1">)</span>
            <span class="s1">shape = self._matrix_reader.shape_from_header(hdr)</span>
            <span class="s1">info = mclass_info.get(hdr.mclass</span><span class="s2">, </span><span class="s3">'unknown'</span><span class="s1">)</span>
            <span class="s1">vars.append((name</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">info))</span>

            <span class="s1">self.mat_stream.seek(next_position)</span>
        <span class="s2">return </span><span class="s1">vars</span>


<span class="s2">def </span><span class="s1">arr_to_2d(arr</span><span class="s2">, </span><span class="s1">oned_as=</span><span class="s3">'row'</span><span class="s1">):</span>
    <span class="s0">''' Make ``arr`` exactly two dimensional 
 
    If `arr` has more than 2 dimensions, raise a ValueError 
 
    Parameters 
    ---------- 
    arr : array 
    oned_as : {'row', 'column'}, optional 
       Whether to reshape 1-D vectors as row vectors or column vectors. 
       See documentation for ``matdims`` for more detail 
 
    Returns 
    ------- 
    arr2d : array 
       2-D version of the array 
    '''</span>
    <span class="s1">dims = matdims(arr</span><span class="s2">, </span><span class="s1">oned_as)</span>
    <span class="s2">if </span><span class="s1">len(dims) &gt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Matlab 4 files cannot save arrays with more than '</span>
                         <span class="s3">'2 dimensions'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">arr.reshape(dims)</span>


<span class="s2">class </span><span class="s1">VarWriter4:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file_writer):</span>
        <span class="s1">self.file_stream = file_writer.file_stream</span>
        <span class="s1">self.oned_as = file_writer.oned_as</span>

    <span class="s2">def </span><span class="s1">write_bytes(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s1">self.file_stream.write(arr.tobytes(order=</span><span class="s3">'F'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">write_string(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s1">self.file_stream.write(s)</span>

    <span class="s2">def </span><span class="s1">write_header(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">P=miDOUBLE</span><span class="s2">, </span><span class="s1">T=mxFULL_CLASS</span><span class="s2">, </span><span class="s1">imagf=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">''' Write header for given data options 
 
        Parameters 
        ---------- 
        name : str 
            name of variable 
        shape : sequence 
            Shape of array as it will be read in matlab 
        P : int, optional 
            code for mat4 data type, one of ``miDOUBLE, miSINGLE, miINT32, 
            miINT16, miUINT16, miUINT8`` 
        T : int, optional 
            code for mat4 matrix class, one of ``mxFULL_CLASS, mxCHAR_CLASS, 
            mxSPARSE_CLASS`` 
        imagf : int, optional 
            flag indicating complex 
        '''</span>
        <span class="s1">header = np.empty(()</span><span class="s2">, </span><span class="s1">mdtypes_template[</span><span class="s3">'header'</span><span class="s1">])</span>
        <span class="s1">M = </span><span class="s2">not </span><span class="s1">SYS_LITTLE_ENDIAN</span>
        <span class="s1">O = </span><span class="s4">0</span>
        <span class="s1">header[</span><span class="s3">'mopt'</span><span class="s1">] = (M * </span><span class="s4">1000 </span><span class="s1">+</span>
                          <span class="s1">O * </span><span class="s4">100 </span><span class="s1">+</span>
                          <span class="s1">P * </span><span class="s4">10 </span><span class="s1">+</span>
                          <span class="s1">T)</span>
        <span class="s1">header[</span><span class="s3">'mrows'</span><span class="s1">] = shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">header[</span><span class="s3">'ncols'</span><span class="s1">] = shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">header[</span><span class="s3">'imagf'</span><span class="s1">] = imagf</span>
        <span class="s1">header[</span><span class="s3">'namlen'</span><span class="s1">] = len(name) + </span><span class="s4">1</span>
        <span class="s1">self.write_bytes(header)</span>
        <span class="s1">data = name + </span><span class="s3">'</span><span class="s2">\0</span><span class="s3">'</span>
        <span class="s1">self.write_string(data.encode(</span><span class="s3">'latin1'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">''' Write matrix `arr`, with name `name` 
 
        Parameters 
        ---------- 
        arr : array_like 
           array to write 
        name : str 
           name in matlab workspace 
        '''</span>
        <span class="s5"># we need to catch sparse first, because np.asarray returns an</span>
        <span class="s5"># an object array for scipy.sparse</span>
        <span class="s2">if </span><span class="s1">scipy.sparse.issparse(arr):</span>
            <span class="s1">self.write_sparse(arr</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s2">return</span>
        <span class="s1">arr = np.asarray(arr)</span>
        <span class="s1">dt = arr.dtype</span>
        <span class="s2">if not </span><span class="s1">dt.isnative:</span>
            <span class="s1">arr = arr.astype(dt.newbyteorder(</span><span class="s3">'='</span><span class="s1">))</span>
        <span class="s1">dtt = dt.type</span>
        <span class="s2">if </span><span class="s1">dtt </span><span class="s2">is </span><span class="s1">np.object_:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Cannot save object arrays in Mat4'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">dtt </span><span class="s2">is </span><span class="s1">np.void:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Cannot save void type arrays'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">dtt </span><span class="s2">in </span><span class="s1">(np.unicode_</span><span class="s2">, </span><span class="s1">np.string_):</span>
            <span class="s1">self.write_char(arr</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s2">return</span>
        <span class="s1">self.write_numeric(arr</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">write_numeric(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">arr = arr_to_2d(arr</span><span class="s2">, </span><span class="s1">self.oned_as)</span>
        <span class="s1">imagf = arr.dtype.kind == </span><span class="s3">'c'</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">P = np_to_mtypes[arr.dtype.str[</span><span class="s4">1</span><span class="s1">:]]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">if </span><span class="s1">imagf:</span>
                <span class="s1">arr = arr.astype(</span><span class="s3">'c128'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">arr = arr.astype(</span><span class="s3">'f8'</span><span class="s1">)</span>
            <span class="s1">P = miDOUBLE</span>
        <span class="s1">self.write_header(name</span><span class="s2">,</span>
                          <span class="s1">arr.shape</span><span class="s2">,</span>
                          <span class="s1">P=P</span><span class="s2">,</span>
                          <span class="s1">T=mxFULL_CLASS</span><span class="s2">,</span>
                          <span class="s1">imagf=imagf)</span>
        <span class="s2">if </span><span class="s1">imagf:</span>
            <span class="s1">self.write_bytes(arr.real)</span>
            <span class="s1">self.write_bytes(arr.imag)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.write_bytes(arr)</span>

    <span class="s2">def </span><span class="s1">write_char(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">arr = arr_to_chars(arr)</span>
        <span class="s1">arr = arr_to_2d(arr</span><span class="s2">, </span><span class="s1">self.oned_as)</span>
        <span class="s1">dims = arr.shape</span>
        <span class="s1">self.write_header(</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">dims</span><span class="s2">,</span>
            <span class="s1">P=miUINT8</span><span class="s2">,</span>
            <span class="s1">T=mxCHAR_CLASS)</span>
        <span class="s2">if </span><span class="s1">arr.dtype.kind == </span><span class="s3">'U'</span><span class="s1">:</span>
            <span class="s5"># Recode unicode to latin1</span>
            <span class="s1">n_chars = np.prod(dims)</span>
            <span class="s1">st_arr = np.ndarray(shape=()</span><span class="s2">,</span>
                                <span class="s1">dtype=arr_dtype_number(arr</span><span class="s2">, </span><span class="s1">n_chars)</span><span class="s2">,</span>
                                <span class="s1">buffer=arr)</span>
            <span class="s1">st = st_arr.item().encode(</span><span class="s3">'latin-1'</span><span class="s1">)</span>
            <span class="s1">arr = np.ndarray(shape=dims</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'S1'</span><span class="s2">, </span><span class="s1">buffer=st)</span>
        <span class="s1">self.write_bytes(arr)</span>

    <span class="s2">def </span><span class="s1">write_sparse(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">''' Sparse matrices are 2-D 
 
        See docstring for VarReader4.read_sparse_array 
        '''</span>
        <span class="s1">A = arr.tocoo()  </span><span class="s5"># convert to sparse COO format (ijv)</span>
        <span class="s1">imagf = A.dtype.kind == </span><span class="s3">'c'</span>
        <span class="s1">ijv = np.zeros((A.nnz + </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">+imagf)</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'f8'</span><span class="s1">)</span>
        <span class="s1">ijv[:-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">0</span><span class="s1">] = A.row</span>
        <span class="s1">ijv[:-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">] = A.col</span>
        <span class="s1">ijv[:-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">0</span><span class="s1">:</span><span class="s4">2</span><span class="s1">] += </span><span class="s4">1  </span><span class="s5"># 1 based indexing</span>
        <span class="s2">if </span><span class="s1">imagf:</span>
            <span class="s1">ijv[:-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s1">] = A.data.real</span>
            <span class="s1">ijv[:-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">3</span><span class="s1">] = A.data.imag</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ijv[:-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s1">] = A.data</span>
        <span class="s1">ijv[-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">0</span><span class="s1">:</span><span class="s4">2</span><span class="s1">] = A.shape</span>
        <span class="s1">self.write_header(</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">ijv.shape</span><span class="s2">,</span>
            <span class="s1">P=miDOUBLE</span><span class="s2">,</span>
            <span class="s1">T=mxSPARSE_CLASS)</span>
        <span class="s1">self.write_bytes(ijv)</span>


<span class="s2">class </span><span class="s1">MatFile4Writer:</span>
    <span class="s0">''' Class for writing matlab 4 format files '''</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file_stream</span><span class="s2">, </span><span class="s1">oned_as=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.file_stream = file_stream</span>
        <span class="s2">if </span><span class="s1">oned_as </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">oned_as = </span><span class="s3">'row'</span>
        <span class="s1">self.oned_as = oned_as</span>
        <span class="s1">self._matrix_writer = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">put_variables(self</span><span class="s2">, </span><span class="s1">mdict</span><span class="s2">, </span><span class="s1">write_header=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">''' Write variables in `mdict` to stream 
 
        Parameters 
        ---------- 
        mdict : mapping 
           mapping with method ``items`` return name, contents pairs 
           where ``name`` which will appeak in the matlab workspace in 
           file load, and ``contents`` is something writeable to a 
           matlab file, such as a NumPy array. 
        write_header : {None, True, False} 
           If True, then write the matlab file header before writing the 
           variables. If None (the default) then write the file header 
           if we are at position 0 in the stream. By setting False 
           here, and setting the stream position to the end of the file, 
           you can append variables to a matlab file 
        '''</span>
        <span class="s5"># there is no header for a matlab 4 mat file, so we ignore the</span>
        <span class="s5"># ``write_header`` input argument. It's there for compatibility</span>
        <span class="s5"># with the matlab 5 version of this method</span>
        <span class="s1">self._matrix_writer = VarWriter4(self)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">var </span><span class="s2">in </span><span class="s1">mdict.items():</span>
            <span class="s1">self._matrix_writer.write(var</span><span class="s2">, </span><span class="s1">name)</span>
</pre>
</body>
</html>