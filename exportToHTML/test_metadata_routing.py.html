<html>
<head>
<title>test_metadata_routing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_metadata_routing.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Metadata Routing Utility Tests 
&quot;&quot;&quot;</span>

<span class="s2"># Author: Adrin Jalali &lt;adrin.jalali@gmail.com&gt;</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">re</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">pytest</span>

<span class="s3">from </span><span class="s1">sklearn </span><span class="s3">import </span><span class="s1">config_context</span>
<span class="s3">from </span><span class="s1">sklearn.base </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">BaseEstimator</span><span class="s3">,</span>
    <span class="s1">ClassifierMixin</span><span class="s3">,</span>
    <span class="s1">MetaEstimatorMixin</span><span class="s3">,</span>
    <span class="s1">RegressorMixin</span><span class="s3">,</span>
    <span class="s1">TransformerMixin</span><span class="s3">,</span>
    <span class="s1">clone</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">sklearn.linear_model </span><span class="s3">import </span><span class="s1">LinearRegression</span>
<span class="s3">from </span><span class="s1">sklearn.utils </span><span class="s3">import </span><span class="s1">metadata_routing</span>
<span class="s3">from </span><span class="s1">sklearn.utils._metadata_requests </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">METHODS</span><span class="s3">,</span>
    <span class="s1">MethodMetadataRequest</span><span class="s3">,</span>
    <span class="s1">_MetadataRequester</span><span class="s3">,</span>
    <span class="s1">request_is_alias</span><span class="s3">,</span>
    <span class="s1">request_is_valid</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">sklearn.utils.metadata_routing </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">MetadataRequest</span><span class="s3">,</span>
    <span class="s1">MetadataRouter</span><span class="s3">,</span>
    <span class="s1">MethodMapping</span><span class="s3">,</span>
    <span class="s1">get_routing_for_object</span><span class="s3">,</span>
    <span class="s1">process_routing</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">sklearn.utils.validation </span><span class="s3">import </span><span class="s1">check_is_fitted</span>

<span class="s1">rng = np.random.RandomState(</span><span class="s4">42</span><span class="s1">)</span>
<span class="s1">N</span><span class="s3">, </span><span class="s1">M = </span><span class="s4">100</span><span class="s3">, </span><span class="s4">4</span>
<span class="s1">X = rng.rand(N</span><span class="s3">, </span><span class="s1">M)</span>
<span class="s1">y = rng.randint(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">size=N)</span>
<span class="s1">my_groups = rng.randint(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">size=N)</span>
<span class="s1">my_weights = rng.rand(N)</span>
<span class="s1">my_other_weights = rng.rand(N)</span>


<span class="s1">@pytest.fixture(autouse=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">enable_slep006():</span>
    <span class="s0">&quot;&quot;&quot;Enable SLEP006 for all tests.&quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">config_context(enable_metadata_routing=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">yield</span>


<span class="s3">def </span><span class="s1">assert_request_is_empty(metadata_request</span><span class="s3">, </span><span class="s1">exclude=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Check if a metadata request dict is empty. 
 
    One can exclude a method or a list of methods from the check using the 
    ``exclude`` parameter. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(metadata_request</span><span class="s3">, </span><span class="s1">MetadataRouter):</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">route_mapping </span><span class="s3">in </span><span class="s1">metadata_request:</span>
            <span class="s1">assert_request_is_empty(route_mapping.router)</span>
        <span class="s3">return</span>

    <span class="s1">exclude = [] </span><span class="s3">if </span><span class="s1">exclude </span><span class="s3">is None else </span><span class="s1">exclude</span>
    <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">METHODS:</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">exclude:</span>
            <span class="s3">continue</span>
        <span class="s1">mmr = getattr(metadata_request</span><span class="s3">, </span><span class="s1">method)</span>
        <span class="s1">props = [</span>
            <span class="s1">prop</span>
            <span class="s3">for </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">alias </span><span class="s3">in </span><span class="s1">mmr.requests.items()</span>
            <span class="s3">if </span><span class="s1">isinstance(alias</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">or </span><span class="s1">alias </span><span class="s3">is not None</span>
        <span class="s1">]</span>
        <span class="s3">assert not </span><span class="s1">len(props)</span>


<span class="s3">def </span><span class="s1">assert_request_equal(request</span><span class="s3">, </span><span class="s1">dictionary):</span>
    <span class="s3">for </span><span class="s1">method</span><span class="s3">, </span><span class="s1">requests </span><span class="s3">in </span><span class="s1">dictionary.items():</span>
        <span class="s1">mmr = getattr(request</span><span class="s3">, </span><span class="s1">method)</span>
        <span class="s3">assert </span><span class="s1">mmr.requests == requests</span>

    <span class="s1">empty_methods = [method </span><span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">METHODS </span><span class="s3">if </span><span class="s1">method </span><span class="s3">not in </span><span class="s1">dictionary]</span>
    <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">empty_methods:</span>
        <span class="s3">assert not </span><span class="s1">len(getattr(request</span><span class="s3">, </span><span class="s1">method).requests)</span>


<span class="s3">def </span><span class="s1">record_metadata(obj</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">record_default=</span><span class="s3">True, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Utility function to store passed metadata to a method. 
 
    If record_default is False, kwargs whose values are &quot;default&quot; are skipped. 
    This is so that checks on keyword arguments whose default was not changed 
    are skipped. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">hasattr(obj</span><span class="s3">, </span><span class="s5">&quot;_records&quot;</span><span class="s1">):</span>
        <span class="s1">obj._records = {}</span>
    <span class="s3">if not </span><span class="s1">record_default:</span>
        <span class="s1">kwargs = {</span>
            <span class="s1">key: val</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">kwargs.items()</span>
            <span class="s3">if not </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">or </span><span class="s1">(val != </span><span class="s5">&quot;default&quot;</span><span class="s1">)</span>
        <span class="s1">}</span>
    <span class="s1">obj._records[method] = kwargs</span>


<span class="s3">def </span><span class="s1">check_recorded_metadata(obj</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Check whether the expected metadata is passed to the object's method.&quot;&quot;&quot;</span>
    <span class="s1">records = getattr(obj</span><span class="s3">, </span><span class="s5">&quot;_records&quot;</span><span class="s3">, </span><span class="s1">dict()).get(method</span><span class="s3">, </span><span class="s1">dict())</span>
    <span class="s3">assert </span><span class="s1">set(kwargs.keys()) == set(records.keys())</span>
    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">kwargs.items():</span>
        <span class="s3">assert </span><span class="s1">records[key] </span><span class="s3">is </span><span class="s1">value</span>


<span class="s3">class </span><span class="s1">MetaRegressor(MetaEstimatorMixin</span><span class="s3">, </span><span class="s1">RegressorMixin</span><span class="s3">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;A meta-regressor which is only a router.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">estimator):</span>
        <span class="s1">self.estimator = estimator</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**fit_params):</span>
        <span class="s1">params = process_routing(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">fit_params)</span>
        <span class="s1">self.estimator_ = clone(self.estimator).fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**params.estimator.fit)</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing(self):</span>
        <span class="s1">router = MetadataRouter(owner=self.__class__.__name__).add(</span>
            <span class="s1">estimator=self.estimator</span><span class="s3">, </span><span class="s1">method_mapping=</span><span class="s5">&quot;one-to-one&quot;</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">router</span>


<span class="s3">class </span><span class="s1">RegressorMetadata(RegressorMixin</span><span class="s3">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;A regressor consuming a metadata.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">record_metadata(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s3">return </span><span class="s1">np.zeros(shape=(len(X)))</span>


<span class="s3">class </span><span class="s1">WeightedMetaRegressor(MetaEstimatorMixin</span><span class="s3">, </span><span class="s1">RegressorMixin</span><span class="s3">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;A meta-regressor which is also a consumer.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">estimator):</span>
        <span class="s1">self.estimator = estimator</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">**fit_params):</span>
        <span class="s1">record_metadata(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>
        <span class="s1">params = process_routing(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">fit_params</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>
        <span class="s1">self.estimator_ = clone(self.estimator).fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**params.estimator.fit)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">**predict_params):</span>
        <span class="s1">params = process_routing(self</span><span class="s3">, </span><span class="s5">&quot;predict&quot;</span><span class="s3">, </span><span class="s1">predict_params)</span>
        <span class="s3">return </span><span class="s1">self.estimator_.predict(X</span><span class="s3">, </span><span class="s1">**params.estimator.predict)</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing(self):</span>
        <span class="s1">router = (</span>
            <span class="s1">MetadataRouter(owner=self.__class__.__name__)</span>
            <span class="s1">.add_self_request(self)</span>
            <span class="s1">.add(estimator=self.estimator</span><span class="s3">, </span><span class="s1">method_mapping=</span><span class="s5">&quot;one-to-one&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">router</span>


<span class="s3">class </span><span class="s1">ClassifierNoMetadata(ClassifierMixin</span><span class="s3">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;An estimator which accepts no metadata on any method.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s3">return </span><span class="s1">np.ones(len(X))  </span><span class="s2"># pragma: no cover</span>


<span class="s3">class </span><span class="s1">ClassifierFitMetadata(ClassifierMixin</span><span class="s3">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;An estimator accepting two metadata in its ``fit`` method.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">brand=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">record_metadata(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight</span><span class="s3">, </span><span class="s1">brand=brand)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s3">return </span><span class="s1">np.ones(len(X))  </span><span class="s2"># pragma: no cover</span>


<span class="s3">class </span><span class="s1">SimpleMetaClassifier(MetaEstimatorMixin</span><span class="s3">, </span><span class="s1">ClassifierMixin</span><span class="s3">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;A meta-estimator which also consumes sample_weight itself in ``fit``.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">estimator):</span>
        <span class="s1">self.estimator = estimator</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">record_metadata(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>
        <span class="s1">params = process_routing(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>
        <span class="s1">self.estimator_ = clone(self.estimator).fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**params.estimator.fit)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing(self):</span>
        <span class="s1">router = (</span>
            <span class="s1">MetadataRouter(owner=self.__class__.__name__)</span>
            <span class="s1">.add_self_request(self)</span>
            <span class="s1">.add(estimator=self.estimator</span><span class="s3">, </span><span class="s1">method_mapping=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">router</span>


<span class="s3">class </span><span class="s1">TransformerMetadata(TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;A transformer which accepts metadata on fit and transform.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">brand=</span><span class="s3">None, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">record_metadata(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">brand=brand</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">record_metadata(self</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>
        <span class="s3">return </span><span class="s1">X</span>


<span class="s3">class </span><span class="s1">MetaTransformer(MetaEstimatorMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;A simple meta-transformer.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">transformer):</span>
        <span class="s1">self.transformer = transformer</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">**fit_params):</span>
        <span class="s1">params = process_routing(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">fit_params)</span>
        <span class="s1">self.transformer_ = clone(self.transformer).fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**params.transformer.fit)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">**transform_params):</span>
        <span class="s1">params = process_routing(self</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">, </span><span class="s1">transform_params)</span>
        <span class="s3">return </span><span class="s1">self.transformer_.transform(X</span><span class="s3">, </span><span class="s1">**params.transformer.transform)</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing(self):</span>
        <span class="s3">return </span><span class="s1">MetadataRouter(owner=self.__class__.__name__).add(</span>
            <span class="s1">transformer=self.transformer</span><span class="s3">, </span><span class="s1">method_mapping=</span><span class="s5">&quot;one-to-one&quot;</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">SimplePipeline(BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;A very simple pipeline, assuming the last step is always a predictor.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">steps):</span>
        <span class="s1">self.steps = steps</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**fit_params):</span>
        <span class="s1">self.steps_ = []</span>
        <span class="s1">params = process_routing(self</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">fit_params)</span>
        <span class="s1">X_transformed = X</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">step </span><span class="s3">in </span><span class="s1">enumerate(self.steps[:-</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">transformer = clone(step).fit(</span>
                <span class="s1">X_transformed</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**params.get(</span><span class="s5">f&quot;step_</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s1">).fit</span>
            <span class="s1">)</span>
            <span class="s1">self.steps_.append(transformer)</span>
            <span class="s1">X_transformed = transformer.transform(</span>
                <span class="s1">X_transformed</span><span class="s3">, </span><span class="s1">**params.get(</span><span class="s5">f&quot;step_</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s1">).transform</span>
            <span class="s1">)</span>

        <span class="s1">self.steps_.append(</span>
            <span class="s1">clone(self.steps[-</span><span class="s4">1</span><span class="s1">]).fit(X_transformed</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**params.predictor.fit)</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">**predict_params):</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s1">X_transformed = X</span>
        <span class="s1">params = process_routing(self</span><span class="s3">, </span><span class="s5">&quot;predict&quot;</span><span class="s3">, </span><span class="s1">predict_params)</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">step </span><span class="s3">in </span><span class="s1">enumerate(self.steps_[:-</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">X_transformed = step.transform(X</span><span class="s3">, </span><span class="s1">**params.get(</span><span class="s5">f&quot;step_</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s1">).transform)</span>

        <span class="s3">return </span><span class="s1">self.steps_[-</span><span class="s4">1</span><span class="s1">].predict(X_transformed</span><span class="s3">, </span><span class="s1">**params.predictor.predict)</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing(self):</span>
        <span class="s1">router = MetadataRouter(owner=self.__class__.__name__)</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">step </span><span class="s3">in </span><span class="s1">enumerate(self.steps[:-</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">router.add(</span>
                <span class="s1">**{</span><span class="s5">f&quot;step_</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s1">: step}</span><span class="s3">,</span>
                <span class="s1">method_mapping=MethodMapping()</span>
                <span class="s1">.add(callee=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">caller=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>
                <span class="s1">.add(callee=</span><span class="s5">&quot;transform&quot;</span><span class="s3">, </span><span class="s1">caller=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>
                <span class="s1">.add(callee=</span><span class="s5">&quot;transform&quot;</span><span class="s3">, </span><span class="s1">caller=</span><span class="s5">&quot;predict&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s1">router.add(predictor=self.steps[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">method_mapping=</span><span class="s5">&quot;one-to-one&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">router</span>


<span class="s3">def </span><span class="s1">test_assert_request_is_empty():</span>
    <span class="s1">requests = MetadataRequest(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">)</span>
    <span class="s1">assert_request_is_empty(requests)</span>

    <span class="s1">requests.fit.add_request(param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s3">None</span><span class="s1">)</span>
    <span class="s2"># this should still work, since None is the default value</span>
    <span class="s1">assert_request_is_empty(requests)</span>

    <span class="s1">requests.fit.add_request(param=</span><span class="s5">&quot;bar&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s5">&quot;value&quot;</span><span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.raises(AssertionError):</span>
        <span class="s2"># now requests is no more empty</span>
        <span class="s1">assert_request_is_empty(requests)</span>

    <span class="s2"># but one can exclude a method</span>
    <span class="s1">assert_request_is_empty(requests</span><span class="s3">, </span><span class="s1">exclude=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>

    <span class="s1">requests.score.add_request(param=</span><span class="s5">&quot;carrot&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.raises(AssertionError):</span>
        <span class="s2"># excluding `fit` is not enough</span>
        <span class="s1">assert_request_is_empty(requests</span><span class="s3">, </span><span class="s1">exclude=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>

    <span class="s2"># and excluding both fit and score would avoid an exception</span>
    <span class="s1">assert_request_is_empty(requests</span><span class="s3">, </span><span class="s1">exclude=[</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s5">&quot;score&quot;</span><span class="s1">])</span>

    <span class="s2"># test if a router is empty</span>
    <span class="s1">assert_request_is_empty(</span>
        <span class="s1">MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">)</span>
        <span class="s1">.add_self_request(WeightedMetaRegressor(estimator=</span><span class="s3">None</span><span class="s1">))</span>
        <span class="s1">.add(method_mapping=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">estimator=RegressorMetadata())</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;val, res&quot;</span><span class="s3">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">False, False</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s3">True, False</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s3">None, False</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;$UNUSED$&quot;</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;$WARN$&quot;</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;invalid-input&quot;</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;valid_arg&quot;</span><span class="s3">, True</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">]</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">test_request_type_is_alias(val</span><span class="s3">, </span><span class="s1">res):</span>
    <span class="s2"># Test request_is_alias</span>
    <span class="s3">assert </span><span class="s1">request_is_alias(val) == res</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;val, res&quot;</span><span class="s3">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">False, True</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s3">True, True</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s3">None, True</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;$UNUSED$&quot;</span><span class="s3">, True</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;$WARN$&quot;</span><span class="s3">, True</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;invalid-input&quot;</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;alias_arg&quot;</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">]</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">test_request_type_is_valid(val</span><span class="s3">, </span><span class="s1">res):</span>
    <span class="s2"># Test request_is_valid</span>
    <span class="s3">assert </span><span class="s1">request_is_valid(val) == res</span>


<span class="s3">def </span><span class="s1">test_default_requests():</span>
    <span class="s3">class </span><span class="s1">OddEstimator(BaseEstimator):</span>
        <span class="s1">__metadata_request__fit = {</span>
            <span class="s2"># set a different default request</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">True</span>
        <span class="s1">}  </span><span class="s2"># type: ignore</span>

    <span class="s1">odd_request = get_routing_for_object(OddEstimator())</span>
    <span class="s3">assert </span><span class="s1">odd_request.fit.requests == {</span><span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>

    <span class="s2"># check other test estimators</span>
    <span class="s3">assert not </span><span class="s1">len(get_routing_for_object(ClassifierNoMetadata()).fit.requests)</span>
    <span class="s1">assert_request_is_empty(ClassifierNoMetadata().get_metadata_routing())</span>

    <span class="s1">trs_request = get_routing_for_object(TransformerMetadata())</span>
    <span class="s3">assert </span><span class="s1">trs_request.fit.requests == {</span>
        <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s5">&quot;brand&quot;</span><span class="s1">: </span><span class="s3">None,</span>
    <span class="s1">}</span>
    <span class="s3">assert </span><span class="s1">trs_request.transform.requests == {</span>
        <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
    <span class="s1">}</span>
    <span class="s1">assert_request_is_empty(trs_request)</span>

    <span class="s1">est_request = get_routing_for_object(ClassifierFitMetadata())</span>
    <span class="s3">assert </span><span class="s1">est_request.fit.requests == {</span>
        <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s5">&quot;brand&quot;</span><span class="s1">: </span><span class="s3">None,</span>
    <span class="s1">}</span>
    <span class="s1">assert_request_is_empty(est_request)</span>


<span class="s3">def </span><span class="s1">test_process_routing_invalid_method():</span>
    <span class="s3">with </span><span class="s1">pytest.raises(TypeError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;Can only route and process input&quot;</span><span class="s1">):</span>
        <span class="s1">process_routing(ClassifierFitMetadata()</span><span class="s3">, </span><span class="s5">&quot;invalid_method&quot;</span><span class="s3">, </span><span class="s1">{})</span>


<span class="s3">def </span><span class="s1">test_process_routing_invalid_object():</span>
    <span class="s3">class </span><span class="s1">InvalidObject:</span>
        <span class="s3">pass</span>

    <span class="s3">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;has not implemented the routing&quot;</span><span class="s1">):</span>
        <span class="s1">process_routing(InvalidObject()</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">{})</span>


<span class="s3">def </span><span class="s1">test_simple_metadata_routing():</span>
    <span class="s2"># Tests that metadata is properly routed</span>

    <span class="s2"># The underlying estimator doesn't accept or request metadata</span>
    <span class="s1">clf = SimpleMetaClassifier(estimator=ClassifierNoMetadata())</span>
    <span class="s1">clf.fit(X</span><span class="s3">, </span><span class="s1">y)</span>

    <span class="s2"># Meta-estimator consumes sample_weight, but doesn't forward it to the underlying</span>
    <span class="s2"># estimator</span>
    <span class="s1">clf = SimpleMetaClassifier(estimator=ClassifierNoMetadata())</span>
    <span class="s1">clf.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=my_weights)</span>

    <span class="s2"># If the estimator accepts the metadata but doesn't explicitly say it doesn't</span>
    <span class="s2"># need it, there's an error</span>
    <span class="s1">clf = SimpleMetaClassifier(estimator=ClassifierFitMetadata())</span>
    <span class="s1">err_message = (</span>
        <span class="s5">&quot;[sample_weight] are passed but are not explicitly set as requested or&quot;</span>
        <span class="s5">&quot; not for ClassifierFitMetadata.fit&quot;</span>
    <span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=re.escape(err_message)):</span>
        <span class="s1">clf.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=my_weights)</span>

    <span class="s2"># Explicitly saying the estimator doesn't need it, makes the error go away,</span>
    <span class="s2"># because in this case `SimpleMetaClassifier` consumes `sample_weight`. If</span>
    <span class="s2"># there was no consumer of sample_weight, passing it would result in an</span>
    <span class="s2"># error.</span>
    <span class="s1">clf = SimpleMetaClassifier(</span>
        <span class="s1">estimator=ClassifierFitMetadata().set_fit_request(sample_weight=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s2"># this doesn't raise since SimpleMetaClassifier itself is a consumer,</span>
    <span class="s2"># and passing metadata to the consumer directly is fine regardless of its</span>
    <span class="s2"># metadata_request values.</span>
    <span class="s1">clf.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=my_weights)</span>
    <span class="s1">check_recorded_metadata(clf.estimator_</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">brand=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s2"># Requesting a metadata will make the meta-estimator forward it correctly</span>
    <span class="s1">clf = SimpleMetaClassifier(</span>
        <span class="s1">estimator=ClassifierFitMetadata().set_fit_request(sample_weight=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">clf.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=my_weights)</span>
    <span class="s1">check_recorded_metadata(clf.estimator_</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=my_weights</span><span class="s3">, </span><span class="s1">brand=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s2"># And requesting it with an alias</span>
    <span class="s1">clf = SimpleMetaClassifier(</span>
        <span class="s1">estimator=ClassifierFitMetadata().set_fit_request(</span>
            <span class="s1">sample_weight=</span><span class="s5">&quot;alternative_weight&quot;</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">clf.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">alternative_weight=my_weights)</span>
    <span class="s1">check_recorded_metadata(clf.estimator_</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=my_weights</span><span class="s3">, </span><span class="s1">brand=</span><span class="s3">None</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_nested_routing():</span>
    <span class="s2"># check if metadata is routed in a nested routing situation.</span>
    <span class="s1">pipeline = SimplePipeline(</span>
        <span class="s1">[</span>
            <span class="s1">MetaTransformer(</span>
                <span class="s1">transformer=TransformerMetadata()</span>
                <span class="s1">.set_fit_request(brand=</span><span class="s3">True, </span><span class="s1">sample_weight=</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s1">.set_transform_request(sample_weight=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">WeightedMetaRegressor(</span>
                <span class="s1">estimator=RegressorMetadata().set_fit_request(</span>
                    <span class="s1">sample_weight=</span><span class="s5">&quot;inner_weights&quot;</span>
                <span class="s1">)</span>
            <span class="s1">).set_fit_request(sample_weight=</span><span class="s5">&quot;outer_weights&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">w1</span><span class="s3">, </span><span class="s1">w2</span><span class="s3">, </span><span class="s1">w3 = [</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">3</span><span class="s1">]</span>
    <span class="s1">pipeline.fit(</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">brand=my_groups</span><span class="s3">, </span><span class="s1">sample_weight=w1</span><span class="s3">, </span><span class="s1">outer_weights=w2</span><span class="s3">, </span><span class="s1">inner_weights=w3</span>
    <span class="s1">)</span>
    <span class="s1">check_recorded_metadata(</span>
        <span class="s1">pipeline.steps_[</span><span class="s4">0</span><span class="s1">].transformer_</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">brand=my_groups</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span>
    <span class="s1">)</span>
    <span class="s1">check_recorded_metadata(</span>
        <span class="s1">pipeline.steps_[</span><span class="s4">0</span><span class="s1">].transformer_</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">, </span><span class="s1">sample_weight=w1</span>
    <span class="s1">)</span>
    <span class="s1">check_recorded_metadata(pipeline.steps_[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=w2)</span>
    <span class="s1">check_recorded_metadata(pipeline.steps_[</span><span class="s4">1</span><span class="s1">].estimator_</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">sample_weight=w3)</span>

    <span class="s1">pipeline.predict(X</span><span class="s3">, </span><span class="s1">sample_weight=w3)</span>
    <span class="s1">check_recorded_metadata(</span>
        <span class="s1">pipeline.steps_[</span><span class="s4">0</span><span class="s1">].transformer_</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">, </span><span class="s1">sample_weight=w3</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_nested_routing_conflict():</span>
    <span class="s2"># check if an error is raised if there's a conflict between keys</span>
    <span class="s1">pipeline = SimplePipeline(</span>
        <span class="s1">[</span>
            <span class="s1">MetaTransformer(</span>
                <span class="s1">transformer=TransformerMetadata()</span>
                <span class="s1">.set_fit_request(brand=</span><span class="s3">True, </span><span class="s1">sample_weight=</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s1">.set_transform_request(sample_weight=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">WeightedMetaRegressor(</span>
                <span class="s1">estimator=RegressorMetadata().set_fit_request(sample_weight=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">).set_fit_request(sample_weight=</span><span class="s5">&quot;outer_weights&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">w1</span><span class="s3">, </span><span class="s1">w2 = [</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s3">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">match=(</span>
            <span class="s1">re.escape(</span>
                <span class="s5">&quot;In WeightedMetaRegressor, there is a conflict on sample_weight between&quot;</span>
                <span class="s5">&quot; what is requested for this estimator and what is requested by its&quot;</span>
                <span class="s5">&quot; children. You can resolve this conflict by using an alias for the&quot;</span>
                <span class="s5">&quot; child estimator(s) requested metadata.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">pipeline.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">brand=my_groups</span><span class="s3">, </span><span class="s1">sample_weight=w1</span><span class="s3">, </span><span class="s1">outer_weights=w2)</span>


<span class="s3">def </span><span class="s1">test_invalid_metadata():</span>
    <span class="s2"># check that passing wrong metadata raises an error</span>
    <span class="s1">trs = MetaTransformer(</span>
        <span class="s1">transformer=TransformerMetadata().set_transform_request(sample_weight=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">TypeError</span><span class="s3">,</span>
        <span class="s1">match=(re.escape(</span><span class="s5">&quot;transform got unexpected argument(s) {'other_param'}&quot;</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">trs.fit(X</span><span class="s3">, </span><span class="s1">y).transform(X</span><span class="s3">, </span><span class="s1">other_param=my_weights)</span>

    <span class="s2"># passing a metadata which is not requested by any estimator should also raise</span>
    <span class="s1">trs = MetaTransformer(</span>
        <span class="s1">transformer=TransformerMetadata().set_transform_request(sample_weight=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s3">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">TypeError</span><span class="s3">,</span>
        <span class="s1">match=(re.escape(</span><span class="s5">&quot;transform got unexpected argument(s) {'sample_weight'}&quot;</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">trs.fit(X</span><span class="s3">, </span><span class="s1">y).transform(X</span><span class="s3">, </span><span class="s1">sample_weight=my_weights)</span>


<span class="s3">def </span><span class="s1">test_get_metadata_routing():</span>
    <span class="s3">class </span><span class="s1">TestDefaultsBadMethodName(_MetadataRequester):</span>
        <span class="s1">__metadata_request__fit = {</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span>
        <span class="s1">__metadata_request__score = {</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True,</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span>
        <span class="s2"># this will raise an error since we don't understand &quot;other_method&quot; as a method</span>
        <span class="s1">__metadata_request__other_method = {</span><span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>

    <span class="s3">class </span><span class="s1">TestDefaults(_MetadataRequester):</span>
        <span class="s1">__metadata_request__fit = {</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span>
        <span class="s1">__metadata_request__score = {</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True,</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span>
        <span class="s1">__metadata_request__predict = {</span><span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>

    <span class="s3">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">AttributeError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;'MetadataRequest' object has no attribute 'other_method'&quot;</span>
    <span class="s1">):</span>
        <span class="s1">TestDefaultsBadMethodName().get_metadata_routing()</span>

    <span class="s1">expected = {</span>
        <span class="s5">&quot;score&quot;</span><span class="s1">: {</span>
            <span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True,</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s5">&quot;fit&quot;</span><span class="s1">: {</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s5">&quot;predict&quot;</span><span class="s1">: {</span><span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">assert_request_equal(TestDefaults().get_metadata_routing()</span><span class="s3">, </span><span class="s1">expected)</span>

    <span class="s1">est = TestDefaults().set_score_request(my_param=</span><span class="s5">&quot;other_param&quot;</span><span class="s1">)</span>
    <span class="s1">expected = {</span>
        <span class="s5">&quot;score&quot;</span><span class="s1">: {</span>
            <span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s5">&quot;other_param&quot;</span><span class="s3">,</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s5">&quot;fit&quot;</span><span class="s1">: {</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s5">&quot;predict&quot;</span><span class="s1">: {</span><span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">assert_request_equal(est.get_metadata_routing()</span><span class="s3">, </span><span class="s1">expected)</span>

    <span class="s1">est = TestDefaults().set_fit_request(sample_weight=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">expected = {</span>
        <span class="s5">&quot;score&quot;</span><span class="s1">: {</span>
            <span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True,</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">None,</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s5">&quot;fit&quot;</span><span class="s1">: {</span>
            <span class="s5">&quot;my_other_param&quot;</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s5">&quot;sample_weight&quot;</span><span class="s1">: </span><span class="s3">True,</span>
        <span class="s1">}</span><span class="s3">,</span>
        <span class="s5">&quot;predict&quot;</span><span class="s1">: {</span><span class="s5">&quot;my_param&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">assert_request_equal(est.get_metadata_routing()</span><span class="s3">, </span><span class="s1">expected)</span>


<span class="s3">def </span><span class="s1">test_setting_default_requests():</span>
    <span class="s2"># Test _get_default_requests method</span>
    <span class="s1">test_cases = dict()</span>

    <span class="s3">class </span><span class="s1">ExplicitRequest(BaseEstimator):</span>
        <span class="s2"># `fit` doesn't accept `props` explicitly, but we want to request it</span>
        <span class="s1">__metadata_request__fit = {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>

        <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">test_cases[ExplicitRequest] = {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>

    <span class="s3">class </span><span class="s1">ExplicitRequestOverwrite(BaseEstimator):</span>
        <span class="s2"># `fit` explicitly accepts `props`, but we want to change the default</span>
        <span class="s2"># request value from None to True</span>
        <span class="s1">__metadata_request__fit = {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>

        <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">prop=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">test_cases[ExplicitRequestOverwrite] = {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>

    <span class="s3">class </span><span class="s1">ImplicitRequest(BaseEstimator):</span>
        <span class="s2"># `fit` requests `prop` and the default None should be used</span>
        <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">prop=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">test_cases[ImplicitRequest] = {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>

    <span class="s3">class </span><span class="s1">ImplicitRequestRemoval(BaseEstimator):</span>
        <span class="s2"># `fit` (in this class or a parent) requests `prop`, but we don't want</span>
        <span class="s2"># it requested at all.</span>
        <span class="s1">__metadata_request__fit = {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: metadata_routing.UNUSED}</span>

        <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">prop=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">test_cases[ImplicitRequestRemoval] = {}</span>

    <span class="s3">for </span><span class="s1">Klass</span><span class="s3">, </span><span class="s1">requests </span><span class="s3">in </span><span class="s1">test_cases.items():</span>
        <span class="s3">assert </span><span class="s1">get_routing_for_object(Klass()).fit.requests == requests</span>
        <span class="s1">assert_request_is_empty(Klass().get_metadata_routing()</span><span class="s3">, </span><span class="s1">exclude=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>
        <span class="s1">Klass().fit(</span><span class="s3">None, None</span><span class="s1">)  </span><span class="s2"># for coverage</span>


<span class="s3">def </span><span class="s1">test_removing_non_existing_param_raises():</span>
    <span class="s0">&quot;&quot;&quot;Test that removing a metadata using UNUSED which doesn't exist raises.&quot;&quot;&quot;</span>

    <span class="s3">class </span><span class="s1">InvalidRequestRemoval(BaseEstimator):</span>
        <span class="s2"># `fit` (in this class or a parent) requests `prop`, but we don't want</span>
        <span class="s2"># it requested at all.</span>
        <span class="s1">__metadata_request__fit = {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: metadata_routing.UNUSED}</span>

        <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;Trying to remove parameter&quot;</span><span class="s1">):</span>
        <span class="s1">InvalidRequestRemoval().get_metadata_routing()</span>


<span class="s3">def </span><span class="s1">test_method_metadata_request():</span>
    <span class="s1">mmr = MethodMetadataRequest(owner=</span><span class="s5">&quot;test&quot;</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>

    <span class="s3">with </span><span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;The alias you're setting for&quot;</span><span class="s1">):</span>
        <span class="s1">mmr.add_request(param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s4">1.4</span><span class="s1">)</span>

    <span class="s1">mmr.add_request(param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s3">None</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">mmr.requests == {</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>
    <span class="s1">mmr.add_request(param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">mmr.requests == {</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>
    <span class="s1">mmr.add_request(param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">mmr.requests == {</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>
    <span class="s1">mmr.add_request(param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">mmr.requests == {</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>
    <span class="s1">mmr.add_request(param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s5">&quot;bar&quot;</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">mmr.requests == {</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s5">&quot;bar&quot;</span><span class="s1">}</span>
    <span class="s3">assert </span><span class="s1">mmr._get_param_names(return_alias=</span><span class="s3">False</span><span class="s1">) == {</span><span class="s5">&quot;foo&quot;</span><span class="s1">}</span>
    <span class="s3">assert </span><span class="s1">mmr._get_param_names(return_alias=</span><span class="s3">True</span><span class="s1">) == {</span><span class="s5">&quot;bar&quot;</span><span class="s1">}</span>


<span class="s3">def </span><span class="s1">test_get_routing_for_object():</span>
    <span class="s3">class </span><span class="s1">Consumer(BaseEstimator):</span>
        <span class="s1">__metadata_request__fit = {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>

    <span class="s1">assert_request_is_empty(get_routing_for_object(</span><span class="s3">None</span><span class="s1">))</span>
    <span class="s1">assert_request_is_empty(get_routing_for_object(object()))</span>

    <span class="s1">mr = MetadataRequest(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">)</span>
    <span class="s1">mr.fit.add_request(param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s5">&quot;bar&quot;</span><span class="s1">)</span>
    <span class="s1">mr_factory = get_routing_for_object(mr)</span>
    <span class="s1">assert_request_is_empty(mr_factory</span><span class="s3">, </span><span class="s1">exclude=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">mr_factory.fit.requests == {</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s5">&quot;bar&quot;</span><span class="s1">}</span>

    <span class="s1">mr = get_routing_for_object(Consumer())</span>
    <span class="s1">assert_request_is_empty(mr</span><span class="s3">, </span><span class="s1">exclude=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">mr.fit.requests == {</span><span class="s5">&quot;prop&quot;</span><span class="s1">: </span><span class="s3">None</span><span class="s1">}</span>


<span class="s3">def </span><span class="s1">test_metaestimator_warnings():</span>
    <span class="s3">class </span><span class="s1">WeightedMetaRegressorWarn(WeightedMetaRegressor):</span>
        <span class="s1">__metadata_request__fit = {</span><span class="s5">&quot;sample_weight&quot;</span><span class="s1">: metadata_routing.WARN}</span>

    <span class="s3">with </span><span class="s1">pytest.warns(</span>
        <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;Support for .* has recently been added to this class&quot;</span>
    <span class="s1">):</span>
        <span class="s1">WeightedMetaRegressorWarn(</span>
            <span class="s1">estimator=LinearRegression().set_fit_request(sample_weight=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">).fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=my_weights)</span>


<span class="s3">def </span><span class="s1">test_estimator_warnings():</span>
    <span class="s3">class </span><span class="s1">RegressorMetadataWarn(RegressorMetadata):</span>
        <span class="s1">__metadata_request__fit = {</span><span class="s5">&quot;sample_weight&quot;</span><span class="s1">: metadata_routing.WARN}</span>

    <span class="s3">with </span><span class="s1">pytest.warns(</span>
        <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;Support for .* has recently been added to this class&quot;</span>
    <span class="s1">):</span>
        <span class="s1">MetaRegressor(estimator=RegressorMetadataWarn()).fit(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=my_weights</span>
        <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;obj, string&quot;</span><span class="s3">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">MethodMetadataRequest(owner=</span><span class="s5">&quot;test&quot;</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">&quot;fit&quot;</span><span class="s1">).add_request(</span>
                <span class="s1">param=</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s5">&quot;bar&quot;</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;{'foo': 'bar'}&quot;</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span>
            <span class="s1">MetadataRequest(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;{}&quot;</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(MethodMapping.from_str(</span><span class="s5">&quot;score&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s5">&quot;[{'callee': 'score', 'caller': 'score'}]&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span>
            <span class="s1">MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">).add(</span>
                <span class="s1">method_mapping=</span><span class="s5">&quot;predict&quot;</span><span class="s3">, </span><span class="s1">estimator=RegressorMetadata()</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span>
                <span class="s5">&quot;{'estimator': {'mapping': [{'callee': 'predict', 'caller': &quot;</span>
                <span class="s5">&quot;'predict'}], 'router': {'fit': {'sample_weight': None}, &quot;</span>
                <span class="s5">&quot;'score': {'sample_weight': None}}}}&quot;</span>
            <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
    <span class="s1">]</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">test_string_representations(obj</span><span class="s3">, </span><span class="s1">string):</span>
    <span class="s3">assert </span><span class="s1">str(obj) == string</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;obj, method, inputs, err_cls, err_msg&quot;</span><span class="s3">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">MethodMapping()</span><span class="s3">,</span>
            <span class="s5">&quot;add&quot;</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;callee&quot;</span><span class="s1">: </span><span class="s5">&quot;invalid&quot;</span><span class="s3">, </span><span class="s5">&quot;caller&quot;</span><span class="s1">: </span><span class="s5">&quot;fit&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">ValueError</span><span class="s3">,</span>
            <span class="s5">&quot;Given callee&quot;</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span>
            <span class="s1">MethodMapping()</span><span class="s3">,</span>
            <span class="s5">&quot;add&quot;</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;callee&quot;</span><span class="s1">: </span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s5">&quot;caller&quot;</span><span class="s1">: </span><span class="s5">&quot;invalid&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">ValueError</span><span class="s3">,</span>
            <span class="s5">&quot;Given caller&quot;</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span>
            <span class="s1">MethodMapping</span><span class="s3">,</span>
            <span class="s5">&quot;from_str&quot;</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;route&quot;</span><span class="s1">: </span><span class="s5">&quot;invalid&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">ValueError</span><span class="s3">,</span>
            <span class="s5">&quot;route should be 'one-to-one' or a single method!&quot;</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span>
            <span class="s1">MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;add_self_request&quot;</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;obj&quot;</span><span class="s1">: MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">)}</span><span class="s3">,</span>
            <span class="s1">ValueError</span><span class="s3">,</span>
            <span class="s5">&quot;Given `obj` is neither a `MetadataRequest` nor does it implement&quot;</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span>
            <span class="s1">ClassifierFitMetadata()</span><span class="s3">,</span>
            <span class="s5">&quot;set_fit_request&quot;</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;invalid&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">TypeError</span><span class="s3">,</span>
            <span class="s5">&quot;Unexpected args&quot;</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
    <span class="s1">]</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">test_validations(obj</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">inputs</span><span class="s3">, </span><span class="s1">err_cls</span><span class="s3">, </span><span class="s1">err_msg):</span>
    <span class="s3">with </span><span class="s1">pytest.raises(err_cls</span><span class="s3">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">getattr(obj</span><span class="s3">, </span><span class="s1">method)(**inputs)</span>


<span class="s3">def </span><span class="s1">test_methodmapping():</span>
    <span class="s1">mm = (</span>
        <span class="s1">MethodMapping()</span>
        <span class="s1">.add(caller=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">callee=</span><span class="s5">&quot;transform&quot;</span><span class="s1">)</span>
        <span class="s1">.add(caller=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">callee=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s1">mm_list = list(mm)</span>
    <span class="s3">assert </span><span class="s1">mm_list[</span><span class="s4">0</span><span class="s1">] == (</span><span class="s5">&quot;transform&quot;</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">mm_list[</span><span class="s4">1</span><span class="s1">] == (</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span>

    <span class="s1">mm = MethodMapping.from_str(</span><span class="s5">&quot;one-to-one&quot;</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">(</span>
        <span class="s1">str(mm)</span>
        <span class="s1">== </span><span class="s5">&quot;[{'callee': 'fit', 'caller': 'fit'}, {'callee': 'partial_fit', 'caller':&quot;</span>
        <span class="s5">&quot; 'partial_fit'}, {'callee': 'predict', 'caller': 'predict'}, {'callee':&quot;</span>
        <span class="s5">&quot; 'predict_proba', 'caller': 'predict_proba'}, {'callee':&quot;</span>
        <span class="s5">&quot; 'predict_log_proba', 'caller': 'predict_log_proba'}, {'callee':&quot;</span>
        <span class="s5">&quot; 'decision_function', 'caller': 'decision_function'}, {'callee': 'score',&quot;</span>
        <span class="s5">&quot; 'caller': 'score'}, {'callee': 'split', 'caller': 'split'}, {'callee':&quot;</span>
        <span class="s5">&quot; 'transform', 'caller': 'transform'}, {'callee': 'inverse_transform',&quot;</span>
        <span class="s5">&quot; 'caller': 'inverse_transform'}]&quot;</span>
    <span class="s1">)</span>

    <span class="s1">mm = MethodMapping.from_str(</span><span class="s5">&quot;score&quot;</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">repr(mm) == </span><span class="s5">&quot;[{'callee': 'score', 'caller': 'score'}]&quot;</span>


<span class="s3">def </span><span class="s1">test_metadatarouter_add_self_request():</span>
    <span class="s2"># adding a MetadataRequest as `self` adds a copy</span>
    <span class="s1">request = MetadataRequest(owner=</span><span class="s5">&quot;nested&quot;</span><span class="s1">)</span>
    <span class="s1">request.fit.add_request(param=</span><span class="s5">&quot;param&quot;</span><span class="s3">, </span><span class="s1">alias=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">router = MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">).add_self_request(request)</span>
    <span class="s3">assert </span><span class="s1">str(router._self_request) == str(request)</span>
    <span class="s2"># should be a copy, not the same object</span>
    <span class="s3">assert </span><span class="s1">router._self_request </span><span class="s3">is not </span><span class="s1">request</span>

    <span class="s2"># one can add an estimator as self</span>
    <span class="s1">est = RegressorMetadata().set_fit_request(sample_weight=</span><span class="s5">&quot;my_weights&quot;</span><span class="s1">)</span>
    <span class="s1">router = MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">).add_self_request(obj=est)</span>
    <span class="s3">assert </span><span class="s1">str(router._self_request) == str(est.get_metadata_routing())</span>
    <span class="s3">assert </span><span class="s1">router._self_request </span><span class="s3">is not </span><span class="s1">est.get_metadata_routing()</span>

    <span class="s2"># adding a consumer+router as self should only add the consumer part</span>
    <span class="s1">est = WeightedMetaRegressor(</span>
        <span class="s1">estimator=RegressorMetadata().set_fit_request(sample_weight=</span><span class="s5">&quot;nested_weights&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">router = MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">).add_self_request(obj=est)</span>
    <span class="s2"># _get_metadata_request() returns the consumer part of the requests</span>
    <span class="s3">assert </span><span class="s1">str(router._self_request) == str(est._get_metadata_request())</span>
    <span class="s2"># get_metadata_routing() returns the complete request set, consumer and</span>
    <span class="s2"># router included.</span>
    <span class="s3">assert </span><span class="s1">str(router._self_request) != str(est.get_metadata_routing())</span>
    <span class="s2"># it should be a copy, not the same object</span>
    <span class="s3">assert </span><span class="s1">router._self_request </span><span class="s3">is not </span><span class="s1">est._get_metadata_request()</span>


<span class="s3">def </span><span class="s1">test_metadata_routing_add():</span>
    <span class="s2"># adding one with a string `method_mapping`</span>
    <span class="s1">router = MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">).add(</span>
        <span class="s1">method_mapping=</span><span class="s5">&quot;fit&quot;</span><span class="s3">,</span>
        <span class="s1">est=RegressorMetadata().set_fit_request(sample_weight=</span><span class="s5">&quot;weights&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">(</span>
        <span class="s1">str(router)</span>
        <span class="s1">== </span><span class="s5">&quot;{'est': {'mapping': [{'callee': 'fit', 'caller': 'fit'}], &quot;</span>
        <span class="s5">&quot;'router': {'fit': {'sample_weight': 'weights'}, 'score': &quot;</span>
        <span class="s5">&quot;{'sample_weight': None}}}}&quot;</span>
    <span class="s1">)</span>

    <span class="s2"># adding one with an instance of MethodMapping</span>
    <span class="s1">router = MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">).add(</span>
        <span class="s1">method_mapping=MethodMapping().add(callee=</span><span class="s5">&quot;score&quot;</span><span class="s3">, </span><span class="s1">caller=</span><span class="s5">&quot;fit&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">est=RegressorMetadata().set_score_request(sample_weight=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">(</span>
        <span class="s1">str(router)</span>
        <span class="s1">== </span><span class="s5">&quot;{'est': {'mapping': [{'callee': 'score', 'caller': 'fit'}], &quot;</span>
        <span class="s5">&quot;'router': {'fit': {'sample_weight': None}, 'score': &quot;</span>
        <span class="s5">&quot;{'sample_weight': True}}}}&quot;</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_metadata_routing_get_param_names():</span>
    <span class="s1">router = (</span>
        <span class="s1">MetadataRouter(owner=</span><span class="s5">&quot;test&quot;</span><span class="s1">)</span>
        <span class="s1">.add_self_request(</span>
            <span class="s1">WeightedMetaRegressor(estimator=RegressorMetadata()).set_fit_request(</span>
                <span class="s1">sample_weight=</span><span class="s5">&quot;self_weights&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">.add(</span>
            <span class="s1">method_mapping=</span><span class="s5">&quot;fit&quot;</span><span class="s3">,</span>
            <span class="s1">trs=TransformerMetadata().set_fit_request(</span>
                <span class="s1">sample_weight=</span><span class="s5">&quot;transform_weights&quot;</span>
            <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s3">assert </span><span class="s1">(</span>
        <span class="s1">str(router)</span>
        <span class="s1">== </span><span class="s5">&quot;{'$self_request': {'fit': {'sample_weight': 'self_weights'}, 'score': &quot;</span>
        <span class="s5">&quot;{'sample_weight': None}}, 'trs': {'mapping': [{'callee': 'fit', &quot;</span>
        <span class="s5">&quot;'caller': 'fit'}], 'router': {'fit': {'brand': None, &quot;</span>
        <span class="s5">&quot;'sample_weight': 'transform_weights'}, 'transform': &quot;</span>
        <span class="s5">&quot;{'sample_weight': None}}}}&quot;</span>
    <span class="s1">)</span>

    <span class="s3">assert </span><span class="s1">router._get_param_names(</span>
        <span class="s1">method=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">return_alias=</span><span class="s3">True, </span><span class="s1">ignore_self_request=</span><span class="s3">False</span>
    <span class="s1">) == {</span><span class="s5">&quot;transform_weights&quot;</span><span class="s3">, </span><span class="s5">&quot;brand&quot;</span><span class="s3">, </span><span class="s5">&quot;self_weights&quot;</span><span class="s1">}</span>
    <span class="s2"># return_alias=False will return original names for &quot;self&quot;</span>
    <span class="s3">assert </span><span class="s1">router._get_param_names(</span>
        <span class="s1">method=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">return_alias=</span><span class="s3">False, </span><span class="s1">ignore_self_request=</span><span class="s3">False</span>
    <span class="s1">) == {</span><span class="s5">&quot;sample_weight&quot;</span><span class="s3">, </span><span class="s5">&quot;brand&quot;</span><span class="s3">, </span><span class="s5">&quot;transform_weights&quot;</span><span class="s1">}</span>
    <span class="s2"># ignoring self would remove &quot;sample_weight&quot;</span>
    <span class="s3">assert </span><span class="s1">router._get_param_names(</span>
        <span class="s1">method=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">return_alias=</span><span class="s3">False, </span><span class="s1">ignore_self_request=</span><span class="s3">True</span>
    <span class="s1">) == {</span><span class="s5">&quot;brand&quot;</span><span class="s3">, </span><span class="s5">&quot;transform_weights&quot;</span><span class="s1">}</span>
    <span class="s2"># return_alias is ignored when ignore_self_request=True</span>
    <span class="s3">assert </span><span class="s1">router._get_param_names(</span>
        <span class="s1">method=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">return_alias=</span><span class="s3">True, </span><span class="s1">ignore_self_request=</span><span class="s3">True</span>
    <span class="s1">) == router._get_param_names(</span>
        <span class="s1">method=</span><span class="s5">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">return_alias=</span><span class="s3">False, </span><span class="s1">ignore_self_request=</span><span class="s3">True</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_method_generation():</span>
    <span class="s2"># Test if all required request methods are generated.</span>

    <span class="s2"># TODO: these test classes can be moved to sklearn.utils._testing once we</span>
    <span class="s2"># have a better idea of what the commonly used classes are.</span>
    <span class="s3">class </span><span class="s1">SimpleEstimator(BaseEstimator):</span>
        <span class="s2"># This class should have no set_{method}_request</span>
        <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">partial_fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">predict_proba(self</span><span class="s3">, </span><span class="s1">X):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">predict_log_proba(self</span><span class="s3">, </span><span class="s1">X):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">decision_function(self</span><span class="s3">, </span><span class="s1">X):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">score(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">X):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">inverse_transform(self</span><span class="s3">, </span><span class="s1">X):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

    <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">METHODS:</span>
        <span class="s3">assert not </span><span class="s1">hasattr(SimpleEstimator()</span><span class="s3">, </span><span class="s5">f&quot;set_</span><span class="s3">{</span><span class="s1">method</span><span class="s3">}</span><span class="s5">_request&quot;</span><span class="s1">)</span>

    <span class="s3">class </span><span class="s1">SimpleEstimator(BaseEstimator):</span>
        <span class="s2"># This class should have every set_{method}_request</span>
        <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">partial_fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">predict_proba(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">predict_log_proba(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">decision_function(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">score(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

        <span class="s3">def </span><span class="s1">inverse_transform(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">pass  </span><span class="s2"># pragma: no cover</span>

    <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">METHODS:</span>
        <span class="s3">assert </span><span class="s1">hasattr(SimpleEstimator()</span><span class="s3">, </span><span class="s5">f&quot;set_</span><span class="s3">{</span><span class="s1">method</span><span class="s3">}</span><span class="s5">_request&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_no_feature_flag_raises_error():</span>
    <span class="s0">&quot;&quot;&quot;Test that when feature flag disabled, set_{method}_requests raises.&quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">config_context(enable_metadata_routing=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s3">, </span><span class="s1">match=</span><span class="s5">&quot;This method is only available&quot;</span><span class="s1">):</span>
            <span class="s1">ClassifierFitMetadata().set_fit_request(sample_weight=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_none_metadata_passed():</span>
    <span class="s0">&quot;&quot;&quot;Test that passing None as metadata when not requested doesn't raise&quot;&quot;&quot;</span>
    <span class="s1">MetaRegressor(estimator=RegressorMetadata()).fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">)</span>
</pre>
</body>
</html>