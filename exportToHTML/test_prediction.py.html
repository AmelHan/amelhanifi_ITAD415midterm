<html>
<head>
<title>test_prediction.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_prediction.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for prediction of state space models 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_raises</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_</span>

<span class="s2">from </span><span class="s1">statsmodels </span><span class="s2">import </span><span class="s1">datasets</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">sarimax</span><span class="s2">, </span><span class="s1">varmax</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.tests.test_impulse_responses </span><span class="s2">import </span><span class="s1">TVSS</span>


<span class="s1">dta = datasets.macrodata.load_pandas().data</span>
<span class="s1">dta.index = pd.period_range(start=</span><span class="s3">'1959Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_predict_dates():</span>
    <span class="s1">index = pd.date_range(start=</span><span class="s3">'1950-01-01'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">11</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'D'</span><span class="s1">)</span>
    <span class="s1">np.random.seed(</span><span class="s4">324328</span><span class="s1">)</span>
    <span class="s1">endog = pd.Series(np.random.normal(size=</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=index[:-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Basic test</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">res = mod.filter(mod.start_params)</span>

    <span class="s5"># In-sample prediction should have the same index</span>
    <span class="s1">pred = res.predict()</span>
    <span class="s1">assert_equal(len(pred)</span><span class="s2">, </span><span class="s1">mod.nobs)</span>
    <span class="s1">assert_equal(pred.index.values</span><span class="s2">, </span><span class="s1">index[:-</span><span class="s4">1</span><span class="s1">].values)</span>
    <span class="s5"># Out-of-sample forecasting should extend the index appropriately</span>
    <span class="s1">fcast = res.forecast()</span>
    <span class="s1">assert_equal(fcast.index[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index[-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Simple differencing in the SARIMAX model should eliminate dates of</span>
    <span class="s5"># series eliminated due to differencing</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.filter(mod.start_params)</span>
    <span class="s1">pred = res.predict()</span>
    <span class="s5"># In-sample prediction should lose the first index value</span>
    <span class="s1">assert_equal(mod.nobs</span><span class="s2">, </span><span class="s1">endog.shape[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(len(pred)</span><span class="s2">, </span><span class="s1">mod.nobs)</span>
    <span class="s1">assert_equal(pred.index.values</span><span class="s2">, </span><span class="s1">index[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">].values)</span>
    <span class="s5"># Out-of-sample forecasting should still extend the index appropriately</span>
    <span class="s1">fcast = res.forecast()</span>
    <span class="s1">assert_equal(fcast.index[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index[-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Simple differencing again, this time with a more complex differencing</span>
    <span class="s5"># structure</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.filter(mod.start_params)</span>
    <span class="s1">pred = res.predict()</span>
    <span class="s5"># In-sample prediction should lose the first 6 index values</span>
    <span class="s1">assert_equal(mod.nobs</span><span class="s2">, </span><span class="s1">endog.shape[</span><span class="s4">0</span><span class="s1">] - (</span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">assert_equal(len(pred)</span><span class="s2">, </span><span class="s1">mod.nobs)</span>
    <span class="s1">assert_equal(pred.index.values</span><span class="s2">, </span><span class="s1">index[</span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">].values)</span>
    <span class="s5"># Out-of-sample forecasting should still extend the index appropriately</span>
    <span class="s1">fcast = res.forecast()</span>
    <span class="s1">assert_equal(fcast.index[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index[-</span><span class="s4">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_memory_no_predicted():</span>
    <span class="s5"># Tests for forecasts with memory_no_predicted is set</span>
    <span class="s1">endog = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">]</span>

    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">res1 = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>
    <span class="s1">mod.ssm.memory_no_predicted = </span><span class="s2">True</span>
    <span class="s1">res2 = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s5"># Make sure we really didn't store all of the values in res2</span>
    <span class="s1">assert_equal(res1.predicted_state.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>
    <span class="s1">assert_(res2.predicted_state </span><span class="s2">is None</span><span class="s1">)</span>
    <span class="s1">assert_equal(res1.predicted_state_cov.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>
    <span class="s1">assert_(res2.predicted_state_cov </span><span class="s2">is None</span><span class="s1">)</span>

    <span class="s5"># Check that we can't do dynamic in-sample prediction</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res2.predict</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res2.get_prediction</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s5"># Make sure the point forecasts are the same</span>
    <span class="s1">assert_allclose(res1.forecast(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res2.forecast(</span><span class="s4">10</span><span class="s1">))</span>

    <span class="s5"># Make sure the confidence intervals are the same</span>
    <span class="s1">fcast1 = res1.get_forecast(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">fcast2 = res1.get_forecast(</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s1">assert_allclose(fcast1.summary_frame()</span><span class="s2">, </span><span class="s1">fcast2.summary_frame())</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'use_exog'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'trend'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_concatenated_predict_sarimax(use_exog</span><span class="s2">, </span><span class="s1">trend):</span>
    <span class="s1">endog = np.arange(</span><span class="s4">100</span><span class="s1">).reshape(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">1.0</span>
    <span class="s1">exog = np.ones(</span><span class="s4">100</span><span class="s1">) </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">exog[</span><span class="s4">10</span><span class="s1">:</span><span class="s4">30</span><span class="s1">] = </span><span class="s4">2.</span>

    <span class="s1">trend_params = [</span><span class="s4">0.1</span><span class="s1">]</span>
    <span class="s1">ar_params = [</span><span class="s4">0.5</span><span class="s1">]</span>
    <span class="s1">exog_params = [</span><span class="s4">1.2</span><span class="s1">]</span>
    <span class="s1">var_params = [</span><span class="s4">1.</span><span class="s1">]</span>

    <span class="s1">params = []</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">]:</span>
        <span class="s1">params += trend_params</span>
    <span class="s1">params += ar_params</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">params += exog_params</span>
    <span class="s1">params += var_params</span>

    <span class="s1">y1 = endog.copy()</span>
    <span class="s1">y1[-</span><span class="s4">50</span><span class="s1">:] = np.nan</span>
    <span class="s1">mod1 = sarimax.SARIMAX(y1</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>
    <span class="s1">p1 = res1.get_prediction()</span>
    <span class="s1">pr1 = p1.prediction_results</span>

    <span class="s1">x2 = exog[:</span><span class="s4">50</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">mod2 = sarimax.SARIMAX(endog[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=x2)</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s1">x2f = exog[</span><span class="s4">50</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">99</span><span class="s2">, </span><span class="s1">exog=x2f)</span>
    <span class="s1">pr2 = p2.prediction_results</span>

    <span class="s1">attrs = (</span>
        <span class="s1">pr1.representation_attributes</span>
        <span class="s1">+ pr1.filter_attributes</span>
        <span class="s1">+ pr1.smoother_attributes)</span>
    <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">assert_allclose(getattr(pr2</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">, </span><span class="s1">getattr(pr1</span><span class="s2">, </span><span class="s1">key))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'use_exog'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'trend'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_concatenated_predict_varmax(use_exog</span><span class="s2">, </span><span class="s1">trend):</span>
    <span class="s1">endog = np.arange(</span><span class="s4">200</span><span class="s1">).reshape(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) * </span><span class="s4">1.0</span>
    <span class="s1">exog = np.ones(</span><span class="s4">100</span><span class="s1">) </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>

    <span class="s1">trend_params = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">var_params = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">exog_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span>
    <span class="s1">cov_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>

    <span class="s1">params = []</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">]:</span>
        <span class="s1">params += trend_params</span>
    <span class="s1">params += var_params</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">params += exog_params</span>
    <span class="s1">params += cov_params</span>

    <span class="s1">y1 = endog.copy()</span>
    <span class="s1">y1[-</span><span class="s4">50</span><span class="s1">:] = np.nan</span>
    <span class="s1">mod1 = varmax.VARMAX(y1</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>
    <span class="s1">p1 = res1.get_prediction()</span>
    <span class="s1">pr1 = p1.prediction_results</span>

    <span class="s1">x2 = exog[:</span><span class="s4">50</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">mod2 = varmax.VARMAX(endog[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=x2)</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s1">x2f = exog[</span><span class="s4">50</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">99</span><span class="s2">, </span><span class="s1">exog=x2f)</span>
    <span class="s1">pr2 = p2.prediction_results</span>

    <span class="s1">attrs = (</span>
        <span class="s1">pr1.representation_attributes</span>
        <span class="s1">+ pr1.filter_attributes</span>
        <span class="s1">+ pr1.smoother_attributes)</span>
    <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">assert_allclose(getattr(pr2</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">, </span><span class="s1">getattr(pr1</span><span class="s2">, </span><span class="s1">key))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'use_exog'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'trend'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_predicted_filtered_smoothed_with_nans(use_exog</span><span class="s2">, </span><span class="s1">trend):</span>
    <span class="s5"># In this test, we construct a model with only NaN values for `endog`, so</span>
    <span class="s5"># that predicted, filtered, and smoothed forecasts should all be the</span>
    <span class="s5"># same</span>
    <span class="s1">endog = np.zeros(</span><span class="s4">200</span><span class="s1">).reshape(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) * np.nan</span>
    <span class="s1">exog = np.ones(</span><span class="s4">100</span><span class="s1">) </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>

    <span class="s1">trend_params = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">var_params = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">exog_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span>
    <span class="s1">cov_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>

    <span class="s1">params = []</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">]:</span>
        <span class="s1">params += trend_params</span>
    <span class="s1">params += var_params</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">params += exog_params</span>
    <span class="s1">params += cov_params</span>

    <span class="s1">x_fit = exog[:</span><span class="s4">50</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">mod = varmax.VARMAX(endog[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=x_fit)</span>
    <span class="s1">res = mod.smooth(params)</span>

    <span class="s1">x_fcast = exog[</span><span class="s4">50</span><span class="s1">:</span><span class="s4">61</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">p_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'predicted'</span><span class="s2">,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s1">f_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s2">,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s1">s_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'smoothed'</span><span class="s2">,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s5"># Test forecasts</span>
    <span class="s1">assert_allclose(s_pred.predicted_mean</span><span class="s2">, </span><span class="s1">p_pred.predicted_mean)</span>
    <span class="s1">assert_allclose(s_pred.var_pred_mean</span><span class="s2">, </span><span class="s1">p_pred.var_pred_mean)</span>
    <span class="s1">assert_allclose(f_pred.predicted_mean</span><span class="s2">, </span><span class="s1">p_pred.predicted_mean)</span>
    <span class="s1">assert_allclose(f_pred.var_pred_mean</span><span class="s2">, </span><span class="s1">p_pred.var_pred_mean)</span>
    <span class="s1">assert_allclose(p_pred.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res.fittedvalues)</span>
    <span class="s1">assert_allclose(p_pred.var_pred_mean[:</span><span class="s4">50</span><span class="s1">].T</span><span class="s2">, </span><span class="s1">res.forecasts_error_cov)</span>

    <span class="s1">p_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'predicted'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s1">f_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s1">s_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'smoothed'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s5"># Test signal predictions</span>
    <span class="s1">assert_allclose(s_signal.predicted_mean</span><span class="s2">, </span><span class="s1">p_signal.predicted_mean)</span>
    <span class="s1">assert_allclose(s_signal.var_pred_mean</span><span class="s2">, </span><span class="s1">p_signal.var_pred_mean)</span>
    <span class="s1">assert_allclose(f_signal.predicted_mean</span><span class="s2">, </span><span class="s1">p_signal.predicted_mean)</span>
    <span class="s1">assert_allclose(f_signal.var_pred_mean</span><span class="s2">, </span><span class="s1">p_signal.var_pred_mean)</span>

    <span class="s2">if </span><span class="s1">use_exog </span><span class="s2">is False and </span><span class="s1">trend == </span><span class="s3">'n'</span><span class="s1">:</span>
        <span class="s1">assert_allclose(p_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res.fittedvalues)</span>
        <span class="s1">assert_allclose(p_signal.var_pred_mean[:</span><span class="s4">50</span><span class="s1">].T</span><span class="s2">, </span><span class="s1">res.forecasts_error_cov)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">assert_allclose(p_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">] + mod[</span><span class="s3">'obs_intercept'</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">res.fittedvalues)</span>
        <span class="s1">assert_allclose((p_signal.var_pred_mean[:</span><span class="s4">50</span><span class="s1">] + mod[</span><span class="s3">'obs_cov'</span><span class="s1">]).T</span><span class="s2">,</span>
                        <span class="s1">res.forecasts_error_cov)</span>


<span class="s2">def </span><span class="s1">test_predicted_filtered_smoothed_with_nans_TVSS(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">50</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan)</span>
    <span class="s1">mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">res = mod.smooth([])</span>

    <span class="s1">mod_oos = TVSS(np.zeros((</span><span class="s4">11</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan)</span>
    <span class="s1">kwargs = {key: mod_oos[key] </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span>
        <span class="s3">'obs_intercept'</span><span class="s2">, </span><span class="s3">'design'</span><span class="s2">, </span><span class="s3">'obs_cov'</span><span class="s2">,</span>
        <span class="s3">'transition'</span><span class="s2">, </span><span class="s3">'selection'</span><span class="s2">, </span><span class="s3">'state_cov'</span><span class="s1">]}</span>

    <span class="s1">p_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'predicted'</span><span class="s2">,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">f_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s2">,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">s_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'smoothed'</span><span class="s2">,</span>
        <span class="s1">**kwargs)</span>

    <span class="s5"># Test forecasts</span>
    <span class="s1">assert_allclose(s_pred.predicted_mean</span><span class="s2">, </span><span class="s1">p_pred.predicted_mean)</span>
    <span class="s1">assert_allclose(s_pred.var_pred_mean</span><span class="s2">, </span><span class="s1">p_pred.var_pred_mean)</span>
    <span class="s1">assert_allclose(f_pred.predicted_mean</span><span class="s2">, </span><span class="s1">p_pred.predicted_mean)</span>
    <span class="s1">assert_allclose(f_pred.var_pred_mean</span><span class="s2">, </span><span class="s1">p_pred.var_pred_mean)</span>
    <span class="s1">assert_allclose(p_pred.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res.fittedvalues)</span>
    <span class="s1">assert_allclose(p_pred.var_pred_mean[:</span><span class="s4">50</span><span class="s1">].T</span><span class="s2">, </span><span class="s1">res.forecasts_error_cov)</span>

    <span class="s1">p_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'predicted'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">f_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">s_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'smoothed'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">**kwargs)</span>

    <span class="s5"># Test signal predictions</span>
    <span class="s1">assert_allclose(s_signal.predicted_mean</span><span class="s2">, </span><span class="s1">p_signal.predicted_mean)</span>
    <span class="s1">assert_allclose(s_signal.var_pred_mean</span><span class="s2">, </span><span class="s1">p_signal.var_pred_mean)</span>
    <span class="s1">assert_allclose(f_signal.predicted_mean</span><span class="s2">, </span><span class="s1">p_signal.predicted_mean)</span>
    <span class="s1">assert_allclose(f_signal.var_pred_mean</span><span class="s2">, </span><span class="s1">p_signal.var_pred_mean)</span>
    <span class="s1">assert_allclose(p_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">] + mod[</span><span class="s3">'obs_intercept'</span><span class="s1">].T</span><span class="s2">,</span>
                    <span class="s1">res.fittedvalues)</span>
    <span class="s1">assert_allclose((p_signal.var_pred_mean[:</span><span class="s4">50</span><span class="s1">] + mod[</span><span class="s3">'obs_cov'</span><span class="s1">].T).T</span><span class="s2">,</span>
                    <span class="s1">res.forecasts_error_cov)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'use_exog'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'trend'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_predicted_filtered_smoothed_varmax(use_exog</span><span class="s2">, </span><span class="s1">trend):</span>
    <span class="s1">endog = np.log(dta[[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'cpi'</span><span class="s1">]])</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s1">]:</span>
        <span class="s1">endog = endog.diff().iloc[</span><span class="s4">1</span><span class="s1">:] * </span><span class="s4">100</span>
    <span class="s2">if </span><span class="s1">trend == </span><span class="s3">'n'</span><span class="s1">:</span>
        <span class="s1">endog -= endog.mean()</span>
    <span class="s1">exog = np.ones(</span><span class="s4">100</span><span class="s1">) </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">exog[</span><span class="s4">20</span><span class="s1">:</span><span class="s4">40</span><span class="s1">] = </span><span class="s4">2.</span>

    <span class="s1">trend_params = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">var_params = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">exog_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span>
    <span class="s1">cov_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>

    <span class="s1">params = []</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">]:</span>
        <span class="s1">params += trend_params</span>
    <span class="s1">params += var_params</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">params += exog_params</span>
    <span class="s1">params += cov_params</span>

    <span class="s1">x_fit = exog[:</span><span class="s4">50</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">mod = varmax.VARMAX(endog[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=x_fit)</span>

    <span class="s5"># Add in an obs_intercept and obs_cov to make the test more comprehensive</span>
    <span class="s1">mod[</span><span class="s3">'obs_intercept'</span><span class="s1">] = [</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.</span><span class="s1">]</span>
    <span class="s1">mod[</span><span class="s3">'obs_cov'</span><span class="s1">] = np.array([[</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">3.4</span><span class="s1">]])</span>

    <span class="s1">res = mod.smooth(params)</span>

    <span class="s1">x_fcast = exog[</span><span class="s4">50</span><span class="s1">:</span><span class="s4">61</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">p_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'predicted'</span><span class="s2">,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s1">f_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s2">,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s1">s_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'smoothed'</span><span class="s2">,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s5"># Test forecasts</span>
    <span class="s1">fcast = res.get_forecast(</span><span class="s4">11</span><span class="s2">, </span><span class="s1">exog=x_fcast)</span>

    <span class="s1">d = mod[</span><span class="s3">'obs_intercept'</span><span class="s1">][:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">Z = mod[</span><span class="s3">'design'</span><span class="s1">]</span>
    <span class="s1">H = mod[</span><span class="s3">'obs_cov'</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">desired_s_signal = Z @ res.smoothed_state</span>
    <span class="s1">desired_f_signal = Z @ res.filtered_state</span>
    <span class="s1">desired_p_signal = Z @ res.predicted_state[...</span><span class="s2">, </span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">assert_allclose(s_pred.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(d + desired_s_signal).T)</span>
    <span class="s1">assert_allclose(s_pred.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.predicted_mean)</span>
    <span class="s1">assert_allclose(f_pred.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(d + desired_f_signal).T)</span>
    <span class="s1">assert_allclose(f_pred.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.predicted_mean)</span>
    <span class="s1">assert_allclose(p_pred.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(d + desired_p_signal).T)</span>
    <span class="s1">assert_allclose(p_pred.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.predicted_mean)</span>

    <span class="s1">desired_s_signal_cov = (</span>
        <span class="s1">Z[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] @ res.smoothed_state_cov.T @ Z.T[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:])</span>
    <span class="s1">desired_f_signal_cov = (</span>
        <span class="s1">Z[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] @ res.filtered_state_cov.T @ Z.T[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:])</span>
    <span class="s1">desired_p_signal_cov = (</span>
        <span class="s1">Z[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] @ res.predicted_state_cov[...</span><span class="s2">, </span><span class="s1">:-</span><span class="s4">1</span><span class="s1">].T @ Z.T[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:])</span>
    <span class="s1">assert_allclose(s_pred.var_pred_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(desired_s_signal_cov.T + H).T)</span>
    <span class="s1">assert_allclose(s_pred.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.var_pred_mean)</span>
    <span class="s1">assert_allclose(f_pred.var_pred_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(desired_f_signal_cov.T + H).T)</span>
    <span class="s1">assert_allclose(f_pred.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.var_pred_mean)</span>
    <span class="s1">assert_allclose(p_pred.var_pred_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(desired_p_signal_cov.T + H).T)</span>
    <span class="s1">assert_allclose(p_pred.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.var_pred_mean)</span>

    <span class="s1">p_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'predicted'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s1">f_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s1">s_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'smoothed'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">exog=x_fcast)</span>

    <span class="s5"># Test signal predictions</span>
    <span class="s1">fcast_signal = fcast.predicted_mean - d.T</span>
    <span class="s1">fcast_signal_cov = (fcast.var_pred_mean.T - H).T</span>
    <span class="s1">assert_allclose(s_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_s_signal.T)</span>
    <span class="s1">assert_allclose(s_signal.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal)</span>
    <span class="s1">assert_allclose(f_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_f_signal.T)</span>
    <span class="s1">assert_allclose(f_signal.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal)</span>
    <span class="s1">assert_allclose(p_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_p_signal.T)</span>
    <span class="s1">assert_allclose(p_signal.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal)</span>

    <span class="s1">assert_allclose(s_signal.var_pred_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_s_signal_cov)</span>
    <span class="s1">assert_allclose(s_signal.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal_cov)</span>
    <span class="s1">assert_allclose(f_signal.var_pred_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_f_signal_cov)</span>
    <span class="s1">assert_allclose(f_signal.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal_cov)</span>
    <span class="s1">assert_allclose(p_signal.var_pred_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_p_signal_cov)</span>
    <span class="s1">assert_allclose(p_signal.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal_cov)</span>


<span class="s2">def </span><span class="s1">test_predicted_filtered_smoothed_TVSS(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">50</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">res = mod.smooth([])</span>

    <span class="s1">mod_oos = TVSS(np.zeros((</span><span class="s4">11</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) * np.nan)</span>
    <span class="s1">kwargs = {key: mod_oos[key] </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span>
        <span class="s3">'obs_intercept'</span><span class="s2">, </span><span class="s3">'design'</span><span class="s2">, </span><span class="s3">'obs_cov'</span><span class="s2">,</span>
        <span class="s3">'transition'</span><span class="s2">, </span><span class="s3">'selection'</span><span class="s2">, </span><span class="s3">'state_cov'</span><span class="s1">]}</span>

    <span class="s1">p_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'predicted'</span><span class="s2">,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">f_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s2">,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">s_pred = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'smoothed'</span><span class="s2">,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">p_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'predicted'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">f_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">**kwargs)</span>

    <span class="s1">s_signal = res.get_prediction(</span>
        <span class="s1">start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">information_set=</span><span class="s3">'smoothed'</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
        <span class="s1">**kwargs)</span>

    <span class="s5"># Test forecasts and signals</span>
    <span class="s1">d = mod[</span><span class="s3">'obs_intercept'</span><span class="s1">].transpose(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">Z = mod[</span><span class="s3">'design'</span><span class="s1">].transpose(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">H = mod[</span><span class="s3">'obs_cov'</span><span class="s1">].transpose(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">fcast = res.get_forecast(</span><span class="s4">11</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">fcast_signal = fcast.predicted_mean - mod_oos[</span><span class="s3">'obs_intercept'</span><span class="s1">].T</span>
    <span class="s1">fcast_signal_cov = fcast.var_pred_mean - mod_oos[</span><span class="s3">'obs_cov'</span><span class="s1">].T</span>

    <span class="s1">desired_s_signal = Z @ res.smoothed_state.T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">desired_f_signal = Z @ res.filtered_state.T[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">desired_p_signal = Z @ res.predicted_state.T[:-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">assert_allclose(s_pred.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(d + desired_s_signal)[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(s_pred.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.predicted_mean)</span>
    <span class="s1">assert_allclose(f_pred.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(d + desired_f_signal)[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(f_pred.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.predicted_mean)</span>
    <span class="s1">assert_allclose(p_pred.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(d + desired_p_signal)[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(p_pred.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.predicted_mean)</span>

    <span class="s1">assert_allclose(s_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_s_signal[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(s_signal.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal)</span>
    <span class="s1">assert_allclose(f_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_f_signal[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(f_signal.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal)</span>
    <span class="s1">assert_allclose(p_signal.predicted_mean[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired_p_signal[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(p_signal.predicted_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal)</span>

    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(mod.nobs):</span>
        <span class="s1">assert_allclose(s_pred.var_pred_mean[t]</span><span class="s2">,</span>
                        <span class="s1">Z[t] @ res.smoothed_state_cov[...</span><span class="s2">, </span><span class="s1">t] @ Z[t].T + H[t])</span>
        <span class="s1">assert_allclose(f_pred.var_pred_mean[t]</span><span class="s2">,</span>
                        <span class="s1">Z[t] @ res.filtered_state_cov[...</span><span class="s2">, </span><span class="s1">t] @ Z[t].T + H[t])</span>
        <span class="s1">assert_allclose(p_pred.var_pred_mean[t]</span><span class="s2">,</span>
                        <span class="s1">Z[t] @ res.predicted_state_cov[...</span><span class="s2">, </span><span class="s1">t] @ Z[t].T + H[t])</span>

        <span class="s1">assert_allclose(s_signal.var_pred_mean[t]</span><span class="s2">,</span>
                        <span class="s1">Z[t] @ res.smoothed_state_cov[...</span><span class="s2">, </span><span class="s1">t] @ Z[t].T)</span>
        <span class="s1">assert_allclose(f_signal.var_pred_mean[t]</span><span class="s2">,</span>
                        <span class="s1">Z[t] @ res.filtered_state_cov[...</span><span class="s2">, </span><span class="s1">t] @ Z[t].T)</span>
        <span class="s1">assert_allclose(p_signal.var_pred_mean[t]</span><span class="s2">,</span>
                        <span class="s1">Z[t] @ res.predicted_state_cov[...</span><span class="s2">, </span><span class="s1">t] @ Z[t].T)</span>

    <span class="s1">assert_allclose(s_pred.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.var_pred_mean)</span>
    <span class="s1">assert_allclose(f_pred.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.var_pred_mean)</span>
    <span class="s1">assert_allclose(p_pred.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast.var_pred_mean)</span>
    <span class="s1">assert_allclose(s_signal.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal_cov)</span>
    <span class="s1">assert_allclose(f_signal.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal_cov)</span>
    <span class="s1">assert_allclose(p_signal.var_pred_mean[</span><span class="s4">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fcast_signal_cov)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'use_exog'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'trend'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_predicted_filtered_dynamic_varmax(use_exog</span><span class="s2">, </span><span class="s1">trend):</span>
    <span class="s1">endog = np.log(dta[[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'cpi'</span><span class="s1">]])</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s1">]:</span>
        <span class="s1">endog = endog.diff().iloc[</span><span class="s4">1</span><span class="s1">:] * </span><span class="s4">100</span>
    <span class="s2">if </span><span class="s1">trend == </span><span class="s3">'n'</span><span class="s1">:</span>
        <span class="s1">endog -= endog.mean()</span>
    <span class="s1">exog = np.ones(</span><span class="s4">100</span><span class="s1">) </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">exog[</span><span class="s4">20</span><span class="s1">:</span><span class="s4">40</span><span class="s1">] = </span><span class="s4">2.</span>

    <span class="s1">trend_params = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">var_params = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">exog_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span>
    <span class="s1">cov_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>

    <span class="s1">params = []</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">]:</span>
        <span class="s1">params += trend_params</span>
    <span class="s1">params += var_params</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">params += exog_params</span>
    <span class="s1">params += cov_params</span>

    <span class="s5"># Compute basic model with 50 observations</span>
    <span class="s1">x_fit1 = exog[:</span><span class="s4">50</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">x_fcast1 = exog[</span><span class="s4">50</span><span class="s1">:</span><span class="s4">61</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">mod1 = varmax.VARMAX(endog[:</span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=x_fit1)</span>

    <span class="s1">res1 = mod1.filter(params)</span>

    <span class="s5"># Compute basic model with only 20 observations</span>
    <span class="s1">x_fit2 = exog[:</span><span class="s4">20</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">x_fcast2 = exog[</span><span class="s4">20</span><span class="s1">:</span><span class="s4">61</span><span class="s1">] </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>
    <span class="s1">mod2 = varmax.VARMAX(endog[:</span><span class="s4">20</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=x_fit2)</span>
    <span class="s1">res2 = mod2.filter(params)</span>

    <span class="s5"># Test predictions</span>
    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s4">18</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s5"># Test predictions, filtered</span>
    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s4">18</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s5"># Test signals</span>
    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">signal_only=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s4">18</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">signal_only=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">signal_only=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s5"># Test signal, filtered</span>
    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">signal_only=</span><span class="s2">True, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s4">18</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">signal_only=</span><span class="s2">True, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>

    <span class="s1">p1 = res1.get_prediction(start=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast1</span><span class="s2">,</span>
                             <span class="s1">signal_only=</span><span class="s2">True, </span><span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">p2 = res2.get_prediction(start=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">exog=x_fcast2</span><span class="s2">, </span><span class="s1">signal_only=</span><span class="s2">True,</span>
                             <span class="s1">information_set=</span><span class="s3">'filtered'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p1.predicted_mean</span><span class="s2">, </span><span class="s1">p2.predicted_mean)</span>
    <span class="s1">assert_allclose(p1.var_pred_mean</span><span class="s2">, </span><span class="s1">p2.var_pred_mean)</span>
</pre>
</body>
</html>