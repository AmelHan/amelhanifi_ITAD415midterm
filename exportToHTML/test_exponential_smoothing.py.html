<html>
<head>
<title>test_exponential_smoothing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_exponential_smoothing.py</font>
</center></td></tr></table>
<pre><span class="s0">r&quot;&quot;&quot; 
Tests for exponential smoothing models 
 
Notes 
----- 
 
These tests are primarily against the `fpp` functions `ses`, `holt`, and `hw` 
and against the `forecast` function `ets`. There are a couple of details about 
how these packages work that are relevant for the tests: 
 
Trend smoothing parameterization 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
Note that `fpp` and `ets` use 
different parameterizations for the trend smoothing parameter. Our 
implementation in `statespace.exponential_smoothing` uses the same 
parameterization as `ets`. 
 
The `fpp` package follows Holt's recursive equations directly, in which the 
trend updating is: 
 
.. math:: 
 
    b_t = \beta^* (\ell_t - \ell_{t-1}) + (1 - \beta^*) b_{t-1} 
 
In our implementation, state updating is done by the Kalman filter, in which 
the trend updating equation is: 
 
.. math:: 
 
    b_{t|t} = b_{t|t-1} + \beta (y_t - l_{t|t-1}) 
 
by rewriting the Kalman updating equation in the form of Holt's method, we 
find that we must have :math:`\beta = \beta^* \alpha`. This is the same 
parameterization used by `ets`, which does not use the Kalman fitler but 
instead uses an innovations state space framework. 
 
Loglikelihood 
^^^^^^^^^^^^^ 
 
The `ets` package has a `loglik` output value, but it does not compute the 
loglikelihood itself, but rather a version without the constant parameters. It 
appears to compute: 
 
.. math:: 
 
    -\frac{n}{2} \log \left (\sum_{t=1}^n \varepsilon_t^2 \right) 
 
while the loglikelihood is: 
 
.. math:: 
 
    -\frac{n}{2} 
    \log \left (2 \pi e \frac{1}{n} \sum_{t=1}^n \varepsilon_t^2 \right) 
 
See Hyndman et al. (2008), pages 68-69. In particular, the former equation - 
which is the value returned by `ets` - is -0.5 times equation (5.3), since for 
these models we have :math:`r(x_{t-1}) = 1`. The latter equation is the log 
of the likelihood formula given at the top of page 69. 
 
Confidence intervals 
^^^^^^^^^^^^^^^^^^^^ 
 
The range of the confidence intervals depends on the estimated variance, 
sigma^2. In our default, we concentrate this variance out of the loglikelihood 
function, meaning that the default is to use the maximum likelihood estimate 
for forecasting purposes. forecast::ets uses a degree-of-freedom-corrected 
estimate of sigma^2, and so our default confidence bands will differ. To 
correct for this in the tests, we set `concentrate_scale=False` and use the 
estimated variance from forecast::ets. 
 
TODO: may want to add a parameter allowing specification of the variance 
      estimator. 
 
Author: Chad Fulton 
License: BSD-3 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">division</span><span class="s2">, </span><span class="s1">absolute_import</span><span class="s2">, </span><span class="s1">print_function</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.exponential_smoothing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ExponentialSmoothing)</span>

<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>
<span class="s1">results_path = os.path.join(current_path</span><span class="s2">, </span><span class="s3">'results'</span><span class="s1">)</span>
<span class="s1">params_path = os.path.join(results_path</span><span class="s2">, </span><span class="s3">'exponential_smoothing_params.csv'</span><span class="s1">)</span>
<span class="s1">predict_path = os.path.join(results_path</span><span class="s2">, </span><span class="s3">'exponential_smoothing_predict.csv'</span><span class="s1">)</span>
<span class="s1">states_path = os.path.join(results_path</span><span class="s2">, </span><span class="s3">'exponential_smoothing_states.csv'</span><span class="s1">)</span>
<span class="s1">results_params = pd.read_csv(params_path</span><span class="s2">, </span><span class="s1">index_col=[</span><span class="s4">0</span><span class="s1">])</span>
<span class="s1">results_predict = pd.read_csv(predict_path</span><span class="s2">, </span><span class="s1">index_col=[</span><span class="s4">0</span><span class="s1">])</span>
<span class="s1">results_states = pd.read_csv(states_path</span><span class="s2">, </span><span class="s1">index_col=[</span><span class="s4">0</span><span class="s1">])</span>

<span class="s5"># R, fpp: oildata &lt;- window(oil,start=1996,end=2007)</span>
<span class="s1">oildata = pd.Series([</span>
    <span class="s4">446.6565229</span><span class="s2">, </span><span class="s4">454.4733065</span><span class="s2">, </span><span class="s4">455.6629740</span><span class="s2">, </span><span class="s4">423.6322388</span><span class="s2">, </span><span class="s4">456.2713279</span><span class="s2">,</span>
    <span class="s4">440.5880501</span><span class="s2">, </span><span class="s4">425.3325201</span><span class="s2">, </span><span class="s4">485.1494479</span><span class="s2">, </span><span class="s4">506.0481621</span><span class="s2">, </span><span class="s4">526.7919833</span><span class="s2">,</span>
    <span class="s4">514.2688890</span><span class="s2">, </span><span class="s4">494.2110193</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">index=pd.period_range(start=</span><span class="s3">'1996'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2007'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'A'</span><span class="s1">))</span>

<span class="s5"># R, fpp: air &lt;- window(ausair,start=1990,end=2004)</span>
<span class="s1">air = pd.Series([</span>
    <span class="s4">17.553400</span><span class="s2">, </span><span class="s4">21.860100</span><span class="s2">, </span><span class="s4">23.886600</span><span class="s2">, </span><span class="s4">26.929300</span><span class="s2">, </span><span class="s4">26.888500</span><span class="s2">,</span>
    <span class="s4">28.831400</span><span class="s2">, </span><span class="s4">30.075100</span><span class="s2">, </span><span class="s4">30.953500</span><span class="s2">, </span><span class="s4">30.185700</span><span class="s2">, </span><span class="s4">31.579700</span><span class="s2">,</span>
    <span class="s4">32.577569</span><span class="s2">, </span><span class="s4">33.477398</span><span class="s2">, </span><span class="s4">39.021581</span><span class="s2">, </span><span class="s4">41.386432</span><span class="s2">, </span><span class="s4">41.596552</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">index=pd.period_range(start=</span><span class="s3">'1990'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2004'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'A'</span><span class="s1">))</span>

<span class="s5"># R, fpp: aust &lt;- window(austourists,start=2005)</span>
<span class="s1">aust = pd.Series([</span>
    <span class="s4">41.727458</span><span class="s2">, </span><span class="s4">24.041850</span><span class="s2">, </span><span class="s4">32.328103</span><span class="s2">, </span><span class="s4">37.328708</span><span class="s2">, </span><span class="s4">46.213153</span><span class="s2">,</span>
    <span class="s4">29.346326</span><span class="s2">, </span><span class="s4">36.482910</span><span class="s2">, </span><span class="s4">42.977719</span><span class="s2">, </span><span class="s4">48.901525</span><span class="s2">, </span><span class="s4">31.180221</span><span class="s2">,</span>
    <span class="s4">37.717881</span><span class="s2">, </span><span class="s4">40.420211</span><span class="s2">, </span><span class="s4">51.206863</span><span class="s2">, </span><span class="s4">31.887228</span><span class="s2">, </span><span class="s4">40.978263</span><span class="s2">,</span>
    <span class="s4">43.772491</span><span class="s2">, </span><span class="s4">55.558567</span><span class="s2">, </span><span class="s4">33.850915</span><span class="s2">, </span><span class="s4">42.076383</span><span class="s2">, </span><span class="s4">45.642292</span><span class="s2">,</span>
    <span class="s4">59.766780</span><span class="s2">, </span><span class="s4">35.191877</span><span class="s2">, </span><span class="s4">44.319737</span><span class="s2">, </span><span class="s4">47.913736</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">index=pd.period_range(start=</span><span class="s3">'2005Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2010Q4'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">CheckExponentialSmoothing:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">res):</span>
        <span class="s1">cls.name = name</span>
        <span class="s1">cls.res = res</span>
        <span class="s1">cls.nobs = res.nobs</span>
        <span class="s1">cls.nforecast = len(results_predict[</span><span class="s3">'%s_mean' </span><span class="s1">% cls.name]) - cls.nobs</span>
        <span class="s1">cls.forecast = res.get_forecast(cls.nforecast)</span>

    <span class="s2">def </span><span class="s1">test_fitted(self):</span>
        <span class="s1">predicted = results_predict[</span><span class="s3">'%s_mean' </span><span class="s1">% self.name]</span>
        <span class="s1">assert_allclose(self.res.fittedvalues</span><span class="s2">, </span><span class="s1">predicted.iloc[:self.nobs])</span>

    <span class="s2">def </span><span class="s1">test_output(self):</span>
        <span class="s5"># There are two types of output, depending on some internal switch of</span>
        <span class="s5"># fpp::ses that appears to depend on if parameters are estimated. If</span>
        <span class="s5"># they are estimated, then llf and mse are available but sse is not.</span>
        <span class="s5"># Otherwise, sse is available and the other two aren't.</span>
        <span class="s1">has_llf = ~np.isnan(results_params[self.name][</span><span class="s3">'llf'</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">has_llf:</span>
            <span class="s1">assert_allclose(self.res.mse</span><span class="s2">, </span><span class="s1">results_params[self.name][</span><span class="s3">'mse'</span><span class="s1">])</span>
            <span class="s5"># As noted in the file docstring, `ets` does not return the actual</span>
            <span class="s5"># loglikelihood, but instead a transformation of it. Here we</span>
            <span class="s5"># compute that transformation based on our results, so as to</span>
            <span class="s5"># compare with the `ets` output.</span>
            <span class="s1">actual = -</span><span class="s4">0.5 </span><span class="s1">* self.nobs * np.log(np.sum(self.res.resid**</span><span class="s4">2</span><span class="s1">))</span>
            <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">results_params[self.name][</span><span class="s3">'llf'</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_allclose(self.res.sse</span><span class="s2">, </span><span class="s1">results_params[self.name][</span><span class="s3">'sse'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_forecasts(self):</span>
        <span class="s5"># Forecast mean</span>
        <span class="s1">predicted = results_predict[</span><span class="s3">'%s_mean' </span><span class="s1">% self.name]</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.forecast.predicted_mean</span><span class="s2">,</span>
            <span class="s1">predicted.iloc[self.nobs:]</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_conf_int(self):</span>
        <span class="s5"># Forecast confidence intervals</span>
        <span class="s1">ci_95 = self.forecast.conf_int(alpha=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">lower = results_predict[</span><span class="s3">'%s_lower' </span><span class="s1">% self.name]</span>
        <span class="s1">upper = results_predict[</span><span class="s3">'%s_upper' </span><span class="s1">% self.name]</span>

        <span class="s1">assert_allclose(ci_95[</span><span class="s3">'lower y'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">lower.iloc[self.nobs:])</span>
        <span class="s1">assert_allclose(ci_95[</span><span class="s3">'upper y'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">upper.iloc[self.nobs:])</span>

    <span class="s2">def </span><span class="s1">test_initial_states(self):</span>
        <span class="s1">mask = results_states.columns.str.startswith(self.name)</span>
        <span class="s1">desired = results_states.loc[:</span><span class="s2">, </span><span class="s1">mask].dropna().iloc[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">assert_allclose(self.res.initial_state.iloc[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s2">def </span><span class="s1">test_states(self):</span>
        <span class="s1">mask = results_states.columns.str.startswith(self.name)</span>
        <span class="s1">desired = results_states.loc[:</span><span class="s2">, </span><span class="s1">mask].dropna().iloc[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">assert_allclose(self.res.filtered_state[</span><span class="s4">1</span><span class="s1">:].T</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s2">def </span><span class="s1">test_misc(self):</span>
        <span class="s1">mod = self.res.model</span>
        <span class="s1">assert_equal(mod.k_params</span><span class="s2">, </span><span class="s1">len(mod.start_params))</span>
        <span class="s1">assert_equal(mod.k_params</span><span class="s2">, </span><span class="s1">len(mod.param_names))</span>

        <span class="s5"># Smoke test for summary creation</span>
        <span class="s1">self.res.summary()</span>


<span class="s2">class </span><span class="s1">TestSESFPPFixed02(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test simple exponential smoothing (FPP: 7.1) against fpp::ses, with</span>
        <span class="s5"># a fixed coefficient 0.2 and simple initialization</span>
        <span class="s1">mod = ExponentialSmoothing(oildata</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'simple'</span><span class="s1">)</span>
        <span class="s1">res = mod.filter([results_params[</span><span class="s3">'oil_fpp1'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]])</span>

        <span class="s1">super().setup_class(</span><span class="s3">'oil_fpp1'</span><span class="s2">, </span><span class="s1">res)</span>


<span class="s2">class </span><span class="s1">TestSESFPPFixed06(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test simple exponential smoothing (FPP: 7.1) against fpp::ses, with</span>
        <span class="s5"># a fixed coefficient 0.6 and simple initialization</span>
        <span class="s1">mod = ExponentialSmoothing(oildata</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'simple'</span><span class="s1">)</span>
        <span class="s1">res = mod.filter([results_params[</span><span class="s3">'oil_fpp2'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]])</span>

        <span class="s1">super().setup_class(</span><span class="s3">'oil_fpp2'</span><span class="s2">, </span><span class="s1">res)</span>


<span class="s2">class </span><span class="s1">TestSESFPPEstimated(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test simple exponential smoothing (FPP: 7.1) against fpp::ses, with</span>
        <span class="s5"># estimated coefficients</span>
        <span class="s1">mod = ExponentialSmoothing(oildata</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'estimated'</span><span class="s2">,</span>
                                   <span class="s1">concentrate_scale=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">res = mod.filter([results_params[</span><span class="s3">'oil_fpp3'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">results_params[</span><span class="s3">'oil_fpp3'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">results_params[</span><span class="s3">'oil_fpp3'</span><span class="s1">][</span><span class="s3">'l0'</span><span class="s1">]])</span>

        <span class="s1">super().setup_class(</span><span class="s3">'oil_fpp3'</span><span class="s2">, </span><span class="s1">res)</span>


<span class="s2">class </span><span class="s1">TestSESETSEstimated(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test simple exponential smoothing (FPP: 7.1) against forecast::ets,</span>
        <span class="s5"># with estimated coefficients</span>
        <span class="s1">mod = ExponentialSmoothing(oildata</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'estimated'</span><span class="s2">,</span>
                                   <span class="s1">concentrate_scale=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">res = mod.filter([results_params[</span><span class="s3">'oil_ets'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">results_params[</span><span class="s3">'oil_ets'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">results_params[</span><span class="s3">'oil_ets'</span><span class="s1">][</span><span class="s3">'l0'</span><span class="s1">]])</span>

        <span class="s1">super().setup_class(</span><span class="s3">'oil_ets'</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s2">def </span><span class="s1">test_mle_estimates(self):</span>
        <span class="s5"># Test that our fitted coefficients are at least as good as those from</span>
        <span class="s5"># `ets`</span>
        <span class="s1">mle_res = self.res.model.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_(self.res.llf &lt;= mle_res.llf)</span>


<span class="s2">class </span><span class="s1">TestHoltFPPFixed(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test Holt's linear trend method (FPP: 7.2) against fpp::holt,</span>
        <span class="s5"># with fixed coefficients and simple initialization</span>

        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">concentrate_scale=</span><span class="s2">False,</span>
                                   <span class="s1">initialization_method=</span><span class="s3">'simple'</span><span class="s1">)</span>
        <span class="s5"># alpha, beta^*</span>
        <span class="s1">params = [results_params[</span><span class="s3">'air_fpp1'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_fpp1'</span><span class="s1">][</span><span class="s3">'beta_star'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_fpp1'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]]</span>
        <span class="s5"># beta = alpha * beta^*</span>
        <span class="s1">params[</span><span class="s4">1</span><span class="s1">] = params[</span><span class="s4">0</span><span class="s1">] * params[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">res = mod.filter(params)</span>

        <span class="s1">super().setup_class(</span><span class="s3">'air_fpp1'</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s2">def </span><span class="s1">test_conf_int(self):</span>
        <span class="s5"># Note: cannot test against the output of the `holt` command in this</span>
        <span class="s5"># case, as `holt` seems to have a bug: while it is parametrized in</span>
        <span class="s5"># terms of `beta_star`, its confidence intervals are computed as though</span>
        <span class="s5"># beta_star was actually beta = alpha * beta_star.</span>
        <span class="s5"># Instead, we'll compare against a direct computation as in</span>
        <span class="s5"># Hyndman et al. (2008) equation (6.1).</span>
        <span class="s1">j = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">14</span><span class="s1">)</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">sigma2 = self.res.params</span>
        <span class="s1">c = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">alpha + beta * j]</span>
        <span class="s1">se = (sigma2 * (</span><span class="s4">1 </span><span class="s1">+ np.cumsum(c**</span><span class="s4">2</span><span class="s1">)))**</span><span class="s4">0.5</span>
        <span class="s1">assert_allclose(self.forecast.se_mean</span><span class="s2">, </span><span class="s1">se)</span>


<span class="s2">class </span><span class="s1">TestHoltDampedFPPEstimated(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test Holt's linear trend method (FPP: 7.2) with a damped trend</span>
        <span class="s5"># against fpp::holt, with estimated coefficients</span>

        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True,</span>
                                   <span class="s1">concentrate_scale=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">params = [results_params[</span><span class="s3">'air_fpp2'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_fpp2'</span><span class="s1">][</span><span class="s3">'beta'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_fpp2'</span><span class="s1">][</span><span class="s3">'phi'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_fpp2'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_fpp2'</span><span class="s1">][</span><span class="s3">'l0'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_fpp2'</span><span class="s1">][</span><span class="s3">'b0'</span><span class="s1">]]</span>
        <span class="s1">res = mod.filter(params)</span>

        <span class="s1">super().setup_class(</span><span class="s3">'air_fpp2'</span><span class="s2">, </span><span class="s1">res)</span>


<span class="s2">class </span><span class="s1">TestHoltDampedETSEstimated(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test Holt's linear trend method (FPP: 7.2) with a damped trend</span>
        <span class="s5"># against forecast::ets, with estimated coefficients</span>

        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True,</span>
                                   <span class="s1">concentrate_scale=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">params = [results_params[</span><span class="s3">'air_ets'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_ets'</span><span class="s1">][</span><span class="s3">'beta'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_ets'</span><span class="s1">][</span><span class="s3">'phi'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_ets'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_ets'</span><span class="s1">][</span><span class="s3">'l0'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">results_params[</span><span class="s3">'air_ets'</span><span class="s1">][</span><span class="s3">'b0'</span><span class="s1">]]</span>
        <span class="s1">res = mod.filter(params)</span>

        <span class="s1">super().setup_class(</span><span class="s3">'air_ets'</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s2">def </span><span class="s1">test_mle_estimates(self):</span>
        <span class="s5"># Test that our fitted coefficients are at least as good as those from</span>
        <span class="s5"># `ets`</span>
        <span class="s1">mle_res = self.res.model.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_(self.res.llf &lt;= mle_res.llf)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersFPPEstimated(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test Holt-Winters seasonal method (FPP: 7.5) against fpp::hw,</span>
        <span class="s5"># with estimated coefficients</span>

        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">,</span>
                                   <span class="s1">concentrate_scale=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">params = np.r_[</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'beta'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'gamma'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'l0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'b0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'s0_0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'s0_1'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_fpp1'</span><span class="s1">][</span><span class="s3">'s0_2'</span><span class="s1">]]</span>
        <span class="s1">res = mod.filter(params)</span>

        <span class="s1">super().setup_class(</span><span class="s3">'aust_fpp1'</span><span class="s2">, </span><span class="s1">res)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersETSEstimated(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test Holt-Winters seasonal method (FPP: 7.5) against forecast::ets,</span>
        <span class="s5"># with estimated coefficients</span>

        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">,</span>
                                   <span class="s1">concentrate_scale=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">params = np.r_[</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'beta'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'gamma'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'l0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'b0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'s0_0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'s0_1'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets1'</span><span class="s1">][</span><span class="s3">'s0_2'</span><span class="s1">]]</span>
        <span class="s1">res = mod.filter(params)</span>

        <span class="s1">super().setup_class(</span><span class="s3">'aust_ets1'</span><span class="s2">, </span><span class="s1">res)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersDampedETSEstimated(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test Holt-Winters seasonal method (FPP: 7.5) with a damped trend</span>
        <span class="s5"># against forecast::ets, with estimated coefficients</span>

        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True,</span>
                                   <span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">concentrate_scale=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">params = np.r_[</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'beta'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'gamma'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'phi'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'l0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'b0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'s0_0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'s0_1'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets2'</span><span class="s1">][</span><span class="s3">'s0_2'</span><span class="s1">]]</span>
        <span class="s1">res = mod.filter(params)</span>

        <span class="s1">super().setup_class(</span><span class="s3">'aust_ets2'</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s2">def </span><span class="s1">test_mle_estimates(self):</span>
        <span class="s5"># Test that our fitted coefficients are at least as good as those from</span>
        <span class="s5"># `ets`</span>
        <span class="s1">mle_res = self.res.model.fit(disp=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">assert_(self.res.llf &lt;= mle_res.llf)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersNoTrendETSEstimated(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s5"># Test Holt-Winters seasonal method (FPP: 7.5) with no trend</span>
        <span class="s5"># against forecast::ets, with estimated coefficients</span>

        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">concentrate_scale=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">params = np.r_[</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets3'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets3'</span><span class="s1">][</span><span class="s3">'gamma'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets3'</span><span class="s1">][</span><span class="s3">'sigma2'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets3'</span><span class="s1">][</span><span class="s3">'l0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets3'</span><span class="s1">][</span><span class="s3">'s0_0'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets3'</span><span class="s1">][</span><span class="s3">'s0_1'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">results_params[</span><span class="s3">'aust_ets3'</span><span class="s1">][</span><span class="s3">'s0_2'</span><span class="s1">]]</span>
        <span class="s1">res = mod.filter(params)</span>

        <span class="s1">super().setup_class(</span><span class="s3">'aust_ets3'</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s2">def </span><span class="s1">test_conf_int(self):</span>
        <span class="s5"># `forecast::ets` seems to have a bug in this case related to the</span>
        <span class="s5"># seasonal component of the standard error computation. From</span>
        <span class="s5"># Hyndman et al. (2008) Table 6.2, &quot;d_{j,m} = 1 if j = 0 (mod m) and</span>
        <span class="s5"># 0 otherwise&quot;. This implies that the seasonal effect on the standard</span>
        <span class="s5"># error computation should only start when the j = m (here m = 4) term</span>
        <span class="s5"># is included in the standard error computation, which happens at the</span>
        <span class="s5"># fifth forecast (h=5). However, `ets` is starting it at the fourth</span>
        <span class="s5"># forecast (h=4).</span>
        <span class="s5"># Instead, we'll compare against a direct computation as in</span>
        <span class="s5"># Hyndman et al. (2008) equation (6.1).</span>
        <span class="s1">j = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">sigma2 = self.res.params[:</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">c = np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">alpha + gamma * ((j % </span><span class="s4">4</span><span class="s1">) == </span><span class="s4">0</span><span class="s1">).astype(int)]</span>
        <span class="s1">se = (sigma2 * (</span><span class="s4">1 </span><span class="s1">+ np.cumsum(c**</span><span class="s4">2</span><span class="s1">)))**</span><span class="s4">0.5</span>
        <span class="s1">assert_allclose(self.forecast.se_mean</span><span class="s2">, </span><span class="s1">se)</span>

    <span class="s2">def </span><span class="s1">test_mle_estimates(self):</span>
        <span class="s5"># Test that our fitted coefficients are at least as good as those from</span>
        <span class="s5"># `ets`</span>
        <span class="s1">start_params = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s4">2.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9</span><span class="s1">]</span>
        <span class="s1">mle_res = self.res.model.fit(start_params</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">assert_(self.res.llf &lt;= mle_res.llf)</span>


<span class="s2">class </span><span class="s1">CheckKnownInitialization:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">start_params):</span>
        <span class="s5"># Base model, with estimated initialization</span>
        <span class="s5"># Note: we use start_params here that are pretty close to MLE so that</span>
        <span class="s5"># tests run quicker.</span>
        <span class="s1">cls.mod = mod</span>
        <span class="s1">cls.start_params = start_params</span>
        <span class="s1">endog = mod.data.orig_endog</span>
        <span class="s1">cls.res = cls.mod.fit(start_params</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s5"># Get the estimated initial parameters</span>
        <span class="s1">cls.initial_level = cls.res.params.get(</span><span class="s3">'initial_level'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">cls.initial_trend = cls.res.params.get(</span><span class="s3">'initial_trend'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">cls.initial_seasonal = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">cls.mod.seasonal:</span>
            <span class="s1">cls.initial_seasonal = (</span>
                <span class="s1">[cls.res.params[</span><span class="s3">'initial_seasonal'</span><span class="s1">]]</span>
                <span class="s1">+ [cls.res.params[</span><span class="s3">'initial_seasonal.L%d' </span><span class="s1">% i]</span>
                   <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">cls.mod.seasonal_periods - </span><span class="s4">1</span><span class="s1">)])</span>

        <span class="s5"># Get the estimated parameters</span>
        <span class="s1">cls.params = cls.res.params[:</span><span class="s3">'initial_level'</span><span class="s1">].drop(</span><span class="s3">'initial_level'</span><span class="s1">)</span>
        <span class="s1">cls.init_params = cls.res.params[</span><span class="s3">'initial_level'</span><span class="s1">:]</span>

        <span class="s5"># Create a model with the given known initialization</span>
        <span class="s1">cls.known_mod = cls.mod.clone(endog</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'known'</span><span class="s2">,</span>
                                      <span class="s1">initial_level=cls.initial_level</span><span class="s2">,</span>
                                      <span class="s1">initial_trend=cls.initial_trend</span><span class="s2">,</span>
                                      <span class="s1">initial_seasonal=cls.initial_seasonal)</span>

    <span class="s2">def </span><span class="s1">test_given_params(self):</span>
        <span class="s5"># Test fixed initialization with given parameters</span>
        <span class="s5"># And filter with the given other parameters</span>
        <span class="s1">known_res = self.known_mod.filter(self.params)</span>

        <span class="s1">assert_allclose(known_res.llf</span><span class="s2">, </span><span class="s1">self.res.llf)</span>
        <span class="s1">assert_allclose(known_res.predicted_state</span><span class="s2">, </span><span class="s1">self.res.predicted_state)</span>
        <span class="s1">assert_allclose(known_res.predicted_state_cov</span><span class="s2">,</span>
                        <span class="s1">self.res.predicted_state_cov)</span>
        <span class="s1">assert_allclose(known_res.filtered_state</span><span class="s2">, </span><span class="s1">self.res.filtered_state)</span>

    <span class="s2">def </span><span class="s1">test_estimated_params(self):</span>
        <span class="s5"># Now fit the original model with a fixed initial_level and make sure</span>
        <span class="s5"># that it gives the same result as the fitted second model</span>
        <span class="s1">fit_res1 = self.mod.fit_constrained(</span>
            <span class="s1">self.init_params.to_dict()</span><span class="s2">, </span><span class="s1">start_params=self.start_params</span><span class="s2">,</span>
            <span class="s1">includes_fixed=</span><span class="s2">True, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">fit_res2 = self.known_mod.fit(</span>
            <span class="s1">self.start_params[:</span><span class="s3">'initial_level'</span><span class="s1">].drop(</span><span class="s3">'initial_level'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">fit_res1.params[:</span><span class="s3">'initial_level'</span><span class="s1">].drop(</span><span class="s3">'initial_level'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">fit_res2.params)</span>
        <span class="s1">assert_allclose(fit_res1.llf</span><span class="s2">, </span><span class="s1">fit_res2.llf)</span>
        <span class="s1">assert_allclose(fit_res1.scale</span><span class="s2">, </span><span class="s1">fit_res2.scale)</span>
        <span class="s1">assert_allclose(fit_res1.predicted_state</span><span class="s2">, </span><span class="s1">fit_res2.predicted_state)</span>
        <span class="s1">assert_allclose(fit_res1.predicted_state_cov</span><span class="s2">,</span>
                        <span class="s1">fit_res2.predicted_state_cov)</span>
        <span class="s1">assert_allclose(fit_res1.filtered_state</span><span class="s2">, </span><span class="s1">fit_res2.filtered_state)</span>


<span class="s2">class </span><span class="s1">TestSESKnownInitialization(CheckKnownInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(oildata)</span>
        <span class="s1">start_params = pd.Series([</span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">440.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params)</span>


<span class="s2">class </span><span class="s1">TestHoltKnownInitialization(CheckKnownInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">15.</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params)</span>


<span class="s2">class </span><span class="s1">TestHoltDampedKnownInitialization(CheckKnownInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">14.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersKnownInitialization(CheckKnownInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">0.0004</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">33.</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9.</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersDampedKnownInitialization(CheckKnownInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True,</span>
                                   <span class="s1">seasonal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">0.0004</span><span class="s2">, </span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">17.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.4</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersNoTrendKnownInitialization(CheckKnownInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.49</span><span class="s2">, </span><span class="s4">30.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params)</span>


<span class="s2">class </span><span class="s1">CheckHeuristicInitialization:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">mod):</span>
        <span class="s1">cls.mod = mod</span>
        <span class="s1">cls.res = cls.mod.filter(cls.mod.start_params)</span>

        <span class="s5"># Save the heuristic values</span>
        <span class="s1">init_heuristic = np.r_[cls.mod._initial_level]</span>
        <span class="s2">if </span><span class="s1">cls.mod.trend:</span>
            <span class="s1">init_heuristic = np.r_[init_heuristic</span><span class="s2">, </span><span class="s1">cls.mod._initial_trend]</span>
        <span class="s2">if </span><span class="s1">cls.mod.seasonal:</span>
            <span class="s1">init_heuristic = np.r_[init_heuristic</span><span class="s2">, </span><span class="s1">cls.mod._initial_seasonal]</span>
        <span class="s1">cls.init_heuristic = init_heuristic</span>

        <span class="s5"># Create a model with the given known initialization</span>
        <span class="s1">endog = cls.mod.data.orig_endog</span>
        <span class="s1">initial_seasonal = cls.mod._initial_seasonal</span>
        <span class="s1">cls.known_mod = cls.mod.clone(endog</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'known'</span><span class="s2">,</span>
                                      <span class="s1">initial_level=cls.mod._initial_level</span><span class="s2">,</span>
                                      <span class="s1">initial_trend=cls.mod._initial_trend</span><span class="s2">,</span>
                                      <span class="s1">initial_seasonal=initial_seasonal)</span>
        <span class="s1">cls.known_res = cls.mod.filter(cls.mod.start_params)</span>


<span class="s2">class </span><span class="s1">TestSESHeuristicInitialization(CheckHeuristicInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(oildata</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'heuristic'</span><span class="s1">)</span>
        <span class="s1">super().setup_class(mod)</span>

    <span class="s2">def </span><span class="s1">test_heuristic(self):</span>
        <span class="s5"># See Hyndman et al. (2008), section 2.6</span>
        <span class="s1">nobs = </span><span class="s4">10</span>
        <span class="s1">exog = np.c_[np.ones(nobs)</span><span class="s2">, </span><span class="s1">np.arange(nobs) + </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">desired = np.linalg.pinv(exog).dot(oildata.values[:nobs])[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">assert_allclose(self.init_heuristic</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">class </span><span class="s1">TestHoltHeuristicInitialization(CheckHeuristicInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True,</span>
                                   <span class="s1">initialization_method=</span><span class="s3">'heuristic'</span><span class="s1">)</span>
        <span class="s1">super().setup_class(mod)</span>

    <span class="s2">def </span><span class="s1">test_heuristic(self):</span>
        <span class="s5"># See Hyndman et al. (2008), section 2.6</span>
        <span class="s1">nobs = </span><span class="s4">10</span>
        <span class="s1">exog = np.c_[np.ones(nobs)</span><span class="s2">, </span><span class="s1">np.arange(nobs) + </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">desired = np.linalg.pinv(exog).dot(air.values[:nobs])</span>
        <span class="s1">assert_allclose(self.init_heuristic</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">class </span><span class="s1">TestHoltDampedHeuristicInitialization(CheckHeuristicInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True,</span>
                                   <span class="s1">initialization_method=</span><span class="s3">'heuristic'</span><span class="s1">)</span>
        <span class="s1">super().setup_class(mod)</span>

    <span class="s2">def </span><span class="s1">test_heuristic(self):</span>
        <span class="s1">TestHoltHeuristicInitialization.test_heuristic(self)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersHeuristicInitialization(CheckHeuristicInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">,</span>
                                   <span class="s1">initialization_method=</span><span class="s3">'heuristic'</span><span class="s1">)</span>
        <span class="s1">super().setup_class(mod)</span>

    <span class="s2">def </span><span class="s1">test_heuristic(self):</span>
        <span class="s5"># See Hyndman et al. (2008), section 2.6</span>

        <span class="s5"># Get trend from 2x4 MA filter</span>
        <span class="s1">trend = (aust[:</span><span class="s4">20</span><span class="s1">].rolling(</span><span class="s4">4</span><span class="s1">).mean()</span>
                          <span class="s1">.rolling(</span><span class="s4">2</span><span class="s1">).mean().shift(-</span><span class="s4">2</span><span class="s1">).dropna())</span>
        <span class="s1">nobs = </span><span class="s4">10</span>
        <span class="s1">exog = np.c_[np.ones(nobs)</span><span class="s2">, </span><span class="s1">np.arange(nobs) + </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">desired = np.linalg.pinv(exog).dot(trend[:nobs])</span>
        <span class="s2">if not </span><span class="s1">self.mod.trend:</span>
            <span class="s1">desired = desired[:</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s5"># Get seasonal initial states</span>
        <span class="s1">detrended = aust - trend</span>
        <span class="s1">initial_seasonal = np.nanmean(detrended.values.reshape(</span><span class="s4">6</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s5"># The above command gets seasonals for observations 1, 2, 3, 4.</span>
        <span class="s5"># Lagging these four periods gives us initial seasonals for lags</span>
        <span class="s5"># L3, L2, L1, L0, but the state vector is ordered L0, L1, L2, L3, so we</span>
        <span class="s5"># need to reverse the order of this vector.</span>
        <span class="s1">initial_seasonal = initial_seasonal[::-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">desired = np.r_[desired</span><span class="s2">, </span><span class="s1">initial_seasonal - np.mean(initial_seasonal)]</span>

        <span class="s1">assert_allclose(self.init_heuristic</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersDampedHeuristicInitialization(</span>
        <span class="s1">CheckHeuristicInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True,</span>
                                   <span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">,</span>
                                   <span class="s1">initialization_method=</span><span class="s3">'heuristic'</span><span class="s1">)</span>
        <span class="s1">super().setup_class(mod)</span>

    <span class="s2">def </span><span class="s1">test_heuristic(self):</span>
        <span class="s1">TestHoltWintersHeuristicInitialization.test_heuristic(self)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersNoTrendHeuristicInitialization(</span>
        <span class="s1">CheckHeuristicInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">,</span>
                                   <span class="s1">initialization_method=</span><span class="s3">'heuristic'</span><span class="s1">)</span>
        <span class="s1">super().setup_class(mod)</span>

    <span class="s2">def </span><span class="s1">test_heuristic(self):</span>
        <span class="s1">TestHoltWintersHeuristicInitialization.test_heuristic(self)</span>


<span class="s2">def </span><span class="s1">test_concentrated_initialization():</span>
    <span class="s5"># Compare a model where initialization is concentrated out versus</span>
    <span class="s5"># numarical maximum likelihood estimation</span>
    <span class="s1">mod1 = ExponentialSmoothing(oildata</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'concentrated'</span><span class="s1">)</span>
    <span class="s1">mod2 = ExponentialSmoothing(oildata)</span>

    <span class="s5"># First, fix the other parameters at a particular value</span>
    <span class="s1">res1 = mod1.filter([</span><span class="s4">0.1</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.fit_constrained({</span><span class="s3">'smoothing_level'</span><span class="s1">: </span><span class="s4">0.1</span><span class="s1">}</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s5"># Alternatively, estimate the remaining parameters</span>
    <span class="s1">res1 = mod1.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.fit(disp=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">assert_allclose(res1.llf</span><span class="s2">, </span><span class="s1">res2.llf)</span>
    <span class="s1">assert_allclose(res1.initial_state</span><span class="s2">, </span><span class="s1">res2.initial_state</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">CheckConcentratedInitialization:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">mod</span><span class="s2">, </span><span class="s1">start_params=</span><span class="s2">None, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">):</span>
        <span class="s5"># Note: because of the different computations methods (linear</span>
        <span class="s5"># regression in the concentrated case versus numerical MLE in the base</span>
        <span class="s5"># case), we have relatively large tolerances for these tests,</span>
        <span class="s5"># particularly when the other parameters are estimated, and we specify</span>
        <span class="s5"># start parameters relatively close to the MLE to avoid problems with</span>
        <span class="s5"># the methods finding different local maxima.</span>
        <span class="s1">cls.start_params = start_params</span>
        <span class="s1">cls.atol = atol</span>
        <span class="s1">cls.rtol = rtol</span>

        <span class="s5"># Compare a model where initialization is concentrated out versus</span>
        <span class="s5"># numarical maximum likelihood estimation</span>
        <span class="s1">cls.mod = mod</span>
        <span class="s1">cls.conc_mod = mod.clone(mod.data.orig_endog</span><span class="s2">,</span>
                                 <span class="s1">initialization_method=</span><span class="s3">'concentrated'</span><span class="s1">)</span>

        <span class="s5"># Generate some fixed parameters</span>
        <span class="s1">cls.params = pd.Series([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.95</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span>
            <span class="s3">'smoothing_level'</span><span class="s2">, </span><span class="s3">'smoothing_trend'</span><span class="s2">, </span><span class="s3">'smoothing_seasonal'</span><span class="s2">,</span>
            <span class="s3">'damping_trend'</span><span class="s1">])</span>

        <span class="s1">drop = []</span>
        <span class="s2">if not </span><span class="s1">cls.mod.trend:</span>
            <span class="s1">drop += [</span><span class="s3">'smoothing_trend'</span><span class="s2">, </span><span class="s3">'damping_trend'</span><span class="s1">]</span>
        <span class="s2">elif not </span><span class="s1">cls.mod.damped_trend:</span>
            <span class="s1">drop += [</span><span class="s3">'damping_trend'</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">cls.mod.seasonal:</span>
            <span class="s1">drop += [</span><span class="s3">'smoothing_seasonal'</span><span class="s1">]</span>
        <span class="s1">cls.params.drop(drop</span><span class="s2">, </span><span class="s1">inplace=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_given_params(self):</span>
        <span class="s5"># First, fix the other parameters at a particular value</span>
        <span class="s5"># (for the non-concentrated model, we need to fit the inital values</span>
        <span class="s5"># directly by MLE)</span>
        <span class="s1">res = self.mod.fit_constrained(self.params.to_dict()</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">conc_res = self.conc_mod.filter(self.params.values)</span>

        <span class="s1">assert_allclose(conc_res.llf</span><span class="s2">, </span><span class="s1">res.llf</span><span class="s2">, </span><span class="s1">atol=self.atol</span><span class="s2">, </span><span class="s1">rtol=self.rtol)</span>
        <span class="s1">assert_allclose(conc_res.initial_state</span><span class="s2">, </span><span class="s1">res.initial_state</span><span class="s2">,</span>
                        <span class="s1">atol=self.atol</span><span class="s2">, </span><span class="s1">rtol=self.rtol)</span>

    <span class="s2">def </span><span class="s1">test_estimated_params(self):</span>
        <span class="s5"># Alternatively, estimate the remaining parameters</span>
        <span class="s1">res = self.mod.fit(self.start_params</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">np.set_printoptions(suppress=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">conc_res = self.conc_mod.fit(self.start_params[:len(self.params)]</span><span class="s2">,</span>
                                     <span class="s1">disp=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">assert_allclose(conc_res.llf</span><span class="s2">, </span><span class="s1">res.llf</span><span class="s2">, </span><span class="s1">atol=self.atol</span><span class="s2">, </span><span class="s1">rtol=self.rtol)</span>
        <span class="s1">assert_allclose(conc_res.initial_state</span><span class="s2">, </span><span class="s1">res.initial_state</span><span class="s2">,</span>
                        <span class="s1">atol=self.atol</span><span class="s2">, </span><span class="s1">rtol=self.rtol)</span>


<span class="s2">class </span><span class="s1">TestSESConcentratedInitialization(CheckConcentratedInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(oildata)</span>
        <span class="s1">start_params = pd.Series([</span><span class="s4">0.85</span><span class="s2">, </span><span class="s4">447.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params=start_params</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHoltConcentratedInitialization(CheckConcentratedInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">15.</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params=start_params</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHoltDampedConcentratedInitialization(</span>
        <span class="s1">CheckConcentratedInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(air</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0005</span><span class="s2">,  </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">15.</span><span class="s2">,  </span><span class="s4">2.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params=start_params</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersConcentratedInitialization(</span>
        <span class="s1">CheckConcentratedInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">0.0004</span><span class="s2">, </span><span class="s4">0.0002</span><span class="s2">, </span><span class="s4">33.</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">2.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9.3</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params=start_params</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersDampedConcentratedInitialization(</span>
        <span class="s1">CheckConcentratedInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">damped_trend=</span><span class="s2">True,</span>
                                   <span class="s1">seasonal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">0.0004</span><span class="s2">, </span><span class="s4">0.0005</span><span class="s2">, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">17.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.4</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params=start_params</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHoltWintersNoTrendConcentratedInitialization(</span>
        <span class="s1">CheckConcentratedInitialization):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">start_params = pd.Series(</span>
            <span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.49</span><span class="s2">, </span><span class="s4">32.</span><span class="s2">, </span><span class="s4">2.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=mod.param_names)</span>
        <span class="s1">super().setup_class(mod</span><span class="s2">, </span><span class="s1">start_params=start_params</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMultiIndex(CheckExponentialSmoothing):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">oildata_copy = oildata.copy()</span>
        <span class="s1">oildata_copy.name = (</span><span class="s3">&quot;oil&quot;</span><span class="s2">, </span><span class="s3">&quot;data&quot;</span><span class="s1">)</span>
        <span class="s1">mod = ExponentialSmoothing(oildata_copy</span><span class="s2">,</span>
                                   <span class="s1">initialization_method=</span><span class="s3">'simple'</span><span class="s1">)</span>
        <span class="s1">res = mod.filter([results_params[</span><span class="s3">'oil_fpp2'</span><span class="s1">][</span><span class="s3">'alpha'</span><span class="s1">]])</span>

        <span class="s1">super().setup_class(</span><span class="s3">'oil_fpp2'</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s2">def </span><span class="s1">test_conf_int(self):</span>
        <span class="s5"># Forecast confidence intervals</span>
        <span class="s1">ci_95 = self.forecast.conf_int(alpha=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">lower = results_predict[</span><span class="s3">'%s_lower' </span><span class="s1">% self.name]</span>
        <span class="s1">upper = results_predict[</span><span class="s3">'%s_upper' </span><span class="s1">% self.name]</span>
        <span class="s1">assert_allclose(ci_95[</span><span class="s3">&quot;lower ('oil', 'data')&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">lower.iloc[self.nobs:])</span>
        <span class="s1">assert_allclose(ci_95[</span><span class="s3">&quot;upper ('oil', 'data')&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">upper.iloc[self.nobs:])</span>


<span class="s2">def </span><span class="s1">test_invalid():</span>
    <span class="s5"># Tests for invalid model specifications that raise ValueErrors</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">'Cannot have a seasonal period of 1.'</span><span class="s1">):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=(</span>
            <span class="s3">'seasonal must be integer_like'</span>
            <span class="s3">r' \(int or np.integer, but not bool or timedelta64\) or None'</span><span class="s1">)):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">'Invalid initialization method &quot;invalid&quot;.'</span><span class="s1">):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'invalid'</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=(</span>
            <span class="s3">'`initial_level` argument must be provided'</span>
            <span class="s3">' when initialization method is set to'</span>
            <span class="s3">' &quot;known&quot;.'</span><span class="s1">)):</span>
        <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'known'</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=(</span>
            <span class="s3">'`initial_trend` argument must be provided'</span>
            <span class="s3">' for models with a trend component when'</span>
            <span class="s3">' initialization method is set to &quot;known&quot;.'</span><span class="s1">)):</span>
        <span class="s1">mod = ExponentialSmoothing(</span>
            <span class="s1">aust</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">True, </span><span class="s1">initialization_method=</span><span class="s3">'known'</span><span class="s2">, </span><span class="s1">initial_level=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=(</span>
            <span class="s3">'`initial_seasonal` argument must be provided'</span>
            <span class="s3">' for models with a seasonal component when'</span>
            <span class="s3">' initialization method is set to &quot;known&quot;.'</span><span class="s1">)):</span>
        <span class="s1">mod = ExponentialSmoothing(</span>
            <span class="s1">aust</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'known'</span><span class="s2">, </span><span class="s1">initial_level=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'initial_level'</span><span class="s2">, </span><span class="s3">'initial_trend'</span><span class="s2">, </span><span class="s3">'initial_seasonal'</span><span class="s1">]:</span>
        <span class="s1">msg = (</span><span class="s3">'Cannot give `%s` argument when initialization is &quot;estimated&quot;'</span>
               <span class="s1">% arg)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">mod = ExponentialSmoothing(aust</span><span class="s2">, </span><span class="s1">**{arg: </span><span class="s4">0</span><span class="s1">})</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=(</span>
            <span class="s3">'Invalid length of initial seasonal values. Must be'</span>
            <span class="s3">' one of s or s-1, where s is the number of seasonal'</span>
            <span class="s3">' periods.'</span><span class="s1">)):</span>
        <span class="s1">mod = ExponentialSmoothing(</span>
            <span class="s1">aust</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">'known'</span><span class="s2">, </span><span class="s1">initial_level=</span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">initial_seasonal=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">,</span>
                       <span class="s1">match=</span><span class="s3">'ExponentialSmoothing does not support `exog`.'</span><span class="s1">):</span>
        <span class="s1">mod = ExponentialSmoothing(aust)</span>
        <span class="s1">mod.clone(aust</span><span class="s2">, </span><span class="s1">exog=air)</span>


<span class="s2">def </span><span class="s1">test_parameterless_model(reset_randomstate):</span>
    <span class="s5"># GH 6687</span>
    <span class="s1">x = np.cumsum(np.random.standard_normal(</span><span class="s4">1000</span><span class="s1">))</span>
    <span class="s1">ses = ExponentialSmoothing(x</span><span class="s2">, </span><span class="s1">initial_level=x[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">initialization_method=</span><span class="s3">&quot;known&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">ses.fix_params({</span><span class="s3">'smoothing_level'</span><span class="s1">: </span><span class="s4">0.5</span><span class="s1">}):</span>
        <span class="s1">res = ses.fit()</span>
    <span class="s2">assert </span><span class="s1">np.isnan(res.bse).all()</span>
    <span class="s2">assert </span><span class="s1">res.fixed_params == [</span><span class="s3">&quot;smoothing_level&quot;</span><span class="s1">]</span>
</pre>
</body>
</html>