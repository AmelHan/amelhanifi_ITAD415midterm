<html>
<head>
<title>bspline.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bspline.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
Bspines and smoothing splines. 
 
General references: 
 
    Craven, P. and Wahba, G. (1978) &quot;Smoothing noisy data with spline functions. 
    Estimating the correct degree of smoothing by 
    the method of generalized cross-validation.&quot; 
    Numerische Mathematik, 31(4), 377-403. 
 
    Hastie, Tibshirani and Friedman (2001). &quot;The Elements of Statistical 
    Learning.&quot; Springer-Verlag. 536 pages. 
 
    Hutchison, M. and Hoog, F. &quot;Smoothing noisy data with spline functions.&quot; 
    Numerische Mathematik, 47(1), 99-106. 
'''</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">numpy.linalg </span><span class="s2">as </span><span class="s1">L</span>

<span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">solveh_banded</span>
<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">golden</span>
<span class="s2">from </span><span class="s1">models </span><span class="s2">import </span><span class="s1">_hbspline     </span><span class="s3">#removed because this was segfaulting</span>

<span class="s3"># Issue warning regarding heavy development status of this module</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s1">_msg = </span><span class="s4">&quot;&quot;&quot; 
The bspline code is technology preview and requires significant work 
on the public API and documentation. The API will likely change in the future 
&quot;&quot;&quot;</span>
<span class="s1">warnings.warn(_msg</span><span class="s2">, </span><span class="s1">FutureWarning)</span>


<span class="s2">def </span><span class="s1">_band2array(a</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">symmetric=</span><span class="s2">False, </span><span class="s1">hermitian=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Take an upper or lower triangular banded matrix and return a 
    numpy array. 
 
    INPUTS: 
       a         -- a matrix in upper or lower triangular banded matrix 
       lower     -- is the matrix upper or lower triangular? 
       symmetric -- if True, return the original result plus its transpose 
       hermitian -- if True (and symmetric False), return the original 
                    result plus its conjugate transposed 
    &quot;&quot;&quot;</span>

    <span class="s1">n = a.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">r = a.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">_a = </span><span class="s5">0</span>

    <span class="s2">if not </span><span class="s1">lower:</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(r):</span>
            <span class="s1">_b = np.diag(a[r-</span><span class="s5">1</span><span class="s1">-j]</span><span class="s2">,</span><span class="s1">k=j)[j:(n+j)</span><span class="s2">,</span><span class="s1">j:(n+j)]</span>
            <span class="s1">_a += _b</span>
            <span class="s2">if </span><span class="s1">symmetric </span><span class="s2">and </span><span class="s1">j &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">_a += _b.T</span>
            <span class="s2">elif </span><span class="s1">hermitian </span><span class="s2">and </span><span class="s1">j &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">_a += _b.conjugate().T</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(r):</span>
            <span class="s1">_b = np.diag(a[j]</span><span class="s2">,</span><span class="s1">k=j)[</span><span class="s5">0</span><span class="s1">:n</span><span class="s2">,</span><span class="s5">0</span><span class="s1">:n]</span>
            <span class="s1">_a += _b</span>
            <span class="s2">if </span><span class="s1">symmetric </span><span class="s2">and </span><span class="s1">j &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">_a += _b.T</span>
            <span class="s2">elif </span><span class="s1">hermitian </span><span class="s2">and </span><span class="s1">j &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">_a += _b.conjugate().T</span>
        <span class="s1">_a = _a.T</span>

    <span class="s2">return </span><span class="s1">_a</span>


<span class="s2">def </span><span class="s1">_upper2lower(ub):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert upper triangular banded matrix to lower banded form. 
 
    INPUTS: 
       ub  -- an upper triangular banded matrix 
 
    OUTPUTS: lb 
       lb  -- a lower triangular banded matrix with same entries 
              as ub 
    &quot;&quot;&quot;</span>

    <span class="s1">lb = np.zeros(ub.shape</span><span class="s2">, </span><span class="s1">ub.dtype)</span>
    <span class="s1">nrow</span><span class="s2">, </span><span class="s1">ncol = ub.shape</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(ub.shape[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s1">lb[i</span><span class="s2">,</span><span class="s5">0</span><span class="s1">:(ncol-i)] = ub[nrow-</span><span class="s5">1</span><span class="s1">-i</span><span class="s2">,</span><span class="s1">i:ncol]</span>
        <span class="s1">lb[i</span><span class="s2">,</span><span class="s1">(ncol-i):] = ub[nrow-</span><span class="s5">1</span><span class="s1">-i</span><span class="s2">,</span><span class="s5">0</span><span class="s1">:i]</span>
    <span class="s2">return </span><span class="s1">lb</span>

<span class="s2">def </span><span class="s1">_lower2upper(lb):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert lower triangular banded matrix to upper banded form. 
 
    INPUTS: 
       lb  -- a lower triangular banded matrix 
 
    OUTPUTS: ub 
       ub  -- an upper triangular banded matrix with same entries 
              as lb 
    &quot;&quot;&quot;</span>

    <span class="s1">ub = np.zeros(lb.shape</span><span class="s2">, </span><span class="s1">lb.dtype)</span>
    <span class="s1">nrow</span><span class="s2">, </span><span class="s1">ncol = lb.shape</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(lb.shape[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s1">ub[nrow-</span><span class="s5">1</span><span class="s1">-i</span><span class="s2">,</span><span class="s1">i:ncol] = lb[i</span><span class="s2">,</span><span class="s5">0</span><span class="s1">:(ncol-i)]</span>
        <span class="s1">ub[nrow-</span><span class="s5">1</span><span class="s1">-i</span><span class="s2">,</span><span class="s5">0</span><span class="s1">:i] = lb[i</span><span class="s2">,</span><span class="s1">(ncol-i):]</span>
    <span class="s2">return </span><span class="s1">ub</span>

<span class="s2">def </span><span class="s1">_triangle2unit(tb</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Take a banded triangular matrix and return its diagonal and the 
    unit matrix: the banded triangular matrix with 1's on the diagonal, 
    i.e. each row is divided by the corresponding entry on the diagonal. 
 
    INPUTS: 
       tb    -- a lower triangular banded matrix 
       lower -- if True, then tb is assumed to be lower triangular banded, 
                in which case return value is also lower triangular banded. 
 
    OUTPUTS: d, b 
       d     -- diagonal entries of tb 
       b     -- unit matrix: if lower is False, b is upper triangular 
                banded and its rows of have been divided by d, 
                else lower is True, b is lower triangular banded 
                and its columns have been divieed by d. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">lower:</span>
        <span class="s1">d = tb[</span><span class="s5">0</span><span class="s1">].copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">d = tb[-</span><span class="s5">1</span><span class="s1">].copy()</span>

    <span class="s2">if </span><span class="s1">lower:</span>
        <span class="s2">return </span><span class="s1">d</span><span class="s2">, </span><span class="s1">(tb / d)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lnum = _upper2lower(tb)</span>
        <span class="s2">return </span><span class="s1">d</span><span class="s2">, </span><span class="s1">_lower2upper(lnum / d)</span>


<span class="s2">def </span><span class="s1">_trace_symbanded(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the trace(ab) for two upper or banded real symmetric matrices 
    stored either in either upper or lower form. 
 
    INPUTS: 
       a, b    -- two banded real symmetric matrices (either lower or upper) 
       lower   -- if True, a and b are assumed to be the lower half 
 
 
    OUTPUTS: trace 
       trace   -- trace(ab) 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">lower:</span>
        <span class="s1">t = _zero_triband(a * b</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">t[</span><span class="s5">0</span><span class="s1">].sum() + </span><span class="s5">2 </span><span class="s1">* t[</span><span class="s5">1</span><span class="s1">:].sum()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">t = _zero_triband(a * b</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">t[-</span><span class="s5">1</span><span class="s1">].sum() + </span><span class="s5">2 </span><span class="s1">* t[:-</span><span class="s5">1</span><span class="s1">].sum()</span>


<span class="s2">def </span><span class="s1">_zero_triband(a</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Explicitly zero out unused elements of a real symmetric banded matrix. 
 
    INPUTS: 
       a   -- a real symmetric banded matrix (either upper or lower hald) 
       lower   -- if True, a is assumed to be the lower half 
    &quot;&quot;&quot;</span>

    <span class="s1">nrow</span><span class="s2">, </span><span class="s1">ncol = a.shape</span>
    <span class="s2">if </span><span class="s1">lower:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nrow):</span>
            <span class="s1">a[i</span><span class="s2">, </span><span class="s1">(ncol-i):] = </span><span class="s5">0.</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nrow):</span>
            <span class="s1">a[i</span><span class="s2">, </span><span class="s5">0</span><span class="s1">:i] = </span><span class="s5">0.</span>
    <span class="s2">return </span><span class="s1">a</span>


<span class="s2">class </span><span class="s1">BSpline:</span>

    <span class="s0">''' 
 
    Bsplines of a given order and specified knots. 
 
    Implementation is based on description in Chapter 5 of 
 
    Hastie, Tibshirani and Friedman (2001). &quot;The Elements of Statistical 
    Learning.&quot; Springer-Verlag. 536 pages. 
 
 
    INPUTS: 
       knots  -- a sorted array of knots with knots[0] the lower boundary, 
                 knots[1] the upper boundary and knots[1:-1] the internal 
                 knots. 
       order  -- order of the Bspline, default is 4 which yields cubic 
                 splines 
       M      -- number of additional boundary knots, if None it defaults 
                 to order 
       coef   -- an optional array of real-valued coefficients for the Bspline 
                 of shape (knots.shape + 2 * (M - 1) - order,). 
       x      -- an optional set of x values at which to evaluate the 
                 Bspline to avoid extra evaluation in the __call__ method 
 
    '''</span>
    <span class="s3"># FIXME: update parameter names, replace single character names</span>
    <span class="s3"># FIXME: `order` should be actual spline order (implemented as order+1)</span>
    <span class="s3">## FIXME: update the use of spline order in extension code (evaluate is recursively called)</span>
    <span class="s3"># FIXME: eliminate duplicate M and m attributes (m is order, M is related to tau size)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">, </span><span class="s1">order=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">M=</span><span class="s2">None, </span><span class="s1">coef=</span><span class="s2">None, </span><span class="s1">x=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">knots = np.squeeze(np.unique(np.asarray(knots)))</span>

        <span class="s2">if </span><span class="s1">knots.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'expecting 1d array for knots'</span><span class="s1">)</span>

        <span class="s1">self.m = order</span>
        <span class="s2">if </span><span class="s1">M </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">M = self.m</span>
        <span class="s1">self.M = M</span>

        <span class="s1">self.tau = np.hstack([[knots[</span><span class="s5">0</span><span class="s1">]]*(self.M-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">, </span><span class="s1">[knots[-</span><span class="s5">1</span><span class="s1">]]*(self.M-</span><span class="s5">1</span><span class="s1">)])</span>

        <span class="s1">self.K = knots.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">2</span>
        <span class="s2">if </span><span class="s1">coef </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.coef = np.zeros((self.K + </span><span class="s5">2 </span><span class="s1">* self.M - self.m)</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.coef = np.squeeze(coef)</span>
            <span class="s2">if </span><span class="s1">self.coef.shape != (self.K + </span><span class="s5">2 </span><span class="s1">* self.M - self.m):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'coefficients of Bspline have incorrect shape'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.x = x</span>

    <span class="s2">def </span><span class="s1">_setx(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">self._x = x</span>
        <span class="s1">self._basisx = self.basis(self._x)</span>

    <span class="s2">def </span><span class="s1">_getx(self):</span>
        <span class="s2">return </span><span class="s1">self._x</span>

    <span class="s1">x = property(_getx</span><span class="s2">, </span><span class="s1">_setx)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the BSpline at a given point, yielding 
        a matrix B and return 
 
        B * self.coef 
 
 
        INPUTS: 
           args -- optional arguments. If None, it returns self._basisx, 
                   the BSpline evaluated at the x values passed in __init__. 
                   Otherwise, return the BSpline evaluated at the 
                   first argument args[0]. 
 
        OUTPUTS: y 
           y    -- value of Bspline at specified x values 
 
        BUGS: 
           If self has no attribute x, an exception will be raised 
           because self has no attribute _basisx. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">args:</span>
            <span class="s1">b = self._basisx.T</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x = args[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">b = np.asarray(self.basis(x)).T</span>
        <span class="s2">return </span><span class="s1">np.squeeze(np.dot(b</span><span class="s2">, </span><span class="s1">self.coef))</span>

    <span class="s2">def </span><span class="s1">basis_element(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">d=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate a particular basis element of the BSpline, 
        or its derivative. 
 
        INPUTS: 
           x  -- x values at which to evaluate the basis element 
           i  -- which element of the BSpline to return 
           d  -- the order of derivative 
 
        OUTPUTS: y 
           y  -- value of d-th derivative of the i-th basis element 
                 of the BSpline at specified x values 
        &quot;&quot;&quot;</span>

        <span class="s1">x = np.asarray(x</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">_shape = x.shape</span>
        <span class="s2">if </span><span class="s1">_shape == ():</span>
            <span class="s1">x.shape = (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">x.shape = (np.product(_shape</span><span class="s2">,</span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">i &lt; self.tau.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3"># TODO: OWNDATA flags...</span>
            <span class="s1">v = _hbspline.evaluate(x</span><span class="s2">, </span><span class="s1">self.tau</span><span class="s2">, </span><span class="s1">self.m</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">i+</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.zeros(x.shape</span><span class="s2">, </span><span class="s1">np.float64)</span>

        <span class="s2">if </span><span class="s1">(i == self.tau.shape[</span><span class="s5">0</span><span class="s1">] - self.m):</span>
            <span class="s1">v = np.where(np.equal(x</span><span class="s2">, </span><span class="s1">self.tau[-</span><span class="s5">1</span><span class="s1">])</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">v)</span>
        <span class="s1">v.shape = _shape</span>
        <span class="s2">return </span><span class="s1">v</span>

    <span class="s2">def </span><span class="s1">basis(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">d=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">lower=</span><span class="s2">None, </span><span class="s1">upper=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the basis of the BSpline or its derivative. 
        If lower or upper is specified, then only 
        the [lower:upper] elements of the basis are returned. 
 
        INPUTS: 
           x     -- x values at which to evaluate the basis element 
           i     -- which element of the BSpline to return 
           d     -- the order of derivative 
           lower -- optional lower limit of the set of basis 
                    elements 
           upper -- optional upper limit of the set of basis 
                    elements 
 
        OUTPUTS: y 
           y  -- value of d-th derivative of the basis elements 
                 of the BSpline at specified x values 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s1">_shape = x.shape</span>
        <span class="s2">if </span><span class="s1">_shape == ():</span>
            <span class="s1">x.shape = (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">x.shape = (np.product(_shape</span><span class="s2">,</span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">upper </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">upper = self.tau.shape[</span><span class="s5">0</span><span class="s1">] - self.m</span>
        <span class="s2">if </span><span class="s1">lower </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lower = </span><span class="s5">0</span>
        <span class="s1">upper = min(upper</span><span class="s2">, </span><span class="s1">self.tau.shape[</span><span class="s5">0</span><span class="s1">] - self.m)</span>
        <span class="s1">lower = max(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">lower)</span>

        <span class="s1">d = np.asarray(d)</span>
        <span class="s2">if </span><span class="s1">d.shape == ():</span>
            <span class="s1">v = _hbspline.evaluate(x</span><span class="s2">, </span><span class="s1">self.tau</span><span class="s2">, </span><span class="s1">self.m</span><span class="s2">, </span><span class="s1">int(d)</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">, </span><span class="s1">upper)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">d.shape[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;if d is not an integer, expecting a jx2 </span><span class="s2">\ 
                   </span><span class="s4">array with first row indicating order </span><span class="s2">\ 
                   </span><span class="s4">of derivative, second row coefficient in front.&quot;</span><span class="s1">)</span>
            <span class="s1">v = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(d.shape[</span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s1">v += d[</span><span class="s5">1</span><span class="s2">,</span><span class="s1">i] * _hbspline.evaluate(x</span><span class="s2">, </span><span class="s1">self.tau</span><span class="s2">, </span><span class="s1">self.m</span><span class="s2">, </span><span class="s1">d[</span><span class="s5">0</span><span class="s2">,</span><span class="s1">i]</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">, </span><span class="s1">upper)</span>

        <span class="s1">v.shape = (upper-lower</span><span class="s2">,</span><span class="s1">) + _shape</span>
        <span class="s2">if </span><span class="s1">upper == self.tau.shape[</span><span class="s5">0</span><span class="s1">] - self.m:</span>
            <span class="s1">v[-</span><span class="s5">1</span><span class="s1">] = np.where(np.equal(x</span><span class="s2">, </span><span class="s1">self.tau[-</span><span class="s5">1</span><span class="s1">])</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">v[-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">v</span>

    <span class="s2">def </span><span class="s1">gram(self</span><span class="s2">, </span><span class="s1">d=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute Gram inner product matrix, storing it in lower 
        triangular banded form. 
 
        The (i,j) entry is 
 
        G_ij = integral b_i^(d) b_j^(d) 
 
        where b_i are the basis elements of the BSpline and (d) is the 
        d-th derivative. 
 
        If d is a matrix then, it is assumed to specify a differential 
        operator as follows: the first row represents the order of derivative 
        with the second row the coefficient corresponding to that order. 
 
        For instance: 
 
        [[2, 3], 
         [3, 1]] 
 
        represents 3 * f^(2) + 1 * f^(3). 
 
        INPUTS: 
           d    -- which derivative to apply to each basis element, 
                   if d is a matrix, it is assumed to specify 
                   a differential operator as above 
 
        OUTPUTS: gram 
           gram -- the matrix of inner products of (derivatives) 
                   of the BSpline elements 
        &quot;&quot;&quot;</span>

        <span class="s1">d = np.squeeze(d)</span>
        <span class="s2">if </span><span class="s1">np.asarray(d).shape == ():</span>
            <span class="s1">self.g = _hbspline.gram(self.tau</span><span class="s2">, </span><span class="s1">self.m</span><span class="s2">, </span><span class="s1">int(d)</span><span class="s2">, </span><span class="s1">int(d))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">d = np.asarray(d)</span>
            <span class="s2">if </span><span class="s1">d.shape[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;if d is not an integer, expecting a jx2 </span><span class="s2">\ 
                   </span><span class="s4">array with first row indicating order </span><span class="s2">\ 
                   </span><span class="s4">of derivative, second row coefficient in front.&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">d.shape == (</span><span class="s5">2</span><span class="s2">,</span><span class="s1">):</span>
                <span class="s1">d.shape = (</span><span class="s5">2</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self.g = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(d.shape[</span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(d.shape[</span><span class="s5">1</span><span class="s1">]):</span>
                    <span class="s1">self.g += d[</span><span class="s5">1</span><span class="s2">,</span><span class="s1">i]* d[</span><span class="s5">1</span><span class="s2">,</span><span class="s1">j] * _hbspline.gram(self.tau</span><span class="s2">, </span><span class="s1">self.m</span><span class="s2">, </span><span class="s1">int(d[</span><span class="s5">0</span><span class="s2">,</span><span class="s1">i])</span><span class="s2">, </span><span class="s1">int(d[</span><span class="s5">0</span><span class="s2">,</span><span class="s1">j]))</span>
        <span class="s1">self.g = self.g.T</span>
        <span class="s1">self.d = d</span>
        <span class="s2">return </span><span class="s1">np.nan_to_num(self.g)</span>

<span class="s2">class </span><span class="s1">SmoothingSpline(BSpline):</span>

    <span class="s1">penmax = </span><span class="s5">30.</span>
    <span class="s1">method = </span><span class="s4">&quot;target_df&quot;</span>
    <span class="s1">target_df = </span><span class="s5">5</span>
    <span class="s1">default_pen = </span><span class="s5">1.0e-03</span>
    <span class="s1">optimize = </span><span class="s2">True</span>

    <span class="s4">''' 
    A smoothing spline, which can be used to smooth scatterplots, i.e. 
    a list of (x,y) tuples. 
 
    See fit method for more information. 
 
    '''</span>

    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None, </span><span class="s1">pen=</span><span class="s5">0.</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fit the smoothing spline to a set of (x,y) pairs. 
 
        INPUTS: 
           y       -- response variable 
           x       -- if None, uses self.x 
           weights -- optional array of weights 
           pen     -- constant in front of Gram matrix 
 
        OUTPUTS: None 
           The smoothing spline is determined by self.coef, 
           subsequent calls of __call__ will be the smoothing spline. 
 
        ALGORITHM: 
           Formally, this solves a minimization: 
 
           fhat = ARGMIN_f SUM_i=1^n (y_i-f(x_i))^2 + pen * int f^(2)^2 
 
           int is integral. pen is lambda (from Hastie) 
 
           See Chapter 5 of 
 
           Hastie, Tibshirani and Friedman (2001). &quot;The Elements of Statistical 
           Learning.&quot; Springer-Verlag. 536 pages. 
 
           for more details. 
 
        TODO: 
           Should add arbitrary derivative penalty instead of just 
           second derivative. 
        &quot;&quot;&quot;</span>

        <span class="s1">banded = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">x = self._x</span>
            <span class="s1">bt = self._basisx.copy()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bt = self.basis(x)</span>

        <span class="s2">if </span><span class="s1">pen == </span><span class="s5">0.</span><span class="s1">: </span><span class="s3"># cannot use cholesky for singular matrices</span>
            <span class="s1">banded = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">x.shape != y.shape:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'x and y shape do not agree, by default x are </span><span class="s2">\ 
               </span><span class="s4">the Bspline</span><span class="s2">\'</span><span class="s4">s internal knots'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">pen &gt;= self.penmax:</span>
            <span class="s1">pen = self.penmax</span>


        <span class="s2">if </span><span class="s1">weights </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.weights = weights</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.weights = </span><span class="s5">1.</span>

        <span class="s1">_w = np.sqrt(self.weights)</span>
        <span class="s1">bt *= _w</span>

        <span class="s3"># throw out rows with zeros (this happens at boundary points!)</span>

        <span class="s1">mask = np.flatnonzero(</span><span class="s5">1 </span><span class="s1">- np.all(np.equal(bt</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">))</span>

        <span class="s1">bt = bt[:</span><span class="s2">,</span><span class="s1">mask]</span>
        <span class="s1">y = y[mask]</span>

        <span class="s1">self.df_total = y.shape[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">bty = np.squeeze(np.dot(bt</span><span class="s2">, </span><span class="s1">_w * y))</span>
        <span class="s1">self.N = y.shape[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">if not </span><span class="s1">banded:</span>
            <span class="s1">self.btb = np.dot(bt</span><span class="s2">, </span><span class="s1">bt.T)</span>
            <span class="s1">_g = _band2array(self.g</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">symmetric=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.coef</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">self.rank = L.lstsq(self.btb + pen*_g</span><span class="s2">, </span><span class="s1">bty)[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span>
            <span class="s1">self.rank = min(self.rank</span><span class="s2">, </span><span class="s1">self.btb.shape[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s2">del </span><span class="s1">_g</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.btb = np.zeros(self.g.shape</span><span class="s2">, </span><span class="s1">np.float64)</span>
            <span class="s1">nband</span><span class="s2">, </span><span class="s1">nbasis = self.g.shape</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nbasis):</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(min(nband</span><span class="s2">, </span><span class="s1">nbasis-i)):</span>
                    <span class="s1">self.btb[k</span><span class="s2">,</span><span class="s1">i] = (bt[i] * bt[i+k]).sum()</span>

            <span class="s1">bty.shape = (</span><span class="s5">1</span><span class="s2">,</span><span class="s1">bty.shape[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">self.pen = pen</span>
            <span class="s1">self.chol</span><span class="s2">, </span><span class="s1">self.coef = solveh_banded(self.btb +</span>
                                                 <span class="s1">pen*self.g</span><span class="s2">,</span>
                                                 <span class="s1">bty</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">self.coef = np.squeeze(self.coef)</span>
        <span class="s1">self.resid = y * self.weights - np.dot(self.coef</span><span class="s2">, </span><span class="s1">bt)</span>
        <span class="s1">self.pen = pen</span>

        <span class="s2">del </span><span class="s1">bty</span>
        <span class="s2">del </span><span class="s1">mask</span>
        <span class="s2">del </span><span class="s1">bt</span>

    <span class="s2">def </span><span class="s1">smooth(self</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s2">if </span><span class="s1">self.method == </span><span class="s4">&quot;target_df&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s4">'pen'</span><span class="s1">):</span>
                <span class="s1">self.fit(y</span><span class="s2">, </span><span class="s1">x=x</span><span class="s2">, </span><span class="s1">weights=weights</span><span class="s2">, </span><span class="s1">pen=self.pen)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.fit_target_df(y</span><span class="s2">, </span><span class="s1">x=x</span><span class="s2">, </span><span class="s1">weights=weights</span><span class="s2">, </span><span class="s1">df=self.target_df)</span>
        <span class="s2">elif </span><span class="s1">self.method == </span><span class="s4">&quot;optimize_gcv&quot;</span><span class="s1">:</span>
            <span class="s1">self.fit_optimize_gcv(y</span><span class="s2">, </span><span class="s1">x=x</span><span class="s2">, </span><span class="s1">weights=weights)</span>


    <span class="s2">def </span><span class="s1">gcv(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generalized cross-validation score of current fit. 
 
        Craven, P. and Wahba, G.  &quot;Smoothing noisy data with spline functions. 
        Estimating the correct degree of smoothing by 
        the method of generalized cross-validation.&quot; 
        Numerische Mathematik, 31(4), 377-403. 
        &quot;&quot;&quot;</span>

        <span class="s1">norm_resid = (self.resid**</span><span class="s5">2</span><span class="s1">).sum()</span>
        <span class="s2">return </span><span class="s1">norm_resid / (self.df_total - self.trace())</span>

    <span class="s2">def </span><span class="s1">df_resid(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Residual degrees of freedom in the fit. 
 
        self.N - self.trace() 
 
        where self.N is the number of observations of last fit. 
        &quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">self.N - self.trace()</span>

    <span class="s2">def </span><span class="s1">df_fit(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        How many degrees of freedom used in the fit? 
 
        self.trace() 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.trace()</span>

    <span class="s2">def </span><span class="s1">trace(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Trace of the smoothing matrix S(pen) 
 
        TODO: addin a reference to Wahba, and whoever else I used. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.pen &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">_invband = _hbspline.invband(self.chol.copy())</span>
            <span class="s1">tr = _trace_symbanded(_invband</span><span class="s2">, </span><span class="s1">self.btb</span><span class="s2">, </span><span class="s1">lower=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">tr</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.rank</span>

    <span class="s2">def </span><span class="s1">fit_target_df(self</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x=</span><span class="s2">None, </span><span class="s1">df=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None, </span><span class="s1">tol=</span><span class="s5">1.0e-03</span><span class="s2">,</span>
                      <span class="s1">apen=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">bpen=</span><span class="s5">1.0e-03</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fit smoothing spline with approximately df degrees of freedom 
        used in the fit, i.e. so that self.trace() is approximately df. 
 
        Uses binary search strategy. 
 
        In general, df must be greater than the dimension of the null space 
        of the Gram inner product. For cubic smoothing splines, this means 
        that df &gt; 2. 
 
        INPUTS: 
           y       -- response variable 
           x       -- if None, uses self.x 
           df      -- target degrees of freedom 
           weights -- optional array of weights 
           tol     -- (relative) tolerance for convergence 
           apen    -- lower bound of penalty for binary search 
           bpen    -- upper bound of penalty for binary search 
 
        OUTPUTS: None 
           The smoothing spline is determined by self.coef, 
           subsequent calls of __call__ will be the smoothing spline. 
        &quot;&quot;&quot;</span>

        <span class="s1">df = df </span><span class="s2">or </span><span class="s1">self.target_df</span>

        <span class="s1">olddf = y.shape[</span><span class="s5">0</span><span class="s1">] - self.m</span>

        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s4">&quot;pen&quot;</span><span class="s1">):</span>
            <span class="s1">self.fit(y</span><span class="s2">, </span><span class="s1">x=x</span><span class="s2">, </span><span class="s1">weights=weights</span><span class="s2">, </span><span class="s1">pen=self.pen)</span>
            <span class="s1">curdf = self.trace()</span>
            <span class="s2">if </span><span class="s1">np.fabs(curdf - df) / df &lt; tol:</span>
                <span class="s2">return</span>
            <span class="s2">if </span><span class="s1">curdf &gt; df:</span>
                <span class="s1">apen</span><span class="s2">, </span><span class="s1">bpen = self.pen</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* self.pen</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">apen</span><span class="s2">, </span><span class="s1">bpen = </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">self.pen</span>

        <span class="s2">while True</span><span class="s1">:</span>

            <span class="s1">curpen = </span><span class="s5">0.5 </span><span class="s1">* (apen + bpen)</span>
            <span class="s1">self.fit(y</span><span class="s2">, </span><span class="s1">x=x</span><span class="s2">, </span><span class="s1">weights=weights</span><span class="s2">, </span><span class="s1">pen=curpen)</span>
            <span class="s1">curdf = self.trace()</span>
            <span class="s2">if </span><span class="s1">curdf &gt; df:</span>
                <span class="s1">apen</span><span class="s2">, </span><span class="s1">bpen = curpen</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* curpen</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">apen</span><span class="s2">, </span><span class="s1">bpen = apen</span><span class="s2">, </span><span class="s1">curpen</span>
            <span class="s2">if </span><span class="s1">apen &gt;= self.penmax:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;penalty too large, try setting penmax </span><span class="s2">\ 
                   </span><span class="s4">higher or decreasing df&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">np.fabs(curdf - df) / df &lt; tol:</span>
                <span class="s2">break</span>

    <span class="s2">def </span><span class="s1">fit_optimize_gcv(self</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None, </span><span class="s1">tol=</span><span class="s5">1.0e-03</span><span class="s2">,</span>
                         <span class="s1">brack=(-</span><span class="s5">100</span><span class="s2">,</span><span class="s5">20</span><span class="s1">)):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fit smoothing spline trying to optimize GCV. 
 
        Try to find a bracketing interval for scipy.optimize.golden 
        based on bracket. 
 
        It is probably best to use target_df instead, as it is 
        sometimes difficult to find a bracketing interval. 
 
        INPUTS: 
           y       -- response variable 
           x       -- if None, uses self.x 
           df      -- target degrees of freedom 
           weights -- optional array of weights 
           tol     -- (relative) tolerance for convergence 
           brack   -- an initial guess at the bracketing interval 
 
        OUTPUTS: None 
           The smoothing spline is determined by self.coef, 
           subsequent calls of __call__ will be the smoothing spline. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">_gcv(pen</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s1">self.fit(y</span><span class="s2">, </span><span class="s1">x=x</span><span class="s2">, </span><span class="s1">pen=np.exp(pen))</span>
            <span class="s1">a = self.gcv()</span>
            <span class="s2">return </span><span class="s1">a</span>

        <span class="s1">a = golden(_gcv</span><span class="s2">, </span><span class="s1">args=(y</span><span class="s2">,</span><span class="s1">x)</span><span class="s2">, </span><span class="s1">brack=brack</span><span class="s2">, </span><span class="s1">tol=tol)</span>
</pre>
</body>
</html>