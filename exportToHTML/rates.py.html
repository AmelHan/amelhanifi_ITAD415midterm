<html>
<head>
<title>rates.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rates.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
Test for ratio of Poisson intensities in two independent samples 
 
Author: Josef Perktold 
License: BSD-3 
 
'''</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span><span class="s2">, </span><span class="s1">optimize</span>

<span class="s2">from </span><span class="s1">statsmodels.stats.base </span><span class="s2">import </span><span class="s1">HolderTuple</span>
<span class="s2">from </span><span class="s1">statsmodels.stats.weightstats </span><span class="s2">import </span><span class="s1">_zstat_generic2</span>
<span class="s2">from </span><span class="s1">statsmodels.stats._inference_tools </span><span class="s2">import </span><span class="s1">_mover_confint</span>

<span class="s3"># shorthand</span>
<span class="s1">norm = stats.norm</span>


<span class="s1">method_names_poisson_1samp = {</span>
    <span class="s4">&quot;test&quot;</span><span class="s1">: [</span>
        <span class="s4">&quot;wald&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;score&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;exact-c&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;midp-c&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;waldccv&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;sqrt-a&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;sqrt-v&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;sqrt&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;confint&quot;</span><span class="s1">: [</span>
        <span class="s4">&quot;wald&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;score&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;exact-c&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;midp-c&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;jeff&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;waldccv&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;sqrt-a&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;sqrt-v&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;sqrt&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;sqrt-cent&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;sqrt-centcc&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">}</span>


<span class="s2">def </span><span class="s1">test_poisson(count</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">method=</span><span class="s2">None, </span><span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s2">,</span>
                 <span class="s1">dispersion=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Test for one sample poisson mean or rate 
 
    Parameters 
    ---------- 
    count : array_like 
        Observed count, number of events. 
    nobs : arrat_like 
        Currently this is total exposure time of the count variable. 
        This will likely change. 
    value : float, array_like 
        This is the value of poisson rate under the null hypothesis. 
    method : str 
        Method to use for confidence interval. 
        This is required, there is currently no default method. 
        See Notes for available methods. 
    alternative : {'two-sided', 'smaller', 'larger'} 
        alternative hypothesis, which can be two-sided or either one of the 
        one-sided tests. 
    dispersion : float 
        Dispersion scale coefficient for Poisson QMLE. Default is that the 
        data follows a Poisson distribution. Dispersion different from 1 
        correspond to excess-dispersion in Poisson quasi-likelihood (GLM). 
        Dispersion coeffficient different from one is currently only used in 
        wald and score method. 
 
    Returns 
    ------- 
    HolderTuple instance with test statistic, pvalue and other attributes. 
 
    Notes 
    ----- 
    The implementatio of the hypothesis test is mainly based on the references 
    for the confidence interval, see confint_poisson. 
 
    Available methods are: 
 
    - &quot;score&quot; : based on score test, uses variance under null value 
    - &quot;wald&quot; : based on wald test, uses variance base on estimated rate. 
    - &quot;waldccv&quot; : based on wald test with 0.5 count added to variance 
      computation. This does not use continuity correction for the center of 
      the confidence interval. 
    - &quot;exact-c&quot; central confidence interval based on gamma distribution 
    - &quot;midp-c&quot; : based on midp correction of central exact confidence interval. 
      this uses numerical inversion of the test function. not vectorized. 
    - &quot;sqrt&quot; : based on square root transformed counts 
    - &quot;sqrt-a&quot; based on Anscombe square root transformation of counts + 3/8. 
 
    See Also 
    -------- 
    confint_poisson 
 
    &quot;&quot;&quot;</span>

    <span class="s1">n = nobs  </span><span class="s3"># short hand</span>
    <span class="s1">rate = count / n</span>

    <span class="s2">if </span><span class="s1">method </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s4">&quot;method needs to be specified, currently no default method&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">if </span><span class="s1">dispersion != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">&quot;wald&quot;</span><span class="s2">, </span><span class="s4">&quot;waldcc&quot;</span><span class="s2">, </span><span class="s4">&quot;score&quot;</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s4">&quot;excess dispersion only supported in wald and score methods&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s1">dist = </span><span class="s4">&quot;normal&quot;</span>

    <span class="s2">if </span><span class="s1">method == </span><span class="s4">&quot;wald&quot;</span><span class="s1">:</span>
        <span class="s1">std = np.sqrt(dispersion * rate / n)</span>
        <span class="s1">statistic = (rate - value) / std</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;waldccv&quot;</span><span class="s1">:</span>
        <span class="s3"># WCC in Barker 2002</span>
        <span class="s3"># add 0.5 event, not 0.5 event rate as in waldcc</span>
        <span class="s3"># std = np.sqrt((rate + 0.5 / n) / n)</span>
        <span class="s3"># statistic = (rate + 0.5 / n - value) / std</span>
        <span class="s1">std = np.sqrt(dispersion * (rate + </span><span class="s5">0.5 </span><span class="s1">/ n) / n)</span>
        <span class="s1">statistic = (rate - value) / std</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;score&quot;</span><span class="s1">:</span>
        <span class="s1">std = np.sqrt(dispersion * value / n)</span>
        <span class="s1">statistic = (rate - value) / std</span>
        <span class="s1">pvalue = stats.norm.sf(statistic)</span>

    <span class="s2">elif </span><span class="s1">method.startswith(</span><span class="s4">&quot;exact-c&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">method.startswith(</span><span class="s4">&quot;midp-c&quot;</span><span class="s1">):</span>
        <span class="s1">pv1 = stats.poisson.cdf(count</span><span class="s2">, </span><span class="s1">n * value)</span>
        <span class="s1">pv2 = stats.poisson.sf(count - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">n * value)</span>
        <span class="s2">if </span><span class="s1">method.startswith(</span><span class="s4">&quot;midp-c&quot;</span><span class="s1">):</span>
            <span class="s1">pv1 = pv1 - </span><span class="s5">0.5 </span><span class="s1">* stats.poisson.pmf(count</span><span class="s2">, </span><span class="s1">n * value)</span>
            <span class="s1">pv2 = pv2 - </span><span class="s5">0.5 </span><span class="s1">* stats.poisson.pmf(count</span><span class="s2">, </span><span class="s1">n * value)</span>
        <span class="s2">if </span><span class="s1">alternative == </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">:</span>
            <span class="s1">pvalue = </span><span class="s5">2 </span><span class="s1">* np.minimum(pv1</span><span class="s2">, </span><span class="s1">pv2)</span>
        <span class="s2">elif </span><span class="s1">alternative == </span><span class="s4">&quot;larger&quot;</span><span class="s1">:</span>
            <span class="s1">pvalue = pv2</span>
        <span class="s2">elif </span><span class="s1">alternative == </span><span class="s4">&quot;smaller&quot;</span><span class="s1">:</span>
            <span class="s1">pvalue = pv1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">'alternative should be &quot;two-sided&quot;, &quot;larger&quot; or &quot;smaller&quot;'</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">statistic = np.nan</span>
        <span class="s1">dist = </span><span class="s4">&quot;Poisson&quot;</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrt&quot;</span><span class="s1">:</span>
        <span class="s1">std = </span><span class="s5">0.5</span>
        <span class="s1">statistic = (np.sqrt(count) - np.sqrt(n * value)) / std</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrt-a&quot;</span><span class="s1">:</span>
        <span class="s3"># anscombe, based on Swift 2009 (with transformation to rate)</span>
        <span class="s1">std = </span><span class="s5">0.5</span>
        <span class="s1">statistic = (np.sqrt(count + </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8</span><span class="s1">) - np.sqrt(n * value + </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8</span><span class="s1">)) / std</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrt-v&quot;</span><span class="s1">:</span>
        <span class="s3"># vandenbroucke, based on Swift 2009 (with transformation to rate)</span>
        <span class="s1">std = </span><span class="s5">0.5</span>
        <span class="s1">crit = stats.norm.isf(</span><span class="s5">0.025</span><span class="s1">)</span>
        <span class="s1">statistic = (np.sqrt(count + (crit**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">2</span><span class="s1">) / </span><span class="s5">12</span><span class="s1">) -</span>
                     <span class="s3"># np.sqrt(n * value + (crit**2 + 2) / 12)) / std</span>
                     <span class="s1">np.sqrt(n * value)) / std</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unknown method %s&quot; </span><span class="s1">% method)</span>

    <span class="s2">if </span><span class="s1">dist == </span><span class="s4">'normal'</span><span class="s1">:</span>
        <span class="s1">statistic</span><span class="s2">, </span><span class="s1">pvalue = _zstat_generic2(statistic</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">alternative)</span>

    <span class="s1">res = HolderTuple(</span>
        <span class="s1">statistic=statistic</span><span class="s2">,</span>
        <span class="s1">pvalue=np.clip(pvalue</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">distribution=dist</span><span class="s2">,</span>
        <span class="s1">method=method</span><span class="s2">,</span>
        <span class="s1">alternative=alternative</span><span class="s2">,</span>
        <span class="s1">rate=rate</span><span class="s2">,</span>
        <span class="s1">nobs=n</span>
        <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">confint_poisson(count</span><span class="s2">, </span><span class="s1">exposure</span><span class="s2">, </span><span class="s1">method=</span><span class="s2">None, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Confidence interval for a Poisson mean or rate 
 
    The function is vectorized for all methods except &quot;midp-c&quot;, which uses 
    an iterative method to invert the hypothesis test function. 
 
    All current methods are central, that is the probability of each tail is 
    smaller or equal to alpha / 2. The one-sided interval limits can be 
    obtained by doubling alpha. 
 
    Parameters 
    ---------- 
    count : array_like 
        Observed count, number of events. 
    exposure : arrat_like 
        Currently this is total exposure time of the count variable. 
        This will likely change. 
    method : str 
        Method to use for confidence interval 
        This is required, there is currently no default method 
    alpha : float in (0, 1) 
        Significance level, nominal coverage of the confidence interval is 
        1 - alpha. 
 
    Returns 
    ------- 
    tuple (low, upp) : confidence limits. 
 
    Notes 
    ----- 
    Methods are mainly based on Barker (2002) [1]_ and Swift (2009) [3]_. 
 
    Available methods are: 
 
    - &quot;exact-c&quot; central confidence interval based on gamma distribution 
    - &quot;score&quot; : based on score test, uses variance under null value 
    - &quot;wald&quot; : based on wald test, uses variance base on estimated rate. 
    - &quot;waldccv&quot; : based on wald test with 0.5 count added to variance 
      computation. This does not use continuity correction for the center of 
      the confidence interval. 
    - &quot;midp-c&quot; : based on midp correction of central exact confidence interval. 
      this uses numerical inversion of the test function. not vectorized. 
    - &quot;jeffreys&quot; : based on Jeffreys' prior. computed using gamma distribution 
    - &quot;sqrt&quot; : based on square root transformed counts 
    - &quot;sqrt-a&quot; based on Anscombe square root transformation of counts + 3/8. 
    - &quot;sqrt-centcc&quot; will likely be dropped. anscombe with continuity corrected 
      center. 
      (Similar to R survival cipoisson, but without the 3/8 right shift of 
      the confidence interval). 
 
    sqrt-cent is the same as sqrt-a, using a different computation, will be 
    deleted. 
 
    sqrt-v is a corrected square root method attributed to vandenbrouke, which 
    might also be deleted. 
 
    Todo: 
 
    - missing dispersion, 
    - maybe split nobs and exposure (? needed in NB). Exposure could be used 
      to standardize rate. 
    - modified wald, switch method if count=0. 
 
    See Also 
    -------- 
    test_poisson 
 
    References 
    ---------- 
    .. [1] Barker, Lawrence. 2002. “A Comparison of Nine Confidence Intervals 
       for a Poisson Parameter When the Expected Number of Events Is ≤ 5.” 
       The American Statistician 56 (2): 85–89. 
       https://doi.org/10.1198/000313002317572736. 
    .. [2] Patil, VV, and HV Kulkarni. 2012. “Comparison of Confidence 
       Intervals for the Poisson Mean: Some New Aspects.” 
       REVSTAT–Statistical Journal 10(2): 211–27. 
    .. [3] Swift, Michael Bruce. 2009. “Comparison of Confidence Intervals for 
       a Poisson Mean – Further Considerations.” Communications in Statistics - 
       Theory and Methods 38 (5): 748–59. 
       https://doi.org/10.1080/03610920802255856. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n = exposure  </span><span class="s3"># short hand</span>
    <span class="s1">rate = count / exposure</span>
    <span class="s1">alpha = alpha / </span><span class="s5">2  </span><span class="s3"># two-sided</span>

    <span class="s2">if </span><span class="s1">method </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s4">&quot;method needs to be specified, currently no default method&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">if </span><span class="s1">method == </span><span class="s4">&quot;wald&quot;</span><span class="s1">:</span>
        <span class="s1">whalf = stats.norm.isf(alpha) * np.sqrt(rate / n)</span>
        <span class="s1">ci = (rate - whalf</span><span class="s2">, </span><span class="s1">rate + whalf)</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;waldccv&quot;</span><span class="s1">:</span>
        <span class="s3"># based on WCC in Barker 2002</span>
        <span class="s3"># add 0.5 event, not 0.5 event rate as in BARKER waldcc</span>
        <span class="s1">whalf = stats.norm.isf(alpha) * np.sqrt((rate + </span><span class="s5">0.5 </span><span class="s1">/ n) / n)</span>
        <span class="s1">ci = (rate - whalf</span><span class="s2">, </span><span class="s1">rate + whalf)</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;score&quot;</span><span class="s1">:</span>
        <span class="s1">crit = stats.norm.isf(alpha)</span>
        <span class="s1">center = count + crit**</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">2</span>
        <span class="s1">whalf = crit * np.sqrt((count + crit**</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">ci = ((center - whalf) / n</span><span class="s2">, </span><span class="s1">(center + whalf) / n)</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;midp-c&quot;</span><span class="s1">:</span>
        <span class="s3"># note local alpha above is for one tail</span>
        <span class="s1">ci = _invert_test_confint(count</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">2 </span><span class="s1">* alpha</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">&quot;midp-c&quot;</span><span class="s2">,</span>
                                  <span class="s1">method_start=</span><span class="s4">&quot;exact-c&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrt&quot;</span><span class="s1">:</span>
        <span class="s3"># drop, wrong n</span>
        <span class="s1">crit = stats.norm.isf(alpha)</span>
        <span class="s1">center = rate + crit**</span><span class="s5">2 </span><span class="s1">/ (</span><span class="s5">4 </span><span class="s1">* n)</span>
        <span class="s1">whalf = crit * np.sqrt(rate / n)</span>
        <span class="s1">ci = (center - whalf</span><span class="s2">, </span><span class="s1">center + whalf)</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrt-cent&quot;</span><span class="s1">:</span>
        <span class="s1">crit = stats.norm.isf(alpha)</span>
        <span class="s1">center = count + crit**</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">4</span>
        <span class="s1">whalf = crit * np.sqrt((count + </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8</span><span class="s1">))</span>
        <span class="s1">ci = ((center - whalf) / n</span><span class="s2">, </span><span class="s1">(center + whalf) / n)</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrt-centcc&quot;</span><span class="s1">:</span>
        <span class="s3"># drop with cc, does not match cipoisson in R survival</span>
        <span class="s1">crit = stats.norm.isf(alpha)</span>
        <span class="s3"># avoid sqrt of negative value if count=0</span>
        <span class="s1">center_low = np.sqrt(np.maximum(count + </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8 </span><span class="s1">- </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">center_upp = np.sqrt(count + </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8 </span><span class="s1">+ </span><span class="s5">0.5</span><span class="s1">)</span>
        <span class="s1">whalf = crit / </span><span class="s5">2</span>
        <span class="s3"># above is for ci of count</span>
        <span class="s1">ci = (((np.maximum(center_low - whalf</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8</span><span class="s1">) / n</span><span class="s2">,</span>
              <span class="s1">((center_upp + whalf)**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8</span><span class="s1">) / n)</span>

        <span class="s3"># crit = stats.norm.isf(alpha)</span>
        <span class="s3"># center = count</span>
        <span class="s3"># whalf = crit * np.sqrt((count + 3 / 8 + 0.5))</span>
        <span class="s3"># ci = ((center - whalf - 0.5) / n, (center + whalf + 0.5) / n)</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrt-a&quot;</span><span class="s1">:</span>
        <span class="s3"># anscombe, based on Swift 2009 (with transformation to rate)</span>
        <span class="s1">crit = stats.norm.isf(alpha)</span>
        <span class="s1">center = np.sqrt(count + </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8</span><span class="s1">)</span>
        <span class="s1">whalf = crit / </span><span class="s5">2</span>
        <span class="s3"># above is for ci of count</span>
        <span class="s1">ci = (((np.maximum(center - whalf</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8</span><span class="s1">) / n</span><span class="s2">,</span>
              <span class="s1">((center + whalf)**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8</span><span class="s1">) / n)</span>

    <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrt-v&quot;</span><span class="s1">:</span>
        <span class="s3"># vandenbroucke, based on Swift 2009 (with transformation to rate)</span>
        <span class="s1">crit = stats.norm.isf(alpha)</span>
        <span class="s1">center = np.sqrt(count + (crit**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">2</span><span class="s1">) / </span><span class="s5">12</span><span class="s1">)</span>
        <span class="s1">whalf = crit / </span><span class="s5">2</span>
        <span class="s3"># above is for ci of count</span>
        <span class="s1">ci = (np.maximum(center - whalf</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))**</span><span class="s5">2 </span><span class="s1">/ n</span><span class="s2">, </span><span class="s1">(center + whalf)**</span><span class="s5">2 </span><span class="s1">/ n</span>

    <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;gamma&quot;</span><span class="s2">, </span><span class="s4">&quot;exact-c&quot;</span><span class="s1">]:</span>
        <span class="s3"># garwood exact, gamma</span>
        <span class="s1">low = stats.gamma.ppf(alpha</span><span class="s2">, </span><span class="s1">count) / exposure</span>
        <span class="s1">upp = stats.gamma.isf(alpha</span><span class="s2">, </span><span class="s1">count+</span><span class="s5">1</span><span class="s1">) / exposure</span>
        <span class="s2">if </span><span class="s1">np.isnan(low).any():</span>
            <span class="s3"># case with count = 0</span>
            <span class="s2">if </span><span class="s1">np.size(low) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">low = </span><span class="s5">0.0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">low[np.isnan(low)] = </span><span class="s5">0.0</span>

        <span class="s1">ci = (low</span><span class="s2">, </span><span class="s1">upp)</span>

    <span class="s2">elif </span><span class="s1">method.startswith(</span><span class="s4">&quot;jeff&quot;</span><span class="s1">):</span>
        <span class="s3"># jeffreys, gamma</span>
        <span class="s1">countc = count + </span><span class="s5">0.5</span>
        <span class="s1">ci = (stats.gamma.ppf(alpha</span><span class="s2">, </span><span class="s1">countc) / exposure</span><span class="s2">,</span>
              <span class="s1">stats.gamma.isf(alpha</span><span class="s2">, </span><span class="s1">countc) / exposure)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unknown method %s&quot; </span><span class="s1">% method)</span>

    <span class="s1">ci = (np.maximum(ci[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ci[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">ci</span>


<span class="s2">def </span><span class="s1">tolerance_int_poisson(count</span><span class="s2">, </span><span class="s1">exposure</span><span class="s2">, </span><span class="s1">prob=</span><span class="s5">0.95</span><span class="s2">, </span><span class="s1">exposure_new=</span><span class="s5">1.</span><span class="s2">,</span>
                          <span class="s1">method=</span><span class="s2">None, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
                          <span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;tolerance interval for a poisson observation 
 
    Parameters 
    ---------- 
    count : array_like 
        Observed count, number of events. 
    exposure : arrat_like 
        Currently this is total exposure time of the count variable. 
    prob : float in (0, 1) 
        Probability of poisson interval, often called &quot;content&quot;. 
        With known parameters, each tail would have at most probability 
        ``1 - prob / 2`` in the two-sided interval. 
    exposure_new : float 
        Exposure of the new or predicted observation. 
    method : str 
        Method to used for confidence interval of the estimate of the 
        poisson rate, used in `confint_poisson`. 
        This is required, there is currently no default method. 
    alpha : float in (0, 1) 
        Significance level for the confidence interval of the estimate of the 
        Poisson rate. Nominal coverage of the confidence interval is 
        1 - alpha. 
    alternative : {&quot;two-sider&quot;, &quot;larger&quot;, &quot;smaller&quot;) 
        The tolerance interval can be two-sided or one-sided. 
        Alternative &quot;larger&quot; provides the upper bound of the confidence 
        interval, larger counts are outside the interval. 
 
    Returns 
    ------- 
    tuple (low, upp) of limits of tolerance interval. 
        The tolerance interval is a closed interval, that is both ``low`` and 
        ``upp`` are in the interval. 
 
    Notes 
    ----- 
    verified against R package tolerance `poistol.int` 
 
    See Also 
    -------- 
    confint_poisson 
    confint_quantile_poisson 
 
    References 
    ---------- 
    .. [1] Hahn, Gerald J., and William Q. Meeker. 1991. Statistical Intervals: 
       A Guide for Practitioners. 1st ed. Wiley Series in Probability and 
       Statistics. Wiley. https://doi.org/10.1002/9780470316771. 
    .. [2] Hahn, Gerald J., and Ramesh Chandra. 1981. “Tolerance Intervals for 
       Poisson and Binomial Variables.” Journal of Quality Technology 13 (2): 
       100–110. https://doi.org/10.1080/00224065.1981.11980998. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">prob_tail = </span><span class="s5">1 </span><span class="s1">- prob</span>
    <span class="s1">alpha_ = alpha</span>
    <span class="s2">if </span><span class="s1">alternative != </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">:</span>
        <span class="s3"># confint_poisson does not have one-sided alternatives</span>
        <span class="s1">alpha_ = alpha * </span><span class="s5">2</span>
    <span class="s1">low</span><span class="s2">, </span><span class="s1">upp = confint_poisson(count</span><span class="s2">, </span><span class="s1">exposure</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">alpha=alpha_)</span>

    <span class="s2">if </span><span class="s1">exposure_new != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">low *= exposure_new</span>
        <span class="s1">upp *= exposure_new</span>

    <span class="s2">if </span><span class="s1">alternative == </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">:</span>
        <span class="s1">low_pred = stats.poisson.ppf(prob_tail / </span><span class="s5">2</span><span class="s2">, </span><span class="s1">low)</span>
        <span class="s1">upp_pred = stats.poisson.ppf(</span><span class="s5">1 </span><span class="s1">- prob_tail / </span><span class="s5">2</span><span class="s2">, </span><span class="s1">upp)</span>
    <span class="s2">elif </span><span class="s1">alternative == </span><span class="s4">&quot;larger&quot;</span><span class="s1">:</span>
        <span class="s1">low_pred = </span><span class="s5">0</span>
        <span class="s1">upp_pred = stats.poisson.ppf(</span><span class="s5">1 </span><span class="s1">- prob_tail</span><span class="s2">, </span><span class="s1">upp)</span>
    <span class="s2">elif </span><span class="s1">alternative == </span><span class="s4">&quot;smaller&quot;</span><span class="s1">:</span>
        <span class="s1">low_pred = stats.poisson.ppf(prob_tail</span><span class="s2">, </span><span class="s1">low)</span>
        <span class="s1">upp_pred = np.inf</span>

    <span class="s3"># clip -1 of ppf(0)</span>
    <span class="s1">low_pred = np.maximum(low_pred</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">low_pred</span><span class="s2">, </span><span class="s1">upp_pred</span>


<span class="s2">def </span><span class="s1">confint_quantile_poisson(count</span><span class="s2">, </span><span class="s1">exposure</span><span class="s2">, </span><span class="s1">prob</span><span class="s2">, </span><span class="s1">exposure_new=</span><span class="s5">1.</span><span class="s2">,</span>
                             <span class="s1">method=</span><span class="s2">None, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
                             <span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;confidence interval for quantile of poisson random variable 
 
    Parameters 
    ---------- 
    count : array_like 
        Observed count, number of events. 
    exposure : arrat_like 
        Currently this is total exposure time of the count variable. 
    prob : float in (0, 1) 
        Probability for the quantile, e.g. 0.95 to get the upper 95% quantile. 
        With known mean mu, the quantile would be poisson.ppf(prob, mu). 
    exposure_new : float 
        Exposure of the new or predicted observation. 
    method : str 
        Method to used for confidence interval of the estimate of the 
        poisson rate, used in `confint_poisson`. 
        This is required, there is currently no default method. 
    alpha : float in (0, 1) 
        Significance level for the confidence interval of the estimate of the 
        Poisson rate. Nominal coverage of the confidence interval is 
        1 - alpha. 
    alternative : {&quot;two-sider&quot;, &quot;larger&quot;, &quot;smaller&quot;) 
        The tolerance interval can be two-sided or one-sided. 
        Alternative &quot;larger&quot; provides the upper bound of the confidence 
        interval, larger counts are outside the interval. 
 
    Returns 
    ------- 
    tuple (low, upp) of limits of tolerance interval. 
    The confidence interval is a closed interval, that is both ``low`` and 
    ``upp`` are in the interval. 
 
    See Also 
    -------- 
    confint_poisson 
    tolerance_int_poisson 
 
    References 
    ---------- 
    Hahn, Gerald J, and William Q Meeker. 2010. Statistical Intervals: A Guide 
    for Practitioners. 
    &quot;&quot;&quot;</span>
    <span class="s1">alpha_ = alpha</span>
    <span class="s2">if </span><span class="s1">alternative != </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">:</span>
        <span class="s3"># confint_poisson does not have one-sided alternatives</span>
        <span class="s1">alpha_ = alpha * </span><span class="s5">2</span>
    <span class="s1">low</span><span class="s2">, </span><span class="s1">upp = confint_poisson(count</span><span class="s2">, </span><span class="s1">exposure</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">alpha=alpha_)</span>
    <span class="s2">if </span><span class="s1">exposure_new != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">low *= exposure_new</span>
        <span class="s1">upp *= exposure_new</span>

    <span class="s2">if </span><span class="s1">alternative == </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">:</span>
        <span class="s1">low_pred = stats.poisson.ppf(prob</span><span class="s2">, </span><span class="s1">low)</span>
        <span class="s1">upp_pred = stats.poisson.ppf(prob</span><span class="s2">, </span><span class="s1">upp)</span>
    <span class="s2">elif </span><span class="s1">alternative == </span><span class="s4">&quot;larger&quot;</span><span class="s1">:</span>
        <span class="s1">low_pred = </span><span class="s5">0</span>
        <span class="s1">upp_pred = stats.poisson.ppf(prob</span><span class="s2">, </span><span class="s1">upp)</span>
    <span class="s2">elif </span><span class="s1">alternative == </span><span class="s4">&quot;smaller&quot;</span><span class="s1">:</span>
        <span class="s1">low_pred = stats.poisson.ppf(prob</span><span class="s2">, </span><span class="s1">low)</span>
        <span class="s1">upp_pred = np.inf</span>

    <span class="s3"># clip -1 of ppf(0)</span>
    <span class="s1">low_pred = np.maximum(low_pred</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">low_pred</span><span class="s2">, </span><span class="s1">upp_pred</span>


<span class="s2">def </span><span class="s1">_invert_test_confint(count</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">&quot;midp-c&quot;</span><span class="s2">,</span>
                         <span class="s1">method_start=</span><span class="s4">&quot;exact-c&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;invert hypothesis test to get confidence interval 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">func(r):</span>
        <span class="s1">v = (test_poisson(count</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">value=r</span><span class="s2">, </span><span class="s1">method=method)[</span><span class="s5">1</span><span class="s1">] -</span>
             <span class="s1">alpha)**</span><span class="s5">2</span>
        <span class="s2">return </span><span class="s1">v</span>

    <span class="s1">ci = confint_poisson(count</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">method=method_start)</span>
    <span class="s1">low = optimize.fmin(func</span><span class="s2">, </span><span class="s1">ci[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xtol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">upp = optimize.fmin(func</span><span class="s2">, </span><span class="s1">ci[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xtol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">np.size(low) == </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">low[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">upp[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_invert_test_confint_2indep(</span>
        <span class="s1">count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
        <span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
        <span class="s1">method=</span><span class="s4">&quot;score&quot;</span><span class="s2">,</span>
        <span class="s1">compare=</span><span class="s4">&quot;diff&quot;</span><span class="s2">,</span>
        <span class="s1">method_start=</span><span class="s4">&quot;wald&quot;</span>
        <span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;invert hypothesis test to get confidence interval for 2indep 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">func(r):</span>
        <span class="s1">v = (test_poisson_2indep(</span>
             <span class="s1">count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
             <span class="s1">value=r</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">compare=compare</span>
             <span class="s1">)[</span><span class="s5">1</span><span class="s1">] - alpha)**</span><span class="s5">2</span>
        <span class="s2">return </span><span class="s1">v</span>

    <span class="s1">ci = confint_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                                <span class="s1">method=method_start</span><span class="s2">, </span><span class="s1">compare=compare)</span>
    <span class="s1">low = optimize.fmin(func</span><span class="s2">, </span><span class="s1">ci[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xtol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">upp = optimize.fmin(func</span><span class="s2">, </span><span class="s1">ci[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xtol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">np.size(low) == </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">low[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">upp[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s1">method_names_poisson_2indep = {</span>
    <span class="s4">&quot;test&quot;</span><span class="s1">: {</span>
        <span class="s4">&quot;ratio&quot;</span><span class="s1">: [</span>
            <span class="s4">&quot;wald&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;score&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;score-log&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;wald-log&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;exact-cond&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;cond-midp&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;sqrt&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;etest-score&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;etest-wald&quot;</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s4">&quot;diff&quot;</span><span class="s1">: [</span>
            <span class="s4">&quot;wald&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;score&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;waldccv&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;etest-score&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;etest-wald&quot;</span>
            <span class="s1">]</span>
        <span class="s1">}</span><span class="s2">,</span>
    <span class="s4">&quot;confint&quot;</span><span class="s1">: {</span>
        <span class="s4">&quot;ratio&quot;</span><span class="s1">: [</span>
            <span class="s4">&quot;waldcc&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;score&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;score-log&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;wald-log&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;sqrtcc&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;mover&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s4">&quot;diff&quot;</span><span class="s1">: [</span>
            <span class="s4">&quot;wald&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;score&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;waldccv&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;mover&quot;</span>
            <span class="s1">]</span>
        <span class="s1">}</span>
    <span class="s1">}</span>


<span class="s2">def </span><span class="s1">test_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">, </span><span class="s1">value=</span><span class="s2">None,</span>
                        <span class="s1">ratio_null=</span><span class="s2">None,</span>
                        <span class="s1">method=</span><span class="s2">None, </span><span class="s1">compare=</span><span class="s4">'ratio'</span><span class="s2">,</span>
                        <span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s2">, </span><span class="s1">etest_kwds=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''Test for comparing two sample Poisson intensity rates. 
 
    Rates are defined as expected count divided by exposure. 
 
    The Null and alternative hypothesis for the rates, rate1 and rate2, of two 
    independent Poisson samples are 
 
    for compare = 'diff' 
 
    - H0: rate1 - rate2 - value = 0 
    - H1: rate1 - rate2 - value != 0  if alternative = 'two-sided' 
    - H1: rate1 - rate2 - value &gt; 0   if alternative = 'larger' 
    - H1: rate1 - rate2 - value &lt; 0   if alternative = 'smaller' 
 
    for compare = 'ratio' 
 
    - H0: rate1 / rate2 - value = 0 
    - H1: rate1 / rate2 - value != 0  if alternative = 'two-sided' 
    - H1: rate1 / rate2 - value &gt; 0   if alternative = 'larger' 
    - H1: rate1 / rate2 - value &lt; 0   if alternative = 'smaller' 
 
    Parameters 
    ---------- 
    count1 : int 
        Number of events in first sample, treatment group. 
    exposure1 : float 
        Total exposure (time * subjects) in first sample. 
    count2 : int 
        Number of events in second sample, control group. 
    exposure2 : float 
        Total exposure (time * subjects) in second sample. 
    ratio_null: float 
        Ratio of the two Poisson rates under the Null hypothesis. Default is 1. 
        Deprecated, use ``value`` instead. 
 
        .. deprecated:: 0.14.0 
 
            Use ``value`` instead. 
 
    value : float 
        Value of the ratio or difference of 2 independent rates under the null 
        hypothesis. Default is equal rates, i.e. 1 for ratio and 0 for diff. 
 
        .. versionadded:: 0.14.0 
 
            Replacement for ``ratio_null``. 
 
    method : string 
        Method for the test statistic and the p-value. Defaults to `'score'`. 
        see Notes. 
 
        ratio: 
 
        - 'wald': method W1A, wald test, variance based on observed rates 
        - 'score': method W2A, score test, variance based on estimate under 
          the Null hypothesis 
        - 'wald-log': W3A, uses log-ratio, variance based on observed rates 
        - 'score-log' W4A, uses log-ratio, variance based on estimate under 
          the Null hypothesis 
        - 'sqrt': W5A, based on variance stabilizing square root transformation 
        - 'exact-cond': exact conditional test based on binomial distribution 
           This uses ``binom_test`` which is minlike in the two-sided case. 
        - 'cond-midp': midpoint-pvalue of exact conditional test 
        - 'etest' or 'etest-score: etest with score test statistic 
        - 'etest-wald': etest with wald test statistic 
 
        diff: 
 
        - 'wald', 
        - 'waldccv' 
        - 'score' 
        - 'etest-score' or 'etest: etest with score test statistic 
        - 'etest-wald': etest with wald test statistic 
 
    compare : {'diff', 'ratio'} 
        Default is &quot;ratio&quot;. 
        If compare is `ratio`, then the hypothesis test is for the 
        rate ratio defined by ratio = rate1 / rate2. 
        If compare is `diff`, then the hypothesis test is for 
        diff = rate1 - rate2. 
    alternative : {&quot;two-sided&quot; (default), &quot;larger&quot;, smaller} 
        The alternative hypothesis, H1, has to be one of the following 
 
        - 'two-sided': H1: ratio, or diff, of rates is not equal to value 
        - 'larger' :   H1: ratio, or diff, of rates is larger than value 
        - 'smaller' :  H1: ratio, or diff, of rates is smaller than value 
    etest_kwds: dictionary 
        Additional optional parameters to be passed to the etest_poisson_2indep 
        function, namely y_grid. 
 
    Returns 
    ------- 
    results : instance of HolderTuple class 
        The two main attributes are test statistic `statistic` and p-value 
        `pvalue`. 
 
    See Also 
    -------- 
    tost_poisson_2indep 
    etest_poisson_2indep 
 
    Notes 
    ----- 
    The hypothesis tests for compare=&quot;ratio&quot; are based on Gu et al 2018. 
    The e-tests are also based on ... 
 
    - 'wald': method W1A, wald test, variance based on separate estimates 
    - 'score': method W2A, score test, variance based on estimate under Null 
    - 'wald-log': W3A, wald test for log transformed ratio 
    - 'score-log' W4A, score test for log transformed ratio 
    - 'sqrt': W5A, based on variance stabilizing square root transformation 
    - 'exact-cond': exact conditional test based on binomial distribution 
    - 'cond-midp': midpoint-pvalue of exact conditional test 
    - 'etest': etest with score test statistic 
    - 'etest-wald': etest with wald test statistic 
 
    The hypothesis test for compare=&quot;diff&quot; are mainly based on Ng et al 2007 
    and ... 
 
    - wald 
    - score 
    - etest-score 
    - etest-wald 
 
    Note the etests use the constraint maximum likelihood estimate (cmle) as 
    parameters for the underlying Poisson probabilities. The constraint cmle 
    parameters are the same as in the score test. 
    The E-test in Krishnamoorty and Thomson uses a moment estimator instead of 
    the score estimator. 
 
    References 
    ---------- 
    .. [1] Gu, Ng, Tang, Schucany 2008: Testing the Ratio of Two Poisson Rates, 
       Biometrical Journal 50 (2008) 2, 2008 
 
    .. [2] Ng, H. K. T., K. Gu, and M. L. Tang. 2007. “A Comparative Study of 
       Tests for the Difference of Two Poisson Means.” 
       Computational Statistics &amp; Data Analysis 51 (6): 3085–99. 
       https://doi.org/10.1016/j.csda.2006.02.004. 
 
    '''</span>

    <span class="s3"># shortcut names</span>
    <span class="s1">y1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">n2 = map(np.asarray</span><span class="s2">, </span><span class="s1">[count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2])</span>
    <span class="s1">d = n2 / n1</span>
    <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2 = y1 / n1</span><span class="s2">, </span><span class="s1">y2 / n2</span>
    <span class="s1">rates_cmle = </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">compare == </span><span class="s4">'ratio'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># default method</span>
            <span class="s1">method = </span><span class="s4">'score'</span>

        <span class="s2">if </span><span class="s1">ratio_null </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;'ratio_null' is deprecated, use 'value' keyword&quot;</span><span class="s2">,</span>
                          <span class="s1">FutureWarning)</span>
            <span class="s1">value = ratio_null</span>
        <span class="s2">if </span><span class="s1">ratio_null </span><span class="s2">is None and </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># default value</span>
            <span class="s1">value = ratio_null = </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># for results holder instance, it still contains ratio_null</span>
            <span class="s1">ratio_null = value</span>

        <span class="s1">r = value</span>
        <span class="s1">r_d = r / d   </span><span class="s3"># r1 * n1 / (r2 * n2)</span>

        <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'score'</span><span class="s1">]:</span>
            <span class="s1">stat = (y1 - y2 * r_d) / np.sqrt((y1 + y2) * r_d)</span>
            <span class="s1">dist = </span><span class="s4">'normal'</span>
        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'wald'</span><span class="s1">]:</span>
            <span class="s1">stat = (y1 - y2 * r_d) / np.sqrt(y1 + y2 * r_d**</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">dist = </span><span class="s4">'normal'</span>
        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'score-log'</span><span class="s1">]:</span>
            <span class="s1">stat = (np.log(y1 / y2) - np.log(r_d))</span>
            <span class="s1">stat /= np.sqrt((</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">/ r_d + r_d) / (y1 + y2))</span>
            <span class="s1">dist = </span><span class="s4">'normal'</span>
        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'wald-log'</span><span class="s1">]:</span>
            <span class="s1">stat = (np.log(y1 / y2) - np.log(r_d)) / np.sqrt(</span><span class="s5">1 </span><span class="s1">/ y1 + </span><span class="s5">1 </span><span class="s1">/ y2)</span>
            <span class="s1">dist = </span><span class="s4">'normal'</span>
        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'sqrt'</span><span class="s1">]:</span>
            <span class="s1">stat = </span><span class="s5">2 </span><span class="s1">* (np.sqrt(y1 + </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8.</span><span class="s1">) - np.sqrt((y2 + </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">8.</span><span class="s1">) * r_d))</span>
            <span class="s1">stat /= np.sqrt(</span><span class="s5">1 </span><span class="s1">+ r_d)</span>
            <span class="s1">dist = </span><span class="s4">'normal'</span>
        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'exact-cond'</span><span class="s2">, </span><span class="s4">'cond-midp'</span><span class="s1">]:</span>
            <span class="s2">from </span><span class="s1">statsmodels.stats </span><span class="s2">import </span><span class="s1">proportion</span>
            <span class="s1">bp = r_d / (</span><span class="s5">1 </span><span class="s1">+ r_d)</span>
            <span class="s1">y_total = y1 + y2</span>
            <span class="s1">stat = np.nan</span>
            <span class="s3"># TODO: why y2 in here and not y1, check definition of H1 &quot;larger&quot;</span>
            <span class="s1">pvalue = proportion.binom_test(y1</span><span class="s2">, </span><span class="s1">y_total</span><span class="s2">, </span><span class="s1">prop=bp</span><span class="s2">,</span>
                                           <span class="s1">alternative=alternative)</span>
            <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'cond-midp'</span><span class="s1">]:</span>
                <span class="s3"># not inplace in case we still want binom pvalue</span>
                <span class="s1">pvalue = pvalue - </span><span class="s5">0.5 </span><span class="s1">* stats.binom.pmf(y1</span><span class="s2">, </span><span class="s1">y_total</span><span class="s2">, </span><span class="s1">bp)</span>

            <span class="s1">dist = </span><span class="s4">'binomial'</span>
        <span class="s2">elif </span><span class="s1">method.startswith(</span><span class="s4">'etest'</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">method.endswith(</span><span class="s4">'wald'</span><span class="s1">):</span>
                <span class="s1">method_etest = </span><span class="s4">'wald'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">method_etest = </span><span class="s4">'score'</span>
            <span class="s2">if </span><span class="s1">etest_kwds </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">etest_kwds = {}</span>

            <span class="s1">stat</span><span class="s2">, </span><span class="s1">pvalue = etest_poisson_2indep(</span>
                <span class="s1">count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">, </span><span class="s1">value=value</span><span class="s2">,</span>
                <span class="s1">method=method_etest</span><span class="s2">, </span><span class="s1">alternative=alternative</span><span class="s2">, </span><span class="s1">**etest_kwds)</span>

            <span class="s1">dist = </span><span class="s4">'poisson'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'method &quot;</span><span class="s2">{</span><span class="s1">method</span><span class="s2">}</span><span class="s4">&quot; not recognized'</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">compare == </span><span class="s4">&quot;diff&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">value = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'wald'</span><span class="s1">]:</span>
            <span class="s1">stat = (rate1 - rate2 - value) / np.sqrt(rate1 / n1 + rate2 / n2)</span>
            <span class="s1">dist = </span><span class="s4">'normal'</span>
            <span class="s4">&quot;waldccv&quot;</span>
        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'waldccv'</span><span class="s1">]:</span>
            <span class="s1">stat = (rate1 - rate2 - value)</span>
            <span class="s1">stat /= np.sqrt((count1 + </span><span class="s5">0.5</span><span class="s1">) / n1**</span><span class="s5">2 </span><span class="s1">+ (count2 + </span><span class="s5">0.5</span><span class="s1">) / n2**</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">dist = </span><span class="s4">'normal'</span>
        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'score'</span><span class="s1">]:</span>
            <span class="s3"># estimate rates with constraint MLE</span>
            <span class="s1">count_pooled = y1 + y2</span>
            <span class="s1">rate_pooled = count_pooled / (n1 + n2)</span>
            <span class="s1">dt = rate_pooled - value</span>
            <span class="s1">r2_cmle = </span><span class="s5">0.5 </span><span class="s1">* (dt + np.sqrt(dt**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">4 </span><span class="s1">* value * y2 / (n1 + n2)))</span>
            <span class="s1">r1_cmle = r2_cmle + value</span>

            <span class="s1">stat = ((rate1 - rate2 - value) /</span>
                    <span class="s1">np.sqrt(r1_cmle / n1 + r2_cmle / n2))</span>
            <span class="s1">rates_cmle = (r1_cmle</span><span class="s2">, </span><span class="s1">r2_cmle)</span>
            <span class="s1">dist = </span><span class="s4">'normal'</span>
        <span class="s2">elif </span><span class="s1">method.startswith(</span><span class="s4">'etest'</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">method.endswith(</span><span class="s4">'wald'</span><span class="s1">):</span>
                <span class="s1">method_etest = </span><span class="s4">'wald'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">method_etest = </span><span class="s4">'score'</span>
                <span class="s2">if </span><span class="s1">method == </span><span class="s4">&quot;etest&quot;</span><span class="s1">:</span>
                    <span class="s1">method = method + </span><span class="s4">&quot;-score&quot;</span>

            <span class="s2">if </span><span class="s1">etest_kwds </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">etest_kwds = {}</span>

            <span class="s1">stat</span><span class="s2">, </span><span class="s1">pvalue = etest_poisson_2indep(</span>
                <span class="s1">count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">, </span><span class="s1">value=value</span><span class="s2">,</span>
                <span class="s1">method=method_etest</span><span class="s2">, </span><span class="s1">compare=</span><span class="s4">&quot;diff&quot;</span><span class="s2">,</span>
                <span class="s1">alternative=alternative</span><span class="s2">, </span><span class="s1">**etest_kwds)</span>

            <span class="s1">dist = </span><span class="s4">'poisson'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'method &quot;</span><span class="s2">{</span><span class="s1">method</span><span class="s2">}</span><span class="s4">&quot; not recognized'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'&quot;compare&quot; needs to be ratio or diff'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">dist == </span><span class="s4">'normal'</span><span class="s1">:</span>
        <span class="s1">stat</span><span class="s2">, </span><span class="s1">pvalue = _zstat_generic2(stat</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">alternative)</span>

    <span class="s1">rates = (rate1</span><span class="s2">, </span><span class="s1">rate2)</span>
    <span class="s1">ratio = rate1 / rate2</span>
    <span class="s1">diff = rate1 - rate2</span>
    <span class="s1">res = HolderTuple(statistic=stat</span><span class="s2">,</span>
                      <span class="s1">pvalue=pvalue</span><span class="s2">,</span>
                      <span class="s1">distribution=dist</span><span class="s2">,</span>
                      <span class="s1">compare=compare</span><span class="s2">,</span>
                      <span class="s1">method=method</span><span class="s2">,</span>
                      <span class="s1">alternative=alternative</span><span class="s2">,</span>
                      <span class="s1">rates=rates</span><span class="s2">,</span>
                      <span class="s1">ratio=ratio</span><span class="s2">,</span>
                      <span class="s1">diff=diff</span><span class="s2">,</span>
                      <span class="s1">value=value</span><span class="s2">,</span>
                      <span class="s1">rates_cmle=rates_cmle</span><span class="s2">,</span>
                      <span class="s1">ratio_null=ratio_null</span><span class="s2">,</span>
                      <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">_score_diff(y1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">value=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">return_cmle=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;score test and cmle for difference of 2 independent poisson rates 
 
    &quot;&quot;&quot;</span>
    <span class="s1">count_pooled = y1 + y2</span>
    <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2 = y1 / n1</span><span class="s2">, </span><span class="s1">y2 / n2</span>
    <span class="s1">rate_pooled = count_pooled / (n1 + n2)</span>
    <span class="s1">dt = rate_pooled - value</span>
    <span class="s1">r2_cmle = </span><span class="s5">0.5 </span><span class="s1">* (dt + np.sqrt(dt**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">4 </span><span class="s1">* value * y2 / (n1 + n2)))</span>
    <span class="s1">r1_cmle = r2_cmle + value</span>
    <span class="s1">eps = </span><span class="s5">1e-20  </span><span class="s3"># avoid zero division in stat_func</span>
    <span class="s1">v = r1_cmle / n1 + r2_cmle / n2</span>
    <span class="s1">stat = (rate1 - rate2 - value) / np.sqrt(v + eps)</span>

    <span class="s2">if </span><span class="s1">return_cmle:</span>
        <span class="s2">return </span><span class="s1">stat</span><span class="s2">, </span><span class="s1">r1_cmle</span><span class="s2">, </span><span class="s1">r2_cmle</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">stat</span>


<span class="s2">def </span><span class="s1">etest_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">, </span><span class="s1">ratio_null=</span><span class="s2">None,</span>
                         <span class="s1">value=</span><span class="s2">None, </span><span class="s1">method=</span><span class="s4">'score'</span><span class="s2">, </span><span class="s1">compare=</span><span class="s4">&quot;ratio&quot;</span><span class="s2">,</span>
                         <span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s2">, </span><span class="s1">ygrid=</span><span class="s2">None,</span>
                         <span class="s1">y_grid=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    E-test for ratio of two sample Poisson rates. 
 
    Rates are defined as expected count divided by exposure. The Null and 
    alternative hypothesis for the rates, rate1 and rate2, of two independent 
    Poisson samples are: 
 
    for compare = 'diff' 
 
    - H0: rate1 - rate2 - value = 0 
    - H1: rate1 - rate2 - value != 0  if alternative = 'two-sided' 
    - H1: rate1 - rate2 - value &gt; 0   if alternative = 'larger' 
    - H1: rate1 - rate2 - value &lt; 0   if alternative = 'smaller' 
 
    for compare = 'ratio' 
 
    - H0: rate1 / rate2 - value = 0 
    - H1: rate1 / rate2 - value != 0  if alternative = 'two-sided' 
    - H1: rate1 / rate2 - value &gt; 0   if alternative = 'larger' 
    - H1: rate1 / rate2 - value &lt; 0   if alternative = 'smaller' 
 
    Parameters 
    ---------- 
    count1 : int 
        Number of events in first sample 
    exposure1 : float 
        Total exposure (time * subjects) in first sample 
    count2 : int 
        Number of events in first sample 
    exposure2 : float 
        Total exposure (time * subjects) in first sample 
    ratio_null: float 
        Ratio of the two Poisson rates under the Null hypothesis. Default is 1. 
        Deprecated, use ``value`` instead. 
 
        .. deprecated:: 0.14.0 
 
            Use ``value`` instead. 
 
    value : float 
        Value of the ratio or diff of 2 independent rates under the null 
        hypothesis. Default is equal rates, i.e. 1 for ratio and 0 for diff. 
 
        .. versionadded:: 0.14.0 
 
            Replacement for ``ratio_null``. 
 
    method : {&quot;score&quot;, &quot;wald&quot;} 
        Method for the test statistic that defines the rejection region. 
    alternative : string 
        The alternative hypothesis, H1, has to be one of the following 
 
        - 'two-sided': H1: ratio of rates is not equal to ratio_null (default) 
        - 'larger' :   H1: ratio of rates is larger than ratio_null 
        - 'smaller' :  H1: ratio of rates is smaller than ratio_null 
 
    y_grid : None or 1-D ndarray 
        Grid values for counts of the Poisson distribution used for computing 
        the pvalue. By default truncation is based on an upper tail Poisson 
        quantiles. 
 
    ygrid : None or 1-D ndarray 
        Same as y_grid. Deprecated. If both y_grid and ygrid are provided, 
        ygrid will be ignored. 
 
        .. deprecated:: 0.14.0 
 
            Use ``y_grid`` instead. 
 
    Returns 
    ------- 
    stat_sample : float 
        test statistic for the sample 
    pvalue : float 
 
    References 
    ---------- 
    Gu, Ng, Tang, Schucany 2008: Testing the Ratio of Two Poisson Rates, 
    Biometrical Journal 50 (2008) 2, 2008 
    Ng, H. K. T., K. Gu, and M. L. Tang. 2007. “A Comparative Study of Tests 
    for the Difference of Two Poisson Means.” Computational Statistics &amp; Data 
    Analysis 51 (6): 3085–99. https://doi.org/10.1016/j.csda.2006.02.004. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">n2 = map(np.asarray</span><span class="s2">, </span><span class="s1">[count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2])</span>
    <span class="s1">d = n2 / n1</span>

    <span class="s1">eps = </span><span class="s5">1e-20  </span><span class="s3"># avoid zero division in stat_func</span>

    <span class="s2">if </span><span class="s1">compare == </span><span class="s4">&quot;ratio&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">ratio_null </span><span class="s2">is None and </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># default value</span>
            <span class="s1">value = </span><span class="s5">1</span>
        <span class="s2">elif </span><span class="s1">ratio_null </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;'ratio_null' is deprecated, use 'value' keyword&quot;</span><span class="s2">,</span>
                          <span class="s1">FutureWarning)</span>
            <span class="s1">value = ratio_null</span>

        <span class="s1">r = value  </span><span class="s3"># rate1 / rate2</span>
        <span class="s1">r_d = r / d</span>
        <span class="s1">rate2_cmle = (y1 + y2) / n2 / (</span><span class="s5">1 </span><span class="s1">+ r_d)</span>
        <span class="s1">rate1_cmle = rate2_cmle * r</span>

        <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'score'</span><span class="s1">]:</span>
            <span class="s2">def </span><span class="s1">stat_func(x1</span><span class="s2">, </span><span class="s1">x2):</span>
                <span class="s2">return </span><span class="s1">(x1 - x2 * r_d) / np.sqrt((x1 + x2) * r_d + eps)</span>
            <span class="s3"># TODO: do I need these? return_results ?</span>
            <span class="s3"># rate2_cmle = (y1 + y2) / n2 / (1 + r_d)</span>
            <span class="s3"># rate1_cmle = rate2_cmle * r</span>
            <span class="s3"># rate1 = rate1_cmle</span>
            <span class="s3"># rate2 = rate2_cmle</span>
        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'wald'</span><span class="s1">]:</span>
            <span class="s2">def </span><span class="s1">stat_func(x1</span><span class="s2">, </span><span class="s1">x2):</span>
                <span class="s2">return </span><span class="s1">(x1 - x2 * r_d) / np.sqrt(x1 + x2 * r_d**</span><span class="s5">2 </span><span class="s1">+ eps)</span>
            <span class="s3"># rate2_mle = y2 / n2</span>
            <span class="s3"># rate1_mle = y1 / n1</span>
            <span class="s3"># rate1 = rate1_mle</span>
            <span class="s3"># rate2 = rate2_mle</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'method not recognized'</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">compare == </span><span class="s4">&quot;diff&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">value = </span><span class="s5">0</span>
        <span class="s1">tmp = _score_diff(y1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">value=value</span><span class="s2">, </span><span class="s1">return_cmle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">rate1_cmle</span><span class="s2">, </span><span class="s1">rate2_cmle = tmp</span>

        <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'score'</span><span class="s1">]:</span>

            <span class="s2">def </span><span class="s1">stat_func(x1</span><span class="s2">, </span><span class="s1">x2):</span>
                <span class="s2">return </span><span class="s1">_score_diff(x1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">value=value)</span>

        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'wald'</span><span class="s1">]:</span>

            <span class="s2">def </span><span class="s1">stat_func(x1</span><span class="s2">, </span><span class="s1">x2):</span>
                <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2 = x1 / n1</span><span class="s2">, </span><span class="s1">x2 / n2</span>
                <span class="s1">stat = (rate1 - rate2 - value)</span>
                <span class="s1">stat /= np.sqrt(rate1 / n1 + rate2 / n2 + eps)</span>
                <span class="s2">return </span><span class="s1">stat</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'method not recognized'</span><span class="s1">)</span>

    <span class="s3"># The sampling distribution needs to be based on the null hypotheis</span>
    <span class="s3"># use constrained MLE from 'score' calculation</span>
    <span class="s1">rate1 = rate1_cmle</span>
    <span class="s1">rate2 = rate2_cmle</span>
    <span class="s1">mean1 = n1 * rate1</span>
    <span class="s1">mean2 = n2 * rate2</span>

    <span class="s1">stat_sample = stat_func(y1</span><span class="s2">, </span><span class="s1">y2)</span>

    <span class="s2">if </span><span class="s1">ygrid </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;ygrid is deprecated, use y_grid&quot;</span><span class="s2">, </span><span class="s1">FutureWarning)</span>
    <span class="s1">y_grid = y_grid </span><span class="s2">if </span><span class="s1">y_grid </span><span class="s2">is not None else </span><span class="s1">ygrid</span>

    <span class="s3"># The following uses a fixed truncation for evaluating the probabilities</span>
    <span class="s3"># It will currently only work for small counts, so that sf at truncation</span>
    <span class="s3"># point is small</span>
    <span class="s3"># We can make it depend on the amount of truncated sf.</span>
    <span class="s3"># Some numerical optimization or checks for large means need to be added.</span>
    <span class="s2">if </span><span class="s1">y_grid </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">threshold = stats.poisson.isf(</span><span class="s5">1e-13</span><span class="s2">, </span><span class="s1">max(mean1</span><span class="s2">, </span><span class="s1">mean2))</span>
        <span class="s1">threshold = max(threshold</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)   </span><span class="s3"># keep at least 100</span>
        <span class="s1">y_grid = np.arange(threshold + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">y_grid = np.asarray(y_grid)</span>
        <span class="s2">if </span><span class="s1">y_grid.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;y_grid needs to be None or 1-dimensional array&quot;</span><span class="s1">)</span>
    <span class="s1">pdf1 = stats.poisson.pmf(y_grid</span><span class="s2">, </span><span class="s1">mean1)</span>
    <span class="s1">pdf2 = stats.poisson.pmf(y_grid</span><span class="s2">, </span><span class="s1">mean2)</span>

    <span class="s1">stat_space = stat_func(y_grid[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y_grid[</span><span class="s2">None, </span><span class="s1">:])  </span><span class="s3"># broadcasting</span>
    <span class="s1">eps = </span><span class="s5">1e-15   </span><span class="s3"># correction for strict inequality check</span>

    <span class="s2">if </span><span class="s1">alternative </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'two-sided'</span><span class="s2">, </span><span class="s4">'2-sided'</span><span class="s2">, </span><span class="s4">'2s'</span><span class="s1">]:</span>
        <span class="s1">mask = np.abs(stat_space) &gt;= (np.abs(stat_sample) - eps)</span>
    <span class="s2">elif </span><span class="s1">alternative </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'larger'</span><span class="s2">, </span><span class="s4">'l'</span><span class="s1">]:</span>
        <span class="s1">mask = stat_space &gt;= (stat_sample - eps)</span>
    <span class="s2">elif </span><span class="s1">alternative </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'smaller'</span><span class="s2">, </span><span class="s4">'s'</span><span class="s1">]:</span>
        <span class="s1">mask = stat_space &lt;= (stat_sample + eps)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'invalid alternative'</span><span class="s1">)</span>

    <span class="s1">pvalue = ((pdf1[:</span><span class="s2">, None</span><span class="s1">] * pdf2[</span><span class="s2">None, </span><span class="s1">:])[mask]).sum()</span>
    <span class="s2">return </span><span class="s1">stat_sample</span><span class="s2">, </span><span class="s1">pvalue</span>


<span class="s2">def </span><span class="s1">tost_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">upp</span><span class="s2">,</span>
                        <span class="s1">method=</span><span class="s4">'score'</span><span class="s2">, </span><span class="s1">compare=</span><span class="s4">'ratio'</span><span class="s1">):</span>
    <span class="s0">'''Equivalence test based on two one-sided `test_proportions_2indep` 
 
    This assumes that we have two independent poisson samples. 
 
    The Null and alternative hypothesis for equivalence testing are 
 
    for compare = 'ratio' 
 
    - H0: rate1 / rate2 &lt;= low or upp &lt;= rate1 / rate2 
    - H1: low &lt; rate1 / rate2 &lt; upp 
 
    for compare = 'diff' 
 
    - H0: rate1 - rate2 &lt;= low or upp &lt;= rate1 - rate2 
    - H1: low &lt; rate - rate &lt; upp 
 
    Parameters 
    ---------- 
    count1 : int 
        Number of events in first sample 
    exposure1 : float 
        Total exposure (time * subjects) in first sample 
    count2 : int 
        Number of events in second sample 
    exposure2 : float 
        Total exposure (time * subjects) in second sample 
    low, upp : 
        equivalence margin for the ratio or difference of Poisson rates 
    method: string 
        TOST uses ``test_poisson_2indep`` and has the same methods. 
 
        ratio: 
 
        - 'wald': method W1A, wald test, variance based on observed rates 
        - 'score': method W2A, score test, variance based on estimate under 
          the Null hypothesis 
        - 'wald-log': W3A, uses log-ratio, variance based on observed rates 
        - 'score-log' W4A, uses log-ratio, variance based on estimate under 
          the Null hypothesis 
        - 'sqrt': W5A, based on variance stabilizing square root transformation 
        - 'exact-cond': exact conditional test based on binomial distribution 
           This uses ``binom_test`` which is minlike in the two-sided case. 
        - 'cond-midp': midpoint-pvalue of exact conditional test 
        - 'etest' or 'etest-score: etest with score test statistic 
        - 'etest-wald': etest with wald test statistic 
 
        diff: 
 
        - 'wald', 
        - 'waldccv' 
        - 'score' 
        - 'etest-score' or 'etest: etest with score test statistic 
        - 'etest-wald': etest with wald test statistic 
 
    Returns 
    ------- 
    results : instance of HolderTuple class 
        The two main attributes are test statistic `statistic` and p-value 
        `pvalue`. 
 
    References 
    ---------- 
    Gu, Ng, Tang, Schucany 2008: Testing the Ratio of Two Poisson Rates, 
    Biometrical Journal 50 (2008) 2, 2008 
 
    See Also 
    -------- 
    test_poisson_2indep 
    confint_poisson_2indep 
    '''</span>

    <span class="s1">tt1 = test_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                              <span class="s1">value=low</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">,</span>
                              <span class="s1">compare=compare</span><span class="s2">,</span>
                              <span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>
    <span class="s1">tt2 = test_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                              <span class="s1">value=upp</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">,</span>
                              <span class="s1">compare=compare</span><span class="s2">,</span>
                              <span class="s1">alternative=</span><span class="s4">'smaller'</span><span class="s1">)</span>

    <span class="s3"># idx_max = 1 if t1.pvalue &lt; t2.pvalue else 0</span>
    <span class="s1">idx_max = np.asarray(tt1.pvalue &lt; tt2.pvalue</span><span class="s2">, </span><span class="s1">int)</span>
    <span class="s1">statistic = np.choose(idx_max</span><span class="s2">, </span><span class="s1">[tt1.statistic</span><span class="s2">, </span><span class="s1">tt2.statistic])</span>
    <span class="s1">pvalue = np.choose(idx_max</span><span class="s2">, </span><span class="s1">[tt1.pvalue</span><span class="s2">, </span><span class="s1">tt2.pvalue])</span>

    <span class="s1">res = HolderTuple(statistic=statistic</span><span class="s2">,</span>
                      <span class="s1">pvalue=pvalue</span><span class="s2">,</span>
                      <span class="s1">method=method</span><span class="s2">,</span>
                      <span class="s1">compare=compare</span><span class="s2">,</span>
                      <span class="s1">equiv_limits=(low</span><span class="s2">, </span><span class="s1">upp)</span><span class="s2">,</span>
                      <span class="s1">results_larger=tt1</span><span class="s2">,</span>
                      <span class="s1">results_smaller=tt2</span><span class="s2">,</span>
                      <span class="s1">title=</span><span class="s4">&quot;Equivalence test for 2 independent Poisson rates&quot;</span>
                      <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">nonequivalence_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                                  <span class="s1">low</span><span class="s2">, </span><span class="s1">upp</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'score'</span><span class="s2">, </span><span class="s1">compare=</span><span class="s4">&quot;ratio&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Test for non-equivalence, minimum effect for poisson. 
 
    This reverses null and alternative hypothesis compared to equivalence 
    testing. The null hypothesis is that the effect, ratio (or diff), is in 
    an interval that specifies a range of irrelevant or unimportant 
    differences between the two samples. 
 
    The Null and alternative hypothesis comparing the ratio of rates are 
 
    for compare = 'ratio': 
 
    - H0: low &lt; rate1 / rate2 &lt; upp 
    - H1: rate1 / rate2 &lt;= low or upp &lt;= rate1 / rate2 
 
    for compare = 'diff': 
 
    - H0: rate1 - rate2 &lt;= low or upp &lt;= rate1 - rate2 
    - H1: low &lt; rate - rate &lt; upp 
 
 
    Notes 
    ----- 
    This is implemented as two one-sided tests at the minimum effect boundaries 
    (low, upp) with (nominal) size alpha / 2 each. 
    The size of the test is the sum of the two one-tailed tests, which 
    corresponds to an equal-tailed two-sided test. 
    If low and upp are equal, then the result is the same as the standard 
    two-sided test. 
 
    The p-value is computed as `2 * min(pvalue_low, pvalue_upp)` in analogy to 
    two-sided equal-tail tests. 
 
    In large samples the nominal size of the test will be below alpha. 
 
    References 
    ---------- 
    .. [1] Hodges, J. L., Jr., and E. L. Lehmann. 1954. Testing the Approximate 
       Validity of Statistical Hypotheses. Journal of the Royal Statistical 
       Society, Series B (Methodological) 16: 261–68. 
 
    .. [2] Kim, Jae H., and Andrew P. Robinson. 2019. “Interval-Based 
       Hypothesis Testing and Its Applications to Economics and Finance.” 
       Econometrics 7 (2): 21. https://doi.org/10.3390/econometrics7020021. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tt1 = test_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                              <span class="s1">value=low</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">compare=compare</span><span class="s2">,</span>
                              <span class="s1">alternative=</span><span class="s4">'smaller'</span><span class="s1">)</span>
    <span class="s1">tt2 = test_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                              <span class="s1">value=upp</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">compare=compare</span><span class="s2">,</span>
                              <span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>

    <span class="s3"># idx_min = 0 if tt1.pvalue &lt; tt2.pvalue else 1</span>
    <span class="s1">idx_min = np.asarray(tt1.pvalue &lt; tt2.pvalue</span><span class="s2">, </span><span class="s1">int)</span>
    <span class="s1">pvalue = </span><span class="s5">2 </span><span class="s1">* np.minimum(tt1.pvalue</span><span class="s2">, </span><span class="s1">tt2.pvalue)</span>
    <span class="s1">statistic = np.choose(idx_min</span><span class="s2">, </span><span class="s1">[tt1.statistic</span><span class="s2">, </span><span class="s1">tt2.statistic])</span>
    <span class="s1">res = HolderTuple(statistic=statistic</span><span class="s2">,</span>
                      <span class="s1">pvalue=pvalue</span><span class="s2">,</span>
                      <span class="s1">method=method</span><span class="s2">,</span>
                      <span class="s1">results_larger=tt1</span><span class="s2">,</span>
                      <span class="s1">results_smaller=tt2</span><span class="s2">,</span>
                      <span class="s1">title=</span><span class="s4">&quot;Equivalence test for 2 independent Poisson rates&quot;</span>
                      <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">confint_poisson_2indep(count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                           <span class="s1">method=</span><span class="s4">'score'</span><span class="s2">, </span><span class="s1">compare=</span><span class="s4">'ratio'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
                           <span class="s1">method_mover=</span><span class="s4">&quot;score&quot;</span><span class="s2">,</span>
                           <span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Confidence interval for ratio or difference of 2 indep poisson rates. 
 
    Parameters 
    ---------- 
    count1 : int 
        Number of events in first sample. 
    exposure1 : float 
        Total exposure (time * subjects) in first sample. 
    count2 : int 
        Number of events in second sample. 
    exposure2 : float 
        Total exposure (time * subjects) in second sample. 
    method : string 
        Method for the test statistic and the p-value. Defaults to `'score'`. 
        see Notes. 
 
        ratio: 
 
        - 'wald': NOT YET, method W1A, wald test, variance based on observed 
          rates 
        - 'waldcc' : 
        - 'score': method W2A, score test, variance based on estimate under 
          the Null hypothesis 
        - 'wald-log': W3A, uses log-ratio, variance based on observed rates 
        - 'score-log' W4A, uses log-ratio, variance based on estimate under 
          the Null hypothesis 
        - 'sqrt': W5A, based on variance stabilizing square root transformation 
        - 'sqrtcc' : 
        - 'exact-cond': NOT YET, exact conditional test based on binomial 
          distribution 
          This uses ``binom_test`` which is minlike in the two-sided case. 
        - 'cond-midp': NOT YET, midpoint-pvalue of exact conditional test 
        - 'mover' : 
 
        diff: 
 
        - 'wald', 
        - 'waldccv' 
        - 'score' 
        - 'mover' 
 
    compare : {'diff', 'ratio'} 
        Default is &quot;ratio&quot;. 
        If compare is `diff`, then the hypothesis test is for 
        diff = rate1 - rate2. 
        If compare is `ratio`, then the hypothesis test is for the 
        rate ratio defined by ratio = rate1 / rate2. 
    alternative : string 
        The alternative hypothesis, H1, has to be one of the following 
 
        - 'two-sided': H1: ratio of rates is not equal to ratio_null (default) 
        - 'larger' :   H1: ratio of rates is larger than ratio_null 
        - 'smaller' :  H1: ratio of rates is smaller than ratio_null 
 
    alpha : float in (0, 1) 
        Significance level, nominal coverage of the confidence interval is 
        1 - alpha. 
 
    Returns 
    ------- 
    tuple (low, upp) : confidence limits. 
 
    &quot;&quot;&quot;</span>

    <span class="s3"># shortcut names</span>
    <span class="s1">y1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">n2 = map(np.asarray</span><span class="s2">, </span><span class="s1">[count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2])</span>
    <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2 = y1 / n1</span><span class="s2">, </span><span class="s1">y2 / n2</span>
    <span class="s1">alpha = alpha / </span><span class="s5">2  </span><span class="s3"># two-sided only</span>

    <span class="s2">if </span><span class="s1">compare == </span><span class="s4">&quot;ratio&quot;</span><span class="s1">:</span>

        <span class="s2">if </span><span class="s1">method == </span><span class="s4">&quot;score&quot;</span><span class="s1">:</span>
            <span class="s1">low</span><span class="s2">, </span><span class="s1">upp = _invert_test_confint_2indep(</span>
                <span class="s1">count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                <span class="s1">alpha=alpha * </span><span class="s5">2</span><span class="s2">,   </span><span class="s3"># check how alpha is defined</span>
                <span class="s1">method=</span><span class="s4">&quot;score&quot;</span><span class="s2">,</span>
                <span class="s1">compare=</span><span class="s4">&quot;ratio&quot;</span><span class="s2">,</span>
                <span class="s1">method_start=</span><span class="s4">&quot;waldcc&quot;</span>
                <span class="s1">)</span>
            <span class="s1">ci = (low</span><span class="s2">, </span><span class="s1">upp)</span>

        <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;wald-log&quot;</span><span class="s1">:</span>
            <span class="s1">crit = stats.norm.isf(alpha)</span>
            <span class="s1">c = </span><span class="s5">0</span>
            <span class="s1">center = (count1 + c) / (count2 + c) * n2 / n1</span>
            <span class="s1">std = np.sqrt(</span><span class="s5">1 </span><span class="s1">/ (count1 + c) + </span><span class="s5">1 </span><span class="s1">/ (count2 + c))</span>

            <span class="s1">ci = (center * np.exp(- crit * std)</span><span class="s2">, </span><span class="s1">center * np.exp(crit * std))</span>

        <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;score-log&quot;</span><span class="s1">:</span>
            <span class="s1">low</span><span class="s2">, </span><span class="s1">upp = _invert_test_confint_2indep(</span>
                <span class="s1">count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                <span class="s1">alpha=alpha * </span><span class="s5">2</span><span class="s2">,   </span><span class="s3"># check how alpha is defined</span>
                <span class="s1">method=</span><span class="s4">&quot;score-log&quot;</span><span class="s2">,</span>
                <span class="s1">compare=</span><span class="s4">&quot;ratio&quot;</span><span class="s2">,</span>
                <span class="s1">method_start=</span><span class="s4">&quot;waldcc&quot;</span>
                <span class="s1">)</span>
            <span class="s1">ci = (low</span><span class="s2">, </span><span class="s1">upp)</span>

        <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;waldcc&quot;</span><span class="s1">:</span>
            <span class="s1">crit = stats.norm.isf(alpha)</span>
            <span class="s1">center = (count1 + </span><span class="s5">0.5</span><span class="s1">) / (count2 + </span><span class="s5">0.5</span><span class="s1">) * n2 / n1</span>
            <span class="s1">std = np.sqrt(</span><span class="s5">1 </span><span class="s1">/ (count1 + </span><span class="s5">0.5</span><span class="s1">) + </span><span class="s5">1 </span><span class="s1">/ (count2 + </span><span class="s5">0.5</span><span class="s1">))</span>

            <span class="s1">ci = (center * np.exp(- crit * std)</span><span class="s2">, </span><span class="s1">center * np.exp(crit * std))</span>

        <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;sqrtcc&quot;</span><span class="s1">:</span>
            <span class="s3"># coded based on Price, Bonett 2000 equ (2.4)</span>
            <span class="s1">crit = stats.norm.isf(alpha)</span>
            <span class="s1">center = np.sqrt((count1 + </span><span class="s5">0.5</span><span class="s1">) * (count2 + </span><span class="s5">0.5</span><span class="s1">))</span>
            <span class="s1">std = </span><span class="s5">0.5 </span><span class="s1">* np.sqrt(count1 + </span><span class="s5">0.5 </span><span class="s1">+ count2 + </span><span class="s5">0.5 </span><span class="s1">- </span><span class="s5">0.25 </span><span class="s1">* crit)</span>
            <span class="s1">denom = (count2 + </span><span class="s5">0.5 </span><span class="s1">- </span><span class="s5">0.25 </span><span class="s1">* crit**</span><span class="s5">2</span><span class="s1">)</span>

            <span class="s1">low_sqrt = (center - crit * std) / denom</span>
            <span class="s1">upp_sqrt = (center + crit * std) / denom</span>

            <span class="s1">ci = (low_sqrt**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">upp_sqrt**</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;mover&quot;</span><span class="s1">:</span>
            <span class="s1">method_p = method_mover</span>
            <span class="s1">ci1 = confint_poisson(y1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">method=method_p</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">2</span><span class="s1">*alpha)</span>
            <span class="s1">ci2 = confint_poisson(y2</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">method=method_p</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">2</span><span class="s1">*alpha)</span>

            <span class="s1">ci = _mover_confint(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">ci1</span><span class="s2">, </span><span class="s1">ci2</span><span class="s2">, </span><span class="s1">contrast=</span><span class="s4">&quot;ratio&quot;</span><span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'method &quot;</span><span class="s2">{</span><span class="s1">method</span><span class="s2">}</span><span class="s4">&quot; not recognized'</span><span class="s1">)</span>

        <span class="s1">ci = (np.maximum(ci[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ci[</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s2">elif </span><span class="s1">compare == </span><span class="s4">&quot;diff&quot;</span><span class="s1">:</span>

        <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'wald'</span><span class="s1">]:</span>
            <span class="s1">crit = stats.norm.isf(alpha)</span>
            <span class="s1">center = rate1 - rate2</span>
            <span class="s1">half = crit * np.sqrt(rate1 / n1 + rate2 / n2)</span>
            <span class="s1">ci = center - half</span><span class="s2">, </span><span class="s1">center + half</span>

        <span class="s2">elif </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'waldccv'</span><span class="s1">]:</span>
            <span class="s1">crit = stats.norm.isf(alpha)</span>
            <span class="s1">center = rate1 - rate2</span>
            <span class="s1">std = np.sqrt((count1 + </span><span class="s5">0.5</span><span class="s1">) / n1**</span><span class="s5">2 </span><span class="s1">+ (count2 + </span><span class="s5">0.5</span><span class="s1">) / n2**</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">half = crit * std</span>
            <span class="s1">ci = center - half</span><span class="s2">, </span><span class="s1">center + half</span>

        <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;score&quot;</span><span class="s1">:</span>
            <span class="s1">low</span><span class="s2">, </span><span class="s1">upp = _invert_test_confint_2indep(</span>
                <span class="s1">count1</span><span class="s2">, </span><span class="s1">exposure1</span><span class="s2">, </span><span class="s1">count2</span><span class="s2">, </span><span class="s1">exposure2</span><span class="s2">,</span>
                <span class="s1">alpha=alpha * </span><span class="s5">2</span><span class="s2">,   </span><span class="s3"># check how alpha is defined</span>
                <span class="s1">method=</span><span class="s4">&quot;score&quot;</span><span class="s2">,</span>
                <span class="s1">compare=</span><span class="s4">&quot;diff&quot;</span><span class="s2">,</span>
                <span class="s1">method_start=</span><span class="s4">&quot;waldccv&quot;</span>
                <span class="s1">)</span>
            <span class="s1">ci = (low</span><span class="s2">, </span><span class="s1">upp)</span>

        <span class="s2">elif </span><span class="s1">method == </span><span class="s4">&quot;mover&quot;</span><span class="s1">:</span>
            <span class="s1">method_p = method_mover</span>
            <span class="s1">ci1 = confint_poisson(y1</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">method=method_p</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">2</span><span class="s1">*alpha)</span>
            <span class="s1">ci2 = confint_poisson(y2</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">method=method_p</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">2</span><span class="s1">*alpha)</span>

            <span class="s1">ci = _mover_confint(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">ci1</span><span class="s2">, </span><span class="s1">ci2</span><span class="s2">, </span><span class="s1">contrast=</span><span class="s4">&quot;diff&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'method &quot;</span><span class="s2">{</span><span class="s1">method</span><span class="s2">}</span><span class="s4">&quot; not recognized'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'&quot;compare&quot; needs to be ratio or diff'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">ci</span>


<span class="s2">def </span><span class="s1">power_poisson_ratio_2indep(</span>
        <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">,</span>
        <span class="s1">nobs_ratio=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">exposure=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">value=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
        <span class="s1">dispersion=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">alternative=</span><span class="s4">&quot;smaller&quot;</span><span class="s2">,</span>
        <span class="s1">method_var=</span><span class="s4">&quot;alt&quot;</span><span class="s2">,</span>
        <span class="s1">return_results=</span><span class="s2">True,</span>
        <span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Power of test of ratio of 2 independent poisson rates. 
 
    This is based on Zhu and Zhu and Lakkis. It does not directly correspond 
    to `test_poisson_2indep`. 
 
    Parameters 
    ---------- 
    rate1 : float 
        Poisson rate for the first sample, treatment group, under the 
        alternative hypothesis. 
    rate2 : float 
        Poisson rate for the second sample, reference group, under the 
        alternative hypothesis. 
    nobs1 : float or int 
        Number of observations in sample 1. 
    nobs_ratio : float 
        Sample size ratio, nobs2 = nobs_ratio * nobs1. 
    exposure : float 
        Exposure for each observation. Total exposure is nobs1 * exposure 
        and nobs2 * exposure. 
    alpha : float in interval (0,1) 
        Significance level, e.g. 0.05, is the probability of a type I 
        error, that is wrong rejections if the Null Hypothesis is true. 
    value : float 
        Rate ratio, rate1 / rate2, under the null hypothesis. 
    dispersion : float 
        Dispersion coefficient for quasi-Poisson. Dispersion different from 
        one can capture over or under dispersion relative to Poisson 
        distribution. 
    method_var : {&quot;score&quot;, &quot;alt&quot;} 
        The variance of the test statistic for the null hypothesis given the 
        rates under the alternative can be either equal to the rates under the 
        alternative ``method_var=&quot;alt&quot;``, or estimated under the constrained 
        of the null hypothesis, ``method_var=&quot;score&quot;``. 
    alternative : string, 'two-sided' (default), 'larger', 'smaller' 
        Alternative hypothesis whether the power is calculated for a 
        two-sided (default) or one sided test. The one-sided test can be 
        either 'larger', 'smaller'. 
    return_results : bool 
        If true, then a results instance with extra information is returned, 
        otherwise only the computed power is returned. 
 
    Returns 
    ------- 
    results : results instance or float 
        If return_results is False, then only the power is returned. 
        If return_results is True, then a results instance with the 
        information in attributes is returned. 
 
        power : float 
            Power of the test, e.g. 0.8, is one minus the probability of a 
            type II error. Power is the probability that the test correctly 
            rejects the Null Hypothesis if the Alternative Hypothesis is true. 
 
        Other attributes in results instance include : 
 
        std_null 
            standard error of difference under the null hypothesis (without 
            sqrt(nobs1)) 
        std_alt 
            standard error of difference under the alternative hypothesis 
            (without sqrt(nobs1)) 
 
    References 
    ---------- 
    .. [1] Zhu, Haiyuan. 2017. “Sample Size Calculation for Comparing Two 
       Poisson or Negative Binomial Rates in Noninferiority or Equivalence 
       Trials.” Statistics in Biopharmaceutical Research, March. 
       https://doi.org/10.1080/19466315.2016.1225594 
    .. [2] Zhu, Haiyuan, and Hassan Lakkis. 2014. “Sample Size Calculation for 
       Comparing Two Negative Binomial Rates.” Statistics in Medicine 33 (3): 
       376–87. https://doi.org/10.1002/sim.5947. 
    .. [3] PASS documentation 
    &quot;&quot;&quot;</span>
    <span class="s3"># TODO: avoid possible circular import, check if needed</span>
    <span class="s2">from </span><span class="s1">statsmodels.stats.power </span><span class="s2">import </span><span class="s1">normal_power_het</span>

    <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1 = map(np.asarray</span><span class="s2">, </span><span class="s1">[rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1])</span>

    <span class="s1">nobs2 = nobs_ratio * nobs1</span>
    <span class="s1">v1 = dispersion / exposure * (</span><span class="s5">1 </span><span class="s1">/ rate1 + </span><span class="s5">1 </span><span class="s1">/ (nobs_ratio * rate2))</span>
    <span class="s2">if </span><span class="s1">method_var == </span><span class="s4">&quot;alt&quot;</span><span class="s1">:</span>
        <span class="s1">v0 = v1</span>
    <span class="s2">elif </span><span class="s1">method_var == </span><span class="s4">&quot;score&quot;</span><span class="s1">:</span>
        <span class="s3"># nobs_ratio = 1 / nobs_ratio</span>
        <span class="s1">v0 = dispersion / exposure * (</span><span class="s5">1 </span><span class="s1">+ value / nobs_ratio)**</span><span class="s5">2</span>
        <span class="s1">v0 /= value / nobs_ratio * (rate1 + (nobs_ratio * rate2))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">f&quot;method_var </span><span class="s2">{</span><span class="s1">method_var</span><span class="s2">} </span><span class="s4">not recognized&quot;</span><span class="s1">)</span>

    <span class="s1">std_null = np.sqrt(v0)</span>
    <span class="s1">std_alt = np.sqrt(v1)</span>
    <span class="s1">es = np.log(rate1 / rate2) - np.log(value)</span>

    <span class="s1">pow_ = normal_power_het(es</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">std_null=std_null</span><span class="s2">,</span>
                            <span class="s1">std_alternative=std_alt</span><span class="s2">,</span>
                            <span class="s1">alternative=alternative)</span>

    <span class="s1">p_pooled = </span><span class="s2">None  </span><span class="s3"># TODO: replace or remove</span>

    <span class="s2">if </span><span class="s1">return_results:</span>
        <span class="s1">res = HolderTuple(</span>
            <span class="s1">power=pow_</span><span class="s2">,</span>
            <span class="s1">p_pooled=p_pooled</span><span class="s2">,</span>
            <span class="s1">std_null=std_null</span><span class="s2">,</span>
            <span class="s1">std_alt=std_alt</span><span class="s2">,</span>
            <span class="s1">nobs1=nobs1</span><span class="s2">,</span>
            <span class="s1">nobs2=nobs2</span><span class="s2">,</span>
            <span class="s1">nobs_ratio=nobs_ratio</span><span class="s2">,</span>
            <span class="s1">alpha=alpha</span><span class="s2">,</span>
            <span class="s1">tuple_=(</span><span class="s4">&quot;power&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># override default</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">return </span><span class="s1">pow_</span>


<span class="s2">def </span><span class="s1">power_equivalence_poisson_2indep(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">,</span>
                                     <span class="s1">low</span><span class="s2">, </span><span class="s1">upp</span><span class="s2">, </span><span class="s1">nobs_ratio=</span><span class="s5">1</span><span class="s2">,</span>
                                     <span class="s1">exposure=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">, </span><span class="s1">dispersion=</span><span class="s5">1</span><span class="s2">,</span>
                                     <span class="s1">method_var=</span><span class="s4">&quot;alt&quot;</span><span class="s2">,</span>
                                     <span class="s1">return_results=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Power of equivalence test of ratio of 2 independent poisson rates. 
 
    Parameters 
    ---------- 
    rate1 : float 
        Poisson rate for the first sample, treatment group, under the 
        alternative hypothesis. 
    rate2 : float 
        Poisson rate for the second sample, reference group, under the 
        alternative hypothesis. 
    nobs1 : float or int 
        Number of observations in sample 1. 
    low : float 
        Lower equivalence margin for the rate ratio, rate1 / rate2. 
    upp : float 
        Upper equivalence margin for the rate ratio, rate1 / rate2. 
    nobs_ratio : float 
        Sample size ratio, nobs2 = nobs_ratio * nobs1. 
    exposure : float 
        Exposure for each observation. Total exposure is nobs1 * exposure 
        and nobs2 * exposure. 
    alpha : float in interval (0,1) 
        Significance level, e.g. 0.05, is the probability of a type I 
        error, that is wrong rejections if the Null Hypothesis is true. 
    value : float 
        Difference between rates 1 and 2 under the null hypothesis. 
    method_var : {&quot;score&quot;, &quot;alt&quot;} 
        The variance of the test statistic for the null hypothesis given the 
        rates uder the alternative, can be either equal to the rates under the 
        alternative ``method_var=&quot;alt&quot;``, or estimated under the constrained 
        of the null hypothesis, ``method_var=&quot;score&quot;``. 
    alternative : string, 'two-sided' (default), 'larger', 'smaller' 
        Alternative hypothesis whether the power is calculated for a 
        two-sided (default) or one sided test. The one-sided test can be 
        either 'larger', 'smaller'. 
    return_results : bool 
        If true, then a results instance with extra information is returned, 
        otherwise only the computed power is returned. 
 
    Returns 
    ------- 
    results : results instance or float 
        If return_results is False, then only the power is returned. 
        If return_results is True, then a results instance with the 
        information in attributes is returned. 
 
        power : float 
            Power of the test, e.g. 0.8, is one minus the probability of a 
            type II error. Power is the probability that the test correctly 
            rejects the Null Hypothesis if the Alternative Hypothesis is true. 
 
        Other attributes in results instance include : 
 
        std_null 
            standard error of difference under the null hypothesis (without 
            sqrt(nobs1)) 
        std_alt 
            standard error of difference under the alternative hypothesis 
            (without sqrt(nobs1)) 
 
    References 
    ---------- 
    .. [1] Zhu, Haiyuan. 2017. “Sample Size Calculation for Comparing Two 
       Poisson or Negative Binomial Rates in Noninferiority or Equivalence 
       Trials.” Statistics in Biopharmaceutical Research, March. 
       https://doi.org/10.1080/19466315.2016.1225594 
    .. [2] Zhu, Haiyuan, and Hassan Lakkis. 2014. “Sample Size Calculation for 
       Comparing Two Negative Binomial Rates.” Statistics in Medicine 33 (3): 
       376–87. https://doi.org/10.1002/sim.5947. 
    .. [3] PASS documentation 
    &quot;&quot;&quot;</span>
    <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1 = map(np.asarray</span><span class="s2">, </span><span class="s1">[rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1])</span>

    <span class="s1">nobs2 = nobs_ratio * nobs1</span>
    <span class="s1">v1 = dispersion / exposure * (</span><span class="s5">1 </span><span class="s1">/ rate1 + </span><span class="s5">1 </span><span class="s1">/ (nobs_ratio * rate2))</span>

    <span class="s2">if </span><span class="s1">method_var == </span><span class="s4">&quot;alt&quot;</span><span class="s1">:</span>
        <span class="s1">v0_low = v0_upp = v1</span>
    <span class="s2">elif </span><span class="s1">method_var == </span><span class="s4">&quot;score&quot;</span><span class="s1">:</span>
        <span class="s1">v0_low = dispersion / exposure * (</span><span class="s5">1 </span><span class="s1">+ low * nobs_ratio)**</span><span class="s5">2</span>
        <span class="s1">v0_low /= low * nobs_ratio * (rate1 + (nobs_ratio * rate2))</span>
        <span class="s1">v0_upp = dispersion / exposure * (</span><span class="s5">1 </span><span class="s1">+ upp * nobs_ratio)**</span><span class="s5">2</span>
        <span class="s1">v0_upp /= upp * nobs_ratio * (rate1 + (nobs_ratio * rate2))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">f&quot;method_var </span><span class="s2">{</span><span class="s1">method_var</span><span class="s2">} </span><span class="s4">not recognized&quot;</span><span class="s1">)</span>

    <span class="s1">es_low = np.log(rate1 / rate2) - np.log(low)</span>
    <span class="s1">es_upp = np.log(rate1 / rate2) - np.log(upp)</span>
    <span class="s1">std_null_low = np.sqrt(v0_low)</span>
    <span class="s1">std_null_upp = np.sqrt(v0_upp)</span>
    <span class="s1">std_alternative = np.sqrt(v1)</span>

    <span class="s1">pow_ = _power_equivalence_het(es_low</span><span class="s2">, </span><span class="s1">es_upp</span><span class="s2">, </span><span class="s1">nobs2</span><span class="s2">, </span><span class="s1">alpha=alpha</span><span class="s2">,</span>
                                  <span class="s1">std_null_low=std_null_low</span><span class="s2">,</span>
                                  <span class="s1">std_null_upp=std_null_upp</span><span class="s2">,</span>
                                  <span class="s1">std_alternative=std_alternative)</span>

    <span class="s2">if </span><span class="s1">return_results:</span>
        <span class="s1">res = HolderTuple(</span>
            <span class="s1">power=pow_[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">power_margins=pow[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">std_null_low=std_null_low</span><span class="s2">,</span>
            <span class="s1">std_null_upp=std_null_upp</span><span class="s2">,</span>
            <span class="s1">std_alt=std_alternative</span><span class="s2">,</span>
            <span class="s1">nobs1=nobs1</span><span class="s2">,</span>
            <span class="s1">nobs2=nobs2</span><span class="s2">,</span>
            <span class="s1">nobs_ratio=nobs_ratio</span><span class="s2">,</span>
            <span class="s1">alpha=alpha</span><span class="s2">,</span>
            <span class="s1">tuple_=(</span><span class="s4">&quot;power&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># override default</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">res</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pow_[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_power_equivalence_het_v0(es_low</span><span class="s2">, </span><span class="s1">es_upp</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
                              <span class="s1">std_null_low=</span><span class="s2">None,</span>
                              <span class="s1">std_null_upp=</span><span class="s2">None,</span>
                              <span class="s1">std_alternative=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;power for equivalence test 
 
    &quot;&quot;&quot;</span>

    <span class="s1">s0_low = std_null_low</span>
    <span class="s1">s0_upp = std_null_upp</span>
    <span class="s1">s1 = std_alternative</span>

    <span class="s1">crit = norm.isf(alpha)</span>
    <span class="s1">pow_ = (</span>
        <span class="s1">norm.cdf((np.sqrt(nobs) * es_low - crit * s0_low) / s1) +</span>
        <span class="s1">norm.cdf((np.sqrt(nobs) * es_upp - crit * s0_upp) / s1) - </span><span class="s5">1</span>
        <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">pow_</span>


<span class="s2">def </span><span class="s1">_power_equivalence_het(es_low</span><span class="s2">, </span><span class="s1">es_upp</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
                           <span class="s1">std_null_low=</span><span class="s2">None,</span>
                           <span class="s1">std_null_upp=</span><span class="s2">None,</span>
                           <span class="s1">std_alternative=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;power for equivalence test 
 
    &quot;&quot;&quot;</span>

    <span class="s1">s0_low = std_null_low</span>
    <span class="s1">s0_upp = std_null_upp</span>
    <span class="s1">s1 = std_alternative</span>

    <span class="s1">crit = norm.isf(alpha)</span>

    <span class="s3"># Note: rejection region is an interval [low, upp]</span>
    <span class="s3"># Here we compute the complement of the two tail probabilities</span>
    <span class="s1">p1 = norm.sf((np.sqrt(nobs) * es_low - crit * s0_low) / s1)</span>
    <span class="s1">p2 = norm.cdf((np.sqrt(nobs) * es_upp + crit * s0_upp) / s1)</span>
    <span class="s1">pow_ = </span><span class="s5">1 </span><span class="s1">- (p1 + p2)</span>
    <span class="s2">return </span><span class="s1">pow_</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span>


<span class="s2">def </span><span class="s1">_std_2poisson_power(</span>
        <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs_ratio=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
        <span class="s1">exposure=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">dispersion=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">value=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">method_var=</span><span class="s4">&quot;score&quot;</span><span class="s2">,</span>
        <span class="s1">):</span>
    <span class="s1">rates_pooled = (rate1 + rate2 * nobs_ratio) / (</span><span class="s5">1 </span><span class="s1">+ nobs_ratio)</span>
    <span class="s3"># v1 = dispersion / exposure * (1 / rate2 + 1 / (nobs_ratio * rate1))</span>
    <span class="s2">if </span><span class="s1">method_var == </span><span class="s4">&quot;alt&quot;</span><span class="s1">:</span>
        <span class="s1">v0 = v1 = rate1 + rate2 / nobs_ratio</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># uaw n1 = 1 as normalization</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">r1_cmle</span><span class="s2">, </span><span class="s1">r2_cmle = _score_diff(</span>
            <span class="s1">rate1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">rate2 * nobs_ratio</span><span class="s2">, </span><span class="s1">nobs_ratio</span><span class="s2">, </span><span class="s1">value=value</span><span class="s2">,</span>
            <span class="s1">return_cmle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">v1 = rate1 + rate2 / nobs_ratio</span>
        <span class="s1">v0 = r1_cmle + r2_cmle / nobs_ratio</span>
    <span class="s2">return </span><span class="s1">rates_pooled</span><span class="s2">, </span><span class="s1">np.sqrt(v0)</span><span class="s2">, </span><span class="s1">np.sqrt(v1)</span>


<span class="s2">def </span><span class="s1">power_poisson_diff_2indep(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">, </span><span class="s1">nobs_ratio=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
                              <span class="s1">value=</span><span class="s5">0</span><span class="s2">,</span>
                              <span class="s1">method_var=</span><span class="s4">&quot;score&quot;</span><span class="s2">,</span>
                              <span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s2">,</span>
                              <span class="s1">return_results=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Power of ztest for the difference between two independent poisson rates. 
 
    Parameters 
    ---------- 
    rate1 : float 
        Poisson rate for the first sample, treatment group, under the 
        alternative hypothesis. 
    rate2 : float 
        Poisson rate for the second sample, reference group, under the 
        alternative hypothesis. 
    nobs1 : float or int 
        Number of observations in sample 1. 
    nobs_ratio : float 
        Sample size ratio, nobs2 = nobs_ratio * nobs1. 
    alpha : float in interval (0,1) 
        Significance level, e.g. 0.05, is the probability of a type I 
        error, that is wrong rejections if the Null Hypothesis is true. 
    value : float 
        Difference between rates 1 and 2 under the null hypothesis. 
    method_var : {&quot;score&quot;, &quot;alt&quot;} 
        The variance of the test statistic for the null hypothesis given the 
        rates uder the alternative, can be either equal to the rates under the 
        alternative ``method_var=&quot;alt&quot;``, or estimated under the constrained 
        of the null hypothesis, ``method_var=&quot;score&quot;``. 
    alternative : string, 'two-sided' (default), 'larger', 'smaller' 
        Alternative hypothesis whether the power is calculated for a 
        two-sided (default) or one sided test. The one-sided test can be 
        either 'larger', 'smaller'. 
    return_results : bool 
        If true, then a results instance with extra information is returned, 
        otherwise only the computed power is returned. 
 
    Returns 
    ------- 
    results : results instance or float 
        If return_results is False, then only the power is returned. 
        If return_results is True, then a results instance with the 
        information in attributes is returned. 
 
        power : float 
            Power of the test, e.g. 0.8, is one minus the probability of a 
            type II error. Power is the probability that the test correctly 
            rejects the Null Hypothesis if the Alternative Hypothesis is true. 
 
        Other attributes in results instance include : 
 
        std_null 
            standard error of difference under the null hypothesis (without 
            sqrt(nobs1)) 
        std_alt 
            standard error of difference under the alternative hypothesis 
            (without sqrt(nobs1)) 
 
    References 
    ---------- 
    .. [1] Stucke, Kathrin, and Meinhard Kieser. 2013. “Sample Size 
       Calculations for Noninferiority Trials with Poisson Distributed Count 
       Data.” Biometrical Journal 55 (2): 203–16. 
       https://doi.org/10.1002/bimj.201200142. 
    .. [2] PASS manual chapter 436 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># TODO: avoid possible circular import, check if needed</span>
    <span class="s2">from </span><span class="s1">statsmodels.stats.power </span><span class="s2">import </span><span class="s1">normal_power_het</span>

    <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1 = map(np.asarray</span><span class="s2">, </span><span class="s1">[rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1])</span>

    <span class="s1">diff = rate1 - rate2</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">std_null</span><span class="s2">, </span><span class="s1">std_alt = _std_2poisson_power(</span>
        <span class="s1">rate1</span><span class="s2">,</span>
        <span class="s1">rate2</span><span class="s2">,</span>
        <span class="s1">nobs_ratio=nobs_ratio</span><span class="s2">,</span>
        <span class="s1">alpha=alpha</span><span class="s2">,</span>
        <span class="s1">value=value</span><span class="s2">,</span>
        <span class="s1">method_var=method_var</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">pow_ = normal_power_het(diff - value</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">std_null=std_null</span><span class="s2">,</span>
                            <span class="s1">std_alternative=std_alt</span><span class="s2">,</span>
                            <span class="s1">alternative=alternative)</span>

    <span class="s2">if </span><span class="s1">return_results:</span>
        <span class="s1">res = HolderTuple(</span>
            <span class="s1">power=pow_</span><span class="s2">,</span>
            <span class="s1">rates_alt=(rate2 + diff</span><span class="s2">, </span><span class="s1">rate2)</span><span class="s2">,</span>
            <span class="s1">std_null=std_null</span><span class="s2">,</span>
            <span class="s1">std_alt=std_alt</span><span class="s2">,</span>
            <span class="s1">nobs1=nobs1</span><span class="s2">,</span>
            <span class="s1">nobs2=nobs_ratio * nobs1</span><span class="s2">,</span>
            <span class="s1">nobs_ratio=nobs_ratio</span><span class="s2">,</span>
            <span class="s1">alpha=alpha</span><span class="s2">,</span>
            <span class="s1">tuple_=(</span><span class="s4">&quot;power&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># override default</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">res</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pow_</span>


<span class="s2">def </span><span class="s1">_var_cmle_negbin(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs_ratio</span><span class="s2">, </span><span class="s1">exposure=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">value=</span><span class="s5">1</span><span class="s2">,</span>
                     <span class="s1">dispersion=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    variance based on constrained cmle, for score test version 
 
    for ratio comparison of two negative binomial samples 
 
    value = rate1 / rate2 under the null 
    &quot;&quot;&quot;</span>
    <span class="s3"># definitions in Zhu</span>
    <span class="s3"># nobs_ratio = n1 / n0</span>
    <span class="s3"># value = ratio = r1 / r0</span>
    <span class="s1">rate0 = rate2  </span><span class="s3"># control</span>
    <span class="s1">nobs_ratio = </span><span class="s5">1 </span><span class="s1">/ nobs_ratio</span>

    <span class="s1">a = - dispersion * exposure * value * (</span><span class="s5">1 </span><span class="s1">+ nobs_ratio)</span>
    <span class="s1">b = (dispersion * exposure * (rate0 * value + nobs_ratio * rate1) -</span>
         <span class="s1">(</span><span class="s5">1 </span><span class="s1">+ nobs_ratio * value))</span>
    <span class="s1">c = rate0 + nobs_ratio * rate1</span>
    <span class="s2">if </span><span class="s1">dispersion == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">r0 = -c / b</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">r0 = (-b - np.sqrt(b**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">4 </span><span class="s1">* a * c)) / (</span><span class="s5">2 </span><span class="s1">* a)</span>
    <span class="s1">r1 = r0 * value</span>
    <span class="s1">v = (</span><span class="s5">1 </span><span class="s1">/ exposure / r0 * (</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">/ value / nobs_ratio) +</span>
         <span class="s1">(</span><span class="s5">1 </span><span class="s1">+ nobs_ratio) / nobs_ratio * dispersion)</span>

    <span class="s1">r2 = r0</span>
    <span class="s2">return </span><span class="s1">v * nobs_ratio</span><span class="s2">, </span><span class="s1">r1</span><span class="s2">, </span><span class="s1">r2</span>


<span class="s2">def </span><span class="s1">power_negbin_ratio_2indep(</span>
        <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">,</span>
        <span class="s1">nobs_ratio=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">exposure=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">value=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">,</span>
        <span class="s1">dispersion=</span><span class="s5">0.01</span><span class="s2">,</span>
        <span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s2">,</span>
        <span class="s1">method_var=</span><span class="s4">&quot;alt&quot;</span><span class="s2">,</span>
        <span class="s1">return_results=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Power of test of ratio of 2 independent negative binomial rates. 
 
    Parameters 
    ---------- 
    rate1 : float 
        Poisson rate for the first sample, treatment group, under the 
        alternative hypothesis. 
    rate2 : float 
        Poisson rate for the second sample, reference group, under the 
        alternative hypothesis. 
    nobs1 : float or int 
        Number of observations in sample 1. 
    low : float 
        Lower equivalence margin for the rate ratio, rate1 / rate2. 
    upp : float 
        Upper equivalence margin for the rate ratio, rate1 / rate2. 
    nobs_ratio : float 
        Sample size ratio, nobs2 = nobs_ratio * nobs1. 
    exposure : float 
        Exposure for each observation. Total exposure is nobs1 * exposure 
        and nobs2 * exposure. 
    value : float 
        Rate ratio, rate1 / rate2, under the null hypothesis. 
    alpha : float in interval (0,1) 
        Significance level, e.g. 0.05, is the probability of a type I 
        error, that is wrong rejections if the Null Hypothesis is true. 
    dispersion : float &gt;= 0. 
        Dispersion parameter for Negative Binomial distribution. 
        The Poisson limiting case corresponds to ``dispersion=0``. 
    method_var : {&quot;score&quot;, &quot;alt&quot;} 
        The variance of the test statistic for the null hypothesis given the 
        rates under the alternative, can be either equal to the rates under the 
        alternative ``method_var=&quot;alt&quot;``, or estimated under the constrained 
        of the null hypothesis, ``method_var=&quot;score&quot;``, or based on a moment 
        constrained estimate, ``method_var=&quot;ftotal&quot;``. see references. 
    alternative : string, 'two-sided' (default), 'larger', 'smaller' 
        Alternative hypothesis whether the power is calculated for a 
        two-sided (default) or one sided test. The one-sided test can be 
        either 'larger', 'smaller'. 
    return_results : bool 
        If true, then a results instance with extra information is returned, 
        otherwise only the computed power is returned. 
 
    Returns 
    ------- 
    results : results instance or float 
        If return_results is False, then only the power is returned. 
        If return_results is True, then a results instance with the 
        information in attributes is returned. 
 
        power : float 
            Power of the test, e.g. 0.8, is one minus the probability of a 
            type II error. Power is the probability that the test correctly 
            rejects the Null Hypothesis if the Alternative Hypothesis is true. 
 
        Other attributes in results instance include : 
 
        std_null 
            standard error of difference under the null hypothesis (without 
            sqrt(nobs1)) 
        std_alt 
            standard error of difference under the alternative hypothesis 
            (without sqrt(nobs1)) 
 
    References 
    ---------- 
    .. [1] Zhu, Haiyuan. 2017. “Sample Size Calculation for Comparing Two 
       Poisson or Negative Binomial Rates in Noninferiority or Equivalence 
       Trials.” Statistics in Biopharmaceutical Research, March. 
       https://doi.org/10.1080/19466315.2016.1225594 
    .. [2] Zhu, Haiyuan, and Hassan Lakkis. 2014. “Sample Size Calculation for 
       Comparing Two Negative Binomial Rates.” Statistics in Medicine 33 (3): 
       376–87. https://doi.org/10.1002/sim.5947. 
    .. [3] PASS documentation 
    &quot;&quot;&quot;</span>
    <span class="s3"># TODO: avoid possible circular import, check if needed</span>
    <span class="s2">from </span><span class="s1">statsmodels.stats.power </span><span class="s2">import </span><span class="s1">normal_power_het</span>

    <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1 = map(np.asarray</span><span class="s2">, </span><span class="s1">[rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1])</span>

    <span class="s1">nobs2 = nobs_ratio * nobs1</span>
    <span class="s1">v1 = ((</span><span class="s5">1 </span><span class="s1">/ rate1 + </span><span class="s5">1 </span><span class="s1">/ (nobs_ratio * rate2)) / exposure +</span>
          <span class="s1">(</span><span class="s5">1 </span><span class="s1">+ nobs_ratio) / nobs_ratio * dispersion)</span>
    <span class="s2">if </span><span class="s1">method_var == </span><span class="s4">&quot;alt&quot;</span><span class="s1">:</span>
        <span class="s1">v0 = v1</span>
    <span class="s2">elif </span><span class="s1">method_var == </span><span class="s4">&quot;ftotal&quot;</span><span class="s1">:</span>
        <span class="s1">v0 = (</span><span class="s5">1 </span><span class="s1">+ value * nobs_ratio)**</span><span class="s5">2 </span><span class="s1">/ (</span>
             <span class="s1">exposure * nobs_ratio * value * (rate1 + nobs_ratio * rate2))</span>
        <span class="s1">v0 += (</span><span class="s5">1 </span><span class="s1">+ nobs_ratio) / nobs_ratio * dispersion</span>
    <span class="s2">elif </span><span class="s1">method_var == </span><span class="s4">&quot;score&quot;</span><span class="s1">:</span>
        <span class="s1">v0 = _var_cmle_negbin(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs_ratio</span><span class="s2">,</span>
                              <span class="s1">exposure=exposure</span><span class="s2">, </span><span class="s1">value=value</span><span class="s2">,</span>
                              <span class="s1">dispersion=dispersion)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">f&quot;method_var </span><span class="s2">{</span><span class="s1">method_var</span><span class="s2">} </span><span class="s4">not recognized&quot;</span><span class="s1">)</span>

    <span class="s1">std_null = np.sqrt(v0)</span>
    <span class="s1">std_alt = np.sqrt(v1)</span>
    <span class="s1">es = np.log(rate1 / rate2) - np.log(value)</span>

    <span class="s1">pow_ = normal_power_het(es</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">std_null=std_null</span><span class="s2">,</span>
                            <span class="s1">std_alternative=std_alt</span><span class="s2">,</span>
                            <span class="s1">alternative=alternative)</span>

    <span class="s2">if </span><span class="s1">return_results:</span>
        <span class="s1">res = HolderTuple(</span>
            <span class="s1">power=pow_</span><span class="s2">,</span>
            <span class="s1">std_null=std_null</span><span class="s2">,</span>
            <span class="s1">std_alt=std_alt</span><span class="s2">,</span>
            <span class="s1">nobs1=nobs1</span><span class="s2">,</span>
            <span class="s1">nobs2=nobs2</span><span class="s2">,</span>
            <span class="s1">nobs_ratio=nobs_ratio</span><span class="s2">,</span>
            <span class="s1">alpha=alpha</span><span class="s2">,</span>
            <span class="s1">tuple_=(</span><span class="s4">&quot;power&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># override default</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">return </span><span class="s1">pow_</span>


<span class="s2">def </span><span class="s1">power_equivalence_neginb_2indep(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">,</span>
                                    <span class="s1">low</span><span class="s2">, </span><span class="s1">upp</span><span class="s2">, </span><span class="s1">nobs_ratio=</span><span class="s5">1</span><span class="s2">,</span>
                                    <span class="s1">exposure=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">, </span><span class="s1">dispersion=</span><span class="s5">0</span><span class="s2">,</span>
                                    <span class="s1">method_var=</span><span class="s4">&quot;alt&quot;</span><span class="s2">,</span>
                                    <span class="s1">return_results=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Power of equivalence test of ratio of 2 indep. negative binomial rates. 
 
    Parameters 
    ---------- 
    rate1 : float 
        Poisson rate for the first sample, treatment group, under the 
        alternative hypothesis. 
    rate2 : float 
        Poisson rate for the second sample, reference group, under the 
        alternative hypothesis. 
    nobs1 : float or int 
        Number of observations in sample 1. 
    low : float 
        Lower equivalence margin for the rate ratio, rate1 / rate2. 
    upp : float 
        Upper equivalence margin for the rate ratio, rate1 / rate2. 
    nobs_ratio : float 
        Sample size ratio, nobs2 = nobs_ratio * nobs1. 
    alpha : float in interval (0,1) 
        Significance level, e.g. 0.05, is the probability of a type I 
        error, that is wrong rejections if the Null Hypothesis is true. 
    dispersion : float &gt;= 0. 
        Dispersion parameter for Negative Binomial distribution. 
        The Poisson limiting case corresponds to ``dispersion=0``. 
    method_var : {&quot;score&quot;, &quot;alt&quot;} 
        The variance of the test statistic for the null hypothesis given the 
        rates under the alternative, can be either equal to the rates under the 
        alternative ``method_var=&quot;alt&quot;``, or estimated under the constrained 
        of the null hypothesis, ``method_var=&quot;score&quot;``, or based on a moment 
        constrained estimate, ``method_var=&quot;ftotal&quot;``. see references. 
    alternative : string, 'two-sided' (default), 'larger', 'smaller' 
        Alternative hypothesis whether the power is calculated for a 
        two-sided (default) or one sided test. The one-sided test can be 
        either 'larger', 'smaller'. 
    return_results : bool 
        If true, then a results instance with extra information is returned, 
        otherwise only the computed power is returned. 
 
    Returns 
    ------- 
    results : results instance or float 
        If return_results is False, then only the power is returned. 
        If return_results is True, then a results instance with the 
        information in attributes is returned. 
 
        power : float 
            Power of the test, e.g. 0.8, is one minus the probability of a 
            type II error. Power is the probability that the test correctly 
            rejects the Null Hypothesis if the Alternative Hypothesis is true. 
 
        Other attributes in results instance include : 
 
        std_null 
            standard error of difference under the null hypothesis (without 
            sqrt(nobs1)) 
        std_alt 
            standard error of difference under the alternative hypothesis 
            (without sqrt(nobs1)) 
 
 
    References 
    ---------- 
    .. [1] Zhu, Haiyuan. 2017. “Sample Size Calculation for Comparing Two 
       Poisson or Negative Binomial Rates in Noninferiority or Equivalence 
       Trials.” Statistics in Biopharmaceutical Research, March. 
       https://doi.org/10.1080/19466315.2016.1225594 
    .. [2] Zhu, Haiyuan, and Hassan Lakkis. 2014. “Sample Size Calculation for 
       Comparing Two Negative Binomial Rates.” Statistics in Medicine 33 (3): 
       376–87. https://doi.org/10.1002/sim.5947. 
    .. [3] PASS documentation 
    &quot;&quot;&quot;</span>
    <span class="s1">rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1 = map(np.asarray</span><span class="s2">, </span><span class="s1">[rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs1])</span>

    <span class="s1">nobs2 = nobs_ratio * nobs1</span>

    <span class="s1">v1 = ((</span><span class="s5">1 </span><span class="s1">/ rate2 + </span><span class="s5">1 </span><span class="s1">/ (nobs_ratio * rate1)) / exposure +</span>
          <span class="s1">(</span><span class="s5">1 </span><span class="s1">+ nobs_ratio) / nobs_ratio * dispersion)</span>
    <span class="s2">if </span><span class="s1">method_var == </span><span class="s4">&quot;alt&quot;</span><span class="s1">:</span>
        <span class="s1">v0_low = v0_upp = v1</span>
    <span class="s2">elif </span><span class="s1">method_var == </span><span class="s4">&quot;ftotal&quot;</span><span class="s1">:</span>
        <span class="s1">v0_low = (</span><span class="s5">1 </span><span class="s1">+ low * nobs_ratio)**</span><span class="s5">2 </span><span class="s1">/ (</span>
             <span class="s1">exposure * nobs_ratio * low * (rate1 + nobs_ratio * rate2))</span>
        <span class="s1">v0_low += (</span><span class="s5">1 </span><span class="s1">+ nobs_ratio) / nobs_ratio * dispersion</span>
        <span class="s1">v0_upp = (</span><span class="s5">1 </span><span class="s1">+ upp * nobs_ratio)**</span><span class="s5">2 </span><span class="s1">/ (</span>
             <span class="s1">exposure * nobs_ratio * upp * (rate1 + nobs_ratio * rate2))</span>
        <span class="s1">v0_upp += (</span><span class="s5">1 </span><span class="s1">+ nobs_ratio) / nobs_ratio * dispersion</span>
    <span class="s2">elif </span><span class="s1">method_var == </span><span class="s4">&quot;score&quot;</span><span class="s1">:</span>
        <span class="s1">v0_low = _var_cmle_negbin(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs_ratio</span><span class="s2">,</span>
                                  <span class="s1">exposure=exposure</span><span class="s2">, </span><span class="s1">value=low</span><span class="s2">,</span>
                                  <span class="s1">dispersion=dispersion)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">v0_upp = _var_cmle_negbin(rate1</span><span class="s2">, </span><span class="s1">rate2</span><span class="s2">, </span><span class="s1">nobs_ratio</span><span class="s2">,</span>
                                  <span class="s1">exposure=exposure</span><span class="s2">, </span><span class="s1">value=upp</span><span class="s2">,</span>
                                  <span class="s1">dispersion=dispersion)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">f&quot;method_var </span><span class="s2">{</span><span class="s1">method_var</span><span class="s2">} </span><span class="s4">not recognized&quot;</span><span class="s1">)</span>

    <span class="s1">es_low = np.log(rate1 / rate2) - np.log(low)</span>
    <span class="s1">es_upp = np.log(rate1 / rate2) - np.log(upp)</span>
    <span class="s1">std_null_low = np.sqrt(v0_low)</span>
    <span class="s1">std_null_upp = np.sqrt(v0_upp)</span>
    <span class="s1">std_alternative = np.sqrt(v1)</span>

    <span class="s1">pow_ = _power_equivalence_het(es_low</span><span class="s2">, </span><span class="s1">es_upp</span><span class="s2">, </span><span class="s1">nobs1</span><span class="s2">, </span><span class="s1">alpha=alpha</span><span class="s2">,</span>
                                  <span class="s1">std_null_low=std_null_low</span><span class="s2">,</span>
                                  <span class="s1">std_null_upp=std_null_upp</span><span class="s2">,</span>
                                  <span class="s1">std_alternative=std_alternative)</span>

    <span class="s2">if </span><span class="s1">return_results:</span>
        <span class="s1">res = HolderTuple(</span>
            <span class="s1">power=pow_[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">power_margins=pow[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">std_null_low=std_null_low</span><span class="s2">,</span>
            <span class="s1">std_null_upp=std_null_upp</span><span class="s2">,</span>
            <span class="s1">std_alt=std_alternative</span><span class="s2">,</span>
            <span class="s1">nobs1=nobs1</span><span class="s2">,</span>
            <span class="s1">nobs2=nobs2</span><span class="s2">,</span>
            <span class="s1">nobs_ratio=nobs_ratio</span><span class="s2">,</span>
            <span class="s1">alpha=alpha</span><span class="s2">,</span>
            <span class="s1">tuple_=(</span><span class="s4">&quot;power&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># override default</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">res</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pow_[</span><span class="s5">0</span><span class="s1">]</span>
</pre>
</body>
</html>