<html>
<head>
<title>test_minimize_constrained.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_minimize_constrained.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">scipy.linalg </span><span class="s0">import </span><span class="s1">block_diag</span>
<span class="s0">from </span><span class="s1">scipy.sparse </span><span class="s0">import </span><span class="s1">csc_matrix</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(TestCase</span><span class="s0">, </span><span class="s1">assert_array_almost_equal</span><span class="s0">,</span>
                           <span class="s1">assert_array_less</span><span class="s0">, </span><span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">,</span>
                           <span class="s1">suppress_warnings)</span>
<span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">(NonlinearConstraint</span><span class="s0">,</span>
                            <span class="s1">LinearConstraint</span><span class="s0">,</span>
                            <span class="s1">Bounds</span><span class="s0">,</span>
                            <span class="s1">minimize</span><span class="s0">,</span>
                            <span class="s1">BFGS</span><span class="s0">,</span>
                            <span class="s1">SR1)</span>


<span class="s0">class </span><span class="s1">Maratos:</span>
    <span class="s2">&quot;&quot;&quot;Problem 15.4 from Nocedal and Wright 
 
    The following optimization problem: 
        minimize 2*(x[0]**2 + x[1]**2 - 1) - x[0] 
        Subject to: x[0]**2 + x[1]**2 - 1 = 0 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">degrees=</span><span class="s3">60</span><span class="s0">, </span><span class="s1">constr_jac=</span><span class="s0">None, </span><span class="s1">constr_hess=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">rads = degrees/</span><span class="s3">180</span><span class="s1">*np.pi</span>
        <span class="s1">self.x0 = [np.cos(rads)</span><span class="s0">, </span><span class="s1">np.sin(rads)]</span>
        <span class="s1">self.x_opt = np.array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">])</span>
        <span class="s1">self.constr_jac = constr_jac</span>
        <span class="s1">self.constr_hess = constr_hess</span>
        <span class="s1">self.bounds = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">fun(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s3">2</span><span class="s1">*(x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">) - x[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">grad(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.array([</span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">hess(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s3">4</span><span class="s1">*np.eye(</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constr(self):</span>
        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2</span>

        <span class="s0">if </span><span class="s1">self.constr_jac </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">jac(x):</span>
                <span class="s0">return </span><span class="s1">[[</span><span class="s3">2</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]]]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">jac = self.constr_jac</span>

        <span class="s0">if </span><span class="s1">self.constr_hess </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">hess(x</span><span class="s0">, </span><span class="s1">v):</span>
                <span class="s0">return </span><span class="s3">2</span><span class="s1">*v[</span><span class="s3">0</span><span class="s1">]*np.eye(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hess = self.constr_hess</span>

        <span class="s0">return </span><span class="s1">NonlinearConstraint(fun</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">jac</span><span class="s0">, </span><span class="s1">hess)</span>


<span class="s0">class </span><span class="s1">MaratosTestArgs:</span>
    <span class="s2">&quot;&quot;&quot;Problem 15.4 from Nocedal and Wright 
 
    The following optimization problem: 
        minimize 2*(x[0]**2 + x[1]**2 - 1) - x[0] 
        Subject to: x[0]**2 + x[1]**2 - 1 = 0 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">degrees=</span><span class="s3">60</span><span class="s0">, </span><span class="s1">constr_jac=</span><span class="s0">None, </span><span class="s1">constr_hess=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">rads = degrees/</span><span class="s3">180</span><span class="s1">*np.pi</span>
        <span class="s1">self.x0 = [np.cos(rads)</span><span class="s0">, </span><span class="s1">np.sin(rads)]</span>
        <span class="s1">self.x_opt = np.array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">])</span>
        <span class="s1">self.constr_jac = constr_jac</span>
        <span class="s1">self.constr_hess = constr_hess</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.b = b</span>
        <span class="s1">self.bounds = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_test_args(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s0">if </span><span class="s1">self.a != a </span><span class="s0">or </span><span class="s1">self.b != b:</span>
            <span class="s0">raise </span><span class="s1">ValueError()</span>

    <span class="s0">def </span><span class="s1">fun(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s1">self._test_args(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s0">return </span><span class="s3">2</span><span class="s1">*(x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">) - x[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">grad(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s1">self._test_args(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s0">return </span><span class="s1">np.array([</span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">hess(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s1">self._test_args(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s0">return </span><span class="s3">4</span><span class="s1">*np.eye(</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constr(self):</span>
        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2</span>

        <span class="s0">if </span><span class="s1">self.constr_jac </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">jac(x):</span>
                <span class="s0">return </span><span class="s1">[[</span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]]]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">jac = self.constr_jac</span>

        <span class="s0">if </span><span class="s1">self.constr_hess </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">hess(x</span><span class="s0">, </span><span class="s1">v):</span>
                <span class="s0">return </span><span class="s3">2</span><span class="s1">*v[</span><span class="s3">0</span><span class="s1">]*np.eye(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hess = self.constr_hess</span>

        <span class="s0">return </span><span class="s1">NonlinearConstraint(fun</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">jac</span><span class="s0">, </span><span class="s1">hess)</span>


<span class="s0">class </span><span class="s1">MaratosGradInFunc:</span>
    <span class="s2">&quot;&quot;&quot;Problem 15.4 from Nocedal and Wright 
 
    The following optimization problem: 
        minimize 2*(x[0]**2 + x[1]**2 - 1) - x[0] 
        Subject to: x[0]**2 + x[1]**2 - 1 = 0 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">degrees=</span><span class="s3">60</span><span class="s0">, </span><span class="s1">constr_jac=</span><span class="s0">None, </span><span class="s1">constr_hess=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">rads = degrees/</span><span class="s3">180</span><span class="s1">*np.pi</span>
        <span class="s1">self.x0 = [np.cos(rads)</span><span class="s0">, </span><span class="s1">np.sin(rads)]</span>
        <span class="s1">self.x_opt = np.array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">])</span>
        <span class="s1">self.constr_jac = constr_jac</span>
        <span class="s1">self.constr_hess = constr_hess</span>
        <span class="s1">self.bounds = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">fun(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">2</span><span class="s1">*(x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">) - x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">np.array([</span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]]))</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">grad(self):</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">hess(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s3">4</span><span class="s1">*np.eye(</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constr(self):</span>
        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2</span>

        <span class="s0">if </span><span class="s1">self.constr_jac </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">jac(x):</span>
                <span class="s0">return </span><span class="s1">[[</span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]]]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">jac = self.constr_jac</span>

        <span class="s0">if </span><span class="s1">self.constr_hess </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">hess(x</span><span class="s0">, </span><span class="s1">v):</span>
                <span class="s0">return </span><span class="s3">2</span><span class="s1">*v[</span><span class="s3">0</span><span class="s1">]*np.eye(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hess = self.constr_hess</span>

        <span class="s0">return </span><span class="s1">NonlinearConstraint(fun</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">jac</span><span class="s0">, </span><span class="s1">hess)</span>


<span class="s0">class </span><span class="s1">HyperbolicIneq:</span>
    <span class="s2">&quot;&quot;&quot;Problem 15.1 from Nocedal and Wright 
 
    The following optimization problem: 
        minimize 1/2*(x[0] - 2)**2 + 1/2*(x[1] - 1/2)**2 
        Subject to: 1/(x[0] + 1) - x[1] &gt;= 1/4 
                                   x[0] &gt;= 0 
                                   x[1] &gt;= 0 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">constr_jac=</span><span class="s0">None, </span><span class="s1">constr_hess=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.x0 = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">self.x_opt = [</span><span class="s3">1.952823</span><span class="s0">, </span><span class="s3">0.088659</span><span class="s1">]</span>
        <span class="s1">self.constr_jac = constr_jac</span>
        <span class="s1">self.constr_hess = constr_hess</span>
        <span class="s1">self.bounds = Bounds(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.inf)</span>

    <span class="s0">def </span><span class="s1">fun(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">*(x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">2</span><span class="s1">)**</span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">*(x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">)**</span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">grad(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">[x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">2</span><span class="s0">, </span><span class="s1">x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">hess(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">np.eye(</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constr(self):</span>
        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s0">return </span><span class="s3">1</span><span class="s1">/(x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">) - x[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">self.constr_jac </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">jac(x):</span>
                <span class="s0">return </span><span class="s1">[[-</span><span class="s3">1</span><span class="s1">/(x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">)**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">jac = self.constr_jac</span>

        <span class="s0">if </span><span class="s1">self.constr_hess </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">hess(x</span><span class="s0">, </span><span class="s1">v):</span>
                <span class="s0">return </span><span class="s3">2</span><span class="s1">*v[</span><span class="s3">0</span><span class="s1">]*np.array([[</span><span class="s3">1</span><span class="s1">/(x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">)**</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                                        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hess = self.constr_hess</span>

        <span class="s0">return </span><span class="s1">NonlinearConstraint(fun</span><span class="s0">, </span><span class="s3">0.25</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">jac</span><span class="s0">, </span><span class="s1">hess)</span>


<span class="s0">class </span><span class="s1">Rosenbrock:</span>
    <span class="s2">&quot;&quot;&quot;Rosenbrock function. 
 
    The following optimization problem: 
        minimize sum(100.0*(x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">rng = np.random.RandomState(random_state)</span>
        <span class="s1">self.x0 = rng.uniform(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">self.x_opt = np.ones(n)</span>
        <span class="s1">self.bounds = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">fun(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s1">r = np.sum(</span><span class="s3">100.0 </span><span class="s1">* (x[</span><span class="s3">1</span><span class="s1">:] - x[:-</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2.0</span><span class="s1">)**</span><span class="s3">2.0 </span><span class="s1">+ (</span><span class="s3">1 </span><span class="s1">- x[:-</span><span class="s3">1</span><span class="s1">])**</span><span class="s3">2.0</span><span class="s0">,</span>
                   <span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">r</span>

    <span class="s0">def </span><span class="s1">grad(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s1">xm = x[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">xm_m1 = x[:-</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">xm_p1 = x[</span><span class="s3">2</span><span class="s1">:]</span>
        <span class="s1">der = np.zeros_like(x)</span>
        <span class="s1">der[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">] = (</span><span class="s3">200 </span><span class="s1">* (xm - xm_m1**</span><span class="s3">2</span><span class="s1">) -</span>
                     <span class="s3">400 </span><span class="s1">* (xm_p1 - xm**</span><span class="s3">2</span><span class="s1">) * xm - </span><span class="s3">2 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">- xm))</span>
        <span class="s1">der[</span><span class="s3">0</span><span class="s1">] = -</span><span class="s3">400 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] * (x[</span><span class="s3">1</span><span class="s1">] - x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2</span><span class="s1">) - </span><span class="s3">2 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">- x[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">der[-</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">200 </span><span class="s1">* (x[-</span><span class="s3">1</span><span class="s1">] - x[-</span><span class="s3">2</span><span class="s1">]**</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">der</span>

    <span class="s0">def </span><span class="s1">hess(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">x = np.atleast_1d(x)</span>
        <span class="s1">H = np.diag(-</span><span class="s3">400 </span><span class="s1">* x[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">) - np.diag(</span><span class="s3">400 </span><span class="s1">* x[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">diagonal = np.zeros(len(x)</span><span class="s0">, </span><span class="s1">dtype=x.dtype)</span>
        <span class="s1">diagonal[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1200 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">400 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">2</span>
        <span class="s1">diagonal[-</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">200</span>
        <span class="s1">diagonal[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">202 </span><span class="s1">+ </span><span class="s3">1200 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">400 </span><span class="s1">* x[</span><span class="s3">2</span><span class="s1">:]</span>
        <span class="s1">H = H + np.diag(diagonal)</span>
        <span class="s0">return </span><span class="s1">H</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constr(self):</span>
        <span class="s0">return </span><span class="s1">()</span>


<span class="s0">class </span><span class="s1">IneqRosenbrock(Rosenbrock):</span>
    <span class="s2">&quot;&quot;&quot;Rosenbrock subject to inequality constraints. 
 
    The following optimization problem: 
        minimize sum(100.0*(x[1] - x[0]**2)**2.0 + (1 - x[0])**2) 
        subject to: x[0] + 2 x[1] &lt;= 1 
 
    Taken from matlab ``fmincon`` documentation. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">Rosenbrock.__init__(self</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">random_state)</span>
        <span class="s1">self.x0 = [-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">]</span>
        <span class="s1">self.x_opt = [</span><span class="s3">0.5022</span><span class="s0">, </span><span class="s3">0.2489</span><span class="s1">]</span>
        <span class="s1">self.bounds = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constr(self):</span>
        <span class="s1">A = [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span>
        <span class="s1">b = </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">LinearConstraint(A</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s0">class </span><span class="s1">BoundedRosenbrock(Rosenbrock):</span>
    <span class="s2">&quot;&quot;&quot;Rosenbrock subject to inequality constraints. 
 
    The following optimization problem: 
        minimize sum(100.0*(x[1] - x[0]**2)**2.0 + (1 - x[0])**2) 
        subject to:  -2 &lt;= x[0] &lt;= 0 
                      0 &lt;= x[1] &lt;= 2 
 
    Taken from matlab ``fmincon`` documentation. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">Rosenbrock.__init__(self</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">random_state)</span>
        <span class="s1">self.x0 = [-</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.2</span><span class="s1">]</span>
        <span class="s1">self.x_opt = </span><span class="s0">None</span>
        <span class="s1">self.bounds = Bounds([-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">EqIneqRosenbrock(Rosenbrock):</span>
    <span class="s2">&quot;&quot;&quot;Rosenbrock subject to equality and inequality constraints. 
 
    The following optimization problem: 
        minimize sum(100.0*(x[1] - x[0]**2)**2.0 + (1 - x[0])**2) 
        subject to: x[0] + 2 x[1] &lt;= 1 
                    2 x[0] + x[1] = 1 
 
    Taken from matlab ``fimincon`` documentation. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">Rosenbrock.__init__(self</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">random_state)</span>
        <span class="s1">self.x0 = [-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">]</span>
        <span class="s1">self.x_opt = [</span><span class="s3">0.41494</span><span class="s0">, </span><span class="s3">0.17011</span><span class="s1">]</span>
        <span class="s1">self.bounds = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constr(self):</span>
        <span class="s1">A_ineq = [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span>
        <span class="s1">b_ineq = </span><span class="s3">1</span>
        <span class="s1">A_eq = [[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span>
        <span class="s1">b_eq = </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">(LinearConstraint(A_ineq</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">b_ineq)</span><span class="s0">,</span>
                <span class="s1">LinearConstraint(A_eq</span><span class="s0">, </span><span class="s1">b_eq</span><span class="s0">, </span><span class="s1">b_eq))</span>


<span class="s0">class </span><span class="s1">Elec:</span>
    <span class="s2">&quot;&quot;&quot;Distribution of electrons on a sphere. 
 
    Problem no 2 from COPS collection [2]_. Find 
    the equilibrium state distribution (of minimal 
    potential) of the electrons positioned on a 
    conducting sphere. 
 
    References 
    ---------- 
    .. [1] E. D. Dolan, J. J. Mor\'{e}, and T. S. Munson, 
           &quot;Benchmarking optimization software with COPS 3.0.&quot;, 
            Argonne National Lab., Argonne, IL (US), 2004. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">n_electrons=</span><span class="s3">200</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s0">,</span>
                 <span class="s1">constr_jac=</span><span class="s0">None, </span><span class="s1">constr_hess=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.n_electrons = n_electrons</span>
        <span class="s1">self.rng = np.random.RandomState(random_state)</span>
        <span class="s4"># Initial Guess</span>
        <span class="s1">phi = self.rng.uniform(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* np.pi</span><span class="s0">, </span><span class="s1">self.n_electrons)</span>
        <span class="s1">theta = self.rng.uniform(-np.pi</span><span class="s0">, </span><span class="s1">np.pi</span><span class="s0">, </span><span class="s1">self.n_electrons)</span>
        <span class="s1">x = np.cos(theta) * np.cos(phi)</span>
        <span class="s1">y = np.cos(theta) * np.sin(phi)</span>
        <span class="s1">z = np.sin(theta)</span>
        <span class="s1">self.x0 = np.hstack((x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z))</span>
        <span class="s1">self.x_opt = </span><span class="s0">None</span>
        <span class="s1">self.constr_jac = constr_jac</span>
        <span class="s1">self.constr_hess = constr_hess</span>
        <span class="s1">self.bounds = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_get_cordinates(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">x_coord = x[:self.n_electrons]</span>
        <span class="s1">y_coord = x[self.n_electrons:</span><span class="s3">2 </span><span class="s1">* self.n_electrons]</span>
        <span class="s1">z_coord = x[</span><span class="s3">2 </span><span class="s1">* self.n_electrons:]</span>
        <span class="s0">return </span><span class="s1">x_coord</span><span class="s0">, </span><span class="s1">y_coord</span><span class="s0">, </span><span class="s1">z_coord</span>

    <span class="s0">def </span><span class="s1">_compute_coordinate_deltas(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">x_coord</span><span class="s0">, </span><span class="s1">y_coord</span><span class="s0">, </span><span class="s1">z_coord = self._get_cordinates(x)</span>
        <span class="s1">dx = x_coord[:</span><span class="s0">, None</span><span class="s1">] - x_coord</span>
        <span class="s1">dy = y_coord[:</span><span class="s0">, None</span><span class="s1">] - y_coord</span>
        <span class="s1">dz = z_coord[:</span><span class="s0">, None</span><span class="s1">] - z_coord</span>
        <span class="s0">return </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy</span><span class="s0">, </span><span class="s1">dz</span>

    <span class="s0">def </span><span class="s1">fun(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">dx</span><span class="s0">, </span><span class="s1">dy</span><span class="s0">, </span><span class="s1">dz = self._compute_coordinate_deltas(x)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">dm1 = (dx**</span><span class="s3">2 </span><span class="s1">+ dy**</span><span class="s3">2 </span><span class="s1">+ dz**</span><span class="s3">2</span><span class="s1">) ** -</span><span class="s3">0.5</span>
        <span class="s1">dm1[np.diag_indices_from(dm1)] = </span><span class="s3">0</span>
        <span class="s0">return </span><span class="s3">0.5 </span><span class="s1">* np.sum(dm1)</span>

    <span class="s0">def </span><span class="s1">grad(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">dx</span><span class="s0">, </span><span class="s1">dy</span><span class="s0">, </span><span class="s1">dz = self._compute_coordinate_deltas(x)</span>

        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">dm3 = (dx**</span><span class="s3">2 </span><span class="s1">+ dy**</span><span class="s3">2 </span><span class="s1">+ dz**</span><span class="s3">2</span><span class="s1">) ** -</span><span class="s3">1.5</span>
        <span class="s1">dm3[np.diag_indices_from(dm3)] = </span><span class="s3">0</span>

        <span class="s1">grad_x = -np.sum(dx * dm3</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">grad_y = -np.sum(dy * dm3</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">grad_z = -np.sum(dz * dm3</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">np.hstack((grad_x</span><span class="s0">, </span><span class="s1">grad_y</span><span class="s0">, </span><span class="s1">grad_z))</span>

    <span class="s0">def </span><span class="s1">hess(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">dx</span><span class="s0">, </span><span class="s1">dy</span><span class="s0">, </span><span class="s1">dz = self._compute_coordinate_deltas(x)</span>
        <span class="s1">d = (dx**</span><span class="s3">2 </span><span class="s1">+ dy**</span><span class="s3">2 </span><span class="s1">+ dz**</span><span class="s3">2</span><span class="s1">) ** </span><span class="s3">0.5</span>

        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">dm3 = d ** -</span><span class="s3">3</span>
            <span class="s1">dm5 = d ** -</span><span class="s3">5</span>

        <span class="s1">i = np.arange(self.n_electrons)</span>
        <span class="s1">dm3[i</span><span class="s0">, </span><span class="s1">i] = </span><span class="s3">0</span>
        <span class="s1">dm5[i</span><span class="s0">, </span><span class="s1">i] = </span><span class="s3">0</span>

        <span class="s1">Hxx = dm3 - </span><span class="s3">3 </span><span class="s1">* dx**</span><span class="s3">2 </span><span class="s1">* dm5</span>
        <span class="s1">Hxx[i</span><span class="s0">, </span><span class="s1">i] = -np.sum(Hxx</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">Hxy = -</span><span class="s3">3 </span><span class="s1">* dx * dy * dm5</span>
        <span class="s1">Hxy[i</span><span class="s0">, </span><span class="s1">i] = -np.sum(Hxy</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">Hxz = -</span><span class="s3">3 </span><span class="s1">* dx * dz * dm5</span>
        <span class="s1">Hxz[i</span><span class="s0">, </span><span class="s1">i] = -np.sum(Hxz</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">Hyy = dm3 - </span><span class="s3">3 </span><span class="s1">* dy**</span><span class="s3">2 </span><span class="s1">* dm5</span>
        <span class="s1">Hyy[i</span><span class="s0">, </span><span class="s1">i] = -np.sum(Hyy</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">Hyz = -</span><span class="s3">3 </span><span class="s1">* dy * dz * dm5</span>
        <span class="s1">Hyz[i</span><span class="s0">, </span><span class="s1">i] = -np.sum(Hyz</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">Hzz = dm3 - </span><span class="s3">3 </span><span class="s1">* dz**</span><span class="s3">2 </span><span class="s1">* dm5</span>
        <span class="s1">Hzz[i</span><span class="s0">, </span><span class="s1">i] = -np.sum(Hzz</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">H = np.vstack((</span>
            <span class="s1">np.hstack((Hxx</span><span class="s0">, </span><span class="s1">Hxy</span><span class="s0">, </span><span class="s1">Hxz))</span><span class="s0">,</span>
            <span class="s1">np.hstack((Hxy</span><span class="s0">, </span><span class="s1">Hyy</span><span class="s0">, </span><span class="s1">Hyz))</span><span class="s0">,</span>
            <span class="s1">np.hstack((Hxz</span><span class="s0">, </span><span class="s1">Hyz</span><span class="s0">, </span><span class="s1">Hzz))</span>
        <span class="s1">))</span>

        <span class="s0">return </span><span class="s1">H</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constr(self):</span>
        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s1">x_coord</span><span class="s0">, </span><span class="s1">y_coord</span><span class="s0">, </span><span class="s1">z_coord = self._get_cordinates(x)</span>
            <span class="s0">return </span><span class="s1">x_coord**</span><span class="s3">2 </span><span class="s1">+ y_coord**</span><span class="s3">2 </span><span class="s1">+ z_coord**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span>

        <span class="s0">if </span><span class="s1">self.constr_jac </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">jac(x):</span>
                <span class="s1">x_coord</span><span class="s0">, </span><span class="s1">y_coord</span><span class="s0">, </span><span class="s1">z_coord = self._get_cordinates(x)</span>
                <span class="s1">Jx = </span><span class="s3">2 </span><span class="s1">* np.diag(x_coord)</span>
                <span class="s1">Jy = </span><span class="s3">2 </span><span class="s1">* np.diag(y_coord)</span>
                <span class="s1">Jz = </span><span class="s3">2 </span><span class="s1">* np.diag(z_coord)</span>
                <span class="s0">return </span><span class="s1">csc_matrix(np.hstack((Jx</span><span class="s0">, </span><span class="s1">Jy</span><span class="s0">, </span><span class="s1">Jz)))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">jac = self.constr_jac</span>

        <span class="s0">if </span><span class="s1">self.constr_hess </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">hess(x</span><span class="s0">, </span><span class="s1">v):</span>
                <span class="s1">D = </span><span class="s3">2 </span><span class="s1">* np.diag(v)</span>
                <span class="s0">return </span><span class="s1">block_diag(D</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">D)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hess = self.constr_hess</span>

        <span class="s0">return </span><span class="s1">NonlinearConstraint(fun</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">jac</span><span class="s0">, </span><span class="s1">hess)</span>


<span class="s0">class </span><span class="s1">TestTrustRegionConstr(TestCase):</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_list_of_problems(self):</span>
        <span class="s1">list_of_problems = [Maratos()</span><span class="s0">,</span>
                            <span class="s1">Maratos(constr_hess=</span><span class="s5">'2-point'</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">Maratos(constr_hess=SR1())</span><span class="s0">,</span>
                            <span class="s1">Maratos(constr_jac=</span><span class="s5">'2-point'</span><span class="s0">, </span><span class="s1">constr_hess=SR1())</span><span class="s0">,</span>
                            <span class="s1">MaratosGradInFunc()</span><span class="s0">,</span>
                            <span class="s1">HyperbolicIneq()</span><span class="s0">,</span>
                            <span class="s1">HyperbolicIneq(constr_hess=</span><span class="s5">'3-point'</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">HyperbolicIneq(constr_hess=BFGS())</span><span class="s0">,</span>
                            <span class="s1">HyperbolicIneq(constr_jac=</span><span class="s5">'3-point'</span><span class="s0">,</span>
                                           <span class="s1">constr_hess=BFGS())</span><span class="s0">,</span>
                            <span class="s1">Rosenbrock()</span><span class="s0">,</span>
                            <span class="s1">IneqRosenbrock()</span><span class="s0">,</span>
                            <span class="s1">EqIneqRosenbrock()</span><span class="s0">,</span>
                            <span class="s1">BoundedRosenbrock()</span><span class="s0">,</span>
                            <span class="s1">Elec(n_electrons=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">Elec(n_electrons=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">constr_hess=</span><span class="s5">'2-point'</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">Elec(n_electrons=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">constr_hess=SR1())</span><span class="s0">,</span>
                            <span class="s1">Elec(n_electrons=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">constr_jac=</span><span class="s5">'3-point'</span><span class="s0">,</span>
                                 <span class="s1">constr_hess=SR1())]</span>

        <span class="s0">for </span><span class="s1">prob </span><span class="s0">in </span><span class="s1">list_of_problems:</span>
            <span class="s0">for </span><span class="s1">grad </span><span class="s0">in </span><span class="s1">(prob.grad</span><span class="s0">, </span><span class="s5">'3-point'</span><span class="s0">, False</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">hess </span><span class="s0">in </span><span class="s1">(prob.hess</span><span class="s0">,</span>
                             <span class="s5">'3-point'</span><span class="s0">,</span>
                             <span class="s1">SR1()</span><span class="s0">,</span>
                             <span class="s1">BFGS(exception_strategy=</span><span class="s5">'damp_update'</span><span class="s1">)</span><span class="s0">,</span>
                             <span class="s1">BFGS(exception_strategy=</span><span class="s5">'skip_update'</span><span class="s1">)):</span>

                    <span class="s4"># Remove exceptions</span>
                    <span class="s0">if </span><span class="s1">grad </span><span class="s0">in </span><span class="s1">(</span><span class="s5">'2-point'</span><span class="s0">, </span><span class="s5">'3-point'</span><span class="s0">, </span><span class="s5">'cs'</span><span class="s0">, False</span><span class="s1">) </span><span class="s0">and </span><span class="s1">\</span>
                       <span class="s1">hess </span><span class="s0">in </span><span class="s1">(</span><span class="s5">'2-point'</span><span class="s0">, </span><span class="s5">'3-point'</span><span class="s0">, </span><span class="s5">'cs'</span><span class="s1">):</span>
                        <span class="s0">continue</span>
                    <span class="s0">if </span><span class="s1">prob.grad </span><span class="s0">is True and </span><span class="s1">grad </span><span class="s0">in </span><span class="s1">(</span><span class="s5">'3-point'</span><span class="s0">, False</span><span class="s1">):</span>
                        <span class="s0">continue</span>
                    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
                        <span class="s1">sup.filter(UserWarning</span><span class="s0">, </span><span class="s5">&quot;delta_grad == 0.0&quot;</span><span class="s1">)</span>
                        <span class="s1">result = minimize(prob.fun</span><span class="s0">, </span><span class="s1">prob.x0</span><span class="s0">,</span>
                                          <span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">,</span>
                                          <span class="s1">jac=grad</span><span class="s0">, </span><span class="s1">hess=hess</span><span class="s0">,</span>
                                          <span class="s1">bounds=prob.bounds</span><span class="s0">,</span>
                                          <span class="s1">constraints=prob.constr)</span>

                    <span class="s0">if </span><span class="s1">prob.x_opt </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">assert_array_almost_equal(result.x</span><span class="s0">, </span><span class="s1">prob.x_opt</span><span class="s0">,</span>
                                                  <span class="s1">decimal=</span><span class="s3">5</span><span class="s1">)</span>
                        <span class="s4"># gtol</span>
                        <span class="s0">if </span><span class="s1">result.status == </span><span class="s3">1</span><span class="s1">:</span>
                            <span class="s1">assert_array_less(result.optimality</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>
                    <span class="s4"># xtol</span>
                    <span class="s0">if </span><span class="s1">result.status == </span><span class="s3">2</span><span class="s1">:</span>
                        <span class="s1">assert_array_less(result.tr_radius</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>

                        <span class="s0">if </span><span class="s1">result.method == </span><span class="s5">&quot;tr_interior_point&quot;</span><span class="s1">:</span>
                            <span class="s1">assert_array_less(result.barrier_parameter</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>
                    <span class="s4"># max iter</span>
                    <span class="s0">if </span><span class="s1">result.status </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">):</span>
                        <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;Invalid termination condition.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_default_jac_and_hess(self):</span>
        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s0">return </span><span class="s1">(x - </span><span class="s3">1</span><span class="s1">) ** </span><span class="s3">2</span>
        <span class="s1">bounds = [(-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span>
        <span class="s1">res = minimize(fun</span><span class="s0">, </span><span class="s1">x0=[-</span><span class="s3">1.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bounds=bounds</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(res.x</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_default_hess(self):</span>
        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s0">return </span><span class="s1">(x - </span><span class="s3">1</span><span class="s1">) ** </span><span class="s3">2</span>
        <span class="s1">bounds = [(-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span>
        <span class="s1">res = minimize(fun</span><span class="s0">, </span><span class="s1">x0=[-</span><span class="s3">1.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bounds=bounds</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">,</span>
                       <span class="s1">jac=</span><span class="s5">'2-point'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(res.x</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_no_constraints(self):</span>
        <span class="s1">prob = Rosenbrock()</span>
        <span class="s1">result = minimize(prob.fun</span><span class="s0">, </span><span class="s1">prob.x0</span><span class="s0">,</span>
                          <span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">,</span>
                          <span class="s1">jac=prob.grad</span><span class="s0">, </span><span class="s1">hess=prob.hess)</span>
        <span class="s1">result1 = minimize(prob.fun</span><span class="s0">, </span><span class="s1">prob.x0</span><span class="s0">,</span>
                           <span class="s1">method=</span><span class="s5">'L-BFGS-B'</span><span class="s0">,</span>
                           <span class="s1">jac=</span><span class="s5">'2-point'</span><span class="s1">)</span>

        <span class="s1">result2 = minimize(prob.fun</span><span class="s0">, </span><span class="s1">prob.x0</span><span class="s0">,</span>
                           <span class="s1">method=</span><span class="s5">'L-BFGS-B'</span><span class="s0">,</span>
                           <span class="s1">jac=</span><span class="s5">'3-point'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(result.x</span><span class="s0">, </span><span class="s1">prob.x_opt</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(result1.x</span><span class="s0">, </span><span class="s1">prob.x_opt</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(result2.x</span><span class="s0">, </span><span class="s1">prob.x_opt</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_hessp(self):</span>
        <span class="s1">prob = Maratos()</span>

        <span class="s0">def </span><span class="s1">hessp(x</span><span class="s0">, </span><span class="s1">p):</span>
            <span class="s1">H = prob.hess(x)</span>
            <span class="s0">return </span><span class="s1">H.dot(p)</span>

        <span class="s1">result = minimize(prob.fun</span><span class="s0">, </span><span class="s1">prob.x0</span><span class="s0">,</span>
                          <span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">,</span>
                          <span class="s1">jac=prob.grad</span><span class="s0">, </span><span class="s1">hessp=hessp</span><span class="s0">,</span>
                          <span class="s1">bounds=prob.bounds</span><span class="s0">,</span>
                          <span class="s1">constraints=prob.constr)</span>

        <span class="s0">if </span><span class="s1">prob.x_opt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">assert_array_almost_equal(result.x</span><span class="s0">, </span><span class="s1">prob.x_opt</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s4"># gtol</span>
        <span class="s0">if </span><span class="s1">result.status == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">assert_array_less(result.optimality</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s4"># xtol</span>
        <span class="s0">if </span><span class="s1">result.status == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">assert_array_less(result.tr_radius</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">result.method == </span><span class="s5">&quot;tr_interior_point&quot;</span><span class="s1">:</span>
                <span class="s1">assert_array_less(result.barrier_parameter</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s4"># max iter</span>
        <span class="s0">if </span><span class="s1">result.status </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;Invalid termination condition.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_args(self):</span>
        <span class="s1">prob = MaratosTestArgs(</span><span class="s5">&quot;a&quot;</span><span class="s0">, </span><span class="s3">234</span><span class="s1">)</span>

        <span class="s1">result = minimize(prob.fun</span><span class="s0">, </span><span class="s1">prob.x0</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;a&quot;</span><span class="s0">, </span><span class="s3">234</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">,</span>
                          <span class="s1">jac=prob.grad</span><span class="s0">, </span><span class="s1">hess=prob.hess</span><span class="s0">,</span>
                          <span class="s1">bounds=prob.bounds</span><span class="s0">,</span>
                          <span class="s1">constraints=prob.constr)</span>

        <span class="s0">if </span><span class="s1">prob.x_opt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">assert_array_almost_equal(result.x</span><span class="s0">, </span><span class="s1">prob.x_opt</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s4"># gtol</span>
        <span class="s0">if </span><span class="s1">result.status == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">assert_array_less(result.optimality</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s4"># xtol</span>
        <span class="s0">if </span><span class="s1">result.status == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">assert_array_less(result.tr_radius</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">result.method == </span><span class="s5">&quot;tr_interior_point&quot;</span><span class="s1">:</span>
                <span class="s1">assert_array_less(result.barrier_parameter</span><span class="s0">, </span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s4"># max iter</span>
        <span class="s0">if </span><span class="s1">result.status </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;Invalid termination condition.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_raise_exception(self):</span>
        <span class="s1">prob = Maratos()</span>
        <span class="s1">message = </span><span class="s5">&quot;Whenever the gradient is estimated via finite-differences&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">minimize(prob.fun</span><span class="s0">, </span><span class="s1">prob.x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">, </span><span class="s1">jac=</span><span class="s5">'2-point'</span><span class="s0">,</span>
                     <span class="s1">hess=</span><span class="s5">'2-point'</span><span class="s0">, </span><span class="s1">constraints=prob.constr)</span>

    <span class="s0">def </span><span class="s1">test_issue_9044(self):</span>
        <span class="s4"># https://github.com/scipy/scipy/issues/9044</span>
        <span class="s4"># Test the returned `OptimizeResult` contains keys consistent with</span>
        <span class="s4"># other solvers.</span>

        <span class="s0">def </span><span class="s1">callback(x</span><span class="s0">, </span><span class="s1">info):</span>
            <span class="s1">assert_(</span><span class="s5">'nit' </span><span class="s0">in </span><span class="s1">info)</span>
            <span class="s1">assert_(</span><span class="s5">'niter' </span><span class="s0">in </span><span class="s1">info)</span>

        <span class="s1">result = minimize(</span><span class="s0">lambda </span><span class="s1">x: x**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">jac=</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">2</span><span class="s1">*x</span><span class="s0">,</span>
                          <span class="s1">hess=</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">2</span><span class="s0">, </span><span class="s1">callback=callback</span><span class="s0">,</span>
                          <span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s1">)</span>
        <span class="s1">assert_(result.get(</span><span class="s5">'success'</span><span class="s1">))</span>
        <span class="s1">assert_(result.get(</span><span class="s5">'nit'</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s4"># Also check existence of the 'niter' attribute, for backward</span>
        <span class="s4"># compatibility</span>
        <span class="s1">assert_(result.get(</span><span class="s5">'niter'</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_issue_15093(self):</span>
        <span class="s4"># scipy docs define bounds as inclusive, so it shouldn't be</span>
        <span class="s4"># an issue to set x0 on the bounds even if keep_feasible is</span>
        <span class="s4"># True. Previously, trust-constr would treat bounds as</span>
        <span class="s4"># exclusive.</span>

        <span class="s1">x0 = np.array([</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">])</span>

        <span class="s0">def </span><span class="s1">obj(x):</span>
            <span class="s1">x1 = x[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">x2 = x[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">x1 ** </span><span class="s3">2 </span><span class="s1">+ x2 ** </span><span class="s3">2</span>

        <span class="s1">bounds = Bounds(np.array([</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">])</span><span class="s0">,</span>
                        <span class="s1">keep_feasible=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s0">, </span><span class="s5">&quot;delta_grad == 0.0&quot;</span><span class="s1">)</span>
            <span class="s1">result = minimize(</span>
                <span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">,</span>
                <span class="s1">fun=obj</span><span class="s0">,</span>
                <span class="s1">x0=x0</span><span class="s0">,</span>
                <span class="s1">bounds=bounds)</span>

        <span class="s0">assert </span><span class="s1">result[</span><span class="s5">'success'</span><span class="s1">]</span>

<span class="s0">class </span><span class="s1">TestEmptyConstraint(TestCase):</span>
    <span class="s2">&quot;&quot;&quot; 
    Here we minimize x^2+y^2 subject to x^2-y^2&gt;1. 
    The actual minimum is at (0, 0) which fails the constraint. 
    Therefore we will find a minimum on the boundary at (+/-1, 0). 
 
    When minimizing on the boundary, optimize uses a set of 
    constraints that removes the constraint that sets that 
    boundary.  In our case, there's only one constraint, so 
    the result is an empty constraint. 
 
    This tests that the empty constraint works. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_empty_constraint(self):</span>

        <span class="s0">def </span><span class="s1">function(x):</span>
            <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2</span>

        <span class="s0">def </span><span class="s1">functionjacobian(x):</span>
            <span class="s0">return </span><span class="s1">np.array([</span><span class="s3">2.</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]])</span>

        <span class="s0">def </span><span class="s1">functionhvp(x</span><span class="s0">, </span><span class="s1">v):</span>
            <span class="s0">return </span><span class="s3">2.</span><span class="s1">*v</span>

        <span class="s0">def </span><span class="s1">constraint(x):</span>
            <span class="s0">return </span><span class="s1">np.array([x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">- x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2</span><span class="s1">])</span>

        <span class="s0">def </span><span class="s1">constraintjacobian(x):</span>
            <span class="s0">return </span><span class="s1">np.array([[</span><span class="s3">2</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]]])</span>

        <span class="s0">def </span><span class="s1">constraintlcoh(x</span><span class="s0">, </span><span class="s1">v):</span>
            <span class="s0">return </span><span class="s1">np.array([[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2.</span><span class="s1">]]) * v[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s1">constraint = NonlinearConstraint(constraint</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">constraintjacobian</span><span class="s0">, </span><span class="s1">constraintlcoh)</span>

        <span class="s1">startpoint = [</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span>

        <span class="s1">bounds = Bounds([-np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span><span class="s0">, </span><span class="s1">[np.inf</span><span class="s0">, </span><span class="s1">np.inf])</span>

        <span class="s1">result = minimize(</span>
          <span class="s1">function</span><span class="s0">,</span>
          <span class="s1">startpoint</span><span class="s0">,</span>
          <span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">,</span>
          <span class="s1">jac=functionjacobian</span><span class="s0">,</span>
          <span class="s1">hessp=functionhvp</span><span class="s0">,</span>
          <span class="s1">constraints=[constraint]</span><span class="s0">,</span>
          <span class="s1">bounds=bounds</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">assert_array_almost_equal(abs(result.x)</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_bug_11886():</span>
    <span class="s0">def </span><span class="s1">opt(x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2</span><span class="s1">+x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2</span>

    <span class="s0">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(PendingDeprecationWarning)</span>
        <span class="s1">A = np.matrix(np.diag([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]))</span>
    <span class="s1">lin_cons = LinearConstraint(A</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.inf)</span>
    <span class="s1">minimize(opt</span><span class="s0">, </span><span class="s3">2</span><span class="s1">*[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">constraints = lin_cons)  </span><span class="s4"># just checking that there are no errors</span>


<span class="s4"># Remove xfail when gh-11649 is resolved</span>
<span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;Known bug in trust-constr; see gh-11649.&quot;</span><span class="s0">,</span>
                   <span class="s1">strict=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_gh11649():</span>
    <span class="s1">bnds = Bounds(lb=[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ub=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keep_feasible=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">assert_inbounds(x):</span>
        <span class="s0">assert </span><span class="s1">np.all(x &gt;= bnds.lb)</span>
        <span class="s0">assert </span><span class="s1">np.all(x &lt;= bnds.ub)</span>

    <span class="s0">def </span><span class="s1">obj(x):</span>
        <span class="s1">assert_inbounds(x)</span>
        <span class="s0">return </span><span class="s1">np.exp(x[</span><span class="s3">0</span><span class="s1">])*(</span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">2</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">4</span><span class="s1">*x[</span><span class="s3">0</span><span class="s1">]*x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">2</span><span class="s1">*x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">nce(x):</span>
        <span class="s1">assert_inbounds(x)</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">nci(x):</span>
        <span class="s1">assert_inbounds(x)</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">]*x[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">x0 = np.array((</span><span class="s3">0.99</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.99</span><span class="s1">))</span>
    <span class="s1">nlcs = [NonlinearConstraint(nci</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">,</span>
            <span class="s1">NonlinearConstraint(nce</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span>

    <span class="s1">res = minimize(fun=obj</span><span class="s0">, </span><span class="s1">x0=x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">'trust-constr'</span><span class="s0">,</span>
                   <span class="s1">bounds=bnds</span><span class="s0">, </span><span class="s1">constraints=nlcs)</span>
    <span class="s0">assert </span><span class="s1">res.success</span>
    <span class="s1">assert_inbounds(res.x)</span>
    <span class="s0">assert </span><span class="s1">nlcs[</span><span class="s3">0</span><span class="s1">].lb &lt; nlcs[</span><span class="s3">0</span><span class="s1">].fun(res.x) &lt; nlcs[</span><span class="s3">0</span><span class="s1">].ub</span>
    <span class="s1">assert_allclose(nce(res.x)</span><span class="s0">, </span><span class="s1">nlcs[</span><span class="s3">1</span><span class="s1">].ub)</span>

    <span class="s1">ref = minimize(fun=obj</span><span class="s0">, </span><span class="s1">x0=x0</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">'slsqp'</span><span class="s0">,</span>
                   <span class="s1">bounds=bnds</span><span class="s0">, </span><span class="s1">constraints=nlcs)</span>
    <span class="s1">assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">ref.fun)</span>


<span class="s0">class </span><span class="s1">TestBoundedNelderMead:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'bounds, x_opt'</span><span class="s0">,</span>
                             <span class="s1">[(Bounds(-np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">Rosenbrock().x_opt)</span><span class="s0">,</span>
                              <span class="s1">(Bounds(-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">0.8</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.8</span><span class="s1">])</span><span class="s0">,</span>
                              <span class="s1">(Bounds(</span><span class="s3">3.0</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">9.0</span><span class="s1">])</span><span class="s0">,</span>
                              <span class="s1">(Bounds([</span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">5.</span><span class="s1">])</span><span class="s0">,</span>
                              <span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_rosen_brock_with_bounds(self</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">x_opt):</span>
        <span class="s1">prob = Rosenbrock()</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s0">, </span><span class="s5">&quot;Initial guess is not within &quot;</span>
                                    <span class="s5">&quot;the specified bounds&quot;</span><span class="s1">)</span>
            <span class="s1">result = minimize(prob.fun</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">method=</span><span class="s5">'Nelder-Mead'</span><span class="s0">,</span>
                              <span class="s1">bounds=bounds)</span>
            <span class="s0">assert </span><span class="s1">np.less_equal(bounds.lb</span><span class="s0">, </span><span class="s1">result.x).all()</span>
            <span class="s0">assert </span><span class="s1">np.less_equal(result.x</span><span class="s0">, </span><span class="s1">bounds.ub).all()</span>
            <span class="s0">assert </span><span class="s1">np.allclose(prob.fun(result.x)</span><span class="s0">, </span><span class="s1">result.fun)</span>
            <span class="s0">assert </span><span class="s1">np.allclose(result.x</span><span class="s0">, </span><span class="s1">x_opt</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1.e-3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_equal_all_bounds(self):</span>
        <span class="s1">prob = Rosenbrock()</span>
        <span class="s1">bounds = Bounds([</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s0">, </span><span class="s5">&quot;Initial guess is not within &quot;</span>
                                    <span class="s5">&quot;the specified bounds&quot;</span><span class="s1">)</span>
            <span class="s1">result = minimize(prob.fun</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">method=</span><span class="s5">'Nelder-Mead'</span><span class="s0">,</span>
                              <span class="s1">bounds=bounds)</span>
            <span class="s0">assert </span><span class="s1">np.allclose(result.x</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_equal_one_bounds(self):</span>
        <span class="s1">prob = Rosenbrock()</span>
        <span class="s1">bounds = Bounds([</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">20.0</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s0">, </span><span class="s5">&quot;Initial guess is not within &quot;</span>
                                    <span class="s5">&quot;the specified bounds&quot;</span><span class="s1">)</span>
            <span class="s1">result = minimize(prob.fun</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">method=</span><span class="s5">'Nelder-Mead'</span><span class="s0">,</span>
                              <span class="s1">bounds=bounds)</span>
            <span class="s0">assert </span><span class="s1">np.allclose(result.x</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">16.0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_invalid_bounds(self):</span>
        <span class="s1">prob = Rosenbrock()</span>
        <span class="s1">message = </span><span class="s5">'An upper bound is less than the corresponding lower bound.'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">bounds = Bounds([-np.inf</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5.0</span><span class="s1">])</span>
            <span class="s1">minimize(prob.fun</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                     <span class="s1">method=</span><span class="s5">'Nelder-Mead'</span><span class="s0">,</span>
                     <span class="s1">bounds=bounds)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;Failing on Azure Linux and macOS builds, &quot;</span>
                              <span class="s5">&quot;see gh-13846&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_outside_bounds_warning(self):</span>
        <span class="s1">prob = Rosenbrock()</span>
        <span class="s1">message = </span><span class="s5">&quot;Initial guess is not within the specified bounds&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">bounds = Bounds([-np.inf</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">])</span>
            <span class="s1">minimize(prob.fun</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span><span class="s0">,</span>
                     <span class="s1">method=</span><span class="s5">'Nelder-Mead'</span><span class="s0">,</span>
                     <span class="s1">bounds=bounds)</span>
</pre>
</body>
</html>