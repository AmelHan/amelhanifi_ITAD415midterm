<html>
<head>
<title>functional.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
functional.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Module for functional boxplots.&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">statsmodels.compat.numpy </span><span class="s2">import </span><span class="s1">NP_LT_123</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy.special </span><span class="s2">import </span><span class="s1">comb</span>

<span class="s2">from </span><span class="s1">statsmodels.graphics.utils </span><span class="s2">import </span><span class="s1">_import_mpl</span>
<span class="s2">from </span><span class="s1">statsmodels.multivariate.pca </span><span class="s2">import </span><span class="s1">PCA</span>
<span class="s2">from </span><span class="s1">statsmodels.nonparametric.kernel_density </span><span class="s2">import </span><span class="s1">KDEMultivariate</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">brute</span><span class="s2">, </span><span class="s1">differential_evolution</span><span class="s2">, </span><span class="s1">fmin</span>
    <span class="s1">have_de_optim = </span><span class="s2">True</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">brute</span><span class="s2">, </span><span class="s1">fmin</span>
    <span class="s1">have_de_optim = </span><span class="s2">False</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">from </span><span class="s1">multiprocessing </span><span class="s2">import </span><span class="s1">Pool</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">utils</span>

<span class="s1">__all__ = [</span><span class="s3">'hdrboxplot'</span><span class="s2">, </span><span class="s3">'fboxplot'</span><span class="s2">, </span><span class="s3">'rainbowplot'</span><span class="s2">, </span><span class="s3">'banddepth'</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">HdrResults:</span>
    <span class="s0">&quot;&quot;&quot;Wrap results and pretty print them.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">kwds):</span>
        <span class="s1">self.__dict__.update(kwds)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">msg = (</span><span class="s3">&quot;HDR boxplot summary:</span><span class="s2">\n</span><span class="s3">&quot;</span>
               <span class="s3">&quot;-&gt; median:</span><span class="s2">\n</span><span class="s3">{}</span><span class="s2">\n</span><span class="s3">&quot;</span>
               <span class="s3">&quot;-&gt; 50% HDR (max, min):</span><span class="s2">\n</span><span class="s3">{}</span><span class="s2">\n</span><span class="s3">&quot;</span>
               <span class="s3">&quot;-&gt; 90% HDR (max, min):</span><span class="s2">\n</span><span class="s3">{}</span><span class="s2">\n</span><span class="s3">&quot;</span>
               <span class="s3">&quot;-&gt; Extra quantiles (max, min):</span><span class="s2">\n</span><span class="s3">{}</span><span class="s2">\n</span><span class="s3">&quot;</span>
               <span class="s3">&quot;-&gt; Outliers:</span><span class="s2">\n</span><span class="s3">{}</span><span class="s2">\n</span><span class="s3">&quot;</span>
               <span class="s3">&quot;-&gt; Outliers indices:</span><span class="s2">\n</span><span class="s3">{}</span><span class="s2">\n</span><span class="s3">&quot;</span>
               <span class="s1">).format(self.median</span><span class="s2">, </span><span class="s1">self.hdr_50</span><span class="s2">, </span><span class="s1">self.hdr_90</span><span class="s2">,</span>
                        <span class="s1">self.extra_quantiles</span><span class="s2">, </span><span class="s1">self.outliers</span><span class="s2">, </span><span class="s1">self.outliers_idx)</span>

        <span class="s2">return </span><span class="s1">msg</span>


<span class="s2">def </span><span class="s1">_inverse_transform(pca</span><span class="s2">, </span><span class="s1">data):</span>
    <span class="s0">&quot;&quot;&quot; 
    Inverse transform on PCA. 
 
    Use PCA's `project` method by temporary replacing its factors with 
    `data`. 
 
    Parameters 
    ---------- 
    pca : statsmodels Principal Component Analysis instance 
        The PCA object to use. 
    data : sequence of ndarrays or 2-D ndarray 
        The vectors of functions to create a functional boxplot from.  If a 
        sequence of 1-D arrays, these should all be the same size. 
        The first axis is the function index, the second axis the one along 
        which the function is defined.  So ``data[0, :]`` is the first 
        functional curve. 
 
    Returns 
    ------- 
    projection : ndarray 
        nobs by nvar array of the projection onto ncomp factors 
    &quot;&quot;&quot;</span>
    <span class="s1">factors = pca.factors</span>
    <span class="s1">pca.factors = data.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factors.shape[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">projection = pca.project()</span>
    <span class="s1">pca.factors = factors</span>
    <span class="s2">return </span><span class="s1">projection</span>


<span class="s2">def </span><span class="s1">_curve_constrained(x</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">sign</span><span class="s2">, </span><span class="s1">band</span><span class="s2">, </span><span class="s1">pca</span><span class="s2">, </span><span class="s1">ks_gaussian):</span>
    <span class="s0">&quot;&quot;&quot;Find out if the curve is within the band. 
 
    The curve value at :attr:`idx` for a given PDF is only returned if 
    within bounds defined by the band. Otherwise, 1E6 is returned. 
 
    Parameters 
    ---------- 
    x : float 
        Curve in reduced space. 
    idx : int 
        Index value of the components to compute. 
    sign : int 
        Return positive or negative value. 
    band : list of float 
        PDF values `[min_pdf, max_pdf]` to be within. 
    pca : statsmodels Principal Component Analysis instance 
        The PCA object to use. 
    ks_gaussian : KDEMultivariate instance 
 
    Returns 
    ------- 
    value : float 
        Curve value at `idx`. 
    &quot;&quot;&quot;</span>
    <span class="s1">x = x.reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">pdf = ks_gaussian.pdf(x)</span>
    <span class="s2">if </span><span class="s1">band[</span><span class="s4">0</span><span class="s1">] &lt; pdf &lt; band[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s1">value = sign * _inverse_transform(pca</span><span class="s2">, </span><span class="s1">x)[</span><span class="s4">0</span><span class="s1">][idx]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">value = </span><span class="s4">1E6</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">_min_max_band(args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Min and max values at `idx`. 
 
    Global optimization to find the extrema per component. 
 
    Parameters 
    ---------- 
    args: list 
        It is a list of an idx and other arguments as a tuple: 
            idx : int 
                Index value of the components to compute 
        The tuple contains: 
            band : list of float 
                PDF values `[min_pdf, max_pdf]` to be within. 
            pca : statsmodels Principal Component Analysis instance 
                The PCA object to use. 
            bounds : sequence 
                ``(min, max)`` pair for each components 
            ks_gaussian : KDEMultivariate instance 
 
    Returns 
    ------- 
    band : tuple of float 
        ``(max, min)`` curve values at `idx` 
    &quot;&quot;&quot;</span>
    <span class="s1">idx</span><span class="s2">, </span><span class="s1">(band</span><span class="s2">, </span><span class="s1">pca</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">ks_gaussian</span><span class="s2">, </span><span class="s1">use_brute</span><span class="s2">, </span><span class="s1">seed) = args</span>
    <span class="s2">if </span><span class="s1">have_de_optim </span><span class="s2">and not </span><span class="s1">use_brute:</span>
        <span class="s1">max_ = differential_evolution(_curve_constrained</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">,</span>
                                      <span class="s1">args=(idx</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">band</span><span class="s2">, </span><span class="s1">pca</span><span class="s2">, </span><span class="s1">ks_gaussian)</span><span class="s2">,</span>
                                      <span class="s1">maxiter=</span><span class="s4">7</span><span class="s2">, </span><span class="s1">seed=seed).x</span>
        <span class="s1">min_ = differential_evolution(_curve_constrained</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">,</span>
                                      <span class="s1">args=(idx</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">band</span><span class="s2">, </span><span class="s1">pca</span><span class="s2">, </span><span class="s1">ks_gaussian)</span><span class="s2">,</span>
                                      <span class="s1">maxiter=</span><span class="s4">7</span><span class="s2">, </span><span class="s1">seed=seed).x</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">max_ = brute(_curve_constrained</span><span class="s2">, </span><span class="s1">ranges=bounds</span><span class="s2">, </span><span class="s1">finish=fmin</span><span class="s2">,</span>
                     <span class="s1">args=(idx</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">band</span><span class="s2">, </span><span class="s1">pca</span><span class="s2">, </span><span class="s1">ks_gaussian))</span>

        <span class="s1">min_ = brute(_curve_constrained</span><span class="s2">, </span><span class="s1">ranges=bounds</span><span class="s2">, </span><span class="s1">finish=fmin</span><span class="s2">,</span>
                     <span class="s1">args=(idx</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">band</span><span class="s2">, </span><span class="s1">pca</span><span class="s2">, </span><span class="s1">ks_gaussian))</span>

    <span class="s1">band = (_inverse_transform(pca</span><span class="s2">, </span><span class="s1">max_)[</span><span class="s4">0</span><span class="s1">][idx]</span><span class="s2">,</span>
            <span class="s1">_inverse_transform(pca</span><span class="s2">, </span><span class="s1">min_)[</span><span class="s4">0</span><span class="s1">][idx])</span>
    <span class="s2">return </span><span class="s1">band</span>


<span class="s2">def </span><span class="s1">hdrboxplot(data</span><span class="s2">, </span><span class="s1">ncomp=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None, </span><span class="s1">threshold=</span><span class="s4">0.95</span><span class="s2">, </span><span class="s1">bw=</span><span class="s2">None,</span>
               <span class="s1">xdata=</span><span class="s2">None, </span><span class="s1">labels=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">use_brute=</span><span class="s2">False, </span><span class="s1">seed=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    High Density Region boxplot 
 
    Parameters 
    ---------- 
    data : sequence of ndarrays or 2-D ndarray 
        The vectors of functions to create a functional boxplot from.  If a 
        sequence of 1-D arrays, these should all be the same size. 
        The first axis is the function index, the second axis the one along 
        which the function is defined.  So ``data[0, :]`` is the first 
        functional curve. 
    ncomp : int, optional 
        Number of components to use.  If None, returns the as many as the 
        smaller of the number of rows or columns in data. 
    alpha : list of floats between 0 and 1, optional 
        Extra quantile values to compute. Default is None 
    threshold : float between 0 and 1, optional 
        Percentile threshold value for outliers detection. High value means 
        a lower sensitivity to outliers. Default is `0.95`. 
    bw : array_like or str, optional 
        If an array, it is a fixed user-specified bandwidth. If `None`, set to 
        `normal_reference`. If a string, should be one of: 
 
            - normal_reference: normal reference rule of thumb (default) 
            - cv_ml: cross validation maximum likelihood 
            - cv_ls: cross validation least squares 
 
    xdata : ndarray, optional 
        The independent variable for the data. If not given, it is assumed to 
        be an array of integers 0..N-1 with N the length of the vectors in 
        `data`. 
    labels : sequence of scalar or str, optional 
        The labels or identifiers of the curves in `data`. If not given, 
        outliers are labeled in the plot with array indices. 
    ax : AxesSubplot, optional 
        If given, this subplot is used to plot in instead of a new figure being 
        created. 
    use_brute : bool 
        Use the brute force optimizer instead of the default differential 
        evolution to find the curves. Default is False. 
    seed : {None, int, np.random.RandomState} 
        Seed value to pass to scipy.optimize.differential_evolution. Can be an 
        integer or RandomState instance. If None, then the default RandomState 
        provided by np.random is used. 
 
    Returns 
    ------- 
    fig : Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
    hdr_res : HdrResults instance 
        An `HdrResults` instance with the following attributes: 
 
         - 'median', array. Median curve. 
         - 'hdr_50', array. 50% quantile band. [sup, inf] curves 
         - 'hdr_90', list of array. 90% quantile band. [sup, inf] 
            curves. 
         - 'extra_quantiles', list of array. Extra quantile band. 
            [sup, inf] curves. 
         - 'outliers', ndarray. Outlier curves. 
 
    See Also 
    -------- 
    banddepth, rainbowplot, fboxplot 
 
    Notes 
    ----- 
    The median curve is the curve with the highest probability on the reduced 
    space of a Principal Component Analysis (PCA). 
 
    Outliers are defined as curves that fall outside the band corresponding 
    to the quantile given by `threshold`. 
 
    The non-outlying region is defined as the band made up of all the 
    non-outlying curves. 
 
    Behind the scene, the dataset is represented as a matrix. Each line 
    corresponding to a 1D curve. This matrix is then decomposed using Principal 
    Components Analysis (PCA). This allows to represent the data using a finite 
    number of modes, or components. This compression process allows to turn the 
    functional representation into a scalar representation of the matrix. In 
    other words, you can visualize each curve from its components. Each curve 
    is thus a point in this reduced space. With 2 components, this is called a 
    bivariate plot (2D plot). 
 
    In this plot, if some points are adjacent (similar components), it means 
    that back in the original space, the curves are similar. Then, finding the 
    median curve means finding the higher density region (HDR) in the reduced 
    space. Moreover, the more you get away from this HDR, the more the curve is 
    unlikely to be similar to the other curves. 
 
    Using a kernel smoothing technique, the probability density function (PDF) 
    of the multivariate space can be recovered. From this PDF, it is possible 
    to compute the density probability linked to the cluster of points and plot 
    its contours. 
 
    Finally, using these contours, the different quantiles can be extracted 
    along with the median curve and the outliers. 
 
    Steps to produce the HDR boxplot include: 
 
    1. Compute a multivariate kernel density estimation 
    2. Compute contour lines for quantiles 90%, 50% and `alpha` % 
    3. Plot the bivariate plot 
    4. Compute median curve along with quantiles and outliers curves. 
 
    References 
    ---------- 
    [1] R.J. Hyndman and H.L. Shang, &quot;Rainbow Plots, Bagplots, and Boxplots for 
        Functional Data&quot;, vol. 19, pp. 29-45, 2010. 
 
    Examples 
    -------- 
    Load the El Nino dataset.  Consists of 60 years worth of Pacific Ocean sea 
    surface temperature data. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; data = sm.datasets.elnino.load() 
 
    Create a functional boxplot.  We see that the years 1982-83 and 1997-98 are 
    outliers; these are the years where El Nino (a climate pattern 
    characterized by warming up of the sea surface and higher air pressures) 
    occurred with unusual intensity. 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(111) 
    &gt;&gt;&gt; res = sm.graphics.hdrboxplot(data.raw_data[:, 1:], 
    ...                              labels=data.raw_data[:, 0].astype(int), 
    ...                              ax=ax) 
 
    &gt;&gt;&gt; ax.set_xlabel(&quot;Month of the year&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Sea surface temperature (C)&quot;) 
    &gt;&gt;&gt; ax.set_xticks(np.arange(13, step=3) - 1) 
    &gt;&gt;&gt; ax.set_xticklabels([&quot;&quot;, &quot;Mar&quot;, &quot;Jun&quot;, &quot;Sep&quot;, &quot;Dec&quot;]) 
    &gt;&gt;&gt; ax.set_xlim([-0.2, 11.2]) 
 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_functional_hdrboxplot.py 
    &quot;&quot;&quot;</span>
    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s2">if </span><span class="s1">labels </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s5"># For use with pandas, get the labels</span>
        <span class="s2">if </span><span class="s1">hasattr(data</span><span class="s2">, </span><span class="s3">'index'</span><span class="s1">):</span>
            <span class="s1">labels = data.index</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">labels = np.arange(len(data))</span>

    <span class="s1">data = np.asarray(data)</span>
    <span class="s2">if </span><span class="s1">xdata </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">xdata = np.arange(data.shape[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dim = data.shape</span>
    <span class="s5"># PCA and bivariate plot</span>
    <span class="s1">pca = PCA(data</span><span class="s2">, </span><span class="s1">ncomp=ncomp)</span>
    <span class="s1">data_r = pca.factors</span>

    <span class="s5"># Create gaussian kernel</span>
    <span class="s1">ks_gaussian = KDEMultivariate(data_r</span><span class="s2">, </span><span class="s1">bw=bw</span><span class="s2">,</span>
                                  <span class="s1">var_type=</span><span class="s3">'c' </span><span class="s1">* data_r.shape[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Boundaries of the n-variate space</span>
    <span class="s1">bounds = np.array([data_r.min(axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">data_r.max(axis=</span><span class="s4">0</span><span class="s1">)]).T</span>

    <span class="s5"># Compute contour line of pvalue linked to a given probability level</span>
    <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">alpha = [threshold</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">alpha.extend([threshold</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>
        <span class="s1">alpha = list(set(alpha))</span>
    <span class="s1">alpha.sort(reverse=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">n_quantiles = len(alpha)</span>
    <span class="s1">pdf_r = ks_gaussian.pdf(data_r).flatten()</span>
    <span class="s2">if </span><span class="s1">NP_LT_123:</span>
        <span class="s1">pvalues = [np.percentile(pdf_r</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">- alpha[i]) * </span><span class="s4">100</span><span class="s2">,</span>
                                 <span class="s1">interpolation=</span><span class="s3">'linear'</span><span class="s1">)</span>
                   <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n_quantiles)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">pvalues = [np.percentile(pdf_r</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">- alpha[i]) * </span><span class="s4">100</span><span class="s2">,</span>
                                 <span class="s1">method=</span><span class="s3">'midpoint'</span><span class="s1">)</span>
                   <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n_quantiles)]</span>

    <span class="s5"># Find mean, outliers curves</span>
    <span class="s2">if </span><span class="s1">have_de_optim </span><span class="s2">and not </span><span class="s1">use_brute:</span>
        <span class="s1">median = differential_evolution(</span><span class="s2">lambda </span><span class="s1">x: - ks_gaussian.pdf(x)</span><span class="s2">,</span>
                                        <span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seed=seed).x</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">median = brute(</span><span class="s2">lambda </span><span class="s1">x: - ks_gaussian.pdf(x)</span><span class="s2">,</span>
                       <span class="s1">ranges=bounds</span><span class="s2">, </span><span class="s1">finish=fmin)</span>

    <span class="s1">outliers_idx = np.where(pdf_r &lt; pvalues[alpha.index(threshold)])[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">labels_outlier = [labels[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">outliers_idx]</span>
    <span class="s1">outliers = data[outliers_idx]</span>

    <span class="s5"># Find HDR given some quantiles</span>

    <span class="s2">def </span><span class="s1">_band_quantiles(band</span><span class="s2">, </span><span class="s1">use_brute=use_brute</span><span class="s2">, </span><span class="s1">seed=seed):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find extreme curves for a quantile band. 
 
        From the `band` of quantiles, the associated PDF extrema values 
        are computed. If `min_alpha` is not provided (single quantile value), 
        `max_pdf` is set to `1E6` in order not to constrain the problem on high 
        values. 
 
        An optimization is performed per component in order to find the min and 
        max curves. This is done by comparing the PDF value of a given curve 
        with the band PDF. 
 
        Parameters 
        ---------- 
        band : array_like 
            alpha values ``(max_alpha, min_alpha)`` ex: ``[0.9, 0.5]`` 
        use_brute : bool 
            Use the brute force optimizer instead of the default differential 
            evolution to find the curves. Default is False. 
        seed : {None, int, np.random.RandomState} 
            Seed value to pass to scipy.optimize.differential_evolution. Can 
            be an integer or RandomState instance. If None, then the default 
            RandomState provided by np.random is used. 
 
 
        Returns 
        ------- 
        band_quantiles : list of 1-D array 
            ``(max_quantile, min_quantile)`` (2, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">min_pdf = pvalues[alpha.index(band[</span><span class="s4">0</span><span class="s1">])]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">max_pdf = pvalues[alpha.index(band[</span><span class="s4">1</span><span class="s1">])]</span>
        <span class="s2">except </span><span class="s1">IndexError:</span>
            <span class="s1">max_pdf = </span><span class="s4">1E6</span>
        <span class="s1">band = [min_pdf</span><span class="s2">, </span><span class="s1">max_pdf]</span>

        <span class="s1">pool = Pool()</span>
        <span class="s1">data = zip(range(dim)</span><span class="s2">, </span><span class="s1">itertools.repeat((band</span><span class="s2">, </span><span class="s1">pca</span><span class="s2">,</span>
                                                 <span class="s1">bounds</span><span class="s2">, </span><span class="s1">ks_gaussian</span><span class="s2">,</span>
                                                 <span class="s1">seed</span><span class="s2">, </span><span class="s1">use_brute)))</span>
        <span class="s1">band_quantiles = pool.map(_min_max_band</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">pool.terminate()</span>
        <span class="s1">pool.close()</span>

        <span class="s1">band_quantiles = list(zip(*band_quantiles))</span>

        <span class="s2">return </span><span class="s1">band_quantiles</span>

    <span class="s1">extra_alpha = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">alpha</span>
                   <span class="s2">if </span><span class="s4">0.5 </span><span class="s1">!= i </span><span class="s2">and </span><span class="s4">0.9 </span><span class="s1">!= i </span><span class="s2">and </span><span class="s1">threshold != i]</span>
    <span class="s2">if </span><span class="s1">len(extra_alpha) &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">extra_quantiles = []</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">extra_alpha:</span>
            <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">_band_quantiles([x]</span><span class="s2">, </span><span class="s1">use_brute=use_brute</span><span class="s2">, </span><span class="s1">seed=seed):</span>
                <span class="s1">extra_quantiles.append(y)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">extra_quantiles = []</span>

    <span class="s5"># Inverse transform from n-variate plot to dataset dataset's shape</span>
    <span class="s1">median = _inverse_transform(pca</span><span class="s2">, </span><span class="s1">median)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">hdr_90 = _band_quantiles([</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">use_brute=use_brute</span><span class="s2">, </span><span class="s1">seed=seed)</span>
    <span class="s1">hdr_50 = _band_quantiles([</span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">use_brute=use_brute</span><span class="s2">, </span><span class="s1">seed=seed)</span>

    <span class="s1">hdr_res = HdrResults({</span>
                            <span class="s3">&quot;median&quot;</span><span class="s1">: median</span><span class="s2">,</span>
                            <span class="s3">&quot;hdr_50&quot;</span><span class="s1">: hdr_50</span><span class="s2">,</span>
                            <span class="s3">&quot;hdr_90&quot;</span><span class="s1">: hdr_90</span><span class="s2">,</span>
                            <span class="s3">&quot;extra_quantiles&quot;</span><span class="s1">: extra_quantiles</span><span class="s2">,</span>
                            <span class="s3">&quot;outliers&quot;</span><span class="s1">: outliers</span><span class="s2">,</span>
                            <span class="s3">&quot;outliers_idx&quot;</span><span class="s1">: outliers_idx</span>
                         <span class="s1">})</span>

    <span class="s5"># Plots</span>
    <span class="s1">ax.plot(np.array([xdata] * n_samples).T</span><span class="s2">, </span><span class="s1">data.T</span><span class="s2">,</span>
            <span class="s1">c=</span><span class="s3">'c'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">.1</span><span class="s2">, </span><span class="s1">label=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">ax.plot(xdata</span><span class="s2">, </span><span class="s1">median</span><span class="s2">, </span><span class="s1">c=</span><span class="s3">'k'</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">'Median'</span><span class="s1">)</span>
    <span class="s1">fill_betweens = []</span>
    <span class="s1">fill_betweens.append(ax.fill_between(xdata</span><span class="s2">, </span><span class="s1">*hdr_50</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'gray'</span><span class="s2">,</span>
                                         <span class="s1">alpha=</span><span class="s4">.4</span><span class="s2">,  </span><span class="s1">label=</span><span class="s3">'50% HDR'</span><span class="s1">))</span>
    <span class="s1">fill_betweens.append(ax.fill_between(xdata</span><span class="s2">, </span><span class="s1">*hdr_90</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'gray'</span><span class="s2">,</span>
                                         <span class="s1">alpha=</span><span class="s4">.3</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">'90% HDR'</span><span class="s1">))</span>

    <span class="s2">if </span><span class="s1">len(extra_quantiles) != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">ax.plot(np.array([xdata] * len(extra_quantiles)).T</span><span class="s2">,</span>
                <span class="s1">np.array(extra_quantiles).T</span><span class="s2">,</span>
                <span class="s1">c=</span><span class="s3">'y'</span><span class="s2">, </span><span class="s1">ls=</span><span class="s3">'-.'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">.4</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">'Extra quantiles'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">len(outliers) != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">ii</span><span class="s2">, </span><span class="s1">outlier </span><span class="s2">in </span><span class="s1">enumerate(outliers):</span>
            <span class="s2">if </span><span class="s1">labels_outlier </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">label = </span><span class="s3">'Outliers'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">label = str(labels_outlier[ii])</span>
            <span class="s1">ax.plot(xdata</span><span class="s2">, </span><span class="s1">outlier</span><span class="s2">, </span><span class="s1">ls=</span><span class="s3">'--'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.7</span><span class="s2">, </span><span class="s1">label=label)</span>

    <span class="s1">handles</span><span class="s2">, </span><span class="s1">labels = ax.get_legend_handles_labels()</span>

    <span class="s5"># Proxy artist for fill_between legend entry</span>
    <span class="s5"># See https://matplotlib.org/1.3.1/users/legend_guide.html</span>
    <span class="s1">plt = _import_mpl()</span>
    <span class="s2">for </span><span class="s1">label</span><span class="s2">, </span><span class="s1">fill_between </span><span class="s2">in </span><span class="s1">zip([</span><span class="s3">'50% HDR'</span><span class="s2">, </span><span class="s3">'90% HDR'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_betweens):</span>
        <span class="s1">p = plt.Rectangle((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">,</span>
                          <span class="s1">fc=fill_between.get_facecolor()[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">handles.append(p)</span>
        <span class="s1">labels.append(label)</span>

    <span class="s1">by_label = dict(zip(labels</span><span class="s2">, </span><span class="s1">handles))</span>
    <span class="s2">if </span><span class="s1">len(outliers) != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">by_label.pop(</span><span class="s3">'Median'</span><span class="s1">)</span>
        <span class="s1">by_label.pop(</span><span class="s3">'50% HDR'</span><span class="s1">)</span>
        <span class="s1">by_label.pop(</span><span class="s3">'90% HDR'</span><span class="s1">)</span>

    <span class="s1">ax.legend(by_label.values()</span><span class="s2">, </span><span class="s1">by_label.keys()</span><span class="s2">, </span><span class="s1">loc=</span><span class="s3">'best'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">fig</span><span class="s2">, </span><span class="s1">hdr_res</span>


<span class="s2">def </span><span class="s1">fboxplot(data</span><span class="s2">, </span><span class="s1">xdata=</span><span class="s2">None, </span><span class="s1">labels=</span><span class="s2">None, </span><span class="s1">depth=</span><span class="s2">None, </span><span class="s1">method=</span><span class="s3">'MBD'</span><span class="s2">,</span>
             <span class="s1">wfactor=</span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">plot_opts=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Plot functional boxplot. 
 
    A functional boxplot is the analog of a boxplot for functional data. 
    Functional data is any type of data that varies over a continuum, i.e. 
    curves, probability distributions, seasonal data, etc. 
 
    The data is first ordered, the order statistic used here is `banddepth`. 
    Plotted are then the median curve, the envelope of the 50% central region, 
    the maximum non-outlying envelope and the outlier curves. 
 
    Parameters 
    ---------- 
    data : sequence of ndarrays or 2-D ndarray 
        The vectors of functions to create a functional boxplot from.  If a 
        sequence of 1-D arrays, these should all be the same size. 
        The first axis is the function index, the second axis the one along 
        which the function is defined.  So ``data[0, :]`` is the first 
        functional curve. 
    xdata : ndarray, optional 
        The independent variable for the data.  If not given, it is assumed to 
        be an array of integers 0..N-1 with N the length of the vectors in 
        `data`. 
    labels : sequence of scalar or str, optional 
        The labels or identifiers of the curves in `data`.  If given, outliers 
        are labeled in the plot. 
    depth : ndarray, optional 
        A 1-D array of band depths for `data`, or equivalent order statistic. 
        If not given, it will be calculated through `banddepth`. 
    method : {'MBD', 'BD2'}, optional 
        The method to use to calculate the band depth.  Default is 'MBD'. 
    wfactor : float, optional 
        Factor by which the central 50% region is multiplied to find the outer 
        region (analog of &quot;whiskers&quot; of a classical boxplot). 
    ax : AxesSubplot, optional 
        If given, this subplot is used to plot in instead of a new figure being 
        created. 
    plot_opts : dict, optional 
        A dictionary with plotting options.  Any of the following can be 
        provided, if not present in `plot_opts` the defaults will be used:: 
 
          - 'cmap_outliers', a Matplotlib LinearSegmentedColormap instance. 
          - 'c_inner', valid MPL color. Color of the central 50% region 
          - 'c_outer', valid MPL color. Color of the non-outlying region 
          - 'c_median', valid MPL color. Color of the median. 
          - 'lw_outliers', scalar.  Linewidth for drawing outlier curves. 
          - 'lw_median', scalar.  Linewidth for drawing the median curve. 
          - 'draw_nonout', bool.  If True, also draw non-outlying curves. 
 
    Returns 
    ------- 
    fig : Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
    depth : ndarray 
        A 1-D array containing the calculated band depths of the curves. 
    ix_depth : ndarray 
        A 1-D array of indices needed to order curves (or `depth`) from most to 
        least central curve. 
    ix_outliers : ndarray 
        A 1-D array of indices of outlying curves in `data`. 
 
    See Also 
    -------- 
    banddepth, rainbowplot 
 
    Notes 
    ----- 
    The median curve is the curve with the highest band depth. 
 
    Outliers are defined as curves that fall outside the band created by 
    multiplying the central region by `wfactor`.  Note that the range over 
    which they fall outside this band does not matter, a single data point 
    outside the band is enough.  If the data is noisy, smoothing may therefore 
    be required. 
 
    The non-outlying region is defined as the band made up of all the 
    non-outlying curves. 
 
    References 
    ---------- 
    [1] Y. Sun and M.G. Genton, &quot;Functional Boxplots&quot;, Journal of Computational 
        and Graphical Statistics, vol. 20, pp. 1-19, 2011. 
    [2] R.J. Hyndman and H.L. Shang, &quot;Rainbow Plots, Bagplots, and Boxplots for 
        Functional Data&quot;, vol. 19, pp. 29-45, 2010. 
 
    Examples 
    -------- 
    Load the El Nino dataset.  Consists of 60 years worth of Pacific Ocean sea 
    surface temperature data. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; data = sm.datasets.elnino.load() 
 
    Create a functional boxplot.  We see that the years 1982-83 and 1997-98 are 
    outliers; these are the years where El Nino (a climate pattern 
    characterized by warming up of the sea surface and higher air pressures) 
    occurred with unusual intensity. 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(111) 
    &gt;&gt;&gt; res = sm.graphics.fboxplot(data.raw_data[:, 1:], wfactor=2.58, 
    ...                            labels=data.raw_data[:, 0].astype(int), 
    ...                            ax=ax) 
 
    &gt;&gt;&gt; ax.set_xlabel(&quot;Month of the year&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Sea surface temperature (C)&quot;) 
    &gt;&gt;&gt; ax.set_xticks(np.arange(13, step=3) - 1) 
    &gt;&gt;&gt; ax.set_xticklabels([&quot;&quot;, &quot;Mar&quot;, &quot;Jun&quot;, &quot;Sep&quot;, &quot;Dec&quot;]) 
    &gt;&gt;&gt; ax.set_xlim([-0.2, 11.2]) 
 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_functional_fboxplot.py 
    &quot;&quot;&quot;</span>
    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s1">plot_opts = {} </span><span class="s2">if </span><span class="s1">plot_opts </span><span class="s2">is None else </span><span class="s1">plot_opts</span>
    <span class="s2">if </span><span class="s1">plot_opts.get(</span><span class="s3">'cmap_outliers'</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">matplotlib.cm </span><span class="s2">import </span><span class="s1">rainbow_r</span>
        <span class="s1">plot_opts[</span><span class="s3">'cmap_outliers'</span><span class="s1">] = rainbow_r</span>

    <span class="s1">data = np.asarray(data)</span>
    <span class="s2">if </span><span class="s1">xdata </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">xdata = np.arange(data.shape[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Calculate band depth if required.</span>
    <span class="s2">if </span><span class="s1">depth </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'MBD'</span><span class="s2">, </span><span class="s3">'BD2'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unknown value for parameter `method`.&quot;</span><span class="s1">)</span>

        <span class="s1">depth = banddepth(data</span><span class="s2">, </span><span class="s1">method=method)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">depth.size != data.shape[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Provided `depth` array is not of correct size.&quot;</span><span class="s1">)</span>

    <span class="s5"># Inner area is 25%-75% region of band-depth ordered curves.</span>
    <span class="s1">ix_depth = np.argsort(depth)[::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">median_curve = data[ix_depth[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">:]</span>
    <span class="s1">ix_IQR = data.shape[</span><span class="s4">0</span><span class="s1">] // </span><span class="s4">2</span>
    <span class="s1">lower = data[ix_depth[</span><span class="s4">0</span><span class="s1">:ix_IQR]</span><span class="s2">, </span><span class="s1">:].min(axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">upper = data[ix_depth[</span><span class="s4">0</span><span class="s1">:ix_IQR]</span><span class="s2">, </span><span class="s1">:].max(axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s5"># Determine region for outlier detection</span>
    <span class="s1">inner_median = np.median(data[ix_depth[</span><span class="s4">0</span><span class="s1">:ix_IQR]</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">lower_fence = inner_median - (inner_median - lower) * wfactor</span>
    <span class="s1">upper_fence = inner_median + (upper - inner_median) * wfactor</span>

    <span class="s5"># Find outliers.</span>
    <span class="s1">ix_outliers = []</span>
    <span class="s1">ix_nonout = []</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(data.shape[</span><span class="s4">0</span><span class="s1">]):</span>
        <span class="s2">if </span><span class="s1">(np.any(data[ii</span><span class="s2">, </span><span class="s1">:] &gt; upper_fence) </span><span class="s2">or</span>
                <span class="s1">np.any(data[ii</span><span class="s2">, </span><span class="s1">:] &lt; lower_fence)):</span>
            <span class="s1">ix_outliers.append(ii)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ix_nonout.append(ii)</span>

    <span class="s1">ix_outliers = np.asarray(ix_outliers)</span>

    <span class="s5"># Plot envelope of all non-outlying data</span>
    <span class="s1">lower_nonout = data[ix_nonout</span><span class="s2">, </span><span class="s1">:].min(axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">upper_nonout = data[ix_nonout</span><span class="s2">, </span><span class="s1">:].max(axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">ax.fill_between(xdata</span><span class="s2">, </span><span class="s1">lower_nonout</span><span class="s2">, </span><span class="s1">upper_nonout</span><span class="s2">,</span>
                    <span class="s1">color=plot_opts.get(</span><span class="s3">'c_outer'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">)))</span>

    <span class="s5"># Plot central 50% region</span>
    <span class="s1">ax.fill_between(xdata</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">, </span><span class="s1">upper</span><span class="s2">,</span>
                    <span class="s1">color=plot_opts.get(</span><span class="s3">'c_inner'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>

    <span class="s5"># Plot median curve</span>
    <span class="s1">ax.plot(xdata</span><span class="s2">, </span><span class="s1">median_curve</span><span class="s2">, </span><span class="s1">color=plot_opts.get(</span><span class="s3">'c_median'</span><span class="s2">, </span><span class="s3">'k'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">lw=plot_opts.get(</span><span class="s3">'lw_median'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

    <span class="s5"># Plot outliers</span>
    <span class="s1">cmap = plot_opts.get(</span><span class="s3">'cmap_outliers'</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">ii</span><span class="s2">, </span><span class="s1">ix </span><span class="s2">in </span><span class="s1">enumerate(ix_outliers):</span>
        <span class="s1">label = str(labels[ix]) </span><span class="s2">if </span><span class="s1">labels </span><span class="s2">is not None else None</span>
        <span class="s1">ax.plot(xdata</span><span class="s2">, </span><span class="s1">data[ix</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
                <span class="s1">color=cmap(float(ii) / (len(ix_outliers)-</span><span class="s4">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">label=label</span><span class="s2">,</span>
                <span class="s1">lw=plot_opts.get(</span><span class="s3">'lw_outliers'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s2">if </span><span class="s1">plot_opts.get(</span><span class="s3">'draw_nonout'</span><span class="s2">, False</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">ix </span><span class="s2">in </span><span class="s1">ix_nonout:</span>
            <span class="s1">ax.plot(xdata</span><span class="s2">, </span><span class="s1">data[ix</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s3">'k-'</span><span class="s2">, </span><span class="s1">lw=</span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">labels </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">ax.legend()</span>

    <span class="s2">return </span><span class="s1">fig</span><span class="s2">, </span><span class="s1">depth</span><span class="s2">, </span><span class="s1">ix_depth</span><span class="s2">, </span><span class="s1">ix_outliers</span>


<span class="s2">def </span><span class="s1">rainbowplot(data</span><span class="s2">, </span><span class="s1">xdata=</span><span class="s2">None, </span><span class="s1">depth=</span><span class="s2">None, </span><span class="s1">method=</span><span class="s3">'MBD'</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None,</span>
                <span class="s1">cmap=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a rainbow plot for a set of curves. 
 
    A rainbow plot contains line plots of all curves in the dataset, colored in 
    order of functional depth.  The median curve is shown in black. 
 
    Parameters 
    ---------- 
    data : sequence of ndarrays or 2-D ndarray 
        The vectors of functions to create a functional boxplot from.  If a 
        sequence of 1-D arrays, these should all be the same size. 
        The first axis is the function index, the second axis the one along 
        which the function is defined.  So ``data[0, :]`` is the first 
        functional curve. 
    xdata : ndarray, optional 
        The independent variable for the data.  If not given, it is assumed to 
        be an array of integers 0..N-1 with N the length of the vectors in 
        `data`. 
    depth : ndarray, optional 
        A 1-D array of band depths for `data`, or equivalent order statistic. 
        If not given, it will be calculated through `banddepth`. 
    method : {'MBD', 'BD2'}, optional 
        The method to use to calculate the band depth.  Default is 'MBD'. 
    ax : AxesSubplot, optional 
        If given, this subplot is used to plot in instead of a new figure being 
        created. 
    cmap : Matplotlib LinearSegmentedColormap instance, optional 
        The colormap used to color curves with.  Default is a rainbow colormap, 
        with red used for the most central and purple for the least central 
        curves. 
 
    Returns 
    ------- 
    Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
 
    See Also 
    -------- 
    banddepth, fboxplot 
 
    References 
    ---------- 
    [1] R.J. Hyndman and H.L. Shang, &quot;Rainbow Plots, Bagplots, and Boxplots for 
        Functional Data&quot;, vol. 19, pp. 29-25, 2010. 
 
    Examples 
    -------- 
    Load the El Nino dataset.  Consists of 60 years worth of Pacific Ocean sea 
    surface temperature data. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; data = sm.datasets.elnino.load() 
 
    Create a rainbow plot: 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(111) 
    &gt;&gt;&gt; res = sm.graphics.rainbowplot(data.raw_data[:, 1:], ax=ax) 
 
    &gt;&gt;&gt; ax.set_xlabel(&quot;Month of the year&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Sea surface temperature (C)&quot;) 
    &gt;&gt;&gt; ax.set_xticks(np.arange(13, step=3) - 1) 
    &gt;&gt;&gt; ax.set_xticklabels([&quot;&quot;, &quot;Mar&quot;, &quot;Jun&quot;, &quot;Sep&quot;, &quot;Dec&quot;]) 
    &gt;&gt;&gt; ax.set_xlim([-0.2, 11.2]) 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_functional_rainbowplot.py 
    &quot;&quot;&quot;</span>
    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s2">if </span><span class="s1">cmap </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">matplotlib.cm </span><span class="s2">import </span><span class="s1">rainbow_r</span>
        <span class="s1">cmap = rainbow_r</span>

    <span class="s1">data = np.asarray(data)</span>
    <span class="s2">if </span><span class="s1">xdata </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">xdata = np.arange(data.shape[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Calculate band depth if required.</span>
    <span class="s2">if </span><span class="s1">depth </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'MBD'</span><span class="s2">, </span><span class="s3">'BD2'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unknown value for parameter `method`.&quot;</span><span class="s1">)</span>

        <span class="s1">depth = banddepth(data</span><span class="s2">, </span><span class="s1">method=method)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">depth.size != data.shape[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Provided `depth` array is not of correct size.&quot;</span><span class="s1">)</span>

    <span class="s1">ix_depth = np.argsort(depth)[::-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s5"># Plot all curves, colored by depth</span>
    <span class="s1">num_curves = data.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(num_curves):</span>
        <span class="s1">ax.plot(xdata</span><span class="s2">, </span><span class="s1">data[ix_depth[ii]</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">c=cmap(ii / (num_curves - </span><span class="s4">1.</span><span class="s1">)))</span>

    <span class="s5"># Plot the median curve</span>
    <span class="s1">median_curve = data[ix_depth[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">:]</span>
    <span class="s1">ax.plot(xdata</span><span class="s2">, </span><span class="s1">median_curve</span><span class="s2">, </span><span class="s3">'k-'</span><span class="s2">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">fig</span>


<span class="s2">def </span><span class="s1">banddepth(data</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'MBD'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the band depth for a set of functional curves. 
 
    Band depth is an order statistic for functional data (see `fboxplot`), with 
    a higher band depth indicating larger &quot;centrality&quot;.  In analog to scalar 
    data, the functional curve with highest band depth is called the median 
    curve, and the band made up from the first N/2 of N curves is the 50% 
    central region. 
 
    Parameters 
    ---------- 
    data : ndarray 
        The vectors of functions to create a functional boxplot from. 
        The first axis is the function index, the second axis the one along 
        which the function is defined.  So ``data[0, :]`` is the first 
        functional curve. 
    method : {'MBD', 'BD2'}, optional 
        Whether to use the original band depth (with J=2) of [1]_ or the 
        modified band depth.  See Notes for details. 
 
    Returns 
    ------- 
    ndarray 
        Depth values for functional curves. 
 
    Notes 
    ----- 
    Functional band depth as an order statistic for functional data was 
    proposed in [1]_ and applied to functional boxplots and bagplots in [2]_. 
 
    The method 'BD2' checks for each curve whether it lies completely inside 
    bands constructed from two curves.  All permutations of two curves in the 
    set of curves are used, and the band depth is normalized to one.  Due to 
    the complete curve having to fall within the band, this method yields a lot 
    of ties. 
 
    The method 'MBD' is similar to 'BD2', but checks the fraction of the curve 
    falling within the bands.  It therefore generates very few ties. 
 
    The algorithm uses the efficient implementation proposed in [3]_. 
 
    References 
    ---------- 
    .. [1] S. Lopez-Pintado and J. Romo, &quot;On the Concept of Depth for 
           Functional Data&quot;, Journal of the American Statistical Association, 
           vol.  104, pp. 718-734, 2009. 
    .. [2] Y. Sun and M.G. Genton, &quot;Functional Boxplots&quot;, Journal of 
           Computational and Graphical Statistics, vol. 20, pp. 1-19, 2011. 
    .. [3] Y. Sun, M. G. Gentonb and D. W. Nychkac, &quot;Exact fast computation 
           of band depth for large functional datasets: How quickly can one 
           million curves be ranked?&quot;, Journal for the Rapid Dissemination 
           of Statistics Research, vol. 1, pp. 68-74, 2012. 
    &quot;&quot;&quot;</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">p = data.shape</span>
    <span class="s1">rv = np.argsort(data</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">rmat = np.argsort(rv</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">) + </span><span class="s4">1</span>

    <span class="s5"># band depth</span>
    <span class="s2">def </span><span class="s1">_fbd2():</span>
        <span class="s1">down = np.min(rmat</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">) - </span><span class="s4">1</span>
        <span class="s1">up = n - np.max(rmat</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">(up * down + n - </span><span class="s4">1</span><span class="s1">) / comb(n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s5"># modified band depth</span>
    <span class="s2">def </span><span class="s1">_fmbd():</span>
        <span class="s1">down = rmat - </span><span class="s4">1</span>
        <span class="s1">up = n - rmat</span>
        <span class="s2">return </span><span class="s1">((np.sum(up * down</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">) / p) + n - </span><span class="s4">1</span><span class="s1">) / comb(n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">method == </span><span class="s3">'BD2'</span><span class="s1">:</span>
        <span class="s1">depth = _fbd2()</span>
    <span class="s2">elif </span><span class="s1">method == </span><span class="s3">'MBD'</span><span class="s1">:</span>
        <span class="s1">depth = _fmbd()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unknown input value for parameter `method`.&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">depth</span>
</pre>
</body>
</html>