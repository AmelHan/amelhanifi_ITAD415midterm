<html>
<head>
<title>_construct.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_construct.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Functions to construct sparse matrices 
&quot;&quot;&quot;</span>

<span class="s1">__docformat__ = </span><span class="s2">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ = [</span><span class="s2">'spdiags'</span><span class="s3">, </span><span class="s2">'eye'</span><span class="s3">, </span><span class="s2">'identity'</span><span class="s3">, </span><span class="s2">'kron'</span><span class="s3">, </span><span class="s2">'kronsum'</span><span class="s3">,</span>
           <span class="s2">'hstack'</span><span class="s3">, </span><span class="s2">'vstack'</span><span class="s3">, </span><span class="s2">'bmat'</span><span class="s3">, </span><span class="s2">'rand'</span><span class="s3">, </span><span class="s2">'random'</span><span class="s3">, </span><span class="s2">'diags'</span><span class="s3">, </span><span class="s2">'block_diag'</span><span class="s1">]</span>

<span class="s3">import </span><span class="s1">numbers</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">scipy._lib._util </span><span class="s3">import </span><span class="s1">check_random_state</span><span class="s3">, </span><span class="s1">rng_integers</span>
<span class="s3">from </span><span class="s1">._sputils </span><span class="s3">import </span><span class="s1">upcast</span><span class="s3">, </span><span class="s1">get_index_dtype</span><span class="s3">, </span><span class="s1">isscalarlike</span>

<span class="s3">from </span><span class="s1">._sparsetools </span><span class="s3">import </span><span class="s1">csr_hstack</span>
<span class="s3">from </span><span class="s1">._csr </span><span class="s3">import </span><span class="s1">csr_matrix</span>
<span class="s3">from </span><span class="s1">._csc </span><span class="s3">import </span><span class="s1">csc_matrix</span>
<span class="s3">from </span><span class="s1">._bsr </span><span class="s3">import </span><span class="s1">bsr_matrix</span>
<span class="s3">from </span><span class="s1">._coo </span><span class="s3">import </span><span class="s1">coo_matrix</span>
<span class="s3">from </span><span class="s1">._dia </span><span class="s3">import </span><span class="s1">dia_matrix</span>

<span class="s3">from </span><span class="s1">._base </span><span class="s3">import </span><span class="s1">issparse</span>


<span class="s3">def </span><span class="s1">spdiags(data</span><span class="s3">, </span><span class="s1">diags</span><span class="s3">, </span><span class="s1">m=</span><span class="s3">None, </span><span class="s1">n=</span><span class="s3">None, </span><span class="s1">format=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a sparse matrix from diagonals. 
 
    Parameters 
    ---------- 
    data : array_like 
        Matrix diagonals stored row-wise 
    diags : sequence of int or an int 
        Diagonals to set: 
 
        * k = 0  the main diagonal 
        * k &gt; 0  the kth upper diagonal 
        * k &lt; 0  the kth lower diagonal 
    m, n : int, tuple, optional 
        Shape of the result. If `n` is None and `m` is a given tuple, 
        the shape is this tuple. If omitted, the matrix is square and 
        its shape is len(data[0]). 
    format : str, optional 
        Format of the result. By default (format=None) an appropriate sparse 
        matrix format is returned. This choice is subject to change. 
 
    See Also 
    -------- 
    diags : more convenient form of this function 
    dia_matrix : the sparse DIAgonal format. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import spdiags 
    &gt;&gt;&gt; data = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) 
    &gt;&gt;&gt; diags = np.array([0, -1, 2]) 
    &gt;&gt;&gt; spdiags(data, diags, 4, 4).toarray() 
    array([[1, 0, 3, 0], 
           [1, 2, 0, 4], 
           [0, 2, 3, 0], 
           [0, 0, 3, 4]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s3">is None and </span><span class="s1">n </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">m = n = len(data[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s3">elif </span><span class="s1">n </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">m</span><span class="s3">, </span><span class="s1">n = m</span>
    <span class="s3">return </span><span class="s1">dia_matrix((data</span><span class="s3">, </span><span class="s1">diags)</span><span class="s3">, </span><span class="s1">shape=(m</span><span class="s3">, </span><span class="s1">n)).asformat(format)</span>


<span class="s3">def </span><span class="s1">diags(diagonals</span><span class="s3">, </span><span class="s1">offsets=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">shape=</span><span class="s3">None, </span><span class="s1">format=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Construct a sparse matrix from diagonals. 
 
    Parameters 
    ---------- 
    diagonals : sequence of array_like 
        Sequence of arrays containing the matrix diagonals, 
        corresponding to `offsets`. 
    offsets : sequence of int or an int, optional 
        Diagonals to set: 
          - k = 0  the main diagonal (default) 
          - k &gt; 0  the kth upper diagonal 
          - k &lt; 0  the kth lower diagonal 
    shape : tuple of int, optional 
        Shape of the result. If omitted, a square matrix large enough 
        to contain the diagonals is returned. 
    format : {&quot;dia&quot;, &quot;csr&quot;, &quot;csc&quot;, &quot;lil&quot;, ...}, optional 
        Matrix format of the result. By default (format=None) an 
        appropriate sparse matrix format is returned. This choice is 
        subject to change. 
    dtype : dtype, optional 
        Data type of the matrix. 
 
    See Also 
    -------- 
    spdiags : construct matrix from diagonals 
 
    Notes 
    ----- 
    This function differs from `spdiags` in the way it handles 
    off-diagonals. 
 
    The result from `diags` is the sparse equivalent of:: 
 
        np.diag(diagonals[0], offsets[0]) 
        + ... 
        + np.diag(diagonals[k], offsets[k]) 
 
    Repeated diagonal offsets are disallowed. 
 
    .. versionadded:: 0.11 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import diags 
    &gt;&gt;&gt; diagonals = [[1, 2, 3, 4], [1, 2, 3], [1, 2]] 
    &gt;&gt;&gt; diags(diagonals, [0, -1, 2]).toarray() 
    array([[1, 0, 1, 0], 
           [1, 2, 0, 2], 
           [0, 2, 3, 0], 
           [0, 0, 3, 4]]) 
 
    Broadcasting of scalars is supported (but shape needs to be 
    specified): 
 
    &gt;&gt;&gt; diags([1, -2, 1], [-1, 0, 1], shape=(4, 4)).toarray() 
    array([[-2.,  1.,  0.,  0.], 
           [ 1., -2.,  1.,  0.], 
           [ 0.,  1., -2.,  1.], 
           [ 0.,  0.,  1., -2.]]) 
 
 
    If only one diagonal is wanted (as in `numpy.diag`), the following 
    works as well: 
 
    &gt;&gt;&gt; diags([1, 2, 3], 1).toarray() 
    array([[ 0.,  1.,  0.,  0.], 
           [ 0.,  0.,  2.,  0.], 
           [ 0.,  0.,  0.,  3.], 
           [ 0.,  0.,  0.,  0.]]) 
    &quot;&quot;&quot;</span>
    <span class="s5"># if offsets is not a sequence, assume that there's only one diagonal</span>
    <span class="s3">if </span><span class="s1">isscalarlike(offsets):</span>
        <span class="s5"># now check that there's actually only one diagonal</span>
        <span class="s3">if </span><span class="s1">len(diagonals) == </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">isscalarlike(diagonals[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s1">diagonals = [np.atleast_1d(diagonals)]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Different number of diagonals and offsets.&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">diagonals = list(map(np.atleast_1d</span><span class="s3">, </span><span class="s1">diagonals))</span>

    <span class="s1">offsets = np.atleast_1d(offsets)</span>

    <span class="s5"># Basic check</span>
    <span class="s3">if </span><span class="s1">len(diagonals) != len(offsets):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Different number of diagonals and offsets.&quot;</span><span class="s1">)</span>

    <span class="s5"># Determine shape, if omitted</span>
    <span class="s3">if </span><span class="s1">shape </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">m = len(diagonals[</span><span class="s4">0</span><span class="s1">]) + abs(int(offsets[</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">shape = (m</span><span class="s3">, </span><span class="s1">m)</span>

    <span class="s5"># Determine data type, if omitted</span>
    <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">dtype = np.common_type(*diagonals)</span>

    <span class="s5"># Construct data array</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = shape</span>

    <span class="s1">M = max([min(m + offset</span><span class="s3">, </span><span class="s1">n - offset) + max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">offset)</span>
             <span class="s3">for </span><span class="s1">offset </span><span class="s3">in </span><span class="s1">offsets])</span>
    <span class="s1">M = max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">M)</span>
    <span class="s1">data_arr = np.zeros((len(offsets)</span><span class="s3">, </span><span class="s1">M)</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">K = min(m</span><span class="s3">, </span><span class="s1">n)</span>

    <span class="s3">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">diagonal </span><span class="s3">in </span><span class="s1">enumerate(diagonals):</span>
        <span class="s1">offset = offsets[j]</span>
        <span class="s1">k = max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">offset)</span>
        <span class="s1">length = min(m + offset</span><span class="s3">, </span><span class="s1">n - offset</span><span class="s3">, </span><span class="s1">K)</span>
        <span class="s3">if </span><span class="s1">length &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Offset %d (index %d) out of bounds&quot; </span><span class="s1">% (offset</span><span class="s3">, </span><span class="s1">j))</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">data_arr[j</span><span class="s3">, </span><span class="s1">k:k+length] = diagonal[...</span><span class="s3">,</span><span class="s1">:length]</span>
        <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">if </span><span class="s1">len(diagonal) != length </span><span class="s3">and </span><span class="s1">len(diagonal) != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Diagonal length (index %d: %d at offset %d) does not &quot;</span>
                    <span class="s2">&quot;agree with matrix size (%d, %d).&quot; </span><span class="s1">% (</span>
                    <span class="s1">j</span><span class="s3">, </span><span class="s1">len(diagonal)</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n)) </span><span class="s3">from </span><span class="s1">e</span>
            <span class="s3">raise</span>

    <span class="s3">return </span><span class="s1">dia_matrix((data_arr</span><span class="s3">, </span><span class="s1">offsets)</span><span class="s3">, </span><span class="s1">shape=(m</span><span class="s3">, </span><span class="s1">n)).asformat(format)</span>


<span class="s3">def </span><span class="s1">identity(n</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s2">'d'</span><span class="s3">, </span><span class="s1">format=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Identity matrix in sparse format 
 
    Returns an identity matrix with shape (n,n) using a given 
    sparse format and dtype. 
 
    Parameters 
    ---------- 
    n : int 
        Shape of the identity matrix. 
    dtype : dtype, optional 
        Data type of the matrix 
    format : str, optional 
        Sparse format of the result, e.g., format=&quot;csr&quot;, etc. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import identity 
    &gt;&gt;&gt; identity(3).toarray() 
    array([[ 1.,  0.,  0.], 
           [ 0.,  1.,  0.], 
           [ 0.,  0.,  1.]]) 
    &gt;&gt;&gt; identity(3, dtype='int8', format='dia') 
    &lt;3x3 sparse matrix of type '&lt;class 'numpy.int8'&gt;' 
            with 3 stored elements (1 diagonals) in DIAgonal format&gt; 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">eye(n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">format=format)</span>


<span class="s3">def </span><span class="s1">eye(m</span><span class="s3">, </span><span class="s1">n=</span><span class="s3">None, </span><span class="s1">k=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">dtype=float</span><span class="s3">, </span><span class="s1">format=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Sparse matrix with ones on diagonal 
 
    Returns a sparse (m x n) matrix where the kth diagonal 
    is all ones and everything else is zeros. 
 
    Parameters 
    ---------- 
    m : int 
        Number of rows in the matrix. 
    n : int, optional 
        Number of columns. Default: `m`. 
    k : int, optional 
        Diagonal to place ones on. Default: 0 (main diagonal). 
    dtype : dtype, optional 
        Data type of the matrix. 
    format : str, optional 
        Sparse format of the result, e.g., format=&quot;csr&quot;, etc. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; sparse.eye(3).toarray() 
    array([[ 1.,  0.,  0.], 
           [ 0.,  1.,  0.], 
           [ 0.,  0.,  1.]]) 
    &gt;&gt;&gt; sparse.eye(3, dtype=np.int8) 
    &lt;3x3 sparse matrix of type '&lt;class 'numpy.int8'&gt;' 
        with 3 stored elements (1 diagonals) in DIAgonal format&gt; 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">n = m</span>
    <span class="s1">m</span><span class="s3">,</span><span class="s1">n = int(m)</span><span class="s3">,</span><span class="s1">int(n)</span>

    <span class="s3">if </span><span class="s1">m == n </span><span class="s3">and </span><span class="s1">k == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s5"># fast branch for special formats</span>
        <span class="s3">if </span><span class="s1">format </span><span class="s3">in </span><span class="s1">[</span><span class="s2">'csr'</span><span class="s3">, </span><span class="s2">'csc'</span><span class="s1">]:</span>
            <span class="s1">idx_dtype = get_index_dtype(maxval=n)</span>
            <span class="s1">indptr = np.arange(n+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">indices = np.arange(n</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">data = np.ones(n</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">cls = {</span><span class="s2">'csr'</span><span class="s1">: csr_matrix</span><span class="s3">, </span><span class="s2">'csc'</span><span class="s1">: csc_matrix}[format]</span>
            <span class="s3">return </span><span class="s1">cls((data</span><span class="s3">,</span><span class="s1">indices</span><span class="s3">,</span><span class="s1">indptr)</span><span class="s3">,</span><span class="s1">(n</span><span class="s3">,</span><span class="s1">n))</span>
        <span class="s3">elif </span><span class="s1">format == </span><span class="s2">'coo'</span><span class="s1">:</span>
            <span class="s1">idx_dtype = get_index_dtype(maxval=n)</span>
            <span class="s1">row = np.arange(n</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">col = np.arange(n</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">data = np.ones(n</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
            <span class="s3">return </span><span class="s1">coo_matrix((data</span><span class="s3">, </span><span class="s1">(row</span><span class="s3">, </span><span class="s1">col))</span><span class="s3">, </span><span class="s1">(n</span><span class="s3">, </span><span class="s1">n))</span>

    <span class="s1">diags = np.ones((</span><span class="s4">1</span><span class="s3">, </span><span class="s1">max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">min(m + k</span><span class="s3">, </span><span class="s1">n)))</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
    <span class="s3">return </span><span class="s1">spdiags(diags</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n).asformat(format)</span>


<span class="s3">def </span><span class="s1">kron(A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">format=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;kronecker product of sparse matrices A and B 
 
    Parameters 
    ---------- 
    A : sparse or dense matrix 
        first matrix of the product 
    B : sparse or dense matrix 
        second matrix of the product 
    format : str, optional 
        format of the result (e.g. &quot;csr&quot;) 
 
    Returns 
    ------- 
    kronecker product in a sparse matrix format 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; A = sparse.csr_matrix(np.array([[0, 2], [5, 0]])) 
    &gt;&gt;&gt; B = sparse.csr_matrix(np.array([[1, 2], [3, 4]])) 
    &gt;&gt;&gt; sparse.kron(A, B).toarray() 
    array([[ 0,  0,  2,  4], 
           [ 0,  0,  6,  8], 
           [ 5, 10,  0,  0], 
           [15, 20,  0,  0]]) 
 
    &gt;&gt;&gt; sparse.kron(A, [[1, 2], [3, 4]]).toarray() 
    array([[ 0,  0,  2,  4], 
           [ 0,  0,  6,  8], 
           [ 5, 10,  0,  0], 
           [15, 20,  0,  0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">B = coo_matrix(B)</span>

    <span class="s3">if </span><span class="s1">(format </span><span class="s3">is None or </span><span class="s1">format == </span><span class="s2">&quot;bsr&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s4">2</span><span class="s1">*B.nnz &gt;= B.shape[</span><span class="s4">0</span><span class="s1">] * B.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s5"># B is fairly dense, use BSR</span>
        <span class="s1">A = csr_matrix(A</span><span class="s3">,</span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">output_shape = (A.shape[</span><span class="s4">0</span><span class="s1">]*B.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">A.shape[</span><span class="s4">1</span><span class="s1">]*B.shape[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s3">if </span><span class="s1">A.nnz == </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">B.nnz == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s5"># kronecker product is the zero matrix</span>
            <span class="s3">return </span><span class="s1">coo_matrix(output_shape).asformat(format)</span>

        <span class="s1">B = B.toarray()</span>
        <span class="s1">data = A.data.repeat(B.size).reshape(-</span><span class="s4">1</span><span class="s3">,</span><span class="s1">B.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1">B.shape[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">data = data * B</span>

        <span class="s3">return </span><span class="s1">bsr_matrix((data</span><span class="s3">,</span><span class="s1">A.indices</span><span class="s3">,</span><span class="s1">A.indptr)</span><span class="s3">, </span><span class="s1">shape=output_shape)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s5"># use COO</span>
        <span class="s1">A = coo_matrix(A)</span>
        <span class="s1">output_shape = (A.shape[</span><span class="s4">0</span><span class="s1">]*B.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">A.shape[</span><span class="s4">1</span><span class="s1">]*B.shape[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s3">if </span><span class="s1">A.nnz == </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">B.nnz == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s5"># kronecker product is the zero matrix</span>
            <span class="s3">return </span><span class="s1">coo_matrix(output_shape).asformat(format)</span>

        <span class="s5"># expand entries of a into blocks</span>
        <span class="s1">row = A.row.repeat(B.nnz)</span>
        <span class="s1">col = A.col.repeat(B.nnz)</span>
        <span class="s1">data = A.data.repeat(B.nnz)</span>

        <span class="s3">if </span><span class="s1">max(A.shape[</span><span class="s4">0</span><span class="s1">]*B.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">A.shape[</span><span class="s4">1</span><span class="s1">]*B.shape[</span><span class="s4">1</span><span class="s1">]) &gt; np.iinfo(</span><span class="s2">'int32'</span><span class="s1">).max:</span>
            <span class="s1">row = row.astype(np.int64)</span>
            <span class="s1">col = col.astype(np.int64)</span>

        <span class="s1">row *= B.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">col *= B.shape[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s5"># increment block indices</span>
        <span class="s1">row</span><span class="s3">,</span><span class="s1">col = row.reshape(-</span><span class="s4">1</span><span class="s3">,</span><span class="s1">B.nnz)</span><span class="s3">,</span><span class="s1">col.reshape(-</span><span class="s4">1</span><span class="s3">,</span><span class="s1">B.nnz)</span>
        <span class="s1">row += B.row</span>
        <span class="s1">col += B.col</span>
        <span class="s1">row</span><span class="s3">,</span><span class="s1">col = row.reshape(-</span><span class="s4">1</span><span class="s1">)</span><span class="s3">,</span><span class="s1">col.reshape(-</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># compute block entries</span>
        <span class="s1">data = data.reshape(-</span><span class="s4">1</span><span class="s3">,</span><span class="s1">B.nnz) * B.data</span>
        <span class="s1">data = data.reshape(-</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">coo_matrix((data</span><span class="s3">,</span><span class="s1">(row</span><span class="s3">,</span><span class="s1">col))</span><span class="s3">, </span><span class="s1">shape=output_shape).asformat(format)</span>


<span class="s3">def </span><span class="s1">kronsum(A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">format=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;kronecker sum of sparse matrices A and B 
 
    Kronecker sum of two sparse matrices is a sum of two Kronecker 
    products kron(I_n,A) + kron(B,I_m) where A has shape (m,m) 
    and B has shape (n,n) and I_m and I_n are identity matrices 
    of shape (m,m) and (n,n), respectively. 
 
    Parameters 
    ---------- 
    A 
        square matrix 
    B 
        square matrix 
    format : str 
        format of the result (e.g. &quot;csr&quot;) 
 
    Returns 
    ------- 
    kronecker sum in a sparse matrix format 
 
    Examples 
    -------- 
 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A = coo_matrix(A)</span>
    <span class="s1">B = coo_matrix(B)</span>

    <span class="s3">if </span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">] != A.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'A is not square'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">B.shape[</span><span class="s4">0</span><span class="s1">] != B.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'B is not square'</span><span class="s1">)</span>

    <span class="s1">dtype = upcast(A.dtype</span><span class="s3">, </span><span class="s1">B.dtype)</span>

    <span class="s1">L = kron(eye(B.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">format=format)</span>
    <span class="s1">R = kron(B</span><span class="s3">, </span><span class="s1">eye(A.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">format=format)</span>

    <span class="s3">return </span><span class="s1">(L+R).asformat(format)  </span><span class="s5"># since L + R is not always same format</span>


<span class="s3">def </span><span class="s1">_compressed_sparse_stack(blocks</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stacking fast path for CSR/CSC matrices 
    (i) vstack for CSR, (ii) hstack for CSC. 
    &quot;&quot;&quot;</span>
    <span class="s1">other_axis = </span><span class="s4">1 </span><span class="s3">if </span><span class="s1">axis == </span><span class="s4">0 </span><span class="s3">else </span><span class="s4">0</span>
    <span class="s1">data = np.concatenate([b.data </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks])</span>
    <span class="s1">constant_dim = blocks[</span><span class="s4">0</span><span class="s1">].shape[other_axis]</span>
    <span class="s1">idx_dtype = get_index_dtype(arrays=[b.indptr </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks]</span><span class="s3">,</span>
                                <span class="s1">maxval=max(data.size</span><span class="s3">, </span><span class="s1">constant_dim))</span>
    <span class="s1">indices = np.empty(data.size</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
    <span class="s1">indptr = np.empty(sum(b.shape[axis] </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks) + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
    <span class="s1">last_indptr = idx_dtype(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">sum_dim = </span><span class="s4">0</span>
    <span class="s1">sum_indices = </span><span class="s4">0</span>
    <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks:</span>
        <span class="s3">if </span><span class="s1">b.shape[other_axis] != constant_dim:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">f'incompatible dimensions for axis </span><span class="s3">{</span><span class="s1">other_axis</span><span class="s3">}</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">indices[sum_indices:sum_indices+b.indices.size] = b.indices</span>
        <span class="s1">sum_indices += b.indices.size</span>
        <span class="s1">idxs = slice(sum_dim</span><span class="s3">, </span><span class="s1">sum_dim + b.shape[axis])</span>
        <span class="s1">indptr[idxs] = b.indptr[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">indptr[idxs] += last_indptr</span>
        <span class="s1">sum_dim += b.shape[axis]</span>
        <span class="s1">last_indptr += b.indptr[-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">indptr[-</span><span class="s4">1</span><span class="s1">] = last_indptr</span>
    <span class="s3">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">csr_matrix((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">,</span>
                          <span class="s1">shape=(sum_dim</span><span class="s3">, </span><span class="s1">constant_dim))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">csc_matrix((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">,</span>
                          <span class="s1">shape=(constant_dim</span><span class="s3">, </span><span class="s1">sum_dim))</span>


<span class="s3">def </span><span class="s1">_stack_along_minor_axis(blocks</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stacking fast path for CSR/CSC matrices along the minor axis 
    (i) hstack for CSR, (ii) vstack for CSC. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_blocks = len(blocks)</span>
    <span class="s3">if </span><span class="s1">n_blocks == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'Missing block matrices'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n_blocks == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">blocks[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s5"># check for incompatible dimensions</span>
    <span class="s1">other_axis = </span><span class="s4">1 </span><span class="s3">if </span><span class="s1">axis == </span><span class="s4">0 </span><span class="s3">else </span><span class="s4">0</span>
    <span class="s1">other_axis_dims = {b.shape[other_axis] </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks}</span>
    <span class="s3">if </span><span class="s1">len(other_axis_dims) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">f'Mismatching dimensions along axis </span><span class="s3">{</span><span class="s1">other_axis</span><span class="s3">}</span><span class="s2">: '</span>
                         <span class="s2">f'</span><span class="s3">{</span><span class="s1">other_axis_dims</span><span class="s3">}</span><span class="s2">'</span><span class="s1">)</span>
    <span class="s1">constant_dim</span><span class="s3">, </span><span class="s1">= other_axis_dims</span>

    <span class="s5"># Do the stacking</span>
    <span class="s1">indptr_list = [b.indptr </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks]</span>
    <span class="s1">data_cat = np.concatenate([b.data </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks])</span>

    <span class="s5"># Need to check if any indices/indptr, would be too large post-</span>
    <span class="s5"># concatenation for np.int32:</span>
    <span class="s5"># - The max value of indices is the output array's stacking-axis length - 1</span>
    <span class="s5"># - The max value in indptr is the number of non-zero entries. This is</span>
    <span class="s5">#   exceedingly unlikely to require int64, but is checked out of an</span>
    <span class="s5">#   abundance of caution.</span>
    <span class="s1">sum_dim = sum(b.shape[axis] </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks)</span>
    <span class="s1">nnz = sum(len(b.indices) </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks)</span>
    <span class="s1">idx_dtype = get_index_dtype(maxval=max(sum_dim - </span><span class="s4">1</span><span class="s3">, </span><span class="s1">nnz))</span>
    <span class="s1">stack_dim_cat = np.array([b.shape[axis] </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks]</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
    <span class="s3">if </span><span class="s1">data_cat.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">indptr_cat = np.concatenate(indptr_list).astype(idx_dtype)</span>
        <span class="s1">indices_cat = (np.concatenate([b.indices </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks])</span>
                       <span class="s1">.astype(idx_dtype))</span>
        <span class="s1">indptr = np.empty(constant_dim + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">indices = np.empty_like(indices_cat)</span>
        <span class="s1">data = np.empty_like(data_cat)</span>
        <span class="s1">csr_hstack(n_blocks</span><span class="s3">, </span><span class="s1">constant_dim</span><span class="s3">, </span><span class="s1">stack_dim_cat</span><span class="s3">,</span>
                   <span class="s1">indptr_cat</span><span class="s3">, </span><span class="s1">indices_cat</span><span class="s3">, </span><span class="s1">data_cat</span><span class="s3">,</span>
                   <span class="s1">indptr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">data)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">indptr = np.zeros(constant_dim + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">indices = np.empty(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">data = np.empty(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">dtype=data_cat.dtype)</span>

    <span class="s3">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">csc_matrix((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">,</span>
                          <span class="s1">shape=(sum_dim</span><span class="s3">, </span><span class="s1">constant_dim))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">csr_matrix((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">,</span>
                          <span class="s1">shape=(constant_dim</span><span class="s3">, </span><span class="s1">sum_dim))</span>


<span class="s3">def </span><span class="s1">hstack(blocks</span><span class="s3">, </span><span class="s1">format=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stack sparse matrices horizontally (column wise) 
 
    Parameters 
    ---------- 
    blocks 
        sequence of sparse matrices with compatible shapes 
    format : str 
        sparse format of the result (e.g., &quot;csr&quot;) 
        by default an appropriate sparse matrix format is returned. 
        This choice is subject to change. 
    dtype : dtype, optional 
        The data-type of the output matrix. If not given, the dtype is 
        determined from that of `blocks`. 
 
    See Also 
    -------- 
    vstack : stack sparse matrices vertically (row wise) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_matrix, hstack 
    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_matrix([[5], [6]]) 
    &gt;&gt;&gt; hstack([A,B]).toarray() 
    array([[1, 2, 5], 
           [3, 4, 6]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">bmat([blocks]</span><span class="s3">, </span><span class="s1">format=format</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s3">def </span><span class="s1">vstack(blocks</span><span class="s3">, </span><span class="s1">format=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stack sparse matrices vertically (row wise) 
 
    Parameters 
    ---------- 
    blocks 
        sequence of sparse matrices with compatible shapes 
    format : str, optional 
        sparse format of the result (e.g., &quot;csr&quot;) 
        by default an appropriate sparse matrix format is returned. 
        This choice is subject to change. 
    dtype : dtype, optional 
        The data-type of the output matrix. If not given, the dtype is 
        determined from that of `blocks`. 
 
    See Also 
    -------- 
    hstack : stack sparse matrices horizontally (column wise) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_matrix, vstack 
    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_matrix([[5, 6]]) 
    &gt;&gt;&gt; vstack([A, B]).toarray() 
    array([[1, 2], 
           [3, 4], 
           [5, 6]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">bmat([[b] </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks]</span><span class="s3">, </span><span class="s1">format=format</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s3">def </span><span class="s1">bmat(blocks</span><span class="s3">, </span><span class="s1">format=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Build a sparse matrix from sparse sub-blocks 
 
    Parameters 
    ---------- 
    blocks : array_like 
        Grid of sparse matrices with compatible shapes. 
        An entry of None implies an all-zero matrix. 
    format : {'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil'}, optional 
        The sparse format of the result (e.g. &quot;csr&quot;). By default an 
        appropriate sparse matrix format is returned. 
        This choice is subject to change. 
    dtype : dtype, optional 
        The data-type of the output matrix. If not given, the dtype is 
        determined from that of `blocks`. 
 
    Returns 
    ------- 
    bmat : sparse matrix 
 
    See Also 
    -------- 
    block_diag, diags 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_matrix, bmat 
    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_matrix([[5], [6]]) 
    &gt;&gt;&gt; C = coo_matrix([[7]]) 
    &gt;&gt;&gt; bmat([[A, B], [None, C]]).toarray() 
    array([[1, 2, 5], 
           [3, 4, 6], 
           [0, 0, 7]]) 
 
    &gt;&gt;&gt; bmat([[A, None], [None, C]]).toarray() 
    array([[1, 2, 0], 
           [3, 4, 0], 
           [0, 0, 7]]) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">blocks = np.asarray(blocks</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s2">'object'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">blocks.ndim != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'blocks must be 2-D'</span><span class="s1">)</span>

    <span class="s1">M</span><span class="s3">,</span><span class="s1">N = blocks.shape</span>

    <span class="s5"># check for fast path cases</span>
    <span class="s3">if </span><span class="s1">(format </span><span class="s3">in </span><span class="s1">(</span><span class="s3">None, </span><span class="s2">'csr'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">all(isinstance(b</span><span class="s3">, </span><span class="s1">csr_matrix)</span>
                                        <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks.flat)):</span>
        <span class="s3">if </span><span class="s1">N &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s5"># stack along columns (axis 1):</span>
            <span class="s1">blocks = [[_stack_along_minor_axis(blocks[b</span><span class="s3">, </span><span class="s1">:]</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)]</span>
                      <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">range(M)]   </span><span class="s5"># must have shape: (M, 1)</span>
            <span class="s1">blocks = np.asarray(blocks</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s2">'object'</span><span class="s1">)</span>

        <span class="s5"># stack along rows (axis 0):</span>
        <span class="s1">A = _compressed_sparse_stack(blocks[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">A = A.astype(dtype)</span>
        <span class="s3">return </span><span class="s1">A</span>
    <span class="s3">elif </span><span class="s1">(format </span><span class="s3">in </span><span class="s1">(</span><span class="s3">None, </span><span class="s2">'csc'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">all(isinstance(b</span><span class="s3">, </span><span class="s1">csc_matrix)</span>
                                          <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">blocks.flat)):</span>
        <span class="s3">if </span><span class="s1">M &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s5"># stack along rows (axis 0):</span>
            <span class="s1">blocks = [[_stack_along_minor_axis(blocks[:</span><span class="s3">, </span><span class="s1">b]</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
                       <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">range(N)]]   </span><span class="s5"># must have shape: (1, N)</span>
            <span class="s1">blocks = np.asarray(blocks</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s2">'object'</span><span class="s1">)</span>

        <span class="s5"># stack along columns (axis 1):</span>
        <span class="s1">A = _compressed_sparse_stack(blocks[</span><span class="s4">0</span><span class="s3">, </span><span class="s1">:]</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">A = A.astype(dtype)</span>
        <span class="s3">return </span><span class="s1">A</span>

    <span class="s1">block_mask = np.zeros(blocks.shape</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">brow_lengths = np.zeros(M</span><span class="s3">, </span><span class="s1">dtype=np.int64)</span>
    <span class="s1">bcol_lengths = np.zeros(N</span><span class="s3">, </span><span class="s1">dtype=np.int64)</span>

    <span class="s5"># convert everything to COO format</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(M):</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(N):</span>
            <span class="s3">if </span><span class="s1">blocks[i</span><span class="s3">,</span><span class="s1">j] </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">A = coo_matrix(blocks[i</span><span class="s3">,</span><span class="s1">j])</span>
                <span class="s1">blocks[i</span><span class="s3">,</span><span class="s1">j] = A</span>
                <span class="s1">block_mask[i</span><span class="s3">,</span><span class="s1">j] = </span><span class="s3">True</span>

                <span class="s3">if </span><span class="s1">brow_lengths[i] == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">brow_lengths[i] = A.shape[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">brow_lengths[i] != A.shape[</span><span class="s4">0</span><span class="s1">]:</span>
                    <span class="s1">msg = (</span><span class="s2">f'blocks[</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s2">,:] has incompatible row dimensions. '</span>
                           <span class="s2">f'Got blocks[</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s2">,</span><span class="s3">{</span><span class="s1">j</span><span class="s3">}</span><span class="s2">].shape[0] == </span><span class="s3">{</span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">}</span><span class="s2">, '</span>
                           <span class="s2">f'expected </span><span class="s3">{</span><span class="s1">brow_lengths[i]</span><span class="s3">}</span><span class="s2">.'</span><span class="s1">)</span>
                    <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

                <span class="s3">if </span><span class="s1">bcol_lengths[j] == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">bcol_lengths[j] = A.shape[</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">bcol_lengths[j] != A.shape[</span><span class="s4">1</span><span class="s1">]:</span>
                    <span class="s1">msg = (</span><span class="s2">f'blocks[:,</span><span class="s3">{</span><span class="s1">j</span><span class="s3">}</span><span class="s2">] has incompatible column '</span>
                           <span class="s2">f'dimensions. '</span>
                           <span class="s2">f'Got blocks[</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s2">,</span><span class="s3">{</span><span class="s1">j</span><span class="s3">}</span><span class="s2">].shape[1] == </span><span class="s3">{</span><span class="s1">A.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">}</span><span class="s2">, '</span>
                           <span class="s2">f'expected </span><span class="s3">{</span><span class="s1">bcol_lengths[j]</span><span class="s3">}</span><span class="s2">.'</span><span class="s1">)</span>
                    <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s1">nnz = sum(block.nnz </span><span class="s3">for </span><span class="s1">block </span><span class="s3">in </span><span class="s1">blocks[block_mask])</span>
    <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">all_dtypes = [blk.dtype </span><span class="s3">for </span><span class="s1">blk </span><span class="s3">in </span><span class="s1">blocks[block_mask]]</span>
        <span class="s1">dtype = upcast(*all_dtypes) </span><span class="s3">if </span><span class="s1">all_dtypes </span><span class="s3">else None</span>

    <span class="s1">row_offsets = np.append(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">np.cumsum(brow_lengths))</span>
    <span class="s1">col_offsets = np.append(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">np.cumsum(bcol_lengths))</span>

    <span class="s1">shape = (row_offsets[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">col_offsets[-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">data = np.empty(nnz</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">idx_dtype = get_index_dtype(maxval=max(shape))</span>
    <span class="s1">row = np.empty(nnz</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
    <span class="s1">col = np.empty(nnz</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>

    <span class="s1">nnz = </span><span class="s4">0</span>
    <span class="s1">ii</span><span class="s3">, </span><span class="s1">jj = np.nonzero(block_mask)</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">zip(ii</span><span class="s3">, </span><span class="s1">jj):</span>
        <span class="s1">B = blocks[i</span><span class="s3">, </span><span class="s1">j]</span>
        <span class="s1">idx = slice(nnz</span><span class="s3">, </span><span class="s1">nnz + B.nnz)</span>
        <span class="s1">data[idx] = B.data</span>
        <span class="s1">np.add(B.row</span><span class="s3">, </span><span class="s1">row_offsets[i]</span><span class="s3">, </span><span class="s1">out=row[idx]</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">np.add(B.col</span><span class="s3">, </span><span class="s1">col_offsets[j]</span><span class="s3">, </span><span class="s1">out=col[idx]</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">nnz += B.nnz</span>

    <span class="s3">return </span><span class="s1">coo_matrix((data</span><span class="s3">, </span><span class="s1">(row</span><span class="s3">, </span><span class="s1">col))</span><span class="s3">, </span><span class="s1">shape=shape).asformat(format)</span>


<span class="s3">def </span><span class="s1">block_diag(mats</span><span class="s3">, </span><span class="s1">format=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Build a block diagonal sparse matrix from provided matrices. 
 
    Parameters 
    ---------- 
    mats : sequence of matrices 
        Input matrices. 
    format : str, optional 
        The sparse format of the result (e.g., &quot;csr&quot;). If not given, the matrix 
        is returned in &quot;coo&quot; format. 
    dtype : dtype specifier, optional 
        The data-type of the output matrix. If not given, the dtype is 
        determined from that of `blocks`. 
 
    Returns 
    ------- 
    res : sparse matrix 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.11.0 
 
    See Also 
    -------- 
    bmat, diags 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_matrix, block_diag 
    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_matrix([[5], [6]]) 
    &gt;&gt;&gt; C = coo_matrix([[7]]) 
    &gt;&gt;&gt; block_diag((A, B, C)).toarray() 
    array([[1, 2, 0, 0], 
           [3, 4, 0, 0], 
           [0, 0, 5, 0], 
           [0, 0, 6, 0], 
           [0, 0, 0, 7]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">row = []</span>
    <span class="s1">col = []</span>
    <span class="s1">data = []</span>
    <span class="s1">r_idx = </span><span class="s4">0</span>
    <span class="s1">c_idx = </span><span class="s4">0</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">mats:</span>
        <span class="s3">if </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">(list</span><span class="s3">, </span><span class="s1">numbers.Number)):</span>
            <span class="s1">a = coo_matrix(a)</span>
        <span class="s1">nrows</span><span class="s3">, </span><span class="s1">ncols = a.shape</span>
        <span class="s3">if </span><span class="s1">issparse(a):</span>
            <span class="s1">a = a.tocoo()</span>
            <span class="s1">row.append(a.row + r_idx)</span>
            <span class="s1">col.append(a.col + c_idx)</span>
            <span class="s1">data.append(a.data)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a_row</span><span class="s3">, </span><span class="s1">a_col = np.divmod(np.arange(nrows*ncols)</span><span class="s3">, </span><span class="s1">ncols)</span>
            <span class="s1">row.append(a_row + r_idx)</span>
            <span class="s1">col.append(a_col + c_idx)</span>
            <span class="s1">data.append(a.ravel())</span>
        <span class="s1">r_idx += nrows</span>
        <span class="s1">c_idx += ncols</span>
    <span class="s1">row = np.concatenate(row)</span>
    <span class="s1">col = np.concatenate(col)</span>
    <span class="s1">data = np.concatenate(data)</span>
    <span class="s3">return </span><span class="s1">coo_matrix((data</span><span class="s3">, </span><span class="s1">(row</span><span class="s3">, </span><span class="s1">col))</span><span class="s3">,</span>
                      <span class="s1">shape=(r_idx</span><span class="s3">, </span><span class="s1">c_idx)</span><span class="s3">,</span>
                      <span class="s1">dtype=dtype).asformat(format)</span>


<span class="s3">def </span><span class="s1">random(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">density=</span><span class="s4">0.01</span><span class="s3">, </span><span class="s1">format=</span><span class="s2">'coo'</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None,</span>
           <span class="s1">random_state=</span><span class="s3">None, </span><span class="s1">data_rvs=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Generate a sparse matrix of the given shape and density with randomly 
    distributed values. 
 
    Parameters 
    ---------- 
    m, n : int 
        shape of the matrix 
    density : real, optional 
        density of the generated matrix: density equal to one means a full 
        matrix, density of 0 means a matrix with no non-zero items. 
    format : str, optional 
        sparse matrix format. 
    dtype : dtype, optional 
        type of the returned matrix values. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
        This random state will be used 
        for sampling the sparsity structure, but not necessarily for sampling 
        the values of the structurally nonzero entries of the matrix. 
    data_rvs : callable, optional 
        Samples a requested number of random values. 
        This function should take a single argument specifying the length 
        of the ndarray that it will return. The structurally nonzero entries 
        of the sparse random matrix will be taken from the array sampled 
        by this function. By default, uniform [0, 1) random values will be 
        sampled using the same random state as is used for sampling 
        the sparsity structure. 
 
    Returns 
    ------- 
    res : sparse matrix 
 
    Notes 
    ----- 
    Only float types are supported for now. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import random 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; from numpy.random import default_rng 
    &gt;&gt;&gt; rng = default_rng() 
    &gt;&gt;&gt; rvs = stats.poisson(25, loc=10).rvs 
    &gt;&gt;&gt; S = random(3, 4, density=0.25, random_state=rng, data_rvs=rvs) 
    &gt;&gt;&gt; S.A 
    array([[ 36.,   0.,  33.,   0.],   # random 
           [  0.,   0.,   0.,   0.], 
           [  0.,   0.,  36.,   0.]]) 
 
    &gt;&gt;&gt; from scipy.sparse import random 
    &gt;&gt;&gt; from scipy.stats import rv_continuous 
    &gt;&gt;&gt; class CustomDistribution(rv_continuous): 
    ...     def _rvs(self,  size=None, random_state=None): 
    ...         return random_state.standard_normal(size) 
    &gt;&gt;&gt; X = CustomDistribution(seed=rng) 
    &gt;&gt;&gt; Y = X()  # get a frozen version of the distribution 
    &gt;&gt;&gt; S = random(3, 4, density=0.25, random_state=rng, data_rvs=Y.rvs) 
    &gt;&gt;&gt; S.A 
    array([[ 0.        ,  0.        ,  0.        ,  0.        ],   # random 
           [ 0.13569738,  1.9467163 , -0.81205367,  0.        ], 
           [ 0.        ,  0.        ,  0.        ,  0.        ]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">density &lt; </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">density &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;density expected to be 0 &lt;= density &lt;= 1&quot;</span><span class="s1">)</span>
    <span class="s1">dtype = np.dtype(dtype)</span>

    <span class="s1">mn = m * n</span>

    <span class="s1">tp = np.intc</span>
    <span class="s3">if </span><span class="s1">mn &gt; np.iinfo(tp).max:</span>
        <span class="s1">tp = np.int64</span>

    <span class="s3">if </span><span class="s1">mn &gt; np.iinfo(tp).max:</span>
        <span class="s1">msg = </span><span class="s2">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s2">Trying to generate a random sparse matrix such as the product of dimensions is 
greater than %d - this is not supported on this machine 
&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">ValueError(msg % np.iinfo(tp).max)</span>

    <span class="s5"># Number of non zero values</span>
    <span class="s1">k = int(round(density * m * n))</span>

    <span class="s1">random_state = check_random_state(random_state)</span>

    <span class="s3">if </span><span class="s1">data_rvs </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">np.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
            <span class="s3">def </span><span class="s1">data_rvs(n):</span>
                <span class="s3">return </span><span class="s1">rng_integers(random_state</span><span class="s3">,</span>
                                    <span class="s1">np.iinfo(dtype).min</span><span class="s3">,</span>
                                    <span class="s1">np.iinfo(dtype).max</span><span class="s3">,</span>
                                    <span class="s1">n</span><span class="s3">,</span>
                                    <span class="s1">dtype=dtype)</span>
        <span class="s3">elif </span><span class="s1">np.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
            <span class="s3">def </span><span class="s1">data_rvs(n):</span>
                <span class="s3">return </span><span class="s1">(random_state.uniform(size=n) +</span>
                        <span class="s1">random_state.uniform(size=n) * </span><span class="s4">1j</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">data_rvs = partial(random_state.uniform</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s4">1.</span><span class="s1">)</span>

    <span class="s1">ind = random_state.choice(mn</span><span class="s3">, </span><span class="s1">size=k</span><span class="s3">, </span><span class="s1">replace=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s1">j = np.floor(ind * </span><span class="s4">1. </span><span class="s1">/ m).astype(tp</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">i = (ind - j * m).astype(tp</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">vals = data_rvs(k).astype(dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">coo_matrix((vals</span><span class="s3">, </span><span class="s1">(i</span><span class="s3">, </span><span class="s1">j))</span><span class="s3">, </span><span class="s1">shape=(m</span><span class="s3">, </span><span class="s1">n)).asformat(format</span><span class="s3">,</span>
                                                             <span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">rand(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">density=</span><span class="s4">0.01</span><span class="s3">, </span><span class="s1">format=</span><span class="s2">&quot;coo&quot;</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Generate a sparse matrix of the given shape and density with uniformly 
    distributed values. 
 
    Parameters 
    ---------- 
    m, n : int 
        shape of the matrix 
    density : real, optional 
        density of the generated matrix: density equal to one means a full 
        matrix, density of 0 means a matrix with no non-zero items. 
    format : str, optional 
        sparse matrix format. 
    dtype : dtype, optional 
        type of the returned matrix values. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    Returns 
    ------- 
    res : sparse matrix 
 
    Notes 
    ----- 
    Only float types are supported for now. 
 
    See Also 
    -------- 
    scipy.sparse.random : Similar function that allows a user-specified random 
        data source. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import rand 
    &gt;&gt;&gt; matrix = rand(3, 4, density=0.25, format=&quot;csr&quot;, random_state=42) 
    &gt;&gt;&gt; matrix 
    &lt;3x4 sparse matrix of type '&lt;class 'numpy.float64'&gt;' 
       with 3 stored elements in Compressed Sparse Row format&gt; 
    &gt;&gt;&gt; matrix.toarray() 
    array([[0.05641158, 0.        , 0.        , 0.65088847], 
           [0.        , 0.        , 0.        , 0.14286682], 
           [0.        , 0.        , 0.        , 0.        ]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">random(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">density</span><span class="s3">, </span><span class="s1">format</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">random_state)</span>
</pre>
</body>
</html>