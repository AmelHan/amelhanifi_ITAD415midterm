<html>
<head>
<title>compiler_unparse.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compiler_unparse.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; Turn compiler.ast structures back into executable python code. 
 
    The unparse method takes a compiler.ast tree and transforms it back into 
    valid python code.  It is incomplete and currently only works for 
    import statements, function calls, function definitions, assignments, and 
    basic expressions. 
 
    Inspired by python-2.5-svn/Demo/parser/unparse.py 
 
    fixme: We may want to move to using _ast trees because the compiler for 
           them is about 6 times faster than compiler.compile. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">cStringIO</span>
<span class="s2">from </span><span class="s1">compiler.ast </span><span class="s2">import </span><span class="s1">Const</span><span class="s2">, </span><span class="s1">Name</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Div</span><span class="s2">, </span><span class="s1">Mul</span><span class="s2">, </span><span class="s1">Sub</span><span class="s2">, </span><span class="s1">Add</span>

<span class="s2">def </span><span class="s1">unparse(ast</span><span class="s2">, </span><span class="s1">single_line_functions=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">s = cStringIO.StringIO()</span>
    <span class="s1">UnparseCompilerAst(ast</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">single_line_functions)</span>
    <span class="s2">return </span><span class="s1">s.getvalue().lstrip()</span>

<span class="s1">op_precedence = { </span><span class="s3">'compiler.ast.Power'</span><span class="s1">:</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'compiler.ast.Mul'</span><span class="s1">:</span><span class="s4">2</span><span class="s2">, </span><span class="s3">'compiler.ast.Div'</span><span class="s1">:</span><span class="s4">2</span><span class="s2">,</span>
                  <span class="s3">'compiler.ast.Add'</span><span class="s1">:</span><span class="s4">1</span><span class="s2">, </span><span class="s3">'compiler.ast.Sub'</span><span class="s1">:</span><span class="s4">1 </span><span class="s1">}</span>

<span class="s2">class </span><span class="s1">UnparseCompilerAst:</span>
    <span class="s0">&quot;&quot;&quot; Methods in this class recursively traverse an AST and 
        output source code for the abstract syntax; original formatting 
        is disregarged. 
    &quot;&quot;&quot;</span>

    <span class="s5">#########################################################################</span>
    <span class="s5"># object interface.</span>
    <span class="s5">#########################################################################</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">file = sys.stdout</span><span class="s2">, </span><span class="s1">single_line_functions=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Unparser(tree, file=sys.stdout) -&gt; None. 
 
            Print the source for tree to file. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.f = file</span>
        <span class="s1">self._single_func = single_line_functions</span>
        <span class="s1">self._do_indent = </span><span class="s2">True</span>
        <span class="s1">self._indent = </span><span class="s4">0</span>
        <span class="s1">self._dispatch(tree)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">self.f.flush()</span>

    <span class="s5">#########################################################################</span>
    <span class="s5"># Unparser private interface.</span>
    <span class="s5">#########################################################################</span>

    <span class="s5">### format, output, and dispatch methods ################################</span>

    <span class="s2">def </span><span class="s1">_fill(self</span><span class="s2">, </span><span class="s1">text = </span><span class="s3">&quot;&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;Indent a piece of text, according to the current indentation level&quot;</span>
        <span class="s2">if </span><span class="s1">self._do_indent:</span>
            <span class="s1">self._write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">+</span><span class="s3">&quot;    &quot;</span><span class="s1">*self._indent + text)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._write(text)</span>

    <span class="s2">def </span><span class="s1">_write(self</span><span class="s2">, </span><span class="s1">text):</span>
        <span class="s0">&quot;Append a piece of text to the current line.&quot;</span>
        <span class="s1">self.f.write(text)</span>

    <span class="s2">def </span><span class="s1">_enter(self):</span>
        <span class="s0">&quot;Print ':', and increase the indentation.&quot;</span>
        <span class="s1">self._write(</span><span class="s3">&quot;: &quot;</span><span class="s1">)</span>
        <span class="s1">self._indent += </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">_leave(self):</span>
        <span class="s0">&quot;Decrease the indentation level.&quot;</span>
        <span class="s1">self._indent -= </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">_dispatch(self</span><span class="s2">, </span><span class="s1">tree):</span>
        <span class="s0">&quot;_dispatcher function, _dispatching tree type T to method _T.&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(tree</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tree:</span>
                <span class="s1">self._dispatch(t)</span>
            <span class="s2">return</span>
        <span class="s1">meth = getattr(self</span><span class="s2">, </span><span class="s3">&quot;_&quot;</span><span class="s1">+tree.__class__.__name__)</span>
        <span class="s2">if </span><span class="s1">tree.__class__.__name__ == </span><span class="s3">'NoneType' </span><span class="s2">and not </span><span class="s1">self._do_indent:</span>
            <span class="s2">return</span>
        <span class="s1">meth(tree)</span>


    <span class="s5">#########################################################################</span>
    <span class="s5"># compiler.ast unparsing methods.</span>
    <span class="s5">#</span>
    <span class="s5"># There should be one method per concrete grammar type. They are</span>
    <span class="s5"># organized in alphabetical order.</span>
    <span class="s5">#########################################################################</span>

    <span class="s2">def </span><span class="s1">_Add(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self.__binary_op(t</span><span class="s2">, </span><span class="s3">'+'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_And(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot; (&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">node </span><span class="s2">in </span><span class="s1">enumerate(t.nodes):</span>
            <span class="s1">self._dispatch(node)</span>
            <span class="s2">if </span><span class="s1">i != len(t.nodes)-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;) and (&quot;</span><span class="s1">)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
               
    <span class="s2">def </span><span class="s1">_AssAttr(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Handle assigning an attribute of an object 
        &quot;&quot;&quot;</span>
        <span class="s1">self._dispatch(t.expr)</span>
        <span class="s1">self._write(</span><span class="s3">'.'</span><span class="s1">+t.attrname)</span>
 
    <span class="s2">def </span><span class="s1">_Assign(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Expression Assignment such as &quot;a = 1&quot;. 
 
            This only handles assignment in expressions.  Keyword assignment 
            is handled separately. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fill()</span>
        <span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">t.nodes:</span>
            <span class="s1">self._dispatch(target)</span>
            <span class="s1">self._write(</span><span class="s3">&quot; = &quot;</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.expr)</span>
        <span class="s2">if not </span><span class="s1">self._do_indent:</span>
            <span class="s1">self._write(</span><span class="s3">'; '</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_AssName(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Name on left hand side of expression. 
 
            Treat just like a name on the right side of an expression. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._Name(t)</span>

    <span class="s2">def </span><span class="s1">_AssTuple(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Tuple on left hand side of an expression. 
        &quot;&quot;&quot;</span>

        <span class="s5"># _write each elements, separated by a comma.</span>
        <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">t.nodes[:-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">self._dispatch(element)</span>
            <span class="s1">self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>

        <span class="s5"># Handle the last one without writing comma</span>
        <span class="s1">last_element = t.nodes[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self._dispatch(last_element)</span>

    <span class="s2">def </span><span class="s1">_AugAssign(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; +=,-=,*=,/=,**=, etc. operations 
        &quot;&quot;&quot;</span>
        
        <span class="s1">self._fill()</span>
        <span class="s1">self._dispatch(t.node)</span>
        <span class="s1">self._write(</span><span class="s3">' '</span><span class="s1">+t.op+</span><span class="s3">' '</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.expr)</span>
        <span class="s2">if not </span><span class="s1">self._do_indent:</span>
            <span class="s1">self._write(</span><span class="s3">';'</span><span class="s1">)</span>
            
    <span class="s2">def </span><span class="s1">_Bitand(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Bit and operation. 
        &quot;&quot;&quot;</span>
        
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">node </span><span class="s2">in </span><span class="s1">enumerate(t.nodes):</span>
            <span class="s1">self._write(</span><span class="s3">&quot;(&quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(node)</span>
            <span class="s1">self._write(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">i != len(t.nodes)-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot; &amp; &quot;</span><span class="s1">)</span>
                
    <span class="s2">def </span><span class="s1">_Bitor(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Bit or operation 
        &quot;&quot;&quot;</span>
        
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">node </span><span class="s2">in </span><span class="s1">enumerate(t.nodes):</span>
            <span class="s1">self._write(</span><span class="s3">&quot;(&quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(node)</span>
            <span class="s1">self._write(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">i != len(t.nodes)-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot; | &quot;</span><span class="s1">)</span>
                
    <span class="s2">def </span><span class="s1">_CallFunc(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Function call. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._dispatch(t.node)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;(&quot;</span><span class="s1">)</span>
        <span class="s1">comma = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">t.args:</span>
            <span class="s2">if </span><span class="s1">comma: self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">: comma = </span><span class="s2">True</span>
            <span class="s1">self._dispatch(e)</span>
        <span class="s2">if </span><span class="s1">t.star_args:</span>
            <span class="s2">if </span><span class="s1">comma: self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">: comma = </span><span class="s2">True</span>
            <span class="s1">self._write(</span><span class="s3">&quot;*&quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(t.star_args)</span>
        <span class="s2">if </span><span class="s1">t.dstar_args:</span>
            <span class="s2">if </span><span class="s1">comma: self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">: comma = </span><span class="s2">True</span>
            <span class="s1">self._write(</span><span class="s3">&quot;**&quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(t.dstar_args)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Compare(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._dispatch(t.expr)</span>
        <span class="s2">for </span><span class="s1">op</span><span class="s2">, </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">t.ops:</span>
            <span class="s1">self._write(</span><span class="s3">&quot; &quot; </span><span class="s1">+ op + </span><span class="s3">&quot; &quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(expr)</span>

    <span class="s2">def </span><span class="s1">_Const(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; A constant value such as an integer value, 3, or a string, &quot;hello&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._dispatch(t.value)</span>

    <span class="s2">def </span><span class="s1">_Decorators(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Handle function decorators (eg. @has_units) 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">t.nodes:</span>
            <span class="s1">self._dispatch(node)</span>

    <span class="s2">def </span><span class="s1">_Dict(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot;{&quot;</span><span class="s1">)</span>
        <span class="s2">for  </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">enumerate(t.items):</span>
            <span class="s1">self._dispatch(k)</span>
            <span class="s1">self._write(</span><span class="s3">&quot;: &quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(v)</span>
            <span class="s2">if </span><span class="s1">i &lt; len(t.items)-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;}&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Discard(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Node for when return value is ignored such as in &quot;foo(a)&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fill()</span>
        <span class="s1">self._dispatch(t.expr)</span>

    <span class="s2">def </span><span class="s1">_Div(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self.__binary_op(t</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Ellipsis(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot;...&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_From(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Handle &quot;from xyz import foo, bar as baz&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s5"># fixme: Are From and ImportFrom handled differently?</span>
        <span class="s1">self._fill(</span><span class="s3">&quot;from &quot;</span><span class="s1">)</span>
        <span class="s1">self._write(t.modname)</span>
        <span class="s1">self._write(</span><span class="s3">&quot; import &quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(name</span><span class="s2">,</span><span class="s1">asname) </span><span class="s2">in </span><span class="s1">enumerate(t.names):</span>
            <span class="s2">if </span><span class="s1">i != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self._write(name)</span>
            <span class="s2">if </span><span class="s1">asname </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot; as &quot;</span><span class="s1">+asname)</span>
                
    <span class="s2">def </span><span class="s1">_Function(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Handle function definitions 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">t.decorators </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._fill(</span><span class="s3">&quot;@&quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(t.decorators)</span>
        <span class="s1">self._fill(</span><span class="s3">&quot;def &quot;</span><span class="s1">+t.name + </span><span class="s3">&quot;(&quot;</span><span class="s1">)</span>
        <span class="s1">defaults = [</span><span class="s2">None</span><span class="s1">] * (len(t.argnames) - len(t.defaults)) + list(t.defaults)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">enumerate(zip(t.argnames</span><span class="s2">, </span><span class="s1">defaults)):</span>
            <span class="s1">self._write(arg[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">arg[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">'='</span><span class="s1">)</span>
                <span class="s1">self._dispatch(arg[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">i &lt; len(t.argnames)-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">', '</span><span class="s1">)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._single_func:</span>
            <span class="s1">self._do_indent = </span><span class="s2">False</span>
        <span class="s1">self._enter()</span>
        <span class="s1">self._dispatch(t.code)</span>
        <span class="s1">self._leave()</span>
        <span class="s1">self._do_indent = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_Getattr(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Handle getting an attribute of an object 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(t.expr</span><span class="s2">, </span><span class="s1">(Div</span><span class="s2">, </span><span class="s1">Mul</span><span class="s2">, </span><span class="s1">Sub</span><span class="s2">, </span><span class="s1">Add)):</span>
            <span class="s1">self._write(</span><span class="s3">'('</span><span class="s1">)</span>
            <span class="s1">self._dispatch(t.expr)</span>
            <span class="s1">self._write(</span><span class="s3">')'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._dispatch(t.expr)</span>
            
        <span class="s1">self._write(</span><span class="s3">'.'</span><span class="s1">+t.attrname)</span>
        
    <span class="s2">def </span><span class="s1">_If(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._fill()</span>
        
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(compare</span><span class="s2">,</span><span class="s1">code) </span><span class="s2">in </span><span class="s1">enumerate(t.tests):</span>
            <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;if &quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;elif &quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(compare)</span>
            <span class="s1">self._enter()</span>
            <span class="s1">self._fill()</span>
            <span class="s1">self._dispatch(code)</span>
            <span class="s1">self._leave()</span>
            <span class="s1">self._write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">t.else_ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._write(</span><span class="s3">&quot;else&quot;</span><span class="s1">)</span>
            <span class="s1">self._enter()</span>
            <span class="s1">self._fill()</span>
            <span class="s1">self._dispatch(t.else_)</span>
            <span class="s1">self._leave()</span>
            <span class="s1">self._write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
            
    <span class="s2">def </span><span class="s1">_IfExp(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._dispatch(t.then)</span>
        <span class="s1">self._write(</span><span class="s3">&quot; if &quot;</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.test)</span>

        <span class="s2">if </span><span class="s1">t.else_ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._write(</span><span class="s3">&quot; else (&quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(t.else_)</span>
            <span class="s1">self._write(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Import(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Handle &quot;import xyz.foo&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fill(</span><span class="s3">&quot;import &quot;</span><span class="s1">)</span>
        
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(name</span><span class="s2">,</span><span class="s1">asname) </span><span class="s2">in </span><span class="s1">enumerate(t.names):</span>
            <span class="s2">if </span><span class="s1">i != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self._write(name)</span>
            <span class="s2">if </span><span class="s1">asname </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot; as &quot;</span><span class="s1">+asname)</span>

    <span class="s2">def </span><span class="s1">_Keyword(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; Keyword value assignment within function calls and definitions. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._write(t.name)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;=&quot;</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.expr)</span>
        
    <span class="s2">def </span><span class="s1">_List(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot;[&quot;</span><span class="s1">)</span>
        <span class="s2">for  </span><span class="s1">i</span><span class="s2">,</span><span class="s1">node </span><span class="s2">in </span><span class="s1">enumerate(t.nodes):</span>
            <span class="s1">self._dispatch(node)</span>
            <span class="s2">if </span><span class="s1">i &lt; len(t.nodes)-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;]&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Module(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s2">if </span><span class="s1">t.doc </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._dispatch(t.doc)</span>
        <span class="s1">self._dispatch(t.node)</span>

    <span class="s2">def </span><span class="s1">_Mul(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self.__binary_op(t</span><span class="s2">, </span><span class="s3">'*'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Name(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(t.name)</span>

    <span class="s2">def </span><span class="s1">_NoneType(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot;None&quot;</span><span class="s1">)</span>
        
    <span class="s2">def </span><span class="s1">_Not(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">'not ('</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.expr)</span>
        <span class="s1">self._write(</span><span class="s3">')'</span><span class="s1">)</span>
        
    <span class="s2">def </span><span class="s1">_Or(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot; (&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">node </span><span class="s2">in </span><span class="s1">enumerate(t.nodes):</span>
            <span class="s1">self._dispatch(node)</span>
            <span class="s2">if </span><span class="s1">i != len(t.nodes)-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;) or (&quot;</span><span class="s1">)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
                
    <span class="s2">def </span><span class="s1">_Pass(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot;pass</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Printnl(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._fill(</span><span class="s3">&quot;print &quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">t.dest:</span>
            <span class="s1">self._write(</span><span class="s3">&quot;&gt;&gt; &quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(t.dest)</span>
            <span class="s1">self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>
        <span class="s1">comma = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">t.nodes:</span>
            <span class="s2">if </span><span class="s1">comma: self._write(</span><span class="s3">', '</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">: comma = </span><span class="s2">True</span>
            <span class="s1">self._dispatch(node)</span>

    <span class="s2">def </span><span class="s1">_Power(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self.__binary_op(t</span><span class="s2">, </span><span class="s3">'**'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Return(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._fill(</span><span class="s3">&quot;return &quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">t.value:</span>
            <span class="s2">if </span><span class="s1">isinstance(t.value</span><span class="s2">, </span><span class="s1">Tuple):</span>
                <span class="s1">text = </span><span class="s3">', '</span><span class="s1">.join([ name.name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">t.value.asList() ])</span>
                <span class="s1">self._write(text)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._dispatch(t.value)</span>
            <span class="s2">if not </span><span class="s1">self._do_indent:</span>
                <span class="s1">self._write(</span><span class="s3">'; '</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Slice(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._dispatch(t.expr)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;[&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">t.lower:</span>
            <span class="s1">self._dispatch(t.lower)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">t.upper:</span>
            <span class="s1">self._dispatch(t.upper)</span>
        <span class="s5">#if t.step:</span>
        <span class="s5">#    self._write(&quot;:&quot;)</span>
        <span class="s5">#    self._dispatch(t.step)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;]&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Sliceobj(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">node </span><span class="s2">in </span><span class="s1">enumerate(t.nodes):</span>
            <span class="s2">if </span><span class="s1">i != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;:&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">(isinstance(node</span><span class="s2">, </span><span class="s1">Const) </span><span class="s2">and </span><span class="s1">node.value </span><span class="s2">is None</span><span class="s1">):</span>
                <span class="s1">self._dispatch(node)</span>

    <span class="s2">def </span><span class="s1">_Stmt(self</span><span class="s2">, </span><span class="s1">tree):</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">tree.nodes:</span>
            <span class="s1">self._dispatch(node)</span>

    <span class="s2">def </span><span class="s1">_Sub(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self.__binary_op(t</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_Subscript(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._dispatch(t.expr)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;[&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">enumerate(t.subs):</span>
            <span class="s2">if </span><span class="s1">i != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
            <span class="s1">self._dispatch(value)</span>
        <span class="s1">self._write(</span><span class="s3">&quot;]&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_TryExcept(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._fill(</span><span class="s3">&quot;try&quot;</span><span class="s1">)</span>
        <span class="s1">self._enter()</span>
        <span class="s1">self._dispatch(t.body)</span>
        <span class="s1">self._leave()</span>

        <span class="s2">for </span><span class="s1">handler </span><span class="s2">in </span><span class="s1">t.handlers:</span>
            <span class="s1">self._fill(</span><span class="s3">'except '</span><span class="s1">)</span>
            <span class="s1">self._dispatch(handler[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">handler[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._write(</span><span class="s3">', '</span><span class="s1">)</span>
                <span class="s1">self._dispatch(handler[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">self._enter()</span>
            <span class="s1">self._dispatch(handler[</span><span class="s4">2</span><span class="s1">])</span>
            <span class="s1">self._leave()</span>
            
        <span class="s2">if </span><span class="s1">t.else_:</span>
            <span class="s1">self._fill(</span><span class="s3">&quot;else&quot;</span><span class="s1">)</span>
            <span class="s1">self._enter()</span>
            <span class="s1">self._dispatch(t.else_)</span>
            <span class="s1">self._leave()</span>

    <span class="s2">def </span><span class="s1">_Tuple(self</span><span class="s2">, </span><span class="s1">t):</span>

        <span class="s2">if not </span><span class="s1">t.nodes:</span>
            <span class="s5"># Empty tuple.</span>
            <span class="s1">self._write(</span><span class="s3">&quot;()&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._write(</span><span class="s3">&quot;(&quot;</span><span class="s1">)</span>

            <span class="s5"># _write each elements, separated by a comma.</span>
            <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">t.nodes[:-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">self._dispatch(element)</span>
                <span class="s1">self._write(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span>

            <span class="s5"># Handle the last one without writing comma</span>
            <span class="s1">last_element = t.nodes[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">self._dispatch(last_element)</span>

            <span class="s1">self._write(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
            
    <span class="s2">def </span><span class="s1">_UnaryAdd(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot;+&quot;</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.expr)</span>
        
    <span class="s2">def </span><span class="s1">_UnarySub(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(</span><span class="s3">&quot;-&quot;</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.expr)        </span>

    <span class="s2">def </span><span class="s1">_With(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._fill(</span><span class="s3">'with '</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.expr)</span>
        <span class="s2">if </span><span class="s1">t.vars:</span>
            <span class="s1">self._write(</span><span class="s3">' as '</span><span class="s1">)</span>
            <span class="s1">self._dispatch(t.vars.name)</span>
        <span class="s1">self._enter()</span>
        <span class="s1">self._dispatch(t.body)</span>
        <span class="s1">self._leave()</span>
        <span class="s1">self._write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
        
    <span class="s2">def </span><span class="s1">_int(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(repr(t))</span>

    <span class="s2">def </span><span class="s1">__binary_op(self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">symbol):</span>
        <span class="s5"># Check if parenthesis are needed on left side and then dispatch</span>
        <span class="s1">has_paren = </span><span class="s2">False</span>
        <span class="s1">left_class = str(t.left.__class__)</span>
        <span class="s2">if </span><span class="s1">(left_class </span><span class="s2">in </span><span class="s1">op_precedence.keys() </span><span class="s2">and</span>
            <span class="s1">op_precedence[left_class] &lt; op_precedence[str(t.__class__)]):</span>
            <span class="s1">has_paren = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">has_paren:</span>
            <span class="s1">self._write(</span><span class="s3">'('</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.left)</span>
        <span class="s2">if </span><span class="s1">has_paren:</span>
            <span class="s1">self._write(</span><span class="s3">')'</span><span class="s1">)</span>
        <span class="s5"># Write the appropriate symbol for operator</span>
        <span class="s1">self._write(symbol)</span>
        <span class="s5"># Check if parenthesis are needed on the right side and then dispatch</span>
        <span class="s1">has_paren = </span><span class="s2">False</span>
        <span class="s1">right_class = str(t.right.__class__)</span>
        <span class="s2">if </span><span class="s1">(right_class </span><span class="s2">in </span><span class="s1">op_precedence.keys() </span><span class="s2">and</span>
            <span class="s1">op_precedence[right_class] &lt; op_precedence[str(t.__class__)]):</span>
            <span class="s1">has_paren = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">has_paren:</span>
            <span class="s1">self._write(</span><span class="s3">'('</span><span class="s1">)</span>
        <span class="s1">self._dispatch(t.right)</span>
        <span class="s2">if </span><span class="s1">has_paren:</span>
            <span class="s1">self._write(</span><span class="s3">')'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_float(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s5"># if t is 0.1, str(t)-&gt;'0.1' while repr(t)-&gt;'0.1000000000001'</span>
        <span class="s5"># We prefer str here.</span>
        <span class="s1">self._write(str(t))</span>

    <span class="s2">def </span><span class="s1">_str(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(repr(t))</span>
        
    <span class="s2">def </span><span class="s1">_tuple(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">self._write(str(t))</span>

    <span class="s5">#########################################################################</span>
    <span class="s5"># These are the methods from the _ast modules unparse.</span>
    <span class="s5">#</span>
    <span class="s5"># As our needs to handle more advanced code increase, we may want to</span>
    <span class="s5"># modify some of the methods below so that they work for compiler.ast.</span>
    <span class="s5">#########################################################################</span>

<span class="s5">#    # stmt</span>
<span class="s5">#    def _Expr(self, tree):</span>
<span class="s5">#        self._fill()</span>
<span class="s5">#        self._dispatch(tree.value)</span>
<span class="s5">#</span>
<span class="s5">#    def _Import(self, t):</span>
<span class="s5">#        self._fill(&quot;import &quot;)</span>
<span class="s5">#        first = True</span>
<span class="s5">#        for a in t.names:</span>
<span class="s5">#            if first:</span>
<span class="s5">#                first = False</span>
<span class="s5">#            else:</span>
<span class="s5">#                self._write(&quot;, &quot;)</span>
<span class="s5">#            self._write(a.name)</span>
<span class="s5">#            if a.asname:</span>
<span class="s5">#                self._write(&quot; as &quot;+a.asname)</span>
<span class="s5">#</span>
<span class="s5">##    def _ImportFrom(self, t):</span>
<span class="s5">##        self._fill(&quot;from &quot;)</span>
<span class="s5">##        self._write(t.module)</span>
<span class="s5">##        self._write(&quot; import &quot;)</span>
<span class="s5">##        for i, a in enumerate(t.names):</span>
<span class="s5">##            if i == 0:</span>
<span class="s5">##                self._write(&quot;, &quot;)</span>
<span class="s5">##            self._write(a.name)</span>
<span class="s5">##            if a.asname:</span>
<span class="s5">##                self._write(&quot; as &quot;+a.asname)</span>
<span class="s5">##        # XXX(jpe) what is level for?</span>
<span class="s5">##</span>
<span class="s5">#</span>
<span class="s5">#    def _Break(self, t):</span>
<span class="s5">#        self._fill(&quot;break&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    def _Continue(self, t):</span>
<span class="s5">#        self._fill(&quot;continue&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    def _Delete(self, t):</span>
<span class="s5">#        self._fill(&quot;del &quot;)</span>
<span class="s5">#        self._dispatch(t.targets)</span>
<span class="s5">#</span>
<span class="s5">#    def _Assert(self, t):</span>
<span class="s5">#        self._fill(&quot;assert &quot;)</span>
<span class="s5">#        self._dispatch(t.test)</span>
<span class="s5">#        if t.msg:</span>
<span class="s5">#            self._write(&quot;, &quot;)</span>
<span class="s5">#            self._dispatch(t.msg)</span>
<span class="s5">#</span>
<span class="s5">#    def _Exec(self, t):</span>
<span class="s5">#        self._fill(&quot;exec &quot;)</span>
<span class="s5">#        self._dispatch(t.body)</span>
<span class="s5">#        if t.globals:</span>
<span class="s5">#            self._write(&quot; in &quot;)</span>
<span class="s5">#            self._dispatch(t.globals)</span>
<span class="s5">#        if t.locals:</span>
<span class="s5">#            self._write(&quot;, &quot;)</span>
<span class="s5">#            self._dispatch(t.locals)</span>
<span class="s5">#</span>
<span class="s5">#    def _Print(self, t):</span>
<span class="s5">#        self._fill(&quot;print &quot;)</span>
<span class="s5">#        do_comma = False</span>
<span class="s5">#        if t.dest:</span>
<span class="s5">#            self._write(&quot;&gt;&gt;&quot;)</span>
<span class="s5">#            self._dispatch(t.dest)</span>
<span class="s5">#            do_comma = True</span>
<span class="s5">#        for e in t.values:</span>
<span class="s5">#            if do_comma:self._write(&quot;, &quot;)</span>
<span class="s5">#            else:do_comma=True</span>
<span class="s5">#            self._dispatch(e)</span>
<span class="s5">#        if not t.nl:</span>
<span class="s5">#            self._write(&quot;,&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    def _Global(self, t):</span>
<span class="s5">#        self._fill(&quot;global&quot;)</span>
<span class="s5">#        for i, n in enumerate(t.names):</span>
<span class="s5">#            if i != 0:</span>
<span class="s5">#                self._write(&quot;,&quot;)</span>
<span class="s5">#            self._write(&quot; &quot; + n)</span>
<span class="s5">#</span>
<span class="s5">#    def _Yield(self, t):</span>
<span class="s5">#        self._fill(&quot;yield&quot;)</span>
<span class="s5">#        if t.value:</span>
<span class="s5">#            self._write(&quot; (&quot;)</span>
<span class="s5">#            self._dispatch(t.value)</span>
<span class="s5">#            self._write(&quot;)&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    def _Raise(self, t):</span>
<span class="s5">#        self._fill('raise ')</span>
<span class="s5">#        if t.type:</span>
<span class="s5">#            self._dispatch(t.type)</span>
<span class="s5">#        if t.inst:</span>
<span class="s5">#            self._write(&quot;, &quot;)</span>
<span class="s5">#            self._dispatch(t.inst)</span>
<span class="s5">#        if t.tback:</span>
<span class="s5">#            self._write(&quot;, &quot;)</span>
<span class="s5">#            self._dispatch(t.tback)</span>
<span class="s5">#</span>
<span class="s5">#</span>
<span class="s5">#    def _TryFinally(self, t):</span>
<span class="s5">#        self._fill(&quot;try&quot;)</span>
<span class="s5">#        self._enter()</span>
<span class="s5">#        self._dispatch(t.body)</span>
<span class="s5">#        self._leave()</span>
<span class="s5">#</span>
<span class="s5">#        self._fill(&quot;finally&quot;)</span>
<span class="s5">#        self._enter()</span>
<span class="s5">#        self._dispatch(t.finalbody)</span>
<span class="s5">#        self._leave()</span>
<span class="s5">#</span>
<span class="s5">#    def _excepthandler(self, t):</span>
<span class="s5">#        self._fill(&quot;except &quot;)</span>
<span class="s5">#        if t.type:</span>
<span class="s5">#            self._dispatch(t.type)</span>
<span class="s5">#        if t.name:</span>
<span class="s5">#            self._write(&quot;, &quot;)</span>
<span class="s5">#            self._dispatch(t.name)</span>
<span class="s5">#        self._enter()</span>
<span class="s5">#        self._dispatch(t.body)</span>
<span class="s5">#        self._leave()</span>
<span class="s5">#</span>
<span class="s5">#    def _ClassDef(self, t):</span>
<span class="s5">#        self._write(&quot;\n&quot;)</span>
<span class="s5">#        self._fill(&quot;class &quot;+t.name)</span>
<span class="s5">#        if t.bases:</span>
<span class="s5">#            self._write(&quot;(&quot;)</span>
<span class="s5">#            for a in t.bases:</span>
<span class="s5">#                self._dispatch(a)</span>
<span class="s5">#                self._write(&quot;, &quot;)</span>
<span class="s5">#            self._write(&quot;)&quot;)</span>
<span class="s5">#        self._enter()</span>
<span class="s5">#        self._dispatch(t.body)</span>
<span class="s5">#        self._leave()</span>
<span class="s5">#</span>
<span class="s5">#    def _FunctionDef(self, t):</span>
<span class="s5">#        self._write(&quot;\n&quot;)</span>
<span class="s5">#        for deco in t.decorators:</span>
<span class="s5">#            self._fill(&quot;@&quot;)</span>
<span class="s5">#            self._dispatch(deco)</span>
<span class="s5">#        self._fill(&quot;def &quot;+t.name + &quot;(&quot;)</span>
<span class="s5">#        self._dispatch(t.args)</span>
<span class="s5">#        self._write(&quot;)&quot;)</span>
<span class="s5">#        self._enter()</span>
<span class="s5">#        self._dispatch(t.body)</span>
<span class="s5">#        self._leave()</span>
<span class="s5">#</span>
<span class="s5">#    def _For(self, t):</span>
<span class="s5">#        self._fill(&quot;for &quot;)</span>
<span class="s5">#        self._dispatch(t.target)</span>
<span class="s5">#        self._write(&quot; in &quot;)</span>
<span class="s5">#        self._dispatch(t.iter)</span>
<span class="s5">#        self._enter()</span>
<span class="s5">#        self._dispatch(t.body)</span>
<span class="s5">#        self._leave()</span>
<span class="s5">#        if t.orelse:</span>
<span class="s5">#            self._fill(&quot;else&quot;)</span>
<span class="s5">#            self._enter()</span>
<span class="s5">#            self._dispatch(t.orelse)</span>
<span class="s5">#            self._leave</span>
<span class="s5">#</span>
<span class="s5">#    def _While(self, t):</span>
<span class="s5">#        self._fill(&quot;while &quot;)</span>
<span class="s5">#        self._dispatch(t.test)</span>
<span class="s5">#        self._enter()</span>
<span class="s5">#        self._dispatch(t.body)</span>
<span class="s5">#        self._leave()</span>
<span class="s5">#        if t.orelse:</span>
<span class="s5">#            self._fill(&quot;else&quot;)</span>
<span class="s5">#            self._enter()</span>
<span class="s5">#            self._dispatch(t.orelse)</span>
<span class="s5">#            self._leave</span>
<span class="s5">#</span>
<span class="s5">#    # expr</span>
<span class="s5">#    def _Str(self, tree):</span>
<span class="s5">#        self._write(repr(tree.s))</span>
<span class="s5">##</span>
<span class="s5">#    def _Repr(self, t):</span>
<span class="s5">#        self._write(&quot;`&quot;)</span>
<span class="s5">#        self._dispatch(t.value)</span>
<span class="s5">#        self._write(&quot;`&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    def _Num(self, t):</span>
<span class="s5">#        self._write(repr(t.n))</span>
<span class="s5">#</span>
<span class="s5">#    def _ListComp(self, t):</span>
<span class="s5">#        self._write(&quot;[&quot;)</span>
<span class="s5">#        self._dispatch(t.elt)</span>
<span class="s5">#        for gen in t.generators:</span>
<span class="s5">#            self._dispatch(gen)</span>
<span class="s5">#        self._write(&quot;]&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    def _GeneratorExp(self, t):</span>
<span class="s5">#        self._write(&quot;(&quot;)</span>
<span class="s5">#        self._dispatch(t.elt)</span>
<span class="s5">#        for gen in t.generators:</span>
<span class="s5">#            self._dispatch(gen)</span>
<span class="s5">#        self._write(&quot;)&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    def _comprehension(self, t):</span>
<span class="s5">#        self._write(&quot; for &quot;)</span>
<span class="s5">#        self._dispatch(t.target)</span>
<span class="s5">#        self._write(&quot; in &quot;)</span>
<span class="s5">#        self._dispatch(t.iter)</span>
<span class="s5">#        for if_clause in t.ifs:</span>
<span class="s5">#            self._write(&quot; if &quot;)</span>
<span class="s5">#            self._dispatch(if_clause)</span>
<span class="s5">#</span>
<span class="s5">#    def _IfExp(self, t):</span>
<span class="s5">#        self._dispatch(t.body)</span>
<span class="s5">#        self._write(&quot; if &quot;)</span>
<span class="s5">#        self._dispatch(t.test)</span>
<span class="s5">#        if t.orelse:</span>
<span class="s5">#            self._write(&quot; else &quot;)</span>
<span class="s5">#            self._dispatch(t.orelse)</span>
<span class="s5">#</span>
<span class="s5">#    unop = {&quot;Invert&quot;:&quot;~&quot;, &quot;Not&quot;: &quot;not&quot;, &quot;UAdd&quot;:&quot;+&quot;, &quot;USub&quot;:&quot;-&quot;}</span>
<span class="s5">#    def _UnaryOp(self, t):</span>
<span class="s5">#        self._write(self.unop[t.op.__class__.__name__])</span>
<span class="s5">#        self._write(&quot;(&quot;)</span>
<span class="s5">#        self._dispatch(t.operand)</span>
<span class="s5">#        self._write(&quot;)&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    binop = { &quot;Add&quot;:&quot;+&quot;, &quot;Sub&quot;:&quot;-&quot;, &quot;Mult&quot;:&quot;*&quot;, &quot;Div&quot;:&quot;/&quot;, &quot;Mod&quot;:&quot;%&quot;,</span>
<span class="s5">#                    &quot;LShift&quot;:&quot;&gt;&gt;&quot;, &quot;RShift&quot;:&quot;&lt;&lt;&quot;, &quot;BitOr&quot;:&quot;|&quot;, &quot;BitXor&quot;:&quot;^&quot;, &quot;BitAnd&quot;:&quot;&amp;&quot;,</span>
<span class="s5">#                    &quot;FloorDiv&quot;:&quot;//&quot;, &quot;Pow&quot;: &quot;**&quot;}</span>
<span class="s5">#    def _BinOp(self, t):</span>
<span class="s5">#        self._write(&quot;(&quot;)</span>
<span class="s5">#        self._dispatch(t.left)</span>
<span class="s5">#        self._write(&quot;)&quot; + self.binop[t.op.__class__.__name__] + &quot;(&quot;)</span>
<span class="s5">#        self._dispatch(t.right)</span>
<span class="s5">#        self._write(&quot;)&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    boolops = {_ast.And: 'and', _ast.Or: 'or'}</span>
<span class="s5">#    def _BoolOp(self, t):</span>
<span class="s5">#        self._write(&quot;(&quot;)</span>
<span class="s5">#        self._dispatch(t.values[0])</span>
<span class="s5">#        for v in t.values[1:]:</span>
<span class="s5">#            self._write(&quot; %s &quot; % self.boolops[t.op.__class__])</span>
<span class="s5">#            self._dispatch(v)</span>
<span class="s5">#        self._write(&quot;)&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    def _Attribute(self,t):</span>
<span class="s5">#        self._dispatch(t.value)</span>
<span class="s5">#        self._write(&quot;.&quot;)</span>
<span class="s5">#        self._write(t.attr)</span>
<span class="s5">#</span>
<span class="s5">##    def _Call(self, t):</span>
<span class="s5">##        self._dispatch(t.func)</span>
<span class="s5">##        self._write(&quot;(&quot;)</span>
<span class="s5">##        comma = False</span>
<span class="s5">##        for e in t.args:</span>
<span class="s5">##            if comma: self._write(&quot;, &quot;)</span>
<span class="s5">##            else: comma = True</span>
<span class="s5">##            self._dispatch(e)</span>
<span class="s5">##        for e in t.keywords:</span>
<span class="s5">##            if comma: self._write(&quot;, &quot;)</span>
<span class="s5">##            else: comma = True</span>
<span class="s5">##            self._dispatch(e)</span>
<span class="s5">##        if t.starargs:</span>
<span class="s5">##            if comma: self._write(&quot;, &quot;)</span>
<span class="s5">##            else: comma = True</span>
<span class="s5">##            self._write(&quot;*&quot;)</span>
<span class="s5">##            self._dispatch(t.starargs)</span>
<span class="s5">##        if t.kwargs:</span>
<span class="s5">##            if comma: self._write(&quot;, &quot;)</span>
<span class="s5">##            else: comma = True</span>
<span class="s5">##            self._write(&quot;**&quot;)</span>
<span class="s5">##            self._dispatch(t.kwargs)</span>
<span class="s5">##        self._write(&quot;)&quot;)</span>
<span class="s5">#</span>
<span class="s5">#    # slice</span>
<span class="s5">#    def _Index(self, t):</span>
<span class="s5">#        self._dispatch(t.value)</span>
<span class="s5">#</span>
<span class="s5">#    def _ExtSlice(self, t):</span>
<span class="s5">#        for i, d in enumerate(t.dims):</span>
<span class="s5">#            if i != 0:</span>
<span class="s5">#                self._write(': ')</span>
<span class="s5">#            self._dispatch(d)</span>
<span class="s5">#</span>
<span class="s5">#    # others</span>
<span class="s5">#    def _arguments(self, t):</span>
<span class="s5">#        first = True</span>
<span class="s5">#        nonDef = len(t.args)-len(t.defaults)</span>
<span class="s5">#        for a in t.args[0:nonDef]:</span>
<span class="s5">#            if first:first = False</span>
<span class="s5">#            else: self._write(&quot;, &quot;)</span>
<span class="s5">#            self._dispatch(a)</span>
<span class="s5">#        for a,d in zip(t.args[nonDef:], t.defaults):</span>
<span class="s5">#            if first:first = False</span>
<span class="s5">#            else: self._write(&quot;, &quot;)</span>
<span class="s5">#            self._dispatch(a),</span>
<span class="s5">#            self._write(&quot;=&quot;)</span>
<span class="s5">#            self._dispatch(d)</span>
<span class="s5">#        if t.vararg:</span>
<span class="s5">#            if first:first = False</span>
<span class="s5">#            else: self._write(&quot;, &quot;)</span>
<span class="s5">#            self._write(&quot;*&quot;+t.vararg)</span>
<span class="s5">#        if t.kwarg:</span>
<span class="s5">#            if first:first = False</span>
<span class="s5">#            else: self._write(&quot;, &quot;)</span>
<span class="s5">#            self._write(&quot;**&quot;+t.kwarg)</span>
<span class="s5">#</span>
<span class="s5">##    def _keyword(self, t):</span>
<span class="s5">##        self._write(t.arg)</span>
<span class="s5">##        self._write(&quot;=&quot;)</span>
<span class="s5">##        self._dispatch(t.value)</span>
<span class="s5">#</span>
<span class="s5">#    def _Lambda(self, t):</span>
<span class="s5">#        self._write(&quot;lambda &quot;)</span>
<span class="s5">#        self._dispatch(t.args)</span>
<span class="s5">#        self._write(&quot;: &quot;)</span>
<span class="s5">#        self._dispatch(t.body)</span>



</pre>
</body>
</html>