<html>
<head>
<title>_resampling.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_resampling.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">combinations</span><span class="s0">, </span><span class="s1">permutations</span><span class="s0">, </span><span class="s1">product</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">import </span><span class="s1">inspect</span>

<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">check_random_state</span><span class="s0">, </span><span class="s1">_rename_parameter</span>
<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">ndtr</span><span class="s0">, </span><span class="s1">ndtri</span><span class="s0">, </span><span class="s1">comb</span><span class="s0">, </span><span class="s1">factorial</span>
<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">rng_integers</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span>
<span class="s0">from </span><span class="s1">._common </span><span class="s0">import </span><span class="s1">ConfidenceInterval</span>
<span class="s0">from </span><span class="s1">._axis_nan_policy </span><span class="s0">import </span><span class="s1">_broadcast_concatenate</span><span class="s0">, </span><span class="s1">_broadcast_arrays</span>
<span class="s0">from </span><span class="s1">._warnings_errors </span><span class="s0">import </span><span class="s1">DegenerateDataWarning</span>

<span class="s1">__all__ = [</span><span class="s2">'bootstrap'</span><span class="s0">, </span><span class="s2">'monte_carlo_test'</span><span class="s0">, </span><span class="s2">'permutation_test'</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_vectorize_statistic(statistic):</span>
    <span class="s3">&quot;&quot;&quot;Vectorize an n-sample statistic&quot;&quot;&quot;</span>
    <span class="s4"># This is a little cleaner than np.nditer at the expense of some data</span>
    <span class="s4"># copying: concatenate samples together, then use np.apply_along_axis</span>
    <span class="s0">def </span><span class="s1">stat_nd(*data</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">lengths = [sample.shape[axis] </span><span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data]</span>
        <span class="s1">split_indices = np.cumsum(lengths)[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">z = _broadcast_concatenate(data</span><span class="s0">, </span><span class="s1">axis)</span>

        <span class="s4"># move working axis to position 0 so that new dimensions in the output</span>
        <span class="s4"># of `statistic` are _prepended_. (&quot;This axis is removed, and replaced</span>
        <span class="s4"># with new dimensions...&quot;)</span>
        <span class="s1">z = np.moveaxis(z</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">stat_1d(z):</span>
            <span class="s1">data = np.split(z</span><span class="s0">, </span><span class="s1">split_indices)</span>
            <span class="s0">return </span><span class="s1">statistic(*data)</span>

        <span class="s0">return </span><span class="s1">np.apply_along_axis(stat_1d</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">z)[()]</span>
    <span class="s0">return </span><span class="s1">stat_nd</span>


<span class="s0">def </span><span class="s1">_jackknife_resample(sample</span><span class="s0">, </span><span class="s1">batch=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Jackknife resample the sample. Only one-sample stats for now.&quot;&quot;&quot;</span>
    <span class="s1">n = sample.shape[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">batch_nominal = batch </span><span class="s0">or </span><span class="s1">n</span>

    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">batch_nominal):</span>
        <span class="s4"># col_start:col_end are the observations to remove</span>
        <span class="s1">batch_actual = min(batch_nominal</span><span class="s0">, </span><span class="s1">n-k)</span>

        <span class="s4"># jackknife - each row leaves out one observation</span>
        <span class="s1">j = np.ones((batch_actual</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">np.fill_diagonal(j[:</span><span class="s0">, </span><span class="s1">k:k+batch_actual]</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">i = np.arange(n)</span>
        <span class="s1">i = np.broadcast_to(i</span><span class="s0">, </span><span class="s1">(batch_actual</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">i = i[j].reshape((batch_actual</span><span class="s0">, </span><span class="s1">n-</span><span class="s5">1</span><span class="s1">))</span>

        <span class="s1">resamples = sample[...</span><span class="s0">, </span><span class="s1">i]</span>
        <span class="s0">yield </span><span class="s1">resamples</span>


<span class="s0">def </span><span class="s1">_bootstrap_resample(sample</span><span class="s0">, </span><span class="s1">n_resamples=</span><span class="s0">None, </span><span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Bootstrap resample the sample.&quot;&quot;&quot;</span>
    <span class="s1">n = sample.shape[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s4"># bootstrap - each row is a random resample of original observations</span>
    <span class="s1">i = rng_integers(random_state</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">(n_resamples</span><span class="s0">, </span><span class="s1">n))</span>

    <span class="s1">resamples = sample[...</span><span class="s0">, </span><span class="s1">i]</span>
    <span class="s0">return </span><span class="s1">resamples</span>


<span class="s0">def </span><span class="s1">_percentile_of_score(a</span><span class="s0">, </span><span class="s1">score</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s3">&quot;&quot;&quot;Vectorized, simplified `scipy.stats.percentileofscore`. 
    Uses logic of the 'mean' value of percentileofscore's kind parameter. 
 
    Unlike `stats.percentileofscore`, the percentile returned is a fraction 
    in [0, 1]. 
    &quot;&quot;&quot;</span>
    <span class="s1">B = a.shape[axis]</span>
    <span class="s0">return </span><span class="s1">((a &lt; score).sum(axis=axis) + (a &lt;= score).sum(axis=axis)) / (</span><span class="s5">2 </span><span class="s1">* B)</span>


<span class="s0">def </span><span class="s1">_percentile_along_axis(theta_hat_b</span><span class="s0">, </span><span class="s1">alpha):</span>
    <span class="s3">&quot;&quot;&quot;`np.percentile` with different percentile for each slice.&quot;&quot;&quot;</span>
    <span class="s4"># the difference between _percentile_along_axis and np.percentile is that</span>
    <span class="s4"># np.percentile gets _all_ the qs for each axis slice, whereas</span>
    <span class="s4"># _percentile_along_axis gets the q corresponding with each axis slice</span>
    <span class="s1">shape = theta_hat_b.shape[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">alpha = np.broadcast_to(alpha</span><span class="s0">, </span><span class="s1">shape)</span>
    <span class="s1">percentiles = np.zeros_like(alpha</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s0">for </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">alpha_i </span><span class="s0">in </span><span class="s1">np.ndenumerate(alpha):</span>
        <span class="s0">if </span><span class="s1">np.isnan(alpha_i):</span>
            <span class="s4"># e.g. when bootstrap distribution has only one unique element</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;The BCa confidence interval cannot be calculated.&quot;</span>
                <span class="s2">&quot; This problem is known to occur when the distribution&quot;</span>
                <span class="s2">&quot; is degenerate or the statistic is np.min.&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(DegenerateDataWarning(msg))</span>
            <span class="s1">percentiles[indices] = np.nan</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">theta_hat_b_i = theta_hat_b[indices]</span>
            <span class="s1">percentiles[indices] = np.percentile(theta_hat_b_i</span><span class="s0">, </span><span class="s1">alpha_i)</span>
    <span class="s0">return </span><span class="s1">percentiles[()]  </span><span class="s4"># return scalar instead of 0d array</span>


<span class="s0">def </span><span class="s1">_bca_interval(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">theta_hat_b</span><span class="s0">, </span><span class="s1">batch):</span>
    <span class="s3">&quot;&quot;&quot;Bias-corrected and accelerated interval.&quot;&quot;&quot;</span>
    <span class="s4"># closely follows [1] 14.3 and 15.4 (Eq. 15.36)</span>

    <span class="s4"># calculate z0_hat</span>
    <span class="s1">theta_hat = np.asarray(statistic(*data</span><span class="s0">, </span><span class="s1">axis=axis))[...</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s1">percentile = _percentile_of_score(theta_hat_b</span><span class="s0">, </span><span class="s1">theta_hat</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">z0_hat = ndtri(percentile)</span>

    <span class="s4"># calculate a_hat</span>
    <span class="s1">theta_hat_ji = []  </span><span class="s4"># j is for sample of data, i is for jackknife resample</span>
    <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">enumerate(data):</span>
        <span class="s4"># _jackknife_resample will add an axis prior to the last axis that</span>
        <span class="s4"># corresponds with the different jackknife resamples. Do the same for</span>
        <span class="s4"># each sample of the data to ensure broadcastability. We need to</span>
        <span class="s4"># create a copy of the list containing the samples anyway, so do this</span>
        <span class="s4"># in the loop to simplify the code. This is not the bottleneck...</span>
        <span class="s1">samples = [np.expand_dims(sample</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">) </span><span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data]</span>
        <span class="s1">theta_hat_i = []</span>
        <span class="s0">for </span><span class="s1">jackknife_sample </span><span class="s0">in </span><span class="s1">_jackknife_resample(sample</span><span class="s0">, </span><span class="s1">batch):</span>
            <span class="s1">samples[j] = jackknife_sample</span>
            <span class="s1">broadcasted = _broadcast_arrays(samples</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">theta_hat_i.append(statistic(*broadcasted</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">theta_hat_ji.append(theta_hat_i)</span>

    <span class="s1">theta_hat_ji = [np.concatenate(theta_hat_i</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s0">for </span><span class="s1">theta_hat_i </span><span class="s0">in </span><span class="s1">theta_hat_ji]</span>

    <span class="s1">n_j = [theta_hat_i.shape[-</span><span class="s5">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">theta_hat_i </span><span class="s0">in </span><span class="s1">theta_hat_ji]</span>

    <span class="s1">theta_hat_j_dot = [theta_hat_i.mean(axis=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
                       <span class="s0">for </span><span class="s1">theta_hat_i </span><span class="s0">in </span><span class="s1">theta_hat_ji]</span>

    <span class="s1">U_ji = [(n - </span><span class="s5">1</span><span class="s1">) * (theta_hat_dot - theta_hat_i)</span>
            <span class="s0">for </span><span class="s1">theta_hat_dot</span><span class="s0">, </span><span class="s1">theta_hat_i</span><span class="s0">, </span><span class="s1">n</span>
            <span class="s0">in </span><span class="s1">zip(theta_hat_j_dot</span><span class="s0">, </span><span class="s1">theta_hat_ji</span><span class="s0">, </span><span class="s1">n_j)]</span>

    <span class="s1">nums = [(U_i**</span><span class="s5">3</span><span class="s1">).sum(axis=-</span><span class="s5">1</span><span class="s1">)/n**</span><span class="s5">3 </span><span class="s0">for </span><span class="s1">U_i</span><span class="s0">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">zip(U_ji</span><span class="s0">, </span><span class="s1">n_j)]</span>
    <span class="s1">dens = [(U_i**</span><span class="s5">2</span><span class="s1">).sum(axis=-</span><span class="s5">1</span><span class="s1">)/n**</span><span class="s5">2 </span><span class="s0">for </span><span class="s1">U_i</span><span class="s0">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">zip(U_ji</span><span class="s0">, </span><span class="s1">n_j)]</span>
    <span class="s1">a_hat = </span><span class="s5">1</span><span class="s1">/</span><span class="s5">6 </span><span class="s1">* sum(nums) / sum(dens)**(</span><span class="s5">3</span><span class="s1">/</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s4"># calculate alpha_1, alpha_2</span>
    <span class="s1">z_alpha = ndtri(alpha)</span>
    <span class="s1">z_1alpha = -z_alpha</span>
    <span class="s1">num1 = z0_hat + z_alpha</span>
    <span class="s1">alpha_1 = ndtr(z0_hat + num1/(</span><span class="s5">1 </span><span class="s1">- a_hat*num1))</span>
    <span class="s1">num2 = z0_hat + z_1alpha</span>
    <span class="s1">alpha_2 = ndtr(z0_hat + num2/(</span><span class="s5">1 </span><span class="s1">- a_hat*num2))</span>
    <span class="s0">return </span><span class="s1">alpha_1</span><span class="s0">, </span><span class="s1">alpha_2</span><span class="s0">, </span><span class="s1">a_hat  </span><span class="s4"># return a_hat for testing</span>


<span class="s0">def </span><span class="s1">_bootstrap_iv(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">, </span><span class="s1">paired</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">confidence_level</span><span class="s0">,</span>
                  <span class="s1">alternative</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">bootstrap_result</span><span class="s0">,</span>
                  <span class="s1">random_state):</span>
    <span class="s3">&quot;&quot;&quot;Input validation and standardization for `bootstrap`.&quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">vectorized </span><span class="s0">not in </span><span class="s1">{</span><span class="s0">True, False, None</span><span class="s1">}:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`vectorized` must be `True`, `False`, or `None`.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">vectorized </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">vectorized = </span><span class="s2">'axis' </span><span class="s0">in </span><span class="s1">inspect.signature(statistic).parameters</span>

    <span class="s0">if not </span><span class="s1">vectorized:</span>
        <span class="s1">statistic = _vectorize_statistic(statistic)</span>

    <span class="s1">axis_int = int(axis)</span>
    <span class="s0">if </span><span class="s1">axis != axis_int:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`axis` must be an integer.&quot;</span><span class="s1">)</span>

    <span class="s1">n_samples = </span><span class="s5">0</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">n_samples = len(data)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`data` must be a sequence of samples.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">n_samples == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`data` must contain at least one sample.&quot;</span><span class="s1">)</span>

    <span class="s1">data_iv = []</span>
    <span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data:</span>
        <span class="s1">sample = np.atleast_1d(sample)</span>
        <span class="s0">if </span><span class="s1">sample.shape[axis_int] &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;each sample in `data` must contain two or more &quot;</span>
                             <span class="s2">&quot;observations along `axis`.&quot;</span><span class="s1">)</span>
        <span class="s1">sample = np.moveaxis(sample</span><span class="s0">, </span><span class="s1">axis_int</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">data_iv.append(sample)</span>

    <span class="s0">if </span><span class="s1">paired </span><span class="s0">not in </span><span class="s1">{</span><span class="s0">True, False</span><span class="s1">}:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`paired` must be `True` or `False`.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">paired:</span>
        <span class="s1">n = data_iv[</span><span class="s5">0</span><span class="s1">].shape[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data_iv[</span><span class="s5">1</span><span class="s1">:]:</span>
            <span class="s0">if </span><span class="s1">sample.shape[-</span><span class="s5">1</span><span class="s1">] != n:</span>
                <span class="s1">message = (</span><span class="s2">&quot;When `paired is True`, all samples must have the &quot;</span>
                           <span class="s2">&quot;same length along `axis`&quot;</span><span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">ValueError(message)</span>

        <span class="s4"># to generate the bootstrap distribution for paired-sample statistics,</span>
        <span class="s4"># resample the indices of the observations</span>
        <span class="s0">def </span><span class="s1">statistic(i</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">data=data_iv</span><span class="s0">, </span><span class="s1">unpaired_statistic=statistic):</span>
            <span class="s1">data = [sample[...</span><span class="s0">, </span><span class="s1">i] </span><span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data]</span>
            <span class="s0">return </span><span class="s1">unpaired_statistic(*data</span><span class="s0">, </span><span class="s1">axis=axis)</span>

        <span class="s1">data_iv = [np.arange(n)]</span>

    <span class="s1">confidence_level_float = float(confidence_level)</span>

    <span class="s1">alternative = alternative.lower()</span>
    <span class="s1">alternatives = {</span><span class="s2">'two-sided'</span><span class="s0">, </span><span class="s2">'less'</span><span class="s0">, </span><span class="s2">'greater'</span><span class="s1">}</span>
    <span class="s0">if </span><span class="s1">alternative </span><span class="s0">not in </span><span class="s1">alternatives:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;`alternative` must be one of </span><span class="s0">{</span><span class="s1">alternatives</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s1">n_resamples_int = int(n_resamples)</span>
    <span class="s0">if </span><span class="s1">n_resamples != n_resamples_int </span><span class="s0">or </span><span class="s1">n_resamples_int &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`n_resamples` must be a non-negative integer.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">batch </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">batch_iv = batch</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">batch_iv = int(batch)</span>
        <span class="s0">if </span><span class="s1">batch != batch_iv </span><span class="s0">or </span><span class="s1">batch_iv &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`batch` must be a positive integer or None.&quot;</span><span class="s1">)</span>

    <span class="s1">methods = {</span><span class="s2">'percentile'</span><span class="s0">, </span><span class="s2">'basic'</span><span class="s0">, </span><span class="s2">'bca'</span><span class="s1">}</span>
    <span class="s1">method = method.lower()</span>
    <span class="s0">if </span><span class="s1">method </span><span class="s0">not in </span><span class="s1">methods:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;`method` must be in </span><span class="s0">{</span><span class="s1">methods</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s1">message = </span><span class="s2">&quot;`bootstrap_result` must have attribute `bootstrap_distribution'&quot;</span>
    <span class="s0">if </span><span class="s1">(bootstrap_result </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">hasattr(bootstrap_result</span><span class="s0">, </span><span class="s2">&quot;bootstrap_distribution&quot;</span><span class="s1">)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(message)</span>

    <span class="s1">message = (</span><span class="s2">&quot;Either `bootstrap_result.bootstrap_distribution.size` or &quot;</span>
               <span class="s2">&quot;`n_resamples` must be positive.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">((</span><span class="s0">not </span><span class="s1">bootstrap_result </span><span class="s0">or</span>
         <span class="s0">not </span><span class="s1">bootstrap_result.bootstrap_distribution.size)</span>
            <span class="s0">and </span><span class="s1">n_resamples_int == </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(message)</span>

    <span class="s1">random_state = check_random_state(random_state)</span>

    <span class="s0">return </span><span class="s1">(data_iv</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">, </span><span class="s1">paired</span><span class="s0">, </span><span class="s1">axis_int</span><span class="s0">,</span>
            <span class="s1">confidence_level_float</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">n_resamples_int</span><span class="s0">, </span><span class="s1">batch_iv</span><span class="s0">,</span>
            <span class="s1">method</span><span class="s0">, </span><span class="s1">bootstrap_result</span><span class="s0">, </span><span class="s1">random_state)</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">BootstrapResult:</span>
    <span class="s3">&quot;&quot;&quot;Result object returned by `scipy.stats.bootstrap`. 
 
    Attributes 
    ---------- 
    confidence_interval : ConfidenceInterval 
        The bootstrap confidence interval as an instance of 
        `collections.namedtuple` with attributes `low` and `high`. 
    bootstrap_distribution : ndarray 
        The bootstrap distribution, that is, the value of `statistic` for 
        each resample. The last dimension corresponds with the resamples 
        (e.g. ``res.bootstrap_distribution.shape[-1] == n_resamples``). 
    standard_error : float or ndarray 
        The bootstrap standard error, that is, the sample standard 
        deviation of the bootstrap distribution. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">confidence_interval: ConfidenceInterval</span>
    <span class="s1">bootstrap_distribution: np.ndarray</span>
    <span class="s1">standard_error: float | np.ndarray</span>


<span class="s0">def </span><span class="s1">bootstrap(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">n_resamples=</span><span class="s5">9999</span><span class="s0">, </span><span class="s1">batch=</span><span class="s0">None,</span>
              <span class="s1">vectorized=</span><span class="s0">None, </span><span class="s1">paired=</span><span class="s0">False, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">confidence_level=</span><span class="s5">0.95</span><span class="s0">,</span>
              <span class="s1">alternative=</span><span class="s2">'two-sided'</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">'BCa'</span><span class="s0">, </span><span class="s1">bootstrap_result=</span><span class="s0">None,</span>
              <span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Compute a two-sided bootstrap confidence interval of a statistic. 
 
    When `method` is ``'percentile'`` and `alternative` is ``'two-sided'``, 
    a bootstrap confidence interval is computed according to the following 
    procedure. 
 
    1. Resample the data: for each sample in `data` and for each of 
       `n_resamples`, take a random sample of the original sample 
       (with replacement) of the same size as the original sample. 
 
    2. Compute the bootstrap distribution of the statistic: for each set of 
       resamples, compute the test statistic. 
 
    3. Determine the confidence interval: find the interval of the bootstrap 
       distribution that is 
 
       - symmetric about the median and 
       - contains `confidence_level` of the resampled statistic values. 
 
    While the ``'percentile'`` method is the most intuitive, it is rarely 
    used in practice. Two more common methods are available, ``'basic'`` 
    ('reverse percentile') and ``'BCa'`` ('bias-corrected and accelerated'); 
    they differ in how step 3 is performed. 
 
    If the samples in `data` are  taken at random from their respective 
    distributions :math:`n` times, the confidence interval returned by 
    `bootstrap` will contain the true value of the statistic for those 
    distributions approximately `confidence_level`:math:`\, \times \, n` times. 
 
    Parameters 
    ---------- 
    data : sequence of array-like 
         Each element of data is a sample from an underlying distribution. 
    statistic : callable 
        Statistic for which the confidence interval is to be calculated. 
        `statistic` must be a callable that accepts ``len(data)`` samples 
        as separate arguments and returns the resulting statistic. 
        If `vectorized` is set ``True``, 
        `statistic` must also accept a keyword argument `axis` and be 
        vectorized to compute the statistic along the provided `axis`. 
    n_resamples : int, default: ``9999`` 
        The number of resamples performed to form the bootstrap distribution 
        of the statistic. 
    batch : int, optional 
        The number of resamples to process in each vectorized call to 
        `statistic`. Memory usage is O(`batch`*``n``), where ``n`` is the 
        sample size. Default is ``None``, in which case ``batch = n_resamples`` 
        (or ``batch = max(n_resamples, n)`` for ``method='BCa'``). 
    vectorized : bool, optional 
        If `vectorized` is set ``False``, `statistic` will not be passed 
        keyword argument `axis` and is expected to calculate the statistic 
        only for 1D samples. If ``True``, `statistic` will be passed keyword 
        argument `axis` and is expected to calculate the statistic along `axis` 
        when passed an ND sample array. If ``None`` (default), `vectorized` 
        will be set ``True`` if ``axis`` is a parameter of `statistic`. Use of 
        a vectorized statistic typically reduces computation time. 
    paired : bool, default: ``False`` 
        Whether the statistic treats corresponding elements of the samples 
        in `data` as paired. 
    axis : int, default: ``0`` 
        The axis of the samples in `data` along which the `statistic` is 
        calculated. 
    confidence_level : float, default: ``0.95`` 
        The confidence level of the confidence interval. 
    alternative : {'two-sided', 'less', 'greater'}, default: ``'two-sided'`` 
        Choose ``'two-sided'`` (default) for a two-sided confidence interval, 
        ``'less'`` for a one-sided confidence interval with the lower bound 
        at ``-np.inf``, and ``'greater'`` for a one-sided confidence interval 
        with the upper bound at ``np.inf``. The other bound of the one-sided 
        confidence intervals is the same as that of a two-sided confidence 
        interval with `confidence_level` twice as far from 1.0; e.g. the upper 
        bound of a 95% ``'less'``  confidence interval is the same as the upper 
        bound of a 90% ``'two-sided'`` confidence interval. 
    method : {'percentile', 'basic', 'bca'}, default: ``'BCa'`` 
        Whether to return the 'percentile' bootstrap confidence interval 
        (``'percentile'``), the 'basic' (AKA 'reverse') bootstrap confidence 
        interval (``'basic'``), or the bias-corrected and accelerated bootstrap 
        confidence interval (``'BCa'``). 
    bootstrap_result : BootstrapResult, optional 
        Provide the result object returned by a previous call to `bootstrap` 
        to include the previous bootstrap distribution in the new bootstrap 
        distribution. This can be used, for example, to change 
        `confidence_level`, change `method`, or see the effect of performing 
        additional resampling without repeating computations. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        Pseudorandom number generator state used to generate resamples. 
 
        If `random_state` is ``None`` (or `np.random`), the 
        `numpy.random.RandomState` singleton is used. 
        If `random_state` is an int, a new ``RandomState`` instance is used, 
        seeded with `random_state`. 
        If `random_state` is already a ``Generator`` or ``RandomState`` 
        instance then that instance is used. 
 
    Returns 
    ------- 
    res : BootstrapResult 
        An object with attributes: 
 
        confidence_interval : ConfidenceInterval 
            The bootstrap confidence interval as an instance of 
            `collections.namedtuple` with attributes `low` and `high`. 
        bootstrap_distribution : ndarray 
            The bootstrap distribution, that is, the value of `statistic` for 
            each resample. The last dimension corresponds with the resamples 
            (e.g. ``res.bootstrap_distribution.shape[-1] == n_resamples``). 
        standard_error : float or ndarray 
            The bootstrap standard error, that is, the sample standard 
            deviation of the bootstrap distribution. 
 
    Warns 
    ----- 
    `~scipy.stats.DegenerateDataWarning` 
        Generated when ``method='BCa'`` and the bootstrap distribution is 
        degenerate (e.g. all elements are identical). 
 
    Notes 
    ----- 
    Elements of the confidence interval may be NaN for ``method='BCa'`` if 
    the bootstrap distribution is degenerate (e.g. all elements are identical). 
    In this case, consider using another `method` or inspecting `data` for 
    indications that other analysis may be more appropriate (e.g. all 
    observations are identical). 
 
    References 
    ---------- 
    .. [1] B. Efron and R. J. Tibshirani, An Introduction to the Bootstrap, 
       Chapman &amp; Hall/CRC, Boca Raton, FL, USA (1993) 
    .. [2] Nathaniel E. Helwig, &quot;Bootstrap Confidence Intervals&quot;, 
       http://users.stat.umn.edu/~helwig/notes/bootci-Notes.pdf 
    .. [3] Bootstrapping (statistics), Wikipedia, 
       https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29 
 
    Examples 
    -------- 
    Suppose we have sampled data from an unknown distribution. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; from scipy.stats import norm 
    &gt;&gt;&gt; dist = norm(loc=2, scale=4)  # our &quot;unknown&quot; distribution 
    &gt;&gt;&gt; data = dist.rvs(size=100, random_state=rng) 
 
    We are interested in the standard deviation of the distribution. 
 
    &gt;&gt;&gt; std_true = dist.std()      # the true value of the statistic 
    &gt;&gt;&gt; print(std_true) 
    4.0 
    &gt;&gt;&gt; std_sample = np.std(data)  # the sample statistic 
    &gt;&gt;&gt; print(std_sample) 
    3.9460644295563863 
 
    The bootstrap is used to approximate the variability we would expect if we 
    were to repeatedly sample from the unknown distribution and calculate the 
    statistic of the sample each time. It does this by repeatedly resampling 
    values *from the original sample* with replacement and calculating the 
    statistic of each resample. This results in a &quot;bootstrap distribution&quot; of 
    the statistic. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.stats import bootstrap 
    &gt;&gt;&gt; data = (data,)  # samples must be in a sequence 
    &gt;&gt;&gt; res = bootstrap(data, np.std, confidence_level=0.9, 
    ...                 random_state=rng) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hist(res.bootstrap_distribution, bins=25) 
    &gt;&gt;&gt; ax.set_title('Bootstrap Distribution') 
    &gt;&gt;&gt; ax.set_xlabel('statistic value') 
    &gt;&gt;&gt; ax.set_ylabel('frequency') 
    &gt;&gt;&gt; plt.show() 
 
    The standard error quantifies this variability. It is calculated as the 
    standard deviation of the bootstrap distribution. 
 
    &gt;&gt;&gt; res.standard_error 
    0.24427002125829136 
    &gt;&gt;&gt; res.standard_error == np.std(res.bootstrap_distribution, ddof=1) 
    True 
 
    The bootstrap distribution of the statistic is often approximately normal 
    with scale equal to the standard error. 
 
    &gt;&gt;&gt; x = np.linspace(3, 5) 
    &gt;&gt;&gt; pdf = norm.pdf(x, loc=std_sample, scale=res.standard_error) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hist(res.bootstrap_distribution, bins=25, density=True) 
    &gt;&gt;&gt; ax.plot(x, pdf) 
    &gt;&gt;&gt; ax.set_title('Normal Approximation of the Bootstrap Distribution') 
    &gt;&gt;&gt; ax.set_xlabel('statistic value') 
    &gt;&gt;&gt; ax.set_ylabel('pdf') 
    &gt;&gt;&gt; plt.show() 
 
    This suggests that we could construct a 90% confidence interval on the 
    statistic based on quantiles of this normal distribution. 
 
    &gt;&gt;&gt; norm.interval(0.9, loc=std_sample, scale=res.standard_error) 
    (3.5442759991341726, 4.3478528599786) 
 
    Due to central limit theorem, this normal approximation is accurate for a 
    variety of statistics and distributions underlying the samples; however, 
    the approximation is not reliable in all cases. Because `bootstrap` is 
    designed to work with arbitrary underlying distributions and statistics, 
    it uses more advanced techniques to generate an accurate confidence 
    interval. 
 
    &gt;&gt;&gt; print(res.confidence_interval) 
    ConfidenceInterval(low=3.57655333533867, high=4.382043696342881) 
 
    If we sample from the original distribution 1000 times and form a bootstrap 
    confidence interval for each sample, the confidence interval 
    contains the true value of the statistic approximately 90% of the time. 
 
    &gt;&gt;&gt; n_trials = 1000 
    &gt;&gt;&gt; ci_contains_true_std = 0 
    &gt;&gt;&gt; for i in range(n_trials): 
    ...    data = (dist.rvs(size=100, random_state=rng),) 
    ...    ci = bootstrap(data, np.std, confidence_level=0.9, n_resamples=1000, 
    ...                   random_state=rng).confidence_interval 
    ...    if ci[0] &lt; std_true &lt; ci[1]: 
    ...        ci_contains_true_std += 1 
    &gt;&gt;&gt; print(ci_contains_true_std) 
    875 
 
    Rather than writing a loop, we can also determine the confidence intervals 
    for all 1000 samples at once. 
 
    &gt;&gt;&gt; data = (dist.rvs(size=(n_trials, 100), random_state=rng),) 
    &gt;&gt;&gt; res = bootstrap(data, np.std, axis=-1, confidence_level=0.9, 
    ...                 n_resamples=1000, random_state=rng) 
    &gt;&gt;&gt; ci_l, ci_u = res.confidence_interval 
 
    Here, `ci_l` and `ci_u` contain the confidence interval for each of the 
    ``n_trials = 1000`` samples. 
 
    &gt;&gt;&gt; print(ci_l[995:]) 
    [3.77729695 3.75090233 3.45829131 3.34078217 3.48072829] 
    &gt;&gt;&gt; print(ci_u[995:]) 
    [4.88316666 4.86924034 4.32032996 4.2822427  4.59360598] 
 
    And again, approximately 90% contain the true value, ``std_true = 4``. 
 
    &gt;&gt;&gt; print(np.sum((ci_l &lt; std_true) &amp; (std_true &lt; ci_u))) 
    900 
 
    `bootstrap` can also be used to estimate confidence intervals of 
    multi-sample statistics, including those calculated by hypothesis 
    tests. `scipy.stats.mood` perform's Mood's test for equal scale parameters, 
    and it returns two outputs: a statistic, and a p-value. To get a 
    confidence interval for the test statistic, we first wrap 
    `scipy.stats.mood` in a function that accepts two sample arguments, 
    accepts an `axis` keyword argument, and returns only the statistic. 
 
    &gt;&gt;&gt; from scipy.stats import mood 
    &gt;&gt;&gt; def my_statistic(sample1, sample2, axis): 
    ...     statistic, _ = mood(sample1, sample2, axis=-1) 
    ...     return statistic 
 
    Here, we use the 'percentile' method with the default 95% confidence level. 
 
    &gt;&gt;&gt; sample1 = norm.rvs(scale=1, size=100, random_state=rng) 
    &gt;&gt;&gt; sample2 = norm.rvs(scale=2, size=100, random_state=rng) 
    &gt;&gt;&gt; data = (sample1, sample2) 
    &gt;&gt;&gt; res = bootstrap(data, my_statistic, method='basic', random_state=rng) 
    &gt;&gt;&gt; print(mood(sample1, sample2)[0])  # element 0 is the statistic 
    -5.521109549096542 
    &gt;&gt;&gt; print(res.confidence_interval) 
    ConfidenceInterval(low=-7.255994487314675, high=-4.016202624747605) 
 
    The bootstrap estimate of the standard error is also available. 
 
    &gt;&gt;&gt; print(res.standard_error) 
    0.8344963846318795 
 
    Paired-sample statistics work, too. For example, consider the Pearson 
    correlation coefficient. 
 
    &gt;&gt;&gt; from scipy.stats import pearsonr 
    &gt;&gt;&gt; n = 100 
    &gt;&gt;&gt; x = np.linspace(0, 10, n) 
    &gt;&gt;&gt; y = x + rng.uniform(size=n) 
    &gt;&gt;&gt; print(pearsonr(x, y)[0])  # element 0 is the statistic 
    0.9962357936065914 
 
    We wrap `pearsonr` so that it returns only the statistic. 
 
    &gt;&gt;&gt; def my_statistic(x, y): 
    ...     return pearsonr(x, y)[0] 
 
    We call `bootstrap` using ``paired=True``. 
    Also, since ``my_statistic`` isn't vectorized to calculate the statistic 
    along a given axis, we pass in ``vectorized=False``. 
 
    &gt;&gt;&gt; res = bootstrap((x, y), my_statistic, vectorized=False, paired=True, 
    ...                 random_state=rng) 
    &gt;&gt;&gt; print(res.confidence_interval) 
    ConfidenceInterval(low=0.9950085825848624, high=0.9971212407917498) 
 
    The result object can be passed back into `bootstrap` to perform additional 
    resampling: 
 
    &gt;&gt;&gt; len(res.bootstrap_distribution) 
    9999 
    &gt;&gt;&gt; res = bootstrap((x, y), my_statistic, vectorized=False, paired=True, 
    ...                 n_resamples=1001, random_state=rng, 
    ...                 bootstrap_result=res) 
    &gt;&gt;&gt; len(res.bootstrap_distribution) 
    11000 
 
    or to change the confidence interval options: 
 
    &gt;&gt;&gt; res2 = bootstrap((x, y), my_statistic, vectorized=False, paired=True, 
    ...                  n_resamples=0, random_state=rng, bootstrap_result=res, 
    ...                  method='percentile', confidence_level=0.9) 
    &gt;&gt;&gt; np.testing.assert_equal(res2.bootstrap_distribution, 
    ...                         res.bootstrap_distribution) 
    &gt;&gt;&gt; res.confidence_interval 
    ConfidenceInterval(low=0.9950035351407804, high=0.9971170323404578) 
 
    without repeating computation of the original bootstrap distribution. 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># Input validation</span>
    <span class="s1">args = _bootstrap_iv(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">, </span><span class="s1">paired</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">,</span>
                         <span class="s1">confidence_level</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">,</span>
                         <span class="s1">method</span><span class="s0">, </span><span class="s1">bootstrap_result</span><span class="s0">, </span><span class="s1">random_state)</span>
    <span class="s1">(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">, </span><span class="s1">paired</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">confidence_level</span><span class="s0">,</span>
     <span class="s1">alternative</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">bootstrap_result</span><span class="s0">,</span>
     <span class="s1">random_state) = args</span>

    <span class="s1">theta_hat_b = ([] </span><span class="s0">if </span><span class="s1">bootstrap_result </span><span class="s0">is None</span>
                   <span class="s0">else </span><span class="s1">[bootstrap_result.bootstrap_distribution])</span>

    <span class="s1">batch_nominal = batch </span><span class="s0">or </span><span class="s1">n_resamples </span><span class="s0">or </span><span class="s5">1</span>

    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch_nominal):</span>
        <span class="s1">batch_actual = min(batch_nominal</span><span class="s0">, </span><span class="s1">n_resamples-k)</span>
        <span class="s4"># Generate resamples</span>
        <span class="s1">resampled_data = []</span>
        <span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data:</span>
            <span class="s1">resample = _bootstrap_resample(sample</span><span class="s0">, </span><span class="s1">n_resamples=batch_actual</span><span class="s0">,</span>
                                           <span class="s1">random_state=random_state)</span>
            <span class="s1">resampled_data.append(resample)</span>

        <span class="s4"># Compute bootstrap distribution of statistic</span>
        <span class="s1">theta_hat_b.append(statistic(*resampled_data</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">theta_hat_b = np.concatenate(theta_hat_b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># Calculate percentile interval</span>
    <span class="s1">alpha = ((</span><span class="s5">1 </span><span class="s1">- confidence_level)/</span><span class="s5">2 </span><span class="s0">if </span><span class="s1">alternative == </span><span class="s2">'two-sided'</span>
             <span class="s0">else </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- confidence_level))</span>
    <span class="s0">if </span><span class="s1">method == </span><span class="s2">'bca'</span><span class="s1">:</span>
        <span class="s1">interval = _bca_interval(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">alpha=alpha</span><span class="s0">,</span>
                                 <span class="s1">theta_hat_b=theta_hat_b</span><span class="s0">, </span><span class="s1">batch=batch)[:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">percentile_fun = _percentile_along_axis</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">interval = alpha</span><span class="s0">, </span><span class="s5">1</span><span class="s1">-alpha</span>

        <span class="s0">def </span><span class="s1">percentile_fun(a</span><span class="s0">, </span><span class="s1">q):</span>
            <span class="s0">return </span><span class="s1">np.percentile(a=a</span><span class="s0">, </span><span class="s1">q=q</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># Calculate confidence interval of statistic</span>
    <span class="s1">ci_l = percentile_fun(theta_hat_b</span><span class="s0">, </span><span class="s1">interval[</span><span class="s5">0</span><span class="s1">]*</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">ci_u = percentile_fun(theta_hat_b</span><span class="s0">, </span><span class="s1">interval[</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">method == </span><span class="s2">'basic'</span><span class="s1">:  </span><span class="s4"># see [3]</span>
        <span class="s1">theta_hat = statistic(*data</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">ci_l</span><span class="s0">, </span><span class="s1">ci_u = </span><span class="s5">2</span><span class="s1">*theta_hat - ci_u</span><span class="s0">, </span><span class="s5">2</span><span class="s1">*theta_hat - ci_l</span>

    <span class="s0">if </span><span class="s1">alternative == </span><span class="s2">'less'</span><span class="s1">:</span>
        <span class="s1">ci_l = np.full_like(ci_l</span><span class="s0">, </span><span class="s1">-np.inf)</span>
    <span class="s0">elif </span><span class="s1">alternative == </span><span class="s2">'greater'</span><span class="s1">:</span>
        <span class="s1">ci_u = np.full_like(ci_u</span><span class="s0">, </span><span class="s1">np.inf)</span>

    <span class="s0">return </span><span class="s1">BootstrapResult(confidence_interval=ConfidenceInterval(ci_l</span><span class="s0">, </span><span class="s1">ci_u)</span><span class="s0">,</span>
                           <span class="s1">bootstrap_distribution=theta_hat_b</span><span class="s0">,</span>
                           <span class="s1">standard_error=np.std(theta_hat_b</span><span class="s0">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">_monte_carlo_test_iv(data</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">,</span>
                         <span class="s1">batch</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s3">&quot;&quot;&quot;Input validation for `monte_carlo_test`.&quot;&quot;&quot;</span>

    <span class="s1">axis_int = int(axis)</span>
    <span class="s0">if </span><span class="s1">axis != axis_int:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`axis` must be an integer.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">vectorized </span><span class="s0">not in </span><span class="s1">{</span><span class="s0">True, False, None</span><span class="s1">}:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`vectorized` must be `True`, `False`, or `None`.&quot;</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">isinstance(rvs</span><span class="s0">, </span><span class="s1">Sequence):</span>
        <span class="s1">rvs = (rvs</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">data = (data</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">rvs_i </span><span class="s0">in </span><span class="s1">rvs:</span>
        <span class="s0">if not </span><span class="s1">callable(rvs_i):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;`rvs` must be callable or sequence of callables.&quot;</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">len(rvs) == len(data):</span>
        <span class="s1">message = </span><span class="s2">&quot;If `rvs` is a sequence, `len(rvs)` must equal `len(data)`.&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(message)</span>

    <span class="s0">if not </span><span class="s1">callable(statistic):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;`statistic` must be callable.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">vectorized </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">vectorized = </span><span class="s2">'axis' </span><span class="s0">in </span><span class="s1">inspect.signature(statistic).parameters</span>

    <span class="s0">if not </span><span class="s1">vectorized:</span>
        <span class="s1">statistic_vectorized = _vectorize_statistic(statistic)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">statistic_vectorized = statistic</span>

    <span class="s1">data = _broadcast_arrays(data</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s1">data_iv = []</span>
    <span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data:</span>
        <span class="s1">sample = np.atleast_1d(sample)</span>
        <span class="s1">sample = np.moveaxis(sample</span><span class="s0">, </span><span class="s1">axis_int</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">data_iv.append(sample)</span>

    <span class="s1">n_resamples_int = int(n_resamples)</span>
    <span class="s0">if </span><span class="s1">n_resamples != n_resamples_int </span><span class="s0">or </span><span class="s1">n_resamples_int &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`n_resamples` must be a positive integer.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">batch </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">batch_iv = batch</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">batch_iv = int(batch)</span>
        <span class="s0">if </span><span class="s1">batch != batch_iv </span><span class="s0">or </span><span class="s1">batch_iv &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`batch` must be a positive integer or None.&quot;</span><span class="s1">)</span>

    <span class="s1">alternatives = {</span><span class="s2">'two-sided'</span><span class="s0">, </span><span class="s2">'greater'</span><span class="s0">, </span><span class="s2">'less'</span><span class="s1">}</span>
    <span class="s1">alternative = alternative.lower()</span>
    <span class="s0">if </span><span class="s1">alternative </span><span class="s0">not in </span><span class="s1">alternatives:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;`alternative` must be in </span><span class="s0">{</span><span class="s1">alternatives</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">(data_iv</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">statistic_vectorized</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">, </span><span class="s1">n_resamples_int</span><span class="s0">,</span>
            <span class="s1">batch_iv</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis_int)</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">MonteCarloTestResult:</span>
    <span class="s3">&quot;&quot;&quot;Result object returned by `scipy.stats.monte_carlo_test`. 
 
    Attributes 
    ---------- 
    statistic : float or ndarray 
        The observed test statistic of the sample. 
    pvalue : float or ndarray 
        The p-value for the given alternative. 
    null_distribution : ndarray 
        The values of the test statistic generated under the null 
        hypothesis. 
    &quot;&quot;&quot;</span>
    <span class="s1">statistic: float | np.ndarray</span>
    <span class="s1">pvalue: float | np.ndarray</span>
    <span class="s1">null_distribution: np.ndarray</span>


<span class="s1">@_rename_parameter(</span><span class="s2">'sample'</span><span class="s0">, </span><span class="s2">'data'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">monte_carlo_test(data</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">vectorized=</span><span class="s0">None,</span>
                     <span class="s1">n_resamples=</span><span class="s5">9999</span><span class="s0">, </span><span class="s1">batch=</span><span class="s0">None, </span><span class="s1">alternative=</span><span class="s2">&quot;two-sided&quot;</span><span class="s0">,</span>
                     <span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s3">r&quot;&quot;&quot;Perform a Monte Carlo hypothesis test. 
 
    `data` contains a sample or a sequence of one or more samples. `rvs` 
    specifies the distribution(s) of the sample(s) in `data` under the null 
    hypothesis. The value of `statistic` for the given `data` is compared 
    against a Monte Carlo null distribution: the value of the statistic for 
    each of `n_resamples` sets of samples generated using `rvs`. This gives 
    the p-value, the probability of observing such an extreme value of the 
    test statistic under the null hypothesis. 
 
    Parameters 
    ---------- 
    data : array-like or sequence of array-like 
        An array or sequence of arrays of observations. 
    rvs : callable or tuple of callables 
        A callable or sequence of callables that generates random variates 
        under the null hypothesis. Each element of `rvs` must be a callable 
        that accepts keyword argument ``size`` (e.g. ``rvs(size=(m, n))``) and 
        returns an N-d array sample of that shape. If `rvs` is a sequence, the 
        number of callables in `rvs` must match the number of samples in 
        `data`, i.e. ``len(rvs) == len(data)``. If `rvs` is a single callable, 
        `data` is treated as a single sample. 
    statistic : callable 
        Statistic for which the p-value of the hypothesis test is to be 
        calculated. `statistic` must be a callable that accepts a sample 
        (e.g. ``statistic(sample)``) or ``len(rvs)`` separate samples (e.g. 
        ``statistic(samples1, sample2)`` if `rvs` contains two callables and 
        `data` contains two samples) and returns the resulting statistic. 
        If `vectorized` is set ``True``, `statistic` must also accept a keyword 
        argument `axis` and be vectorized to compute the statistic along the 
        provided `axis` of the samples in `data`. 
    vectorized : bool, optional 
        If `vectorized` is set ``False``, `statistic` will not be passed 
        keyword argument `axis` and is expected to calculate the statistic 
        only for 1D samples. If ``True``, `statistic` will be passed keyword 
        argument `axis` and is expected to calculate the statistic along `axis` 
        when passed ND sample arrays. If ``None`` (default), `vectorized` 
        will be set ``True`` if ``axis`` is a parameter of `statistic`. Use of 
        a vectorized statistic typically reduces computation time. 
    n_resamples : int, default: 9999 
        Number of samples drawn from each of the callables of `rvs`. 
        Equivalently, the number statistic values under the null hypothesis 
        used as the Monte Carlo null distribution. 
    batch : int, optional 
        The number of Monte Carlo samples to process in each call to 
        `statistic`. Memory usage is O(`batch`*``sample.size[axis]``). Default 
        is ``None``, in which case `batch` equals `n_resamples`. 
    alternative : {'two-sided', 'less', 'greater'} 
        The alternative hypothesis for which the p-value is calculated. 
        For each alternative, the p-value is defined as follows. 
 
        - ``'greater'`` : the percentage of the null distribution that is 
          greater than or equal to the observed value of the test statistic. 
        - ``'less'`` : the percentage of the null distribution that is 
          less than or equal to the observed value of the test statistic. 
        - ``'two-sided'`` : twice the smaller of the p-values above. 
 
    axis : int, default: 0 
        The axis of `data` (or each sample within `data`) over which to 
        calculate the statistic. 
 
    Returns 
    ------- 
    res : MonteCarloTestResult 
        An object with attributes: 
 
        statistic : float or ndarray 
            The test statistic of the observed `data`. 
        pvalue : float or ndarray 
            The p-value for the given alternative. 
        null_distribution : ndarray 
            The values of the test statistic generated under the null 
            hypothesis. 
 
    References 
    ---------- 
 
    .. [1] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be 
       Zero: Calculating Exact P-values When Permutations Are Randomly Drawn.&quot; 
       Statistical Applications in Genetics and Molecular Biology 9.1 (2010). 
 
    Examples 
    -------- 
 
    Suppose we wish to test whether a small sample has been drawn from a normal 
    distribution. We decide that we will use the skew of the sample as a 
    test statistic, and we will consider a p-value of 0.05 to be statistically 
    significant. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; def statistic(x, axis): 
    ...     return stats.skew(x, axis) 
 
    After collecting our data, we calculate the observed value of the test 
    statistic. 
 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = stats.skewnorm.rvs(a=1, size=50, random_state=rng) 
    &gt;&gt;&gt; statistic(x, axis=0) 
    0.12457412450240658 
 
    To determine the probability of observing such an extreme value of the 
    skewness by chance if the sample were drawn from the normal distribution, 
    we can perform a Monte Carlo hypothesis test. The test will draw many 
    samples at random from their normal distribution, calculate the skewness 
    of each sample, and compare our original skewness against this 
    distribution to determine an approximate p-value. 
 
    &gt;&gt;&gt; from scipy.stats import monte_carlo_test 
    &gt;&gt;&gt; # because our statistic is vectorized, we pass `vectorized=True` 
    &gt;&gt;&gt; rvs = lambda size: stats.norm.rvs(size=size, random_state=rng) 
    &gt;&gt;&gt; res = monte_carlo_test(x, rvs, statistic, vectorized=True) 
    &gt;&gt;&gt; print(res.statistic) 
    0.12457412450240658 
    &gt;&gt;&gt; print(res.pvalue) 
    0.7012 
 
    The probability of obtaining a test statistic less than or equal to the 
    observed value under the null hypothesis is ~70%. This is greater than 
    our chosen threshold of 5%, so we cannot consider this to be significant 
    evidence against the null hypothesis. 
 
    Note that this p-value essentially matches that of 
    `scipy.stats.skewtest`, which relies on an asymptotic distribution of a 
    test statistic based on the sample skewness. 
 
    &gt;&gt;&gt; stats.skewtest(x).pvalue 
    0.6892046027110614 
 
    This asymptotic approximation is not valid for small sample sizes, but 
    `monte_carlo_test` can be used with samples of any size. 
 
    &gt;&gt;&gt; x = stats.skewnorm.rvs(a=1, size=7, random_state=rng) 
    &gt;&gt;&gt; # stats.skewtest(x) would produce an error due to small sample 
    &gt;&gt;&gt; res = monte_carlo_test(x, rvs, statistic, vectorized=True) 
 
    The Monte Carlo distribution of the test statistic is provided for 
    further investigation. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hist(res.null_distribution, bins=50) 
    &gt;&gt;&gt; ax.set_title(&quot;Monte Carlo distribution of test statistic&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;Value of Statistic&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Frequency&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">args = _monte_carlo_test_iv(data</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">,</span>
                                <span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s1">(data</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">,</span>
     <span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis) = args</span>

    <span class="s4"># Some statistics return plain floats; ensure they're at least np.float64</span>
    <span class="s1">observed = np.asarray(statistic(*data</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))[()]</span>

    <span class="s1">n_observations = [sample.shape[-</span><span class="s5">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data]</span>
    <span class="s1">batch_nominal = batch </span><span class="s0">or </span><span class="s1">n_resamples</span>
    <span class="s1">null_distribution = []</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch_nominal):</span>
        <span class="s1">batch_actual = min(batch_nominal</span><span class="s0">, </span><span class="s1">n_resamples - k)</span>
        <span class="s1">resamples = [rvs_i(size=(batch_actual</span><span class="s0">, </span><span class="s1">n_observations_i))</span>
                     <span class="s0">for </span><span class="s1">rvs_i</span><span class="s0">, </span><span class="s1">n_observations_i </span><span class="s0">in </span><span class="s1">zip(rvs</span><span class="s0">, </span><span class="s1">n_observations)]</span>
        <span class="s1">null_distribution.append(statistic(*resamples</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">null_distribution = np.concatenate(null_distribution)</span>
    <span class="s1">null_distribution = null_distribution.reshape([-</span><span class="s5">1</span><span class="s1">] + [</span><span class="s5">1</span><span class="s1">]*observed.ndim)</span>

    <span class="s0">def </span><span class="s1">less(null_distribution</span><span class="s0">, </span><span class="s1">observed):</span>
        <span class="s1">cmps = null_distribution &lt;= observed</span>
        <span class="s1">pvalues = (cmps.sum(axis=</span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span><span class="s1">) / (n_resamples + </span><span class="s5">1</span><span class="s1">)  </span><span class="s4"># see [1]</span>
        <span class="s0">return </span><span class="s1">pvalues</span>

    <span class="s0">def </span><span class="s1">greater(null_distribution</span><span class="s0">, </span><span class="s1">observed):</span>
        <span class="s1">cmps = null_distribution &gt;= observed</span>
        <span class="s1">pvalues = (cmps.sum(axis=</span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span><span class="s1">) / (n_resamples + </span><span class="s5">1</span><span class="s1">)  </span><span class="s4"># see [1]</span>
        <span class="s0">return </span><span class="s1">pvalues</span>

    <span class="s0">def </span><span class="s1">two_sided(null_distribution</span><span class="s0">, </span><span class="s1">observed):</span>
        <span class="s1">pvalues_less = less(null_distribution</span><span class="s0">, </span><span class="s1">observed)</span>
        <span class="s1">pvalues_greater = greater(null_distribution</span><span class="s0">, </span><span class="s1">observed)</span>
        <span class="s1">pvalues = np.minimum(pvalues_less</span><span class="s0">, </span><span class="s1">pvalues_greater) * </span><span class="s5">2</span>
        <span class="s0">return </span><span class="s1">pvalues</span>

    <span class="s1">compare = {</span><span class="s2">&quot;less&quot;</span><span class="s1">: less</span><span class="s0">,</span>
               <span class="s2">&quot;greater&quot;</span><span class="s1">: greater</span><span class="s0">,</span>
               <span class="s2">&quot;two-sided&quot;</span><span class="s1">: two_sided}</span>

    <span class="s1">pvalues = compare[alternative](null_distribution</span><span class="s0">, </span><span class="s1">observed)</span>
    <span class="s1">pvalues = np.clip(pvalues</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">MonteCarloTestResult(observed</span><span class="s0">, </span><span class="s1">pvalues</span><span class="s0">, </span><span class="s1">null_distribution)</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">PermutationTestResult:</span>
    <span class="s3">&quot;&quot;&quot;Result object returned by `scipy.stats.permutation_test`. 
 
    Attributes 
    ---------- 
    statistic : float or ndarray 
        The observed test statistic of the data. 
    pvalue : float or ndarray 
        The p-value for the given alternative. 
    null_distribution : ndarray 
        The values of the test statistic generated under the null 
        hypothesis. 
    &quot;&quot;&quot;</span>
    <span class="s1">statistic: float | np.ndarray</span>
    <span class="s1">pvalue: float | np.ndarray</span>
    <span class="s1">null_distribution: np.ndarray</span>


<span class="s0">def </span><span class="s1">_all_partitions_concatenated(ns):</span>
    <span class="s3">&quot;&quot;&quot; 
    Generate all partitions of indices of groups of given sizes, concatenated 
 
    `ns` is an iterable of ints. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">all_partitions(z</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">combinations(z</span><span class="s0">, </span><span class="s1">n):</span>
            <span class="s1">x0 = set(c)</span>
            <span class="s1">x1 = z - x0</span>
            <span class="s0">yield </span><span class="s1">[x0</span><span class="s0">, </span><span class="s1">x1]</span>

    <span class="s0">def </span><span class="s1">all_partitions_n(z</span><span class="s0">, </span><span class="s1">ns):</span>
        <span class="s0">if </span><span class="s1">len(ns) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">[z]</span>
            <span class="s0">return</span>
        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">all_partitions(z</span><span class="s0">, </span><span class="s1">ns[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">all_partitions_n(c[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ns[</span><span class="s5">1</span><span class="s1">:]):</span>
                <span class="s0">yield </span><span class="s1">c[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">1</span><span class="s1">] + d</span>

    <span class="s1">z = set(range(np.sum(ns)))</span>
    <span class="s0">for </span><span class="s1">partitioning </span><span class="s0">in </span><span class="s1">all_partitions_n(z</span><span class="s0">, </span><span class="s1">ns[:]):</span>
        <span class="s1">x = np.concatenate([list(partition)</span>
                            <span class="s0">for </span><span class="s1">partition </span><span class="s0">in </span><span class="s1">partitioning]).astype(int)</span>
        <span class="s0">yield </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">_batch_generator(iterable</span><span class="s0">, </span><span class="s1">batch):</span>
    <span class="s3">&quot;&quot;&quot;A generator that yields batches of elements from an iterable&quot;&quot;&quot;</span>
    <span class="s1">iterator = iter(iterable)</span>
    <span class="s0">if </span><span class="s1">batch &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`batch` must be positive.&quot;</span><span class="s1">)</span>
    <span class="s1">z = [item </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">zip(range(batch)</span><span class="s0">, </span><span class="s1">iterator)]</span>
    <span class="s0">while </span><span class="s1">z:  </span><span class="s4"># we don't want StopIteration without yielding an empty list</span>
        <span class="s0">yield </span><span class="s1">z</span>
        <span class="s1">z = [item </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">zip(range(batch)</span><span class="s0">, </span><span class="s1">iterator)]</span>


<span class="s0">def </span><span class="s1">_pairings_permutations_gen(n_permutations</span><span class="s0">, </span><span class="s1">n_samples</span><span class="s0">, </span><span class="s1">n_obs_sample</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">,</span>
                               <span class="s1">random_state):</span>
    <span class="s4"># Returns a generator that yields arrays of size</span>
    <span class="s4"># `(batch, n_samples, n_obs_sample)`.</span>
    <span class="s4"># Each row is an independent permutation of indices 0 to `n_obs_sample`.</span>
    <span class="s1">batch = min(batch</span><span class="s0">, </span><span class="s1">n_permutations)</span>

    <span class="s0">if </span><span class="s1">hasattr(random_state</span><span class="s0">, </span><span class="s2">'permuted'</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">batched_perm_generator():</span>
            <span class="s1">indices = np.arange(n_obs_sample)</span>
            <span class="s1">indices = np.tile(indices</span><span class="s0">, </span><span class="s1">(batch</span><span class="s0">, </span><span class="s1">n_samples</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">n_permutations</span><span class="s0">, </span><span class="s1">batch):</span>
                <span class="s1">batch_actual = min(batch</span><span class="s0">, </span><span class="s1">n_permutations-k)</span>
                <span class="s4"># Don't permute in place, otherwise results depend on `batch`</span>
                <span class="s1">permuted_indices = random_state.permuted(indices</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s0">yield </span><span class="s1">permuted_indices[:batch_actual]</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s4"># RandomState and early Generators don't have `permuted`</span>
        <span class="s0">def </span><span class="s1">batched_perm_generator():</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">n_permutations</span><span class="s0">, </span><span class="s1">batch):</span>
                <span class="s1">batch_actual = min(batch</span><span class="s0">, </span><span class="s1">n_permutations-k)</span>
                <span class="s1">size = (batch_actual</span><span class="s0">, </span><span class="s1">n_samples</span><span class="s0">, </span><span class="s1">n_obs_sample)</span>
                <span class="s1">x = random_state.random(size=size)</span>
                <span class="s0">yield </span><span class="s1">np.argsort(x</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)[:batch_actual]</span>

    <span class="s0">return </span><span class="s1">batched_perm_generator()</span>


<span class="s0">def </span><span class="s1">_calculate_null_both(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">n_permutations</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">,</span>
                         <span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Calculate null distribution for independent sample tests. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples = len(data)</span>

    <span class="s4"># compute number of permutations</span>
    <span class="s4"># (distinct partitions of data into samples of these sizes)</span>
    <span class="s1">n_obs_i = [sample.shape[-</span><span class="s5">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data]  </span><span class="s4"># observations per sample</span>
    <span class="s1">n_obs_ic = np.cumsum(n_obs_i)</span>
    <span class="s1">n_obs = n_obs_ic[-</span><span class="s5">1</span><span class="s1">]  </span><span class="s4"># total number of observations</span>
    <span class="s1">n_max = np.prod([comb(n_obs_ic[i]</span><span class="s0">, </span><span class="s1">n_obs_ic[i-</span><span class="s5">1</span><span class="s1">])</span>
                     <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n_samples-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)])</span>

    <span class="s4"># perm_generator is an iterator that produces permutations of indices</span>
    <span class="s4"># from 0 to n_obs. We'll concatenate the samples, use these indices to</span>
    <span class="s4"># permute the data, then split the samples apart again.</span>
    <span class="s0">if </span><span class="s1">n_permutations &gt;= n_max:</span>
        <span class="s1">exact_test = </span><span class="s0">True</span>
        <span class="s1">n_permutations = n_max</span>
        <span class="s1">perm_generator = _all_partitions_concatenated(n_obs_i)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">exact_test = </span><span class="s0">False</span>
        <span class="s4"># Neither RandomState.permutation nor Generator.permutation</span>
        <span class="s4"># can permute axis-slices independently. If this feature is</span>
        <span class="s4"># added in the future, batches of the desired size should be</span>
        <span class="s4"># generated in a single call.</span>
        <span class="s1">perm_generator = (random_state.permutation(n_obs)</span>
                          <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n_permutations))</span>

    <span class="s1">batch = batch </span><span class="s0">or </span><span class="s1">int(n_permutations)</span>
    <span class="s1">null_distribution = []</span>

    <span class="s4"># First, concatenate all the samples. In batches, permute samples with</span>
    <span class="s4"># indices produced by the `perm_generator`, split them into new samples of</span>
    <span class="s4"># the original sizes, compute the statistic for each batch, and add these</span>
    <span class="s4"># statistic values to the null distribution.</span>
    <span class="s1">data = np.concatenate(data</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">indices </span><span class="s0">in </span><span class="s1">_batch_generator(perm_generator</span><span class="s0">, </span><span class="s1">batch=batch):</span>
        <span class="s1">indices = np.array(indices)</span>

        <span class="s4"># `indices` is 2D: each row is a permutation of the indices.</span>
        <span class="s4"># We use it to index `data` along its last axis, which corresponds</span>
        <span class="s4"># with observations.</span>
        <span class="s4"># After indexing, the second to last axis of `data_batch` corresponds</span>
        <span class="s4"># with permutations, and the last axis corresponds with observations.</span>
        <span class="s1">data_batch = data[...</span><span class="s0">, </span><span class="s1">indices]</span>

        <span class="s4"># Move the permutation axis to the front: we'll concatenate a list</span>
        <span class="s4"># of batched statistic values along this zeroth axis to form the</span>
        <span class="s4"># null distribution.</span>
        <span class="s1">data_batch = np.moveaxis(data_batch</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">data_batch = np.split(data_batch</span><span class="s0">, </span><span class="s1">n_obs_ic[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">null_distribution.append(statistic(*data_batch</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">null_distribution = np.concatenate(null_distribution</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">null_distribution</span><span class="s0">, </span><span class="s1">n_permutations</span><span class="s0">, </span><span class="s1">exact_test</span>


<span class="s0">def </span><span class="s1">_calculate_null_pairings(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">n_permutations</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">,</span>
                             <span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Calculate null distribution for association tests. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples = len(data)</span>

    <span class="s4"># compute number of permutations (factorial(n) permutations of each sample)</span>
    <span class="s1">n_obs_sample = data[</span><span class="s5">0</span><span class="s1">].shape[-</span><span class="s5">1</span><span class="s1">]  </span><span class="s4"># observations per sample; same for each</span>
    <span class="s1">n_max = factorial(n_obs_sample)**n_samples</span>

    <span class="s4"># `perm_generator` is an iterator that produces a list of permutations of</span>
    <span class="s4"># indices from 0 to n_obs_sample, one for each sample.</span>
    <span class="s0">if </span><span class="s1">n_permutations &gt;= n_max:</span>
        <span class="s1">exact_test = </span><span class="s0">True</span>
        <span class="s1">n_permutations = n_max</span>
        <span class="s1">batch = batch </span><span class="s0">or </span><span class="s1">int(n_permutations)</span>
        <span class="s4"># cartesian product of the sets of all permutations of indices</span>
        <span class="s1">perm_generator = product(*(permutations(range(n_obs_sample))</span>
                                   <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n_samples)))</span>
        <span class="s1">batched_perm_generator = _batch_generator(perm_generator</span><span class="s0">, </span><span class="s1">batch=batch)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">exact_test = </span><span class="s0">False</span>
        <span class="s1">batch = batch </span><span class="s0">or </span><span class="s1">int(n_permutations)</span>
        <span class="s4"># Separate random permutations of indices for each sample.</span>
        <span class="s4"># Again, it would be nice if RandomState/Generator.permutation</span>
        <span class="s4"># could permute each axis-slice separately.</span>
        <span class="s1">args = n_permutations</span><span class="s0">, </span><span class="s1">n_samples</span><span class="s0">, </span><span class="s1">n_obs_sample</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">, </span><span class="s1">random_state</span>
        <span class="s1">batched_perm_generator = _pairings_permutations_gen(*args)</span>

    <span class="s1">null_distribution = []</span>

    <span class="s0">for </span><span class="s1">indices </span><span class="s0">in </span><span class="s1">batched_perm_generator:</span>
        <span class="s1">indices = np.array(indices)</span>

        <span class="s4"># `indices` is 3D: the zeroth axis is for permutations, the next is</span>
        <span class="s4"># for samples, and the last is for observations. Swap the first two</span>
        <span class="s4"># to make the zeroth axis correspond with samples, as it does for</span>
        <span class="s4"># `data`.</span>
        <span class="s1">indices = np.swapaxes(indices</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s4"># When we're done, `data_batch` will be a list of length `n_samples`.</span>
        <span class="s4"># Each element will be a batch of random permutations of one sample.</span>
        <span class="s4"># The zeroth axis of each batch will correspond with permutations,</span>
        <span class="s4"># and the last will correspond with observations. (This makes it</span>
        <span class="s4"># easy to pass into `statistic`.)</span>
        <span class="s1">data_batch = [</span><span class="s0">None</span><span class="s1">]*n_samples</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n_samples):</span>
            <span class="s1">data_batch[i] = data[i][...</span><span class="s0">, </span><span class="s1">indices[i]]</span>
            <span class="s1">data_batch[i] = np.moveaxis(data_batch[i]</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">null_distribution.append(statistic(*data_batch</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">null_distribution = np.concatenate(null_distribution</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">null_distribution</span><span class="s0">, </span><span class="s1">n_permutations</span><span class="s0">, </span><span class="s1">exact_test</span>


<span class="s0">def </span><span class="s1">_calculate_null_samples(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">n_permutations</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">,</span>
                            <span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Calculate null distribution for paired-sample tests. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples = len(data)</span>

    <span class="s4"># By convention, the meaning of the &quot;samples&quot; permutations type for</span>
    <span class="s4"># data with only one sample is to flip the sign of the observations.</span>
    <span class="s4"># Achieve this by adding a second sample - the negative of the original.</span>
    <span class="s0">if </span><span class="s1">n_samples == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">data = [data[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-data[</span><span class="s5">0</span><span class="s1">]]</span>

    <span class="s4"># The &quot;samples&quot; permutation strategy is the same as the &quot;pairings&quot;</span>
    <span class="s4"># strategy except the roles of samples and observations are flipped.</span>
    <span class="s4"># So swap these axes, then we'll use the function for the &quot;pairings&quot;</span>
    <span class="s4"># strategy to do all the work!</span>
    <span class="s1">data = np.swapaxes(data</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># (Of course, the user's statistic doesn't know what we've done here,</span>
    <span class="s4"># so we need to pass it what it's expecting.)</span>
    <span class="s0">def </span><span class="s1">statistic_wrapped(*data</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">data = np.swapaxes(data</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">n_samples == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">data = data[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">statistic(*data</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">return </span><span class="s1">_calculate_null_pairings(data</span><span class="s0">, </span><span class="s1">statistic_wrapped</span><span class="s0">, </span><span class="s1">n_permutations</span><span class="s0">,</span>
                                    <span class="s1">batch</span><span class="s0">, </span><span class="s1">random_state)</span>


<span class="s0">def </span><span class="s1">_permutation_test_iv(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">permutation_type</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">,</span>
                         <span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">random_state):</span>
    <span class="s3">&quot;&quot;&quot;Input validation for `permutation_test`.&quot;&quot;&quot;</span>

    <span class="s1">axis_int = int(axis)</span>
    <span class="s0">if </span><span class="s1">axis != axis_int:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`axis` must be an integer.&quot;</span><span class="s1">)</span>

    <span class="s1">permutation_types = {</span><span class="s2">'samples'</span><span class="s0">, </span><span class="s2">'pairings'</span><span class="s0">, </span><span class="s2">'independent'</span><span class="s1">}</span>
    <span class="s1">permutation_type = permutation_type.lower()</span>
    <span class="s0">if </span><span class="s1">permutation_type </span><span class="s0">not in </span><span class="s1">permutation_types:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;`permutation_type` must be in </span><span class="s0">{</span><span class="s1">permutation_types</span><span class="s0">}</span><span class="s2">.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">vectorized </span><span class="s0">not in </span><span class="s1">{</span><span class="s0">True, False, None</span><span class="s1">}:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`vectorized` must be `True`, `False`, or `None`.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">vectorized </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">vectorized = </span><span class="s2">'axis' </span><span class="s0">in </span><span class="s1">inspect.signature(statistic).parameters</span>

    <span class="s0">if not </span><span class="s1">vectorized:</span>
        <span class="s1">statistic = _vectorize_statistic(statistic)</span>

    <span class="s1">message = </span><span class="s2">&quot;`data` must be a tuple containing at least two samples&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">len(data) &lt; </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">permutation_type == </span><span class="s2">'independent'</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(message)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">raise </span><span class="s1">TypeError(message)</span>

    <span class="s1">data = _broadcast_arrays(data</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s1">data_iv = []</span>
    <span class="s0">for </span><span class="s1">sample </span><span class="s0">in </span><span class="s1">data:</span>
        <span class="s1">sample = np.atleast_1d(sample)</span>
        <span class="s0">if </span><span class="s1">sample.shape[axis] &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;each sample in `data` must contain two or more &quot;</span>
                             <span class="s2">&quot;observations along `axis`.&quot;</span><span class="s1">)</span>
        <span class="s1">sample = np.moveaxis(sample</span><span class="s0">, </span><span class="s1">axis_int</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">data_iv.append(sample)</span>

    <span class="s1">n_resamples_int = (int(n_resamples) </span><span class="s0">if not </span><span class="s1">np.isinf(n_resamples)</span>
                       <span class="s0">else </span><span class="s1">np.inf)</span>
    <span class="s0">if </span><span class="s1">n_resamples != n_resamples_int </span><span class="s0">or </span><span class="s1">n_resamples_int &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`n_resamples` must be a positive integer.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">batch </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">batch_iv = batch</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">batch_iv = int(batch)</span>
        <span class="s0">if </span><span class="s1">batch != batch_iv </span><span class="s0">or </span><span class="s1">batch_iv &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`batch` must be a positive integer or None.&quot;</span><span class="s1">)</span>

    <span class="s1">alternatives = {</span><span class="s2">'two-sided'</span><span class="s0">, </span><span class="s2">'greater'</span><span class="s0">, </span><span class="s2">'less'</span><span class="s1">}</span>
    <span class="s1">alternative = alternative.lower()</span>
    <span class="s0">if </span><span class="s1">alternative </span><span class="s0">not in </span><span class="s1">alternatives:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;`alternative` must be in </span><span class="s0">{</span><span class="s1">alternatives</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s1">random_state = check_random_state(random_state)</span>

    <span class="s0">return </span><span class="s1">(data_iv</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">permutation_type</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">, </span><span class="s1">n_resamples_int</span><span class="s0">,</span>
            <span class="s1">batch_iv</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis_int</span><span class="s0">, </span><span class="s1">random_state)</span>


<span class="s0">def </span><span class="s1">permutation_test(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">permutation_type=</span><span class="s2">'independent'</span><span class="s0">,</span>
                     <span class="s1">vectorized=</span><span class="s0">None, </span><span class="s1">n_resamples=</span><span class="s5">9999</span><span class="s0">, </span><span class="s1">batch=</span><span class="s0">None,</span>
                     <span class="s1">alternative=</span><span class="s2">&quot;two-sided&quot;</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Performs a permutation test of a given statistic on provided data. 
 
    For independent sample statistics, the null hypothesis is that the data are 
    randomly sampled from the same distribution. 
    For paired sample statistics, two null hypothesis can be tested: 
    that the data are paired at random or that the data are assigned to samples 
    at random. 
 
    Parameters 
    ---------- 
    data : iterable of array-like 
        Contains the samples, each of which is an array of observations. 
        Dimensions of sample arrays must be compatible for broadcasting except 
        along `axis`. 
    statistic : callable 
        Statistic for which the p-value of the hypothesis test is to be 
        calculated. `statistic` must be a callable that accepts samples 
        as separate arguments (e.g. ``statistic(*data)``) and returns the 
        resulting statistic. 
        If `vectorized` is set ``True``, `statistic` must also accept a keyword 
        argument `axis` and be vectorized to compute the statistic along the 
        provided `axis` of the sample arrays. 
    permutation_type : {'independent', 'samples', 'pairings'}, optional 
        The type of permutations to be performed, in accordance with the 
        null hypothesis. The first two permutation types are for paired sample 
        statistics, in which all samples contain the same number of 
        observations and observations with corresponding indices along `axis` 
        are considered to be paired; the third is for independent sample 
        statistics. 
 
        - ``'samples'`` : observations are assigned to different samples 
          but remain paired with the same observations from other samples. 
          This permutation type is appropriate for paired sample hypothesis 
          tests such as the Wilcoxon signed-rank test and the paired t-test. 
        - ``'pairings'`` : observations are paired with different observations, 
          but they remain within the same sample. This permutation type is 
          appropriate for association/correlation tests with statistics such 
          as Spearman's :math:`\rho`, Kendall's :math:`\tau`, and Pearson's 
          :math:`r`. 
        - ``'independent'`` (default) : observations are assigned to different 
          samples. Samples may contain different numbers of observations. This 
          permutation type is appropriate for independent sample hypothesis 
          tests such as the Mann-Whitney :math:`U` test and the independent 
          sample t-test. 
 
          Please see the Notes section below for more detailed descriptions 
          of the permutation types. 
 
    vectorized : bool, optional 
        If `vectorized` is set ``False``, `statistic` will not be passed 
        keyword argument `axis` and is expected to calculate the statistic 
        only for 1D samples. If ``True``, `statistic` will be passed keyword 
        argument `axis` and is expected to calculate the statistic along `axis` 
        when passed an ND sample array. If ``None`` (default), `vectorized` 
        will be set ``True`` if ``axis`` is a parameter of `statistic`. Use 
        of a vectorized statistic typically reduces computation time. 
    n_resamples : int or np.inf, default: 9999 
        Number of random permutations (resamples) used to approximate the null 
        distribution. If greater than or equal to the number of distinct 
        permutations, the exact null distribution will be computed. 
        Note that the number of distinct permutations grows very rapidly with 
        the sizes of samples, so exact tests are feasible only for very small 
        data sets. 
    batch : int, optional 
        The number of permutations to process in each call to `statistic`. 
        Memory usage is O(`batch`*``n``), where ``n`` is the total size 
        of all samples, regardless of the value of `vectorized`. Default is 
        ``None``, in which case ``batch`` is the number of permutations. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        The alternative hypothesis for which the p-value is calculated. 
        For each alternative, the p-value is defined for exact tests as 
        follows. 
 
        - ``'greater'`` : the percentage of the null distribution that is 
          greater than or equal to the observed value of the test statistic. 
        - ``'less'`` : the percentage of the null distribution that is 
          less than or equal to the observed value of the test statistic. 
        - ``'two-sided'`` (default) : twice the smaller of the p-values above. 
 
        Note that p-values for randomized tests are calculated according to the 
        conservative (over-estimated) approximation suggested in [2]_ and [3]_ 
        rather than the unbiased estimator suggested in [4]_. That is, when 
        calculating the proportion of the randomized null distribution that is 
        as extreme as the observed value of the test statistic, the values in 
        the numerator and denominator are both increased by one. An 
        interpretation of this adjustment is that the observed value of the 
        test statistic is always included as an element of the randomized 
        null distribution. 
        The convention used for two-sided p-values is not universal; 
        the observed test statistic and null distribution are returned in 
        case a different definition is preferred. 
 
    axis : int, default: 0 
        The axis of the (broadcasted) samples over which to calculate the 
        statistic. If samples have a different number of dimensions, 
        singleton dimensions are prepended to samples with fewer dimensions 
        before `axis` is considered. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        Pseudorandom number generator state used to generate permutations. 
 
        If `random_state` is ``None`` (default), the 
        `numpy.random.RandomState` singleton is used. 
        If `random_state` is an int, a new ``RandomState`` instance is used, 
        seeded with `random_state`. 
        If `random_state` is already a ``Generator`` or ``RandomState`` 
        instance then that instance is used. 
 
    Returns 
    ------- 
    res : PermutationTestResult 
        An object with attributes: 
 
        statistic : float or ndarray 
            The observed test statistic of the data. 
        pvalue : float or ndarray 
            The p-value for the given alternative. 
        null_distribution : ndarray 
            The values of the test statistic generated under the null 
            hypothesis. 
 
    Notes 
    ----- 
 
    The three types of permutation tests supported by this function are 
    described below. 
 
    **Unpaired statistics** (``permutation_type='independent'``): 
 
    The null hypothesis associated with this permutation type is that all 
    observations are sampled from the same underlying distribution and that 
    they have been assigned to one of the samples at random. 
 
    Suppose ``data`` contains two samples; e.g. ``a, b = data``. 
    When ``1 &lt; n_resamples &lt; binom(n, k)``, where 
 
    * ``k`` is the number of observations in ``a``, 
    * ``n`` is the total number of observations in ``a`` and ``b``, and 
    * ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``), 
 
    the data are pooled (concatenated), randomly assigned to either the first 
    or second sample, and the statistic is calculated. This process is 
    performed repeatedly, `permutation` times, generating a distribution of the 
    statistic under the null hypothesis. The statistic of the original 
    data is compared to this distribution to determine the p-value. 
 
    When ``n_resamples &gt;= binom(n, k)``, an exact test is performed: the data 
    are *partitioned* between the samples in each distinct way exactly once, 
    and the exact null distribution is formed. 
    Note that for a given partitioning of the data between the samples, 
    only one ordering/permutation of the data *within* each sample is 
    considered. For statistics that do not depend on the order of the data 
    within samples, this dramatically reduces computational cost without 
    affecting the shape of the null distribution (because the frequency/count 
    of each value is affected by the same factor). 
 
    For ``a = [a1, a2, a3, a4]`` and ``b = [b1, b2, b3]``, an example of this 
    permutation type is ``x = [b3, a1, a2, b2]`` and ``y = [a4, b1, a3]``. 
    Because only one ordering/permutation of the data *within* each sample 
    is considered in an exact test, a resampling like ``x = [b3, a1, b2, a2]`` 
    and ``y = [a4, a3, b1]`` would *not* be considered distinct from the 
    example above. 
 
    ``permutation_type='independent'`` does not support one-sample statistics, 
    but it can be applied to statistics with more than two samples. In this 
    case, if ``n`` is an array of the number of observations within each 
    sample, the number of distinct partitions is:: 
 
        np.prod([binom(sum(n[i:]), sum(n[i+1:])) for i in range(len(n)-1)]) 
 
    **Paired statistics, permute pairings** (``permutation_type='pairings'``): 
 
    The null hypothesis associated with this permutation type is that 
    observations within each sample are drawn from the same underlying 
    distribution and that pairings with elements of other samples are 
    assigned at random. 
 
    Suppose ``data`` contains only one sample; e.g. ``a, = data``, and we 
    wish to consider all possible pairings of elements of ``a`` with elements 
    of a second sample, ``b``. Let ``n`` be the number of observations in 
    ``a``, which must also equal the number of observations in ``b``. 
 
    When ``1 &lt; n_resamples &lt; factorial(n)``, the elements of ``a`` are 
    randomly permuted. The user-supplied statistic accepts one data argument, 
    say ``a_perm``, and calculates the statistic considering ``a_perm`` and 
    ``b``. This process is performed repeatedly, `permutation` times, 
    generating a distribution of the statistic under the null hypothesis. 
    The statistic of the original data is compared to this distribution to 
    determine the p-value. 
 
    When ``n_resamples &gt;= factorial(n)``, an exact test is performed: 
    ``a`` is permuted in each distinct way exactly once. Therefore, the 
    `statistic` is computed for each unique pairing of samples between ``a`` 
    and ``b`` exactly once. 
 
    For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this 
    permutation type is ``a_perm = [a3, a1, a2]`` while ``b`` is left 
    in its original order. 
 
    ``permutation_type='pairings'`` supports ``data`` containing any number 
    of samples, each of which must contain the same number of observations. 
    All samples provided in ``data`` are permuted *independently*. Therefore, 
    if ``m`` is the number of samples and ``n`` is the number of observations 
    within each sample, then the number of permutations in an exact test is:: 
 
        factorial(n)**m 
 
    Note that if a two-sample statistic, for example, does not inherently 
    depend on the order in which observations are provided - only on the 
    *pairings* of observations - then only one of the two samples should be 
    provided in ``data``. This dramatically reduces computational cost without 
    affecting the shape of the null distribution (because the frequency/count 
    of each value is affected by the same factor). 
 
    **Paired statistics, permute samples** (``permutation_type='samples'``): 
 
    The null hypothesis associated with this permutation type is that 
    observations within each pair are drawn from the same underlying 
    distribution and that the sample to which they are assigned is random. 
 
    Suppose ``data`` contains two samples; e.g. ``a, b = data``. 
    Let ``n`` be the number of observations in ``a``, which must also equal 
    the number of observations in ``b``. 
 
    When ``1 &lt; n_resamples &lt; 2**n``, the elements of ``a`` are ``b`` are 
    randomly swapped between samples (maintaining their pairings) and the 
    statistic is calculated. This process is performed repeatedly, 
    `permutation` times,  generating a distribution of the statistic under the 
    null hypothesis. The statistic of the original data is compared to this 
    distribution to determine the p-value. 
 
    When ``n_resamples &gt;= 2**n``, an exact test is performed: the observations 
    are assigned to the two samples in each distinct way (while maintaining 
    pairings) exactly once. 
 
    For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this 
    permutation type is ``x = [b1, a2, b3]`` and ``y = [a1, b2, a3]``. 
 
    ``permutation_type='samples'`` supports ``data`` containing any number 
    of samples, each of which must contain the same number of observations. 
    If ``data`` contains more than one sample, paired observations within 
    ``data`` are exchanged between samples *independently*. Therefore, if ``m`` 
    is the number of samples and ``n`` is the number of observations within 
    each sample, then the number of permutations in an exact test is:: 
 
        factorial(m)**n 
 
    Several paired-sample statistical tests, such as the Wilcoxon signed rank 
    test and paired-sample t-test, can be performed considering only the 
    *difference* between two paired elements. Accordingly, if ``data`` contains 
    only one sample, then the null distribution is formed by independently 
    changing the *sign* of each observation. 
 
    .. warning:: 
        The p-value is calculated by counting the elements of the null 
        distribution that are as extreme or more extreme than the observed 
        value of the statistic. Due to the use of finite precision arithmetic, 
        some statistic functions return numerically distinct values when the 
        theoretical values would be exactly equal. In some cases, this could 
        lead to a large error in the calculated p-value. `permutation_test` 
        guards against this by considering elements in the null distribution 
        that are &quot;close&quot; (within a factor of ``1+1e-14``) to the observed 
        value of the test statistic as equal to the observed value of the 
        test statistic. However, the user is advised to inspect the null 
        distribution to assess whether this method of comparison is 
        appropriate, and if not, calculate the p-value manually. See example 
        below. 
 
    References 
    ---------- 
 
    .. [1] R. A. Fisher. The Design of Experiments, 6th Ed (1951). 
    .. [2] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be 
       Zero: Calculating Exact P-values When Permutations Are Randomly Drawn.&quot; 
       Statistical Applications in Genetics and Molecular Biology 9.1 (2010). 
    .. [3] M. D. Ernst. &quot;Permutation Methods: A Basis for Exact Inference&quot;. 
       Statistical Science (2004). 
    .. [4] B. Efron and R. J. Tibshirani. An Introduction to the Bootstrap 
       (1993). 
 
    Examples 
    -------- 
 
    Suppose we wish to test whether two samples are drawn from the same 
    distribution. Assume that the underlying distributions are unknown to us, 
    and that before observing the data, we hypothesized that the mean of the 
    first sample would be less than that of the second sample. We decide that 
    we will use the difference between the sample means as a test statistic, 
    and we will consider a p-value of 0.05 to be statistically significant. 
 
    For efficiency, we write the function defining the test statistic in a 
    vectorized fashion: the samples ``x`` and ``y`` can be ND arrays, and the 
    statistic will be calculated for each axis-slice along `axis`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; def statistic(x, y, axis): 
    ...     return np.mean(x, axis=axis) - np.mean(y, axis=axis) 
 
    After collecting our data, we calculate the observed value of the test 
    statistic. 
 
    &gt;&gt;&gt; from scipy.stats import norm 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = norm.rvs(size=5, random_state=rng) 
    &gt;&gt;&gt; y = norm.rvs(size=6, loc = 3, random_state=rng) 
    &gt;&gt;&gt; statistic(x, y, 0) 
    -3.5411688580987266 
 
    Indeed, the test statistic is negative, suggesting that the true mean of 
    the distribution underlying ``x`` is less than that of the distribution 
    underlying ``y``. To determine the probability of this occuring by chance 
    if the two samples were drawn from the same distribution, we perform 
    a permutation test. 
 
    &gt;&gt;&gt; from scipy.stats import permutation_test 
    &gt;&gt;&gt; # because our statistic is vectorized, we pass `vectorized=True` 
    &gt;&gt;&gt; # `n_resamples=np.inf` indicates that an exact test is to be performed 
    &gt;&gt;&gt; res = permutation_test((x, y), statistic, vectorized=True, 
    ...                        n_resamples=np.inf, alternative='less') 
    &gt;&gt;&gt; print(res.statistic) 
    -3.5411688580987266 
    &gt;&gt;&gt; print(res.pvalue) 
    0.004329004329004329 
 
    The probability of obtaining a test statistic less than or equal to the 
    observed value under the null hypothesis is 0.4329%. This is less than our 
    chosen threshold of 5%, so we consider this to be significant evidence 
    against the null hypothesis in favor of the alternative. 
 
    Because the size of the samples above was small, `permutation_test` could 
    perform an exact test. For larger samples, we resort to a randomized 
    permutation test. 
 
    &gt;&gt;&gt; x = norm.rvs(size=100, random_state=rng) 
    &gt;&gt;&gt; y = norm.rvs(size=120, loc=0.3, random_state=rng) 
    &gt;&gt;&gt; res = permutation_test((x, y), statistic, n_resamples=100000, 
    ...                        vectorized=True, alternative='less', 
    ...                        random_state=rng) 
    &gt;&gt;&gt; print(res.statistic) 
    -0.5230459671240913 
    &gt;&gt;&gt; print(res.pvalue) 
    0.00016999830001699983 
 
    The approximate probability of obtaining a test statistic less than or 
    equal to the observed value under the null hypothesis is 0.0225%. This is 
    again less than our chosen threshold of 5%, so again we have significant 
    evidence to reject the null hypothesis in favor of the alternative. 
 
    For large samples and number of permutations, the result is comparable to 
    that of the corresponding asymptotic test, the independent sample t-test. 
 
    &gt;&gt;&gt; from scipy.stats import ttest_ind 
    &gt;&gt;&gt; res_asymptotic = ttest_ind(x, y, alternative='less') 
    &gt;&gt;&gt; print(res_asymptotic.pvalue) 
    0.00012688101537979522 
 
    The permutation distribution of the test statistic is provided for 
    further investigation. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.hist(res.null_distribution, bins=50) 
    &gt;&gt;&gt; plt.title(&quot;Permutation distribution of test statistic&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Value of Statistic&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Frequency&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    Inspection of the null distribution is essential if the statistic suffers 
    from inaccuracy due to limited machine precision. Consider the following 
    case: 
 
    &gt;&gt;&gt; from scipy.stats import pearsonr 
    &gt;&gt;&gt; x = [1, 2, 4, 3] 
    &gt;&gt;&gt; y = [2, 4, 6, 8] 
    &gt;&gt;&gt; def statistic(x, y): 
    ...     return pearsonr(x, y).statistic 
    &gt;&gt;&gt; res = permutation_test((x, y), statistic, vectorized=False, 
    ...                        permutation_type='pairings', 
    ...                        alternative='greater') 
    &gt;&gt;&gt; r, pvalue, null = res.statistic, res.pvalue, res.null_distribution 
 
    In this case, some elements of the null distribution differ from the 
    observed value of the correlation coefficient ``r`` due to numerical noise. 
    We manually inspect the elements of the null distribution that are nearly 
    the same as the observed value of the test statistic. 
 
    &gt;&gt;&gt; r 
    0.8 
    &gt;&gt;&gt; unique = np.unique(null) 
    &gt;&gt;&gt; unique 
    array([-1. , -0.8, -0.8, -0.6, -0.4, -0.2, -0.2,  0. ,  0.2,  0.2,  0.4, 
            0.6,  0.8,  0.8,  1. ]) # may vary 
    &gt;&gt;&gt; unique[np.isclose(r, unique)].tolist() 
    [0.7999999999999999, 0.8] 
 
    If `permutation_test` were to perform the comparison naively, the 
    elements of the null distribution with value ``0.7999999999999999`` would 
    not be considered as extreme or more extreme as the observed value of the 
    statistic, so the calculated p-value would be too small. 
 
    &gt;&gt;&gt; incorrect_pvalue = np.count_nonzero(null &gt;= r) / len(null) 
    &gt;&gt;&gt; incorrect_pvalue 
    0.1111111111111111  # may vary 
 
    Instead, `permutation_test` treats elements of the null distribution that 
    are within ``max(1e-14, abs(r)*1e-14)`` of the observed value of the 
    statistic ``r`` to be equal to ``r``. 
 
    &gt;&gt;&gt; correct_pvalue = np.count_nonzero(null &gt;= r - 1e-14) / len(null) 
    &gt;&gt;&gt; correct_pvalue 
    0.16666666666666666 
    &gt;&gt;&gt; res.pvalue == correct_pvalue 
    True 
 
    This method of comparison is expected to be accurate in most practical 
    situations, but the user is advised to assess this by inspecting the 
    elements of the null distribution that are close to the observed value 
    of the statistic. Also, consider the use of statistics that can be 
    calculated using exact arithmetic (e.g. integer statistics). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">args = _permutation_test_iv(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">permutation_type</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">,</span>
                                <span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">,</span>
                                <span class="s1">random_state)</span>
    <span class="s1">(data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">permutation_type</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">batch</span><span class="s0">,</span>
     <span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">random_state) = args</span>

    <span class="s1">observed = statistic(*data</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">null_calculators = {</span><span class="s2">&quot;pairings&quot;</span><span class="s1">: _calculate_null_pairings</span><span class="s0">,</span>
                        <span class="s2">&quot;samples&quot;</span><span class="s1">: _calculate_null_samples</span><span class="s0">,</span>
                        <span class="s2">&quot;independent&quot;</span><span class="s1">: _calculate_null_both}</span>
    <span class="s1">null_calculator_args = (data</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">,</span>
                            <span class="s1">batch</span><span class="s0">, </span><span class="s1">random_state)</span>
    <span class="s1">calculate_null = null_calculators[permutation_type]</span>
    <span class="s1">null_distribution</span><span class="s0">, </span><span class="s1">n_resamples</span><span class="s0">, </span><span class="s1">exact_test = (</span>
        <span class="s1">calculate_null(*null_calculator_args))</span>

    <span class="s4"># See References [2] and [3]</span>
    <span class="s1">adjustment = </span><span class="s5">0 </span><span class="s0">if </span><span class="s1">exact_test </span><span class="s0">else </span><span class="s5">1</span>

    <span class="s4"># relative tolerance for detecting numerically distinct but</span>
    <span class="s4"># theoretically equal values in the null distribution</span>
    <span class="s1">eps = </span><span class="s5">1e-14</span>
    <span class="s1">gamma = np.maximum(eps</span><span class="s0">, </span><span class="s1">np.abs(eps * observed))</span>

    <span class="s0">def </span><span class="s1">less(null_distribution</span><span class="s0">, </span><span class="s1">observed):</span>
        <span class="s1">cmps = null_distribution &lt;= observed + gamma</span>
        <span class="s1">pvalues = (cmps.sum(axis=</span><span class="s5">0</span><span class="s1">) + adjustment) / (n_resamples + adjustment)</span>
        <span class="s0">return </span><span class="s1">pvalues</span>

    <span class="s0">def </span><span class="s1">greater(null_distribution</span><span class="s0">, </span><span class="s1">observed):</span>
        <span class="s1">cmps = null_distribution &gt;= observed - gamma</span>
        <span class="s1">pvalues = (cmps.sum(axis=</span><span class="s5">0</span><span class="s1">) + adjustment) / (n_resamples + adjustment)</span>
        <span class="s0">return </span><span class="s1">pvalues</span>

    <span class="s0">def </span><span class="s1">two_sided(null_distribution</span><span class="s0">, </span><span class="s1">observed):</span>
        <span class="s1">pvalues_less = less(null_distribution</span><span class="s0">, </span><span class="s1">observed)</span>
        <span class="s1">pvalues_greater = greater(null_distribution</span><span class="s0">, </span><span class="s1">observed)</span>
        <span class="s1">pvalues = np.minimum(pvalues_less</span><span class="s0">, </span><span class="s1">pvalues_greater) * </span><span class="s5">2</span>
        <span class="s0">return </span><span class="s1">pvalues</span>

    <span class="s1">compare = {</span><span class="s2">&quot;less&quot;</span><span class="s1">: less</span><span class="s0">,</span>
               <span class="s2">&quot;greater&quot;</span><span class="s1">: greater</span><span class="s0">,</span>
               <span class="s2">&quot;two-sided&quot;</span><span class="s1">: two_sided}</span>

    <span class="s1">pvalues = compare[alternative](null_distribution</span><span class="s0">, </span><span class="s1">observed)</span>
    <span class="s1">pvalues = np.clip(pvalues</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">PermutationTestResult(observed</span><span class="s0">, </span><span class="s1">pvalues</span><span class="s0">, </span><span class="s1">null_distribution)</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">ResamplingMethod:</span>
    <span class="s3">&quot;&quot;&quot;Configuration information for a statistical resampling method. 
 
    Instances of this class can be passed into the `method` parameter of some 
    hypothesis test functions to perform a resampling or Monte Carlo version 
    of the hypothesis test. 
 
    Attributes 
    ---------- 
    n_resamples : int 
        The number of resamples to perform or Monte Carlo samples to draw. 
    batch : int, optional 
        The number of resamples to process in each vectorized call to 
        the statistic. Batch sizes &gt;&gt;1 tend to be faster when the statistic 
        is vectorized, but memory usage scales linearly with the batch size. 
        Default is ``None``, which processes all resamples in a single batch. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_resamples: int = </span><span class="s5">9999</span>
    <span class="s1">batch: int = </span><span class="s0">None  </span><span class="s4"># type: ignore[assignment]</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">MonteCarloMethod(ResamplingMethod):</span>
    <span class="s3">&quot;&quot;&quot;Configuration information for a Monte Carlo hypothesis test. 
 
    Instances of this class can be passed into the `method` parameter of some 
    hypothesis test functions to perform a Monte Carlo version of the 
    hypothesis tests. 
 
    Attributes 
    ---------- 
    n_resamples : int, optional 
        The number of Monte Carlo samples to draw. Default is 9999. 
    batch : int, optional 
        The number of Monte Carlo samples to process in each vectorized call to 
        the statistic. Batch sizes &gt;&gt;1 tend to be faster when the statistic 
        is vectorized, but memory usage scales linearly with the batch size. 
        Default is ``None``, which processes all samples in a single batch. 
    rvs : callable or tuple of callables, optional 
        A callable or sequence of callables that generates random variates 
        under the null hypothesis. Each element of `rvs` must be a callable 
        that accepts keyword argument ``size`` (e.g. ``rvs(size=(m, n))``) and 
        returns an N-d array sample of that shape. If `rvs` is a sequence, the 
        number of callables in `rvs` must match the number of samples passed 
        to the hypothesis test in which the `MonteCarloMethod` is used. Default 
        is ``None``, in which case the hypothesis test function chooses values 
        to match the standard version of the hypothesis test. For example, 
        the null hypothesis of `scipy.stats.pearsonr` is typically that the 
        samples are drawn from the standard normal distribution, so 
        ``rvs = (rng.normal, rng.normal)`` where 
        ``rng = np.random.default_rng()``. 
    &quot;&quot;&quot;</span>
    <span class="s1">rvs: object = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_asdict(self):</span>
        <span class="s4"># `dataclasses.asdict` deepcopies; we don't want that.</span>
        <span class="s0">return </span><span class="s1">dict(n_resamples=self.n_resamples</span><span class="s0">, </span><span class="s1">batch=self.batch</span><span class="s0">,</span>
                    <span class="s1">rvs=self.rvs)</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">PermutationMethod(ResamplingMethod):</span>
    <span class="s3">&quot;&quot;&quot;Configuration information for a permutation hypothesis test. 
 
    Instances of this class can be passed into the `method` parameter of some 
    hypothesis test functions to perform a permutation version of the 
    hypothesis tests. 
 
    Attributes 
    ---------- 
    n_resamples : int, optional 
        The number of resamples to perform. Default is 9999. 
    batch : int, optional 
        The number of resamples to process in each vectorized call to 
        the statistic. Batch sizes &gt;&gt;1 tend to be faster when the statistic 
        is vectorized, but memory usage scales linearly with the batch size. 
        Default is ``None``, which processes all resamples in a single batch. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        Pseudorandom number generator state used to generate resamples. 
 
        If `random_state` is already a ``Generator`` or ``RandomState`` 
        instance, then that instance is used. 
        If `random_state` is an int, a new ``RandomState`` instance is used, 
        seeded with `random_state`. 
        If `random_state` is ``None`` (default), the 
        `numpy.random.RandomState` singleton is used. 
    &quot;&quot;&quot;</span>
    <span class="s1">random_state: object = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_asdict(self):</span>
        <span class="s4"># `dataclasses.asdict` deepcopies; we don't want that.</span>
        <span class="s0">return </span><span class="s1">dict(n_resamples=self.n_resamples</span><span class="s0">, </span><span class="s1">batch=self.batch</span><span class="s0">,</span>
                    <span class="s1">random_state=self.random_state)</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">BootstrapMethod(ResamplingMethod):</span>
    <span class="s3">&quot;&quot;&quot;Configuration information for a bootstrap confidence interval. 
 
    Instances of this class can be passed into the `method` parameter of some 
    confidence interval methods to generate a bootstrap confidence interval. 
 
    Attributes 
    ---------- 
    n_resamples : int, optional 
        The number of resamples to perform. Default is 9999. 
    batch : int, optional 
        The number of resamples to process in each vectorized call to 
        the statistic. Batch sizes &gt;&gt;1 tend to be faster when the statistic 
        is vectorized, but memory usage scales linearly with the batch size. 
        Default is ``None``, which processes all resamples in a single batch. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        Pseudorandom number generator state used to generate resamples. 
 
        If `random_state` is already a ``Generator`` or ``RandomState`` 
        instance, then that instance is used. 
        If `random_state` is an int, a new ``RandomState`` instance is used, 
        seeded with `random_state`. 
        If `random_state` is ``None`` (default), the 
        `numpy.random.RandomState` singleton is used. 
 
    method : {'bca', 'percentile', 'basic'} 
        Whether to use the 'percentile' bootstrap ('percentile'), the 'basic' 
        (AKA 'reverse') bootstrap ('basic'), or the bias-corrected and 
        accelerated bootstrap ('BCa', default). 
    &quot;&quot;&quot;</span>
    <span class="s1">random_state: object = </span><span class="s0">None</span>
    <span class="s1">method: str = </span><span class="s2">'BCa'</span>

    <span class="s0">def </span><span class="s1">_asdict(self):</span>
        <span class="s4"># `dataclasses.asdict` deepcopies; we don't want that.</span>
        <span class="s0">return </span><span class="s1">dict(n_resamples=self.n_resamples</span><span class="s0">, </span><span class="s1">batch=self.batch</span><span class="s0">,</span>
                    <span class="s1">random_state=self.random_state</span><span class="s0">, </span><span class="s1">method=self.method)</span>
</pre>
</body>
</html>