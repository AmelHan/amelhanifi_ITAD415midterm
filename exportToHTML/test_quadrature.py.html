<html>
<head>
<title>test_quadrature.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_quadrature.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">cos</span><span class="s0">, </span><span class="s1">sin</span><span class="s0">, </span><span class="s1">pi</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_equal</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">,</span>
                           <span class="s1">assert_</span><span class="s0">, </span><span class="s1">suppress_warnings)</span>

<span class="s0">from </span><span class="s1">scipy.integrate </span><span class="s0">import </span><span class="s1">(quadrature</span><span class="s0">, </span><span class="s1">romberg</span><span class="s0">, </span><span class="s1">romb</span><span class="s0">, </span><span class="s1">newton_cotes</span><span class="s0">,</span>
                             <span class="s1">cumulative_trapezoid</span><span class="s0">, </span><span class="s1">cumtrapz</span><span class="s0">, </span><span class="s1">trapz</span><span class="s0">, </span><span class="s1">trapezoid</span><span class="s0">,</span>
                             <span class="s1">quad</span><span class="s0">, </span><span class="s1">simpson</span><span class="s0">, </span><span class="s1">simps</span><span class="s0">, </span><span class="s1">fixed_quad</span><span class="s0">, </span><span class="s1">AccuracyWarning</span><span class="s0">,</span>
                             <span class="s1">qmc_quad)</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span><span class="s0">, </span><span class="s1">special </span><span class="s0">as </span><span class="s1">sc</span>


<span class="s0">class </span><span class="s1">TestFixedQuad:</span>
    <span class="s0">def </span><span class="s1">test_scalar(self):</span>
        <span class="s1">n = </span><span class="s2">4</span>
        <span class="s1">expected = </span><span class="s2">1</span><span class="s1">/(</span><span class="s2">2</span><span class="s1">*n)</span>
        <span class="s1">got</span><span class="s0">, </span><span class="s1">_ = fixed_quad(</span><span class="s0">lambda </span><span class="s1">x: x**(</span><span class="s2">2</span><span class="s1">*n - </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">n=n)</span>
        <span class="s3"># quadrature exact for this input</span>
        <span class="s1">assert_allclose(got</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vector(self):</span>
        <span class="s1">n = </span><span class="s2">4</span>
        <span class="s1">p = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*n)</span>
        <span class="s1">expected = </span><span class="s2">1</span><span class="s1">/(p + </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">got</span><span class="s0">, </span><span class="s1">_ = fixed_quad(</span><span class="s0">lambda </span><span class="s1">x: x**p[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">n=n)</span>
        <span class="s1">assert_allclose(got</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestQuadrature:</span>
    <span class="s0">def </span><span class="s1">quad(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">args):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">test_quadrature(self):</span>
        <span class="s3"># Typical function with two extra arguments:</span>
        <span class="s0">def </span><span class="s1">myfunc(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">z):       </span><span class="s3"># Bessel function integrand</span>
            <span class="s0">return </span><span class="s1">cos(n*x-z*sin(x))/pi</span>
        <span class="s1">val</span><span class="s0">, </span><span class="s1">err = quadrature(myfunc</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.8</span><span class="s1">))</span>
        <span class="s1">table_val = </span><span class="s2">0.30614353532540296487</span>
        <span class="s1">assert_almost_equal(val</span><span class="s0">, </span><span class="s1">table_val</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_quadrature_rtol(self):</span>
        <span class="s0">def </span><span class="s1">myfunc(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">z):       </span><span class="s3"># Bessel function integrand</span>
            <span class="s0">return </span><span class="s2">1e90 </span><span class="s1">* cos(n*x-z*sin(x))/pi</span>
        <span class="s1">val</span><span class="s0">, </span><span class="s1">err = quadrature(myfunc</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>
        <span class="s1">table_val = </span><span class="s2">1e90 </span><span class="s1">* </span><span class="s2">0.30614353532540296487</span>
        <span class="s1">assert_allclose(val</span><span class="s0">, </span><span class="s1">table_val</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_quadrature_miniter(self):</span>
        <span class="s3"># Typical function with two extra arguments:</span>
        <span class="s0">def </span><span class="s1">myfunc(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">z):       </span><span class="s3"># Bessel function integrand</span>
            <span class="s0">return </span><span class="s1">cos(n*x-z*sin(x))/pi</span>
        <span class="s1">table_val = </span><span class="s2">0.30614353532540296487</span>
        <span class="s0">for </span><span class="s1">miniter </span><span class="s0">in </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">52</span><span class="s1">]:</span>
            <span class="s1">val</span><span class="s0">, </span><span class="s1">err = quadrature(myfunc</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">miniter=miniter)</span>
            <span class="s1">assert_almost_equal(val</span><span class="s0">, </span><span class="s1">table_val</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">7</span><span class="s1">)</span>
            <span class="s1">assert_(err &lt; </span><span class="s2">1.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_quadrature_single_args(self):</span>
        <span class="s0">def </span><span class="s1">myfunc(x</span><span class="s0">, </span><span class="s1">n):</span>
            <span class="s0">return </span><span class="s2">1e90 </span><span class="s1">* cos(n*x-</span><span class="s2">1.8</span><span class="s1">*sin(x))/pi</span>
        <span class="s1">val</span><span class="s0">, </span><span class="s1">err = quadrature(myfunc</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, </span><span class="s1">args=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>
        <span class="s1">table_val = </span><span class="s2">1e90 </span><span class="s1">* </span><span class="s2">0.30614353532540296487</span>
        <span class="s1">assert_allclose(val</span><span class="s0">, </span><span class="s1">table_val</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_romberg(self):</span>
        <span class="s3"># Typical function with two extra arguments:</span>
        <span class="s0">def </span><span class="s1">myfunc(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">z):       </span><span class="s3"># Bessel function integrand</span>
            <span class="s0">return </span><span class="s1">cos(n*x-z*sin(x))/pi</span>
        <span class="s1">val = romberg(myfunc</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, </span><span class="s1">args=(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.8</span><span class="s1">))</span>
        <span class="s1">table_val = </span><span class="s2">0.30614353532540296487</span>
        <span class="s1">assert_almost_equal(val</span><span class="s0">, </span><span class="s1">table_val</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_romberg_rtol(self):</span>
        <span class="s3"># Typical function with two extra arguments:</span>
        <span class="s0">def </span><span class="s1">myfunc(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">z):       </span><span class="s3"># Bessel function integrand</span>
            <span class="s0">return </span><span class="s2">1e19</span><span class="s1">*cos(n*x-z*sin(x))/pi</span>
        <span class="s1">val = romberg(myfunc</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, </span><span class="s1">args=(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1.8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>
        <span class="s1">table_val = </span><span class="s2">1e19</span><span class="s1">*</span><span class="s2">0.30614353532540296487</span>
        <span class="s1">assert_allclose(val</span><span class="s0">, </span><span class="s1">table_val</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_romb(self):</span>
        <span class="s1">assert_equal(romb(np.arange(</span><span class="s2">17</span><span class="s1">))</span><span class="s0">, </span><span class="s2">128</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_romb_gh_3731(self):</span>
        <span class="s3"># Check that romb makes maximal use of data points</span>
        <span class="s1">x = np.arange(</span><span class="s2">2</span><span class="s1">**</span><span class="s2">4</span><span class="s1">+</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">y = np.cos(</span><span class="s2">0.2</span><span class="s1">*x)</span>
        <span class="s1">val = romb(y)</span>
        <span class="s1">val2</span><span class="s0">, </span><span class="s1">err = quad(</span><span class="s0">lambda </span><span class="s1">x: np.cos(</span><span class="s2">0.2</span><span class="s1">*x)</span><span class="s0">, </span><span class="s1">x.min()</span><span class="s0">, </span><span class="s1">x.max())</span>
        <span class="s1">assert_allclose(val</span><span class="s0">, </span><span class="s1">val2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0</span><span class="s1">)</span>

        <span class="s3"># should be equal to romb with 2**k+1 samples</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(AccuracyWarning</span><span class="s0">, </span><span class="s4">&quot;divmax .4. exceeded&quot;</span><span class="s1">)</span>
            <span class="s1">val3 = romberg(</span><span class="s0">lambda </span><span class="s1">x: np.cos(</span><span class="s2">0.2</span><span class="s1">*x)</span><span class="s0">, </span><span class="s1">x.min()</span><span class="s0">, </span><span class="s1">x.max()</span><span class="s0">, </span><span class="s1">divmax=</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(val</span><span class="s0">, </span><span class="s1">val3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_non_dtype(self):</span>
        <span class="s3"># Check that we work fine with functions returning float</span>
        <span class="s0">import </span><span class="s1">math</span>
        <span class="s1">valmath = romberg(math.sin</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">expected_val = </span><span class="s2">0.45969769413185085</span>
        <span class="s1">assert_almost_equal(valmath</span><span class="s0">, </span><span class="s1">expected_val</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_newton_cotes(self):</span>
        <span class="s5">&quot;&quot;&quot;Test the first few degrees, for evenly spaced points.&quot;&quot;&quot;</span>
        <span class="s1">n = </span><span class="s2">1</span>
        <span class="s1">wts</span><span class="s0">, </span><span class="s1">errcoff = newton_cotes(n</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(wts</span><span class="s0">, </span><span class="s1">n*np.array([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(errcoff</span><span class="s0">, </span><span class="s1">-n**</span><span class="s2">3</span><span class="s1">/</span><span class="s2">12.0</span><span class="s1">)</span>

        <span class="s1">n = </span><span class="s2">2</span>
        <span class="s1">wts</span><span class="s0">, </span><span class="s1">errcoff = newton_cotes(n</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(wts</span><span class="s0">, </span><span class="s1">n*np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">4.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])/</span><span class="s2">6.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(errcoff</span><span class="s0">, </span><span class="s1">-n**</span><span class="s2">5</span><span class="s1">/</span><span class="s2">2880.0</span><span class="s1">)</span>

        <span class="s1">n = </span><span class="s2">3</span>
        <span class="s1">wts</span><span class="s0">, </span><span class="s1">errcoff = newton_cotes(n</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(wts</span><span class="s0">, </span><span class="s1">n*np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])/</span><span class="s2">8.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(errcoff</span><span class="s0">, </span><span class="s1">-n**</span><span class="s2">5</span><span class="s1">/</span><span class="s2">6480.0</span><span class="s1">)</span>

        <span class="s1">n = </span><span class="s2">4</span>
        <span class="s1">wts</span><span class="s0">, </span><span class="s1">errcoff = newton_cotes(n</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(wts</span><span class="s0">, </span><span class="s1">n*np.array([</span><span class="s2">7.0</span><span class="s0">, </span><span class="s2">32.0</span><span class="s0">, </span><span class="s2">12.0</span><span class="s0">, </span><span class="s2">32.0</span><span class="s0">, </span><span class="s2">7.0</span><span class="s1">])/</span><span class="s2">90.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(errcoff</span><span class="s0">, </span><span class="s1">-n**</span><span class="s2">7</span><span class="s1">/</span><span class="s2">1935360.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_newton_cotes2(self):</span>
        <span class="s5">&quot;&quot;&quot;Test newton_cotes with points that are not evenly spaced.&quot;&quot;&quot;</span>

        <span class="s1">x = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">y = x**</span><span class="s2">2</span>
        <span class="s1">wts</span><span class="s0">, </span><span class="s1">errcoff = newton_cotes(x)</span>
        <span class="s1">exact_integral = </span><span class="s2">8.0</span><span class="s1">/</span><span class="s2">3</span>
        <span class="s1">numeric_integral = np.dot(wts</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_almost_equal(numeric_integral</span><span class="s0">, </span><span class="s1">exact_integral)</span>

        <span class="s1">x = np.array([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">])</span>
        <span class="s1">y = x**</span><span class="s2">2</span>
        <span class="s1">wts</span><span class="s0">, </span><span class="s1">errcoff = newton_cotes(x)</span>
        <span class="s1">exact_integral = </span><span class="s2">9.0</span>
        <span class="s1">numeric_integral = np.dot(wts</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_almost_equal(numeric_integral</span><span class="s0">, </span><span class="s1">exact_integral)</span>

    <span class="s3"># ignore the DeprecationWarning emitted by the even kwd</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">'ignore::DeprecationWarning'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_simpson(self):</span>
        <span class="s1">y = np.arange(</span><span class="s2">17</span><span class="s1">)</span>
        <span class="s1">assert_equal(simpson(y)</span><span class="s0">, </span><span class="s2">128</span><span class="s1">)</span>
        <span class="s1">assert_equal(simpson(y</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s2">64</span><span class="s1">)</span>
        <span class="s1">assert_equal(simpson(y</span><span class="s0">, </span><span class="s1">x=np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">17</span><span class="s1">))</span><span class="s0">, </span><span class="s2">32</span><span class="s1">)</span>

        <span class="s1">y = np.arange(</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s2">2</span><span class="s1">**y</span>
        <span class="s1">assert_equal(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'avg'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">13.875</span><span class="s1">)</span>
        <span class="s1">assert_equal(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'first'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">13.75</span><span class="s1">)</span>
        <span class="s1">assert_equal(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'last'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">14</span><span class="s1">)</span>

        <span class="s3"># `even='simpson'`</span>
        <span class="s3"># integral should be exactly 21</span>
        <span class="s1">x = np.linspace(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s0">return </span><span class="s1">x**</span><span class="s2">2</span>

        <span class="s1">assert_allclose(simpson(f(x)</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'simpson'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">21.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(simpson(f(x)</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'avg'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">21 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">/</span><span class="s2">6</span><span class="s1">)</span>

        <span class="s3"># integral should be exactly 114</span>
        <span class="s1">x = np.linspace(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(simpson(f(x)</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">2.0</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'simpson'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">114</span><span class="s1">)</span>
        <span class="s1">assert_allclose(simpson(f(x)</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">2.0</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'avg'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">115 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s1">)</span>

        <span class="s3"># `even='simpson'`, test multi-axis behaviour</span>
        <span class="s1">a = np.arange(</span><span class="s2">16</span><span class="s1">).reshape(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">x = np.arange(</span><span class="s2">64.</span><span class="s1">).reshape(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">y = f(x)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">):</span>
            <span class="s1">r = simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'simpson'</span><span class="s0">, </span><span class="s1">axis=i)</span>
            <span class="s1">it = np.nditer(a</span><span class="s0">, </span><span class="s1">flags=[</span><span class="s4">'multi_index'</span><span class="s1">])</span>
            <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">it:</span>
                <span class="s1">idx = list(it.multi_index)</span>
                <span class="s1">idx.insert(i</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span>
                <span class="s1">integral = x[tuple(idx)][-</span><span class="s2">1</span><span class="s1">]**</span><span class="s2">3 </span><span class="s1">/ </span><span class="s2">3 </span><span class="s1">- x[tuple(idx)][</span><span class="s2">0</span><span class="s1">]**</span><span class="s2">3 </span><span class="s1">/ </span><span class="s2">3</span>
                <span class="s1">assert_allclose(r[it.multi_index]</span><span class="s0">, </span><span class="s1">integral)</span>

        <span class="s3"># test when integration axis only has two points</span>
        <span class="s1">x = np.arange(</span><span class="s2">16</span><span class="s1">).reshape(</span><span class="s2">8</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">y = f(x)</span>
        <span class="s0">for </span><span class="s1">even </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'simpson'</span><span class="s0">, </span><span class="s4">'avg'</span><span class="s0">, </span><span class="s4">'first'</span><span class="s0">, </span><span class="s4">'last'</span><span class="s1">]:</span>
            <span class="s1">r = simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">even=even</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span>

            <span class="s1">integral = </span><span class="s2">0.5 </span><span class="s1">* (y[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] + y[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]) * (x[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] - x[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
            <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s1">integral)</span>

        <span class="s3"># odd points, test multi-axis behaviour</span>
        <span class="s1">a = np.arange(</span><span class="s2">25</span><span class="s1">).reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">x = np.arange(</span><span class="s2">125</span><span class="s1">).reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">y = f(x)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">):</span>
            <span class="s1">r = simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=i)</span>
            <span class="s1">it = np.nditer(a</span><span class="s0">, </span><span class="s1">flags=[</span><span class="s4">'multi_index'</span><span class="s1">])</span>
            <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">it:</span>
                <span class="s1">idx = list(it.multi_index)</span>
                <span class="s1">idx.insert(i</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span>
                <span class="s1">integral = x[tuple(idx)][-</span><span class="s2">1</span><span class="s1">]**</span><span class="s2">3 </span><span class="s1">/ </span><span class="s2">3 </span><span class="s1">- x[tuple(idx)][</span><span class="s2">0</span><span class="s1">]**</span><span class="s2">3 </span><span class="s1">/ </span><span class="s2">3</span>
                <span class="s1">assert_allclose(r[it.multi_index]</span><span class="s0">, </span><span class="s1">integral)</span>

        <span class="s3"># Tests for checking base case</span>
        <span class="s1">x = np.array([</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">y = np.power(x</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">)</span>

        <span class="s1">x = np.array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">y = np.power(x</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">)</span>

        <span class="s1">x = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]])</span>
        <span class="s1">y = np.power(x</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">zero_axis = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span>
        <span class="s1">default_axis = [</span><span class="s2">170 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s1">] * </span><span class="s2">3   </span><span class="s3"># 8**3 / 3 - 1/3</span>
        <span class="s1">assert_allclose(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">zero_axis)</span>
        <span class="s3"># the following should be exact for even='simpson'</span>
        <span class="s1">assert_allclose(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default_axis)</span>

        <span class="s1">x = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">32</span><span class="s1">]])</span>
        <span class="s1">y = np.power(x</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">zero_axis = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">136.0</span><span class="s0">, </span><span class="s2">1088.0</span><span class="s0">, </span><span class="s2">8704.0</span><span class="s1">]</span>
        <span class="s1">default_axis = [</span><span class="s2">170 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s0">, </span><span class="s2">170 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s0">, </span><span class="s2">32</span><span class="s1">**</span><span class="s2">3 </span><span class="s1">/ </span><span class="s2">3 </span><span class="s1">- </span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">assert_allclose(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">zero_axis)</span>
        <span class="s1">assert_allclose(simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default_axis)</span>

    <span class="s0">def </span><span class="s1">test_simpson_even_is_deprecated(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">y = x**</span><span class="s2">2</span>
        <span class="s0">with </span><span class="s1">pytest.deprecated_call():</span>
            <span class="s1">simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">even=</span><span class="s4">'first'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'droplast'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_simpson_2d_integer_no_x(self</span><span class="s0">, </span><span class="s1">droplast):</span>
        <span class="s3"># The inputs are 2d integer arrays.  The results should be</span>
        <span class="s3"># identical to the results when the inputs are floating point.</span>
        <span class="s1">y = np.array([[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">22</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]])</span>
        <span class="s0">if </span><span class="s1">droplast:</span>
            <span class="s1">y = y[:</span><span class="s0">, </span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">result = simpson(y</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">expected = simpson(np.array(y</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_simps(self):</span>
        <span class="s3"># Basic coverage test for the alias</span>
        <span class="s1">y = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s2">2</span><span class="s1">**y</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">simps(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestCumulative_trapezoid:</span>
    <span class="s0">def </span><span class="s1">test_1d(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">num=</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">y = x</span>
        <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">y_expected = [</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span>
        <span class="s1">assert_allclose(y_int</span><span class="s0">, </span><span class="s1">y_expected)</span>

        <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_allclose(y_int</span><span class="s0">, </span><span class="s1">y_expected[</span><span class="s2">1</span><span class="s1">:])</span>

    <span class="s0">def </span><span class="s1">test_y_nd_x_nd(self):</span>
        <span class="s1">x = np.arange(</span><span class="s2">3 </span><span class="s1">* </span><span class="s2">2 </span><span class="s1">* </span><span class="s2">4</span><span class="s1">).reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">y = x</span>
        <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">y_expected = np.array([[[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">2.</span><span class="s0">, </span><span class="s2">4.5</span><span class="s1">]</span><span class="s0">,</span>
                                <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">4.5</span><span class="s0">, </span><span class="s2">10.</span><span class="s0">, </span><span class="s2">16.5</span><span class="s1">]]</span><span class="s0">,</span>
                               <span class="s1">[[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">8.5</span><span class="s0">, </span><span class="s2">18.</span><span class="s0">, </span><span class="s2">28.5</span><span class="s1">]</span><span class="s0">,</span>
                                <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">12.5</span><span class="s0">, </span><span class="s2">26.</span><span class="s0">, </span><span class="s2">40.5</span><span class="s1">]]</span><span class="s0">,</span>
                               <span class="s1">[[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">16.5</span><span class="s0">, </span><span class="s2">34.</span><span class="s0">, </span><span class="s2">52.5</span><span class="s1">]</span><span class="s0">,</span>
                                <span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">20.5</span><span class="s0">, </span><span class="s2">42.</span><span class="s0">, </span><span class="s2">64.5</span><span class="s1">]]])</span>

        <span class="s1">assert_allclose(y_int</span><span class="s0">, </span><span class="s1">y_expected)</span>

        <span class="s3"># Try with all axes</span>
        <span class="s1">shapes = [(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">shape </span><span class="s0">in </span><span class="s1">zip([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">shapes):</span>
            <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">3.45</span><span class="s0">, </span><span class="s1">axis=axis)</span>
            <span class="s1">assert_equal(y_int.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
            <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None, </span><span class="s1">axis=axis)</span>
            <span class="s1">assert_equal(y_int.shape</span><span class="s0">, </span><span class="s1">shape)</span>

    <span class="s0">def </span><span class="s1">test_y_nd_x_1d(self):</span>
        <span class="s1">y = np.arange(</span><span class="s2">3 </span><span class="s1">* </span><span class="s2">2 </span><span class="s1">* </span><span class="s2">4</span><span class="s1">).reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">x = np.arange(</span><span class="s2">4</span><span class="s1">)**</span><span class="s2">2</span>
        <span class="s3"># Try with all axes</span>
        <span class="s1">ys_expected = (</span>
            <span class="s1">np.array([[[</span><span class="s2">4.</span><span class="s0">, </span><span class="s2">5.</span><span class="s0">, </span><span class="s2">6.</span><span class="s0">, </span><span class="s2">7.</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s2">8.</span><span class="s0">, </span><span class="s2">9.</span><span class="s0">, </span><span class="s2">10.</span><span class="s0">, </span><span class="s2">11.</span><span class="s1">]]</span><span class="s0">,</span>
                      <span class="s1">[[</span><span class="s2">40.</span><span class="s0">, </span><span class="s2">44.</span><span class="s0">, </span><span class="s2">48.</span><span class="s0">, </span><span class="s2">52.</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s2">56.</span><span class="s0">, </span><span class="s2">60.</span><span class="s0">, </span><span class="s2">64.</span><span class="s0">, </span><span class="s2">68.</span><span class="s1">]]])</span><span class="s0">,</span>
            <span class="s1">np.array([[[</span><span class="s2">2.</span><span class="s0">, </span><span class="s2">3.</span><span class="s0">, </span><span class="s2">4.</span><span class="s0">, </span><span class="s2">5.</span><span class="s1">]]</span><span class="s0">,</span>
                      <span class="s1">[[</span><span class="s2">10.</span><span class="s0">, </span><span class="s2">11.</span><span class="s0">, </span><span class="s2">12.</span><span class="s0">, </span><span class="s2">13.</span><span class="s1">]]</span><span class="s0">,</span>
                      <span class="s1">[[</span><span class="s2">18.</span><span class="s0">, </span><span class="s2">19.</span><span class="s0">, </span><span class="s2">20.</span><span class="s0">, </span><span class="s2">21.</span><span class="s1">]]])</span><span class="s0">,</span>
            <span class="s1">np.array([[[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">5.</span><span class="s0">, </span><span class="s2">17.5</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s2">4.5</span><span class="s0">, </span><span class="s2">21.</span><span class="s0">, </span><span class="s2">53.5</span><span class="s1">]]</span><span class="s0">,</span>
                      <span class="s1">[[</span><span class="s2">8.5</span><span class="s0">, </span><span class="s2">37.</span><span class="s0">, </span><span class="s2">89.5</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s2">12.5</span><span class="s0">, </span><span class="s2">53.</span><span class="s0">, </span><span class="s2">125.5</span><span class="s1">]]</span><span class="s0">,</span>
                      <span class="s1">[[</span><span class="s2">16.5</span><span class="s0">, </span><span class="s2">69.</span><span class="s0">, </span><span class="s2">161.5</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s2">20.5</span><span class="s0">, </span><span class="s2">85.</span><span class="s0">, </span><span class="s2">197.5</span><span class="s1">]]]))</span>

        <span class="s0">for </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">y_expected </span><span class="s0">in </span><span class="s1">zip([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ys_expected):</span>
            <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x=x[:y.shape[axis]]</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">,</span>
                                         <span class="s1">initial=</span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">assert_allclose(y_int</span><span class="s0">, </span><span class="s1">y_expected)</span>

    <span class="s0">def </span><span class="s1">test_x_none(self):</span>
        <span class="s1">y = np.linspace(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">num=</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">y_int = cumulative_trapezoid(y)</span>
        <span class="s1">y_expected = [-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span>
        <span class="s1">assert_allclose(y_int</span><span class="s0">, </span><span class="s1">y_expected)</span>

        <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">1.23</span><span class="s1">)</span>
        <span class="s1">y_expected = [</span><span class="s2">1.23</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span>
        <span class="s1">assert_allclose(y_int</span><span class="s0">, </span><span class="s1">y_expected)</span>

        <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">y_expected = [-</span><span class="s2">4.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">6.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.5</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span>
        <span class="s1">assert_allclose(y_int</span><span class="s0">, </span><span class="s1">y_expected)</span>

        <span class="s1">y_int = cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">1.23</span><span class="s1">)</span>
        <span class="s1">y_expected = [</span><span class="s2">1.23</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">6.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.5</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span>
        <span class="s1">assert_allclose(y_int</span><span class="s0">, </span><span class="s1">y_expected)</span>

    <span class="s0">def </span><span class="s1">test_cumtrapz(self):</span>
        <span class="s3"># Basic coverage test for the alias</span>
        <span class="s1">x = np.arange(</span><span class="s2">3 </span><span class="s1">* </span><span class="s2">2 </span><span class="s1">* </span><span class="s2">4</span><span class="s1">).reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">y = x</span>
        <span class="s1">assert_allclose(cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">cumtrapz(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestTrapezoid:</span>
    <span class="s5">&quot;&quot;&quot;This function is tested in NumPy more extensive, just do some 
    basic due diligence here.&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_trapezoid(self):</span>
        <span class="s1">y = np.arange(</span><span class="s2">17</span><span class="s1">)</span>
        <span class="s1">assert_equal(trapezoid(y)</span><span class="s0">, </span><span class="s2">128</span><span class="s1">)</span>
        <span class="s1">assert_equal(trapezoid(y</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s2">64</span><span class="s1">)</span>
        <span class="s1">assert_equal(trapezoid(y</span><span class="s0">, </span><span class="s1">x=np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">17</span><span class="s1">))</span><span class="s0">, </span><span class="s2">32</span><span class="s1">)</span>

        <span class="s1">y = np.arange(</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s2">2</span><span class="s1">**y</span>
        <span class="s1">assert_equal(trapezoid(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">13.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_trapz(self):</span>
        <span class="s3"># Basic coverage test for the alias</span>
        <span class="s1">y = np.arange(</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s2">2</span><span class="s1">**y</span>
        <span class="s1">assert_equal(trapezoid(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">trapz(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestQMCQuad:</span>
    <span class="s0">def </span><span class="s1">test_input_validation(self):</span>
        <span class="s1">message = </span><span class="s4">&quot;`func` must be callable.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc_quad(</span><span class="s4">&quot;a duck&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">message = </span><span class="s4">&quot;`func` must evaluate the integrand at points...&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc_quad(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s0">def </span><span class="s1">func(x):</span>
            <span class="s0">assert </span><span class="s1">x.ndim == </span><span class="s2">1</span>
            <span class="s0">return </span><span class="s1">np.sum(x)</span>
        <span class="s1">message = </span><span class="s4">&quot;Exception encountered when attempting vectorized call...&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc_quad(func</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">message = </span><span class="s4">&quot;`n_points` must be an integer.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc_quad(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">n_points=</span><span class="s2">1024.5</span><span class="s1">)</span>

        <span class="s1">message = </span><span class="s4">&quot;`n_estimates` must be an integer.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc_quad(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">n_estimates=</span><span class="s2">8.5</span><span class="s1">)</span>

        <span class="s1">message = </span><span class="s4">&quot;`qrng` must be an instance of scipy.stats.qmc.QMCEngine.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc_quad(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">qrng=</span><span class="s4">&quot;a duck&quot;</span><span class="s1">)</span>

        <span class="s1">message = </span><span class="s4">&quot;`qrng` must be initialized with dimensionality equal to &quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc_quad(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">qrng=stats.qmc.Sobol(</span><span class="s2">1</span><span class="s1">))</span>

        <span class="s1">message = </span><span class="s4">r&quot;`log` must be boolean \(`True` or `False`\).&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc_quad(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">log=</span><span class="s2">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">basic_test(self</span><span class="s0">, </span><span class="s1">n_points=</span><span class="s2">2</span><span class="s1">**</span><span class="s2">8</span><span class="s0">, </span><span class="s1">n_estimates=</span><span class="s2">8</span><span class="s0">, </span><span class="s1">signs=np.ones(</span><span class="s2">2</span><span class="s1">)):</span>

        <span class="s1">ndim = </span><span class="s2">2</span>
        <span class="s1">mean = np.zeros(ndim)</span>
        <span class="s1">cov = np.eye(ndim)</span>

        <span class="s0">def </span><span class="s1">func(x):</span>
            <span class="s0">return </span><span class="s1">stats.multivariate_normal.pdf(x.T</span><span class="s0">, </span><span class="s1">mean</span><span class="s0">, </span><span class="s1">cov)</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s2">2879434385674690281</span><span class="s1">)</span>
        <span class="s1">qrng = stats.qmc.Sobol(ndim</span><span class="s0">, </span><span class="s1">seed=rng)</span>
        <span class="s1">a = np.zeros(ndim)</span>
        <span class="s1">b = np.ones(ndim) * signs</span>
        <span class="s1">res = qmc_quad(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n_points=n_points</span><span class="s0">,</span>
                       <span class="s1">n_estimates=n_estimates</span><span class="s0">, </span><span class="s1">qrng=qrng)</span>
        <span class="s1">ref = stats.multivariate_normal.cdf(b</span><span class="s0">, </span><span class="s1">mean</span><span class="s0">, </span><span class="s1">cov</span><span class="s0">, </span><span class="s1">lower_limit=a)</span>
        <span class="s1">atol = sc.stdtrit(n_estimates-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.995</span><span class="s1">) * res.standard_error  </span><span class="s3"># 99% CI</span>
        <span class="s1">assert_allclose(res.integral</span><span class="s0">, </span><span class="s1">ref</span><span class="s0">, </span><span class="s1">atol=atol)</span>
        <span class="s0">assert </span><span class="s1">np.prod(signs)*res.integral &gt; </span><span class="s2">0</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s2">2879434385674690281</span><span class="s1">)</span>
        <span class="s1">qrng = stats.qmc.Sobol(ndim</span><span class="s0">, </span><span class="s1">seed=rng)</span>
        <span class="s1">logres = qmc_quad(</span><span class="s0">lambda </span><span class="s1">*args: np.log(func(*args))</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">,</span>
                          <span class="s1">n_points=n_points</span><span class="s0">, </span><span class="s1">n_estimates=n_estimates</span><span class="s0">,</span>
                          <span class="s1">log=</span><span class="s0">True, </span><span class="s1">qrng=qrng)</span>
        <span class="s1">assert_allclose(np.exp(logres.integral)</span><span class="s0">, </span><span class="s1">res.integral</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.imag(logres.integral) == (np.pi </span><span class="s0">if </span><span class="s1">np.prod(signs) &lt; </span><span class="s2">0 </span><span class="s0">else </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.exp(logres.standard_error)</span><span class="s0">,</span>
                        <span class="s1">res.standard_error</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-16</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_points&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">**</span><span class="s2">8</span><span class="s0">, </span><span class="s2">2</span><span class="s1">**</span><span class="s2">12</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_estimates&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s2">16</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_basic(self</span><span class="s0">, </span><span class="s1">n_points</span><span class="s0">, </span><span class="s1">n_estimates):</span>
        <span class="s1">self.basic_test(n_points</span><span class="s0">, </span><span class="s1">n_estimates)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;signs&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_sign(self</span><span class="s0">, </span><span class="s1">signs):</span>
        <span class="s1">self.basic_test(signs=signs)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;log&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_zero(self</span><span class="s0">, </span><span class="s1">log):</span>
        <span class="s1">message = </span><span class="s4">&quot;A lower limit was equal to an upper limit, so&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">res = qmc_quad(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">log=log)</span>
        <span class="s0">assert </span><span class="s1">res.integral == (-np.inf </span><span class="s0">if </span><span class="s1">log </span><span class="s0">else </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.standard_error == </span><span class="s2">0</span>

    <span class="s0">def </span><span class="s1">test_flexible_input(self):</span>
        <span class="s3"># check that qrng is not required</span>
        <span class="s3"># also checks that for 1d problems, a and b can be scalars</span>
        <span class="s0">def </span><span class="s1">func(x):</span>
            <span class="s0">return </span><span class="s1">stats.norm.pdf(x</span><span class="s0">, </span><span class="s1">scale=</span><span class="s2">2</span><span class="s1">)</span>

        <span class="s1">res = qmc_quad(func</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">ref = stats.norm.cdf(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">scale=</span><span class="s2">2</span><span class="s1">) - stats.norm.cdf(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">scale=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.integral</span><span class="s0">, </span><span class="s1">ref</span><span class="s0">, </span><span class="s2">1e-2</span><span class="s1">)</span>
</pre>
</body>
</html>