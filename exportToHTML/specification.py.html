<html>
<head>
<title>specification.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
specification.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
SARIMAX specification class. 
 
Author: Chad Fulton 
License: BSD-3 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>

<span class="s2">from </span><span class="s1">statsmodels.tools.data </span><span class="s2">import </span><span class="s1">_is_using_pandas</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.base.tsa_model </span><span class="s2">import </span><span class="s1">TimeSeriesModel</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.tools </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_invertible</span><span class="s2">, </span><span class="s1">constrain_stationary_univariate </span><span class="s2">as </span><span class="s1">constrain</span><span class="s2">,</span>
    <span class="s1">unconstrain_stationary_univariate </span><span class="s2">as </span><span class="s1">unconstrain</span><span class="s2">,</span>
    <span class="s1">prepare_exog</span><span class="s2">, </span><span class="s1">prepare_trend_spec</span><span class="s2">, </span><span class="s1">prepare_trend_data)</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.tools </span><span class="s2">import </span><span class="s1">standardize_lag_order</span><span class="s2">, </span><span class="s1">validate_basic</span>


<span class="s2">class </span><span class="s1">SARIMAXSpecification:</span>
    <span class="s0">&quot;&quot;&quot; 
    SARIMAX specification. 
 
    Parameters 
    ---------- 
    endog : array_like, optional 
        The observed time-series process :math:`y`. 
    exog : array_like, optional 
        Array of exogenous regressors. 
    order : tuple, optional 
        The (p,d,q) order of the model for the autoregressive, differences, and 
        moving average components. d is always an integer, while p and q may 
        either be integers or lists of integers. May not be used in combination 
        with the arguments `ar_order`, `diff`, or `ma_order`. 
    seasonal_order : tuple, optional 
        The (P,D,Q,s) order of the seasonal component of the model for the 
        AR parameters, differences, MA parameters, and periodicity. Default 
        is (0, 0, 0, 0). D and s are always integers, while P and Q 
        may either be integers or lists of positive integers. May not be used 
        in combination with the arguments `seasonal_ar_order`, `seasonal_diff`, 
        or `seasonal_ma_order`. 
    ar_order : int or list of int 
        The autoregressive order of the model. May be an integer, in which case 
        all autoregressive lags up to and including it will be included. 
        Alternatively, may be a list of integers specifying which lag orders 
        are included. May not be used in combination with `order`. 
    diff : int 
        The order of integration of the model. May not be used in combination 
        with `order`. 
    ma_order : int or list of int 
        The moving average order of the model. May be an integer or 
        list of integers. See the documentation for `ar_order` for details. 
        May not be used in combination with `order`. 
    seasonal_ar_order : int or list of int 
        The seasonal autoregressive order of the model. May be an integer or 
        list of integers. See the documentation for `ar_order` for examples. 
        Note that if `seasonal_periods = 4` and `seasonal_ar_order = 2`, then 
        this implies that the overall model will include lags 4 and 8. 
        May not be used in combination with `seasonal_order`. 
    seasonal_diff : int 
        The order of seasonal integration of the model. May not be used in 
        combination with `seasonal_order`. 
    seasonal_ma_order : int or list of int 
        The moving average order of the model. May be an integer or 
        list of integers. See the documentation for `ar_order` and 
        `seasonal_ar_order` for additional details. May not be used in 
        combination with `seasonal_order`. 
    seasonal_periods : int 
        Number of periods in a season. May not be used in combination with 
        `seasonal_order`. 
    enforce_stationarity : bool, optional 
        Whether or not to require the autoregressive parameters to correspond 
        to a stationarity process. This is only possible in estimation by 
        numerical maximum likelihood. 
    enforce_invertibility : bool, optional 
        Whether or not to require the moving average parameters to correspond 
        to an invertible process. This is only possible in estimation by 
        numerical maximum likelihood. 
    concentrate_scale : bool, optional 
        Whether or not to concentrate the scale (variance of the error term) 
        out of the likelihood. This reduces the number of parameters by one. 
        This is only applicable when considering estimation by numerical 
        maximum likelihood. 
    dates : array_like of datetime, optional 
        If no index is given by `endog` or `exog`, an array-like object of 
        datetime objects can be provided. 
    freq : str, optional 
        If no index is given by `endog` or `exog`, the frequency of the 
        time-series may be specified here as a Pandas offset or offset string. 
    missing : str 
        Available options are 'none', 'drop', and 'raise'. If 'none', no nan 
        checking is done. If 'drop', any observations with nans are dropped. 
        If 'raise', an error is raised. Default is 'none'. 
 
    Attributes 
    ---------- 
    order : tuple, optional 
        The (p,d,q) order of the model for the autoregressive, differences, and 
        moving average components. d is always an integer, while p and q may 
        either be integers or lists of integers. 
    seasonal_order : tuple, optional 
        The (P,D,Q,s) order of the seasonal component of the model for the 
        AR parameters, differences, MA parameters, and periodicity. Default 
        is (0, 0, 0, 0). D and s are always integers, while P and Q 
        may either be integers or lists of positive integers. 
    ar_order : int or list of int 
        The autoregressive order of the model. May be an integer, in which case 
        all autoregressive lags up to and including it will be included. For 
        example, if `ar_order = 3`, then the model will include lags 1, 2, 
        and 3. Alternatively, may be a list of integers specifying exactly 
        which lag orders are included. For example, if `ar_order = [1, 3]`, 
        then the model will include lags 1 and 3 but will exclude lag 2. 
    diff : int 
        The order of integration of the model. 
    ma_order : int or list of int 
        The moving average order of the model. May be an integer or 
        list of integers. See the documentation for `ar_order` for examples. 
    seasonal_ar_order : int or list of int 
        The seasonal autoregressive order of the model. May be an integer or 
        list of integers. See the documentation for `ar_order` for examples. 
        Note that if `seasonal_periods = 4` and `seasonal_ar_order = 2`, then 
        this implies that the overall model will include lags 4 and 8. 
    seasonal_diff : int 
        The order of seasonal integration of the model. 
    seasonal_ma_order : int or list of int 
        The moving average order of the model. May be an integer or 
        list of integers. See the documentation for `ar_order` and 
        `seasonal_ar_order` for additional details. 
    seasonal_periods : int 
        Number of periods in a season. 
    trend : str{'n','c','t','ct'} or iterable, optional 
        Parameter controlling the deterministic trend polynomial :math:`A(t)`. 
        Can be specified as a string where 'c' indicates a constant (i.e. a 
        degree zero component of the trend polynomial), 't' indicates a 
        linear trend with time, and 'ct' is both. Can also be specified as an 
        iterable defining the polynomial as in `numpy.poly1d`, where 
        `[1,1,0,1]` would denote :math:`a + bt + ct^3`. Default is to not 
        include a trend component. 
    ar_lags : list of int 
        List of included autoregressive lags. If `ar_order` is a list, then 
        `ar_lags == ar_order`. If `ar_lags = [1, 2]`, then the overall model 
        will include the 1st and 2nd autoregressive lags. 
    ma_lags : list of int 
        List of included moving average lags. If `ma_order` is a list, then 
        `ma_lags == ma_order`. If `ma_lags = [1, 2]`, then the overall model 
        will include the 1st and 2nd moving average lags. 
    seasonal_ar_lags : list of int 
        List of included seasonal autoregressive lags. If `seasonal_ar_order` 
        is a list, then `seasonal_ar_lags == seasonal_ar_order`. If 
        `seasonal_periods = 4` and `seasonal_ar_lags = [1, 2]`, then the 
        overall model will include the 4th and 8th autoregressive lags. 
    seasonal_ma_lags : list of int 
        List of included seasonal moving average lags. If `seasonal_ma_order` 
        is a list, then `seasonal_ma_lags == seasonal_ma_order`. See the 
        documentation to `seasonal_ar_lags` for examples. 
    max_ar_order : int 
        Largest included autoregressive lag. 
    max_ma_order : int 
        Largest included moving average lag. 
    max_seasonal_ar_order : int 
        Largest included seasonal autoregressive lag. 
    max_seasonal_ma_order : int 
        Largest included seasonal moving average lag. 
    max_reduced_ar_order : int 
        Largest lag in the reduced autoregressive polynomial. Equal to 
        `max_ar_order + max_seasonal_ar_order * seasonal_periods`. 
    max_reduced_ma_order : int 
        Largest lag in the reduced moving average polynomial. Equal to 
        `max_ma_order + max_seasonal_ma_order * seasonal_periods`. 
    enforce_stationarity : bool 
        Whether or not to transform the AR parameters to enforce stationarity 
        in the autoregressive component of the model. This is only possible 
        in estimation by numerical maximum likelihood. 
    enforce_invertibility : bool 
        Whether or not to transform the MA parameters to enforce invertibility 
        in the moving average component of the model. This is only possible 
        in estimation by numerical maximum likelihood. 
    concentrate_scale : bool 
        Whether or not to concentrate the variance (scale term) out of the 
        log-likelihood function. This is only applicable when considering 
        estimation by numerical maximum likelihood. 
    is_ar_consecutive 
    is_ma_consecutive 
    is_integrated 
    is_seasonal 
    k_exog_params 
    k_ar_params 
    k_ma_params 
    k_seasonal_ar_params 
    k_seasonal_ma_params 
    k_params 
    exog_names 
    ar_names 
    ma_names 
    seasonal_ar_names 
    seasonal_ma_names 
    param_names 
 
    Examples 
    -------- 
    &gt;&gt;&gt; SARIMAXSpecification(order=(1, 0, 2)) 
    SARIMAXSpecification(endog=y, order=(1, 0, 2)) 
 
    &gt;&gt;&gt; spec = SARIMAXSpecification(ar_order=1, ma_order=2) 
    SARIMAXSpecification(endog=y, order=(1, 0, 2)) 
 
    &gt;&gt;&gt; spec = SARIMAXSpecification(ar_order=1, seasonal_order=(1, 0, 0, 4)) 
    SARIMAXSpecification(endog=y, order=(1, 0, 0), seasonal_order=(1, 0, 0, 4)) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">endog=</span><span class="s2">None, </span><span class="s1">exog=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s2">None,</span>
                 <span class="s1">seasonal_order=</span><span class="s2">None, </span><span class="s1">ar_order=</span><span class="s2">None, </span><span class="s1">diff=</span><span class="s2">None, </span><span class="s1">ma_order=</span><span class="s2">None,</span>
                 <span class="s1">seasonal_ar_order=</span><span class="s2">None, </span><span class="s1">seasonal_diff=</span><span class="s2">None,</span>
                 <span class="s1">seasonal_ma_order=</span><span class="s2">None, </span><span class="s1">seasonal_periods=</span><span class="s2">None, </span><span class="s1">trend=</span><span class="s2">None,</span>
                 <span class="s1">enforce_stationarity=</span><span class="s2">None, </span><span class="s1">enforce_invertibility=</span><span class="s2">None,</span>
                 <span class="s1">concentrate_scale=</span><span class="s2">None, </span><span class="s1">trend_offset=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dates=</span><span class="s2">None, </span><span class="s1">freq=</span><span class="s2">None,</span>
                 <span class="s1">missing=</span><span class="s4">'none'</span><span class="s2">, </span><span class="s1">validate_specification=</span><span class="s2">True</span><span class="s1">):</span>

        <span class="s5"># Basic parameters</span>
        <span class="s1">self.enforce_stationarity = enforce_stationarity</span>
        <span class="s1">self.enforce_invertibility = enforce_invertibility</span>
        <span class="s1">self.concentrate_scale = concentrate_scale</span>
        <span class="s1">self.trend_offset = trend_offset</span>

        <span class="s5"># Validate that we were not given conflicting specifications</span>
        <span class="s1">has_order = order </span><span class="s2">is not None</span>
        <span class="s1">has_specific_order = (ar_order </span><span class="s2">is not None or </span><span class="s1">diff </span><span class="s2">is not None or</span>
                              <span class="s1">ma_order </span><span class="s2">is not None</span><span class="s1">)</span>
        <span class="s1">has_seasonal_order = seasonal_order </span><span class="s2">is not None</span>
        <span class="s1">has_specific_seasonal_order = (seasonal_ar_order </span><span class="s2">is not None or</span>
                                       <span class="s1">seasonal_diff </span><span class="s2">is not None or</span>
                                       <span class="s1">seasonal_ma_order </span><span class="s2">is not None or</span>
                                       <span class="s1">seasonal_periods </span><span class="s2">is not None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">has_order </span><span class="s2">and </span><span class="s1">has_specific_order:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot specify both `order` and either of'</span>
                             <span class="s4">' `ar_order` or `ma_order`.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">has_seasonal_order </span><span class="s2">and </span><span class="s1">has_specific_seasonal_order:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot specify both `seasonal_order` and any of'</span>
                             <span class="s4">' `seasonal_ar_order`, `seasonal_ma_order`,'</span>
                             <span class="s4">' or `seasonal_periods`.'</span><span class="s1">)</span>

        <span class="s5"># Compute `order`</span>
        <span class="s2">if </span><span class="s1">has_specific_order:</span>
            <span class="s1">ar_order = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">ar_order </span><span class="s2">is None else </span><span class="s1">ar_order</span>
            <span class="s1">diff = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">diff </span><span class="s2">is None else </span><span class="s1">diff</span>
            <span class="s1">ma_order = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">ma_order </span><span class="s2">is None else </span><span class="s1">ma_order</span>
            <span class="s1">order = (ar_order</span><span class="s2">, </span><span class="s1">diff</span><span class="s2">, </span><span class="s1">ma_order)</span>
        <span class="s2">elif not </span><span class="s1">has_order:</span>
            <span class="s1">order = (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s5"># Compute `seasonal_order`</span>
        <span class="s2">if </span><span class="s1">has_specific_seasonal_order:</span>
            <span class="s1">seasonal_ar_order = (</span>
                <span class="s3">0 </span><span class="s2">if </span><span class="s1">seasonal_ar_order </span><span class="s2">is None else </span><span class="s1">seasonal_ar_order)</span>
            <span class="s1">seasonal_diff = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">seasonal_diff </span><span class="s2">is None else </span><span class="s1">seasonal_diff</span>
            <span class="s1">seasonal_ma_order = (</span>
                <span class="s3">0 </span><span class="s2">if </span><span class="s1">seasonal_ma_order </span><span class="s2">is None else </span><span class="s1">seasonal_ma_order)</span>
            <span class="s1">seasonal_periods = (</span>
                <span class="s3">0 </span><span class="s2">if </span><span class="s1">seasonal_periods </span><span class="s2">is None else </span><span class="s1">seasonal_periods)</span>
            <span class="s1">seasonal_order = (seasonal_ar_order</span><span class="s2">, </span><span class="s1">seasonal_diff</span><span class="s2">,</span>
                              <span class="s1">seasonal_ma_order</span><span class="s2">, </span><span class="s1">seasonal_periods)</span>
        <span class="s2">elif not </span><span class="s1">has_seasonal_order:</span>
            <span class="s1">seasonal_order = (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s5"># Validate shapes of `order`, `seasonal_order`</span>
        <span class="s2">if </span><span class="s1">len(order) != </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'`order` argument must be an iterable with three'</span>
                             <span class="s4">' elements.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(seasonal_order) != </span><span class="s3">4</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'`seasonal_order` argument must be an iterable'</span>
                             <span class="s4">' with four elements.'</span><span class="s1">)</span>

        <span class="s5"># Validate differencing parameters</span>
        <span class="s2">if </span><span class="s1">validate_specification:</span>
            <span class="s2">if </span><span class="s1">order[</span><span class="s3">1</span><span class="s1">] &lt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot specify negative differencing.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">order[</span><span class="s3">1</span><span class="s1">] != int(order[</span><span class="s3">1</span><span class="s1">]):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot specify fractional differencing.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">seasonal_order[</span><span class="s3">1</span><span class="s1">] &lt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot specify negative seasonal'</span>
                                 <span class="s4">' differencing.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">seasonal_order[</span><span class="s3">1</span><span class="s1">] != int(seasonal_order[</span><span class="s3">1</span><span class="s1">]):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot specify fractional seasonal'</span>
                                 <span class="s4">' differencing.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">seasonal_order[</span><span class="s3">3</span><span class="s1">] &lt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot specify negative seasonal'</span>
                                 <span class="s4">' periodicity.'</span><span class="s1">)</span>

        <span class="s5"># Standardize to integers or lists of integers</span>
        <span class="s1">order = (</span>
            <span class="s1">standardize_lag_order(order[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'AR'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">int(order[</span><span class="s3">1</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">standardize_lag_order(order[</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'MA'</span><span class="s1">))</span>
        <span class="s1">seasonal_order = (</span>
            <span class="s1">standardize_lag_order(seasonal_order[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'seasonal AR'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">int(seasonal_order[</span><span class="s3">1</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">standardize_lag_order(seasonal_order[</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'seasonal MA'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">int(seasonal_order[</span><span class="s3">3</span><span class="s1">]))</span>

        <span class="s5"># Validate seasonals</span>
        <span class="s2">if </span><span class="s1">validate_specification:</span>
            <span class="s2">if </span><span class="s1">seasonal_order[</span><span class="s3">3</span><span class="s1">] == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Seasonal periodicity must be greater'</span>
                                 <span class="s4">' than 1.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">((seasonal_order[</span><span class="s3">0</span><span class="s1">] != </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">seasonal_order[</span><span class="s3">1</span><span class="s1">] != </span><span class="s3">0 </span><span class="s2">or</span>
                    <span class="s1">seasonal_order[</span><span class="s3">2</span><span class="s1">] != </span><span class="s3">0</span><span class="s1">) </span><span class="s2">and </span><span class="s1">seasonal_order[</span><span class="s3">3</span><span class="s1">] == </span><span class="s3">0</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Must include nonzero seasonal periodicity if'</span>
                                 <span class="s4">' including seasonal AR, MA, or'</span>
                                 <span class="s4">' differencing.'</span><span class="s1">)</span>

        <span class="s5"># Basic order</span>
        <span class="s1">self.order = order</span>
        <span class="s1">self.ar_order</span><span class="s2">, </span><span class="s1">self.diff</span><span class="s2">, </span><span class="s1">self.ma_order = order</span>

        <span class="s1">self.seasonal_order = seasonal_order</span>
        <span class="s1">(self.seasonal_ar_order</span><span class="s2">, </span><span class="s1">self.seasonal_diff</span><span class="s2">, </span><span class="s1">self.seasonal_ma_order</span><span class="s2">,</span>
         <span class="s1">self.seasonal_periods) = seasonal_order</span>

        <span class="s5"># Lists of included lags</span>
        <span class="s2">if </span><span class="s1">isinstance(self.ar_order</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">self.ar_lags = self.ar_order</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ar_lags = np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">self.ar_order + </span><span class="s3">1</span><span class="s1">).tolist()</span>
        <span class="s2">if </span><span class="s1">isinstance(self.ma_order</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">self.ma_lags = self.ma_order</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ma_lags = np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">self.ma_order + </span><span class="s3">1</span><span class="s1">).tolist()</span>

        <span class="s2">if </span><span class="s1">isinstance(self.seasonal_ar_order</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">self.seasonal_ar_lags = self.seasonal_ar_order</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.seasonal_ar_lags = (</span>
                <span class="s1">np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">self.seasonal_ar_order + </span><span class="s3">1</span><span class="s1">).tolist())</span>
        <span class="s2">if </span><span class="s1">isinstance(self.seasonal_ma_order</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">self.seasonal_ma_lags = self.seasonal_ma_order</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.seasonal_ma_lags = (</span>
                <span class="s1">np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">self.seasonal_ma_order + </span><span class="s3">1</span><span class="s1">).tolist())</span>

        <span class="s5"># Maximum lag orders</span>
        <span class="s1">self.max_ar_order = self.ar_lags[-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">self.ar_lags </span><span class="s2">else </span><span class="s3">0</span>
        <span class="s1">self.max_ma_order = self.ma_lags[-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">self.ma_lags </span><span class="s2">else </span><span class="s3">0</span>

        <span class="s1">self.max_seasonal_ar_order = (</span>
            <span class="s1">self.seasonal_ar_lags[-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">self.seasonal_ar_lags </span><span class="s2">else </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self.max_seasonal_ma_order = (</span>
            <span class="s1">self.seasonal_ma_lags[-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">self.seasonal_ma_lags </span><span class="s2">else </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">self.max_reduced_ar_order = (</span>
            <span class="s1">self.max_ar_order +</span>
            <span class="s1">self.max_seasonal_ar_order * self.seasonal_periods)</span>
        <span class="s1">self.max_reduced_ma_order = (</span>
            <span class="s1">self.max_ma_order +</span>
            <span class="s1">self.max_seasonal_ma_order * self.seasonal_periods)</span>

        <span class="s5"># Check that we don't have duplicate AR or MA lags from the seasonal</span>
        <span class="s5"># component</span>
        <span class="s1">ar_lags = set(self.ar_lags)</span>
        <span class="s1">seasonal_ar_lags = set(np.array(self.seasonal_ar_lags)</span>
                               <span class="s1">* self.seasonal_periods)</span>
        <span class="s1">duplicate_ar_lags = ar_lags.intersection(seasonal_ar_lags)</span>
        <span class="s2">if </span><span class="s1">validate_specification </span><span class="s2">and </span><span class="s1">len(duplicate_ar_lags) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Invalid model: autoregressive lag(s) %s are'</span>
                             <span class="s4">' in both the seasonal and non-seasonal'</span>
                             <span class="s4">' autoregressive components.'</span>
                             <span class="s1">% duplicate_ar_lags)</span>

        <span class="s1">ma_lags = set(self.ma_lags)</span>
        <span class="s1">seasonal_ma_lags = set(np.array(self.seasonal_ma_lags)</span>
                               <span class="s1">* self.seasonal_periods)</span>
        <span class="s1">duplicate_ma_lags = ma_lags.intersection(seasonal_ma_lags)</span>
        <span class="s2">if </span><span class="s1">validate_specification </span><span class="s2">and </span><span class="s1">len(duplicate_ma_lags) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Invalid model: moving average lag(s) %s are'</span>
                             <span class="s4">' in both the seasonal and non-seasonal'</span>
                             <span class="s4">' moving average components.'</span>
                             <span class="s1">% duplicate_ma_lags)</span>

        <span class="s5"># Handle trend</span>
        <span class="s1">self.trend = trend</span>
        <span class="s1">self.trend_poly</span><span class="s2">, </span><span class="s1">_ = prepare_trend_spec(trend)</span>

        <span class="s5"># Check for a constant column in the provided exog</span>
        <span class="s1">exog_is_pandas = _is_using_pandas(exog</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(validate_specification </span><span class="s2">and </span><span class="s1">exog </span><span class="s2">is not None and</span>
                <span class="s1">len(self.trend_poly) &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">self.trend_poly[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s5"># Figure out if we have any constant columns</span>
            <span class="s1">x = np.asanyarray(exog)</span>
            <span class="s1">ptp0 = np.ptp(x</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">col_is_const = ptp0 == </span><span class="s3">0</span>
            <span class="s1">nz_const = col_is_const &amp; (x[</span><span class="s3">0</span><span class="s1">] != </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">col_const = nz_const</span>

            <span class="s5"># If we already have a constant column, raise an error</span>
            <span class="s2">if </span><span class="s1">np.any(col_const):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'A constant trend was included in the model'</span>
                                 <span class="s4">' specification, but the `exog` data already'</span>
                                 <span class="s4">' contains a column of constants.'</span><span class="s1">)</span>

        <span class="s5"># This contains the included exponents of the trend polynomial,</span>
        <span class="s5"># where e.g. the constant term has exponent 0, a linear trend has</span>
        <span class="s5"># exponent 1, etc.</span>
        <span class="s1">self.trend_terms = np.where(self.trend_poly == </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s5"># Trend order is either the degree of the trend polynomial, if all</span>
        <span class="s5"># exponents are included, or a list of included exponents. Here we need</span>
        <span class="s5"># to make a distinction between a degree zero polynomial (i.e. a</span>
        <span class="s5"># constant) and the zero polynomial (i.e. not even a constant). The</span>
        <span class="s5"># former has `trend_order = 0`, while the latter has</span>
        <span class="s5"># `trend_order = None`.</span>
        <span class="s1">self.k_trend = len(self.trend_terms)</span>
        <span class="s2">if </span><span class="s1">len(self.trend_terms) == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.trend_order = </span><span class="s2">None</span>
            <span class="s1">self.trend_degree = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">np.all(self.trend_terms == np.arange(len(self.trend_terms))):</span>
            <span class="s1">self.trend_order = self.trend_terms[-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">self.trend_degree = self.trend_terms[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.trend_order = self.trend_terms</span>
            <span class="s1">self.trend_degree = self.trend_terms[-</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s5"># Handle endog / exog</span>
        <span class="s5"># Standardize exog</span>
        <span class="s1">self.k_exog</span><span class="s2">, </span><span class="s1">exog = prepare_exog(exog)</span>

        <span class="s5"># Standardize endog (including creating a faux endog if necessary)</span>
        <span class="s1">faux_endog = endog </span><span class="s2">is None</span>
        <span class="s2">if </span><span class="s1">endog </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">endog = [] </span><span class="s2">if </span><span class="s1">exog </span><span class="s2">is None else </span><span class="s1">np.zeros(len(exog)) * np.nan</span>

        <span class="s5"># Add trend data into exog</span>
        <span class="s1">nobs = len(endog) </span><span class="s2">if </span><span class="s1">exog </span><span class="s2">is None else </span><span class="s1">len(exog)</span>
        <span class="s2">if </span><span class="s1">self.trend_order </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s5"># Add in the data</span>
            <span class="s1">trend_data = self.construct_trend_data(nobs</span><span class="s2">, </span><span class="s1">trend_offset)</span>
            <span class="s2">if </span><span class="s1">exog </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">exog = trend_data</span>
            <span class="s2">elif </span><span class="s1">exog_is_pandas:</span>
                <span class="s1">trend_data = pd.DataFrame(trend_data</span><span class="s2">, </span><span class="s1">index=exog.index</span><span class="s2">,</span>
                                          <span class="s1">columns=self.construct_trend_names())</span>
                <span class="s1">exog = pd.concat([trend_data</span><span class="s2">, </span><span class="s1">exog]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">exog = np.c_[trend_data</span><span class="s2">, </span><span class="s1">exog]</span>

        <span class="s5"># Create an underlying time series model, to handle endog / exog,</span>
        <span class="s5"># especially validating shapes, retrieving names, and potentially</span>
        <span class="s5"># providing us with a time series index</span>
        <span class="s1">self._model = TimeSeriesModel(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">dates=dates</span><span class="s2">, </span><span class="s1">freq=freq</span><span class="s2">,</span>
                                      <span class="s1">missing=missing)</span>
        <span class="s1">self.endog = </span><span class="s2">None if </span><span class="s1">faux_endog </span><span class="s2">else </span><span class="s1">self._model.endog</span>
        <span class="s1">self.exog = self._model.exog</span>

        <span class="s5"># Validate endog shape</span>
        <span class="s2">if </span><span class="s1">(validate_specification </span><span class="s2">and not </span><span class="s1">faux_endog </span><span class="s2">and</span>
                <span class="s1">self.endog.ndim &gt; </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">self.endog.shape[</span><span class="s3">1</span><span class="s1">] &gt; </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'SARIMAX models require univariate `endog`. Got'</span>
                             <span class="s4">' shape %s.' </span><span class="s1">% str(self.endog.shape))</span>

        <span class="s1">self._has_missing = (</span>
            <span class="s2">None if </span><span class="s1">faux_endog </span><span class="s2">else </span><span class="s1">np.any(np.isnan(self.endog)))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_ar_consecutive(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (bool) Is autoregressive lag polynomial consecutive. 
 
        I.e. does it include all lags up to and including the maximum lag. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(self.max_seasonal_ar_order == </span><span class="s3">0 </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">isinstance(self.ar_order</span><span class="s2">, </span><span class="s1">list))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_ma_consecutive(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (bool) Is moving average lag polynomial consecutive. 
 
        I.e. does it include all lags up to and including the maximum lag. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(self.max_seasonal_ma_order == </span><span class="s3">0 </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">isinstance(self.ma_order</span><span class="s2">, </span><span class="s1">list))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_integrated(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (bool) Is the model integrated. 
 
        I.e. does it have a nonzero `diff` or `seasonal_diff`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.diff &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self.seasonal_diff &gt; </span><span class="s3">0</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_seasonal(self):</span>
        <span class="s0">&quot;&quot;&quot;(bool) Does the model include a seasonal component.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.seasonal_periods != </span><span class="s3">0</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">k_exog_params(self):</span>
        <span class="s0">&quot;&quot;&quot;(int) Number of parameters associated with exogenous variables.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.exog_names)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">k_ar_params(self):</span>
        <span class="s0">&quot;&quot;&quot;(int) Number of autoregressive (non-seasonal) parameters.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.ar_lags)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">k_ma_params(self):</span>
        <span class="s0">&quot;&quot;&quot;(int) Number of moving average (non-seasonal) parameters.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.ma_lags)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">k_seasonal_ar_params(self):</span>
        <span class="s0">&quot;&quot;&quot;(int) Number of seasonal autoregressive parameters.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.seasonal_ar_lags)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">k_seasonal_ma_params(self):</span>
        <span class="s0">&quot;&quot;&quot;(int) Number of seasonal moving average parameters.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.seasonal_ma_lags)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">k_params(self):</span>
        <span class="s0">&quot;&quot;&quot;(int) Total number of model parameters.&quot;&quot;&quot;</span>
        <span class="s1">k_params = (self.k_exog_params + self.k_ar_params + self.k_ma_params +</span>
                    <span class="s1">self.k_seasonal_ar_params + self.k_seasonal_ma_params)</span>
        <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">k_params += </span><span class="s3">1</span>
        <span class="s2">return </span><span class="s1">k_params</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">exog_names(self):</span>
        <span class="s0">&quot;&quot;&quot;(list of str) Names associated with exogenous parameters.&quot;&quot;&quot;</span>
        <span class="s1">exog_names = self._model.exog_names</span>
        <span class="s2">return </span><span class="s1">[] </span><span class="s2">if </span><span class="s1">exog_names </span><span class="s2">is None else </span><span class="s1">exog_names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ar_names(self):</span>
        <span class="s0">&quot;&quot;&quot;(list of str) Names of (non-seasonal) autoregressive parameters.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s4">'ar.L%d' </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.ar_lags]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ma_names(self):</span>
        <span class="s0">&quot;&quot;&quot;(list of str) Names of (non-seasonal) moving average parameters.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s4">'ma.L%d' </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.ma_lags]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">seasonal_ar_names(self):</span>
        <span class="s0">&quot;&quot;&quot;(list of str) Names of seasonal autoregressive parameters.&quot;&quot;&quot;</span>
        <span class="s1">s = self.seasonal_periods</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s4">'ar.S.L%d' </span><span class="s1">% (i * s) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.seasonal_ar_lags]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">seasonal_ma_names(self):</span>
        <span class="s0">&quot;&quot;&quot;(list of str) Names of seasonal moving average parameters.&quot;&quot;&quot;</span>
        <span class="s1">s = self.seasonal_periods</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s4">'ma.S.L%d' </span><span class="s1">% (i * s) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.seasonal_ma_lags]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">param_names(self):</span>
        <span class="s0">&quot;&quot;&quot;(list of str) Names of all model parameters.&quot;&quot;&quot;</span>
        <span class="s1">names = (self.exog_names + self.ar_names + self.ma_names +</span>
                 <span class="s1">self.seasonal_ar_names + self.seasonal_ma_names)</span>
        <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">names.append(</span><span class="s4">'sigma2'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">valid_estimators(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (list of str) Estimators that could be used with specification. 
 
        Note: does not consider the presense of `exog` in determining valid 
        estimators. If there are exogenous variables, then feasible Generalized 
        Least Squares should be used through the `gls` estimator, and the 
        `valid_estimators` are the estimators that could be passed as the 
        `arma_estimator` argument to `gls`. 
        &quot;&quot;&quot;</span>
        <span class="s1">estimators = {</span><span class="s4">'yule_walker'</span><span class="s2">, </span><span class="s4">'burg'</span><span class="s2">, </span><span class="s4">'innovations'</span><span class="s2">,</span>
                      <span class="s4">'hannan_rissanen'</span><span class="s2">, </span><span class="s4">'innovations_mle'</span><span class="s2">, </span><span class="s4">'statespace'</span><span class="s1">}</span>

        <span class="s5"># Properties</span>
        <span class="s1">has_ar = self.max_ar_order != </span><span class="s3">0</span>
        <span class="s1">has_ma = self.max_ma_order != </span><span class="s3">0</span>
        <span class="s1">has_seasonal = self.seasonal_periods != </span><span class="s3">0</span>

        <span class="s5"># Only state space can handle missing data or concentrated scale</span>
        <span class="s2">if </span><span class="s1">self._has_missing:</span>
            <span class="s1">estimators.intersection_update([</span><span class="s4">'statespace'</span><span class="s1">])</span>

        <span class="s5"># Only numerical MLE estimators can enforce restrictions</span>
        <span class="s2">if </span><span class="s1">((self.enforce_stationarity </span><span class="s2">and </span><span class="s1">self.max_ar_order &gt; </span><span class="s3">0</span><span class="s1">) </span><span class="s2">or</span>
                <span class="s1">(self.enforce_invertibility </span><span class="s2">and </span><span class="s1">self.max_ma_order &gt; </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">estimators.intersection_update([</span><span class="s4">'innovations_mle'</span><span class="s2">, </span><span class="s4">'statespace'</span><span class="s1">])</span>

        <span class="s5"># Innovations: no AR, non-consecutive MA, seasonal</span>
        <span class="s2">if </span><span class="s1">has_ar </span><span class="s2">or not </span><span class="s1">self.is_ma_consecutive </span><span class="s2">or </span><span class="s1">has_seasonal:</span>
            <span class="s1">estimators.discard(</span><span class="s4">'innovations'</span><span class="s1">)</span>
        <span class="s5"># Yule-Walker/Burg: no MA, non-consecutive AR, seasonal</span>
        <span class="s2">if </span><span class="s1">has_ma </span><span class="s2">or not </span><span class="s1">self.is_ar_consecutive </span><span class="s2">or </span><span class="s1">has_seasonal:</span>
            <span class="s1">estimators.discard(</span><span class="s4">'yule_walker'</span><span class="s1">)</span>
            <span class="s1">estimators.discard(</span><span class="s4">'burg'</span><span class="s1">)</span>
        <span class="s5"># Hannan-Rissanen: no seasonal</span>
        <span class="s2">if </span><span class="s1">has_seasonal:</span>
            <span class="s1">estimators.discard(</span><span class="s4">'hannan_rissanen'</span><span class="s1">)</span>
        <span class="s5"># Innovations MLE: cannot have enforce_stationary=False or</span>
        <span class="s5"># concentratre_scale=True</span>
        <span class="s2">if </span><span class="s1">self.enforce_stationarity </span><span class="s2">is False or </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">estimators.discard(</span><span class="s4">'innovations_mle'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">estimators</span>

    <span class="s2">def </span><span class="s1">validate_estimator(self</span><span class="s2">, </span><span class="s1">estimator):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate an SARIMA estimator. 
 
        Parameters 
        ---------- 
        estimator : str 
            Name of the estimator to validate against the current state of 
            the specification. Possible values are: 'yule_walker', 'burg', 
            'innovations', 'hannan_rissanen', 'innovoations_mle', 'statespace'. 
 
        Notes 
        ----- 
        This method will raise a `ValueError` if an invalid method is passed, 
        and otherwise will return None. 
 
        This method does not consider the presense of `exog` in determining 
        valid estimators. If there are exogenous variables, then feasible 
        Generalized Least Squares should be used through the `gls` estimator, 
        and a &quot;valid&quot; estimator is one that could be passed as the 
        `arma_estimator` argument to `gls`. 
 
        This method only uses the attributes `enforce_stationarity` and 
        `concentrate_scale` to determine the validity of numerical maximum 
        likelihood estimators. These only include 'innovations_mle' (which 
        does not support `enforce_stationarity=False` or 
        `concentrate_scale=True`) and 'statespace' (which supports all 
        combinations of each). 
 
        Examples 
        -------- 
        &gt;&gt;&gt; spec = SARIMAXSpecification(order=(1, 0, 2)) 
 
        &gt;&gt;&gt; spec.validate_estimator('yule_walker') 
        ValueError: Yule-Walker estimator does not support moving average 
                    components. 
 
        &gt;&gt;&gt; spec.validate_estimator('burg') 
        ValueError: Burg estimator does not support moving average components. 
 
        &gt;&gt;&gt; spec.validate_estimator('innovations') 
        ValueError: Burg estimator does not support autoregressive components. 
 
        &gt;&gt;&gt; spec.validate_estimator('hannan_rissanen')  # returns None 
        &gt;&gt;&gt; spec.validate_estimator('innovations_mle')  # returns None 
        &gt;&gt;&gt; spec.validate_estimator('statespace')       # returns None 
 
        &gt;&gt;&gt; spec.validate_estimator('not_an_estimator') 
        ValueError: &quot;not_an_estimator&quot; is not a valid estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">has_ar = self.max_ar_order != </span><span class="s3">0</span>
        <span class="s1">has_ma = self.max_ma_order != </span><span class="s3">0</span>
        <span class="s1">has_seasonal = self.seasonal_periods != </span><span class="s3">0</span>
        <span class="s1">has_missing = self._has_missing</span>

        <span class="s1">titles = {</span>
            <span class="s4">'yule_walker'</span><span class="s1">: </span><span class="s4">'Yule-Walker'</span><span class="s2">,</span>
            <span class="s4">'burg'</span><span class="s1">: </span><span class="s4">'Burg'</span><span class="s2">,</span>
            <span class="s4">'innovations'</span><span class="s1">: </span><span class="s4">'Innovations'</span><span class="s2">,</span>
            <span class="s4">'hannan_rissanen'</span><span class="s1">: </span><span class="s4">'Hannan-Rissanen'</span><span class="s2">,</span>
            <span class="s4">'innovations_mle'</span><span class="s1">: </span><span class="s4">'Innovations MLE'</span><span class="s2">,</span>
            <span class="s4">'statespace'</span><span class="s1">: </span><span class="s4">'State space'</span>
        <span class="s1">}</span>

        <span class="s5"># Only state space form can support missing data</span>
        <span class="s2">if </span><span class="s1">estimator != </span><span class="s4">'statespace'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">has_missing:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'%s estimator does not support missing'</span>
                                 <span class="s4">' values in `endog`.' </span><span class="s1">% titles[estimator])</span>

        <span class="s5"># Only state space and innovations MLE can enforce parameter</span>
        <span class="s5"># restrictions</span>
        <span class="s2">if </span><span class="s1">estimator </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">'innovations_mle'</span><span class="s2">, </span><span class="s4">'statespace'</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">self.max_ar_order &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'%s estimator cannot enforce a stationary'</span>
                                 <span class="s4">' autoregressive lag polynomial.'</span>
                                 <span class="s1">% titles[estimator])</span>
            <span class="s2">if </span><span class="s1">self.max_ma_order &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'%s estimator cannot enforce an invertible'</span>
                                 <span class="s4">' moving average lag polynomial.'</span>
                                 <span class="s1">% titles[estimator])</span>

        <span class="s5"># Now go through specific disqualifications for each estimator</span>
        <span class="s2">if </span><span class="s1">estimator </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'yule_walker'</span><span class="s2">, </span><span class="s4">'burg'</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">has_seasonal:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'%s estimator does not support seasonal'</span>
                                 <span class="s4">' components.' </span><span class="s1">% titles[estimator])</span>
            <span class="s2">if not </span><span class="s1">self.is_ar_consecutive:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'%s estimator does not support'</span>
                                 <span class="s4">' non-consecutive autoregressive lags.'</span>
                                 <span class="s1">% titles[estimator])</span>
            <span class="s2">if </span><span class="s1">has_ma:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'%s estimator does not support moving average'</span>
                                 <span class="s4">' components.' </span><span class="s1">% titles[estimator])</span>
        <span class="s2">elif </span><span class="s1">estimator == </span><span class="s4">'innovations'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">has_seasonal:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Innovations estimator does not support'</span>
                                 <span class="s4">' seasonal components.'</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">self.is_ma_consecutive:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Innovations estimator does not support'</span>
                                 <span class="s4">' non-consecutive moving average lags.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">has_ar:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Innovations estimator does not support'</span>
                                 <span class="s4">' autoregressive components.'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">estimator == </span><span class="s4">'hannan_rissanen'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">has_seasonal:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Hannan-Rissanen estimator does not support'</span>
                                 <span class="s4">' seasonal components.'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">estimator == </span><span class="s4">'innovations_mle'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Innovations MLE estimator does not support'</span>
                                 <span class="s4">' non-stationary autoregressive components,'</span>
                                 <span class="s4">' but `enforce_stationarity` is set to False'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.concentrate_scale:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Innovations MLE estimator does not support'</span>
                                 <span class="s4">' concentrating the scale out of the'</span>
                                 <span class="s4">' log-likelihood function'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">estimator == </span><span class="s4">'statespace'</span><span class="s1">:</span>
            <span class="s5"># State space form supports all variations of SARIMAX.</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'&quot;%s&quot; is not a valid estimator.' </span><span class="s1">% estimator)</span>

    <span class="s2">def </span><span class="s1">split_params(self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">allow_infnan=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Split parameter array by type into dictionary. 
 
        Parameters 
        ---------- 
        params : array_like 
            Array of model parameters. 
        allow_infnan : bool, optional 
            Whether or not to allow `params` to contain -np.Inf, np.Inf, and 
            np.nan. Default is False. 
 
        Returns 
        ------- 
        split_params : dict 
            Dictionary with keys 'exog_params', 'ar_params', 'ma_params', 
            'seasonal_ar_params', 'seasonal_ma_params', and (unless 
            `concentrate_scale=True`) 'sigma2'. Values are the parameters 
            associated with the key, based on the `params` argument. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; spec = SARIMAXSpecification(ar_order=1) 
        &gt;&gt;&gt; spec.split_params([0.5, 4]) 
        {'exog_params': array([], dtype=float64), 
         'ar_params': array([0.5]), 
         'ma_params': array([], dtype=float64), 
         'seasonal_ar_params': array([], dtype=float64), 
         'seasonal_ma_params': array([], dtype=float64), 
         'sigma2': 4.0} 
        &quot;&quot;&quot;</span>
        <span class="s1">params = validate_basic(params</span><span class="s2">, </span><span class="s1">self.k_params</span><span class="s2">,</span>
                                <span class="s1">allow_infnan=allow_infnan</span><span class="s2">,</span>
                                <span class="s1">title=</span><span class="s4">'joint parameters'</span><span class="s1">)</span>

        <span class="s1">ix = [self.k_exog_params</span><span class="s2">, </span><span class="s1">self.k_ar_params</span><span class="s2">, </span><span class="s1">self.k_ma_params</span><span class="s2">,</span>
              <span class="s1">self.k_seasonal_ar_params</span><span class="s2">, </span><span class="s1">self.k_seasonal_ma_params]</span>
        <span class="s1">names = [</span><span class="s4">'exog_params'</span><span class="s2">, </span><span class="s4">'ar_params'</span><span class="s2">, </span><span class="s4">'ma_params'</span><span class="s2">,</span>
                 <span class="s4">'seasonal_ar_params'</span><span class="s2">, </span><span class="s4">'seasonal_ma_params'</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">ix.append(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">names.append(</span><span class="s4">'sigma2'</span><span class="s1">)</span>
        <span class="s1">ix = np.cumsum(ix)</span>

        <span class="s1">out = dict(zip(names</span><span class="s2">, </span><span class="s1">np.split(params</span><span class="s2">, </span><span class="s1">ix)))</span>
        <span class="s2">if </span><span class="s4">'sigma2' </span><span class="s2">in </span><span class="s1">out:</span>
            <span class="s1">out[</span><span class="s4">'sigma2'</span><span class="s1">] = out[</span><span class="s4">'sigma2'</span><span class="s1">].item()</span>

        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">join_params(self</span><span class="s2">, </span><span class="s1">exog_params=</span><span class="s2">None, </span><span class="s1">ar_params=</span><span class="s2">None, </span><span class="s1">ma_params=</span><span class="s2">None,</span>
                    <span class="s1">seasonal_ar_params=</span><span class="s2">None, </span><span class="s1">seasonal_ma_params=</span><span class="s2">None,</span>
                    <span class="s1">sigma2=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Join parameters into a single vector. 
 
        Parameters 
        ---------- 
        exog_params : array_like, optional 
            Parameters associated with exogenous regressors. Required if 
            `exog` is part of specification. 
        ar_params : array_like, optional 
            Parameters associated with (non-seasonal) autoregressive component. 
            Required if this component is part of the specification. 
        ma_params : array_like, optional 
            Parameters associated with (non-seasonal) moving average component. 
            Required if this component is part of the specification. 
        seasonal_ar_params : array_like, optional 
            Parameters associated with seasonal autoregressive component. 
            Required if this component is part of the specification. 
        seasonal_ma_params : array_like, optional 
            Parameters associated with seasonal moving average component. 
            Required if this component is part of the specification. 
        sigma2 : array_like, optional 
            Innovation variance parameter. Required unless 
            `concentrated_scale=True`. 
 
        Returns 
        ------- 
        params : ndarray 
            Array of parameters. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; spec = SARIMAXSpecification(ar_order=1) 
        &gt;&gt;&gt; spec.join_params(ar_params=0.5, sigma2=4) 
        array([0.5, 4. ]) 
        &quot;&quot;&quot;</span>
        <span class="s1">definitions = [</span>
            <span class="s1">(</span><span class="s4">'exogenous variables'</span><span class="s2">, </span><span class="s1">self.k_exog_params</span><span class="s2">, </span><span class="s1">exog_params)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'AR terms'</span><span class="s2">, </span><span class="s1">self.k_ar_params</span><span class="s2">, </span><span class="s1">ar_params)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'MA terms'</span><span class="s2">, </span><span class="s1">self.k_ma_params</span><span class="s2">, </span><span class="s1">ma_params)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'seasonal AR terms'</span><span class="s2">, </span><span class="s1">self.k_seasonal_ar_params</span><span class="s2">,</span>
                <span class="s1">seasonal_ar_params)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'seasonal MA terms'</span><span class="s2">, </span><span class="s1">self.k_seasonal_ma_params</span><span class="s2">,</span>
                <span class="s1">seasonal_ma_params)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'variance'</span><span class="s2">, </span><span class="s1">int(</span><span class="s2">not </span><span class="s1">self.concentrate_scale)</span><span class="s2">, </span><span class="s1">sigma2)]</span>

        <span class="s1">params_list = []</span>
        <span class="s2">for </span><span class="s1">title</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">params </span><span class="s2">in </span><span class="s1">definitions:</span>
            <span class="s2">if </span><span class="s1">k &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s5"># Validate</span>
                <span class="s2">if </span><span class="s1">params </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Specification includes %s, but no'</span>
                                     <span class="s4">' parameters were provided.' </span><span class="s1">% title)</span>
                <span class="s1">params = np.atleast_1d(np.squeeze(params))</span>
                <span class="s2">if not </span><span class="s1">params.shape == (k</span><span class="s2">,</span><span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Specification included %d %s, but'</span>
                                     <span class="s4">' parameters with shape %s were provided.'</span>
                                     <span class="s1">% (k</span><span class="s2">, </span><span class="s1">title</span><span class="s2">, </span><span class="s1">params.shape))</span>

                <span class="s5"># Otherwise add to the list</span>
                <span class="s1">params_list.append(params)</span>

        <span class="s2">return </span><span class="s1">np.concatenate(params_list)</span>

    <span class="s2">def </span><span class="s1">validate_params(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate parameter vector by raising ValueError on invalid values. 
 
        Parameters 
        ---------- 
        params : array_like 
            Array of model parameters. 
 
        Notes 
        ----- 
        Primarily checks that the parameters have the right shape and are not 
        NaN or infinite. Also checks if parameters are consistent with a 
        stationary process if `enforce_stationarity=True` and that they are 
        consistent with an invertible process if `enforce_invertibility=True`. 
        Finally, checks that the variance term is positive, unless 
        `concentrate_scale=True`. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; spec = SARIMAXSpecification(ar_order=1) 
        &gt;&gt;&gt; spec.validate_params([-0.5, 4.])  # returns None 
        &gt;&gt;&gt; spec.validate_params([-0.5, -2]) 
        ValueError: Non-positive variance term. 
        &gt;&gt;&gt; spec.validate_params([-1.5, 4.]) 
        ValueError: Non-stationary autoregressive polynomial. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Note: split_params includes basic validation</span>
        <span class="s1">params = self.split_params(params)</span>

        <span class="s5"># Specific checks</span>
        <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
            <span class="s2">if </span><span class="s1">self.k_ar_params:</span>
                <span class="s1">ar_poly = np.r_[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-params[</span><span class="s4">'ar_params'</span><span class="s1">]]</span>
                <span class="s2">if not </span><span class="s1">is_invertible(ar_poly):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Non-stationary autoregressive'</span>
                                     <span class="s4">' polynomial.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.k_seasonal_ar_params:</span>
                <span class="s1">seasonal_ar_poly = np.r_[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-params[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">]]</span>
                <span class="s2">if not </span><span class="s1">is_invertible(seasonal_ar_poly):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Non-stationary seasonal autoregressive'</span>
                                     <span class="s4">' polynomial.'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
            <span class="s2">if </span><span class="s1">self.k_ma_params:</span>
                <span class="s1">ma_poly = np.r_[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">params[</span><span class="s4">'ma_params'</span><span class="s1">]]</span>
                <span class="s2">if not </span><span class="s1">is_invertible(ma_poly):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Non-invertible moving average'</span>
                                     <span class="s4">' polynomial.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.k_seasonal_ma_params:</span>
                <span class="s1">seasonal_ma_poly = np.r_[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">params[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">]]</span>
                <span class="s2">if not </span><span class="s1">is_invertible(seasonal_ma_poly):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Non-invertible seasonal moving average'</span>
                                     <span class="s4">' polynomial.'</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s2">if </span><span class="s1">params[</span><span class="s4">'sigma2'</span><span class="s1">] &lt;= </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Non-positive variance term.'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">constrain_params(self</span><span class="s2">, </span><span class="s1">unconstrained):</span>
        <span class="s0">&quot;&quot;&quot; 
        Constrain parameter values to be valid through transformations. 
 
        Parameters 
        ---------- 
        unconstrained : array_like 
            Array of model unconstrained parameters. 
 
        Returns 
        ------- 
        constrained : ndarray 
            Array of model parameters transformed to produce a valid model. 
 
        Notes 
        ----- 
        This is usually only used when performing numerical minimization 
        of the log-likelihood function. This function is necessary because 
        the minimizers consider values over the entire real space, while 
        SARIMAX models require parameters in subspaces (for example positive 
        variances). 
 
        Examples 
        -------- 
        &gt;&gt;&gt; spec = SARIMAXSpecification(ar_order=1) 
        &gt;&gt;&gt; spec.constrain_params([10, -2]) 
        array([-0.99504,  4.     ]) 
        &quot;&quot;&quot;</span>
        <span class="s1">unconstrained = self.split_params(unconstrained)</span>
        <span class="s1">params = {}</span>

        <span class="s2">if </span><span class="s1">self.k_exog_params:</span>
            <span class="s1">params[</span><span class="s4">'exog_params'</span><span class="s1">] = unconstrained[</span><span class="s4">'exog_params'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.k_ar_params:</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s1">params[</span><span class="s4">'ar_params'</span><span class="s1">] = constrain(unconstrained[</span><span class="s4">'ar_params'</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params[</span><span class="s4">'ar_params'</span><span class="s1">] = unconstrained[</span><span class="s4">'ar_params'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.k_ma_params:</span>
            <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s1">params[</span><span class="s4">'ma_params'</span><span class="s1">] = -constrain(unconstrained[</span><span class="s4">'ma_params'</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params[</span><span class="s4">'ma_params'</span><span class="s1">] = unconstrained[</span><span class="s4">'ma_params'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ar_params:</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s1">params[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">] = (</span>
                    <span class="s1">constrain(unconstrained[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">] = (</span>
                    <span class="s1">unconstrained[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ma_params:</span>
            <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s1">params[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">] = (</span>
                    <span class="s1">-constrain(unconstrained[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">] = (</span>
                    <span class="s1">unconstrained[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">])</span>
        <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">params[</span><span class="s4">'sigma2'</span><span class="s1">] = unconstrained[</span><span class="s4">'sigma2'</span><span class="s1">]**</span><span class="s3">2</span>

        <span class="s2">return </span><span class="s1">self.join_params(**params)</span>

    <span class="s2">def </span><span class="s1">unconstrain_params(self</span><span class="s2">, </span><span class="s1">constrained):</span>
        <span class="s0">&quot;&quot;&quot; 
        Reverse transformations used to constrain parameter values to be valid. 
 
        Parameters 
        ---------- 
        constrained : array_like 
            Array of model parameters. 
 
        Returns 
        ------- 
        unconstrained : ndarray 
            Array of parameters with constraining transformions reversed. 
 
        Notes 
        ----- 
        This is usually only used when performing numerical minimization 
        of the log-likelihood function. This function is the (approximate) 
        inverse of `constrain_params`. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; spec = SARIMAXSpecification(ar_order=1) 
        &gt;&gt;&gt; spec.unconstrain_params([-0.5, 4.]) 
        array([0.57735, 2.     ]) 
        &quot;&quot;&quot;</span>
        <span class="s1">constrained = self.split_params(constrained)</span>
        <span class="s1">params = {}</span>

        <span class="s2">if </span><span class="s1">self.k_exog_params:</span>
            <span class="s1">params[</span><span class="s4">'exog_params'</span><span class="s1">] = constrained[</span><span class="s4">'exog_params'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.k_ar_params:</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s1">params[</span><span class="s4">'ar_params'</span><span class="s1">] = unconstrain(constrained[</span><span class="s4">'ar_params'</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params[</span><span class="s4">'ar_params'</span><span class="s1">] = constrained[</span><span class="s4">'ar_params'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.k_ma_params:</span>
            <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s1">params[</span><span class="s4">'ma_params'</span><span class="s1">] = unconstrain(-constrained[</span><span class="s4">'ma_params'</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params[</span><span class="s4">'ma_params'</span><span class="s1">] = constrained[</span><span class="s4">'ma_params'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ar_params:</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s1">params[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">] = (</span>
                    <span class="s1">unconstrain(constrained[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">] = (</span>
                    <span class="s1">constrained[</span><span class="s4">'seasonal_ar_params'</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ma_params:</span>
            <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s1">params[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">] = (</span>
                    <span class="s1">unconstrain(-constrained[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">] = (</span>
                    <span class="s1">constrained[</span><span class="s4">'seasonal_ma_params'</span><span class="s1">])</span>
        <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">params[</span><span class="s4">'sigma2'</span><span class="s1">] = constrained[</span><span class="s4">'sigma2'</span><span class="s1">]**</span><span class="s3">0.5</span>

        <span class="s2">return </span><span class="s1">self.join_params(**params)</span>

    <span class="s2">def </span><span class="s1">construct_trend_data(self</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">offset=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self.trend_order </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">trend_data = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">trend_data = prepare_trend_data(</span>
                <span class="s1">self.trend_poly</span><span class="s2">, </span><span class="s1">int(np.sum(self.trend_poly))</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">offset)</span>

        <span class="s2">return </span><span class="s1">trend_data</span>

    <span class="s2">def </span><span class="s1">construct_trend_names(self):</span>
        <span class="s1">names = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.trend_terms:</span>
            <span class="s2">if </span><span class="s1">i == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">names.append(</span><span class="s4">'const'</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">i == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">names.append(</span><span class="s4">'drift'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">names.append(</span><span class="s4">'trend.%d' </span><span class="s1">% i)</span>
        <span class="s2">return </span><span class="s1">names</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">&quot;&quot;&quot;Represent SARIMAXSpecification object as a string.&quot;&quot;&quot;</span>
        <span class="s1">components = []</span>
        <span class="s2">if </span><span class="s1">self.endog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">components.append(</span><span class="s4">'endog=%s' </span><span class="s1">% self._model.endog_names)</span>
        <span class="s2">if </span><span class="s1">self.k_exog_params:</span>
            <span class="s1">components.append(</span><span class="s4">'exog=%s' </span><span class="s1">% self.exog_names)</span>
        <span class="s1">components.append(</span><span class="s4">'order=%s' </span><span class="s1">% str(self.order))</span>
        <span class="s2">if </span><span class="s1">self.seasonal_periods &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">components.append(</span><span class="s4">'seasonal_order=%s' </span><span class="s1">% str(self.seasonal_order))</span>
        <span class="s2">if </span><span class="s1">self.enforce_stationarity </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">components.append(</span><span class="s4">'enforce_stationarity=%s'</span>
                              <span class="s1">% self.enforce_stationarity)</span>
        <span class="s2">if </span><span class="s1">self.enforce_invertibility </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">components.append(</span><span class="s4">'enforce_invertibility=%s'</span>
                              <span class="s1">% self.enforce_invertibility)</span>
        <span class="s2">if </span><span class="s1">self.concentrate_scale </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">components.append(</span><span class="s4">'concentrate_scale=%s' </span><span class="s1">% self.concentrate_scale)</span>
        <span class="s2">return </span><span class="s4">'SARIMAXSpecification(%s)' </span><span class="s1">% </span><span class="s4">', '</span><span class="s1">.join(components)</span>
</pre>
</body>
</html>