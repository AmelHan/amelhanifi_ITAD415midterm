<html>
<head>
<title>test__shgo.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__shgo.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">sys</span>

<span class="s0">import </span><span class="s1">numpy</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">from </span><span class="s1">multiprocessing </span><span class="s0">import </span><span class="s1">Pool</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">IS_PYPY</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">warns</span>
<span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">(shgo</span><span class="s0">, </span><span class="s1">Bounds</span><span class="s0">, </span><span class="s1">minimize_scalar</span><span class="s0">, </span><span class="s1">minimize</span><span class="s0">, </span><span class="s1">rosen</span><span class="s0">,</span>
                            <span class="s1">rosen_der</span><span class="s0">, </span><span class="s1">rosen_hess</span><span class="s0">, </span><span class="s1">NonlinearConstraint)</span>
<span class="s0">from </span><span class="s1">scipy.optimize._constraints </span><span class="s0">import </span><span class="s1">new_constraint_to_old</span>
<span class="s0">from </span><span class="s1">scipy.optimize._shgo </span><span class="s0">import </span><span class="s1">SHGO</span>


<span class="s0">class </span><span class="s1">StructTestFunction:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">expected_x</span><span class="s0">, </span><span class="s1">expected_fun=</span><span class="s0">None,</span>
                 <span class="s1">expected_xl=</span><span class="s0">None, </span><span class="s1">expected_funl=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.bounds = bounds</span>
        <span class="s1">self.expected_x = expected_x</span>
        <span class="s1">self.expected_fun = expected_fun</span>
        <span class="s1">self.expected_xl = expected_xl</span>
        <span class="s1">self.expected_funl = expected_funl</span>


<span class="s0">def </span><span class="s1">wrap_constraints(g):</span>
    <span class="s1">cons = []</span>
    <span class="s0">if </span><span class="s1">g </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">(type(g) </span><span class="s0">is not </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">(type(g) </span><span class="s0">is not </span><span class="s1">list):</span>
            <span class="s1">g = (g</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">pass</span>
        <span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">g:</span>
            <span class="s1">cons.append({</span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'ineq'</span><span class="s0">,</span>
                         <span class="s2">'fun'</span><span class="s1">: g})</span>
        <span class="s1">cons = tuple(cons)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">cons = </span><span class="s0">None</span>
    <span class="s0">return </span><span class="s1">cons</span>


<span class="s0">class </span><span class="s1">StructTest1(StructTestFunction):</span>
    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">g(x):</span>
        <span class="s0">return </span><span class="s1">-(numpy.sum(x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">) - </span><span class="s3">6.0</span><span class="s1">)</span>

    <span class="s1">cons = wrap_constraints(g)</span>


<span class="s1">test1_1 = StructTest1(bounds=[(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)]</span><span class="s0">,</span>
                      <span class="s1">expected_x=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
<span class="s1">test1_2 = StructTest1(bounds=[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span><span class="s0">,</span>
                      <span class="s1">expected_x=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
<span class="s1">test1_3 = StructTest1(bounds=[(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, None</span><span class="s1">)]</span><span class="s0">,</span>
                      <span class="s1">expected_x=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">StructTest2(StructTestFunction):</span>
    <span class="s4">&quot;&quot;&quot; 
    Scalar function with several minima to test all minimiser retrievals 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">(x - </span><span class="s3">30</span><span class="s1">) * numpy.sin(x)</span>

    <span class="s0">def </span><span class="s1">g(x):</span>
        <span class="s0">return </span><span class="s3">58 </span><span class="s1">- numpy.sum(x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">cons = wrap_constraints(g)</span>


<span class="s1">test2_1 = StructTest2(bounds=[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">60</span><span class="s1">)]</span><span class="s0">,</span>
                      <span class="s1">expected_x=[</span><span class="s3">1.53567906</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">expected_fun=-</span><span class="s3">28.44677132</span><span class="s0">,</span>
                      <span class="s5"># Important: test that funl return is in the correct</span>
                      <span class="s5"># order</span>
                      <span class="s1">expected_xl=numpy.array([[</span><span class="s3">1.53567906</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">55.01782167</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">7.80894889</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">48.74797493</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">14.07445705</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">42.4913859</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">20.31743841</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">36.28607535</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">26.43039605</span><span class="s1">]</span><span class="s0">,</span>
                                               <span class="s1">[</span><span class="s3">30.76371366</span><span class="s1">]])</span><span class="s0">,</span>

                      <span class="s1">expected_funl=numpy.array([-</span><span class="s3">28.44677132</span><span class="s0">, </span><span class="s1">-</span><span class="s3">24.99785984</span><span class="s0">,</span>
                                                 <span class="s1">-</span><span class="s3">22.16855376</span><span class="s0">, </span><span class="s1">-</span><span class="s3">18.72136195</span><span class="s0">,</span>
                                                 <span class="s1">-</span><span class="s3">15.89423937</span><span class="s0">, </span><span class="s1">-</span><span class="s3">12.45154942</span><span class="s0">,</span>
                                                 <span class="s1">-</span><span class="s3">9.63133158</span><span class="s0">, </span><span class="s1">-</span><span class="s3">6.20801301</span><span class="s0">,</span>
                                                 <span class="s1">-</span><span class="s3">3.43727232</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.46353338</span><span class="s1">])</span>
                      <span class="s1">)</span>

<span class="s1">test2_2 = StructTest2(bounds=[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4.5</span><span class="s1">)]</span><span class="s0">,</span>
                      <span class="s1">expected_x=[</span><span class="s3">1.53567906</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">expected_fun=[-</span><span class="s3">28.44677132</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">expected_xl=numpy.array([[</span><span class="s3">1.53567906</span><span class="s1">]])</span><span class="s0">,</span>
                      <span class="s1">expected_funl=numpy.array([-</span><span class="s3">28.44677132</span><span class="s1">])</span>
                      <span class="s1">)</span>


<span class="s0">class </span><span class="s1">StructTest3(StructTestFunction):</span>
    <span class="s4">&quot;&quot;&quot; 
    Hock and Schittkowski 18 problem (HS18). Hoch and Schittkowski (1981) 
    http://www.ai7.uni-bayreuth.de/test_problem_coll.pdf 
    Minimize: f = 0.01 * (x_1)**2 + (x_2)**2 
 
    Subject to: x_1 * x_2 - 25.0 &gt;= 0, 
                (x_1)**2 + (x_2)**2 - 25.0 &gt;= 0, 
                2 &lt;= x_1 &lt;= 50, 
                0 &lt;= x_2 &lt;= 50. 
 
    Approx. Answer: 
        f([(250)**0.5 , (2.5)**0.5]) = 5.0 
 
 
    &quot;&quot;&quot;</span>

    <span class="s5"># amended to test vectorisation of constraints</span>
    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s3">0.01 </span><span class="s1">* (x[</span><span class="s3">0</span><span class="s1">]) ** </span><span class="s3">2 </span><span class="s1">+ (x[</span><span class="s3">1</span><span class="s1">]) ** </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">g1(x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] * x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">25.0</span>

    <span class="s0">def </span><span class="s1">g2(x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">25.0</span>

    <span class="s5"># g = (g1, g2)</span>
    <span class="s5"># cons = wrap_constraints(g)</span>

    <span class="s0">def </span><span class="s1">g(x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] * x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">25.0</span><span class="s0">, </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">25.0</span>

    <span class="s5"># this checks that shgo can be sent new-style constraints</span>
    <span class="s1">__nlc = NonlinearConstraint(g</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.inf)</span>
    <span class="s1">cons = (__nlc</span><span class="s0">,</span><span class="s1">)</span>

<span class="s1">test3_1 = StructTest3(bounds=[(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)]</span><span class="s0">,</span>
                      <span class="s1">expected_x=[</span><span class="s3">250 </span><span class="s1">** </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">2.5 </span><span class="s1">** </span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">expected_fun=</span><span class="s3">5.0</span>
                      <span class="s1">)</span>


<span class="s0">class </span><span class="s1">StructTest4(StructTestFunction):</span>
    <span class="s4">&quot;&quot;&quot; 
    Hock and Schittkowski 11 problem (HS11). Hoch and Schittkowski (1981) 
 
    NOTE: Did not find in original reference to HS collection, refer to 
          Henderson (2015) problem 7 instead. 02.03.2016 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">((x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">10</span><span class="s1">) ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">5 </span><span class="s1">* (x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">12</span><span class="s1">) ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">2</span><span class="s1">] ** </span><span class="s3">4</span>
                <span class="s1">+ </span><span class="s3">3 </span><span class="s1">* (x[</span><span class="s3">3</span><span class="s1">] - </span><span class="s3">11</span><span class="s1">) ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">10 </span><span class="s1">* x[</span><span class="s3">4</span><span class="s1">] ** </span><span class="s3">6 </span><span class="s1">+ </span><span class="s3">7 </span><span class="s1">* x[</span><span class="s3">5</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span>
                    <span class="s3">6</span><span class="s1">] ** </span><span class="s3">4</span>
                <span class="s1">- </span><span class="s3">4 </span><span class="s1">* x[</span><span class="s3">5</span><span class="s1">] * x[</span><span class="s3">6</span><span class="s1">] - </span><span class="s3">10 </span><span class="s1">* x[</span><span class="s3">5</span><span class="s1">] - </span><span class="s3">8 </span><span class="s1">* x[</span><span class="s3">6</span><span class="s1">]</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">g1(x):</span>
        <span class="s0">return </span><span class="s1">-(</span><span class="s3">2 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">3 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">4 </span><span class="s1">+ x[</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">4 </span><span class="s1">* x[</span><span class="s3">3</span><span class="s1">] ** </span><span class="s3">2</span>
                 <span class="s1">+ </span><span class="s3">5 </span><span class="s1">* x[</span><span class="s3">4</span><span class="s1">] - </span><span class="s3">127</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">g2(x):</span>
        <span class="s0">return </span><span class="s1">-(</span><span class="s3">7 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">3 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">10 </span><span class="s1">* x[</span><span class="s3">2</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">3</span><span class="s1">] - x[</span><span class="s3">4</span><span class="s1">] - </span><span class="s3">282.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">g3(x):</span>
        <span class="s0">return </span><span class="s1">-(</span><span class="s3">23 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">6 </span><span class="s1">* x[</span><span class="s3">5</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">8 </span><span class="s1">* x[</span><span class="s3">6</span><span class="s1">] - </span><span class="s3">196</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">g4(x):</span>
        <span class="s0">return </span><span class="s1">-(</span><span class="s3">4 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">3 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] * x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">2 </span><span class="s1">* x[</span><span class="s3">2</span><span class="s1">] ** </span><span class="s3">2</span>
                 <span class="s1">+ </span><span class="s3">5 </span><span class="s1">* x[</span><span class="s3">5</span><span class="s1">] - </span><span class="s3">11 </span><span class="s1">* x[</span><span class="s3">6</span><span class="s1">])</span>

    <span class="s1">g = (g1</span><span class="s0">, </span><span class="s1">g2</span><span class="s0">, </span><span class="s1">g3</span><span class="s0">, </span><span class="s1">g4)</span>

    <span class="s1">cons = wrap_constraints(g)</span>


<span class="s1">test4_1 = StructTest4(bounds=[(-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">] * </span><span class="s3">7</span><span class="s0">,</span>
                      <span class="s1">expected_x=[</span><span class="s3">2.330499</span><span class="s0">, </span><span class="s3">1.951372</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.4775414</span><span class="s0">,</span>
                                  <span class="s3">4.365726</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.6244870</span><span class="s0">, </span><span class="s3">1.038131</span><span class="s0">, </span><span class="s3">1.594227</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">expected_fun=</span><span class="s3">680.6300573</span>
                      <span class="s1">)</span>


<span class="s0">class </span><span class="s1">StructTest5(StructTestFunction):</span>
    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">(-(x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">47.0</span><span class="s1">)</span>
                <span class="s1">* numpy.sin(numpy.sqrt(abs(x[</span><span class="s3">0</span><span class="s1">] / </span><span class="s3">2.0 </span><span class="s1">+ (x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">47.0</span><span class="s1">))))</span>
                <span class="s1">- x[</span><span class="s3">0</span><span class="s1">] * numpy.sin(numpy.sqrt(abs(x[</span><span class="s3">0</span><span class="s1">] - (x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">47.0</span><span class="s1">))))</span>
                <span class="s1">)</span>

    <span class="s1">g = </span><span class="s0">None</span>
    <span class="s1">cons = wrap_constraints(g)</span>


<span class="s1">test5_1 = StructTest5(bounds=[(-</span><span class="s3">512</span><span class="s0">, </span><span class="s3">512</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">512</span><span class="s0">, </span><span class="s3">512</span><span class="s1">)]</span><span class="s0">,</span>
                      <span class="s1">expected_fun=[-</span><span class="s3">959.64066272085051</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">expected_x=[</span><span class="s3">512.</span><span class="s0">, </span><span class="s3">404.23180542</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">StructTestLJ(StructTestFunction):</span>
    <span class="s4">&quot;&quot;&quot; 
    LennardJones objective function. Used to test symmetry constraints 
    settings. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">print(</span><span class="s2">f'x = </span><span class="s0">{</span><span class="s1">x</span><span class="s0">}</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">self.N = args[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">k = int(self.N / </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">s = </span><span class="s3">0.0</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(k - </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(i + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">k):</span>
                <span class="s1">a = </span><span class="s3">3 </span><span class="s1">* i</span>
                <span class="s1">b = </span><span class="s3">3 </span><span class="s1">* j</span>
                <span class="s1">xd = x[a] - x[b]</span>
                <span class="s1">yd = x[a + </span><span class="s3">1</span><span class="s1">] - x[b + </span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">zd = x[a + </span><span class="s3">2</span><span class="s1">] - x[b + </span><span class="s3">2</span><span class="s1">]</span>
                <span class="s1">ed = xd * xd + yd * yd + zd * zd</span>
                <span class="s1">ud = ed * ed * ed</span>
                <span class="s0">if </span><span class="s1">ed &gt; </span><span class="s3">0.0</span><span class="s1">:</span>
                    <span class="s1">s += (</span><span class="s3">1.0 </span><span class="s1">/ ud - </span><span class="s3">2.0</span><span class="s1">) / ud</span>

        <span class="s0">return </span><span class="s1">s</span>

    <span class="s1">g = </span><span class="s0">None</span>
    <span class="s1">cons = wrap_constraints(g)</span>


<span class="s1">N = </span><span class="s3">6</span>
<span class="s1">boundsLJ = list(zip([-</span><span class="s3">4.0</span><span class="s1">] * </span><span class="s3">6</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s1">] * </span><span class="s3">6</span><span class="s1">))</span>

<span class="s1">testLJ = StructTestLJ(bounds=boundsLJ</span><span class="s0">,</span>
                      <span class="s1">expected_fun=[-</span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">expected_x=</span><span class="s0">None,</span>
                      <span class="s5"># expected_x=[-2.71247337e-08,</span>
                      <span class="s5">#            -2.71247337e-08,</span>
                      <span class="s5">#            -2.50000222e+00,</span>
                      <span class="s5">#            -2.71247337e-08,</span>
                      <span class="s5">#            -2.71247337e-08,</span>
                      <span class="s5">#            -1.50000222e+00]</span>
                      <span class="s1">)</span>


<span class="s0">class </span><span class="s1">StructTestS(StructTestFunction):</span>
    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">((x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">0.5</span><span class="s1">) ** </span><span class="s3">2 </span><span class="s1">+ (x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">0.5</span><span class="s1">) ** </span><span class="s3">2</span>
                <span class="s1">+ (x[</span><span class="s3">2</span><span class="s1">] - </span><span class="s3">0.5</span><span class="s1">) ** </span><span class="s3">2 </span><span class="s1">+ (x[</span><span class="s3">3</span><span class="s1">] - </span><span class="s3">0.5</span><span class="s1">) ** </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">g = </span><span class="s0">None</span>
    <span class="s1">cons = wrap_constraints(g)</span>


<span class="s1">test_s = StructTestS(bounds=[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">] * </span><span class="s3">4</span><span class="s0">,</span>
                     <span class="s1">expected_fun=</span><span class="s3">0.0</span><span class="s0">,</span>
                     <span class="s1">expected_x=numpy.ones(</span><span class="s3">4</span><span class="s1">) - </span><span class="s3">0.5</span>
                     <span class="s1">)</span>


<span class="s0">class </span><span class="s1">StructTestTable(StructTestFunction):</span>
    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">if </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">3.0 </span><span class="s0">and </span><span class="s1">x[</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">3.0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">50</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">100</span>

    <span class="s1">g = </span><span class="s0">None</span>
    <span class="s1">cons = wrap_constraints(g)</span>


<span class="s1">test_table = StructTestTable(bounds=[(-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)]</span><span class="s0">,</span>
                             <span class="s1">expected_fun=[</span><span class="s3">50</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">expected_x=[</span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">StructTestInfeasible(StructTestFunction):</span>
    <span class="s4">&quot;&quot;&quot; 
    Test function with no feasible domain. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">g1(x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">g2(x):</span>
        <span class="s0">return </span><span class="s1">-(x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">g3(x):</span>
        <span class="s0">return </span><span class="s1">-x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">g4(x):</span>
        <span class="s0">return </span><span class="s1">-(-x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">g = (g1</span><span class="s0">, </span><span class="s1">g2</span><span class="s0">, </span><span class="s1">g3</span><span class="s0">, </span><span class="s1">g4)</span>
    <span class="s1">cons = wrap_constraints(g)</span>


<span class="s1">test_infeasible = StructTestInfeasible(bounds=[(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span><span class="s0">,</span>
                                       <span class="s1">expected_fun=</span><span class="s0">None,</span>
                                       <span class="s1">expected_x=</span><span class="s0">None</span>
                                       <span class="s1">)</span>


<span class="s1">@pytest.mark.skip(</span><span class="s2">&quot;Not a test&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">run_test(test</span><span class="s0">, </span><span class="s1">args=()</span><span class="s0">, </span><span class="s1">test_atol=</span><span class="s3">1e-5</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">iters=</span><span class="s0">None,</span>
             <span class="s1">callback=</span><span class="s0">None, </span><span class="s1">minimizer_kwargs=</span><span class="s0">None, </span><span class="s1">options=</span><span class="s0">None,</span>
             <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">1</span><span class="s1">):</span>
    <span class="s1">res = shgo(test.f</span><span class="s0">, </span><span class="s1">test.bounds</span><span class="s0">, </span><span class="s1">args=args</span><span class="s0">, </span><span class="s1">constraints=test.cons</span><span class="s0">,</span>
               <span class="s1">n=n</span><span class="s0">, </span><span class="s1">iters=iters</span><span class="s0">, </span><span class="s1">callback=callback</span><span class="s0">,</span>
               <span class="s1">minimizer_kwargs=minimizer_kwargs</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
               <span class="s1">sampling_method=sampling_method</span><span class="s0">, </span><span class="s1">workers=workers)</span>

    <span class="s1">print(</span><span class="s2">f'res = </span><span class="s0">{</span><span class="s1">res</span><span class="s0">}</span><span class="s2">'</span><span class="s1">)</span>
    <span class="s1">logging.info(</span><span class="s2">f'res = </span><span class="s0">{</span><span class="s1">res</span><span class="s0">}</span><span class="s2">'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">test.expected_x </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">numpy.testing.assert_allclose(res.x</span><span class="s0">, </span><span class="s1">test.expected_x</span><span class="s0">,</span>
                                      <span class="s1">rtol=test_atol</span><span class="s0">,</span>
                                      <span class="s1">atol=test_atol)</span>

    <span class="s5"># (Optional tests)</span>
    <span class="s0">if </span><span class="s1">test.expected_fun </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">numpy.testing.assert_allclose(res.fun</span><span class="s0">,</span>
                                      <span class="s1">test.expected_fun</span><span class="s0">,</span>
                                      <span class="s1">atol=test_atol)</span>

    <span class="s0">if </span><span class="s1">test.expected_xl </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">numpy.testing.assert_allclose(res.xl</span><span class="s0">,</span>
                                      <span class="s1">test.expected_xl</span><span class="s0">,</span>
                                      <span class="s1">atol=test_atol)</span>

    <span class="s0">if </span><span class="s1">test.expected_funl </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">numpy.testing.assert_allclose(res.funl</span><span class="s0">,</span>
                                      <span class="s1">test.expected_funl</span><span class="s0">,</span>
                                      <span class="s1">atol=test_atol)</span>
    <span class="s0">return</span>


<span class="s5"># Base test functions:</span>
<span class="s0">class </span><span class="s1">TestShgoSobolTestFunctions:</span>
    <span class="s4">&quot;&quot;&quot; 
    Global optimisation tests with Sobol sampling: 
    &quot;&quot;&quot;</span>

    <span class="s5"># Sobol algorithm</span>
    <span class="s0">def </span><span class="s1">test_f1_1_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Multivariate test function 1: 
        x[0]**2 + x[1]**2 with bounds=[(-1, 6), (-1, 6)]&quot;&quot;&quot;</span>
        <span class="s1">run_test(test1_1)</span>

    <span class="s0">def </span><span class="s1">test_f1_2_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Multivariate test function 1: 
         x[0]**2 + x[1]**2 with bounds=[(0, 1), (0, 1)]&quot;&quot;&quot;</span>
        <span class="s1">run_test(test1_2)</span>

    <span class="s0">def </span><span class="s1">test_f1_3_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Multivariate test function 1: 
        x[0]**2 + x[1]**2 with bounds=[(None, None),(None, None)]&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">run_test(test1_3</span><span class="s0">, </span><span class="s1">options=options)</span>

    <span class="s0">def </span><span class="s1">test_f2_1_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Univariate test function on 
        f(x) = (x - 30) * sin(x) with bounds=[(0, 60)]&quot;&quot;&quot;</span>
        <span class="s1">run_test(test2_1)</span>

    <span class="s0">def </span><span class="s1">test_f2_2_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Univariate test function on 
        f(x) = (x - 30) * sin(x) bounds=[(0, 4.5)]&quot;&quot;&quot;</span>
        <span class="s1">run_test(test2_2)</span>

    <span class="s0">def </span><span class="s1">test_f3_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;NLP: Hock and Schittkowski problem 18&quot;&quot;&quot;</span>
        <span class="s1">run_test(test3_1)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_f4_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;NLP: (High dimensional) Hock and Schittkowski 11 problem (HS11)&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'infty_constraints'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>
        <span class="s5"># run_test(test4_1, n=990, options=options)</span>
        <span class="s1">run_test(test4_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">990 </span><span class="s1">* </span><span class="s3">2</span><span class="s0">, </span><span class="s1">options=options)</span>

    <span class="s0">def </span><span class="s1">test_f5_1_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;NLP: Eggholder, multimodal&quot;&quot;&quot;</span>
        <span class="s5"># run_test(test5_1, n=30)</span>
        <span class="s1">run_test(test5_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">60</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f5_2_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;NLP: Eggholder, multimodal&quot;&quot;&quot;</span>
        <span class="s5"># run_test(test5_1, n=60, iters=5)</span>
        <span class="s1">run_test(test5_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">60</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">5</span><span class="s1">)</span>

        <span class="s5"># def test_t911(self):</span>
        <span class="s5">#    &quot;&quot;&quot;1D tabletop function&quot;&quot;&quot;</span>
        <span class="s5">#    run_test(test11_1)</span>


<span class="s0">class </span><span class="s1">TestShgoSimplicialTestFunctions:</span>
    <span class="s4">&quot;&quot;&quot; 
    Global optimisation tests with Simplicial sampling: 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_f1_1_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;Multivariate test function 1: 
        x[0]**2 + x[1]**2 with bounds=[(-1, 6), (-1, 6)]&quot;&quot;&quot;</span>
        <span class="s1">run_test(test1_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f1_2_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;Multivariate test function 1: 
        x[0]**2 + x[1]**2 with bounds=[(0, 1), (0, 1)]&quot;&quot;&quot;</span>
        <span class="s1">run_test(test1_2</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f1_3_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;Multivariate test function 1: x[0]**2 + x[1]**2 
        with bounds=[(None, None),(None, None)]&quot;&quot;&quot;</span>
        <span class="s1">run_test(test1_3</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f2_1_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;Univariate test function on 
        f(x) = (x - 30) * sin(x) with bounds=[(0, 60)]&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'minimize_every_iter'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>
        <span class="s1">run_test(test2_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">200</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">7</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f2_2_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;Univariate test function on 
        f(x) = (x - 30) * sin(x) bounds=[(0, 4.5)]&quot;&quot;&quot;</span>
        <span class="s1">run_test(test2_2</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f3_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;NLP: Hock and Schittkowski problem 18&quot;&quot;&quot;</span>
        <span class="s1">run_test(test3_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_f4_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;NLP: (High dimensional) Hock and Schittkowski 11 problem (HS11)&quot;&quot;&quot;</span>
        <span class="s1">run_test(test4_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_lj_symmetry_old(self):</span>
        <span class="s4">&quot;&quot;&quot;LJ: Symmetry-constrained test function&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'symmetry'</span><span class="s1">: </span><span class="s0">True,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">args = (</span><span class="s3">6</span><span class="s0">,</span><span class="s1">)  </span><span class="s5"># Number of atoms</span>
        <span class="s1">run_test(testLJ</span><span class="s0">, </span><span class="s1">args=args</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">300</span><span class="s0">,</span>
                 <span class="s1">options=options</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f5_1_lj_symmetry(self):</span>
        <span class="s4">&quot;&quot;&quot;LJ: Symmetry constrained test function&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'symmetry'</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s1">] * </span><span class="s3">6</span><span class="s0">,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">args = (</span><span class="s3">6</span><span class="s0">,</span><span class="s1">)  </span><span class="s5"># No. of atoms</span>

        <span class="s1">run_test(testLJ</span><span class="s0">, </span><span class="s1">args=args</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">300</span><span class="s0">,</span>
                 <span class="s1">options=options</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f5_2_cons_symmetry(self):</span>
        <span class="s4">&quot;&quot;&quot;Symmetry constrained test function&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'symmetry'</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>

        <span class="s1">run_test(test1_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">200</span><span class="s0">,</span>
                 <span class="s1">options=options</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f5_3_cons_symmetry(self):</span>
        <span class="s4">&quot;&quot;&quot;Assymmetrically constrained test function&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'symmetry'</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>

        <span class="s1">run_test(test_s</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">10000</span><span class="s0">,</span>
                 <span class="s1">options=options</span><span class="s0">,</span>
                 <span class="s1">iters=</span><span class="s3">1</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skip(</span><span class="s2">&quot;Not a test&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_f0_min_variance(self):</span>
        <span class="s4">&quot;&quot;&quot;Return a minimum on a perfectly symmetric problem, based on 
            gh10429&quot;&quot;&quot;</span>
        <span class="s1">avg = </span><span class="s3">0.5  </span><span class="s5"># Given average value of x</span>
        <span class="s1">cons = {</span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'eq'</span><span class="s0">, </span><span class="s2">'fun'</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: numpy.mean(x) - avg}</span>

        <span class="s5"># Minimize the variance of x under the given constraint</span>
        <span class="s1">res = shgo(numpy.var</span><span class="s0">, </span><span class="s1">bounds=</span><span class="s3">6 </span><span class="s1">* [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">constraints=cons)</span>
        <span class="s0">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skip(</span><span class="s2">&quot;Not a test&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_f0_min_variance_1D(self):</span>
        <span class="s4">&quot;&quot;&quot;Return a minimum on a perfectly symmetric 1D problem, based on 
            gh10538&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s0">return </span><span class="s1">x * (x - </span><span class="s3">1.0</span><span class="s1">) * (x - </span><span class="s3">0.5</span><span class="s1">)</span>

        <span class="s1">bounds = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span>
        <span class="s1">res = shgo(fun</span><span class="s0">, </span><span class="s1">bounds=bounds)</span>
        <span class="s1">ref = minimize_scalar(fun</span><span class="s0">, </span><span class="s1">bounds=bounds[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">ref.fun)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s0">, </span><span class="s1">ref.x</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-6</span><span class="s1">)</span>

<span class="s5"># Argument test functions</span>
<span class="s0">class </span><span class="s1">TestShgoArguments:</span>
    <span class="s0">def </span><span class="s1">test_1_1_simpl_iter(self):</span>
        <span class="s4">&quot;&quot;&quot;Iterative simplicial sampling on TestFunction 1 (multivariate)&quot;&quot;&quot;</span>
        <span class="s1">run_test(test1_2</span><span class="s0">, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">iters=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_1_2_simpl_iter(self):</span>
        <span class="s4">&quot;&quot;&quot;Iterative simplicial on TestFunction 2 (univariate)&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'minimize_every_iter'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>
        <span class="s1">run_test(test2_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">iters=</span><span class="s3">9</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_2_1_sobol_iter(self):</span>
        <span class="s4">&quot;&quot;&quot;Iterative Sobol sampling on TestFunction 1 (multivariate)&quot;&quot;&quot;</span>
        <span class="s1">run_test(test1_2</span><span class="s0">, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_2_2_sobol_iter(self):</span>
        <span class="s4">&quot;&quot;&quot;Iterative Sobol sampling on TestFunction 2 (univariate)&quot;&quot;&quot;</span>
        <span class="s1">res = shgo(test2_1.f</span><span class="s0">, </span><span class="s1">test2_1.bounds</span><span class="s0">, </span><span class="s1">constraints=test2_1.cons</span><span class="s0">,</span>
                   <span class="s1">n=</span><span class="s0">None, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

        <span class="s1">numpy.testing.assert_allclose(res.x</span><span class="s0">, </span><span class="s1">test2_1.expected_x</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-5</span><span class="s0">,</span>
                                      <span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">test2_1.expected_fun</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_3_1_disp_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;Iterative sampling on TestFunction 1 and 2  (multi and univariate) 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">callback_func(x):</span>
            <span class="s1">print(</span><span class="s2">&quot;Local minimization callback test&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">test </span><span class="s0">in </span><span class="s1">[test1_1</span><span class="s0">, </span><span class="s1">test2_1]:</span>
            <span class="s1">shgo(test.f</span><span class="s0">, </span><span class="s1">test.bounds</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s0">,</span>
                 <span class="s1">callback=callback_func</span><span class="s0">, </span><span class="s1">options={</span><span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>
            <span class="s1">shgo(test.f</span><span class="s0">, </span><span class="s1">test.bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s0">,</span>
                 <span class="s1">callback=callback_func</span><span class="s0">, </span><span class="s1">options={</span><span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>

    <span class="s0">def </span><span class="s1">test_3_2_disp_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Iterative sampling on TestFunction 1 and 2 (multi and univariate)&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">callback_func(x):</span>
            <span class="s1">print(</span><span class="s2">&quot;Local minimization callback test&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">test </span><span class="s0">in </span><span class="s1">[test1_1</span><span class="s0">, </span><span class="s1">test2_1]:</span>
            <span class="s1">shgo(test.f</span><span class="s0">, </span><span class="s1">test.bounds</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s0">,</span>
                 <span class="s1">callback=callback_func</span><span class="s0">, </span><span class="s1">options={</span><span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>

            <span class="s1">shgo(test.f</span><span class="s0">, </span><span class="s1">test.bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s0">,</span>
                 <span class="s1">callback=callback_func</span><span class="s0">, </span><span class="s1">options={</span><span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>

    <span class="s0">def </span><span class="s1">test_args_gh14589(self):</span>
        <span class="s4">&quot;&quot;&quot;Using `args` used to cause `shgo` to fail; see #14589, #15986, 
        #16506&quot;&quot;&quot;</span>
        <span class="s1">res = shgo(func=</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z: x * z + y</span><span class="s0">, </span><span class="s1">bounds=[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">args=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
                   <span class="s1">)</span>
        <span class="s1">ref = shgo(func=</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">2 </span><span class="s1">* x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">bounds=[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)])</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">ref.fun)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s0">, </span><span class="s1">ref.x)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_4_1_known_f_min(self):</span>
        <span class="s4">&quot;&quot;&quot;Test known function minima stopping criteria&quot;&quot;&quot;</span>
        <span class="s5"># Specify known function value</span>
        <span class="s1">options = {</span><span class="s2">'f_min'</span><span class="s1">: test4_1.expected_fun</span><span class="s0">,</span>
                   <span class="s2">'f_tol'</span><span class="s1">: </span><span class="s3">1e-6</span><span class="s0">,</span>
                   <span class="s2">'minimize_every_iter'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s5"># TODO: Make default n higher for faster tests</span>
        <span class="s1">run_test(test4_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">test_atol=</span><span class="s3">1e-5</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_4_2_known_f_min(self):</span>
        <span class="s4">&quot;&quot;&quot;Test Global mode limiting local evalutions&quot;&quot;&quot;</span>
        <span class="s1">options = {  </span><span class="s5"># Specify known function value</span>
            <span class="s2">'f_min'</span><span class="s1">: test4_1.expected_fun</span><span class="s0">,</span>
            <span class="s2">'f_tol'</span><span class="s1">: </span><span class="s3">1e-6</span><span class="s0">,</span>
            <span class="s5"># Specify number of local iterations to perform</span>
            <span class="s2">'minimize_every_iter'</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">'local_iter'</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}</span>

        <span class="s1">run_test(test4_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">test_atol=</span><span class="s3">1e-5</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_4_4_known_f_min(self):</span>
        <span class="s4">&quot;&quot;&quot;Test Global mode limiting local evaluations for 1D funcs&quot;&quot;&quot;</span>
        <span class="s1">options = {  </span><span class="s5"># Specify known function value</span>
            <span class="s2">'f_min'</span><span class="s1">: test2_1.expected_fun</span><span class="s0">,</span>
            <span class="s2">'f_tol'</span><span class="s1">: </span><span class="s3">1e-6</span><span class="s0">,</span>
            <span class="s5"># Specify number of local iterations to perform+</span>
            <span class="s2">'minimize_every_iter'</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">'local_iter'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
            <span class="s2">'infty_constraints'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>

        <span class="s1">res = shgo(test2_1.f</span><span class="s0">, </span><span class="s1">test2_1.bounds</span><span class="s0">, </span><span class="s1">constraints=test2_1.cons</span><span class="s0">,</span>
                   <span class="s1">n=</span><span class="s0">None, </span><span class="s1">iters=</span><span class="s0">None, </span><span class="s1">options=options</span><span class="s0">,</span>
                   <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_allclose(res.x</span><span class="s0">, </span><span class="s1">test2_1.expected_x</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-5</span><span class="s0">,</span>
                                      <span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_5_1_simplicial_argless(self):</span>
        <span class="s4">&quot;&quot;&quot;Test Default simplicial sampling settings on TestFunction 1&quot;&quot;&quot;</span>
        <span class="s1">res = shgo(test1_1.f</span><span class="s0">, </span><span class="s1">test1_1.bounds</span><span class="s0">, </span><span class="s1">constraints=test1_1.cons)</span>
        <span class="s1">numpy.testing.assert_allclose(res.x</span><span class="s0">, </span><span class="s1">test1_1.expected_x</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-5</span><span class="s0">,</span>
                                      <span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_5_2_sobol_argless(self):</span>
        <span class="s4">&quot;&quot;&quot;Test Default sobol sampling settings on TestFunction 1&quot;&quot;&quot;</span>
        <span class="s1">res = shgo(test1_1.f</span><span class="s0">, </span><span class="s1">test1_1.bounds</span><span class="s0">, </span><span class="s1">constraints=test1_1.cons</span><span class="s0">,</span>
                   <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_allclose(res.x</span><span class="s0">, </span><span class="s1">test1_1.expected_x</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-5</span><span class="s0">,</span>
                                      <span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_6_1_simplicial_max_iter(self):</span>
        <span class="s4">&quot;&quot;&quot;Test that maximum iteration option works on TestFunction 3&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'max_iter'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span>
        <span class="s1">res = shgo(test3_1.f</span><span class="s0">, </span><span class="s1">test3_1.bounds</span><span class="s0">, </span><span class="s1">constraints=test3_1.cons</span><span class="s0">,</span>
                   <span class="s1">options=options</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_allclose(res.x</span><span class="s0">, </span><span class="s1">test3_1.expected_x</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-5</span><span class="s0">,</span>
                                      <span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">test3_1.expected_fun</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_6_2_simplicial_min_iter(self):</span>
        <span class="s4">&quot;&quot;&quot;Test that maximum iteration option works on TestFunction 3&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'min_iter'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span>
        <span class="s1">res = shgo(test3_1.f</span><span class="s0">, </span><span class="s1">test3_1.bounds</span><span class="s0">, </span><span class="s1">constraints=test3_1.cons</span><span class="s0">,</span>
                   <span class="s1">options=options</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_allclose(res.x</span><span class="s0">, </span><span class="s1">test3_1.expected_x</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-5</span><span class="s0">,</span>
                                      <span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">test3_1.expected_fun</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_7_1_minkwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Test the minimizer_kwargs arguments for solvers with constraints&quot;&quot;&quot;</span>
        <span class="s5"># Test solvers</span>
        <span class="s0">for </span><span class="s1">solver </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'COBYLA'</span><span class="s0">, </span><span class="s2">'SLSQP'</span><span class="s1">]:</span>
            <span class="s5"># Note that passing global constraints to SLSQP is tested in other</span>
            <span class="s5"># unittests which run test4_1 normally</span>
            <span class="s1">minimizer_kwargs = {</span><span class="s2">'method'</span><span class="s1">: solver</span><span class="s0">,</span>
                                <span class="s2">'constraints'</span><span class="s1">: test3_1.cons}</span>
            <span class="s1">run_test(test3_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">test_atol=</span><span class="s3">1e-3</span><span class="s0">,</span>
                     <span class="s1">minimizer_kwargs=minimizer_kwargs</span><span class="s0">,</span>
                     <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_7_2_minkwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Test the minimizer_kwargs default inits&quot;&quot;&quot;</span>
        <span class="s1">minimizer_kwargs = {</span><span class="s2">'ftol'</span><span class="s1">: </span><span class="s3">1e-5</span><span class="s1">}</span>
        <span class="s1">options = {</span><span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}  </span><span class="s5"># For coverage purposes</span>
        <span class="s1">SHGO(test3_1.f</span><span class="s0">, </span><span class="s1">test3_1.bounds</span><span class="s0">, </span><span class="s1">constraints=test3_1.cons[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
             <span class="s1">minimizer_kwargs=minimizer_kwargs</span><span class="s0">, </span><span class="s1">options=options)</span>

    <span class="s0">def </span><span class="s1">test_7_3_minkwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Test minimizer_kwargs arguments for solvers without constraints&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">solver </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'Nelder-Mead'</span><span class="s0">, </span><span class="s2">'Powell'</span><span class="s0">, </span><span class="s2">'CG'</span><span class="s0">, </span><span class="s2">'BFGS'</span><span class="s0">, </span><span class="s2">'Newton-CG'</span><span class="s0">,</span>
                       <span class="s2">'L-BFGS-B'</span><span class="s0">, </span><span class="s2">'TNC'</span><span class="s0">, </span><span class="s2">'dogleg'</span><span class="s0">, </span><span class="s2">'trust-ncg'</span><span class="s0">, </span><span class="s2">'trust-exact'</span><span class="s0">,</span>
                       <span class="s2">'trust-krylov'</span><span class="s1">]:</span>
            <span class="s0">def </span><span class="s1">jac(x):</span>
                <span class="s0">return </span><span class="s1">numpy.array([</span><span class="s3">2 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">]]).T</span>

            <span class="s0">def </span><span class="s1">hess(x):</span>
                <span class="s0">return </span><span class="s1">numpy.array([[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]])</span>

            <span class="s1">minimizer_kwargs = {</span><span class="s2">'method'</span><span class="s1">: solver</span><span class="s0">,</span>
                                <span class="s2">'jac'</span><span class="s1">: jac</span><span class="s0">,</span>
                                <span class="s2">'hess'</span><span class="s1">: hess}</span>
            <span class="s1">logging.info(</span><span class="s2">f&quot;Solver = </span><span class="s0">{</span><span class="s1">solver</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s1">logging.info(</span><span class="s2">&quot;=&quot; </span><span class="s1">* </span><span class="s3">100</span><span class="s1">)</span>
            <span class="s1">run_test(test1_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">test_atol=</span><span class="s3">1e-3</span><span class="s0">,</span>
                     <span class="s1">minimizer_kwargs=minimizer_kwargs</span><span class="s0">,</span>
                     <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_8_homology_group_diff(self):</span>
        <span class="s1">options = {</span><span class="s2">'minhgrd'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
                   <span class="s2">'minimize_every_iter'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>

        <span class="s1">run_test(test1_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">iters=</span><span class="s0">None, </span><span class="s1">options=options</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_9_cons_g(self):</span>
        <span class="s4">&quot;&quot;&quot;Test single function constraint passing&quot;&quot;&quot;</span>
        <span class="s1">SHGO(test3_1.f</span><span class="s0">, </span><span class="s1">test3_1.bounds</span><span class="s0">, </span><span class="s1">constraints=test3_1.cons[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.xfail(IS_PYPY </span><span class="s0">and </span><span class="s1">sys.platform == </span><span class="s2">'win32'</span><span class="s0">,</span>
            <span class="s1">reason=</span><span class="s2">&quot;Failing and fix in PyPy not planned (see gh-18632)&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_10_finite_time(self):</span>
        <span class="s4">&quot;&quot;&quot;Test single function constraint passing&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'maxtime'</span><span class="s1">: </span><span class="s3">1e-15</span><span class="s1">}</span>

        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s1">time.sleep(</span><span class="s3">1e-14</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s3">0.0</span>

        <span class="s1">res = shgo(f</span><span class="s0">, </span><span class="s1">test1_1.bounds</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">options=options)</span>
        <span class="s5"># Assert that only 1 rather than 5 requested iterations ran:</span>
        <span class="s0">assert </span><span class="s1">res.nit == </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">test_11_f_min_0(self):</span>
        <span class="s4">&quot;&quot;&quot;Test to cover the case where f_lowest == 0&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'f_min'</span><span class="s1">: </span><span class="s3">0.0</span><span class="s0">,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">res = shgo(test1_2.f</span><span class="s0">, </span><span class="s1">test1_2.bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">iters=</span><span class="s0">None,</span>
                   <span class="s1">options=options</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_equal(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">res.x[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">numpy.testing.assert_equal(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">res.x[</span><span class="s3">1</span><span class="s1">])</span>

    <span class="s5"># @nottest</span>
    <span class="s1">@pytest.mark.skip(reason=</span><span class="s2">&quot;no way of currently testing this&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_12_sobol_inf_cons(self):</span>
        <span class="s4">&quot;&quot;&quot;Test to cover the case where f_lowest == 0&quot;&quot;&quot;</span>
        <span class="s5"># TODO: This test doesn't cover anything new, it is unknown what the</span>
        <span class="s5"># original test was intended for as it was never complete. Delete or</span>
        <span class="s5"># replace in the future.</span>
        <span class="s1">options = {</span><span class="s2">'maxtime'</span><span class="s1">: </span><span class="s3">1e-15</span><span class="s0">,</span>
                   <span class="s2">'f_min'</span><span class="s1">: </span><span class="s3">0.0</span><span class="s1">}</span>
        <span class="s1">res = shgo(test1_2.f</span><span class="s0">, </span><span class="s1">test1_2.bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">iters=</span><span class="s0">None,</span>
                   <span class="s1">options=options</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_equal(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">res.fun)</span>

    <span class="s0">def </span><span class="s1">test_13_high_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Test init of high-dimensional sobol sequences&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s0">return </span><span class="s3">0</span>

        <span class="s1">bounds = [(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">] * </span><span class="s3">41</span>
        <span class="s1">SHGOc = SHGO(f</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
        <span class="s5"># SHGOc.sobol_points(2, 50)</span>
        <span class="s1">SHGOc.sampling_function(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_14_local_iter(self):</span>
        <span class="s4">&quot;&quot;&quot;Test limited local iterations for a pseudo-global mode&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'local_iter'</span><span class="s1">: </span><span class="s3">4</span><span class="s1">}</span>
        <span class="s1">run_test(test5_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">60</span><span class="s0">, </span><span class="s1">options=options)</span>

    <span class="s0">def </span><span class="s1">test_15_min_every_iter(self):</span>
        <span class="s4">&quot;&quot;&quot;Test minimize every iter options and cover function cache&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'minimize_every_iter'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">run_test(test1_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">7</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                 <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_16_disp_bounds_minimizer(self):</span>
        <span class="s4">&quot;&quot;&quot;Test disp=True with minimizers that do not support bounds &quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">minimizer_kwargs = {</span><span class="s2">'method'</span><span class="s1">: </span><span class="s2">'nelder-mead'</span><span class="s1">}</span>
        <span class="s1">run_test(test1_2</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s0">,</span>
                 <span class="s1">options=options</span><span class="s0">, </span><span class="s1">minimizer_kwargs=minimizer_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_17_custom_sampling(self):</span>
        <span class="s4">&quot;&quot;&quot;Test the functionality to add custom sampling methods to shgo&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">sample(n</span><span class="s0">, </span><span class="s1">d):</span>
            <span class="s0">return </span><span class="s1">numpy.random.uniform(size=(n</span><span class="s0">, </span><span class="s1">d))</span>

        <span class="s1">run_test(test1_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">30</span><span class="s0">, </span><span class="s1">sampling_method=sample)</span>

    <span class="s0">def </span><span class="s1">test_18_bounds_class(self):</span>
        <span class="s5"># test that new and old bounds yield same result</span>
        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s0">return </span><span class="s1">numpy.square(x).sum()</span>

        <span class="s1">lb = [-</span><span class="s3">6.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5.</span><span class="s1">]</span>
        <span class="s1">ub = [-</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">3.</span><span class="s0">, </span><span class="s3">5.</span><span class="s1">]</span>
        <span class="s1">bounds_old = list(zip(lb</span><span class="s0">, </span><span class="s1">ub))</span>
        <span class="s1">bounds_new = Bounds(lb</span><span class="s0">, </span><span class="s1">ub)</span>

        <span class="s1">res_old_bounds = shgo(f</span><span class="s0">, </span><span class="s1">bounds_old)</span>
        <span class="s1">res_new_bounds = shgo(f</span><span class="s0">, </span><span class="s1">bounds_new)</span>

        <span class="s0">assert </span><span class="s1">res_new_bounds.nfev == res_old_bounds.nfev</span>
        <span class="s0">assert </span><span class="s1">res_new_bounds.message == res_old_bounds.message</span>
        <span class="s0">assert </span><span class="s1">res_new_bounds.success == res_old_bounds.success</span>
        <span class="s1">x_opt = numpy.array([-</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">])</span>
        <span class="s1">numpy.testing.assert_allclose(res_new_bounds.x</span><span class="s0">, </span><span class="s1">x_opt)</span>
        <span class="s1">numpy.testing.assert_allclose(res_new_bounds.x</span><span class="s0">,</span>
                                      <span class="s1">res_old_bounds.x)</span>

    <span class="s0">def </span><span class="s1">test_19_parallelization(self):</span>
        <span class="s4">&quot;&quot;&quot;Test the functionality to add custom sampling methods to shgo&quot;&quot;&quot;</span>

        <span class="s0">with </span><span class="s1">Pool(</span><span class="s3">2</span><span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
            <span class="s1">run_test(test1_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">30</span><span class="s0">, </span><span class="s1">workers=p.map)  </span><span class="s5"># Constrained</span>
        <span class="s1">run_test(test1_1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">30</span><span class="s0">, </span><span class="s1">workers=map)  </span><span class="s5"># Constrained</span>
        <span class="s0">with </span><span class="s1">Pool(</span><span class="s3">2</span><span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
            <span class="s1">run_test(test_s</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">30</span><span class="s0">, </span><span class="s1">workers=p.map)  </span><span class="s5"># Unconstrained</span>
        <span class="s1">run_test(test_s</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">30</span><span class="s0">, </span><span class="s1">workers=map)  </span><span class="s5"># Unconstrained</span>

    <span class="s0">def </span><span class="s1">test_20_constrained_args(self):</span>
        <span class="s4">&quot;&quot;&quot;Test that constraints can be passed to arguments&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">eggholder(x):</span>
            <span class="s0">return </span><span class="s1">(-(x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">47.0</span><span class="s1">)</span>
                    <span class="s1">* numpy.sin(numpy.sqrt(abs(x[</span><span class="s3">0</span><span class="s1">] / </span><span class="s3">2.0 </span><span class="s1">+ (x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">47.0</span><span class="s1">))))</span>
                    <span class="s1">- x[</span><span class="s3">0</span><span class="s1">] * numpy.sin(numpy.sqrt(abs(x[</span><span class="s3">0</span><span class="s1">] - (x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">47.0</span><span class="s1">))))</span>
                    <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">f(x):  </span><span class="s5"># (cattle-feed)</span>
            <span class="s0">return </span><span class="s3">24.55 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">26.75 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">39 </span><span class="s1">* x[</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">40.50 </span><span class="s1">* x[</span><span class="s3">3</span><span class="s1">]</span>

        <span class="s1">bounds = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">] * </span><span class="s3">4</span>

        <span class="s0">def </span><span class="s1">g1_modified(x</span><span class="s0">, </span><span class="s1">i):</span>
            <span class="s0">return </span><span class="s1">i * </span><span class="s3">2.3 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] + i * </span><span class="s3">5.6 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">11.1 </span><span class="s1">* x[</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">1.3 </span><span class="s1">* x[</span>
                <span class="s3">3</span><span class="s1">] - </span><span class="s3">5  </span><span class="s5"># &gt;=0</span>

        <span class="s0">def </span><span class="s1">g2(x):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">12 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">11.9 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">41.8 </span><span class="s1">* x[</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">52.1 </span><span class="s1">* x[</span><span class="s3">3</span><span class="s1">] - </span><span class="s3">21</span>
                    <span class="s1">- </span><span class="s3">1.645 </span><span class="s1">* numpy.sqrt(</span><span class="s3">0.28 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">0.19 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2</span>
                                         <span class="s1">+ </span><span class="s3">20.5 </span><span class="s1">* x[</span><span class="s3">2</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">0.62 </span><span class="s1">* x[</span><span class="s3">3</span><span class="s1">] ** </span><span class="s3">2</span><span class="s1">)</span>
                    <span class="s1">)  </span><span class="s5"># &gt;=0</span>

        <span class="s0">def </span><span class="s1">h1(x):</span>
            <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] + x[</span><span class="s3">2</span><span class="s1">] + x[</span><span class="s3">3</span><span class="s1">] - </span><span class="s3">1  </span><span class="s5"># == 0</span>

        <span class="s1">cons = ({</span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'ineq'</span><span class="s0">, </span><span class="s2">'fun'</span><span class="s1">: g1_modified</span><span class="s0">, </span><span class="s2">&quot;args&quot;</span><span class="s1">: (</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)}</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'ineq'</span><span class="s0">, </span><span class="s2">'fun'</span><span class="s1">: g2}</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'eq'</span><span class="s0">, </span><span class="s2">'fun'</span><span class="s1">: h1})</span>

        <span class="s1">shgo(f</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">300</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">constraints=cons)</span>
        <span class="s5"># using constrain with arguments AND sampling method sobol</span>
        <span class="s1">shgo(f</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">300</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">constraints=cons</span><span class="s0">,</span>
             <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_21_1_jac_true(self):</span>
        <span class="s4">&quot;&quot;&quot;Test that shgo can handle objective functions that return the 
        gradient alongside the objective value. Fixes gh-13547&quot;&quot;&quot;</span>
        <span class="s5"># previous</span>
        <span class="s0">def </span><span class="s1">func(x):</span>
            <span class="s0">return </span><span class="s1">numpy.sum(numpy.power(x</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* x</span>

        <span class="s1">shgo(</span>
            <span class="s1">func</span><span class="s0">,</span>
            <span class="s1">bounds=[[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">iters=</span><span class="s3">5</span><span class="s0">,</span>
            <span class="s1">sampling_method=</span><span class="s2">&quot;sobol&quot;</span><span class="s0">,</span>
            <span class="s1">minimizer_kwargs={</span><span class="s2">'method'</span><span class="s1">: </span><span class="s2">'SLSQP'</span><span class="s0">, </span><span class="s2">'jac'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s5"># new</span>
        <span class="s0">def </span><span class="s1">func(x):</span>
            <span class="s0">return </span><span class="s1">numpy.sum(x ** </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* x</span>

        <span class="s1">bounds = [[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]]</span>

        <span class="s1">res = shgo(func</span><span class="s0">, </span><span class="s1">bounds=bounds</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">&quot;sobol&quot;</span><span class="s0">,</span>
                   <span class="s1">minimizer_kwargs={</span><span class="s2">'method'</span><span class="s1">: </span><span class="s2">'SLSQP'</span><span class="s0">, </span><span class="s2">'jac'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>
        <span class="s1">ref = minimize(func</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bounds=bounds</span><span class="s0">,</span>
                       <span class="s1">jac=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">ref.fun)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s0">, </span><span class="s1">ref.x</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'derivative'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'jac'</span><span class="s0">, </span><span class="s2">'hess'</span><span class="s0">, </span><span class="s2">'hessp'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_21_2_derivative_options(self</span><span class="s0">, </span><span class="s1">derivative):</span>
        <span class="s4">&quot;&quot;&quot;shgo used to raise an error when passing `options` with 'jac' 
        # see gh-12963. check that this is resolved 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">objective(x):</span>
            <span class="s0">return </span><span class="s3">3 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] * x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">2 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">5</span>

        <span class="s0">def </span><span class="s1">gradient(x):</span>
            <span class="s0">return </span><span class="s3">6 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">2</span>

        <span class="s0">def </span><span class="s1">hess(x):</span>
            <span class="s0">return </span><span class="s3">6</span>

        <span class="s0">def </span><span class="s1">hessp(x</span><span class="s0">, </span><span class="s1">p):</span>
            <span class="s0">return </span><span class="s3">6 </span><span class="s1">* p</span>

        <span class="s1">derivative_funcs = {</span><span class="s2">'jac'</span><span class="s1">: gradient</span><span class="s0">, </span><span class="s2">'hess'</span><span class="s1">: hess</span><span class="s0">, </span><span class="s2">'hessp'</span><span class="s1">: hessp}</span>
        <span class="s1">options = {derivative: derivative_funcs[derivative]}</span>
        <span class="s1">minimizer_kwargs = {</span><span class="s2">'method'</span><span class="s1">: </span><span class="s2">'trust-constr'</span><span class="s1">}</span>

        <span class="s1">bounds = [(-</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)]</span>
        <span class="s1">res = shgo(objective</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">minimizer_kwargs=minimizer_kwargs</span><span class="s0">,</span>
                   <span class="s1">options=options)</span>
        <span class="s1">ref = minimize(objective</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bounds=bounds</span><span class="s0">, </span><span class="s1">**minimizer_kwargs</span><span class="s0">,</span>
                       <span class="s1">**options)</span>

        <span class="s0">assert </span><span class="s1">res.success</span>
        <span class="s1">numpy.testing.assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">ref.fun)</span>
        <span class="s1">numpy.testing.assert_allclose(res.x</span><span class="s0">, </span><span class="s1">ref.x)</span>

    <span class="s0">def </span><span class="s1">test_21_3_hess_options_rosen(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure the Hessian gets passed correctly to the local minimizer 
        routine. Previous report gh-14533. 
        &quot;&quot;&quot;</span>
        <span class="s1">bounds = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1.6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1.6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1.4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1.4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1.4</span><span class="s1">)]</span>
        <span class="s1">options = {</span><span class="s2">'jac'</span><span class="s1">: rosen_der</span><span class="s0">, </span><span class="s2">'hess'</span><span class="s1">: rosen_hess}</span>
        <span class="s1">minimizer_kwargs = {</span><span class="s2">'method'</span><span class="s1">: </span><span class="s2">'Newton-CG'</span><span class="s1">}</span>
        <span class="s1">res = shgo(rosen</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">minimizer_kwargs=minimizer_kwargs</span><span class="s0">,</span>
                   <span class="s1">options=options)</span>
        <span class="s1">ref = minimize(rosen</span><span class="s0">, </span><span class="s1">numpy.zeros(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">'Newton-CG'</span><span class="s0">,</span>
                       <span class="s1">**options)</span>
        <span class="s0">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">ref.fun)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s0">, </span><span class="s1">ref.x</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_21_arg_tuple_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;shgo used to raise an error when passing `args` with Sobol sampling 
        # see gh-12114. check that this is resolved&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">fun(x</span><span class="s0">, </span><span class="s1">k):</span>
            <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] ** k</span>

        <span class="s1">constraints = ({</span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'ineq'</span><span class="s0">, </span><span class="s2">'fun'</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">})</span>

        <span class="s1">bounds = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)]</span>
        <span class="s1">res = shgo(fun</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">args=(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">constraints=constraints</span><span class="s0">,</span>
                   <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
        <span class="s1">ref = minimize(fun</span><span class="s0">, </span><span class="s1">numpy.zeros(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">bounds=bounds</span><span class="s0">, </span><span class="s1">args=(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                       <span class="s1">constraints=constraints)</span>
        <span class="s0">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s0">, </span><span class="s1">ref.fun)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s0">, </span><span class="s1">ref.x)</span>


<span class="s5"># Failure test functions</span>
<span class="s0">class </span><span class="s1">TestShgoFailures:</span>
    <span class="s0">def </span><span class="s1">test_1_maxiter(self):</span>
        <span class="s4">&quot;&quot;&quot;Test failure on insufficient iterations&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'maxiter'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span>
        <span class="s1">res = shgo(test4_1.f</span><span class="s0">, </span><span class="s1">test4_1.bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">iters=</span><span class="s0">None,</span>
                   <span class="s1">options=options</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

        <span class="s1">numpy.testing.assert_equal(</span><span class="s0">False, </span><span class="s1">res.success)</span>
        <span class="s5"># numpy.testing.assert_equal(4, res.nfev)</span>
        <span class="s1">numpy.testing.assert_equal(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">res.tnev)</span>

    <span class="s0">def </span><span class="s1">test_2_sampling(self):</span>
        <span class="s4">&quot;&quot;&quot;Rejection of unknown sampling method&quot;&quot;&quot;</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">shgo</span><span class="s0">, </span><span class="s1">test1_1.f</span><span class="s0">, </span><span class="s1">test1_1.bounds</span><span class="s0">,</span>
                      <span class="s1">sampling_method=</span><span class="s2">'not_Sobol'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_3_1_no_min_pool_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Check that the routine stops when no minimiser is found 
           after maximum specified function evaluations&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'maxfev'</span><span class="s1">: </span><span class="s3">10</span><span class="s0">,</span>
                   <span class="s5"># 'maxev': 10,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">res = shgo(test_table.f</span><span class="s0">, </span><span class="s1">test_table.bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                   <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_equal(</span><span class="s0">False, </span><span class="s1">res.success)</span>
        <span class="s5"># numpy.testing.assert_equal(9, res.nfev)</span>
        <span class="s1">numpy.testing.assert_equal(</span><span class="s3">12</span><span class="s0">, </span><span class="s1">res.nfev)</span>

    <span class="s0">def </span><span class="s1">test_3_2_no_min_pool_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;Check that the routine stops when no minimiser is found 
           after maximum specified sampling evaluations&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'maxev'</span><span class="s1">: </span><span class="s3">10</span><span class="s0">,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>
        <span class="s1">res = shgo(test_table.f</span><span class="s0">, </span><span class="s1">test_table.bounds</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                   <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_equal(</span><span class="s0">False, </span><span class="s1">res.success)</span>

    <span class="s0">def </span><span class="s1">test_4_1_bound_err(self):</span>
        <span class="s4">&quot;&quot;&quot;Specified bounds ub &gt; lb&quot;&quot;&quot;</span>
        <span class="s1">bounds = [(</span><span class="s3">6</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">shgo</span><span class="s0">, </span><span class="s1">test1_1.f</span><span class="s0">, </span><span class="s1">bounds)</span>

    <span class="s0">def </span><span class="s1">test_4_2_bound_err(self):</span>
        <span class="s4">&quot;&quot;&quot;Specified bounds are of the form (lb, ub)&quot;&quot;&quot;</span>
        <span class="s1">bounds = [(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">shgo</span><span class="s0">, </span><span class="s1">test1_1.f</span><span class="s0">, </span><span class="s1">bounds)</span>

    <span class="s0">def </span><span class="s1">test_5_1_1_infeasible_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the algorithm terminates on infeasible problems 
           after maxev is exceeded. Use infty constraints option&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'maxev'</span><span class="s1">: </span><span class="s3">100</span><span class="s0">,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>

        <span class="s1">res = shgo(test_infeasible.f</span><span class="s0">, </span><span class="s1">test_infeasible.bounds</span><span class="s0">,</span>
                   <span class="s1">constraints=test_infeasible.cons</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                   <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

        <span class="s1">numpy.testing.assert_equal(</span><span class="s0">False, </span><span class="s1">res.success)</span>

    <span class="s0">def </span><span class="s1">test_5_1_2_infeasible_sobol(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the algorithm terminates on infeasible problems 
           after maxev is exceeded. Do not use infty constraints option&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'maxev'</span><span class="s1">: </span><span class="s3">100</span><span class="s0">,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">True,</span>
                   <span class="s2">'infty_constraints'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>

        <span class="s1">res = shgo(test_infeasible.f</span><span class="s0">, </span><span class="s1">test_infeasible.bounds</span><span class="s0">,</span>
                   <span class="s1">constraints=test_infeasible.cons</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                   <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>

        <span class="s1">numpy.testing.assert_equal(</span><span class="s0">False, </span><span class="s1">res.success)</span>

    <span class="s0">def </span><span class="s1">test_5_2_infeasible_simplicial(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the algorithm terminates on infeasible problems 
           after maxev is exceeded.&quot;&quot;&quot;</span>
        <span class="s1">options = {</span><span class="s2">'maxev'</span><span class="s1">: </span><span class="s3">1000</span><span class="s0">,</span>
                   <span class="s2">'disp'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>

        <span class="s1">res = shgo(test_infeasible.f</span><span class="s0">, </span><span class="s1">test_infeasible.bounds</span><span class="s0">,</span>
                   <span class="s1">constraints=test_infeasible.cons</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span>
                   <span class="s1">sampling_method=</span><span class="s2">'simplicial'</span><span class="s1">)</span>

        <span class="s1">numpy.testing.assert_equal(</span><span class="s0">False, </span><span class="s1">res.success)</span>

    <span class="s0">def </span><span class="s1">test_6_1_lower_known_f_min(self):</span>
        <span class="s4">&quot;&quot;&quot;Test Global mode limiting local evaluations with f* too high&quot;&quot;&quot;</span>
        <span class="s1">options = {  </span><span class="s5"># Specify known function value</span>
            <span class="s2">'f_min'</span><span class="s1">: test2_1.expected_fun + </span><span class="s3">2.0</span><span class="s0">,</span>
            <span class="s2">'f_tol'</span><span class="s1">: </span><span class="s3">1e-6</span><span class="s0">,</span>
            <span class="s5"># Specify number of local iterations to perform+</span>
            <span class="s2">'minimize_every_iter'</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">'local_iter'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
            <span class="s2">'infty_constraints'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>
        <span class="s1">args = (test2_1.f</span><span class="s0">, </span><span class="s1">test2_1.bounds)</span>
        <span class="s1">kwargs = {</span><span class="s2">'constraints'</span><span class="s1">: test2_1.cons</span><span class="s0">,</span>
                  <span class="s2">'n'</span><span class="s1">: </span><span class="s0">None,</span>
                  <span class="s2">'iters'</span><span class="s1">: </span><span class="s0">None,</span>
                  <span class="s2">'options'</span><span class="s1">: options</span><span class="s0">,</span>
                  <span class="s2">'sampling_method'</span><span class="s1">: </span><span class="s2">'sobol'</span>
                  <span class="s1">}</span>
        <span class="s1">warns(UserWarning</span><span class="s0">, </span><span class="s1">shgo</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test(self):</span>
        <span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">rosen</span><span class="s0">, </span><span class="s1">shgo</span>
        <span class="s1">bounds = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s1">fun.nfev += </span><span class="s3">1</span>
            <span class="s0">return </span><span class="s1">rosen(x)</span>

        <span class="s1">fun.nfev = </span><span class="s3">0</span>

        <span class="s1">result = shgo(fun</span><span class="s0">, </span><span class="s1">bounds)</span>
        <span class="s1">print(result.x</span><span class="s0">, </span><span class="s1">result.fun</span><span class="s0">, </span><span class="s1">fun.nfev)  </span><span class="s5"># 50</span>


<span class="s5"># Returns</span>
<span class="s0">class </span><span class="s1">TestShgoReturns:</span>
    <span class="s0">def </span><span class="s1">test_1_nfev_simplicial(self):</span>
        <span class="s1">bounds = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s1">fun.nfev += </span><span class="s3">1</span>
            <span class="s0">return </span><span class="s1">rosen(x)</span>

        <span class="s1">fun.nfev = </span><span class="s3">0</span>

        <span class="s1">result = shgo(fun</span><span class="s0">, </span><span class="s1">bounds)</span>
        <span class="s1">numpy.testing.assert_equal(fun.nfev</span><span class="s0">, </span><span class="s1">result.nfev)</span>

    <span class="s0">def </span><span class="s1">test_1_nfev_sobol(self):</span>
        <span class="s1">bounds = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">fun(x):</span>
            <span class="s1">fun.nfev += </span><span class="s3">1</span>
            <span class="s0">return </span><span class="s1">rosen(x)</span>

        <span class="s1">fun.nfev = </span><span class="s3">0</span>

        <span class="s1">result = shgo(fun</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
        <span class="s1">numpy.testing.assert_equal(fun.nfev</span><span class="s0">, </span><span class="s1">result.nfev)</span>


<span class="s0">def </span><span class="s1">test_vector_constraint():</span>
    <span class="s5"># gh15514</span>
    <span class="s0">def </span><span class="s1">quad(x):</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s0">return </span><span class="s1">[np.sum(x ** </span><span class="s3">2</span><span class="s1">)]</span>

    <span class="s1">nlc = NonlinearConstraint(quad</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">oldc = new_constraint_to_old(nlc</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]))</span>

    <span class="s1">res = shgo(rosen</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">constraints=oldc</span><span class="s0">, </span><span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.all(np.sum((res.x)**</span><span class="s3">2</span><span class="s1">) &gt;= </span><span class="s3">2.2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.all(np.sum((res.x) ** </span><span class="s3">2</span><span class="s1">) &lt;= </span><span class="s3">3.0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">res.success</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:delta_grad&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_trust_constr():</span>
    <span class="s0">def </span><span class="s1">quad(x):</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s0">return </span><span class="s1">[np.sum(x ** </span><span class="s3">2</span><span class="s1">)]</span>

    <span class="s1">nlc = NonlinearConstraint(quad</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">minimizer_kwargs = {</span><span class="s2">'method'</span><span class="s1">: </span><span class="s2">'trust-constr'</span><span class="s1">}</span>
    <span class="s5"># note that we don't supply the constraints in minimizer_kwargs,</span>
    <span class="s5"># so if the final result obeys the constraints we know that shgo</span>
    <span class="s5"># passed them on to 'trust-constr'</span>
    <span class="s1">res = shgo(</span>
        <span class="s1">rosen</span><span class="s0">,</span>
        <span class="s1">[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">constraints=nlc</span><span class="s0">,</span>
        <span class="s1">sampling_method=</span><span class="s2">'sobol'</span><span class="s0">,</span>
        <span class="s1">minimizer_kwargs=minimizer_kwargs</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.all(np.sum((res.x)**</span><span class="s3">2</span><span class="s1">) &gt;= </span><span class="s3">2.6</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.all(np.sum((res.x) ** </span><span class="s3">2</span><span class="s1">) &lt;= </span><span class="s3">3.0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">res.success</span>


<span class="s0">def </span><span class="s1">test_equality_constraints():</span>
    <span class="s5"># gh16260</span>
    <span class="s1">bounds = [(</span><span class="s3">0.9</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">)] * </span><span class="s3">2  </span><span class="s5"># Constrain probabilities to 0 and 1.</span>

    <span class="s0">def </span><span class="s1">faulty(x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">nlc = NonlinearConstraint(faulty</span><span class="s0">, </span><span class="s3">3.9</span><span class="s0">, </span><span class="s3">3.9</span><span class="s1">)</span>
    <span class="s1">res = shgo(rosen</span><span class="s0">, </span><span class="s1">bounds=bounds</span><span class="s0">, </span><span class="s1">constraints=nlc)</span>
    <span class="s1">assert_allclose(np.sum(res.x)</span><span class="s0">, </span><span class="s3">3.9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">faulty(x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">3.9</span>

    <span class="s1">constraints = {</span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'eq'</span><span class="s0">, </span><span class="s2">'fun'</span><span class="s1">: faulty}</span>
    <span class="s1">res = shgo(rosen</span><span class="s0">, </span><span class="s1">bounds=bounds</span><span class="s0">, </span><span class="s1">constraints=constraints)</span>
    <span class="s1">assert_allclose(np.sum(res.x)</span><span class="s0">, </span><span class="s3">3.9</span><span class="s1">)</span>

    <span class="s1">bounds = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)] * </span><span class="s3">4</span>
    <span class="s5"># sum of variable should equal 1.</span>
    <span class="s0">def </span><span class="s1">faulty(x):</span>
        <span class="s0">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] + x[</span><span class="s3">2</span><span class="s1">] + x[</span><span class="s3">3</span><span class="s1">] - </span><span class="s3">1</span>

    <span class="s5"># options = {'minimize_every_iter': True, 'local_iter':10}</span>
    <span class="s1">constraints = {</span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'eq'</span><span class="s0">, </span><span class="s2">'fun'</span><span class="s1">: faulty}</span>
    <span class="s1">res = shgo(</span>
        <span class="s0">lambda </span><span class="s1">x: - np.prod(x)</span><span class="s0">,</span>
        <span class="s1">bounds=bounds</span><span class="s0">,</span>
        <span class="s1">constraints=constraints</span><span class="s0">,</span>
        <span class="s1">sampling_method=</span><span class="s2">'sobol'</span>
    <span class="s1">)</span>
    <span class="s1">assert_allclose(np.sum(res.x)</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">test_gh16971():</span>
    <span class="s0">def </span><span class="s1">cons(x):</span>
        <span class="s0">return </span><span class="s1">np.sum(x**</span><span class="s3">2</span><span class="s1">) - </span><span class="s3">0</span>

    <span class="s1">c = {</span><span class="s2">'fun'</span><span class="s1">: cons</span><span class="s0">, </span><span class="s2">'type'</span><span class="s1">: </span><span class="s2">'ineq'</span><span class="s1">}</span>
    <span class="s1">minimizer_kwargs = {</span>
        <span class="s2">'method'</span><span class="s1">: </span><span class="s2">'COBYLA'</span><span class="s0">,</span>
        <span class="s2">'options'</span><span class="s1">: {</span><span class="s2">'rhobeg'</span><span class="s1">: </span><span class="s3">5</span><span class="s0">, </span><span class="s2">'tol'</span><span class="s1">: </span><span class="s3">5e-1</span><span class="s0">, </span><span class="s2">'catol'</span><span class="s1">: </span><span class="s3">0.05</span><span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">s = SHGO(</span>
        <span class="s1">rosen</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)]*</span><span class="s3">2</span><span class="s0">, </span><span class="s1">constraints=c</span><span class="s0">, </span><span class="s1">minimizer_kwargs=minimizer_kwargs</span>
    <span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">s.minimizer_kwargs[</span><span class="s2">'method'</span><span class="s1">].lower() == </span><span class="s2">'cobyla'</span>
    <span class="s0">assert </span><span class="s1">s.minimizer_kwargs[</span><span class="s2">'options'</span><span class="s1">][</span><span class="s2">'catol'</span><span class="s1">] == </span><span class="s3">0.05</span>
</pre>
</body>
</html>