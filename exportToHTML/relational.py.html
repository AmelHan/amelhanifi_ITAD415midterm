<html>
<head>
<title>relational.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
relational.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>

<span class="s0">from </span><span class="s1">._base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">VectorPlotter</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">adjust_legend_subtitles</span><span class="s0">,</span>
    <span class="s1">_default_color</span><span class="s0">,</span>
    <span class="s1">_deprecate_ci</span><span class="s0">,</span>
    <span class="s1">_get_transform_functions</span><span class="s0">,</span>
    <span class="s1">_normalize_kwargs</span><span class="s0">,</span>
    <span class="s1">_scatter_legend_artist</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">._statistics </span><span class="s0">import </span><span class="s1">EstimateAggregator</span>
<span class="s0">from </span><span class="s1">.axisgrid </span><span class="s0">import </span><span class="s1">FacetGrid</span><span class="s0">, </span><span class="s1">_facet_docs</span>
<span class="s0">from </span><span class="s1">._docstrings </span><span class="s0">import </span><span class="s1">DocstringComponents</span><span class="s0">, </span><span class="s1">_core_docs</span>


<span class="s1">__all__ = [</span><span class="s2">&quot;relplot&quot;</span><span class="s0">, </span><span class="s2">&quot;scatterplot&quot;</span><span class="s0">, </span><span class="s2">&quot;lineplot&quot;</span><span class="s1">]</span>


<span class="s1">_relational_narrative = DocstringComponents(dict(</span>

    <span class="s3"># ---  Introductory prose</span>
    <span class="s1">main_api=</span><span class="s2">&quot;&quot;&quot; 
The relationship between `x` and `y` can be shown for different subsets 
of the data using the `hue`, `size`, and `style` parameters. These 
parameters control what visual semantics are used to identify the different 
subsets. It is possible to show up to three dimensions independently by 
using all three semantic types, but this style of plot can be hard to 
interpret and is often ineffective. Using redundant semantics (i.e. both 
`hue` and `style` for the same variable) can be helpful for making 
graphics more accessible. 
 
See the :ref:`tutorial &lt;relational_tutorial&gt;` for more information. 
    &quot;&quot;&quot;</span><span class="s0">,</span>

    <span class="s1">relational_semantic=</span><span class="s2">&quot;&quot;&quot; 
The default treatment of the `hue` (and to a lesser extent, `size`) 
semantic, if present, depends on whether the variable is inferred to 
represent &quot;numeric&quot; or &quot;categorical&quot; data. In particular, numeric variables 
are represented with a sequential colormap by default, and the legend 
entries show regular &quot;ticks&quot; with values that may or may not exist in the 
data. This behavior can be controlled through various parameters, as 
described and illustrated below. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
<span class="s1">))</span>

<span class="s1">_relational_docs = dict(</span>

    <span class="s3"># --- Shared function parameters</span>
    <span class="s1">data_vars=</span><span class="s2">&quot;&quot;&quot; 
x, y : names of variables in `data` or vector data 
    Input data variables; must be numeric. Can pass data directly or 
    reference columns in `data`. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">data=</span><span class="s2">&quot;&quot;&quot; 
data : DataFrame, array, or list of arrays 
    Input data structure. If `x` and `y` are specified as names, this 
    should be a &quot;long-form&quot; DataFrame containing those columns. Otherwise 
    it is treated as &quot;wide-form&quot; data and grouping variables are ignored. 
    See the examples for the various ways this parameter can be specified 
    and the different effects of each. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">palette=</span><span class="s2">&quot;&quot;&quot; 
palette : string, list, dict, or matplotlib colormap 
    An object that determines how colors are chosen when `hue` is used. 
    It can be the name of a seaborn palette or matplotlib colormap, a list 
    of colors (anything matplotlib understands), a dict mapping levels 
    of the `hue` variable to colors, or a matplotlib colormap object. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">hue_order=</span><span class="s2">&quot;&quot;&quot; 
hue_order : list 
    Specified order for the appearance of the `hue` variable levels, 
    otherwise they are determined from the data. Not relevant when the 
    `hue` variable is numeric. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">hue_norm=</span><span class="s2">&quot;&quot;&quot; 
hue_norm : tuple or :class:`matplotlib.colors.Normalize` object 
    Normalization in data units for colormap applied to the `hue` 
    variable when it is numeric. Not relevant if `hue` is categorical. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">sizes=</span><span class="s2">&quot;&quot;&quot; 
sizes : list, dict, or tuple 
    An object that determines how sizes are chosen when `size` is used. 
    List or dict arguments should provide a size for each unique data value, 
    which forces a categorical interpretation. The argument may also be a 
    min, max tuple. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">size_order=</span><span class="s2">&quot;&quot;&quot; 
size_order : list 
    Specified order for appearance of the `size` variable levels, 
    otherwise they are determined from the data. Not relevant when the 
    `size` variable is numeric. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">size_norm=</span><span class="s2">&quot;&quot;&quot; 
size_norm : tuple or Normalize object 
    Normalization in data units for scaling plot objects when the 
    `size` variable is numeric. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">dashes=</span><span class="s2">&quot;&quot;&quot; 
dashes : boolean, list, or dictionary 
    Object determining how to draw the lines for different levels of the 
    `style` variable. Setting to `True` will use default dash codes, or 
    you can pass a list of dash codes or a dictionary mapping levels of the 
    `style` variable to dash codes. Setting to `False` will use solid 
    lines for all subsets. Dashes are specified as in matplotlib: a tuple 
    of `(segment, gap)` lengths, or an empty string to draw a solid line. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">markers=</span><span class="s2">&quot;&quot;&quot; 
markers : boolean, list, or dictionary 
    Object determining how to draw the markers for different levels of the 
    `style` variable. Setting to `True` will use default markers, or 
    you can pass a list of markers or a dictionary mapping levels of the 
    `style` variable to markers. Setting to `False` will draw 
    marker-less lines.  Markers are specified as in matplotlib. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">style_order=</span><span class="s2">&quot;&quot;&quot; 
style_order : list 
    Specified order for appearance of the `style` variable levels 
    otherwise they are determined from the data. Not relevant when the 
    `style` variable is numeric. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">units=</span><span class="s2">&quot;&quot;&quot; 
units : vector or key in `data` 
    Grouping variable identifying sampling units. When used, a separate 
    line will be drawn for each unit with appropriate semantics, but no 
    legend entry will be added. Useful for showing distribution of 
    experimental replicates when exact identities are not needed. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">estimator=</span><span class="s2">&quot;&quot;&quot; 
estimator : name of pandas method or callable or None 
    Method for aggregating across multiple observations of the `y` 
    variable at the same `x` level. If `None`, all observations will 
    be drawn. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">ci=</span><span class="s2">&quot;&quot;&quot; 
ci : int or &quot;sd&quot; or None 
    Size of the confidence interval to draw when aggregating. 
 
    .. deprecated:: 0.12.0 
        Use the new `errorbar` parameter for more flexibility. 
 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">n_boot=</span><span class="s2">&quot;&quot;&quot; 
n_boot : int 
    Number of bootstraps to use for computing the confidence interval. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">seed=</span><span class="s2">&quot;&quot;&quot; 
seed : int, numpy.random.Generator, or numpy.random.RandomState 
    Seed or random number generator for reproducible bootstrapping. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">legend=</span><span class="s2">&quot;&quot;&quot; 
legend : &quot;auto&quot;, &quot;brief&quot;, &quot;full&quot;, or False 
    How to draw the legend. If &quot;brief&quot;, numeric `hue` and `size` 
    variables will be represented with a sample of evenly spaced values. 
    If &quot;full&quot;, every group will get an entry in the legend. If &quot;auto&quot;, 
    choose between brief or full representation based on number of levels. 
    If `False`, no legend data is added and no legend is drawn. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">ax_in=</span><span class="s2">&quot;&quot;&quot; 
ax : matplotlib Axes 
    Axes object to draw the plot onto, otherwise uses the current Axes. 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">ax_out=</span><span class="s2">&quot;&quot;&quot; 
ax : matplotlib Axes 
    Returns the Axes object with the plot drawn onto it. 
    &quot;&quot;&quot;</span><span class="s0">,</span>

<span class="s1">)</span>


<span class="s1">_param_docs = DocstringComponents.from_nested_components(</span>
    <span class="s1">core=_core_docs[</span><span class="s2">&quot;params&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">facets=DocstringComponents(_facet_docs)</span><span class="s0">,</span>
    <span class="s1">rel=DocstringComponents(_relational_docs)</span><span class="s0">,</span>
    <span class="s1">stat=DocstringComponents.from_function_params(EstimateAggregator.__init__)</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">class </span><span class="s1">_RelationalPlotter(VectorPlotter):</span>

    <span class="s1">wide_structure = {</span>
        <span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;@index&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;@values&quot;</span><span class="s0">, </span><span class="s2">&quot;hue&quot;</span><span class="s1">: </span><span class="s2">&quot;@columns&quot;</span><span class="s0">, </span><span class="s2">&quot;style&quot;</span><span class="s1">: </span><span class="s2">&quot;@columns&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s3"># TODO where best to define default parameters?</span>
    <span class="s1">sort = </span><span class="s0">True</span>


<span class="s0">class </span><span class="s1">_LinePlotter(_RelationalPlotter):</span>

    <span class="s1">_legend_attributes = [</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s2">&quot;marker&quot;</span><span class="s0">, </span><span class="s2">&quot;dashes&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">,</span>
        <span class="s1">data=</span><span class="s0">None, </span><span class="s1">variables={}</span><span class="s0">,</span>
        <span class="s1">estimator=</span><span class="s0">None, </span><span class="s1">n_boot=</span><span class="s0">None, </span><span class="s1">seed=</span><span class="s0">None, </span><span class="s1">errorbar=</span><span class="s0">None,</span>
        <span class="s1">sort=</span><span class="s0">True, </span><span class="s1">orient=</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">err_style=</span><span class="s0">None, </span><span class="s1">err_kws=</span><span class="s0">None, </span><span class="s1">legend=</span><span class="s0">None</span>
    <span class="s1">):</span>

        <span class="s3"># TODO this is messy, we want the mapping to be agnostic about</span>
        <span class="s3"># the kind of plot to draw, but for the time being we need to set</span>
        <span class="s3"># this information so the SizeMapping can use it</span>
        <span class="s1">self._default_size_range = (</span>
            <span class="s1">np.r_[</span><span class="s4">.5</span><span class="s0">, </span><span class="s4">2</span><span class="s1">] * mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s1">super().__init__(data=data</span><span class="s0">, </span><span class="s1">variables=variables)</span>

        <span class="s1">self.estimator = estimator</span>
        <span class="s1">self.errorbar = errorbar</span>
        <span class="s1">self.n_boot = n_boot</span>
        <span class="s1">self.seed = seed</span>
        <span class="s1">self.sort = sort</span>
        <span class="s1">self.orient = orient</span>
        <span class="s1">self.err_style = err_style</span>
        <span class="s1">self.err_kws = {} </span><span class="s0">if </span><span class="s1">err_kws </span><span class="s0">is None else </span><span class="s1">err_kws</span>

        <span class="s1">self.legend = legend</span>

    <span class="s0">def </span><span class="s1">plot(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">kws):</span>
        <span class="s5">&quot;&quot;&quot;Draw the plot onto an axes, passing matplotlib kwargs.&quot;&quot;&quot;</span>

        <span class="s3"># Draw a test plot, using the passed in kwargs. The goal here is to</span>
        <span class="s3"># honor both (a) the current state of the plot cycler and (b) the</span>
        <span class="s3"># specified kwargs on all the lines we will draw, overriding when</span>
        <span class="s3"># relevant with the data semantics. Note that we won't cycle</span>
        <span class="s3"># internally; in other words, if `hue` is not used, all elements will</span>
        <span class="s3"># have the same color, but they will have the color that you would have</span>
        <span class="s3"># gotten from the corresponding matplotlib function, and calling the</span>
        <span class="s3"># function will advance the axes property cycle.</span>

        <span class="s1">kws = _normalize_kwargs(kws</span><span class="s0">, </span><span class="s1">mpl.lines.Line2D)</span>
        <span class="s1">kws.setdefault(</span><span class="s2">&quot;markeredgewidth&quot;</span><span class="s0">, </span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">kws.setdefault(</span><span class="s2">&quot;markeredgecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;w&quot;</span><span class="s1">)</span>

        <span class="s3"># Set default error kwargs</span>
        <span class="s1">err_kws = self.err_kws.copy()</span>
        <span class="s0">if </span><span class="s1">self.err_style == </span><span class="s2">&quot;band&quot;</span><span class="s1">:</span>
            <span class="s1">err_kws.setdefault(</span><span class="s2">&quot;alpha&quot;</span><span class="s0">, </span><span class="s4">.2</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">self.err_style == </span><span class="s2">&quot;bars&quot;</span><span class="s1">:</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">self.err_style </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">err = </span><span class="s2">&quot;`err_style` must be 'band' or 'bars', not {}&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError(err.format(self.err_style))</span>

        <span class="s3"># Initialize the aggregation object</span>
        <span class="s1">agg = EstimateAggregator(</span>
            <span class="s1">self.estimator</span><span class="s0">, </span><span class="s1">self.errorbar</span><span class="s0">, </span><span class="s1">n_boot=self.n_boot</span><span class="s0">, </span><span class="s1">seed=self.seed</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># TODO abstract variable to aggregate over here-ish. Better name?</span>
        <span class="s1">orient = self.orient</span>
        <span class="s0">if </span><span class="s1">orient </span><span class="s0">not in </span><span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">}:</span>
            <span class="s1">err = </span><span class="s2">f&quot;`orient` must be either 'x' or 'y', not </span><span class="s0">{</span><span class="s1">orient</span><span class="s0">!r}</span><span class="s2">.&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError(err)</span>
        <span class="s1">other = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[orient]</span>

        <span class="s3"># TODO How to handle NA? We don't want NA to propagate through to the</span>
        <span class="s3"># estimate/CI when some values are present, but we would also like</span>
        <span class="s3"># matplotlib to show &quot;gaps&quot; in the line when all values are missing.</span>
        <span class="s3"># This is straightforward absent aggregation, but complicated with it.</span>
        <span class="s3"># If we want to use nas, we need to conditionalize dropna in iter_data.</span>

        <span class="s3"># Loop over the semantic subsets and add to the plot</span>
        <span class="s1">grouping_vars = </span><span class="s2">&quot;hue&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s2">&quot;style&quot;</span>
        <span class="s0">for </span><span class="s1">sub_vars</span><span class="s0">, </span><span class="s1">sub_data </span><span class="s0">in </span><span class="s1">self.iter_data(grouping_vars</span><span class="s0">, </span><span class="s1">from_comp_data=</span><span class="s0">True</span><span class="s1">):</span>

            <span class="s0">if </span><span class="s1">self.sort:</span>
                <span class="s1">sort_vars = [</span><span class="s2">&quot;units&quot;</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">other]</span>
                <span class="s1">sort_cols = [var </span><span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">sort_vars </span><span class="s0">if </span><span class="s1">var </span><span class="s0">in </span><span class="s1">self.variables]</span>
                <span class="s1">sub_data = sub_data.sort_values(sort_cols)</span>

            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">self.estimator </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">sub_data[orient].value_counts().max() &gt; </span><span class="s4">1</span>
            <span class="s1">):</span>
                <span class="s0">if </span><span class="s2">&quot;units&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
                    <span class="s3"># TODO eventually relax this constraint</span>
                    <span class="s1">err = </span><span class="s2">&quot;estimator must be None when specifying units&quot;</span>
                    <span class="s0">raise </span><span class="s1">ValueError(err)</span>
                <span class="s1">grouped = sub_data.groupby(orient</span><span class="s0">, </span><span class="s1">sort=self.sort)</span>
                <span class="s3"># Could pass as_index=False instead of reset_index,</span>
                <span class="s3"># but that fails on a corner case with older pandas.</span>
                <span class="s1">sub_data = grouped.apply(agg</span><span class="s0">, </span><span class="s1">other).reset_index()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">sub_data[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s2">min&quot;</span><span class="s1">] = np.nan</span>
                <span class="s1">sub_data[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s2">max&quot;</span><span class="s1">] = np.nan</span>

            <span class="s3"># Apply inverse axis scaling</span>
            <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s2">&quot;xy&quot;</span><span class="s1">:</span>
                <span class="s1">_</span><span class="s0">, </span><span class="s1">inv = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">var)</span>
                <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">sub_data.filter(regex=</span><span class="s2">f&quot;^</span><span class="s0">{</span><span class="s1">var</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">):</span>
                    <span class="s1">sub_data[col] = inv(sub_data[col])</span>

            <span class="s3"># --- Draw the main line(s)</span>

            <span class="s0">if </span><span class="s2">&quot;units&quot; </span><span class="s0">in </span><span class="s1">self.variables:   </span><span class="s3"># XXX why not add to grouping variables?</span>
                <span class="s1">lines = []</span>
                <span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">unit_data </span><span class="s0">in </span><span class="s1">sub_data.groupby(</span><span class="s2">&quot;units&quot;</span><span class="s1">):</span>
                    <span class="s1">lines.extend(ax.plot(unit_data[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">unit_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**kws))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">lines = ax.plot(sub_data[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sub_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**kws)</span>

            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lines:</span>

                <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">sub_vars:</span>
                    <span class="s1">line.set_color(self._hue_map(sub_vars[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]))</span>

                <span class="s0">if </span><span class="s2">&quot;size&quot; </span><span class="s0">in </span><span class="s1">sub_vars:</span>
                    <span class="s1">line.set_linewidth(self._size_map(sub_vars[</span><span class="s2">&quot;size&quot;</span><span class="s1">]))</span>

                <span class="s0">if </span><span class="s2">&quot;style&quot; </span><span class="s0">in </span><span class="s1">sub_vars:</span>
                    <span class="s1">attributes = self._style_map(sub_vars[</span><span class="s2">&quot;style&quot;</span><span class="s1">])</span>
                    <span class="s0">if </span><span class="s2">&quot;dashes&quot; </span><span class="s0">in </span><span class="s1">attributes:</span>
                        <span class="s1">line.set_dashes(attributes[</span><span class="s2">&quot;dashes&quot;</span><span class="s1">])</span>
                    <span class="s0">if </span><span class="s2">&quot;marker&quot; </span><span class="s0">in </span><span class="s1">attributes:</span>
                        <span class="s1">line.set_marker(attributes[</span><span class="s2">&quot;marker&quot;</span><span class="s1">])</span>

            <span class="s1">line_color = line.get_color()</span>
            <span class="s1">line_alpha = line.get_alpha()</span>
            <span class="s1">line_capstyle = line.get_solid_capstyle()</span>

            <span class="s3"># --- Draw the confidence intervals</span>

            <span class="s0">if </span><span class="s1">self.estimator </span><span class="s0">is not None and </span><span class="s1">self.errorbar </span><span class="s0">is not None</span><span class="s1">:</span>

                <span class="s3"># TODO handling of orientation will need to happen here</span>

                <span class="s0">if </span><span class="s1">self.err_style == </span><span class="s2">&quot;band&quot;</span><span class="s1">:</span>

                    <span class="s1">func = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: ax.fill_between</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: ax.fill_betweenx}[orient]</span>
                    <span class="s1">func(</span>
                        <span class="s1">sub_data[orient]</span><span class="s0">,</span>
                        <span class="s1">sub_data[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s2">min&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sub_data[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s2">max&quot;</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">color=line_color</span><span class="s0">, </span><span class="s1">**err_kws</span>
                    <span class="s1">)</span>

                <span class="s0">elif </span><span class="s1">self.err_style == </span><span class="s2">&quot;bars&quot;</span><span class="s1">:</span>

                    <span class="s1">error_param = {</span>
                        <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s2">err&quot;</span><span class="s1">: (</span>
                            <span class="s1">sub_data[other] - sub_data[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s2">min&quot;</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">sub_data[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s2">max&quot;</span><span class="s1">] - sub_data[other]</span><span class="s0">,</span>
                        <span class="s1">)</span>
                    <span class="s1">}</span>
                    <span class="s1">ebars = ax.errorbar(</span>
                        <span class="s1">sub_data[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sub_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**error_param</span><span class="s0">,</span>
                        <span class="s1">linestyle=</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">color=line_color</span><span class="s0">, </span><span class="s1">alpha=line_alpha</span><span class="s0">,</span>
                        <span class="s1">**err_kws</span>
                    <span class="s1">)</span>

                    <span class="s3"># Set the capstyle properly on the error bars</span>
                    <span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">ebars.get_children():</span>
                        <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">mpl.collections.LineCollection):</span>
                            <span class="s1">obj.set_capstyle(line_capstyle)</span>

        <span class="s3"># Finalize the axes details</span>
        <span class="s1">self._add_axis_labels(ax)</span>
        <span class="s0">if </span><span class="s1">self.legend:</span>
            <span class="s1">legend_artist = partial(mpl.lines.Line2D</span><span class="s0">, </span><span class="s1">xdata=[]</span><span class="s0">, </span><span class="s1">ydata=[])</span>
            <span class="s1">attrs = {</span><span class="s2">&quot;hue&quot;</span><span class="s1">: </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s2">&quot;style&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span>
            <span class="s1">self.add_legend_data(ax</span><span class="s0">, </span><span class="s1">legend_artist</span><span class="s0">, </span><span class="s1">kws</span><span class="s0">, </span><span class="s1">attrs)</span>
            <span class="s1">handles</span><span class="s0">, </span><span class="s1">_ = ax.get_legend_handles_labels()</span>
            <span class="s0">if </span><span class="s1">handles:</span>
                <span class="s1">legend = ax.legend(title=self.legend_title)</span>
                <span class="s1">adjust_legend_subtitles(legend)</span>


<span class="s0">class </span><span class="s1">_ScatterPlotter(_RelationalPlotter):</span>

    <span class="s1">_legend_attributes = [</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s2">&quot;marker&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">data=</span><span class="s0">None, </span><span class="s1">variables={}</span><span class="s0">, </span><span class="s1">legend=</span><span class="s0">None</span><span class="s1">):</span>

        <span class="s3"># TODO this is messy, we want the mapping to be agnostic about</span>
        <span class="s3"># the kind of plot to draw, but for the time being we need to set</span>
        <span class="s3"># this information so the SizeMapping can use it</span>
        <span class="s1">self._default_size_range = (</span>
            <span class="s1">np.r_[</span><span class="s4">.5</span><span class="s0">, </span><span class="s4">2</span><span class="s1">] * np.square(mpl.rcParams[</span><span class="s2">&quot;lines.markersize&quot;</span><span class="s1">])</span>
        <span class="s1">)</span>

        <span class="s1">super().__init__(data=data</span><span class="s0">, </span><span class="s1">variables=variables)</span>

        <span class="s1">self.legend = legend</span>

    <span class="s0">def </span><span class="s1">plot(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">kws):</span>

        <span class="s3"># --- Determine the visual attributes of the plot</span>

        <span class="s1">data = self.comp_data.dropna()</span>
        <span class="s0">if </span><span class="s1">data.empty:</span>
            <span class="s0">return</span>

        <span class="s1">kws = _normalize_kwargs(kws</span><span class="s0">, </span><span class="s1">mpl.collections.PathCollection)</span>

        <span class="s3"># Define the vectors of x and y positions</span>
        <span class="s1">empty = np.full(len(data)</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">x = data.get(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">empty)</span>
        <span class="s1">y = data.get(</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">empty)</span>

        <span class="s3"># Apply inverse scaling to the coordinate variables</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">inv_x = _get_transform_functions(ax</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">inv_y = _get_transform_functions(ax</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = inv_x(x)</span><span class="s0">, </span><span class="s1">inv_y(y)</span>

        <span class="s0">if </span><span class="s2">&quot;style&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
            <span class="s3"># Use a representative marker so scatter sets the edgecolor</span>
            <span class="s3"># properly for line art markers. We currently enforce either</span>
            <span class="s3"># all or none line art so this works.</span>
            <span class="s1">example_level = self._style_map.levels[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">example_marker = self._style_map(example_level</span><span class="s0">, </span><span class="s2">&quot;marker&quot;</span><span class="s1">)</span>
            <span class="s1">kws.setdefault(</span><span class="s2">&quot;marker&quot;</span><span class="s0">, </span><span class="s1">example_marker)</span>

        <span class="s3"># Conditionally set the marker edgecolor based on whether the marker is &quot;filled&quot;</span>
        <span class="s3"># See https://github.com/matplotlib/matplotlib/issues/17849 for context</span>
        <span class="s1">m = kws.get(</span><span class="s2">&quot;marker&quot;</span><span class="s0">, </span><span class="s1">mpl.rcParams.get(</span><span class="s2">&quot;marker&quot;</span><span class="s0">, </span><span class="s2">&quot;o&quot;</span><span class="s1">))</span>
        <span class="s0">if not </span><span class="s1">isinstance(m</span><span class="s0">, </span><span class="s1">mpl.markers.MarkerStyle):</span>
            <span class="s3"># TODO in more recent matplotlib (which?) can pass a MarkerStyle here</span>
            <span class="s1">m = mpl.markers.MarkerStyle(m)</span>
        <span class="s0">if </span><span class="s1">m.is_filled():</span>
            <span class="s1">kws.setdefault(</span><span class="s2">&quot;edgecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;w&quot;</span><span class="s1">)</span>

        <span class="s3"># Draw the scatter plot</span>
        <span class="s1">points = ax.scatter(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">**kws)</span>

        <span class="s3"># Apply the mapping from semantic variables to artist attributes</span>

        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
            <span class="s1">points.set_facecolors(self._hue_map(data[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]))</span>

        <span class="s0">if </span><span class="s2">&quot;size&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
            <span class="s1">points.set_sizes(self._size_map(data[</span><span class="s2">&quot;size&quot;</span><span class="s1">]))</span>

        <span class="s0">if </span><span class="s2">&quot;style&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
            <span class="s1">p = [self._style_map(val</span><span class="s0">, </span><span class="s2">&quot;path&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">data[</span><span class="s2">&quot;style&quot;</span><span class="s1">]]</span>
            <span class="s1">points.set_paths(p)</span>

        <span class="s3"># Apply dependent default attributes</span>

        <span class="s0">if </span><span class="s2">&quot;linewidth&quot; </span><span class="s0">not in </span><span class="s1">kws:</span>
            <span class="s1">sizes = points.get_sizes()</span>
            <span class="s1">linewidth = </span><span class="s4">.08 </span><span class="s1">* np.sqrt(np.percentile(sizes</span><span class="s0">, </span><span class="s4">10</span><span class="s1">))</span>
            <span class="s1">points.set_linewidths(linewidth)</span>
            <span class="s1">kws[</span><span class="s2">&quot;linewidth&quot;</span><span class="s1">] = linewidth</span>

        <span class="s3"># Finalize the axes details</span>
        <span class="s1">self._add_axis_labels(ax)</span>
        <span class="s0">if </span><span class="s1">self.legend:</span>
            <span class="s1">attrs = {</span><span class="s2">&quot;hue&quot;</span><span class="s1">: </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s2">&quot;style&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span>
            <span class="s1">self.add_legend_data(ax</span><span class="s0">, </span><span class="s1">_scatter_legend_artist</span><span class="s0">, </span><span class="s1">kws</span><span class="s0">, </span><span class="s1">attrs)</span>
            <span class="s1">handles</span><span class="s0">, </span><span class="s1">_ = ax.get_legend_handles_labels()</span>
            <span class="s0">if </span><span class="s1">handles:</span>
                <span class="s1">legend = ax.legend(title=self.legend_title)</span>
                <span class="s1">adjust_legend_subtitles(legend)</span>


<span class="s0">def </span><span class="s1">lineplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
    <span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">size=</span><span class="s0">None, </span><span class="s1">style=</span><span class="s0">None, </span><span class="s1">units=</span><span class="s0">None,</span>
    <span class="s1">palette=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">hue_norm=</span><span class="s0">None,</span>
    <span class="s1">sizes=</span><span class="s0">None, </span><span class="s1">size_order=</span><span class="s0">None, </span><span class="s1">size_norm=</span><span class="s0">None,</span>
    <span class="s1">dashes=</span><span class="s0">True, </span><span class="s1">markers=</span><span class="s0">None, </span><span class="s1">style_order=</span><span class="s0">None,</span>
    <span class="s1">estimator=</span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">errorbar=(</span><span class="s2">&quot;ci&quot;</span><span class="s0">, </span><span class="s4">95</span><span class="s1">)</span><span class="s0">, </span><span class="s1">n_boot=</span><span class="s4">1000</span><span class="s0">, </span><span class="s1">seed=</span><span class="s0">None,</span>
    <span class="s1">orient=</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">True, </span><span class="s1">err_style=</span><span class="s2">&quot;band&quot;</span><span class="s0">, </span><span class="s1">err_kws=</span><span class="s0">None,</span>
    <span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">ci=</span><span class="s2">&quot;deprecated&quot;</span><span class="s0">, </span><span class="s1">ax=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s3"># Handle deprecation of ci parameter</span>
    <span class="s1">errorbar = _deprecate_ci(errorbar</span><span class="s0">, </span><span class="s1">ci)</span>

    <span class="s1">p = _LinePlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">size=size</span><span class="s0">, </span><span class="s1">style=style</span><span class="s0">, </span><span class="s1">units=units)</span><span class="s0">,</span>
        <span class="s1">estimator=estimator</span><span class="s0">, </span><span class="s1">n_boot=n_boot</span><span class="s0">, </span><span class="s1">seed=seed</span><span class="s0">, </span><span class="s1">errorbar=errorbar</span><span class="s0">,</span>
        <span class="s1">sort=sort</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">err_style=err_style</span><span class="s0">, </span><span class="s1">err_kws=err_kws</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm)</span>
    <span class="s1">p.map_size(sizes=sizes</span><span class="s0">, </span><span class="s1">order=size_order</span><span class="s0">, </span><span class="s1">norm=size_norm)</span>
    <span class="s1">p.map_style(markers=markers</span><span class="s0">, </span><span class="s1">dashes=dashes</span><span class="s0">, </span><span class="s1">order=style_order)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s2">&quot;style&quot; </span><span class="s0">not in </span><span class="s1">p.variables </span><span class="s0">and not </span><span class="s1">{</span><span class="s2">&quot;ls&quot;</span><span class="s0">, </span><span class="s2">&quot;linestyle&quot;</span><span class="s1">} &amp; set(kwargs):  </span><span class="s3"># XXX</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;dashes&quot;</span><span class="s1">] = </span><span class="s2">&quot;&quot; </span><span class="s0">if </span><span class="s1">dashes </span><span class="s0">is None or </span><span class="s1">isinstance(dashes</span><span class="s0">, </span><span class="s1">bool) </span><span class="s0">else </span><span class="s1">dashes</span>

    <span class="s0">if not </span><span class="s1">p.has_xy_data:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s1">p._attach(ax)</span>

    <span class="s3"># Other functions have color as an explicit param,</span>
    <span class="s3"># and we should probably do that here too</span>
    <span class="s1">color = kwargs.pop(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">kwargs.pop(</span><span class="s2">&quot;c&quot;</span><span class="s0">, None</span><span class="s1">))</span>
    <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = _default_color(ax.plot</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">kwargs)</span>

    <span class="s1">p.plot(ax</span><span class="s0">, </span><span class="s1">kwargs)</span>
    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">lineplot.__doc__ = </span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s2">Draw a line plot with possibility of several semantic groupings. 
 
{narrative.main_api} 
 
{narrative.relational_semantic} 
 
By default, the plot aggregates over multiple `y` values at each value of 
`x` and shows an estimate of the central tendency and a confidence 
interval for that estimate. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
hue : vector or key in `data` 
    Grouping variable that will produce lines with different colors. 
    Can be either categorical or numeric, although color mapping will 
    behave differently in latter case. 
size : vector or key in `data` 
    Grouping variable that will produce lines with different widths. 
    Can be either categorical or numeric, although size mapping will 
    behave differently in latter case. 
style : vector or key in `data` 
    Grouping variable that will produce lines with different dashes 
    and/or markers. Can have a numeric dtype but will always be treated 
    as categorical. 
{params.rel.units} 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
{params.rel.sizes} 
{params.rel.size_order} 
{params.rel.size_norm} 
{params.rel.dashes} 
{params.rel.markers} 
{params.rel.style_order} 
{params.rel.estimator} 
{params.stat.errorbar} 
{params.rel.n_boot} 
{params.rel.seed} 
orient : &quot;x&quot; or &quot;y&quot; 
    Dimension along which the data are sorted / aggregated. Equivalently, 
    the &quot;independent variable&quot; of the resulting function. 
sort : boolean 
    If True, the data will be sorted by the x and y variables, otherwise 
    lines will connect points in the order they appear in the dataset. 
err_style : &quot;band&quot; or &quot;bars&quot; 
    Whether to draw the confidence intervals with translucent error bands 
    or discrete error bars. 
err_kws : dict of keyword arguments 
    Additional parameters to control the aesthetics of the error bars. The 
    kwargs are passed either to :meth:`matplotlib.axes.Axes.fill_between` 
    or :meth:`matplotlib.axes.Axes.errorbar`, depending on `err_style`. 
{params.rel.legend} 
{params.rel.ci} 
{params.core.ax} 
kwargs : key, value mappings 
    Other keyword arguments are passed down to 
    :meth:`matplotlib.axes.Axes.plot`. 
 
Returns 
------- 
{returns.ax} 
 
See Also 
-------- 
{seealso.scatterplot} 
{seealso.pointplot} 
 
Examples 
-------- 
 
.. include:: ../docstrings/lineplot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">narrative=_relational_narrative</span><span class="s0">,</span>
    <span class="s1">params=_param_docs</span><span class="s0">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s2">&quot;returns&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">seealso=_core_docs[</span><span class="s2">&quot;seealso&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">scatterplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
    <span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">size=</span><span class="s0">None, </span><span class="s1">style=</span><span class="s0">None,</span>
    <span class="s1">palette=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">hue_norm=</span><span class="s0">None,</span>
    <span class="s1">sizes=</span><span class="s0">None, </span><span class="s1">size_order=</span><span class="s0">None, </span><span class="s1">size_norm=</span><span class="s0">None,</span>
    <span class="s1">markers=</span><span class="s0">True, </span><span class="s1">style_order=</span><span class="s0">None, </span><span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">ax=</span><span class="s0">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s1">p = _ScatterPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">size=size</span><span class="s0">, </span><span class="s1">style=style)</span><span class="s0">,</span>
        <span class="s1">legend=legend</span>
    <span class="s1">)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm)</span>
    <span class="s1">p.map_size(sizes=sizes</span><span class="s0">, </span><span class="s1">order=size_order</span><span class="s0">, </span><span class="s1">norm=size_norm)</span>
    <span class="s1">p.map_style(markers=markers</span><span class="s0">, </span><span class="s1">order=style_order)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if not </span><span class="s1">p.has_xy_data:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s1">p._attach(ax)</span>

    <span class="s1">color = kwargs.pop(</span><span class="s2">&quot;color&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = _default_color(ax.scatter</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">kwargs)</span>

    <span class="s1">p.plot(ax</span><span class="s0">, </span><span class="s1">kwargs)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">scatterplot.__doc__ = </span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s2">Draw a scatter plot with possibility of several semantic groupings. 
 
{narrative.main_api} 
 
{narrative.relational_semantic} 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
hue : vector or key in `data` 
    Grouping variable that will produce points with different colors. 
    Can be either categorical or numeric, although color mapping will 
    behave differently in latter case. 
size : vector or key in `data` 
    Grouping variable that will produce points with different sizes. 
    Can be either categorical or numeric, although size mapping will 
    behave differently in latter case. 
style : vector or key in `data` 
    Grouping variable that will produce points with different markers. 
    Can have a numeric dtype but will always be treated as categorical. 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
{params.rel.sizes} 
{params.rel.size_order} 
{params.rel.size_norm} 
{params.rel.markers} 
{params.rel.style_order} 
{params.rel.legend} 
{params.core.ax} 
kwargs : key, value mappings 
    Other keyword arguments are passed down to 
    :meth:`matplotlib.axes.Axes.scatter`. 
 
Returns 
------- 
{returns.ax} 
 
See Also 
-------- 
{seealso.lineplot} 
{seealso.stripplot} 
{seealso.swarmplot} 
 
Examples 
-------- 
 
.. include:: ../docstrings/scatterplot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">narrative=_relational_narrative</span><span class="s0">,</span>
    <span class="s1">params=_param_docs</span><span class="s0">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s2">&quot;returns&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">seealso=_core_docs[</span><span class="s2">&quot;seealso&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">relplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
    <span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">size=</span><span class="s0">None, </span><span class="s1">style=</span><span class="s0">None, </span><span class="s1">units=</span><span class="s0">None,</span>
    <span class="s1">row=</span><span class="s0">None, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">col_wrap=</span><span class="s0">None, </span><span class="s1">row_order=</span><span class="s0">None, </span><span class="s1">col_order=</span><span class="s0">None,</span>
    <span class="s1">palette=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">hue_norm=</span><span class="s0">None,</span>
    <span class="s1">sizes=</span><span class="s0">None, </span><span class="s1">size_order=</span><span class="s0">None, </span><span class="s1">size_norm=</span><span class="s0">None,</span>
    <span class="s1">markers=</span><span class="s0">None, </span><span class="s1">dashes=</span><span class="s0">None, </span><span class="s1">style_order=</span><span class="s0">None,</span>
    <span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">kind=</span><span class="s2">&quot;scatter&quot;</span><span class="s0">, </span><span class="s1">height=</span><span class="s4">5</span><span class="s0">, </span><span class="s1">aspect=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">facet_kws=</span><span class="s0">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;scatter&quot;</span><span class="s1">:</span>

        <span class="s1">Plotter = _ScatterPlotter</span>
        <span class="s1">func = scatterplot</span>
        <span class="s1">markers = </span><span class="s0">True if </span><span class="s1">markers </span><span class="s0">is None else </span><span class="s1">markers</span>

    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;line&quot;</span><span class="s1">:</span>

        <span class="s1">Plotter = _LinePlotter</span>
        <span class="s1">func = lineplot</span>
        <span class="s1">dashes = </span><span class="s0">True if </span><span class="s1">dashes </span><span class="s0">is None else </span><span class="s1">dashes</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">err = </span><span class="s2">f&quot;Plot kind </span><span class="s0">{</span><span class="s1">kind</span><span class="s0">} </span><span class="s2">not recognized&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(err)</span>

    <span class="s3"># Check for attempt to plot onto specific axes and warn</span>
    <span class="s0">if </span><span class="s2">&quot;ax&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;relplot is a figure-level function and does not accept &quot;</span>
            <span class="s2">&quot;the `ax` parameter. You may wish to try {}&quot;</span><span class="s1">.format(kind + </span><span class="s2">&quot;plot&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">UserWarning)</span>
        <span class="s1">kwargs.pop(</span><span class="s2">&quot;ax&quot;</span><span class="s1">)</span>

    <span class="s3"># Use the full dataset to map the semantics</span>
    <span class="s1">variables = dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">size=size</span><span class="s0">, </span><span class="s1">style=style)</span>
    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;line&quot;</span><span class="s1">:</span>
        <span class="s1">variables[</span><span class="s2">&quot;units&quot;</span><span class="s1">] = units</span>
    <span class="s0">elif </span><span class="s1">units </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s2">&quot;The `units` parameter of `relplot` has no effect with kind='scatter'&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">p = Plotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=variables</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm)</span>
    <span class="s1">p.map_size(sizes=sizes</span><span class="s0">, </span><span class="s1">order=size_order</span><span class="s0">, </span><span class="s1">norm=size_norm)</span>
    <span class="s1">p.map_style(markers=markers</span><span class="s0">, </span><span class="s1">dashes=dashes</span><span class="s0">, </span><span class="s1">order=style_order)</span>

    <span class="s3"># Extract the semantic mappings</span>
    <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">p.variables:</span>
        <span class="s1">palette = p._hue_map.lookup_table</span>
        <span class="s1">hue_order = p._hue_map.levels</span>
        <span class="s1">hue_norm = p._hue_map.norm</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">palette = hue_order = hue_norm = </span><span class="s0">None</span>

    <span class="s0">if </span><span class="s2">&quot;size&quot; </span><span class="s0">in </span><span class="s1">p.variables:</span>
        <span class="s1">sizes = p._size_map.lookup_table</span>
        <span class="s1">size_order = p._size_map.levels</span>
        <span class="s1">size_norm = p._size_map.norm</span>

    <span class="s0">if </span><span class="s2">&quot;style&quot; </span><span class="s0">in </span><span class="s1">p.variables:</span>
        <span class="s1">style_order = p._style_map.levels</span>
        <span class="s0">if </span><span class="s1">markers:</span>
            <span class="s1">markers = {k: p._style_map(k</span><span class="s0">, </span><span class="s2">&quot;marker&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">style_order}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">markers = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">dashes:</span>
            <span class="s1">dashes = {k: p._style_map(k</span><span class="s0">, </span><span class="s2">&quot;dashes&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">style_order}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dashes = </span><span class="s0">None</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">markers = dashes = style_order = </span><span class="s0">None</span>

    <span class="s3"># Now extract the data that would be used to draw a single plot</span>
    <span class="s1">variables = p.variables</span>
    <span class="s1">plot_data = p.plot_data</span>

    <span class="s3"># Define the common plotting parameters</span>
    <span class="s1">plot_kws = dict(</span>
        <span class="s1">palette=palette</span><span class="s0">, </span><span class="s1">hue_order=hue_order</span><span class="s0">, </span><span class="s1">hue_norm=hue_norm</span><span class="s0">,</span>
        <span class="s1">sizes=sizes</span><span class="s0">, </span><span class="s1">size_order=size_order</span><span class="s0">, </span><span class="s1">size_norm=size_norm</span><span class="s0">,</span>
        <span class="s1">markers=markers</span><span class="s0">, </span><span class="s1">dashes=dashes</span><span class="s0">, </span><span class="s1">style_order=style_order</span><span class="s0">,</span>
        <span class="s1">legend=</span><span class="s0">False,</span>
    <span class="s1">)</span>
    <span class="s1">plot_kws.update(kwargs)</span>
    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;scatter&quot;</span><span class="s1">:</span>
        <span class="s1">plot_kws.pop(</span><span class="s2">&quot;dashes&quot;</span><span class="s1">)</span>

    <span class="s3"># Add the grid semantics onto the plotter</span>
    <span class="s1">grid_variables = dict(</span>
        <span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">row=row</span><span class="s0">, </span><span class="s1">col=col</span><span class="s0">,</span>
        <span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">size=size</span><span class="s0">, </span><span class="s1">style=style</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;line&quot;</span><span class="s1">:</span>
        <span class="s1">grid_variables[</span><span class="s2">&quot;units&quot;</span><span class="s1">] = units</span>
    <span class="s1">p.assign_variables(data</span><span class="s0">, </span><span class="s1">grid_variables)</span>

    <span class="s3"># Define the named variables for plotting on each facet</span>
    <span class="s3"># Rename the variables with a leading underscore to avoid</span>
    <span class="s3"># collisions with faceting variable names</span>
    <span class="s1">plot_variables = {v: </span><span class="s2">f&quot;_</span><span class="s0">{</span><span class="s1">v</span><span class="s0">}</span><span class="s2">&quot; </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">variables}</span>
    <span class="s1">plot_kws.update(plot_variables)</span>

    <span class="s3"># Pass the row/col variables to FacetGrid with their original</span>
    <span class="s3"># names so that the axes titles render correctly</span>
    <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;row&quot;</span><span class="s0">, </span><span class="s2">&quot;col&quot;</span><span class="s1">]:</span>
        <span class="s3"># Handle faceting variables that lack name information</span>
        <span class="s0">if </span><span class="s1">var </span><span class="s0">in </span><span class="s1">p.variables </span><span class="s0">and </span><span class="s1">p.variables[var] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">p.variables[var] = </span><span class="s2">f&quot;_</span><span class="s0">{</span><span class="s1">var</span><span class="s0">}</span><span class="s2">_&quot;</span>
    <span class="s1">grid_kws = {v: p.variables.get(v) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;row&quot;</span><span class="s0">, </span><span class="s2">&quot;col&quot;</span><span class="s1">]}</span>

    <span class="s3"># Rename the columns of the plot_data structure appropriately</span>
    <span class="s1">new_cols = plot_variables.copy()</span>
    <span class="s1">new_cols.update(grid_kws)</span>
    <span class="s1">full_data = p.plot_data.rename(columns=new_cols)</span>

    <span class="s3"># Set up the FacetGrid object</span>
    <span class="s1">facet_kws = {} </span><span class="s0">if </span><span class="s1">facet_kws </span><span class="s0">is None else </span><span class="s1">facet_kws.copy()</span>
    <span class="s1">g = FacetGrid(</span>
        <span class="s1">data=full_data.dropna(axis=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">how=</span><span class="s2">&quot;all&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">**grid_kws</span><span class="s0">,</span>
        <span class="s1">col_wrap=col_wrap</span><span class="s0">, </span><span class="s1">row_order=row_order</span><span class="s0">, </span><span class="s1">col_order=col_order</span><span class="s0">,</span>
        <span class="s1">height=height</span><span class="s0">, </span><span class="s1">aspect=aspect</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False,</span>
        <span class="s1">**facet_kws</span>
    <span class="s1">)</span>

    <span class="s3"># Draw the plot</span>
    <span class="s1">g.map_dataframe(func</span><span class="s0">, </span><span class="s1">**plot_kws)</span>

    <span class="s3"># Label the axes, using the original variables</span>
    <span class="s3"># Pass &quot;&quot; when the variable name is None to overwrite internal variables</span>
    <span class="s1">g.set_axis_labels(variables.get(</span><span class="s2">&quot;x&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">variables.get(</span><span class="s2">&quot;y&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">legend:</span>
        <span class="s3"># Replace the original plot data so the legend uses numeric data with</span>
        <span class="s3"># the correct type, since we force a categorical mapping above.</span>
        <span class="s1">p.plot_data = plot_data</span>

        <span class="s3"># Handle the additional non-semantic keyword arguments out here.</span>
        <span class="s3"># We're selective because some kwargs may be seaborn function specific</span>
        <span class="s3"># and not relevant to the matplotlib artists going into the legend.</span>
        <span class="s3"># Ideally, we will have a better solution where we don't need to re-make</span>
        <span class="s3"># the legend out here and will have parity with the axes-level functions.</span>
        <span class="s1">keys = [</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;alpha&quot;</span><span class="s0">, </span><span class="s2">&quot;m&quot;</span><span class="s0">, </span><span class="s2">&quot;marker&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;scatter&quot;</span><span class="s1">:</span>
            <span class="s1">legend_artist = _scatter_legend_artist</span>
            <span class="s1">keys += [</span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s2">&quot;facecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;fc&quot;</span><span class="s0">, </span><span class="s2">&quot;edgecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;ec&quot;</span><span class="s0">, </span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s2">&quot;lw&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">legend_artist = partial(mpl.lines.Line2D</span><span class="s0">, </span><span class="s1">xdata=[]</span><span class="s0">, </span><span class="s1">ydata=[])</span>
            <span class="s1">keys += [</span>
                <span class="s2">&quot;markersize&quot;</span><span class="s0">, </span><span class="s2">&quot;ms&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;markeredgewidth&quot;</span><span class="s0">, </span><span class="s2">&quot;mew&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;markeredgecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;mec&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;linestyle&quot;</span><span class="s0">, </span><span class="s2">&quot;ls&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s2">&quot;lw&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>

        <span class="s1">common_kws = {k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items() </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">keys}</span>
        <span class="s1">attrs = {</span><span class="s2">&quot;hue&quot;</span><span class="s1">: </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;style&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span>
        <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;scatter&quot;</span><span class="s1">:</span>
            <span class="s1">attrs[</span><span class="s2">&quot;size&quot;</span><span class="s1">] = </span><span class="s2">&quot;s&quot;</span>
        <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;line&quot;</span><span class="s1">:</span>
            <span class="s1">attrs[</span><span class="s2">&quot;size&quot;</span><span class="s1">] = </span><span class="s2">&quot;linewidth&quot;</span>
        <span class="s1">p.add_legend_data(g.axes.flat[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">legend_artist</span><span class="s0">, </span><span class="s1">common_kws</span><span class="s0">, </span><span class="s1">attrs)</span>
        <span class="s0">if </span><span class="s1">p.legend_data:</span>
            <span class="s1">g.add_legend(legend_data=p.legend_data</span><span class="s0">,</span>
                         <span class="s1">label_order=p.legend_order</span><span class="s0">,</span>
                         <span class="s1">title=p.legend_title</span><span class="s0">,</span>
                         <span class="s1">adjust_subtitles=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s3"># Rename the columns of the FacetGrid's `data` attribute</span>
    <span class="s3"># to match the original column names</span>
    <span class="s1">orig_cols = {</span>
        <span class="s2">f&quot;_</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s2">f&quot;_</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">_&quot; </span><span class="s0">if </span><span class="s1">v </span><span class="s0">is None else </span><span class="s1">v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">variables.items()</span>
    <span class="s1">}</span>
    <span class="s1">grid_data = g.data.rename(columns=orig_cols)</span>
    <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">(x </span><span class="s0">is not None or </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">pd.DataFrame):</span>
            <span class="s1">data = pd.DataFrame(data)</span>
        <span class="s1">g.data = pd.merge(</span>
            <span class="s1">data</span><span class="s0">,</span>
            <span class="s1">grid_data[grid_data.columns.difference(data.columns)]</span><span class="s0">,</span>
            <span class="s1">left_index=</span><span class="s0">True,</span>
            <span class="s1">right_index=</span><span class="s0">True,</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">g.data = grid_data</span>

    <span class="s0">return </span><span class="s1">g</span>


<span class="s1">relplot.__doc__ = </span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s2">Figure-level interface for drawing relational plots onto a FacetGrid. 
 
This function provides access to several different axes-level functions 
that show the relationship between two variables with semantic mappings 
of subsets. The `kind` parameter selects the underlying axes-level 
function to use: 
 
- :func:`scatterplot` (with `kind=&quot;scatter&quot;`; the default) 
- :func:`lineplot` (with `kind=&quot;line&quot;`) 
 
Extra keyword arguments are passed to the underlying function, so you 
should refer to the documentation for each to see kind-specific options. 
 
{narrative.main_api} 
 
{narrative.relational_semantic} 
 
After plotting, the :class:`FacetGrid` with the plot is returned and can 
be used directly to tweak supporting plot details or add other layers. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
hue : vector or key in `data` 
    Grouping variable that will produce elements with different colors. 
    Can be either categorical or numeric, although color mapping will 
    behave differently in latter case. 
size : vector or key in `data` 
    Grouping variable that will produce elements with different sizes. 
    Can be either categorical or numeric, although size mapping will 
    behave differently in latter case. 
style : vector or key in `data` 
    Grouping variable that will produce elements with different styles. 
    Can have a numeric dtype but will always be treated as categorical. 
{params.rel.units} 
{params.facets.rowcol} 
{params.facets.col_wrap} 
row_order, col_order : lists of strings 
    Order to organize the rows and/or columns of the grid in, otherwise the 
    orders are inferred from the data objects. 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
{params.rel.sizes} 
{params.rel.size_order} 
{params.rel.size_norm} 
{params.rel.style_order} 
{params.rel.dashes} 
{params.rel.markers} 
{params.rel.legend} 
kind : string 
    Kind of plot to draw, corresponding to a seaborn relational plot. 
    Options are `&quot;scatter&quot;` or `&quot;line&quot;`. 
{params.facets.height} 
{params.facets.aspect} 
facet_kws : dict 
    Dictionary of other keyword arguments to pass to :class:`FacetGrid`. 
kwargs : key, value pairings 
    Other keyword arguments are passed through to the underlying plotting 
    function. 
 
Returns 
------- 
{returns.facetgrid} 
 
Examples 
-------- 
 
.. include:: ../docstrings/relplot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">narrative=_relational_narrative</span><span class="s0">,</span>
    <span class="s1">params=_param_docs</span><span class="s0">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s2">&quot;returns&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
</pre>
</body>
</html>