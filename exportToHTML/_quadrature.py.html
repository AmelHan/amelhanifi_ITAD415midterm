<html>
<head>
<title>_quadrature.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_quadrature.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span><span class="s0">, </span><span class="s1">Callable</span><span class="s0">, </span><span class="s1">Any</span><span class="s0">, </span><span class="s1">cast</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>

<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">roots_legendre</span>
<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">gammaln</span><span class="s0">, </span><span class="s1">logsumexp</span>
<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">_rng_spawn</span>


<span class="s1">__all__ = [</span><span class="s2">'fixed_quad'</span><span class="s0">, </span><span class="s2">'quadrature'</span><span class="s0">, </span><span class="s2">'romberg'</span><span class="s0">, </span><span class="s2">'romb'</span><span class="s0">,</span>
           <span class="s2">'trapezoid'</span><span class="s0">, </span><span class="s2">'trapz'</span><span class="s0">, </span><span class="s2">'simps'</span><span class="s0">, </span><span class="s2">'simpson'</span><span class="s0">,</span>
           <span class="s2">'cumulative_trapezoid'</span><span class="s0">, </span><span class="s2">'cumtrapz'</span><span class="s0">, </span><span class="s2">'newton_cotes'</span><span class="s0">,</span>
           <span class="s2">'qmc_quad'</span><span class="s0">, </span><span class="s2">'AccuracyWarning'</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">trapezoid(y</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">dx=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">):</span>
    <span class="s4">r&quot;&quot;&quot; 
    Integrate along the given axis using the composite trapezoidal rule. 
 
    If `x` is provided, the integration happens in sequence along its 
    elements - they are not sorted. 
 
    Integrate `y` (`x`) along each 1d slice on the given axis, compute 
    :math:`\int y(x) dx`. 
    When `x` is specified, this integrates along the parametric curve, 
    computing :math:`\int_t y(t) dt = 
    \int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`. 
 
    Parameters 
    ---------- 
    y : array_like 
        Input array to integrate. 
    x : array_like, optional 
        The sample points corresponding to the `y` values. If `x` is None, 
        the sample points are assumed to be evenly spaced `dx` apart. The 
        default is None. 
    dx : scalar, optional 
        The spacing between sample points when `x` is None. The default is 1. 
    axis : int, optional 
        The axis along which to integrate. 
 
    Returns 
    ------- 
    trapezoid : float or ndarray 
        Definite integral of `y` = n-dimensional array as approximated along 
        a single axis by the trapezoidal rule. If `y` is a 1-dimensional array, 
        then the result is a float. If `n` is greater than 1, then the result 
        is an `n`-1 dimensional array. 
 
    See Also 
    -------- 
    cumulative_trapezoid, simpson, romb 
 
    Notes 
    ----- 
    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points 
    will be taken from `y` array, by default x-axis distances between 
    points will be 1.0, alternatively they can be provided with `x` array 
    or with `dx` scalar.  Return value will be equal to combined area under 
    the red lines. 
 
    References 
    ---------- 
    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule 
 
    .. [2] Illustration image: 
           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png 
 
    Examples 
    -------- 
    Use the trapezoidal rule on evenly spaced points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; integrate.trapezoid([1, 2, 3]) 
    4.0 
 
    The spacing between sample points can be selected by either the 
    ``x`` or ``dx`` arguments: 
 
    &gt;&gt;&gt; integrate.trapezoid([1, 2, 3], x=[4, 6, 8]) 
    8.0 
    &gt;&gt;&gt; integrate.trapezoid([1, 2, 3], dx=2) 
    8.0 
 
    Using a decreasing ``x`` corresponds to integrating in reverse: 
 
    &gt;&gt;&gt; integrate.trapezoid([1, 2, 3], x=[8, 6, 4]) 
    -8.0 
 
    More generally ``x`` is used to integrate along a parametric curve. We can 
    estimate the integral :math:`\int_0^1 x^2 = 1/3` using: 
 
    &gt;&gt;&gt; x = np.linspace(0, 1, num=50) 
    &gt;&gt;&gt; y = x**2 
    &gt;&gt;&gt; integrate.trapezoid(y, x) 
    0.33340274885464394 
 
    Or estimate the area of a circle, noting we repeat the sample which closes 
    the curve: 
 
    &gt;&gt;&gt; theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True) 
    &gt;&gt;&gt; integrate.trapezoid(np.cos(theta), x=np.sin(theta)) 
    3.141571941375841 
 
    ``trapezoid`` can be applied along a specified axis to do multiple 
    computations in one call: 
 
    &gt;&gt;&gt; a = np.arange(6).reshape(2, 3) 
    &gt;&gt;&gt; a 
    array([[0, 1, 2], 
           [3, 4, 5]]) 
    &gt;&gt;&gt; integrate.trapezoid(a, axis=0) 
    array([1.5, 2.5, 3.5]) 
    &gt;&gt;&gt; integrate.trapezoid(a, axis=1) 
    array([2.,  8.]) 
    &quot;&quot;&quot;</span>
    <span class="s5"># Future-proofing, in case NumPy moves from trapz to trapezoid for the same</span>
    <span class="s5"># reasons as SciPy</span>
    <span class="s0">if </span><span class="s1">hasattr(np</span><span class="s0">, </span><span class="s2">'trapezoid'</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">np.trapezoid(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=dx</span><span class="s0">, </span><span class="s1">axis=axis)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.trapz(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=dx</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s5"># Note: alias kept for backwards compatibility. Rename was done</span>
<span class="s5"># because trapz is a slur in colloquial English (see gh-12924).</span>
<span class="s0">def </span><span class="s1">trapz(y</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">dx=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;An alias of `trapezoid`. 
 
    `trapz` is kept for backwards compatibility. For new code, prefer 
    `trapezoid` instead. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">trapezoid(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=dx</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s0">class </span><span class="s1">AccuracyWarning(Warning):</span>
    <span class="s0">pass</span>


<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s5"># workaround for mypy function attributes see:</span>
    <span class="s5"># https://github.com/python/mypy/issues/2087#issuecomment-462726600</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Protocol</span>

    <span class="s0">class </span><span class="s1">CacheAttributes(Protocol):</span>
        <span class="s1">cache: dict[int</span><span class="s0">, </span><span class="s1">tuple[Any</span><span class="s0">, </span><span class="s1">Any]]</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">CacheAttributes = Callable</span>


<span class="s0">def </span><span class="s1">cache_decorator(func: Callable) -&gt; CacheAttributes:</span>
    <span class="s0">return </span><span class="s1">cast(CacheAttributes</span><span class="s0">, </span><span class="s1">func)</span>


<span class="s1">@cache_decorator</span>
<span class="s0">def </span><span class="s1">_cached_roots_legendre(n):</span>
    <span class="s4">&quot;&quot;&quot; 
    Cache roots_legendre results to speed up calls of the fixed_quad 
    function. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s0">in </span><span class="s1">_cached_roots_legendre.cache:</span>
        <span class="s0">return </span><span class="s1">_cached_roots_legendre.cache[n]</span>

    <span class="s1">_cached_roots_legendre.cache[n] = roots_legendre(n)</span>
    <span class="s0">return </span><span class="s1">_cached_roots_legendre.cache[n]</span>


<span class="s1">_cached_roots_legendre.cache = dict()</span>


<span class="s0">def </span><span class="s1">fixed_quad(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">args=()</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">5</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Compute a definite integral using fixed-order Gaussian quadrature. 
 
    Integrate `func` from `a` to `b` using Gaussian quadrature of 
    order `n`. 
 
    Parameters 
    ---------- 
    func : callable 
        A Python function or method to integrate (must accept vector inputs). 
        If integrating a vector-valued function, the returned array must have 
        shape ``(..., len(x))``. 
    a : float 
        Lower limit of integration. 
    b : float 
        Upper limit of integration. 
    args : tuple, optional 
        Extra arguments to pass to function, if any. 
    n : int, optional 
        Order of quadrature integration. Default is 5. 
 
    Returns 
    ------- 
    val : float 
        Gaussian quadrature approximation to the integral 
    none : None 
        Statically returned value of None 
 
    See Also 
    -------- 
    quad : adaptive quadrature using QUADPACK 
    dblquad : double integrals 
    tplquad : triple integrals 
    romberg : adaptive Romberg quadrature 
    quadrature : adaptive Gaussian quadrature 
    romb : integrators for sampled data 
    simpson : integrators for sampled data 
    cumulative_trapezoid : cumulative integration for sampled data 
    ode : ODE integrator 
    odeint : ODE integrator 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; f = lambda x: x**8 
    &gt;&gt;&gt; integrate.fixed_quad(f, 0.0, 1.0, n=4) 
    (0.1110884353741496, None) 
    &gt;&gt;&gt; integrate.fixed_quad(f, 0.0, 1.0, n=5) 
    (0.11111111111111102, None) 
    &gt;&gt;&gt; print(1/9.0)  # analytical result 
    0.1111111111111111 
 
    &gt;&gt;&gt; integrate.fixed_quad(np.cos, 0.0, np.pi/2, n=4) 
    (0.9999999771971152, None) 
    &gt;&gt;&gt; integrate.fixed_quad(np.cos, 0.0, np.pi/2, n=5) 
    (1.000000000039565, None) 
    &gt;&gt;&gt; np.sin(np.pi/2)-np.sin(0)  # analytical result 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">w = _cached_roots_legendre(n)</span>
    <span class="s1">x = np.real(x)</span>
    <span class="s0">if </span><span class="s1">np.isinf(a) </span><span class="s0">or </span><span class="s1">np.isinf(b):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Gaussian quadrature is only available for &quot;</span>
                         <span class="s2">&quot;finite limits.&quot;</span><span class="s1">)</span>
    <span class="s1">y = (b-a)*(x+</span><span class="s3">1</span><span class="s1">)/</span><span class="s3">2.0 </span><span class="s1">+ a</span>
    <span class="s0">return </span><span class="s1">(b-a)/</span><span class="s3">2.0 </span><span class="s1">* np.sum(w*func(y</span><span class="s0">, </span><span class="s1">*args)</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, None</span>


<span class="s0">def </span><span class="s1">vectorize1(func</span><span class="s0">, </span><span class="s1">args=()</span><span class="s0">, </span><span class="s1">vec_func=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Vectorize the call to a function. 
 
    This is an internal utility function used by `romberg` and 
    `quadrature` to create a vectorized version of a function. 
 
    If `vec_func` is True, the function `func` is assumed to take vector 
    arguments. 
 
    Parameters 
    ---------- 
    func : callable 
        User defined function. 
    args : tuple, optional 
        Extra arguments for the function. 
    vec_func : bool, optional 
        True if the function func takes vector arguments. 
 
    Returns 
    ------- 
    vfunc : callable 
        A function that will take a vector argument and return the 
        result. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">vec_func:</span>
        <span class="s0">def </span><span class="s1">vfunc(x):</span>
            <span class="s0">return </span><span class="s1">func(x</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">def </span><span class="s1">vfunc(x):</span>
            <span class="s0">if </span><span class="s1">np.isscalar(x):</span>
                <span class="s0">return </span><span class="s1">func(x</span><span class="s0">, </span><span class="s1">*args)</span>
            <span class="s1">x = np.asarray(x)</span>
            <span class="s5"># call with first point to get output type</span>
            <span class="s1">y0 = func(x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">*args)</span>
            <span class="s1">n = len(x)</span>
            <span class="s1">dtype = getattr(y0</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s0">, </span><span class="s1">type(y0))</span>
            <span class="s1">output = np.empty((n</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">output[</span><span class="s3">0</span><span class="s1">] = y0</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n):</span>
                <span class="s1">output[i] = func(x[i]</span><span class="s0">, </span><span class="s1">*args)</span>
            <span class="s0">return </span><span class="s1">output</span>
    <span class="s0">return </span><span class="s1">vfunc</span>


<span class="s0">def </span><span class="s1">quadrature(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">args=()</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1.49e-8</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1.49e-8</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s3">50</span><span class="s0">,</span>
               <span class="s1">vec_func=</span><span class="s0">True, </span><span class="s1">miniter=</span><span class="s3">1</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Compute a definite integral using fixed-tolerance Gaussian quadrature. 
 
    Integrate `func` from `a` to `b` using Gaussian quadrature 
    with absolute tolerance `tol`. 
 
    Parameters 
    ---------- 
    func : function 
        A Python function or method to integrate. 
    a : float 
        Lower limit of integration. 
    b : float 
        Upper limit of integration. 
    args : tuple, optional 
        Extra arguments to pass to function. 
    tol, rtol : float, optional 
        Iteration stops when error between last two iterates is less than 
        `tol` OR the relative change is less than `rtol`. 
    maxiter : int, optional 
        Maximum order of Gaussian quadrature. 
    vec_func : bool, optional 
        True or False if func handles arrays as arguments (is 
        a &quot;vector&quot; function). Default is True. 
    miniter : int, optional 
        Minimum order of Gaussian quadrature. 
 
    Returns 
    ------- 
    val : float 
        Gaussian quadrature approximation (within tolerance) to integral. 
    err : float 
        Difference between last two estimates of the integral. 
 
    See Also 
    -------- 
    romberg : adaptive Romberg quadrature 
    fixed_quad : fixed-order Gaussian quadrature 
    quad : adaptive quadrature using QUADPACK 
    dblquad : double integrals 
    tplquad : triple integrals 
    romb : integrator for sampled data 
    simpson : integrator for sampled data 
    cumulative_trapezoid : cumulative integration for sampled data 
    ode : ODE integrator 
    odeint : ODE integrator 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; f = lambda x: x**8 
    &gt;&gt;&gt; integrate.quadrature(f, 0.0, 1.0) 
    (0.11111111111111106, 4.163336342344337e-17) 
    &gt;&gt;&gt; print(1/9.0)  # analytical result 
    0.1111111111111111 
 
    &gt;&gt;&gt; integrate.quadrature(np.cos, 0.0, np.pi/2) 
    (0.9999999999999536, 3.9611425250996035e-11) 
    &gt;&gt;&gt; np.sin(np.pi/2)-np.sin(0)  # analytical result 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance(args</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">args = (args</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">vfunc = vectorize1(func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">vec_func=vec_func)</span>
    <span class="s1">val = np.inf</span>
    <span class="s1">err = np.inf</span>
    <span class="s1">maxiter = max(miniter+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">maxiter)</span>
    <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(miniter</span><span class="s0">, </span><span class="s1">maxiter+</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">newval = fixed_quad(vfunc</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">n)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">err = abs(newval-val)</span>
        <span class="s1">val = newval</span>

        <span class="s0">if </span><span class="s1">err &lt; tol </span><span class="s0">or </span><span class="s1">err &lt; rtol*abs(val):</span>
            <span class="s0">break</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;maxiter (%d) exceeded. Latest difference = %e&quot; </span><span class="s1">% (maxiter</span><span class="s0">, </span><span class="s1">err)</span><span class="s0">,</span>
            <span class="s1">AccuracyWarning)</span>
    <span class="s0">return </span><span class="s1">val</span><span class="s0">, </span><span class="s1">err</span>


<span class="s0">def </span><span class="s1">tupleset(t</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">value):</span>
    <span class="s1">l = list(t)</span>
    <span class="s1">l[i] = value</span>
    <span class="s0">return </span><span class="s1">tuple(l)</span>


<span class="s5"># Note: alias kept for backwards compatibility. Rename was done</span>
<span class="s5"># because cumtrapz is a slur in colloquial English (see gh-12924).</span>
<span class="s0">def </span><span class="s1">cumtrapz(y</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">dx=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;An alias of `cumulative_trapezoid`. 
 
    `cumtrapz` is kept for backwards compatibility. For new code, prefer 
    `cumulative_trapezoid` instead. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=dx</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">initial=initial)</span>


<span class="s0">def </span><span class="s1">cumulative_trapezoid(y</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">dx=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Cumulatively integrate y(x) using the composite trapezoidal rule. 
 
    Parameters 
    ---------- 
    y : array_like 
        Values to integrate. 
    x : array_like, optional 
        The coordinate to integrate along. If None (default), use spacing `dx` 
        between consecutive elements in `y`. 
    dx : float, optional 
        Spacing between elements of `y`. Only used if `x` is None. 
    axis : int, optional 
        Specifies the axis to cumulate. Default is -1 (last axis). 
    initial : scalar, optional 
        If given, insert this value at the beginning of the returned result. 
        Typically this value should be 0. Default is None, which means no 
        value at ``x[0]`` is returned and `res` has one element less than `y` 
        along the axis of integration. 
 
    Returns 
    ------- 
    res : ndarray 
        The result of cumulative integration of `y` along `axis`. 
        If `initial` is None, the shape is such that the axis of integration 
        has one less value than `y`. If `initial` is given, the shape is equal 
        to that of `y`. 
 
    See Also 
    -------- 
    numpy.cumsum, numpy.cumprod 
    quad : adaptive quadrature using QUADPACK 
    romberg : adaptive Romberg quadrature 
    quadrature : adaptive Gaussian quadrature 
    fixed_quad : fixed-order Gaussian quadrature 
    dblquad : double integrals 
    tplquad : triple integrals 
    romb : integrators for sampled data 
    ode : ODE integrators 
    odeint : ODE integrators 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; x = np.linspace(-2, 2, num=20) 
    &gt;&gt;&gt; y = x 
    &gt;&gt;&gt; y_int = integrate.cumulative_trapezoid(y, x, initial=0) 
    &gt;&gt;&gt; plt.plot(x, y_int, 'ro', x, y[0] + 0.5 * x**2, 'b-') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y = np.asarray(y)</span>
    <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">d = dx</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">d = np.diff(x)</span>
            <span class="s5"># reshape to correct shape</span>
            <span class="s1">shape = [</span><span class="s3">1</span><span class="s1">] * y.ndim</span>
            <span class="s1">shape[axis] = -</span><span class="s3">1</span>
            <span class="s1">d = d.reshape(shape)</span>
        <span class="s0">elif </span><span class="s1">len(x.shape) != len(y.shape):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;If given, shape of x must be 1-D or the &quot;</span>
                             <span class="s2">&quot;same as y.&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">d = np.diff(x</span><span class="s0">, </span><span class="s1">axis=axis)</span>

        <span class="s0">if </span><span class="s1">d.shape[axis] != y.shape[axis] - </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;If given, length of x along axis must be the &quot;</span>
                             <span class="s2">&quot;same as y.&quot;</span><span class="s1">)</span>

    <span class="s1">nd = len(y.shape)</span>
    <span class="s1">slice1 = tupleset((slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)*nd</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(</span><span class="s3">1</span><span class="s0">, None</span><span class="s1">))</span>
    <span class="s1">slice2 = tupleset((slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)*nd</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">res = np.cumsum(d * (y[slice1] + y[slice2]) / </span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">if </span><span class="s1">initial </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">np.isscalar(initial):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`initial` parameter should be a scalar.&quot;</span><span class="s1">)</span>

        <span class="s1">shape = list(res.shape)</span>
        <span class="s1">shape[axis] = </span><span class="s3">1</span>
        <span class="s1">res = np.concatenate([np.full(shape</span><span class="s0">, </span><span class="s1">initial</span><span class="s0">, </span><span class="s1">dtype=res.dtype)</span><span class="s0">, </span><span class="s1">res]</span><span class="s0">,</span>
                             <span class="s1">axis=axis)</span>

    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_basic_simpson(y</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s1">nd = len(y.shape)</span>
    <span class="s0">if </span><span class="s1">start </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">start = </span><span class="s3">0</span>
    <span class="s1">step = </span><span class="s3">2</span>
    <span class="s1">slice_all = (slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)*nd</span>
    <span class="s1">slice0 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step))</span>
    <span class="s1">slice1 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(start+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">stop+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">step))</span>
    <span class="s1">slice2 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(start+</span><span class="s3">2</span><span class="s0">, </span><span class="s1">stop+</span><span class="s3">2</span><span class="s0">, </span><span class="s1">step))</span>

    <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s1">:  </span><span class="s5"># Even-spaced Simpson's rule.</span>
        <span class="s1">result = np.sum(y[slice0] + </span><span class="s3">4.0</span><span class="s1">*y[slice1] + y[slice2]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">result *= dx / </span><span class="s3">3.0</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># Account for possibly different spacings.</span>
        <span class="s5">#    Simpson's rule changes a bit.</span>
        <span class="s1">h = np.diff(x</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">sl0 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step))</span>
        <span class="s1">sl1 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(start+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">stop+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">step))</span>
        <span class="s1">h0 = h[sl0].astype(float</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">h1 = h[sl1].astype(float</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">hsum = h0 + h1</span>
        <span class="s1">hprod = h0 * h1</span>
        <span class="s1">h0divh1 = np.true_divide(h0</span><span class="s0">, </span><span class="s1">h1</span><span class="s0">, </span><span class="s1">out=np.zeros_like(h0)</span><span class="s0">, </span><span class="s1">where=h1 != </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">tmp = hsum/</span><span class="s3">6.0 </span><span class="s1">* (y[slice0] *</span>
                          <span class="s1">(</span><span class="s3">2.0 </span><span class="s1">- np.true_divide(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">h0divh1</span><span class="s0">,</span>
                                                <span class="s1">out=np.zeros_like(h0divh1)</span><span class="s0">,</span>
                                                <span class="s1">where=h0divh1 != </span><span class="s3">0</span><span class="s1">)) +</span>
                          <span class="s1">y[slice1] * (hsum *</span>
                                       <span class="s1">np.true_divide(hsum</span><span class="s0">, </span><span class="s1">hprod</span><span class="s0">,</span>
                                                      <span class="s1">out=np.zeros_like(hsum)</span><span class="s0">,</span>
                                                      <span class="s1">where=hprod != </span><span class="s3">0</span><span class="s1">)) +</span>
                          <span class="s1">y[slice2] * (</span><span class="s3">2.0 </span><span class="s1">- h0divh1))</span>
        <span class="s1">result = np.sum(tmp</span><span class="s0">, </span><span class="s1">axis=axis)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s5"># Note: alias kept for backwards compatibility. simps was renamed to simpson</span>
<span class="s5"># because the former is a slur in colloquial English (see gh-12924).</span>
<span class="s0">def </span><span class="s1">simps(y</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">dx=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">even=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;An alias of `simpson`. 
 
    `simps` is kept for backwards compatibility. For new code, prefer 
    `simpson` instead. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">simpson(y</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">dx=dx</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">even=even)</span>


<span class="s0">def </span><span class="s1">simpson(y</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">dx=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">even=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Integrate y(x) using samples along the given axis and the composite 
    Simpson's rule. If x is None, spacing of dx is assumed. 
 
    If there are an even number of samples, N, then there are an odd 
    number of intervals (N-1), but Simpson's rule requires an even number 
    of intervals. The parameter 'even' controls how this is handled. 
 
    Parameters 
    ---------- 
    y : array_like 
        Array to be integrated. 
    x : array_like, optional 
        If given, the points at which `y` is sampled. 
    dx : float, optional 
        Spacing of integration points along axis of `x`. Only used when 
        `x` is None. Default is 1. 
    axis : int, optional 
        Axis along which to integrate. Default is the last axis. 
    even : {None, 'simpson', 'avg', 'first', 'last'}, optional 
        'avg' : Average two results: 
            1) use the first N-2 intervals with 
               a trapezoidal rule on the last interval and 
            2) use the last 
               N-2 intervals with a trapezoidal rule on the first interval. 
 
        'first' : Use Simpson's rule for the first N-2 intervals with 
                a trapezoidal rule on the last interval. 
 
        'last' : Use Simpson's rule for the last N-2 intervals with a 
               trapezoidal rule on the first interval. 
 
        None : equivalent to 'simpson' (default) 
 
        'simpson' : Use Simpson's rule for the first N-2 intervals with the 
                  addition of a 3-point parabolic segment for the last 
                  interval using equations outlined by Cartwright [1]_. 
                  If the axis to be integrated over only has two points then 
                  the integration falls back to a trapezoidal integration. 
 
                  .. versionadded:: 1.11.0 
 
        .. versionchanged:: 1.11.0 
            The newly added 'simpson' option is now the default as it is more 
            accurate in most situations. 
 
        .. deprecated:: 1.11.0 
            Parameter `even` is deprecated and will be removed in SciPy 
            1.13.0. After this time the behaviour for an even number of 
            points will follow that of `even='simpson'`. 
 
    Returns 
    ------- 
    float 
        The estimated integral computed with the composite Simpson's rule. 
 
    See Also 
    -------- 
    quad : adaptive quadrature using QUADPACK 
    romberg : adaptive Romberg quadrature 
    quadrature : adaptive Gaussian quadrature 
    fixed_quad : fixed-order Gaussian quadrature 
    dblquad : double integrals 
    tplquad : triple integrals 
    romb : integrators for sampled data 
    cumulative_trapezoid : cumulative integration for sampled data 
    ode : ODE integrators 
    odeint : ODE integrators 
 
    Notes 
    ----- 
    For an odd number of samples that are equally spaced the result is 
    exact if the function is a polynomial of order 3 or less. If 
    the samples are not equally spaced, then the result is exact only 
    if the function is a polynomial of order 2 or less. 
 
    References 
    ---------- 
    .. [1] Cartwright, Kenneth V. Simpson's Rule Cumulative Integration with 
           MS Excel and Irregularly-spaced Data. Journal of Mathematical 
           Sciences and Mathematics Education. 12 (2): 1-9 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(0, 10) 
    &gt;&gt;&gt; y = np.arange(0, 10) 
 
    &gt;&gt;&gt; integrate.simpson(y, x) 
    40.5 
 
    &gt;&gt;&gt; y = np.power(x, 3) 
    &gt;&gt;&gt; integrate.simpson(y, x) 
    1640.5 
    &gt;&gt;&gt; integrate.quad(lambda x: x**3, 0, 9)[0] 
    1640.25 
 
    &gt;&gt;&gt; integrate.simpson(y, x, even='first') 
    1644.5 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y = np.asarray(y)</span>
    <span class="s1">nd = len(y.shape)</span>
    <span class="s1">N = y.shape[axis]</span>
    <span class="s1">last_dx = dx</span>
    <span class="s1">first_dx = dx</span>
    <span class="s1">returnshape = </span><span class="s3">0</span>
    <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s0">if </span><span class="s1">len(x.shape) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">shapex = [</span><span class="s3">1</span><span class="s1">] * nd</span>
            <span class="s1">shapex[axis] = x.shape[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">saveshape = x.shape</span>
            <span class="s1">returnshape = </span><span class="s3">1</span>
            <span class="s1">x = x.reshape(tuple(shapex))</span>
        <span class="s0">elif </span><span class="s1">len(x.shape) != len(y.shape):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;If given, shape of x must be 1-D or the &quot;</span>
                             <span class="s2">&quot;same as y.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">x.shape[axis] != N:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;If given, length of x along axis must be the &quot;</span>
                             <span class="s2">&quot;same as y.&quot;</span><span class="s1">)</span>

    <span class="s5"># even keyword parameter is deprecated</span>
    <span class="s0">if </span><span class="s1">even </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The 'even' keyword is deprecated as of SciPy 1.11.0 and will be &quot;</span>
            <span class="s2">&quot;removed in SciPy 1.13.0&quot;</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s3">2</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">N % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">val = </span><span class="s3">0.0</span>
        <span class="s1">result = </span><span class="s3">0.0</span>
        <span class="s1">slice_all = (slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * nd</span>

        <span class="s5"># default is 'simpson'</span>
        <span class="s1">even = even </span><span class="s0">if </span><span class="s1">even </span><span class="s0">is not None else </span><span class="s2">&quot;simpson&quot;</span>

        <span class="s0">if </span><span class="s1">even </span><span class="s0">not in </span><span class="s1">[</span><span class="s2">'avg'</span><span class="s0">, </span><span class="s2">'last'</span><span class="s0">, </span><span class="s2">'first'</span><span class="s0">, </span><span class="s2">'simpson'</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Parameter 'even' must be 'simpson', &quot;</span>
                <span class="s2">&quot;'avg', 'last', or 'first'.&quot;</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">N == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s5"># need at least 3 points in integration axis to form parabolic</span>
            <span class="s5"># segment. If there are two points then any of 'avg', 'first',</span>
            <span class="s5"># 'last' should give the same result.</span>
            <span class="s1">slice1 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">slice2 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">last_dx = x[slice1] - x[slice2]</span>
            <span class="s1">val += </span><span class="s3">0.5 </span><span class="s1">* last_dx * (y[slice1] + y[slice2])</span>

            <span class="s5"># calculation is finished. Set `even` to None to skip other</span>
            <span class="s5"># scenarios</span>
            <span class="s1">even = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">even == </span><span class="s2">'simpson'</span><span class="s1">:</span>
            <span class="s5"># use Simpson's rule on first intervals</span>
            <span class="s1">result = _basic_simpson(y</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">N-</span><span class="s3">3</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">axis)</span>

            <span class="s1">slice1 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">slice2 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">slice3 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3</span><span class="s1">)</span>

            <span class="s1">h = np.asfarray([dx</span><span class="s0">, </span><span class="s1">dx])</span>
            <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s5"># grab the last two spacings from the appropriate axis</span>
                <span class="s1">hm2 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
                <span class="s1">hm1 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(-</span><span class="s3">1</span><span class="s0">, None, </span><span class="s3">1</span><span class="s1">))</span>

                <span class="s1">diffs = np.float64(np.diff(x</span><span class="s0">, </span><span class="s1">axis=axis))</span>
                <span class="s1">h = [np.squeeze(diffs[hm2]</span><span class="s0">, </span><span class="s1">axis=axis)</span><span class="s0">,</span>
                     <span class="s1">np.squeeze(diffs[hm1]</span><span class="s0">, </span><span class="s1">axis=axis)]</span>

            <span class="s5"># This is the correction for the last interval according to</span>
            <span class="s5"># Cartwright.</span>
            <span class="s5"># However, I used the equations given at</span>
            <span class="s5"># https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule_for_irregularly_spaced_data</span>
            <span class="s5"># A footnote on Wikipedia says:</span>
            <span class="s5"># Cartwright 2017, Equation 8. The equation in Cartwright is</span>
            <span class="s5"># calculating the first interval whereas the equations in the</span>
            <span class="s5"># Wikipedia article are adjusting for the last integral. If the</span>
            <span class="s5"># proper algebraic substitutions are made, the equation results in</span>
            <span class="s5"># the values shown.</span>
            <span class="s1">num = </span><span class="s3">2 </span><span class="s1">* h[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">3 </span><span class="s1">* h[</span><span class="s3">0</span><span class="s1">] * h[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">den = </span><span class="s3">6 </span><span class="s1">* (h[</span><span class="s3">1</span><span class="s1">] + h[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">alpha = np.true_divide(</span>
                <span class="s1">num</span><span class="s0">,</span>
                <span class="s1">den</span><span class="s0">,</span>
                <span class="s1">out=np.zeros_like(den)</span><span class="s0">,</span>
                <span class="s1">where=den != </span><span class="s3">0</span>
            <span class="s1">)</span>

            <span class="s1">num = h[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">3.0 </span><span class="s1">* h[</span><span class="s3">0</span><span class="s1">] * h[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">den = </span><span class="s3">6 </span><span class="s1">* h[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">beta = np.true_divide(</span>
                <span class="s1">num</span><span class="s0">,</span>
                <span class="s1">den</span><span class="s0">,</span>
                <span class="s1">out=np.zeros_like(den)</span><span class="s0">,</span>
                <span class="s1">where=den != </span><span class="s3">0</span>
            <span class="s1">)</span>

            <span class="s1">num = </span><span class="s3">1 </span><span class="s1">* h[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">3</span>
            <span class="s1">den = </span><span class="s3">6 </span><span class="s1">* h[</span><span class="s3">0</span><span class="s1">] * (h[</span><span class="s3">0</span><span class="s1">] + h[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">eta = np.true_divide(</span>
                <span class="s1">num</span><span class="s0">,</span>
                <span class="s1">den</span><span class="s0">,</span>
                <span class="s1">out=np.zeros_like(den)</span><span class="s0">,</span>
                <span class="s1">where=den != </span><span class="s3">0</span>
            <span class="s1">)</span>

            <span class="s1">result += alpha*y[slice1] + beta*y[slice2] - eta*y[slice3]</span>

        <span class="s5"># The following code (down to result=result+val) can be removed</span>
        <span class="s5"># once the 'even' keyword is removed.</span>

        <span class="s5"># Compute using Simpson's rule on first intervals</span>
        <span class="s0">if </span><span class="s1">even </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'avg'</span><span class="s0">, </span><span class="s2">'first'</span><span class="s1">]:</span>
            <span class="s1">slice1 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">slice2 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">last_dx = x[slice1] - x[slice2]</span>
            <span class="s1">val += </span><span class="s3">0.5</span><span class="s1">*last_dx*(y[slice1]+y[slice2])</span>
            <span class="s1">result = _basic_simpson(y</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">N-</span><span class="s3">3</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">axis)</span>
        <span class="s5"># Compute using Simpson's rule on last set of intervals</span>
        <span class="s0">if </span><span class="s1">even </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'avg'</span><span class="s0">, </span><span class="s2">'last'</span><span class="s1">]:</span>
            <span class="s1">slice1 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">slice2 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">first_dx = x[tuple(slice2)] - x[tuple(slice1)]</span>
            <span class="s1">val += </span><span class="s3">0.5</span><span class="s1">*first_dx*(y[slice2]+y[slice1])</span>
            <span class="s1">result += _basic_simpson(y</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">N-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">axis)</span>
        <span class="s0">if </span><span class="s1">even == </span><span class="s2">'avg'</span><span class="s1">:</span>
            <span class="s1">val /= </span><span class="s3">2.0</span>
            <span class="s1">result /= </span><span class="s3">2.0</span>
        <span class="s1">result = result + val</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = _basic_simpson(y</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">N-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s0">if </span><span class="s1">returnshape:</span>
        <span class="s1">x = x.reshape(saveshape)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">romb(y</span><span class="s0">, </span><span class="s1">dx=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">show=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Romberg integration using samples of a function. 
 
    Parameters 
    ---------- 
    y : array_like 
        A vector of ``2**k + 1`` equally-spaced samples of a function. 
    dx : float, optional 
        The sample spacing. Default is 1. 
    axis : int, optional 
        The axis along which to integrate. Default is -1 (last axis). 
    show : bool, optional 
        When `y` is a single 1-D array, then if this argument is True 
        print the table showing Richardson extrapolation from the 
        samples. Default is False. 
 
    Returns 
    ------- 
    romb : ndarray 
        The integrated result for `axis`. 
 
    See Also 
    -------- 
    quad : adaptive quadrature using QUADPACK 
    romberg : adaptive Romberg quadrature 
    quadrature : adaptive Gaussian quadrature 
    fixed_quad : fixed-order Gaussian quadrature 
    dblquad : double integrals 
    tplquad : triple integrals 
    simpson : integrators for sampled data 
    cumulative_trapezoid : cumulative integration for sampled data 
    ode : ODE integrators 
    odeint : ODE integrators 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(10, 14.25, 0.25) 
    &gt;&gt;&gt; y = np.arange(3, 12) 
 
    &gt;&gt;&gt; integrate.romb(y) 
    56.0 
 
    &gt;&gt;&gt; y = np.sin(np.power(x, 2.5)) 
    &gt;&gt;&gt; integrate.romb(y) 
    -0.742561336672229 
 
    &gt;&gt;&gt; integrate.romb(y, show=True) 
    Richardson Extrapolation Table for Romberg Integration 
    ====================================================== 
    -0.81576 
     4.63862  6.45674 
    -1.10581 -3.02062 -3.65245 
    -2.57379 -3.06311 -3.06595 -3.05664 
    -1.34093 -0.92997 -0.78776 -0.75160 -0.74256 
    ====================================================== 
    -0.742561336672229  # may vary 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y = np.asarray(y)</span>
    <span class="s1">nd = len(y.shape)</span>
    <span class="s1">Nsamps = y.shape[axis]</span>
    <span class="s1">Ninterv = Nsamps-</span><span class="s3">1</span>
    <span class="s1">n = </span><span class="s3">1</span>
    <span class="s1">k = </span><span class="s3">0</span>
    <span class="s0">while </span><span class="s1">n &lt; Ninterv:</span>
        <span class="s1">n &lt;&lt;= </span><span class="s3">1</span>
        <span class="s1">k += </span><span class="s3">1</span>
    <span class="s0">if </span><span class="s1">n != Ninterv:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Number of samples must be one plus a &quot;</span>
                         <span class="s2">&quot;non-negative power of 2.&quot;</span><span class="s1">)</span>

    <span class="s1">R = {}</span>
    <span class="s1">slice_all = (slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * nd</span>
    <span class="s1">slice0 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">slicem1 = tupleset(slice_all</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">h = Ninterv * np.asarray(dx</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">R[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)] = (y[slice0] + y[slicem1])/</span><span class="s3">2.0</span><span class="s1">*h</span>
    <span class="s1">slice_R = slice_all</span>
    <span class="s1">start = stop = step = Ninterv</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k+</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">start &gt;&gt;= </span><span class="s3">1</span>
        <span class="s1">slice_R = tupleset(slice_R</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slice(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step))</span>
        <span class="s1">step &gt;&gt;= </span><span class="s3">1</span>
        <span class="s1">R[(i</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)] = </span><span class="s3">0.5</span><span class="s1">*(R[(i-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)] + h*y[slice_R].sum(axis=axis))</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">i+</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">prev = R[(i</span><span class="s0">, </span><span class="s1">j-</span><span class="s3">1</span><span class="s1">)]</span>
            <span class="s1">R[(i</span><span class="s0">, </span><span class="s1">j)] = prev + (prev-R[(i-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">j-</span><span class="s3">1</span><span class="s1">)]) / ((</span><span class="s3">1 </span><span class="s1">&lt;&lt; (</span><span class="s3">2</span><span class="s1">*j))-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">h /= </span><span class="s3">2.0</span>

    <span class="s0">if </span><span class="s1">show:</span>
        <span class="s0">if not </span><span class="s1">np.isscalar(R[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]):</span>
            <span class="s1">print(</span><span class="s2">&quot;*** Printing table only supported for integrals&quot; </span><span class="s1">+</span>
                  <span class="s2">&quot; of a single data set.&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">precis = show[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">IndexError):</span>
                <span class="s1">precis = </span><span class="s3">5</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">width = show[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">IndexError):</span>
                <span class="s1">width = </span><span class="s3">8</span>
            <span class="s1">formstr = </span><span class="s2">&quot;%%%d.%df&quot; </span><span class="s1">% (width</span><span class="s0">, </span><span class="s1">precis)</span>

            <span class="s1">title = </span><span class="s2">&quot;Richardson Extrapolation Table for Romberg Integration&quot;</span>
            <span class="s1">print(title</span><span class="s0">, </span><span class="s2">&quot;=&quot; </span><span class="s1">* len(title)</span><span class="s0">, </span><span class="s1">sep=</span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">end=</span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(k+</span><span class="s3">1</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(i+</span><span class="s3">1</span><span class="s1">):</span>
                    <span class="s1">print(formstr % R[(i</span><span class="s0">, </span><span class="s1">j)]</span><span class="s0">, </span><span class="s1">end=</span><span class="s2">&quot; &quot;</span><span class="s1">)</span>
                <span class="s1">print()</span>
            <span class="s1">print(</span><span class="s2">&quot;=&quot; </span><span class="s1">* len(title))</span>

    <span class="s0">return </span><span class="s1">R[(k</span><span class="s0">, </span><span class="s1">k)]</span>

<span class="s5"># Romberg quadratures for numeric integration.</span>
<span class="s5">#</span>
<span class="s5"># Written by Scott M. Ransom &lt;ransom@cfa.harvard.edu&gt;</span>
<span class="s5"># last revision: 14 Nov 98</span>
<span class="s5">#</span>
<span class="s5"># Cosmetic changes by Konrad Hinsen &lt;hinsen@cnrs-orleans.fr&gt;</span>
<span class="s5"># last revision: 1999-7-21</span>
<span class="s5">#</span>
<span class="s5"># Adapted to SciPy by Travis Oliphant &lt;oliphant.travis@ieee.org&gt;</span>
<span class="s5"># last revision: Dec 2001</span>


<span class="s0">def </span><span class="s1">_difftrap(function</span><span class="s0">, </span><span class="s1">interval</span><span class="s0">, </span><span class="s1">numtraps):</span>
    <span class="s4">&quot;&quot;&quot; 
    Perform part of the trapezoidal rule to integrate a function. 
    Assume that we had called difftrap with all lower powers-of-2 
    starting with 1. Calling difftrap only returns the summation 
    of the new ordinates. It does _not_ multiply by the width 
    of the trapezoids. This must be performed by the caller. 
        'function' is the function to evaluate (must accept vector arguments). 
        'interval' is a sequence with lower and upper limits 
                   of integration. 
        'numtraps' is the number of trapezoids to use (must be a 
                   power-of-2). 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">numtraps &lt;= </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;numtraps must be &gt; 0 in difftrap().&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">numtraps == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s3">0.5</span><span class="s1">*(function(interval[</span><span class="s3">0</span><span class="s1">])+function(interval[</span><span class="s3">1</span><span class="s1">]))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">numtosum = numtraps/</span><span class="s3">2</span>
        <span class="s1">h = float(interval[</span><span class="s3">1</span><span class="s1">]-interval[</span><span class="s3">0</span><span class="s1">])/numtosum</span>
        <span class="s1">lox = interval[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">0.5 </span><span class="s1">* h</span>
        <span class="s1">points = lox + h * np.arange(numtosum)</span>
        <span class="s1">s = np.sum(function(points)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">s</span>


<span class="s0">def </span><span class="s1">_romberg_diff(b</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s4">&quot;&quot;&quot; 
    Compute the differences for the Romberg quadrature corrections. 
    See Forman Acton's &quot;Real Computing Made Real,&quot; p 143. 
    &quot;&quot;&quot;</span>
    <span class="s1">tmp = </span><span class="s3">4.0</span><span class="s1">**k</span>
    <span class="s0">return </span><span class="s1">(tmp * c - b)/(tmp - </span><span class="s3">1.0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_printresmat(function</span><span class="s0">, </span><span class="s1">interval</span><span class="s0">, </span><span class="s1">resmat):</span>
    <span class="s5"># Print the Romberg result matrix.</span>
    <span class="s1">i = j = </span><span class="s3">0</span>
    <span class="s1">print(</span><span class="s2">'Romberg integration of'</span><span class="s0">, </span><span class="s1">repr(function)</span><span class="s0">, </span><span class="s1">end=</span><span class="s2">' '</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s2">'from'</span><span class="s0">, </span><span class="s1">interval)</span>
    <span class="s1">print(</span><span class="s2">''</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s2">'%6s %9s %9s' </span><span class="s1">% (</span><span class="s2">'Steps'</span><span class="s0">, </span><span class="s2">'StepSize'</span><span class="s0">, </span><span class="s2">'Results'</span><span class="s1">))</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(resmat)):</span>
        <span class="s1">print(</span><span class="s2">'%6d %9f' </span><span class="s1">% (</span><span class="s3">2</span><span class="s1">**i</span><span class="s0">, </span><span class="s1">(interval[</span><span class="s3">1</span><span class="s1">]-interval[</span><span class="s3">0</span><span class="s1">])/(</span><span class="s3">2.</span><span class="s1">**i))</span><span class="s0">, </span><span class="s1">end=</span><span class="s2">' '</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(i+</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">print(</span><span class="s2">'%9f' </span><span class="s1">% (resmat[i][j])</span><span class="s0">, </span><span class="s1">end=</span><span class="s2">' '</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s2">''</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s2">''</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s2">'The final result is'</span><span class="s0">, </span><span class="s1">resmat[i][j]</span><span class="s0">, </span><span class="s1">end=</span><span class="s2">' '</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s2">'after'</span><span class="s0">, </span><span class="s3">2</span><span class="s1">**(len(resmat)-</span><span class="s3">1</span><span class="s1">)+</span><span class="s3">1</span><span class="s0">, </span><span class="s2">'function evaluations.'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">romberg(function</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">args=()</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1.48e-8</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1.48e-8</span><span class="s0">, </span><span class="s1">show=</span><span class="s0">False,</span>
            <span class="s1">divmax=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">vec_func=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Romberg integration of a callable function or method. 
 
    Returns the integral of `function` (a function of one variable) 
    over the interval (`a`, `b`). 
 
    If `show` is 1, the triangular array of the intermediate results 
    will be printed. If `vec_func` is True (default is False), then 
    `function` is assumed to support vector arguments. 
 
    Parameters 
    ---------- 
    function : callable 
        Function to be integrated. 
    a : float 
        Lower limit of integration. 
    b : float 
        Upper limit of integration. 
 
    Returns 
    ------- 
    results : float 
        Result of the integration. 
 
    Other Parameters 
    ---------------- 
    args : tuple, optional 
        Extra arguments to pass to function. Each element of `args` will 
        be passed as a single argument to `func`. Default is to pass no 
        extra arguments. 
    tol, rtol : float, optional 
        The desired absolute and relative tolerances. Defaults are 1.48e-8. 
    show : bool, optional 
        Whether to print the results. Default is False. 
    divmax : int, optional 
        Maximum order of extrapolation. Default is 10. 
    vec_func : bool, optional 
        Whether `func` handles arrays as arguments (i.e., whether it is a 
        &quot;vector&quot; function). Default is False. 
 
    See Also 
    -------- 
    fixed_quad : Fixed-order Gaussian quadrature. 
    quad : Adaptive quadrature using QUADPACK. 
    dblquad : Double integrals. 
    tplquad : Triple integrals. 
    romb : Integrators for sampled data. 
    simpson : Integrators for sampled data. 
    cumulative_trapezoid : Cumulative integration for sampled data. 
    ode : ODE integrator. 
    odeint : ODE integrator. 
 
    References 
    ---------- 
    .. [1] 'Romberg's method' https://en.wikipedia.org/wiki/Romberg%27s_method 
 
    Examples 
    -------- 
    Integrate a gaussian from 0 to 1 and compare to the error function. 
 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; from scipy.special import erf 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; gaussian = lambda x: 1/np.sqrt(np.pi) * np.exp(-x**2) 
    &gt;&gt;&gt; result = integrate.romberg(gaussian, 0, 1, show=True) 
    Romberg integration of &lt;function vfunc at ...&gt; from [0, 1] 
 
    :: 
 
       Steps  StepSize  Results 
           1  1.000000  0.385872 
           2  0.500000  0.412631  0.421551 
           4  0.250000  0.419184  0.421368  0.421356 
           8  0.125000  0.420810  0.421352  0.421350  0.421350 
          16  0.062500  0.421215  0.421350  0.421350  0.421350  0.421350 
          32  0.031250  0.421317  0.421350  0.421350  0.421350  0.421350  0.421350 
 
    The final result is 0.421350396475 after 33 function evaluations. 
 
    &gt;&gt;&gt; print(&quot;%g %g&quot; % (2*result, erf(1))) 
    0.842701 0.842701 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">np.isinf(a) </span><span class="s0">or </span><span class="s1">np.isinf(b):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Romberg integration only available &quot;</span>
                         <span class="s2">&quot;for finite limits.&quot;</span><span class="s1">)</span>
    <span class="s1">vfunc = vectorize1(function</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">vec_func=vec_func)</span>
    <span class="s1">n = </span><span class="s3">1</span>
    <span class="s1">interval = [a</span><span class="s0">, </span><span class="s1">b]</span>
    <span class="s1">intrange = b - a</span>
    <span class="s1">ordsum = _difftrap(vfunc</span><span class="s0">, </span><span class="s1">interval</span><span class="s0">, </span><span class="s1">n)</span>
    <span class="s1">result = intrange * ordsum</span>
    <span class="s1">resmat = [[result]]</span>
    <span class="s1">err = np.inf</span>
    <span class="s1">last_row = resmat[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">divmax+</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">n *= </span><span class="s3">2</span>
        <span class="s1">ordsum += _difftrap(vfunc</span><span class="s0">, </span><span class="s1">interval</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">row = [intrange * ordsum / n]</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(i):</span>
            <span class="s1">row.append(_romberg_diff(last_row[k]</span><span class="s0">, </span><span class="s1">row[k]</span><span class="s0">, </span><span class="s1">k+</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">result = row[i]</span>
        <span class="s1">lastresult = last_row[i-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">show:</span>
            <span class="s1">resmat.append(row)</span>
        <span class="s1">err = abs(result - lastresult)</span>
        <span class="s0">if </span><span class="s1">err &lt; tol </span><span class="s0">or </span><span class="s1">err &lt; rtol * abs(result):</span>
            <span class="s0">break</span>
        <span class="s1">last_row = row</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;divmax (%d) exceeded. Latest difference = %e&quot; </span><span class="s1">% (divmax</span><span class="s0">, </span><span class="s1">err)</span><span class="s0">,</span>
            <span class="s1">AccuracyWarning)</span>

    <span class="s0">if </span><span class="s1">show:</span>
        <span class="s1">_printresmat(vfunc</span><span class="s0">, </span><span class="s1">interval</span><span class="s0">, </span><span class="s1">resmat)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s5"># Coefficients for Newton-Cotes quadrature</span>
<span class="s5">#</span>
<span class="s5"># These are the points being used</span>
<span class="s5">#  to construct the local interpolating polynomial</span>
<span class="s5">#  a are the weights for Newton-Cotes integration</span>
<span class="s5">#  B is the error coefficient.</span>
<span class="s5">#  error in these coefficients grows as N gets larger.</span>
<span class="s5">#  or as samples are closer and closer together</span>

<span class="s5"># You can use maxima to find these rational coefficients</span>
<span class="s5">#  for equally spaced data using the commands</span>
<span class="s5">#  a(i,N) := integrate(product(r-j,j,0,i-1) * product(r-j,j,i+1,N),r,0,N) / ((N-i)! * i!) * (-1)^(N-i);</span>
<span class="s5">#  Be(N) := N^(N+2)/(N+2)! * (N/(N+3) - sum((i/N)^(N+2)*a(i,N),i,0,N));</span>
<span class="s5">#  Bo(N) := N^(N+1)/(N+1)! * (N/(N+2) - sum((i/N)^(N+1)*a(i,N),i,0,N));</span>
<span class="s5">#  B(N) := (if (mod(N,2)=0) then Be(N) else Bo(N));</span>
<span class="s5">#</span>
<span class="s5"># pre-computed for equally-spaced weights</span>
<span class="s5">#</span>
<span class="s5"># num_a, den_a, int_a, num_B, den_B = _builtincoeffs[N]</span>
<span class="s5">#</span>
<span class="s5">#  a = num_a*array(int_a)/den_a</span>
<span class="s5">#  B = num_B*1.0 / den_B</span>
<span class="s5">#</span>
<span class="s5">#  integrate(f(x),x,x_0,x_N) = dx*sum(a*f(x_i)) + B*(dx)^(2k+3) f^(2k+2)(x*)</span>
<span class="s5">#    where k = N // 2</span>
<span class="s5">#</span>
<span class="s1">_builtincoeffs = {</span>
    <span class="s3">1</span><span class="s1">: (</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s1">[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">2</span><span class="s1">: (</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s1">[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">90</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">3</span><span class="s1">: (</span><span class="s3">3</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s1">[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">-</span><span class="s3">3</span><span class="s0">,</span><span class="s3">80</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">4</span><span class="s1">: (</span><span class="s3">2</span><span class="s0">,</span><span class="s3">45</span><span class="s0">,</span><span class="s1">[</span><span class="s3">7</span><span class="s0">,</span><span class="s3">32</span><span class="s0">,</span><span class="s3">12</span><span class="s0">,</span><span class="s3">32</span><span class="s0">,</span><span class="s3">7</span><span class="s1">]</span><span class="s0">,</span><span class="s1">-</span><span class="s3">8</span><span class="s0">,</span><span class="s3">945</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">5</span><span class="s1">: (</span><span class="s3">5</span><span class="s0">,</span><span class="s3">288</span><span class="s0">,</span><span class="s1">[</span><span class="s3">19</span><span class="s0">,</span><span class="s3">75</span><span class="s0">,</span><span class="s3">50</span><span class="s0">,</span><span class="s3">50</span><span class="s0">,</span><span class="s3">75</span><span class="s0">,</span><span class="s3">19</span><span class="s1">]</span><span class="s0">,</span><span class="s1">-</span><span class="s3">275</span><span class="s0">,</span><span class="s3">12096</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">6</span><span class="s1">: (</span><span class="s3">1</span><span class="s0">,</span><span class="s3">140</span><span class="s0">,</span><span class="s1">[</span><span class="s3">41</span><span class="s0">,</span><span class="s3">216</span><span class="s0">,</span><span class="s3">27</span><span class="s0">,</span><span class="s3">272</span><span class="s0">,</span><span class="s3">27</span><span class="s0">,</span><span class="s3">216</span><span class="s0">,</span><span class="s3">41</span><span class="s1">]</span><span class="s0">,</span><span class="s1">-</span><span class="s3">9</span><span class="s0">,</span><span class="s3">1400</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">7</span><span class="s1">: (</span><span class="s3">7</span><span class="s0">,</span><span class="s3">17280</span><span class="s0">,</span><span class="s1">[</span><span class="s3">751</span><span class="s0">,</span><span class="s3">3577</span><span class="s0">,</span><span class="s3">1323</span><span class="s0">,</span><span class="s3">2989</span><span class="s0">,</span><span class="s3">2989</span><span class="s0">,</span><span class="s3">1323</span><span class="s0">,</span><span class="s3">3577</span><span class="s0">,</span><span class="s3">751</span><span class="s1">]</span><span class="s0">,</span><span class="s1">-</span><span class="s3">8183</span><span class="s0">,</span><span class="s3">518400</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">8</span><span class="s1">: (</span><span class="s3">4</span><span class="s0">,</span><span class="s3">14175</span><span class="s0">,</span><span class="s1">[</span><span class="s3">989</span><span class="s0">,</span><span class="s3">5888</span><span class="s0">,</span><span class="s1">-</span><span class="s3">928</span><span class="s0">,</span><span class="s3">10496</span><span class="s0">,</span><span class="s1">-</span><span class="s3">4540</span><span class="s0">,</span><span class="s3">10496</span><span class="s0">,</span><span class="s1">-</span><span class="s3">928</span><span class="s0">,</span><span class="s3">5888</span><span class="s0">,</span><span class="s3">989</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">-</span><span class="s3">2368</span><span class="s0">,</span><span class="s3">467775</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">9</span><span class="s1">: (</span><span class="s3">9</span><span class="s0">,</span><span class="s3">89600</span><span class="s0">,</span><span class="s1">[</span><span class="s3">2857</span><span class="s0">,</span><span class="s3">15741</span><span class="s0">,</span><span class="s3">1080</span><span class="s0">,</span><span class="s3">19344</span><span class="s0">,</span><span class="s3">5778</span><span class="s0">,</span><span class="s3">5778</span><span class="s0">,</span><span class="s3">19344</span><span class="s0">,</span><span class="s3">1080</span><span class="s0">,</span>
                 <span class="s3">15741</span><span class="s0">,</span><span class="s3">2857</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">4671</span><span class="s0">, </span><span class="s3">394240</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">10</span><span class="s1">: (</span><span class="s3">5</span><span class="s0">,</span><span class="s3">299376</span><span class="s0">,</span><span class="s1">[</span><span class="s3">16067</span><span class="s0">,</span><span class="s3">106300</span><span class="s0">,</span><span class="s1">-</span><span class="s3">48525</span><span class="s0">,</span><span class="s3">272400</span><span class="s0">,</span><span class="s1">-</span><span class="s3">260550</span><span class="s0">,</span><span class="s3">427368</span><span class="s0">,</span>
                   <span class="s1">-</span><span class="s3">260550</span><span class="s0">,</span><span class="s3">272400</span><span class="s0">,</span><span class="s1">-</span><span class="s3">48525</span><span class="s0">,</span><span class="s3">106300</span><span class="s0">,</span><span class="s3">16067</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s3">673175</span><span class="s0">, </span><span class="s3">163459296</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">11</span><span class="s1">: (</span><span class="s3">11</span><span class="s0">,</span><span class="s3">87091200</span><span class="s0">,</span><span class="s1">[</span><span class="s3">2171465</span><span class="s0">,</span><span class="s3">13486539</span><span class="s0">,</span><span class="s1">-</span><span class="s3">3237113</span><span class="s0">, </span><span class="s3">25226685</span><span class="s0">,</span><span class="s1">-</span><span class="s3">9595542</span><span class="s0">,</span>
                      <span class="s3">15493566</span><span class="s0">,</span><span class="s3">15493566</span><span class="s0">,</span><span class="s1">-</span><span class="s3">9595542</span><span class="s0">,</span><span class="s3">25226685</span><span class="s0">,</span><span class="s1">-</span><span class="s3">3237113</span><span class="s0">,</span>
                      <span class="s3">13486539</span><span class="s0">,</span><span class="s3">2171465</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2224234463</span><span class="s0">, </span><span class="s3">237758976000</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">12</span><span class="s1">: (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5255250</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1364651</span><span class="s0">,</span><span class="s3">9903168</span><span class="s0">,</span><span class="s1">-</span><span class="s3">7587864</span><span class="s0">,</span><span class="s3">35725120</span><span class="s0">,</span><span class="s1">-</span><span class="s3">51491295</span><span class="s0">,</span>
                      <span class="s3">87516288</span><span class="s0">,</span><span class="s1">-</span><span class="s3">87797136</span><span class="s0">,</span><span class="s3">87516288</span><span class="s0">,</span><span class="s1">-</span><span class="s3">51491295</span><span class="s0">,</span><span class="s3">35725120</span><span class="s0">,</span>
                      <span class="s1">-</span><span class="s3">7587864</span><span class="s0">,</span><span class="s3">9903168</span><span class="s0">,</span><span class="s3">1364651</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3012</span><span class="s0">, </span><span class="s3">875875</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">13</span><span class="s1">: (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">402361344000</span><span class="s0">,</span><span class="s1">[</span><span class="s3">8181904909</span><span class="s0">, </span><span class="s3">56280729661</span><span class="s0">, </span><span class="s1">-</span><span class="s3">31268252574</span><span class="s0">,</span>
                           <span class="s3">156074417954</span><span class="s0">,</span><span class="s1">-</span><span class="s3">151659573325</span><span class="s0">,</span><span class="s3">206683437987</span><span class="s0">,</span>
                           <span class="s1">-</span><span class="s3">43111992612</span><span class="s0">,</span><span class="s1">-</span><span class="s3">43111992612</span><span class="s0">,</span><span class="s3">206683437987</span><span class="s0">,</span>
                           <span class="s1">-</span><span class="s3">151659573325</span><span class="s0">,</span><span class="s3">156074417954</span><span class="s0">,</span><span class="s1">-</span><span class="s3">31268252574</span><span class="s0">,</span>
                           <span class="s3">56280729661</span><span class="s0">,</span><span class="s3">8181904909</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2639651053</span><span class="s0">,</span>
         <span class="s3">344881152000</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s3">14</span><span class="s1">: (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">2501928000</span><span class="s0">, </span><span class="s1">[</span><span class="s3">90241897</span><span class="s0">,</span><span class="s3">710986864</span><span class="s0">,</span><span class="s1">-</span><span class="s3">770720657</span><span class="s0">,</span><span class="s3">3501442784</span><span class="s0">,</span>
                         <span class="s1">-</span><span class="s3">6625093363</span><span class="s0">,</span><span class="s3">12630121616</span><span class="s0">,</span><span class="s1">-</span><span class="s3">16802270373</span><span class="s0">,</span><span class="s3">19534438464</span><span class="s0">,</span>
                         <span class="s1">-</span><span class="s3">16802270373</span><span class="s0">,</span><span class="s3">12630121616</span><span class="s0">,</span><span class="s1">-</span><span class="s3">6625093363</span><span class="s0">,</span><span class="s3">3501442784</span><span class="s0">,</span>
                         <span class="s1">-</span><span class="s3">770720657</span><span class="s0">,</span><span class="s3">710986864</span><span class="s0">,</span><span class="s3">90241897</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3740727473</span><span class="s0">,</span>
         <span class="s3">1275983280000</span><span class="s1">)</span>
    <span class="s1">}</span>


<span class="s0">def </span><span class="s1">newton_cotes(rn</span><span class="s0">, </span><span class="s1">equal=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s4">r&quot;&quot;&quot; 
    Return weights and error coefficient for Newton-Cotes integration. 
 
    Suppose we have (N+1) samples of f at the positions 
    x_0, x_1, ..., x_N. Then an N-point Newton-Cotes formula for the 
    integral between x_0 and x_N is: 
 
    :math:`\int_{x_0}^{x_N} f(x)dx = \Delta x \sum_{i=0}^{N} a_i f(x_i) 
    + B_N (\Delta x)^{N+2} f^{N+1} (\xi)` 
 
    where :math:`\xi \in [x_0,x_N]` 
    and :math:`\Delta x = \frac{x_N-x_0}{N}` is the average samples spacing. 
 
    If the samples are equally-spaced and N is even, then the error 
    term is :math:`B_N (\Delta x)^{N+3} f^{N+2}(\xi)`. 
 
    Parameters 
    ---------- 
    rn : int 
        The integer order for equally-spaced data or the relative positions of 
        the samples with the first sample at 0 and the last at N, where N+1 is 
        the length of `rn`. N is the order of the Newton-Cotes integration. 
    equal : int, optional 
        Set to 1 to enforce equally spaced data. 
 
    Returns 
    ------- 
    an : ndarray 
        1-D array of weights to apply to the function at the provided sample 
        positions. 
    B : float 
        Error coefficient. 
 
    Notes 
    ----- 
    Normally, the Newton-Cotes rules are used on smaller integration 
    regions and a composite rule is used to return the total integral. 
 
    Examples 
    -------- 
    Compute the integral of sin(x) in [0, :math:`\pi`]: 
 
    &gt;&gt;&gt; from scipy.integrate import newton_cotes 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; def f(x): 
    ...     return np.sin(x) 
    &gt;&gt;&gt; a = 0 
    &gt;&gt;&gt; b = np.pi 
    &gt;&gt;&gt; exact = 2 
    &gt;&gt;&gt; for N in [2, 4, 6, 8, 10]: 
    ...     x = np.linspace(a, b, N + 1) 
    ...     an, B = newton_cotes(N, 1) 
    ...     dx = (b - a) / N 
    ...     quad = dx * np.sum(an * f(x)) 
    ...     error = abs(quad - exact) 
    ...     print('{:2d}  {:10.9f}  {:.5e}'.format(N, quad, error)) 
    ... 
     2   2.094395102   9.43951e-02 
     4   1.998570732   1.42927e-03 
     6   2.000017814   1.78136e-05 
     8   1.999999835   1.64725e-07 
    10   2.000000001   1.14677e-09 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">N = len(rn)-</span><span class="s3">1</span>
        <span class="s0">if </span><span class="s1">equal:</span>
            <span class="s1">rn = np.arange(N+</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">np.all(np.diff(rn) == </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">equal = </span><span class="s3">1</span>
    <span class="s0">except </span><span class="s1">Exception:</span>
        <span class="s1">N = rn</span>
        <span class="s1">rn = np.arange(N+</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">equal = </span><span class="s3">1</span>

    <span class="s0">if </span><span class="s1">equal </span><span class="s0">and </span><span class="s1">N </span><span class="s0">in </span><span class="s1">_builtincoeffs:</span>
        <span class="s1">na</span><span class="s0">, </span><span class="s1">da</span><span class="s0">, </span><span class="s1">vi</span><span class="s0">, </span><span class="s1">nb</span><span class="s0">, </span><span class="s1">db = _builtincoeffs[N]</span>
        <span class="s1">an = na * np.array(vi</span><span class="s0">, </span><span class="s1">dtype=float) / da</span>
        <span class="s0">return </span><span class="s1">an</span><span class="s0">, </span><span class="s1">float(nb)/db</span>

    <span class="s0">if </span><span class="s1">(rn[</span><span class="s3">0</span><span class="s1">] != </span><span class="s3">0</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(rn[-</span><span class="s3">1</span><span class="s1">] != N):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;The sample positions must start at 0&quot;</span>
                         <span class="s2">&quot; and end at N&quot;</span><span class="s1">)</span>
    <span class="s1">yi = rn / float(N)</span>
    <span class="s1">ti = </span><span class="s3">2 </span><span class="s1">* yi - </span><span class="s3">1</span>
    <span class="s1">nvec = np.arange(N+</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">C = ti ** nvec[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
    <span class="s1">Cinv = np.linalg.inv(C)</span>
    <span class="s5"># improve precision of result</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s1">):</span>
        <span class="s1">Cinv = </span><span class="s3">2</span><span class="s1">*Cinv - Cinv.dot(C).dot(Cinv)</span>
    <span class="s1">vec = </span><span class="s3">2.0 </span><span class="s1">/ (nvec[::</span><span class="s3">2</span><span class="s1">]+</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">ai = Cinv[:</span><span class="s0">, </span><span class="s1">::</span><span class="s3">2</span><span class="s1">].dot(vec) * (N / </span><span class="s3">2.</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">(N % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">) </span><span class="s0">and </span><span class="s1">equal:</span>
        <span class="s1">BN = N/(N+</span><span class="s3">3.</span><span class="s1">)</span>
        <span class="s1">power = N+</span><span class="s3">2</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">BN = N/(N+</span><span class="s3">2.</span><span class="s1">)</span>
        <span class="s1">power = N+</span><span class="s3">1</span>

    <span class="s1">BN = BN - np.dot(yi**power</span><span class="s0">, </span><span class="s1">ai)</span>
    <span class="s1">p1 = power+</span><span class="s3">1</span>
    <span class="s1">fac = power*math.log(N) - gammaln(p1)</span>
    <span class="s1">fac = math.exp(fac)</span>
    <span class="s0">return </span><span class="s1">ai</span><span class="s0">, </span><span class="s1">BN*fac</span>


<span class="s0">def </span><span class="s1">_qmc_quad_iv(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n_points</span><span class="s0">, </span><span class="s1">n_estimates</span><span class="s0">, </span><span class="s1">qrng</span><span class="s0">, </span><span class="s1">log):</span>

    <span class="s5"># lazy import to avoid issues with partially-initialized submodule</span>
    <span class="s0">if not </span><span class="s1">hasattr(qmc_quad</span><span class="s0">, </span><span class="s2">'qmc'</span><span class="s1">):</span>
        <span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
        <span class="s1">qmc_quad.stats = stats</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">stats = qmc_quad.stats</span>

    <span class="s0">if not </span><span class="s1">callable(func):</span>
        <span class="s1">message = </span><span class="s2">&quot;`func` must be callable.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(message)</span>

    <span class="s5"># a, b will be modified, so copy. Oh well if it's copied twice.</span>
    <span class="s1">a = np.atleast_1d(a).copy()</span>
    <span class="s1">b = np.atleast_1d(b).copy()</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = np.broadcast_arrays(a</span><span class="s0">, </span><span class="s1">b)</span>
    <span class="s1">dim = a.shape[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">func((a + b) / </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s1">message = (</span><span class="s2">&quot;`func` must evaluate the integrand at points within &quot;</span>
                   <span class="s2">&quot;the integration range; e.g. `func( (a + b) / 2)` &quot;</span>
                   <span class="s2">&quot;must return the integrand at the centroid of the &quot;</span>
                   <span class="s2">&quot;integration volume.&quot;</span><span class="s1">)</span>
        <span class="s0">raise </span><span class="s1">ValueError(message) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">func(np.array([a</span><span class="s0">, </span><span class="s1">b]).T)</span>
        <span class="s1">vfunc = func</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s1">message = (</span><span class="s2">&quot;Exception encountered when attempting vectorized call to &quot;</span>
                   <span class="s2">f&quot;`func`: </span><span class="s0">{</span><span class="s1">e</span><span class="s0">}</span><span class="s2">. For better performance, `func` should &quot;</span>
                   <span class="s2">&quot;accept two-dimensional array `x` with shape `(len(a), &quot;</span>
                   <span class="s2">&quot;n_points)` and return an array of the integrand value at &quot;</span>
                   <span class="s2">&quot;each of the `n_points.&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(message</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">vfunc(x):</span>
            <span class="s0">return </span><span class="s1">np.apply_along_axis(func</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">arr=x)</span>

    <span class="s1">n_points_int = np.int64(n_points)</span>
    <span class="s0">if </span><span class="s1">n_points != n_points_int:</span>
        <span class="s1">message = </span><span class="s2">&quot;`n_points` must be an integer.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(message)</span>

    <span class="s1">n_estimates_int = np.int64(n_estimates)</span>
    <span class="s0">if </span><span class="s1">n_estimates != n_estimates_int:</span>
        <span class="s1">message = </span><span class="s2">&quot;`n_estimates` must be an integer.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(message)</span>

    <span class="s0">if </span><span class="s1">qrng </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">qrng = stats.qmc.Halton(dim)</span>
    <span class="s0">elif not </span><span class="s1">isinstance(qrng</span><span class="s0">, </span><span class="s1">stats.qmc.QMCEngine):</span>
        <span class="s1">message = </span><span class="s2">&quot;`qrng` must be an instance of scipy.stats.qmc.QMCEngine.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(message)</span>

    <span class="s0">if </span><span class="s1">qrng.d != a.shape[</span><span class="s3">0</span><span class="s1">]:</span>
        <span class="s1">message = (</span><span class="s2">&quot;`qrng` must be initialized with dimensionality equal to &quot;</span>
                   <span class="s2">&quot;the number of variables in `a`, i.e., &quot;</span>
                   <span class="s2">&quot;`qrng.random().shape[-1]` must equal `a.shape[0]`.&quot;</span><span class="s1">)</span>
        <span class="s0">raise </span><span class="s1">ValueError(message)</span>

    <span class="s1">rng_seed = getattr(qrng</span><span class="s0">, </span><span class="s2">'rng_seed'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">rng = stats._qmc.check_random_state(rng_seed)</span>

    <span class="s0">if </span><span class="s1">log </span><span class="s0">not in </span><span class="s1">{</span><span class="s0">True, False</span><span class="s1">}:</span>
        <span class="s1">message = </span><span class="s2">&quot;`log` must be boolean (`True` or `False`).&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(message)</span>

    <span class="s0">return </span><span class="s1">(vfunc</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n_points_int</span><span class="s0">, </span><span class="s1">n_estimates_int</span><span class="s0">, </span><span class="s1">qrng</span><span class="s0">, </span><span class="s1">rng</span><span class="s0">, </span><span class="s1">log</span><span class="s0">, </span><span class="s1">stats)</span>


<span class="s1">QMCQuadResult = namedtuple(</span><span class="s2">'QMCQuadResult'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'integral'</span><span class="s0">, </span><span class="s2">'standard_error'</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">qmc_quad(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">n_estimates=</span><span class="s3">8</span><span class="s0">, </span><span class="s1">n_points=</span><span class="s3">1024</span><span class="s0">, </span><span class="s1">qrng=</span><span class="s0">None,</span>
             <span class="s1">log=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Compute an integral in N-dimensions using Quasi-Monte Carlo quadrature. 
 
    Parameters 
    ---------- 
    func : callable 
        The integrand. Must accept a single argument ``x``, an array which 
        specifies the point(s) at which to evaluate the scalar-valued 
        integrand, and return the value(s) of the integrand. 
        For efficiency, the function should be vectorized to accept an array of 
        shape ``(d, n_points)``, where ``d`` is the number of variables (i.e. 
        the dimensionality of the function domain) and `n_points` is the number 
        of quadrature points, and return an array of shape ``(n_points,)``, 
        the integrand at each quadrature point. 
    a, b : array-like 
        One-dimensional arrays specifying the lower and upper integration 
        limits, respectively, of each of the ``d`` variables. 
    n_estimates, n_points : int, optional 
        `n_estimates` (default: 8) statistically independent QMC samples, each 
        of `n_points` (default: 1024) points, will be generated by `qrng`. 
        The total number of points at which the integrand `func` will be 
        evaluated is ``n_points * n_estimates``. See Notes for details. 
    qrng : `~scipy.stats.qmc.QMCEngine`, optional 
        An instance of the QMCEngine from which to sample QMC points. 
        The QMCEngine must be initialized to a number of dimensions ``d`` 
        corresponding with the number of variables ``x1, ..., xd`` passed to 
        `func`. 
        The provided QMCEngine is used to produce the first integral estimate. 
        If `n_estimates` is greater than one, additional QMCEngines are 
        spawned from the first (with scrambling enabled, if it is an option.) 
        If a QMCEngine is not provided, the default `scipy.stats.qmc.Halton` 
        will be initialized with the number of dimensions determine from 
        the length of `a`. 
    log : boolean, default: False 
        When set to True, `func` returns the log of the integrand, and 
        the result object contains the log of the integral. 
 
    Returns 
    ------- 
    result : object 
        A result object with attributes: 
 
        integral : float 
            The estimate of the integral. 
        standard_error : 
            The error estimate. See Notes for interpretation. 
 
    Notes 
    ----- 
    Values of the integrand at each of the `n_points` points of a QMC sample 
    are used to produce an estimate of the integral. This estimate is drawn 
    from a population of possible estimates of the integral, the value of 
    which we obtain depends on the particular points at which the integral 
    was evaluated. We perform this process `n_estimates` times, each time 
    evaluating the integrand at different scrambled QMC points, effectively 
    drawing i.i.d. random samples from the population of integral estimates. 
    The sample mean :math:`m` of these integral estimates is an 
    unbiased estimator of the true value of the integral, and the standard 
    error of the mean :math:`s` of these estimates may be used to generate 
    confidence intervals using the t distribution with ``n_estimates - 1`` 
    degrees of freedom. Perhaps counter-intuitively, increasing `n_points` 
    while keeping the total number of function evaluation points 
    ``n_points * n_estimates`` fixed tends to reduce the actual error, whereas 
    increasing `n_estimates` tends to decrease the error estimate. 
 
    Examples 
    -------- 
    QMC quadrature is particularly useful for computing integrals in higher 
    dimensions. An example integrand is the probability density function 
    of a multivariate normal distribution. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; dim = 8 
    &gt;&gt;&gt; mean = np.zeros(dim) 
    &gt;&gt;&gt; cov = np.eye(dim) 
    &gt;&gt;&gt; def func(x): 
    ...     # `multivariate_normal` expects the _last_ axis to correspond with 
    ...     # the dimensionality of the space, so `x` must be transposed 
    ...     return stats.multivariate_normal.pdf(x.T, mean, cov) 
 
    To compute the integral over the unit hypercube: 
 
    &gt;&gt;&gt; from scipy.integrate import qmc_quad 
    &gt;&gt;&gt; a = np.zeros(dim) 
    &gt;&gt;&gt; b = np.ones(dim) 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; qrng = stats.qmc.Halton(d=dim, seed=rng) 
    &gt;&gt;&gt; n_estimates = 8 
    &gt;&gt;&gt; res = qmc_quad(func, a, b, n_estimates=n_estimates, qrng=qrng) 
    &gt;&gt;&gt; res.integral, res.standard_error 
    (0.00018429555666024108, 1.0389431116001344e-07) 
 
    A two-sided, 99% confidence interval for the integral may be estimated 
    as: 
 
    &gt;&gt;&gt; t = stats.t(df=n_estimates-1, loc=res.integral, 
    ...             scale=res.standard_error) 
    &gt;&gt;&gt; t.interval(0.99) 
    (0.0001839319802536469, 0.00018465913306683527) 
 
    Indeed, the value reported by `scipy.stats.multivariate_normal` is 
    within this range. 
 
    &gt;&gt;&gt; stats.multivariate_normal.cdf(b, mean, cov, lower_limit=a) 
    0.00018430867675187443 
 
    &quot;&quot;&quot;</span>
    <span class="s1">args = _qmc_quad_iv(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n_points</span><span class="s0">, </span><span class="s1">n_estimates</span><span class="s0">, </span><span class="s1">qrng</span><span class="s0">, </span><span class="s1">log)</span>
    <span class="s1">func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n_points</span><span class="s0">, </span><span class="s1">n_estimates</span><span class="s0">, </span><span class="s1">qrng</span><span class="s0">, </span><span class="s1">rng</span><span class="s0">, </span><span class="s1">log</span><span class="s0">, </span><span class="s1">stats = args</span>

    <span class="s0">def </span><span class="s1">sum_product(integrands</span><span class="s0">, </span><span class="s1">dA</span><span class="s0">, </span><span class="s1">log=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">log:</span>
            <span class="s0">return </span><span class="s1">logsumexp(integrands) + np.log(dA)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.sum(integrands * dA)</span>

    <span class="s0">def </span><span class="s1">mean(estimates</span><span class="s0">, </span><span class="s1">log=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">log:</span>
            <span class="s0">return </span><span class="s1">logsumexp(estimates) - np.log(n_estimates)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.mean(estimates)</span>

    <span class="s0">def </span><span class="s1">std(estimates</span><span class="s0">, </span><span class="s1">m=</span><span class="s0">None, </span><span class="s1">ddof=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">log=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">m = m </span><span class="s0">or </span><span class="s1">mean(estimates</span><span class="s0">, </span><span class="s1">log)</span>
        <span class="s0">if </span><span class="s1">log:</span>
            <span class="s1">estimates</span><span class="s0">, </span><span class="s1">m = np.broadcast_arrays(estimates</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s1">temp = np.vstack((estimates</span><span class="s0">, </span><span class="s1">m + np.pi * </span><span class="s3">1j</span><span class="s1">))</span>
            <span class="s1">diff = logsumexp(temp</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">np.real(</span><span class="s3">0.5 </span><span class="s1">* (logsumexp(</span><span class="s3">2 </span><span class="s1">* diff)</span>
                                  <span class="s1">- np.log(n_estimates - ddof)))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.std(estimates</span><span class="s0">, </span><span class="s1">ddof=ddof)</span>

    <span class="s0">def </span><span class="s1">sem(estimates</span><span class="s0">, </span><span class="s1">m=</span><span class="s0">None, </span><span class="s1">s=</span><span class="s0">None, </span><span class="s1">log=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">m = m </span><span class="s0">or </span><span class="s1">mean(estimates</span><span class="s0">, </span><span class="s1">log)</span>
        <span class="s1">s = s </span><span class="s0">or </span><span class="s1">std(estimates</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">ddof=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">log=log)</span>
        <span class="s0">if </span><span class="s1">log:</span>
            <span class="s0">return </span><span class="s1">s - </span><span class="s3">0.5</span><span class="s1">*np.log(n_estimates)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">s / np.sqrt(n_estimates)</span>

    <span class="s5"># The sign of the integral depends on the order of the limits. Fix this by</span>
    <span class="s5"># ensuring that lower bounds are indeed lower and setting sign of resulting</span>
    <span class="s5"># integral manually</span>
    <span class="s0">if </span><span class="s1">np.any(a == b):</span>
        <span class="s1">message = (</span><span class="s2">&quot;A lower limit was equal to an upper limit, so the value &quot;</span>
                   <span class="s2">&quot;of the integral is zero by definition.&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(message</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">QMCQuadResult(-np.inf </span><span class="s0">if </span><span class="s1">log </span><span class="s0">else </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">i_swap = b &lt; a</span>
    <span class="s1">sign = (-</span><span class="s3">1</span><span class="s1">)**(i_swap.sum(axis=-</span><span class="s3">1</span><span class="s1">))  </span><span class="s5"># odd # of swaps -&gt; negative</span>
    <span class="s1">a[i_swap]</span><span class="s0">, </span><span class="s1">b[i_swap] = b[i_swap]</span><span class="s0">, </span><span class="s1">a[i_swap]</span>

    <span class="s1">A = np.prod(b - a)</span>
    <span class="s1">dA = A / n_points</span>

    <span class="s1">estimates = np.zeros(n_estimates)</span>
    <span class="s1">rngs = _rng_spawn(qrng.rng</span><span class="s0">, </span><span class="s1">n_estimates)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n_estimates):</span>
        <span class="s5"># Generate integral estimate</span>
        <span class="s1">sample = qrng.random(n_points)</span>
        <span class="s5"># The rationale for transposing is that this allows users to easily</span>
        <span class="s5"># unpack `x` into separate variables, if desired. This is consistent</span>
        <span class="s5"># with the `xx` array passed into the `scipy.integrate.nquad` `func`.</span>
        <span class="s1">x = stats.qmc.scale(sample</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b).T  </span><span class="s5"># (n_dim, n_points)</span>
        <span class="s1">integrands = func(x)</span>
        <span class="s1">estimates[i] = sum_product(integrands</span><span class="s0">, </span><span class="s1">dA</span><span class="s0">, </span><span class="s1">log)</span>

        <span class="s5"># Get a new, independently-scrambled QRNG for next time</span>
        <span class="s1">qrng = type(qrng)(seed=rngs[i]</span><span class="s0">, </span><span class="s1">**qrng._init_quad)</span>

    <span class="s1">integral = mean(estimates</span><span class="s0">, </span><span class="s1">log)</span>
    <span class="s1">standard_error = sem(estimates</span><span class="s0">, </span><span class="s1">m=integral</span><span class="s0">, </span><span class="s1">log=log)</span>
    <span class="s1">integral = integral + np.pi*</span><span class="s3">1j </span><span class="s0">if </span><span class="s1">(log </span><span class="s0">and </span><span class="s1">sign &lt; </span><span class="s3">0</span><span class="s1">) </span><span class="s0">else </span><span class="s1">integral*sign</span>
    <span class="s0">return </span><span class="s1">QMCQuadResult(integral</span><span class="s0">, </span><span class="s1">standard_error)</span>
</pre>
</body>
</html>