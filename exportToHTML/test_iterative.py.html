<html>
<head>
<title>test_iterative.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_iterative.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; Test functions for the sparse.linalg._isolve module 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">platform</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_array_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">,</span>
                           <span class="s1">suppress_warnings)</span>
<span class="s2">import </span><span class="s1">pytest</span>


<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">arange</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">ones</span><span class="s2">, </span><span class="s1">eye</span><span class="s2">, </span><span class="s1">iscomplexobj</span>
<span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">norm</span>
<span class="s2">from </span><span class="s1">scipy.sparse </span><span class="s2">import </span><span class="s1">spdiags</span><span class="s2">, </span><span class="s1">csr_matrix</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">kronsum</span>

<span class="s2">from </span><span class="s1">scipy.sparse.linalg </span><span class="s2">import </span><span class="s1">LinearOperator</span><span class="s2">, </span><span class="s1">aslinearoperator</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg._isolve </span><span class="s2">import </span><span class="s1">(bicg</span><span class="s2">, </span><span class="s1">bicgstab</span><span class="s2">, </span><span class="s1">cg</span><span class="s2">, </span><span class="s1">cgs</span><span class="s2">,</span>
                                         <span class="s1">gcrotmk</span><span class="s2">, </span><span class="s1">gmres</span><span class="s2">, </span><span class="s1">lgmres</span><span class="s2">,</span>
                                         <span class="s1">minres</span><span class="s2">, </span><span class="s1">qmr</span><span class="s2">, </span><span class="s1">tfqmr)</span>

<span class="s3"># TODO check that method preserve shape and type</span>
<span class="s3"># TODO test both preconditioner methods</span>


<span class="s3"># list of all solvers under test</span>
<span class="s1">_SOLVERS = [bicg</span><span class="s2">, </span><span class="s1">bicgstab</span><span class="s2">, </span><span class="s1">cg</span><span class="s2">, </span><span class="s1">cgs</span><span class="s2">, </span><span class="s1">gcrotmk</span><span class="s2">, </span><span class="s1">gmres</span><span class="s2">, </span><span class="s1">lgmres</span><span class="s2">,</span>
            <span class="s1">minres</span><span class="s2">, </span><span class="s1">qmr</span><span class="s2">, </span><span class="s1">tfqmr]</span>
<span class="s3"># create parametrized fixture for easy reuse in tests</span>
<span class="s1">@pytest.fixture(params=_SOLVERS</span><span class="s2">, </span><span class="s1">scope=</span><span class="s4">&quot;session&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">solver(request):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fixture for all solvers in scipy.sparse.linalg._isolve 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s2">class </span><span class="s1">Case:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">b=</span><span class="s2">None, </span><span class="s1">skip=</span><span class="s2">None, </span><span class="s1">nonconvergence=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.A = A</span>
        <span class="s2">if </span><span class="s1">b </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.b = arange(A.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.b = b</span>
        <span class="s2">if </span><span class="s1">skip </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.skip = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.skip = skip</span>
        <span class="s2">if </span><span class="s1">nonconvergence </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.nonconvergence = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.nonconvergence = nonconvergence</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">IterativeParams:</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">sym_solvers = [minres</span><span class="s2">, </span><span class="s1">cg]</span>
        <span class="s1">posdef_solvers = [cg]</span>
        <span class="s1">real_solvers = [minres]</span>

        <span class="s3"># list of Cases</span>
        <span class="s1">self.cases = []</span>

        <span class="s3"># Symmetric and Positive Definite</span>
        <span class="s1">N = </span><span class="s5">40</span>
        <span class="s1">data = ones((</span><span class="s5">3</span><span class="s2">, </span><span class="s1">N))</span>
        <span class="s1">data[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:] = </span><span class="s5">2</span>
        <span class="s1">data[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = -</span><span class="s5">1</span>
        <span class="s1">data[</span><span class="s5">2</span><span class="s2">, </span><span class="s1">:] = -</span><span class="s5">1</span>
        <span class="s1">Poisson1D = spdiags(data</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s1">)</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;poisson1d&quot;</span><span class="s2">, </span><span class="s1">Poisson1D))</span>
        <span class="s3"># note: minres fails for single precision</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;poisson1d-F&quot;</span><span class="s2">, </span><span class="s1">Poisson1D.astype(</span><span class="s4">'f'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=[minres]))</span>

        <span class="s3"># Symmetric and Negative Definite</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;neg-poisson1d&quot;</span><span class="s2">, </span><span class="s1">-Poisson1D</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers))</span>
        <span class="s3"># note: minres fails for single precision</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;neg-poisson1d-F&quot;</span><span class="s2">, </span><span class="s1">(-Poisson1D).astype(</span><span class="s4">'f'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers + [minres]))</span>

        <span class="s3"># 2-dimensional Poisson equations</span>
        <span class="s1">Poisson2D = kronsum(Poisson1D</span><span class="s2">, </span><span class="s1">Poisson1D)</span>
        <span class="s3"># note: minres fails for 2-d poisson problem,</span>
        <span class="s3"># it will be fixed in the future PR</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;poisson2d&quot;</span><span class="s2">, </span><span class="s1">Poisson2D</span><span class="s2">, </span><span class="s1">skip=[minres]))</span>
        <span class="s3"># note: minres fails for single precision</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;poisson2d-F&quot;</span><span class="s2">, </span><span class="s1">Poisson2D.astype(</span><span class="s4">'f'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=[minres]))</span>

        <span class="s3"># Symmetric and Indefinite</span>
        <span class="s1">data = array([[</span><span class="s5">6</span><span class="s2">, </span><span class="s1">-</span><span class="s5">5</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">'d'</span><span class="s1">)</span>
        <span class="s1">RandDiag = spdiags(data</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s1">)</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-diag&quot;</span><span class="s2">, </span><span class="s1">RandDiag</span><span class="s2">, </span><span class="s1">skip=posdef_solvers))</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-diag-F&quot;</span><span class="s2">, </span><span class="s1">RandDiag.astype(</span><span class="s4">'f'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers))</span>

        <span class="s3"># Random real-valued</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">data = np.random.rand(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers + sym_solvers))</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-F&quot;</span><span class="s2">, </span><span class="s1">data.astype(</span><span class="s4">'f'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers + sym_solvers))</span>

        <span class="s3"># Random symmetric real-valued</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">data = np.random.rand(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">data = data + data.T</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-sym&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">skip=posdef_solvers))</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-sym-F&quot;</span><span class="s2">, </span><span class="s1">data.astype(</span><span class="s4">'f'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers))</span>

        <span class="s3"># Random pos-def symmetric real</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">data = np.random.rand(</span><span class="s5">9</span><span class="s2">, </span><span class="s5">9</span><span class="s1">)</span>
        <span class="s1">data = np.dot(data.conj()</span><span class="s2">, </span><span class="s1">data.T)</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-sym-pd&quot;</span><span class="s2">, </span><span class="s1">data))</span>
        <span class="s3"># note: minres fails for single precision</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-sym-pd-F&quot;</span><span class="s2">, </span><span class="s1">data.astype(</span><span class="s4">'f'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=[minres]))</span>

        <span class="s3"># Random complex-valued</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">data = np.random.rand(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s1">) + </span><span class="s5">1j </span><span class="s1">* np.random.rand(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">skip_cmplx = posdef_solvers + sym_solvers + real_solvers</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-cmplx&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">skip=skip_cmplx))</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-cmplx-F&quot;</span><span class="s2">, </span><span class="s1">data.astype(</span><span class="s4">'F'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=skip_cmplx))</span>

        <span class="s3"># Random hermitian complex-valued</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">data = np.random.rand(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s1">) + </span><span class="s5">1j </span><span class="s1">* np.random.rand(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">data = data + data.T.conj()</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-cmplx-herm&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers + real_solvers))</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-cmplx-herm-F&quot;</span><span class="s2">, </span><span class="s1">data.astype(</span><span class="s4">'F'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers + real_solvers))</span>

        <span class="s3"># Random pos-def hermitian complex-valued</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">data = np.random.rand(</span><span class="s5">9</span><span class="s2">, </span><span class="s5">9</span><span class="s1">) + </span><span class="s5">1j </span><span class="s1">* np.random.rand(</span><span class="s5">9</span><span class="s2">, </span><span class="s5">9</span><span class="s1">)</span>
        <span class="s1">data = np.dot(data.conj()</span><span class="s2">, </span><span class="s1">data.T)</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-cmplx-sym-pd&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">skip=real_solvers))</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;rand-cmplx-sym-pd-F&quot;</span><span class="s2">, </span><span class="s1">data.astype(</span><span class="s4">'F'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=real_solvers))</span>

        <span class="s3"># Non-symmetric and Positive Definite</span>
        <span class="s3">#</span>
        <span class="s3"># cgs, qmr, bicg and tfqmr fail to converge on this one</span>
        <span class="s3">#   -- algorithmic limitation apparently</span>
        <span class="s1">data = ones((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">data[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:] = </span><span class="s5">2</span>
        <span class="s1">data[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = -</span><span class="s5">1</span>
        <span class="s1">A = spdiags(data</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s1">)</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;nonsymposdef&quot;</span><span class="s2">, </span><span class="s1">A</span><span class="s2">,</span>
                               <span class="s1">skip=sym_solvers + [cgs</span><span class="s2">, </span><span class="s1">qmr</span><span class="s2">, </span><span class="s1">bicg</span><span class="s2">, </span><span class="s1">tfqmr]))</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;nonsymposdef-F&quot;</span><span class="s2">, </span><span class="s1">A.astype(</span><span class="s4">'F'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">skip=sym_solvers + [cgs</span><span class="s2">, </span><span class="s1">qmr</span><span class="s2">, </span><span class="s1">bicg</span><span class="s2">, </span><span class="s1">tfqmr]))</span>

        <span class="s3"># Symmetric, non-pd, hitting cgs/bicg/bicgstab/qmr/tfqmr breakdown</span>
        <span class="s1">A = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">b = np.array([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s2">assert </span><span class="s1">(A == A.T).all()</span>
        <span class="s1">self.cases.append(Case(</span><span class="s4">&quot;sym-nonpd&quot;</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                               <span class="s1">skip=posdef_solvers</span><span class="s2">,</span>
                               <span class="s1">nonconvergence=[cgs</span><span class="s2">, </span><span class="s1">bicg</span><span class="s2">, </span><span class="s1">bicgstab</span><span class="s2">, </span><span class="s1">qmr</span><span class="s2">, </span><span class="s1">tfqmr]</span>
                               <span class="s1">)</span>
                          <span class="s1">)</span>


<span class="s1">cases = IterativeParams().cases</span>
<span class="s1">@pytest.fixture(params=cases</span><span class="s2">, </span><span class="s1">ids=[x.name </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">cases]</span><span class="s2">, </span><span class="s1">scope=</span><span class="s4">&quot;session&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">case(request):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fixture for all cases in IterativeParams 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s2">def </span><span class="s1">check_maxiter(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s1">A = case.A</span>
    <span class="s1">tol = </span><span class="s5">1e-12</span>

    <span class="s1">b = case.b</span>
    <span class="s1">x0 = </span><span class="s5">0 </span><span class="s1">* b</span>

    <span class="s1">residuals = []</span>

    <span class="s2">def </span><span class="s1">callback(x):</span>
        <span class="s1">residuals.append(norm(b - case.A * x))</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0=x0</span><span class="s2">, </span><span class="s1">tol=tol</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">callback=callback)</span>

    <span class="s2">assert </span><span class="s1">len(residuals) == </span><span class="s5">1</span>
    <span class="s2">assert </span><span class="s1">info == </span><span class="s5">1</span>


<span class="s2">def </span><span class="s1">test_maxiter(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s2">if </span><span class="s1">solver </span><span class="s2">in </span><span class="s1">case.skip + case.nonconvergence:</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;unsupported combination&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
        <span class="s1">check_maxiter(solver</span><span class="s2">, </span><span class="s1">case)</span>


<span class="s2">def </span><span class="s1">assert_normclose(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-8</span><span class="s1">):</span>
    <span class="s1">residual = norm(a - b)</span>
    <span class="s1">tolerance = tol * norm(b)</span>
    <span class="s2">assert </span><span class="s1">residual &lt; tolerance</span>


<span class="s2">def </span><span class="s1">check_convergence(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s1">A = case.A</span>

    <span class="s2">if </span><span class="s1">A.dtype.char </span><span class="s2">in </span><span class="s4">&quot;dD&quot;</span><span class="s1">:</span>
        <span class="s1">tol = </span><span class="s5">1e-8</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">tol = </span><span class="s5">1e-2</span>

    <span class="s1">b = case.b</span>
    <span class="s1">x0 = </span><span class="s5">0 </span><span class="s1">* b</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0=x0</span><span class="s2">, </span><span class="s1">tol=tol)</span>

    <span class="s1">assert_array_equal(x0</span><span class="s2">, </span><span class="s5">0 </span><span class="s1">* b)  </span><span class="s3"># ensure that x0 is not overwritten</span>
    <span class="s2">if </span><span class="s1">solver </span><span class="s2">not in </span><span class="s1">case.nonconvergence:</span>
        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
        <span class="s1">assert_normclose(A @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=tol)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">info != </span><span class="s5">0</span>
        <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - b) &lt;= np.linalg.norm(b)</span>


<span class="s2">def </span><span class="s1">test_convergence(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s2">if </span><span class="s1">solver </span><span class="s2">in </span><span class="s1">case.skip:</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;unsupported combination&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
        <span class="s1">check_convergence(solver</span><span class="s2">, </span><span class="s1">case)</span>


<span class="s2">def </span><span class="s1">check_precond_dummy(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s1">tol = </span><span class="s5">1e-8</span>

    <span class="s2">def </span><span class="s1">identity(b</span><span class="s2">, </span><span class="s1">which=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;trivial preconditioner&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">b</span>

    <span class="s1">A = case.A</span>

    <span class="s1">M</span><span class="s2">, </span><span class="s1">N = A.shape</span>
    <span class="s3"># Ensure the diagonal elements of A are non-zero before calculating</span>
    <span class="s3"># 1.0/A.diagonal()</span>
    <span class="s1">diagOfA = A.diagonal()</span>
    <span class="s2">if </span><span class="s1">np.count_nonzero(diagOfA) == len(diagOfA):</span>
        <span class="s1">spdiags([</span><span class="s5">1.0 </span><span class="s1">/ diagOfA]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">N)</span>

    <span class="s1">b = case.b</span>
    <span class="s1">x0 = </span><span class="s5">0 </span><span class="s1">* b</span>

    <span class="s1">precond = LinearOperator(A.shape</span><span class="s2">, </span><span class="s1">identity</span><span class="s2">, </span><span class="s1">rmatvec=identity)</span>

    <span class="s2">if </span><span class="s1">solver </span><span class="s2">is </span><span class="s1">qmr:</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">M1=precond</span><span class="s2">, </span><span class="s1">M2=precond</span><span class="s2">, </span><span class="s1">x0=x0</span><span class="s2">, </span><span class="s1">tol=tol)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">M=precond</span><span class="s2">, </span><span class="s1">x0=x0</span><span class="s2">, </span><span class="s1">tol=tol)</span>
    <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
    <span class="s1">assert_normclose(A @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol)</span>

    <span class="s1">A = aslinearoperator(A)</span>
    <span class="s1">A.psolve = identity</span>
    <span class="s1">A.rpsolve = identity</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0=x0</span><span class="s2">, </span><span class="s1">tol=tol)</span>
    <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
    <span class="s1">assert_normclose(A @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=tol)</span>


<span class="s2">def </span><span class="s1">test_precond_dummy(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s2">if </span><span class="s1">solver </span><span class="s2">in </span><span class="s1">case.skip + case.nonconvergence:</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;unsupported combination&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
        <span class="s1">check_precond_dummy(solver</span><span class="s2">, </span><span class="s1">case)</span>


<span class="s2">def </span><span class="s1">check_precond_inverse(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s1">tol = </span><span class="s5">1e-8</span>

    <span class="s2">def </span><span class="s1">inverse(b</span><span class="s2">, </span><span class="s1">which=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;inverse preconditioner&quot;&quot;&quot;</span>
        <span class="s1">A = case.A</span>
        <span class="s2">if not </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">A = A.toarray()</span>
        <span class="s2">return </span><span class="s1">np.linalg.solve(A</span><span class="s2">, </span><span class="s1">b)</span>

    <span class="s2">def </span><span class="s1">rinverse(b</span><span class="s2">, </span><span class="s1">which=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;inverse preconditioner&quot;&quot;&quot;</span>
        <span class="s1">A = case.A</span>
        <span class="s2">if not </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">A = A.toarray()</span>
        <span class="s2">return </span><span class="s1">np.linalg.solve(A.T</span><span class="s2">, </span><span class="s1">b)</span>

    <span class="s1">matvec_count = [</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">matvec(b):</span>
        <span class="s1">matvec_count[</span><span class="s5">0</span><span class="s1">] += </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">case.A @ b</span>

    <span class="s2">def </span><span class="s1">rmatvec(b):</span>
        <span class="s1">matvec_count[</span><span class="s5">0</span><span class="s1">] += </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">case.A.T @ b</span>

    <span class="s1">b = case.b</span>
    <span class="s1">x0 = </span><span class="s5">0 </span><span class="s1">* b</span>

    <span class="s1">A = LinearOperator(case.A.shape</span><span class="s2">, </span><span class="s1">matvec</span><span class="s2">, </span><span class="s1">rmatvec=rmatvec)</span>
    <span class="s1">precond = LinearOperator(case.A.shape</span><span class="s2">, </span><span class="s1">inverse</span><span class="s2">, </span><span class="s1">rmatvec=rinverse)</span>

    <span class="s3"># Solve with preconditioner</span>
    <span class="s1">matvec_count = [</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">M=precond</span><span class="s2">, </span><span class="s1">x0=x0</span><span class="s2">, </span><span class="s1">tol=tol)</span>

    <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
    <span class="s1">assert_normclose(case.A @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol)</span>

    <span class="s3"># Solution should be nearly instant</span>
    <span class="s2">assert </span><span class="s1">matvec_count[</span><span class="s5">0</span><span class="s1">] &lt;= </span><span class="s5">3</span>


<span class="s2">def </span><span class="s1">test_precond_inverse(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s2">if </span><span class="s1">(solver </span><span class="s2">in </span><span class="s1">case.skip </span><span class="s2">or </span><span class="s1">solver </span><span class="s2">is </span><span class="s1">qmr</span>
            <span class="s2">or </span><span class="s1">case.name </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;poisson1d&quot;</span><span class="s2">, </span><span class="s4">&quot;poisson2d&quot;</span><span class="s1">)):</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;unsupported combination&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
        <span class="s1">check_precond_inverse(solver</span><span class="s2">, </span><span class="s1">case)</span>


<span class="s2">def </span><span class="s1">test_reentrancy(solver):</span>
    <span class="s1">reentrant = [lgmres</span><span class="s2">, </span><span class="s1">minres</span><span class="s2">, </span><span class="s1">gcrotmk</span><span class="s2">, </span><span class="s1">tfqmr]</span>
    <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
        <span class="s1">_check_reentrancy(solver</span><span class="s2">, </span><span class="s1">solver </span><span class="s2">in </span><span class="s1">reentrant)</span>


<span class="s2">def </span><span class="s1">_check_reentrancy(solver</span><span class="s2">, </span><span class="s1">is_reentrant):</span>
    <span class="s2">def </span><span class="s1">matvec(x):</span>
        <span class="s1">A = np.array([[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3.0</span><span class="s1">]])</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
        <span class="s2">return </span><span class="s1">y</span>
    <span class="s1">b = np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">/ </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">/ </span><span class="s5">3</span><span class="s1">])</span>
    <span class="s1">op = LinearOperator((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">matvec=matvec</span><span class="s2">, </span><span class="s1">rmatvec=matvec</span><span class="s2">,</span>
                        <span class="s1">dtype=b.dtype)</span>

    <span class="s2">if not </span><span class="s1">is_reentrant:</span>
        <span class="s1">pytest.raises(RuntimeError</span><span class="s2">, </span><span class="s1">solver</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">info = solver(op</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_atol(solver):</span>
    <span class="s3"># TODO: minres / tfqmr. It didn't historically use absolute tolerances, so</span>
    <span class="s3"># fixing it is less urgent.</span>
    <span class="s2">if </span><span class="s1">solver </span><span class="s2">in </span><span class="s1">(minres</span><span class="s2">, </span><span class="s1">tfqmr):</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;TODO&quot;</span><span class="s1">)</span>

    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">A = np.random.rand(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">A = A @ A.T + </span><span class="s5">10 </span><span class="s1">* np.eye(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">b = </span><span class="s5">1e3 </span><span class="s1">* np.random.rand(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">b_norm = np.linalg.norm(b)</span>

    <span class="s1">tols = np.r_[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.logspace(np.log10(</span><span class="s5">1e-10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.log10(</span><span class="s5">1e2</span><span class="s1">)</span><span class="s2">, </span><span class="s5">7</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.inf]</span>

    <span class="s3"># Check effect of badly scaled preconditioners</span>
    <span class="s1">M0 = np.random.randn(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">M0 = M0 @ M0.T</span>
    <span class="s1">Ms = [</span><span class="s2">None, </span><span class="s5">1e-6 </span><span class="s1">* M0</span><span class="s2">, </span><span class="s5">1e6 </span><span class="s1">* M0]</span>

    <span class="s2">for </span><span class="s1">M</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">atol </span><span class="s2">in </span><span class="s1">itertools.product(Ms</span><span class="s2">, </span><span class="s1">tols</span><span class="s2">, </span><span class="s1">tols):</span>
        <span class="s2">if </span><span class="s1">tol == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">atol == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">continue</span>

        <span class="s2">if </span><span class="s1">solver </span><span class="s2">is </span><span class="s1">qmr:</span>
            <span class="s2">if </span><span class="s1">M </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">M = aslinearoperator(M)</span>
                <span class="s1">M2 = aslinearoperator(np.eye(</span><span class="s5">10</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">M2 = </span><span class="s2">None</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">M1=M</span><span class="s2">, </span><span class="s1">M2=M2</span><span class="s2">, </span><span class="s1">tol=tol</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">M=M</span><span class="s2">, </span><span class="s1">tol=tol</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
        <span class="s1">residual = A @ x - b</span>
        <span class="s1">err = np.linalg.norm(residual)</span>
        <span class="s1">atol2 = tol * b_norm</span>
        <span class="s3"># Added 1.00025 fudge factor because of `err` exceeding `atol` just</span>
        <span class="s3"># very slightly on s390x (see gh-17839)</span>
        <span class="s2">assert </span><span class="s1">err &lt;= </span><span class="s5">1.00025 </span><span class="s1">* max(atol</span><span class="s2">, </span><span class="s1">atol2)</span>


<span class="s2">def </span><span class="s1">test_zero_rhs(solver):</span>
    <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">A = np.random.rand(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">A = A @ A.T + </span><span class="s5">10 </span><span class="s1">* np.eye(</span><span class="s5">10</span><span class="s1">)</span>

    <span class="s1">b = np.zeros(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">tols = np.r_[np.logspace(np.log10(</span><span class="s5">1e-10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.log10(</span><span class="s5">1e2</span><span class="s1">)</span><span class="s2">, </span><span class="s5">7</span><span class="s1">)]</span>

    <span class="s2">for </span><span class="s1">tol </span><span class="s2">in </span><span class="s1">tols:</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=tol)</span>
            <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
            <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-15</span><span class="s1">)</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=tol</span><span class="s2">, </span><span class="s1">x0=ones(</span><span class="s5">10</span><span class="s1">))</span>
            <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
            <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">atol=tol)</span>

            <span class="s2">if </span><span class="s1">solver </span><span class="s2">is not </span><span class="s1">minres:</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=tol</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">x0=ones(</span><span class="s5">10</span><span class="s1">))</span>
                <span class="s2">if </span><span class="s1">info == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

                <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=tol</span><span class="s2">, </span><span class="s1">atol=tol)</span>
                <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
                <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-300</span><span class="s1">)</span>

                <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=tol</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
                <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-300</span><span class="s1">)</span>


<span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">&quot;see gh-18697&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_maxiter_worsening(solver):</span>
    <span class="s2">if </span><span class="s1">solver </span><span class="s2">not in </span><span class="s1">(gmres</span><span class="s2">, </span><span class="s1">lgmres):</span>
        <span class="s3"># these were skipped from the very beginning, see gh-9201; gh-14160</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;unsupported combination&quot;</span><span class="s1">)</span>
    <span class="s3"># Check error does not grow (boundlessly) with increasing maxiter.</span>
    <span class="s3"># This can occur due to the solvers hitting close to breakdown,</span>
    <span class="s3"># which they should detect and halt as necessary.</span>
    <span class="s3"># cf. gh-9100</span>
    <span class="s2">if </span><span class="s1">(solver </span><span class="s2">is </span><span class="s1">gmres </span><span class="s2">and </span><span class="s1">platform.machine() == </span><span class="s4">'aarch64'</span>
            <span class="s2">and </span><span class="s1">sys.version_info[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">9</span><span class="s1">):</span>
        <span class="s1">pytest.xfail(reason=</span><span class="s4">&quot;gh-13019&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">(solver </span><span class="s2">is </span><span class="s1">lgmres </span><span class="s2">and</span>
            <span class="s1">platform.machine() </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">'x86_64' 'x86'</span><span class="s2">, </span><span class="s4">'aarch64'</span><span class="s2">, </span><span class="s4">'arm64'</span><span class="s1">]):</span>
        <span class="s3"># see gh-17839</span>
        <span class="s1">pytest.xfail(reason=</span><span class="s4">&quot;fails on at least ppc64le, ppc64 and riscv64&quot;</span><span class="s1">)</span>

    <span class="s3"># Singular matrix, rhs numerically not in range</span>
    <span class="s1">A = np.array([[-</span><span class="s5">0.1112795288033378</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.16127952880333685</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.13627952880333782 </span><span class="s1">+ </span><span class="s5">6.283185307179586j</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.13627952880333782 </span><span class="s1">- </span><span class="s5">6.283185307179586j</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">0.1112795288033368</span><span class="s2">, </span><span class="s5">0j</span><span class="s2">, </span><span class="s5">0j</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.16127952880333785</span><span class="s1">]])</span>
    <span class="s1">v = np.ones(</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">best_error = np.inf</span>
    <span class="s1">tol = </span><span class="s5">7 </span><span class="s2">if </span><span class="s1">platform.machine() == </span><span class="s4">'aarch64' </span><span class="s2">else </span><span class="s5">5</span>

    <span class="s2">for </span><span class="s1">maxiter </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">20</span><span class="s1">):</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">maxiter=maxiter</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">info == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - v) &lt;= </span><span class="s5">1e-8 </span><span class="s1">* np.linalg.norm(v)</span>

        <span class="s1">error = np.linalg.norm(A @ x - v)</span>
        <span class="s1">best_error = min(best_error</span><span class="s2">, </span><span class="s1">error)</span>

        <span class="s3"># Check with slack</span>
        <span class="s2">assert </span><span class="s1">error &lt;= tol * best_error</span>


<span class="s2">def </span><span class="s1">test_x0_working(solver):</span>
    <span class="s3"># Easy problem</span>
    <span class="s1">np.random.seed(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">10</span>
    <span class="s1">A = np.random.rand(n</span><span class="s2">, </span><span class="s1">n)</span>
    <span class="s1">A = A @ A.T</span>
    <span class="s1">b = np.random.rand(n)</span>
    <span class="s1">x0 = np.random.rand(n)</span>

    <span class="s2">if </span><span class="s1">solver </span><span class="s2">is </span><span class="s1">minres:</span>
        <span class="s1">kw = dict(tol=</span><span class="s5">1e-6</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">kw = dict(atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">**kw)</span>
    <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
    <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - b) &lt;= </span><span class="s5">1e-6 </span><span class="s1">* np.linalg.norm(b)</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0=x0</span><span class="s2">, </span><span class="s1">**kw)</span>
    <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
    <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - b) &lt;= </span><span class="s5">2e-6 </span><span class="s1">* np.linalg.norm(b)</span>


<span class="s2">def </span><span class="s1">test_x0_equals_Mb(solver</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s2">if </span><span class="s1">solver </span><span class="s2">in </span><span class="s1">case.skip </span><span class="s2">or </span><span class="s1">solver </span><span class="s2">is </span><span class="s1">tfqmr:</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;unsupported combination&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
        <span class="s1">A = case.A</span>
        <span class="s1">b = case.b</span>
        <span class="s1">x0 = </span><span class="s4">'Mb'</span>
        <span class="s1">tol = </span><span class="s5">1e-8</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = solver(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0=x0</span><span class="s2">, </span><span class="s1">tol=tol)</span>

        <span class="s1">assert_array_equal(x0</span><span class="s2">, </span><span class="s4">'Mb'</span><span class="s1">)  </span><span class="s3"># ensure that x0 is not overwritten</span>
        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
        <span class="s1">assert_normclose(A @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=tol)</span>


<span class="s2">def </span><span class="s1">test_show(case</span><span class="s2">, </span><span class="s1">capsys):</span>
    <span class="s2">def </span><span class="s1">cb(x):</span>
        <span class="s2">pass</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">info = tfqmr(case.A</span><span class="s2">, </span><span class="s1">case.b</span><span class="s2">, </span><span class="s1">callback=cb</span><span class="s2">, </span><span class="s1">show=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">out</span><span class="s2">, </span><span class="s1">err = capsys.readouterr()</span>

    <span class="s2">if </span><span class="s1">case.name == </span><span class="s4">&quot;sym-nonpd&quot;</span><span class="s1">:</span>
        <span class="s3"># no logs for some reason</span>
        <span class="s1">exp = </span><span class="s4">&quot;&quot;</span>
    <span class="s2">elif </span><span class="s1">case.name </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;nonsymposdef&quot;</span><span class="s2">, </span><span class="s4">&quot;nonsymposdef-F&quot;</span><span class="s1">):</span>
        <span class="s3"># Asymmetric and Positive Definite</span>
        <span class="s1">exp = </span><span class="s4">&quot;TFQMR: Linear solve not converged due to reach MAXIT iterations&quot;</span>
    <span class="s2">else</span><span class="s1">:  </span><span class="s3"># all other cases</span>
        <span class="s1">exp = </span><span class="s4">&quot;TFQMR: Linear solve converged due to reach TOL iterations&quot;</span>

    <span class="s2">assert </span><span class="s1">out.startswith(exp)</span>
    <span class="s2">assert </span><span class="s1">err == </span><span class="s4">&quot;&quot;</span>


<span class="s3"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">TestQMR:</span>
    <span class="s2">def </span><span class="s1">test_leftright_precond(self):</span>
        <span class="s0">&quot;&quot;&quot;Check that QMR works with left and right preconditioners&quot;&quot;&quot;</span>

        <span class="s2">from </span><span class="s1">scipy.sparse.linalg._dsolve </span><span class="s2">import </span><span class="s1">splu</span>
        <span class="s2">from </span><span class="s1">scipy.sparse.linalg._interface </span><span class="s2">import </span><span class="s1">LinearOperator</span>

        <span class="s1">n = </span><span class="s5">100</span>

        <span class="s1">dat = ones(n)</span>
        <span class="s1">A = spdiags([-</span><span class="s5">2 </span><span class="s1">* dat</span><span class="s2">, </span><span class="s5">4 </span><span class="s1">* dat</span><span class="s2">, </span><span class="s1">-dat]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">b = arange(n</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">'d'</span><span class="s1">)</span>

        <span class="s1">L = spdiags([-dat / </span><span class="s5">2</span><span class="s2">, </span><span class="s1">dat]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">U = spdiags([</span><span class="s5">4 </span><span class="s1">* dat</span><span class="s2">, </span><span class="s1">-dat]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">n)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(SparseEfficiencyWarning</span><span class="s2">,</span>
                       <span class="s4">&quot;splu converted its input to CSC format&quot;</span><span class="s1">)</span>
            <span class="s1">L_solver = splu(L)</span>
            <span class="s1">U_solver = splu(U)</span>

        <span class="s2">def </span><span class="s1">L_solve(b):</span>
            <span class="s2">return </span><span class="s1">L_solver.solve(b)</span>

        <span class="s2">def </span><span class="s1">U_solve(b):</span>
            <span class="s2">return </span><span class="s1">U_solver.solve(b)</span>

        <span class="s2">def </span><span class="s1">LT_solve(b):</span>
            <span class="s2">return </span><span class="s1">L_solver.solve(b</span><span class="s2">, </span><span class="s4">'T'</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">UT_solve(b):</span>
            <span class="s2">return </span><span class="s1">U_solver.solve(b</span><span class="s2">, </span><span class="s4">'T'</span><span class="s1">)</span>

        <span class="s1">M1 = LinearOperator((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">matvec=L_solve</span><span class="s2">, </span><span class="s1">rmatvec=LT_solve)</span>
        <span class="s1">M2 = LinearOperator((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">matvec=U_solve</span><span class="s2">, </span><span class="s1">rmatvec=UT_solve)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = qmr(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">15</span><span class="s2">, </span><span class="s1">M1=M1</span><span class="s2">, </span><span class="s1">M2=M2)</span>

        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
        <span class="s1">assert_normclose(A @ x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-8</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestGMRES:</span>
    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">A = np.vander(np.arange(</span><span class="s5">10</span><span class="s1">) + </span><span class="s5">1</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">b = np.zeros(</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">b[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
            <span class="s1">x_gm</span><span class="s2">, </span><span class="s1">err = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">restart=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">assert_allclose(x_gm[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0.359</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_callback(self):</span>

        <span class="s2">def </span><span class="s1">store_residual(r</span><span class="s2">, </span><span class="s1">rvec):</span>
            <span class="s1">rvec[rvec.nonzero()[</span><span class="s5">0</span><span class="s1">].max() + </span><span class="s5">1</span><span class="s1">] = r</span>

        <span class="s3"># Define, A,b</span>
        <span class="s1">A = csr_matrix(array([[-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">]]))</span>
        <span class="s1">b = ones((A.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">maxiter = </span><span class="s5">1</span>
        <span class="s1">rvec = zeros(maxiter + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">rvec[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1.0</span>

        <span class="s2">def </span><span class="s1">callback(r):</span>
            <span class="s2">return </span><span class="s1">store_residual(r</span><span class="s2">, </span><span class="s1">rvec)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">flag = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0=zeros(A.shape[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-16</span><span class="s2">,</span>
                            <span class="s1">maxiter=maxiter</span><span class="s2">, </span><span class="s1">callback=callback)</span>

        <span class="s3"># Expected output from SciPy 1.0.0</span>
        <span class="s1">assert_allclose(rvec</span><span class="s2">, </span><span class="s1">array([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.81649658092772603</span><span class="s1">])</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>

        <span class="s3"># Test preconditioned callback</span>
        <span class="s1">M = </span><span class="s5">1e-3 </span><span class="s1">* np.eye(A.shape[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">rvec = zeros(maxiter + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">rvec[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1.0</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">flag = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">M=M</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-16</span><span class="s2">, </span><span class="s1">maxiter=maxiter</span><span class="s2">,</span>
                            <span class="s1">callback=callback)</span>

        <span class="s3"># Expected output from SciPy 1.0.0</span>
        <span class="s3"># (callback has preconditioned residual!)</span>
        <span class="s1">assert_allclose(rvec</span><span class="s2">, </span><span class="s1">array([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1e-3 </span><span class="s1">* </span><span class="s5">0.81649658092772603</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_abi(self):</span>
        <span class="s3"># Check we don't segfault on gmres with complex argument</span>
        <span class="s1">A = eye(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">b = ones(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
            <span class="s1">r_x</span><span class="s2">, </span><span class="s1">r_info = gmres(A</span><span class="s2">, </span><span class="s1">b)</span>
            <span class="s1">r_x = r_x.astype(complex)</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A.astype(complex)</span><span class="s2">, </span><span class="s1">b.astype(complex))</span>

        <span class="s2">assert </span><span class="s1">iscomplexobj(x)</span>
        <span class="s1">assert_allclose(r_x</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">assert </span><span class="s1">r_info == info</span>

    <span class="s2">def </span><span class="s1">test_atol_legacy(self):</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>

            <span class="s3"># Check the strange legacy behavior: the tolerance is interpreted</span>
            <span class="s3"># as atol, but only for the initial residual</span>
            <span class="s1">A = eye(</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">b = </span><span class="s5">1e-6 </span><span class="s1">* ones(</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-5</span><span class="s1">)</span>
            <span class="s1">assert_array_equal(x</span><span class="s2">, </span><span class="s1">np.zeros(</span><span class="s5">2</span><span class="s1">))</span>

            <span class="s1">A = eye(</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">b = ones(</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-5</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - b) &lt;= </span><span class="s5">1e-5 </span><span class="s1">* np.linalg.norm(b)</span>
            <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>

            <span class="s1">rndm = np.random.RandomState(</span><span class="s5">12345</span><span class="s1">)</span>
            <span class="s1">A = rndm.rand(</span><span class="s5">30</span><span class="s2">, </span><span class="s5">30</span><span class="s1">)</span>
            <span class="s1">b = </span><span class="s5">1e-6 </span><span class="s1">* ones(</span><span class="s5">30</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-7</span><span class="s2">, </span><span class="s1">restart=</span><span class="s5">20</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - b) &gt; </span><span class="s5">1e-7</span>

        <span class="s1">A = eye(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">b = </span><span class="s5">1e-10 </span><span class="s1">* ones(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - b) &lt;= </span><span class="s5">1e-8 </span><span class="s1">* np.linalg.norm(b)</span>

    <span class="s2">def </span><span class="s1">test_defective_precond_breakdown(self):</span>
        <span class="s3"># Breakdown due to defective preconditioner</span>
        <span class="s1">M = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">M[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = </span><span class="s5">0</span>

        <span class="s1">b = np.array([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">x = np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">A = np.diag([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">])</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0=x</span><span class="s2">, </span><span class="s1">M=M</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-15</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># Should not return nans, nor terminate with false success</span>
        <span class="s2">assert not </span><span class="s1">np.isnan(x).any()</span>
        <span class="s2">if </span><span class="s1">info == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - b) &lt;= </span><span class="s5">1e-15 </span><span class="s1">* np.linalg.norm(b)</span>

        <span class="s3"># The solution should be OK outside null space of M</span>
        <span class="s1">assert_allclose(M @ (A @ x)</span><span class="s2">, </span><span class="s1">M @ b)</span>

    <span class="s2">def </span><span class="s1">test_defective_matrix_breakdown(self):</span>
        <span class="s3"># Breakdown due to defective matrix</span>
        <span class="s1">A = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>
        <span class="s1">b = np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># Should not return nans, nor terminate with false success</span>
        <span class="s2">assert not </span><span class="s1">np.isnan(x).any()</span>
        <span class="s2">if </span><span class="s1">info == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">np.linalg.norm(A @ x - b) &lt;= </span><span class="s5">1e-8 </span><span class="s1">* np.linalg.norm(b)</span>

        <span class="s3"># The solution should be OK outside null space of A</span>
        <span class="s1">assert_allclose(A @ (A @ x)</span><span class="s2">, </span><span class="s1">A @ b)</span>

    <span class="s2">def </span><span class="s1">test_callback_type(self):</span>
        <span class="s3"># The legacy callback type changes meaning of 'maxiter'</span>
        <span class="s1">np.random.seed(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">A = np.random.rand(</span><span class="s5">20</span><span class="s2">, </span><span class="s5">20</span><span class="s1">)</span>
        <span class="s1">b = np.random.rand(</span><span class="s5">20</span><span class="s1">)</span>

        <span class="s1">cb_count = [</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">pr_norm_cb(r):</span>
            <span class="s1">cb_count[</span><span class="s5">0</span><span class="s1">] += </span><span class="s5">1</span>
            <span class="s2">assert </span><span class="s1">isinstance(r</span><span class="s2">, </span><span class="s1">float)</span>

        <span class="s2">def </span><span class="s1">x_cb(x):</span>
            <span class="s1">cb_count[</span><span class="s5">0</span><span class="s1">] += </span><span class="s5">1</span>
            <span class="s2">assert </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ndarray)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(DeprecationWarning</span><span class="s2">, </span><span class="s4">&quot;.*called without specifying.*&quot;</span><span class="s1">)</span>
            <span class="s3"># 2 iterations is not enough to solve the problem</span>
            <span class="s1">cb_count = [</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">callback=pr_norm_cb</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">2</span><span class="s2">,</span>
                            <span class="s1">restart=</span><span class="s5">50</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">info == </span><span class="s5">2</span>
            <span class="s2">assert </span><span class="s1">cb_count[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">2</span>

        <span class="s3"># With `callback_type` specified, no warning should be raised</span>
        <span class="s1">cb_count = [</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">callback=pr_norm_cb</span><span class="s2">,</span>
                        <span class="s1">maxiter=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">restart=</span><span class="s5">50</span><span class="s2">, </span><span class="s1">callback_type=</span><span class="s4">'legacy'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">2</span>
        <span class="s2">assert </span><span class="s1">cb_count[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">2</span>

        <span class="s3"># 2 restart cycles is enough to solve the problem</span>
        <span class="s1">cb_count = [</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">callback=pr_norm_cb</span><span class="s2">,</span>
                        <span class="s1">maxiter=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">restart=</span><span class="s5">50</span><span class="s2">, </span><span class="s1">callback_type=</span><span class="s4">'pr_norm'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
        <span class="s2">assert </span><span class="s1">cb_count[</span><span class="s5">0</span><span class="s1">] &gt; </span><span class="s5">2</span>

        <span class="s3"># 2 restart cycles is enough to solve the problem</span>
        <span class="s1">cb_count = [</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">callback=x_cb</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">2</span><span class="s2">,</span>
                        <span class="s1">restart=</span><span class="s5">50</span><span class="s2">, </span><span class="s1">callback_type=</span><span class="s4">'x'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">0</span>
        <span class="s2">assert </span><span class="s1">cb_count[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">2</span>

    <span class="s2">def </span><span class="s1">test_callback_x_monotonic(self):</span>
        <span class="s3"># Check that callback_type='x' gives monotonic norm decrease</span>
        <span class="s1">np.random.seed(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">A = np.random.rand(</span><span class="s5">20</span><span class="s2">, </span><span class="s5">20</span><span class="s1">) + np.eye(</span><span class="s5">20</span><span class="s1">)</span>
        <span class="s1">b = np.random.rand(</span><span class="s5">20</span><span class="s1">)</span>

        <span class="s1">prev_r = [np.inf]</span>
        <span class="s1">count = [</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">x_cb(x):</span>
            <span class="s1">r = np.linalg.norm(A @ x - b)</span>
            <span class="s2">assert </span><span class="s1">r &lt;= prev_r[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">prev_r[</span><span class="s5">0</span><span class="s1">] = r</span>
            <span class="s1">count[</span><span class="s5">0</span><span class="s1">] += </span><span class="s5">1</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">info = gmres(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">callback=x_cb</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">20</span><span class="s2">, </span><span class="s1">restart=</span><span class="s5">10</span><span class="s2">,</span>
                        <span class="s1">callback_type=</span><span class="s4">'x'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">info == </span><span class="s5">20</span>
        <span class="s2">assert </span><span class="s1">count[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">21</span>
        <span class="s1">x_cb(x)</span>

    <span class="s2">def </span><span class="s1">test_restrt_dep(self):</span>
        <span class="s2">with </span><span class="s1">pytest.warns(</span>
            <span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">match=</span><span class="s4">&quot;'gmres' keyword argument 'restrt'&quot;</span>
        <span class="s1">):</span>
            <span class="s1">gmres(np.array([</span><span class="s5">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s5">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">restrt=</span><span class="s5">10</span><span class="s1">)</span>
</pre>
</body>
</html>