<html>
<head>
<title>test_bsplines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_bsplines.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">scipy.interpolate </span><span class="s0">import </span><span class="s1">(BSpline</span><span class="s0">, </span><span class="s1">BPoly</span><span class="s0">, </span><span class="s1">PPoly</span><span class="s0">, </span><span class="s1">make_interp_spline</span><span class="s0">,</span>
                               <span class="s1">make_lsq_spline</span><span class="s0">, </span><span class="s1">_bspl</span><span class="s0">, </span><span class="s1">splev</span><span class="s0">, </span><span class="s1">splrep</span><span class="s0">, </span><span class="s1">splprep</span><span class="s0">,</span>
                               <span class="s1">splder</span><span class="s0">, </span><span class="s1">splantider</span><span class="s0">, </span><span class="s1">sproot</span><span class="s0">, </span><span class="s1">splint</span><span class="s0">, </span><span class="s1">insert</span><span class="s0">,</span>
                               <span class="s1">CubicSpline</span><span class="s0">, </span><span class="s1">make_smoothing_spline)</span>
<span class="s0">import </span><span class="s1">scipy.linalg </span><span class="s0">as </span><span class="s1">sl</span>

<span class="s0">from </span><span class="s1">scipy.interpolate._bsplines </span><span class="s0">import </span><span class="s1">(_not_a_knot</span><span class="s0">, </span><span class="s1">_augknt</span><span class="s0">,</span>
                                        <span class="s1">_woodbury_algorithm</span><span class="s0">, </span><span class="s1">_periodic_knots</span><span class="s0">,</span>
                                         <span class="s1">_make_interp_per_full_matr)</span>
<span class="s0">import </span><span class="s1">scipy.interpolate._fitpack_impl </span><span class="s0">as </span><span class="s1">_impl</span>
<span class="s0">import </span><span class="s1">os</span>


<span class="s0">class </span><span class="s1">TestBSpline:</span>

    <span class="s0">def </span><span class="s1">test_ctor(self):</span>
        <span class="s2"># knots should be an ordered 1-D array of finite real numbers</span>
        <span class="s1">assert_raises((TypeError</span><span class="s0">, </span><span class="s1">ValueError)</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">,</span>
                <span class="s1">**dict(t=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">, </span><span class="s1">**dict(t=[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">, </span><span class="s1">**dict(t=[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">, </span><span class="s1">**dict(t=[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">, </span><span class="s1">**dict(t=[[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">))</span>

        <span class="s2"># for n+k+1 knots and degree k need at least n coefficients</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">, </span><span class="s1">**dict(t=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">,</span>
                <span class="s1">**dict(t=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">2</span><span class="s1">))</span>

        <span class="s2"># non-integer orders</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">,</span>
                <span class="s1">**dict(t=[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">&quot;cubic&quot;</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">,</span>
                <span class="s1">**dict(t=[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">2.5</span><span class="s1">))</span>

        <span class="s2"># basic interval cannot have measure zero (here: [1..1])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">,</span>
                <span class="s1">**dict(t=[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">2</span><span class="s1">))</span>

        <span class="s2"># tck vs self.tck</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">k = </span><span class="s3">11</span><span class="s0">, </span><span class="s3">3</span>
        <span class="s1">t = np.arange(n+k+</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c = np.random.random(n)</span>
        <span class="s1">b = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">assert_allclose(t</span><span class="s0">, </span><span class="s1">b.t)</span>
        <span class="s1">assert_allclose(c</span><span class="s0">, </span><span class="s1">b.c)</span>
        <span class="s1">assert_equal(k</span><span class="s0">, </span><span class="s1">b.k)</span>

    <span class="s0">def </span><span class="s1">test_tck(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">tck = b.tck</span>

        <span class="s1">assert_allclose(b.t</span><span class="s0">, </span><span class="s1">tck[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.c</span><span class="s0">, </span><span class="s1">tck[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_equal(b.k</span><span class="s0">, </span><span class="s1">tck[</span><span class="s3">2</span><span class="s1">])</span>

        <span class="s2"># b.tck is read-only</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AttributeError):</span>
            <span class="s1">b.tck = </span><span class="s4">'foo'</span>

    <span class="s0">def </span><span class="s1">test_degree_0(self):</span>
        <span class="s1">xx = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>

        <span class="s1">b = BSpline(t=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>

        <span class="s1">b = BSpline(t=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.35</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c=[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">np.where(xx &lt; </span><span class="s3">0.35</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_degree_1(self):</span>
        <span class="s1">t = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">c = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">k = </span><span class="s3">1</span>
        <span class="s1">b = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">x = np.linspace(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">assert_allclose(c[</span><span class="s3">0</span><span class="s1">]*B_012(x) + c[</span><span class="s3">1</span><span class="s1">]*B_012(x-</span><span class="s3">1</span><span class="s1">) + c[</span><span class="s3">2</span><span class="s1">]*B_012(x-</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">b(x)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(splev(x</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k))</span><span class="s0">, </span><span class="s1">b(x)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_bernstein(self):</span>
        <span class="s2"># a special knot vector: Bernstein polynomials</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">t = np.asarray([</span><span class="s3">0</span><span class="s1">]*(k+</span><span class="s3">1</span><span class="s1">) + [</span><span class="s3">1</span><span class="s1">]*(k+</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">c = np.asarray([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">])</span>
        <span class="s1">bp = BPoly(c.reshape(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">bspl = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">xx = np.linspace(-</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bp(xx</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">bspl(xx</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(splev(xx</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k))</span><span class="s0">,</span>
                        <span class="s1">bspl(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rndm_naive_eval(self):</span>
        <span class="s2"># test random coefficient spline *on the base interval*,</span>
        <span class="s2"># t[k] &lt;= x &lt; t[-k-1]</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">xx = np.linspace(t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">y_b = b(xx)</span>

        <span class="s1">y_n = [_naive_eval(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">xx]</span>
        <span class="s1">assert_allclose(y_b</span><span class="s0">, </span><span class="s1">y_n</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s1">y_n2 = [_naive_eval_2(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">xx]</span>
        <span class="s1">assert_allclose(y_b</span><span class="s0">, </span><span class="s1">y_n2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rndm_splev(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">xx = np.linspace(t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">splev(xx</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k))</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rndm_splrep(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">x = np.sort(np.random.random(</span><span class="s3">20</span><span class="s1">))</span>
        <span class="s1">y = np.random.random(</span><span class="s3">20</span><span class="s1">)</span>

        <span class="s1">tck = splrep(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">b = BSpline(*tck)</span>

        <span class="s1">t</span><span class="s0">, </span><span class="s1">k = b.t</span><span class="s0">, </span><span class="s1">b.k</span>
        <span class="s1">xx = np.linspace(t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">splev(xx</span><span class="s0">, </span><span class="s1">tck)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rndm_unity(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">b.c = np.ones_like(b.c)</span>
        <span class="s1">xx = np.linspace(b.t[b.k]</span><span class="s0">, </span><span class="s1">b.t[-b.k-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vectorization(self):</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">k = </span><span class="s3">22</span><span class="s0">, </span><span class="s3">3</span>
        <span class="s1">t = np.sort(np.random.random(n))</span>
        <span class="s1">c = np.random.random(size=(n</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>
        <span class="s1">b = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">tm</span><span class="s0">, </span><span class="s1">tp = t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">xx = tm + (tp - tm) * np.random.random((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">assert_equal(b(xx).shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_len_c(self):</span>
        <span class="s2"># for n+k+1 knots, only first n coefs are used.</span>
        <span class="s2"># and BTW this is consistent with FITPACK</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">k = </span><span class="s3">33</span><span class="s0">, </span><span class="s3">3</span>
        <span class="s1">t = np.sort(np.random.random(n+k+</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">c = np.random.random(n)</span>

        <span class="s2"># pad coefficients with random garbage</span>
        <span class="s1">c_pad = np.r_[c</span><span class="s0">, </span><span class="s1">np.random.random(k+</span><span class="s3">1</span><span class="s1">)]</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">b_pad = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">BSpline(t</span><span class="s0">, </span><span class="s1">c_pad</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">dt = t[-</span><span class="s3">1</span><span class="s1">] - t[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">xx = np.linspace(t[</span><span class="s3">0</span><span class="s1">] - dt</span><span class="s0">, </span><span class="s1">t[-</span><span class="s3">1</span><span class="s1">] + dt</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">b_pad(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">splev(xx</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k))</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">splev(xx</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c_pad</span><span class="s0">, </span><span class="s1">k))</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_endpoints(self):</span>
        <span class="s2"># base interval is closed</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">tm</span><span class="s0">, </span><span class="s1">tp = t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">extrap </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">assert_allclose(b([tm</span><span class="s0">, </span><span class="s1">tp]</span><span class="s0">, </span><span class="s1">extrap)</span><span class="s0">,</span>
                            <span class="s1">b([tm + </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s1">tp - </span><span class="s3">1e-10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">extrap)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_continuity(self):</span>
        <span class="s2"># assert continuity at internal knots</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">assert_allclose(b(t[k+</span><span class="s3">1</span><span class="s1">:-k-</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1e-10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b(t[k+</span><span class="s3">1</span><span class="s1">:-k-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1e-10</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">atol=</span><span class="s3">1e-9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_extrap(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">dt = t[-</span><span class="s3">1</span><span class="s1">] - t[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">xx = np.linspace(t[k] - dt</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">] + dt</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">mask = (t[k] &lt; xx) &amp; (xx &lt; t[-k-</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s2"># extrap has no effect within the base interval</span>
        <span class="s1">assert_allclose(b(xx[mask]</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">b(xx[mask]</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">False</span><span class="s1">))</span>

        <span class="s2"># extrapolated values agree with FITPACK</span>
        <span class="s1">assert_allclose(b(xx</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">splev(xx</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">ext=</span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_default_extrap(self):</span>
        <span class="s2"># BSpline defaults to extrapolate=True</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">xx = [t[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">t[-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">yy = b(xx)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.all(np.isnan(yy)))</span>

    <span class="s0">def </span><span class="s1">test_periodic_extrap(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">t = np.sort(np.random.random(</span><span class="s3">8</span><span class="s1">))</span>
        <span class="s1">c = np.random.random(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">b = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">n = t.size - (k + </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">dt = t[-</span><span class="s3">1</span><span class="s1">] - t[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">xx = np.linspace(t[k] - dt</span><span class="s0">, </span><span class="s1">t[n] + dt</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">xy = t[k] + (xx - t[k]) % (t[n] - t[k])</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">splev(xy</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)))</span>

        <span class="s2"># Direct check</span>
        <span class="s1">xx = [-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">xy = t[k] + (xx - t[k]) % (t[n] - t[k])</span>
        <span class="s1">assert_equal(b(xx</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s4">'periodic'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b(xy</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_ppoly(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">pp = PPoly.from_spline((t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k))</span>

        <span class="s1">xx = np.linspace(t[k]</span><span class="s0">, </span><span class="s1">t[-k]</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">pp(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_derivative_rndm(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">xx = np.linspace(t[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">t[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">xx = np.r_[xx</span><span class="s0">, </span><span class="s1">t]</span>

        <span class="s0">for </span><span class="s1">der </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k+</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">yd = splev(xx</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">der=der)</span>
            <span class="s1">assert_allclose(yd</span><span class="s0">, </span><span class="s1">b(xx</span><span class="s0">, </span><span class="s1">nu=der)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># higher derivatives all vanish</span>
        <span class="s1">assert_allclose(b(xx</span><span class="s0">, </span><span class="s1">nu=k+</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_derivative_jumps(self):</span>
        <span class="s2"># example from de Boor, Chap IX, example (24)</span>
        <span class="s2"># NB: knots augmented &amp; corresp coefs are zeroed out</span>
        <span class="s2"># in agreement with the convention (29)</span>
        <span class="s1">k = </span><span class="s3">2</span>
        <span class="s1">t = [-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">c = np.r_[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.random.random(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">b = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s2"># b is continuous at x != 6 (triple knot)</span>
        <span class="s1">x = np.asarray([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">6</span><span class="s1">])</span>
        <span class="s1">assert_allclose(b(x[x != </span><span class="s3">6</span><span class="s1">] - </span><span class="s3">1e-10</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">b(x[x != </span><span class="s3">6</span><span class="s1">] + </span><span class="s3">1e-10</span><span class="s1">))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.allclose(b(</span><span class="s3">6.</span><span class="s1">-</span><span class="s3">1e-10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b(</span><span class="s3">6</span><span class="s1">+</span><span class="s3">1e-10</span><span class="s1">)))</span>

        <span class="s2"># 1st derivative jumps at double knots, 1 &amp; 6:</span>
        <span class="s1">x0 = np.asarray([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_allclose(b(x0 - </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s1">nu=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">b(x0 + </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s1">nu=</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">x1 = np.asarray([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">])</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.all(np.allclose(b(x1 - </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s1">nu=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                                       <span class="s1">b(x1 + </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s1">nu=</span><span class="s3">1</span><span class="s1">))))</span>

        <span class="s2"># 2nd derivative is not guaranteed to be continuous either</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.all(np.allclose(b(x - </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s1">nu=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                       <span class="s1">b(x + </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s1">nu=</span><span class="s3">2</span><span class="s1">))))</span>

    <span class="s0">def </span><span class="s1">test_basis_element_quadratic(self):</span>
        <span class="s1">xx = np.linspace(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">b = BSpline.basis_element(t=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">,</span>
                        <span class="s1">splev(xx</span><span class="s0">, </span><span class="s1">(b.t</span><span class="s0">, </span><span class="s1">b.c</span><span class="s0">, </span><span class="s1">b.k))</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">,</span>
                        <span class="s1">B_0123(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s1">b = BSpline.basis_element(t=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">xx = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">,</span>
                <span class="s1">np.where(xx &lt; </span><span class="s3">1</span><span class="s0">, </span><span class="s1">xx*xx</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2.</span><span class="s1">-xx)**</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_basis_element_rndm(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">xx = np.linspace(t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">_sum_basis_elements(xx</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_cmplx(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">cc = c * (</span><span class="s3">1. </span><span class="s1">+ </span><span class="s3">3.j</span><span class="s1">)</span>

        <span class="s1">b = BSpline(t</span><span class="s0">, </span><span class="s1">cc</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">b_re = BSpline(t</span><span class="s0">, </span><span class="s1">b.c.real</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">b_im = BSpline(t</span><span class="s0">, </span><span class="s1">b.c.imag</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">xx = np.linspace(t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx).real</span><span class="s0">, </span><span class="s1">b_re(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx).imag</span><span class="s0">, </span><span class="s1">b_im(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_nan(self):</span>
        <span class="s2"># nan in, nan out.</span>
        <span class="s1">b = BSpline.basis_element([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_(np.isnan(b(np.nan)))</span>

    <span class="s0">def </span><span class="s1">test_derivative_method(self):</span>
        <span class="s1">b = _make_random_spline(k=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">b0 = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">xx = np.linspace(t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k):</span>
            <span class="s1">b = b.derivative()</span>
            <span class="s1">assert_allclose(b0(xx</span><span class="s0">, </span><span class="s1">j)</span><span class="s0">, </span><span class="s1">b(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_antiderivative_method(self):</span>
        <span class="s1">b = _make_random_spline()</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">xx = np.linspace(t[k]</span><span class="s0">, </span><span class="s1">t[-k-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.antiderivative().derivative()(xx)</span><span class="s0">,</span>
                        <span class="s1">b(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># repeat with N-D array for c</span>
        <span class="s1">c = np.c_[c</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">c]</span>
        <span class="s1">c = np.dstack((c</span><span class="s0">, </span><span class="s1">c))</span>
        <span class="s1">b = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">assert_allclose(b.antiderivative().derivative()(xx)</span><span class="s0">,</span>
                        <span class="s1">b(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_integral(self):</span>
        <span class="s1">b = BSpline.basis_element([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])  </span><span class="s2"># x for x &lt; 1 else 2 - x</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1 </span><span class="s1">* </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">)</span>

        <span class="s2"># extrapolate or zeros outside of [0, 2]; default is yes</span>
        <span class="s1">assert_allclose(b.integrate(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.integrate(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.integrate(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1 </span><span class="s1">* </span><span class="s3">0.5</span><span class="s1">)</span>

        <span class="s2"># Test ``_fitpack._splint()``</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">_impl.splint(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">b.tck))</span>

        <span class="s2"># Test ``extrapolate='periodic'``.</span>
        <span class="s1">b.extrapolate = </span><span class="s4">'periodic'</span>
        <span class="s1">i = b.antiderivative()</span>
        <span class="s1">period_int = i(</span><span class="s3">2</span><span class="s1">) - i(</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">period_int)</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1 </span><span class="s1">* period_int)</span>
        <span class="s1">assert_allclose(b.integrate(-</span><span class="s3">9</span><span class="s0">, </span><span class="s1">-</span><span class="s3">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">period_int)</span>
        <span class="s1">assert_allclose(b.integrate(-</span><span class="s3">8</span><span class="s0">, </span><span class="s1">-</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* period_int)</span>

        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">i(</span><span class="s3">1.5</span><span class="s1">) - i(</span><span class="s3">0.5</span><span class="s1">))</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">i(</span><span class="s3">1</span><span class="s1">) - i(</span><span class="s3">0</span><span class="s1">) + i(</span><span class="s3">2</span><span class="s1">) - i(</span><span class="s3">1.5</span><span class="s1">))</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">1.5 </span><span class="s1">+ </span><span class="s3">12</span><span class="s0">, </span><span class="s3">3 </span><span class="s1">+ </span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">i(</span><span class="s3">1</span><span class="s1">) - i(</span><span class="s3">0</span><span class="s1">) + i(</span><span class="s3">2</span><span class="s1">) - i(</span><span class="s3">1.5</span><span class="s1">))</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">3 </span><span class="s1">+ </span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">i(</span><span class="s3">1</span><span class="s1">) - i(</span><span class="s3">0</span><span class="s1">) + i(</span><span class="s3">2</span><span class="s1">) - i(</span><span class="s3">1.5</span><span class="s1">) + </span><span class="s3">6 </span><span class="s1">* period_int)</span>

        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">i(</span><span class="s3">0</span><span class="s1">) - i(</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_allclose(b.integrate(-</span><span class="s3">9</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">i(</span><span class="s3">0</span><span class="s1">) - i(</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_allclose(b.integrate(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">9</span><span class="s1">)</span><span class="s0">, </span><span class="s1">i(</span><span class="s3">1</span><span class="s1">) - i(</span><span class="s3">2</span><span class="s1">) - </span><span class="s3">4 </span><span class="s1">* period_int)</span>

    <span class="s0">def </span><span class="s1">test_integrate_ppoly(self):</span>
        <span class="s2"># test .integrate method to be consistent with PPoly.integrate</span>
        <span class="s1">x = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">b.extrapolate = </span><span class="s4">'periodic'</span>
        <span class="s1">p = PPoly.from_spline(b)</span>

        <span class="s0">for </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 </span><span class="s0">in </span><span class="s1">[(-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">4</span><span class="s0">, </span><span class="s3">13</span><span class="s1">)]:</span>
            <span class="s1">assert_allclose(b.integrate(x0</span><span class="s0">, </span><span class="s1">x1)</span><span class="s0">,</span>
                            <span class="s1">p.integrate(x0</span><span class="s0">, </span><span class="s1">x1))</span>

    <span class="s0">def </span><span class="s1">test_subclassing(self):</span>
        <span class="s2"># classmethods should not decay to the base class</span>
        <span class="s0">class </span><span class="s1">B(BSpline):</span>
            <span class="s0">pass</span>

        <span class="s1">b = B.basis_element([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(b.__class__</span><span class="s0">, </span><span class="s1">B)</span>
        <span class="s1">assert_equal(b.derivative().__class__</span><span class="s0">, </span><span class="s1">B)</span>
        <span class="s1">assert_equal(b.antiderivative().__class__</span><span class="s0">, </span><span class="s1">B)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'axis'</span><span class="s0">, </span><span class="s1">range(-</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_axis(self</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">k = </span><span class="s3">22</span><span class="s0">, </span><span class="s3">3</span>
        <span class="s1">t = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">n + k + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">sh = [</span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]</span>
        <span class="s2"># We need the positive axis for some of the indexing and slices used</span>
        <span class="s2"># in this test.</span>
        <span class="s1">pos_axis = axis % </span><span class="s3">4</span>
        <span class="s1">sh.insert(pos_axis</span><span class="s0">, </span><span class="s1">n)   </span><span class="s2"># [22, 6, 7, 8] etc</span>
        <span class="s1">c = np.random.random(size=sh)</span>
        <span class="s1">b = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">assert_equal(b.c.shape</span><span class="s0">,</span>
                     <span class="s1">[sh[pos_axis]</span><span class="s0">,</span><span class="s1">] + sh[:pos_axis] + sh[pos_axis+</span><span class="s3">1</span><span class="s1">:])</span>

        <span class="s1">xp = np.random.random((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">assert_equal(b(xp).shape</span><span class="s0">,</span>
                     <span class="s1">sh[:pos_axis] + list(xp.shape) + sh[pos_axis+</span><span class="s3">1</span><span class="s1">:])</span>

        <span class="s2"># -c.ndim &lt;= axis &lt; c.ndim</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">[-c.ndim - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">c.ndim]:</span>
            <span class="s1">assert_raises(np.AxisError</span><span class="s0">, </span><span class="s1">BSpline</span><span class="s0">,</span>
                          <span class="s1">**dict(t=t</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">axis=ax))</span>

        <span class="s2"># derivative, antiderivative keeps the axis</span>
        <span class="s0">for </span><span class="s1">b1 </span><span class="s0">in </span><span class="s1">[BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis).derivative()</span><span class="s0">,</span>
                   <span class="s1">BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis).derivative(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s1">BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis).antiderivative()</span><span class="s0">,</span>
                   <span class="s1">BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=axis).antiderivative(</span><span class="s3">2</span><span class="s1">)]:</span>
            <span class="s1">assert_equal(b1.axis</span><span class="s0">, </span><span class="s1">b.axis)</span>

    <span class="s0">def </span><span class="s1">test_neg_axis(self):</span>
        <span class="s1">k = </span><span class="s3">2</span>
        <span class="s1">t = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span>
        <span class="s1">c = np.array([[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>

        <span class="s1">spl = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">spl0 = BSpline(t</span><span class="s0">, </span><span class="s1">c[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">spl1 = BSpline(t</span><span class="s0">, </span><span class="s1">c[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">assert_equal(spl(</span><span class="s3">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[spl0(</span><span class="s3">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">spl1(</span><span class="s3">2.5</span><span class="s1">)])</span>

    <span class="s0">def </span><span class="s1">test_design_matrix_bc_types(self):</span>
        <span class="s5">''' 
        Splines with different boundary conditions are built on different 
        types of vectors of knots. As far as design matrix depends only on 
        vector of knots, `k` and `x` it is useful to make tests for different 
        boundary conditions (and as following different vectors of knots). 
        '''</span>
        <span class="s0">def </span><span class="s1">run_design_matrix_tests(n</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc_type):</span>
            <span class="s5">''' 
            To avoid repetition of code the following function is provided. 
            '''</span>
            <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
            <span class="s1">x = np.sort(np.random.random_sample(n) * </span><span class="s3">40 </span><span class="s1">- </span><span class="s3">20</span><span class="s1">)</span>
            <span class="s1">y = np.random.random_sample(n) * </span><span class="s3">40 </span><span class="s1">- </span><span class="s3">20</span>
            <span class="s0">if </span><span class="s1">bc_type == </span><span class="s4">&quot;periodic&quot;</span><span class="s1">:</span>
                <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = y[-</span><span class="s3">1</span><span class="s1">]</span>

            <span class="s1">bspl = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">bc_type=bc_type)</span>

            <span class="s1">c = np.eye(len(bspl.t) - k - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">des_matr_def = BSpline(bspl.t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)(x)</span>
            <span class="s1">des_matr_csr = BSpline.design_matrix(x</span><span class="s0">,</span>
                                                 <span class="s1">bspl.t</span><span class="s0">,</span>
                                                 <span class="s1">k).toarray()</span>
            <span class="s1">assert_allclose(des_matr_csr @ bspl.c</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
            <span class="s1">assert_allclose(des_matr_def</span><span class="s0">, </span><span class="s1">des_matr_csr</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># &quot;clamped&quot; and &quot;natural&quot; work only with `k = 3`</span>
        <span class="s1">n = </span><span class="s3">11</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s0">for </span><span class="s1">bc </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;clamped&quot;</span><span class="s0">, </span><span class="s4">&quot;natural&quot;</span><span class="s1">]:</span>
            <span class="s1">run_design_matrix_tests(n</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc)</span>

        <span class="s2"># &quot;not-a-knot&quot; works with odd `k`</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
            <span class="s1">run_design_matrix_tests(n</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s4">&quot;not-a-knot&quot;</span><span class="s1">)</span>

        <span class="s2"># &quot;periodic&quot; works with any `k` (even more than `n`)</span>
        <span class="s1">n = </span><span class="s3">5  </span><span class="s2"># smaller `n` to test `k &gt; n` case</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
            <span class="s1">run_design_matrix_tests(n</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s4">&quot;periodic&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'extrapolate'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True, </span><span class="s4">'periodic'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'degree'</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_design_matrix_same_as_BSpline_call(self</span><span class="s0">, </span><span class="s1">extrapolate</span><span class="s0">, </span><span class="s1">degree):</span>
        <span class="s5">&quot;&quot;&quot;Test that design_matrix(x) is equivalent to BSpline(..)(x).&quot;&quot;&quot;</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">x = np.random.random_sample(</span><span class="s3">10 </span><span class="s1">* (degree + </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax = np.amin(x)</span><span class="s0">, </span><span class="s1">np.amax(x)</span>
        <span class="s1">k = degree</span>
        <span class="s1">t = np.r_[np.linspace(xmin - </span><span class="s3">2</span><span class="s0">, </span><span class="s1">xmin - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">degree)</span><span class="s0">,</span>
                  <span class="s1">np.linspace(xmin</span><span class="s0">, </span><span class="s1">xmax</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* (degree + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
                  <span class="s1">np.linspace(xmax + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">xmax + </span><span class="s3">2</span><span class="s0">, </span><span class="s1">degree)]</span>
        <span class="s1">c = np.eye(len(t) - k - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">bspline = BSpline(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">bspline(x)</span><span class="s0">, </span><span class="s1">BSpline.design_matrix(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate).toarray()</span>
        <span class="s1">)</span>

        <span class="s2"># extrapolation regime</span>
        <span class="s1">x = np.array([xmin - </span><span class="s3">10</span><span class="s0">, </span><span class="s1">xmin - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">xmax + </span><span class="s3">1.5</span><span class="s0">, </span><span class="s1">xmax + </span><span class="s3">10</span><span class="s1">])</span>
        <span class="s0">if not </span><span class="s1">extrapolate:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                <span class="s1">BSpline.design_matrix(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">bspline(x)</span><span class="s0">,</span>
                <span class="s1">BSpline.design_matrix(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">extrapolate).toarray()</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_design_matrix_x_shapes(self):</span>
        <span class="s2"># test for different `x` shapes</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">10</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">x = np.sort(np.random.random_sample(n) * </span><span class="s3">40 </span><span class="s1">- </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">y = np.random.random_sample(n) * </span><span class="s3">40 </span><span class="s1">- </span><span class="s3">20</span>

        <span class="s1">bspl = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s1">xc = x[:i]</span>
            <span class="s1">yc = y[:i]</span>
            <span class="s1">des_matr_csr = BSpline.design_matrix(xc</span><span class="s0">,</span>
                                                 <span class="s1">bspl.t</span><span class="s0">,</span>
                                                 <span class="s1">k).toarray()</span>
            <span class="s1">assert_allclose(des_matr_csr @ bspl.c</span><span class="s0">, </span><span class="s1">yc</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_design_matrix_t_shapes(self):</span>
        <span class="s2"># test for minimal possible `t` shape</span>
        <span class="s1">t = [</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]</span>
        <span class="s1">des_matr = BSpline.design_matrix(</span><span class="s3">2.</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s3">3</span><span class="s1">).toarray()</span>
        <span class="s1">assert_allclose(des_matr</span><span class="s0">,</span>
                        <span class="s1">[[</span><span class="s3">0.25</span><span class="s0">, </span><span class="s3">0.58333333</span><span class="s0">, </span><span class="s3">0.16666667</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]]</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_design_matrix_asserts(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">10</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">x = np.sort(np.random.random_sample(n) * </span><span class="s3">40 </span><span class="s1">- </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">y = np.random.random_sample(n) * </span><span class="s3">40 </span><span class="s1">- </span><span class="s3">20</span>
        <span class="s1">bspl = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>
        <span class="s2"># invalid vector of knots (should be a 1D non-descending array)</span>
        <span class="s2"># here the actual vector of knots is reversed, so it is invalid</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">BSpline.design_matrix(x</span><span class="s0">, </span><span class="s1">bspl.t[::-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">k = </span><span class="s3">2</span>
        <span class="s1">t = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">5.</span><span class="s1">]</span>
        <span class="s1">x = [</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]</span>
        <span class="s2"># out of bounds</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">BSpline.design_matrix(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'bc_type'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'natural'</span><span class="s0">, </span><span class="s4">'clamped'</span><span class="s0">,</span>
                                         <span class="s4">'periodic'</span><span class="s0">, </span><span class="s4">'not-a-knot'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_from_power_basis(self</span><span class="s0">, </span><span class="s1">bc_type):</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">x = np.sort(np.random.random(</span><span class="s3">20</span><span class="s1">))</span>
        <span class="s1">y = np.random.random(</span><span class="s3">20</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">bc_type == </span><span class="s4">'periodic'</span><span class="s1">:</span>
            <span class="s1">y[-</span><span class="s3">1</span><span class="s1">] = y[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">cb = CubicSpline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=bc_type)</span>
        <span class="s1">bspl = BSpline.from_power_basis(cb</span><span class="s0">, </span><span class="s1">bc_type=bc_type)</span>
        <span class="s1">xx = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">assert_allclose(cb(xx)</span><span class="s0">, </span><span class="s1">bspl(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">bspl_new = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=bc_type)</span>
        <span class="s1">assert_allclose(bspl.c</span><span class="s0">, </span><span class="s1">bspl_new.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'bc_type'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'natural'</span><span class="s0">, </span><span class="s4">'clamped'</span><span class="s0">,</span>
                                         <span class="s4">'periodic'</span><span class="s0">, </span><span class="s4">'not-a-knot'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_from_power_basis_complex(self</span><span class="s0">, </span><span class="s1">bc_type):</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">x = np.sort(np.random.random(</span><span class="s3">20</span><span class="s1">))</span>
        <span class="s1">y = np.random.random(</span><span class="s3">20</span><span class="s1">) + np.random.random(</span><span class="s3">20</span><span class="s1">) * </span><span class="s3">1j</span>
        <span class="s0">if </span><span class="s1">bc_type == </span><span class="s4">'periodic'</span><span class="s1">:</span>
            <span class="s1">y[-</span><span class="s3">1</span><span class="s1">] = y[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">cb = CubicSpline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=bc_type)</span>
        <span class="s1">bspl = BSpline.from_power_basis(cb</span><span class="s0">, </span><span class="s1">bc_type=bc_type)</span>
        <span class="s1">bspl_new_real = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y.real</span><span class="s0">, </span><span class="s1">bc_type=bc_type)</span>
        <span class="s1">bspl_new_imag = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y.imag</span><span class="s0">, </span><span class="s1">bc_type=bc_type)</span>
        <span class="s1">assert_equal(bspl.c.dtype</span><span class="s0">, </span><span class="s1">(bspl_new_real.c</span>
                                    <span class="s1">+ </span><span class="s3">1j </span><span class="s1">* bspl_new_imag.c).dtype)</span>
        <span class="s1">assert_allclose(bspl.c</span><span class="s0">, </span><span class="s1">bspl_new_real.c</span>
                        <span class="s1">+ </span><span class="s3">1j </span><span class="s1">* bspl_new_imag.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_from_power_basis_exmp(self):</span>
        <span class="s5">''' 
        For x = [0, 1, 2, 3, 4] and y = [1, 1, 1, 1, 1] 
        the coefficients of Cubic Spline in the power basis: 
 
        $[[0, 0, 0, 0, 0],\\$ 
        $[0, 0, 0, 0, 0],\\$ 
        $[0, 0, 0, 0, 0],\\$ 
        $[1, 1, 1, 1, 1]]$ 
 
        It could be shown explicitly that coefficients of the interpolating 
        function in B-spline basis are c = [1, 1, 1, 1, 1, 1, 1] 
        '''</span>
        <span class="s1">x = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">bspl = BSpline.from_power_basis(CubicSpline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'natural'</span><span class="s1">)</span><span class="s0">,</span>
                                        <span class="s1">bc_type=</span><span class="s4">'natural'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bspl.c</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_read_only(self):</span>
        <span class="s2"># BSpline must work on read-only knots and coefficients.</span>
        <span class="s1">t = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">c = np.array([</span><span class="s3">3.0</span><span class="s1">])</span>
        <span class="s1">t.setflags(write=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">c.setflags(write=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">xx = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">xx.setflags(write=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">b = BSpline(t=t</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_knots_multiplicity():</span>
    <span class="s2"># Take a spline w/ random coefficients, throw in knots of varying</span>
    <span class="s2"># multiplicity.</span>

    <span class="s0">def </span><span class="s1">check_splev(b</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s1">der=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">):</span>
        <span class="s2"># check evaluations against FITPACK, incl extrapolations</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.tck</span>
        <span class="s1">x = np.unique(t)</span>
        <span class="s1">x = np.r_[t[</span><span class="s3">0</span><span class="s1">]-</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">*(x[</span><span class="s3">1</span><span class="s1">:] + x[:</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">t[-</span><span class="s3">1</span><span class="s1">]+</span><span class="s3">0.1</span><span class="s1">]</span>
        <span class="s1">assert_allclose(splev(x</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">der)</span><span class="s0">, </span><span class="s1">b(x</span><span class="s0">, </span><span class="s1">der)</span><span class="s0">,</span>
                <span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s4">f'der = </span><span class="s0">{</span><span class="s1">der</span><span class="s0">}  </span><span class="s4">k = </span><span class="s0">{</span><span class="s1">b.k</span><span class="s0">}</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s2"># test loop itself</span>
    <span class="s2"># [the index `j` is for interpreting the traceback in case of a failure]</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]:</span>
        <span class="s1">b = _make_random_spline(k=k)</span>
        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">b1 </span><span class="s0">in </span><span class="s1">enumerate(_make_multiples(b)):</span>
            <span class="s1">check_splev(b1</span><span class="s0">, </span><span class="s1">j)</span>
            <span class="s0">for </span><span class="s1">der </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k+</span><span class="s3">1</span><span class="s1">):</span>
                <span class="s1">check_splev(b1</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s1">der</span><span class="s0">, </span><span class="s3">1e-12</span><span class="s0">, </span><span class="s3">1e-12</span><span class="s1">)</span>


<span class="s2">### stolen from @pv, verbatim</span>
<span class="s0">def </span><span class="s1">_naive_B(x</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">t):</span>
    <span class="s5">&quot;&quot;&quot; 
    Naive way to compute B-spline basis functions. Useful only for testing! 
    computes B(x; t[i],..., t[i+k+1]) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">k == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s3">1.0 </span><span class="s0">if </span><span class="s1">t[i] &lt;= x &lt; t[i+</span><span class="s3">1</span><span class="s1">] </span><span class="s0">else </span><span class="s3">0.0</span>
    <span class="s0">if </span><span class="s1">t[i+k] == t[i]:</span>
        <span class="s1">c1 = </span><span class="s3">0.0</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">c1 = (x - t[i])/(t[i+k] - t[i]) * _naive_B(x</span><span class="s0">, </span><span class="s1">k-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">t)</span>
    <span class="s0">if </span><span class="s1">t[i+k+</span><span class="s3">1</span><span class="s1">] == t[i+</span><span class="s3">1</span><span class="s1">]:</span>
        <span class="s1">c2 = </span><span class="s3">0.0</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">c2 = (t[i+k+</span><span class="s3">1</span><span class="s1">] - x)/(t[i+k+</span><span class="s3">1</span><span class="s1">] - t[i+</span><span class="s3">1</span><span class="s1">]) * _naive_B(x</span><span class="s0">, </span><span class="s1">k-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">i+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">t)</span>
    <span class="s0">return </span><span class="s1">(c1 + c2)</span>


<span class="s2">### stolen from @pv, verbatim</span>
<span class="s0">def </span><span class="s1">_naive_eval(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s5">&quot;&quot;&quot; 
    Naive B-spline evaluation. Useful only for testing! 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x == t[k]:</span>
        <span class="s1">i = k</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">i = np.searchsorted(t</span><span class="s0">, </span><span class="s1">x) - </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">t[i] &lt;= x &lt;= t[i+</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">i &gt;= k </span><span class="s0">and </span><span class="s1">i &lt; len(t) - k</span>
    <span class="s0">return </span><span class="s1">sum(c[i-j] * _naive_B(x</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">i-j</span><span class="s0">, </span><span class="s1">t) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">k+</span><span class="s3">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">_naive_eval_2(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s5">&quot;&quot;&quot;Naive B-spline evaluation, another way.&quot;&quot;&quot;</span>
    <span class="s1">n = len(t) - (k+</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">n &gt;= k+</span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">len(c) &gt;= n</span>
    <span class="s0">assert </span><span class="s1">t[k] &lt;= x &lt;= t[n]</span>
    <span class="s0">return </span><span class="s1">sum(c[i] * _naive_B(x</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">t) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n))</span>


<span class="s0">def </span><span class="s1">_sum_basis_elements(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s1">n = len(t) - (k+</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">n &gt;= k+</span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">len(c) &gt;= n</span>
    <span class="s1">s = </span><span class="s3">0.</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
        <span class="s1">b = BSpline.basis_element(t[i:i+k+</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">extrapolate=</span><span class="s0">False</span><span class="s1">)(x)</span>
        <span class="s1">s += c[i] * np.nan_to_num(b)   </span><span class="s2"># zero out out-of-bounds elements</span>
    <span class="s0">return </span><span class="s1">s</span>


<span class="s0">def </span><span class="s1">B_012(x):</span>
    <span class="s5">&quot;&quot;&quot; A linear B-spline function B(x | 0, 1, 2).&quot;&quot;&quot;</span>
    <span class="s1">x = np.atleast_1d(x)</span>
    <span class="s0">return </span><span class="s1">np.piecewise(x</span><span class="s0">, </span><span class="s1">[(x &lt; </span><span class="s3">0</span><span class="s1">) | (x &gt; </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(x &gt;= </span><span class="s3">0</span><span class="s1">) &amp; (x &lt; </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(x &gt;= </span><span class="s3">1</span><span class="s1">) &amp; (x &lt;= </span><span class="s3">2</span><span class="s1">)]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">0.</span><span class="s0">, lambda </span><span class="s1">x: x</span><span class="s0">, lambda </span><span class="s1">x: </span><span class="s3">2.</span><span class="s1">-x])</span>


<span class="s0">def </span><span class="s1">B_0123(x</span><span class="s0">, </span><span class="s1">der=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;A quadratic B-spline function B(x | 0, 1, 2, 3).&quot;&quot;&quot;</span>
    <span class="s1">x = np.atleast_1d(x)</span>
    <span class="s1">conds = [x &lt; </span><span class="s3">1</span><span class="s0">, </span><span class="s1">(x &gt; </span><span class="s3">1</span><span class="s1">) &amp; (x &lt; </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">x &gt; </span><span class="s3">2</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">der == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">funcs = [</span><span class="s0">lambda </span><span class="s1">x: x*x/</span><span class="s3">2.</span><span class="s0">,</span>
                 <span class="s0">lambda </span><span class="s1">x: </span><span class="s3">3.</span><span class="s1">/</span><span class="s3">4 </span><span class="s1">- (x-</span><span class="s3">3.</span><span class="s1">/</span><span class="s3">2</span><span class="s1">)**</span><span class="s3">2</span><span class="s0">,</span>
                 <span class="s0">lambda </span><span class="s1">x: (</span><span class="s3">3.</span><span class="s1">-x)**</span><span class="s3">2 </span><span class="s1">/ </span><span class="s3">2</span><span class="s1">]</span>
    <span class="s0">elif </span><span class="s1">der == </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s1">funcs = [</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">1.</span><span class="s0">,</span>
                 <span class="s0">lambda </span><span class="s1">x: -</span><span class="s3">2.</span><span class="s0">,</span>
                 <span class="s0">lambda </span><span class="s1">x: </span><span class="s3">1.</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'never be here: der=%s' </span><span class="s1">% der)</span>
    <span class="s1">pieces = np.piecewise(x</span><span class="s0">, </span><span class="s1">conds</span><span class="s0">, </span><span class="s1">funcs)</span>
    <span class="s0">return </span><span class="s1">pieces</span>


<span class="s0">def </span><span class="s1">_make_random_spline(n=</span><span class="s3">35</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s1">):</span>
    <span class="s1">np.random.seed(</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s1">t = np.sort(np.random.random(n+k+</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">c = np.random.random(n)</span>
    <span class="s0">return </span><span class="s1">BSpline.construct_fast(t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>


<span class="s0">def </span><span class="s1">_make_multiples(b):</span>
    <span class="s5">&quot;&quot;&quot;Increase knot multiplicity.&quot;&quot;&quot;</span>
    <span class="s1">c</span><span class="s0">, </span><span class="s1">k = b.c</span><span class="s0">, </span><span class="s1">b.k</span>

    <span class="s1">t1 = b.t.copy()</span>
    <span class="s1">t1[</span><span class="s3">17</span><span class="s1">:</span><span class="s3">19</span><span class="s1">] = t1[</span><span class="s3">17</span><span class="s1">]</span>
    <span class="s1">t1[</span><span class="s3">22</span><span class="s1">] = t1[</span><span class="s3">21</span><span class="s1">]</span>
    <span class="s0">yield </span><span class="s1">BSpline(t1</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>

    <span class="s1">t1 = b.t.copy()</span>
    <span class="s1">t1[:k+</span><span class="s3">1</span><span class="s1">] = t1[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">yield </span><span class="s1">BSpline(t1</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>

    <span class="s1">t1 = b.t.copy()</span>
    <span class="s1">t1[-k-</span><span class="s3">1</span><span class="s1">:] = t1[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">yield </span><span class="s1">BSpline(t1</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k)</span>


<span class="s0">class </span><span class="s1">TestInterop:</span>
    <span class="s2">#</span>
    <span class="s2"># Test that FITPACK-based spl* functions can deal with BSpline objects</span>
    <span class="s2">#</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">xx = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">*np.pi</span><span class="s0">, </span><span class="s3">41</span><span class="s1">)</span>
        <span class="s1">yy = np.cos(xx)</span>
        <span class="s1">b = make_interp_spline(xx</span><span class="s0">, </span><span class="s1">yy)</span>
        <span class="s1">self.tck = (b.t</span><span class="s0">, </span><span class="s1">b.c</span><span class="s0">, </span><span class="s1">b.k)</span>
        <span class="s1">self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">self.b = xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">b</span>

        <span class="s1">self.xnew = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">*np.pi</span><span class="s0">, </span><span class="s3">21</span><span class="s1">)</span>

        <span class="s1">c2 = np.c_[b.c</span><span class="s0">, </span><span class="s1">b.c</span><span class="s0">, </span><span class="s1">b.c]</span>
        <span class="s1">self.c2 = np.dstack((c2</span><span class="s0">, </span><span class="s1">c2))</span>
        <span class="s1">self.b2 = BSpline(b.t</span><span class="s0">, </span><span class="s1">self.c2</span><span class="s0">, </span><span class="s1">b.k)</span>

    <span class="s0">def </span><span class="s1">test_splev(self):</span>
        <span class="s1">xnew</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">b2 = self.xnew</span><span class="s0">, </span><span class="s1">self.b</span><span class="s0">, </span><span class="s1">self.b2</span>

        <span class="s2"># check that splev works with 1-D array of coefficients</span>
        <span class="s2"># for array and scalar `x`</span>
        <span class="s1">assert_allclose(splev(xnew</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">,</span>
                        <span class="s1">b(xnew)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(splev(xnew</span><span class="s0">, </span><span class="s1">b.tck)</span><span class="s0">,</span>
                        <span class="s1">b(xnew)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose([splev(x</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">xnew]</span><span class="s0">,</span>
                        <span class="s1">b(xnew)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-15</span><span class="s1">)</span>

        <span class="s2"># With N-D coefficients, there's a quirck:</span>
        <span class="s2"># splev(x, BSpline) is equivalent to BSpline(x)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Calling splev.. with BSpline&quot;</span><span class="s1">):</span>
            <span class="s1">splev(xnew</span><span class="s0">, </span><span class="s1">b2)</span>

        <span class="s2"># However, splev(x, BSpline.tck) needs some transposes. This is because</span>
        <span class="s2"># BSpline interpolates along the first axis, while the legacy FITPACK</span>
        <span class="s2"># wrapper does list(map(...)) which effectively interpolates along the</span>
        <span class="s2"># last axis. Like so:</span>
        <span class="s1">sh = tuple(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">b2.c.ndim)) + (</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)   </span><span class="s2"># sh = (1, 2, 0)</span>
        <span class="s1">cc = b2.c.transpose(sh)</span>
        <span class="s1">tck = (b2.t</span><span class="s0">, </span><span class="s1">cc</span><span class="s0">, </span><span class="s1">b2.k)</span>
        <span class="s1">assert_allclose(splev(xnew</span><span class="s0">, </span><span class="s1">tck)</span><span class="s0">,</span>
                        <span class="s1">b2(xnew).transpose(sh)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_splrep(self):</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = self.xx</span><span class="s0">, </span><span class="s1">self.yy</span>
        <span class="s2"># test that &quot;new&quot; splrep is equivalent to _impl.splrep</span>
        <span class="s1">tck = splrep(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k = _impl.splrep(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_allclose(tck[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(tck[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_equal(tck[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s2"># also cover the `full_output=True` branch</span>
        <span class="s1">tck_f</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = splrep(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(tck_f[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(tck_f[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_equal(tck_f[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s2"># test that the result of splrep roundtrips with splev:</span>
        <span class="s2"># evaluate the spline on the original `x` points</span>
        <span class="s1">yy = splev(x</span><span class="s0">, </span><span class="s1">tck)</span>
        <span class="s1">assert_allclose(y</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

        <span class="s2"># ... and also it roundtrips if wrapped in a BSpline</span>
        <span class="s1">b = BSpline(*tck)</span>
        <span class="s1">assert_allclose(y</span><span class="s0">, </span><span class="s1">b(x)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_splrep_errors(self):</span>
        <span class="s2"># test that both &quot;old&quot; and &quot;new&quot; splrep raise for an N-D ``y`` array</span>
        <span class="s2"># with n &gt; 1</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = self.xx</span><span class="s0">, </span><span class="s1">self.yy</span>
        <span class="s1">y2 = np.c_[y</span><span class="s0">, </span><span class="s1">y]</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">splrep(x</span><span class="s0">, </span><span class="s1">y2)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">_impl.splrep(x</span><span class="s0">, </span><span class="s1">y2)</span>

        <span class="s2"># input below minimum size</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;m &gt; k must hold&quot;</span><span class="s1">):</span>
            <span class="s1">splrep(x[:</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y[:</span><span class="s3">3</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;m &gt; k must hold&quot;</span><span class="s1">):</span>
            <span class="s1">_impl.splrep(x[:</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y[:</span><span class="s3">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_splprep(self):</span>
        <span class="s1">x = np.arange(</span><span class="s3">15</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">u = splprep(x)</span>
        <span class="s1">tck</span><span class="s0">, </span><span class="s1">u1 = _impl.splprep(x)</span>

        <span class="s2"># test the roundtrip with splev for both &quot;old&quot; and &quot;new&quot; output</span>
        <span class="s1">assert_allclose(u</span><span class="s0">, </span><span class="s1">u1</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(splev(u</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(splev(u</span><span class="s0">, </span><span class="s1">tck)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

        <span class="s2"># cover the ``full_output=True`` branch</span>
        <span class="s1">(b_f</span><span class="s0">, </span><span class="s1">u_f)</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = splprep(x</span><span class="s0">, </span><span class="s1">s=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(u</span><span class="s0">, </span><span class="s1">u_f</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(splev(u_f</span><span class="s0">, </span><span class="s1">b_f)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_splprep_errors(self):</span>
        <span class="s2"># test that both &quot;old&quot; and &quot;new&quot; code paths raise for x.ndim &gt; 2</span>
        <span class="s1">x = np.arange(</span><span class="s3">3</span><span class="s1">*</span><span class="s3">4</span><span class="s1">*</span><span class="s3">5</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;too many values to unpack&quot;</span><span class="s1">):</span>
            <span class="s1">splprep(x)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;too many values to unpack&quot;</span><span class="s1">):</span>
            <span class="s1">_impl.splprep(x)</span>

        <span class="s2"># input below minimum size</span>
        <span class="s1">x = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">40</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;m &gt; k must hold&quot;</span><span class="s1">):</span>
            <span class="s1">splprep([x])</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;m &gt; k must hold&quot;</span><span class="s1">):</span>
            <span class="s1">_impl.splprep([x])</span>

        <span class="s2"># automatically calculated parameters are non-increasing</span>
        <span class="s2"># see gh-7589</span>
        <span class="s1">x = [-</span><span class="s3">50.49072266</span><span class="s0">, </span><span class="s1">-</span><span class="s3">50.49072266</span><span class="s0">, </span><span class="s1">-</span><span class="s3">54.49072266</span><span class="s0">, </span><span class="s1">-</span><span class="s3">54.49072266</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Invalid inputs&quot;</span><span class="s1">):</span>
            <span class="s1">splprep([x])</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Invalid inputs&quot;</span><span class="s1">):</span>
            <span class="s1">_impl.splprep([x])</span>

        <span class="s2"># given non-increasing parameter values u</span>
        <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">u = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.3</span><span class="s0">, </span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Invalid inputs&quot;</span><span class="s1">):</span>
            <span class="s1">splprep(*[[x]</span><span class="s0">, None, </span><span class="s1">u])</span>

    <span class="s0">def </span><span class="s1">test_sproot(self):</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">b2 = self.b</span><span class="s0">, </span><span class="s1">self.b2</span>
        <span class="s1">roots = np.array([</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">])*np.pi</span>
        <span class="s2"># sproot accepts a BSpline obj w/ 1-D coef array</span>
        <span class="s1">assert_allclose(sproot(b)</span><span class="s0">, </span><span class="s1">roots</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-7</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sproot((b.t</span><span class="s0">, </span><span class="s1">b.c</span><span class="s0">, </span><span class="s1">b.k))</span><span class="s0">, </span><span class="s1">roots</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-7</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-7</span><span class="s1">)</span>

        <span class="s2"># ... and deals with trailing dimensions if coef array is N-D</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Calling sproot.. with BSpline&quot;</span><span class="s1">):</span>
            <span class="s1">sproot(b2</span><span class="s0">, </span><span class="s1">mest=</span><span class="s3">50</span><span class="s1">)</span>

        <span class="s2"># and legacy behavior is preserved for a tck tuple w/ N-D coef</span>
        <span class="s1">c2r = b2.c.transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">rr = np.asarray(sproot((b2.t</span><span class="s0">, </span><span class="s1">c2r</span><span class="s0">, </span><span class="s1">b2.k)</span><span class="s0">, </span><span class="s1">mest=</span><span class="s3">50</span><span class="s1">))</span>
        <span class="s1">assert_equal(rr.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">assert_allclose(rr - roots</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_splint(self):</span>
        <span class="s2"># test that splint accepts BSpline objects</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">b2 = self.b</span><span class="s0">, </span><span class="s1">self.b2</span>
        <span class="s1">assert_allclose(splint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">,</span>
                        <span class="s1">splint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">b.tck)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(splint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">,</span>
                        <span class="s1">b.integrate(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># ... and deals with N-D arrays of coefficients</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Calling splint.. with BSpline&quot;</span><span class="s1">):</span>
            <span class="s1">splint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">b2)</span>

        <span class="s2"># and the legacy behavior is preserved for a tck tuple w/ N-D coef</span>
        <span class="s1">c2r = b2.c.transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">integr = np.asarray(splint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">(b2.t</span><span class="s0">, </span><span class="s1">c2r</span><span class="s0">, </span><span class="s1">b2.k)))</span>
        <span class="s1">assert_equal(integr.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_allclose(integr</span><span class="s0">,</span>
                        <span class="s1">splint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_splder(self):</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">[self.b</span><span class="s0">, </span><span class="s1">self.b2]:</span>
            <span class="s2"># pad the c array (FITPACK convention)</span>
            <span class="s1">ct = len(b.t) - len(b.c)</span>
            <span class="s0">if </span><span class="s1">ct &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">b.c = np.r_[b.c</span><span class="s0">, </span><span class="s1">np.zeros((ct</span><span class="s0">,</span><span class="s1">) + b.c.shape[</span><span class="s3">1</span><span class="s1">:])]</span>

            <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]:</span>
                <span class="s1">bd = splder(b)</span>
                <span class="s1">tck_d = _impl.splder((b.t</span><span class="s0">, </span><span class="s1">b.c</span><span class="s0">, </span><span class="s1">b.k))</span>
                <span class="s1">assert_allclose(bd.t</span><span class="s0">, </span><span class="s1">tck_d[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
                <span class="s1">assert_allclose(bd.c</span><span class="s0">, </span><span class="s1">tck_d[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
                <span class="s1">assert_equal(bd.k</span><span class="s0">, </span><span class="s1">tck_d[</span><span class="s3">2</span><span class="s1">])</span>
                <span class="s1">assert_(isinstance(bd</span><span class="s0">, </span><span class="s1">BSpline))</span>
                <span class="s1">assert_(isinstance(tck_d</span><span class="s0">, </span><span class="s1">tuple))  </span><span class="s2"># back-compat: tck in and out</span>

    <span class="s0">def </span><span class="s1">test_splantider(self):</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">[self.b</span><span class="s0">, </span><span class="s1">self.b2]:</span>
            <span class="s2"># pad the c array (FITPACK convention)</span>
            <span class="s1">ct = len(b.t) - len(b.c)</span>
            <span class="s0">if </span><span class="s1">ct &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">b.c = np.r_[b.c</span><span class="s0">, </span><span class="s1">np.zeros((ct</span><span class="s0">,</span><span class="s1">) + b.c.shape[</span><span class="s3">1</span><span class="s1">:])]</span>

            <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]:</span>
                <span class="s1">bd = splantider(b)</span>
                <span class="s1">tck_d = _impl.splantider((b.t</span><span class="s0">, </span><span class="s1">b.c</span><span class="s0">, </span><span class="s1">b.k))</span>
                <span class="s1">assert_allclose(bd.t</span><span class="s0">, </span><span class="s1">tck_d[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
                <span class="s1">assert_allclose(bd.c</span><span class="s0">, </span><span class="s1">tck_d[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
                <span class="s1">assert_equal(bd.k</span><span class="s0">, </span><span class="s1">tck_d[</span><span class="s3">2</span><span class="s1">])</span>
                <span class="s1">assert_(isinstance(bd</span><span class="s0">, </span><span class="s1">BSpline))</span>
                <span class="s1">assert_(isinstance(tck_d</span><span class="s0">, </span><span class="s1">tuple))  </span><span class="s2"># back-compat: tck in and out</span>

    <span class="s0">def </span><span class="s1">test_insert(self):</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">b2</span><span class="s0">, </span><span class="s1">xx = self.b</span><span class="s0">, </span><span class="s1">self.b2</span><span class="s0">, </span><span class="s1">self.xx</span>

        <span class="s1">j = b.t.size // </span><span class="s3">2</span>
        <span class="s1">tn = </span><span class="s3">0.5</span><span class="s1">*(b.t[j] + b.t[j+</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">bn</span><span class="s0">, </span><span class="s1">tck_n = insert(tn</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">insert(tn</span><span class="s0">, </span><span class="s1">(b.t</span><span class="s0">, </span><span class="s1">b.c</span><span class="s0">, </span><span class="s1">b.k))</span>
        <span class="s1">assert_allclose(splev(xx</span><span class="s0">, </span><span class="s1">bn)</span><span class="s0">,</span>
                        <span class="s1">splev(xx</span><span class="s0">, </span><span class="s1">tck_n)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(bn</span><span class="s0">, </span><span class="s1">BSpline))</span>
        <span class="s1">assert_(isinstance(tck_n</span><span class="s0">, </span><span class="s1">tuple))   </span><span class="s2"># back-compat: tck in, tck out</span>

        <span class="s2"># for N-D array of coefficients, BSpline.c needs to be transposed</span>
        <span class="s2"># after that, the results are equivalent.</span>
        <span class="s1">sh = tuple(range(b2.c.ndim))</span>
        <span class="s1">c_ = b2.c.transpose(sh[</span><span class="s3">1</span><span class="s1">:] + (</span><span class="s3">0</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">tck_n2 = insert(tn</span><span class="s0">, </span><span class="s1">(b2.t</span><span class="s0">, </span><span class="s1">c_</span><span class="s0">, </span><span class="s1">b2.k))</span>

        <span class="s1">bn2 = insert(tn</span><span class="s0">, </span><span class="s1">b2)</span>

        <span class="s2"># need a transpose for comparing the results, cf test_splev</span>
        <span class="s1">assert_allclose(np.asarray(splev(xx</span><span class="s0">, </span><span class="s1">tck_n2)).transpose(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">bn2(xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(bn2</span><span class="s0">, </span><span class="s1">BSpline))</span>
        <span class="s1">assert_(isinstance(tck_n2</span><span class="s0">, </span><span class="s1">tuple))   </span><span class="s2"># back-compat: tck in, tck out</span>


<span class="s0">class </span><span class="s1">TestInterp:</span>
    <span class="s2">#</span>
    <span class="s2"># Test basic ways of constructing interpolating splines.</span>
    <span class="s2">#</span>
    <span class="s1">xx = np.linspace(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">*np.pi)</span>
    <span class="s1">yy = np.sin(xx)</span>

    <span class="s0">def </span><span class="s1">test_non_int_order(self):</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">2.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_order_0(self):</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_linear(self):</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'k'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_incompatible_x_y(self</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s1">x = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Shapes of x&quot;</span><span class="s1">):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'k'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_broken_x(self</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s1">x = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]      </span><span class="s2"># duplicates</span>
        <span class="s1">y = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;x to not have duplicates&quot;</span><span class="s1">):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>

        <span class="s1">x = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]      </span><span class="s2"># unsorted</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Expect x to be a 1D strictly&quot;</span><span class="s1">):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>

        <span class="s1">x = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">x = np.asarray(x).reshape((</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))     </span><span class="s2"># 1D</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Expect x to be a 1D strictly&quot;</span><span class="s1">):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>

    <span class="s0">def </span><span class="s1">test_not_a_knot(self):</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]:</span>
            <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k)</span>
            <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_periodic(self):</span>
        <span class="s2"># k = 5 here for more derivatives</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s2"># in periodic case it is expected equality of k-1 first</span>
        <span class="s2"># derivatives at the boundaries</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">):</span>
            <span class="s1">assert_allclose(b(self.xx[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nu=i)</span><span class="s0">, </span><span class="s1">b(self.xx[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nu=i)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-11</span><span class="s1">)</span>
        <span class="s2"># tests for axis=-1</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">):</span>
            <span class="s1">assert_allclose(b(self.xx[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nu=i)</span><span class="s0">, </span><span class="s1">b(self.xx[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nu=i)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-11</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'k'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_periodic_random(self</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s2"># tests for both cases (k &gt; n and k &lt;= n)</span>
        <span class="s1">n = </span><span class="s3">5</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">x = np.sort(np.random.random_sample(n) * </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">y = np.random.random_sample(n) * </span><span class="s3">100</span>
        <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = y[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(x)</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_periodic_axis(self):</span>
        <span class="s1">n = self.xx.shape[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">x = np.random.random_sample(n) * </span><span class="s3">2 </span><span class="s1">* np.pi</span>
        <span class="s1">x = np.sort(x)</span>
        <span class="s1">x[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0.</span>
        <span class="s1">x[-</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">2 </span><span class="s1">* np.pi</span>
        <span class="s1">y = np.zeros((</span><span class="s3">2</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = np.sin(x)</span>
        <span class="s1">y[</span><span class="s3">1</span><span class="s1">] = np.cos(x)</span>
        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
            <span class="s1">assert_allclose(b(x[i])</span><span class="s0">, </span><span class="s1">y[:</span><span class="s0">, </span><span class="s1">i]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(x[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">b(x[-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_periodic_points_exception(self):</span>
        <span class="s2"># first and last points should match when periodic case expected</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">k = </span><span class="s3">5</span>
        <span class="s1">n = </span><span class="s3">8</span>
        <span class="s1">x = np.sort(np.random.random_sample(n))</span>
        <span class="s1">y = np.random.random_sample(n)</span>
        <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = y[-</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1  </span><span class="s2"># to be sure that they are not equal</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_periodic_knots_exception(self):</span>
        <span class="s2"># `periodic` case does not work with passed vector of knots</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">n = </span><span class="s3">7</span>
        <span class="s1">x = np.sort(np.random.random_sample(n))</span>
        <span class="s1">y = np.random.random_sample(n)</span>
        <span class="s1">t = np.zeros(n + </span><span class="s3">2 </span><span class="s1">* k)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s4">'periodic'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'k'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_periodic_splev(self</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s2"># comparision values of periodic b-spline with splev</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">tck = splrep(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">per=</span><span class="s0">True, </span><span class="s1">k=k)</span>
        <span class="s1">spl = splev(self.xx</span><span class="s0">, </span><span class="s1">tck)</span>
        <span class="s1">assert_allclose(spl</span><span class="s0">, </span><span class="s1">b(self.xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># comparison derivatives of periodic b-spline with splev</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k):</span>
            <span class="s1">spl = splev(self.xx</span><span class="s0">, </span><span class="s1">tck</span><span class="s0">, </span><span class="s1">der=i)</span>
            <span class="s1">assert_allclose(spl</span><span class="s0">, </span><span class="s1">b(self.xx</span><span class="s0">, </span><span class="s1">nu=i)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_periodic_cubic(self):</span>
        <span class="s2"># comparison values of cubic periodic b-spline with CubicSpline</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">cub = CubicSpline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">cub(self.xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># edge case: Cubic interpolation on 3 points</span>
        <span class="s1">n = </span><span class="s3">3</span>
        <span class="s1">x = np.sort(np.random.random_sample(n) * </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">y = np.random.random_sample(n) * </span><span class="s3">100</span>
        <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = y[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">cub = CubicSpline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(x)</span><span class="s0">, </span><span class="s1">cub(x)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_periodic_full_matrix(self):</span>
        <span class="s2"># comparison values of cubic periodic b-spline with</span>
        <span class="s2"># solution of the system with full matrix</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'periodic'</span><span class="s1">)</span>
        <span class="s1">t = _periodic_knots(self.xx</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">c = _make_interp_per_full_matr(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">b1 = np.vectorize(</span><span class="s0">lambda </span><span class="s1">x: _naive_eval(x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">k))</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">b1(self.xx)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_quadratic_deriv(self):</span>
        <span class="s1">der = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">8.</span><span class="s1">)]  </span><span class="s2"># order, value: f'(x) = 8.</span>

        <span class="s2"># derivative at right-hand edge</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">bc_type=(</span><span class="s0">None, </span><span class="s1">der))</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">der[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># derivative at left-hand edge</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">bc_type=(der</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">der[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_cubic_deriv(self):</span>
        <span class="s1">k = </span><span class="s3">3</span>

        <span class="s2"># first derivatives at left &amp; right edges:</span>
        <span class="s1">der_l</span><span class="s0">, </span><span class="s1">der_r = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">)]</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc_type=(der_l</span><span class="s0">, </span><span class="s1">der_r))</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose([b(self.xx[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b(self.xx[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s1">[der_l[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">der_r[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># 'natural' cubic spline, zero out 2nd derivatives at the boundaries</span>
        <span class="s1">der_l</span><span class="s0">, </span><span class="s1">der_r = [(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc_type=(der_l</span><span class="s0">, </span><span class="s1">der_r))</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_quintic_derivs(self):</span>
        <span class="s1">k</span><span class="s0">, </span><span class="s1">n = </span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span>
        <span class="s1">x = np.arange(n).astype(np.float_)</span>
        <span class="s1">y = np.sin(x)</span>
        <span class="s1">der_l = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">12.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span>
        <span class="s1">der_r = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">8.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">)]</span>
        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">bc_type=(der_l</span><span class="s0">, </span><span class="s1">der_r))</span>
        <span class="s1">assert_allclose(b(x)</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose([b(x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b(x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s1">[val </span><span class="s0">for </span><span class="s1">(nu</span><span class="s0">, </span><span class="s1">val) </span><span class="s0">in </span><span class="s1">der_l])</span>
        <span class="s1">assert_allclose([b(x[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b(x[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s1">[val </span><span class="s0">for </span><span class="s1">(nu</span><span class="s0">, </span><span class="s1">val) </span><span class="s0">in </span><span class="s1">der_r])</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">'unstable'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_cubic_deriv_unstable(self):</span>
        <span class="s2"># 1st and 2nd derivative at x[0], no derivative information at x[-1]</span>
        <span class="s2"># The problem is not that it fails [who would use this anyway],</span>
        <span class="s2"># the problem is that it fails *silently*, and I've no idea</span>
        <span class="s2"># how to detect this sort of instability.</span>
        <span class="s2"># In this particular case: it's OK for len(t) &lt; 20, goes haywire</span>
        <span class="s2"># at larger `len(t)`.</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">t = _augknt(self.xx</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">der_l = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">)]</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">bc_type=(der_l</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_knots_not_data_sites(self):</span>
        <span class="s2"># Knots need not coincide with the data sites.</span>
        <span class="s2"># use a quadratic spline, knots are at data averages,</span>
        <span class="s2"># two additional constraints are zero 2nd derivatives at edges</span>
        <span class="s1">k = </span><span class="s3">2</span>
        <span class="s1">t = np.r_[(self.xx[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)*(k+</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s1">(self.xx[</span><span class="s3">1</span><span class="s1">:] + self.xx[:-</span><span class="s3">1</span><span class="s1">]) / </span><span class="s3">2.</span><span class="s0">,</span>
                  <span class="s1">(self.xx[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)*(k+</span><span class="s3">1</span><span class="s1">)]</span>
        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t</span><span class="s0">,</span>
                               <span class="s1">bc_type=([(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]))</span>

        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">self.yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose([b(self.xx[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b(self.xx[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_minimum_points_and_deriv(self):</span>
        <span class="s2"># interpolation of f(x) = x**3 between 0 and 1. f'(x) = 3 * xx**2 and</span>
        <span class="s2"># f'(0) = 0, f'(1) = 3.</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">x = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span>
        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc_type=([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">)]))</span>

        <span class="s1">xx = np.linspace(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">)</span>
        <span class="s1">yy = xx**</span><span class="s3">3</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_deriv_spec(self):</span>
        <span class="s2"># If one of the derivatives is omitted, the spline definition is</span>
        <span class="s2"># incomplete.</span>
        <span class="s1">x = y = [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)]</span><span class="s0">, None</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)])</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s3">42</span><span class="s1">)</span>

        <span class="s2"># CubicSpline expects`bc_type=(left_pair, right_pair)`, while</span>
        <span class="s2"># here we expect `bc_type=(iterable, iterable)`.</span>
        <span class="s1">l</span><span class="s0">, </span><span class="s1">r = (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bc_type=(l</span><span class="s0">, </span><span class="s1">r))</span>

    <span class="s0">def </span><span class="s1">test_complex(self):</span>
        <span class="s1">k = </span><span class="s3">3</span>
        <span class="s1">xx = self.xx</span>
        <span class="s1">yy = self.yy + </span><span class="s3">1.j</span><span class="s1">*self.yy</span>

        <span class="s2"># first derivatives at left &amp; right edges:</span>
        <span class="s1">der_l</span><span class="s0">, </span><span class="s1">der_r = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3.j</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">+</span><span class="s3">2.j</span><span class="s1">)]</span>
        <span class="s1">b = make_interp_spline(xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc_type=(der_l</span><span class="s0">, </span><span class="s1">der_r))</span>
        <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose([b(xx[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b(xx[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s1">[der_l[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">der_r[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

        <span class="s2"># also test zero and first order</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">b = make_interp_spline(xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=k)</span>
            <span class="s1">assert_allclose(b(xx)</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_int_xy(self):</span>
        <span class="s1">x = np.arange(</span><span class="s3">10</span><span class="s1">).astype(np.int_)</span>
        <span class="s1">y = np.arange(</span><span class="s3">10</span><span class="s1">).astype(np.int_)</span>

        <span class="s2"># Cython chokes on &quot;buffer type mismatch&quot; (construction) or</span>
        <span class="s2"># &quot;no matching signature found&quot; (evaluation)</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">):</span>
            <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>
            <span class="s1">b(x)</span>

    <span class="s0">def </span><span class="s1">test_sliced_input(self):</span>
        <span class="s2"># Cython code chokes on non C contiguous arrays</span>
        <span class="s1">xx = np.linspace(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>

        <span class="s1">x = xx[::</span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">y = xx[::</span><span class="s3">5</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">):</span>
            <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>

    <span class="s0">def </span><span class="s1">test_check_finite(self):</span>
        <span class="s2"># check_finite defaults to True; nans and such trigger a ValueError</span>
        <span class="s1">x = np.arange(</span><span class="s3">10</span><span class="s1">).astype(float)</span>
        <span class="s1">y = x**</span><span class="s3">2</span>

        <span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]:</span>
            <span class="s1">y[-</span><span class="s3">1</span><span class="s1">] = z</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">make_interp_spline</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'k'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_list_input(self</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s2"># regression test for gh-8714: TypeError for x, y being lists and k=2</span>
        <span class="s1">x = list(range(</span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">y = [a**</span><span class="s3">2 </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">x]</span>
        <span class="s1">make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k=k)</span>

    <span class="s0">def </span><span class="s1">test_multiple_rhs(self):</span>
        <span class="s1">yy = np.c_[np.sin(self.xx)</span><span class="s0">, </span><span class="s1">np.cos(self.xx)]</span>
        <span class="s1">der_l = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">])]</span>
        <span class="s1">der_r = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">])]</span>

        <span class="s1">b = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=(der_l</span><span class="s0">, </span><span class="s1">der_r))</span>
        <span class="s1">assert_allclose(b(self.xx)</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">der_l[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b(self.xx[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">der_r[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_shapes(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">k</span><span class="s0">, </span><span class="s1">n = </span><span class="s3">3</span><span class="s0">, </span><span class="s3">22</span>
        <span class="s1">x = np.sort(np.random.random(size=n))</span>
        <span class="s1">y = np.random.random(size=(n</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>

        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">assert_equal(b.c.shape</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>

        <span class="s2"># now throw in some derivatives</span>
        <span class="s1">d_l = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.random.random((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)))]</span>
        <span class="s1">d_r = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.random.random((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)))]</span>
        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc_type=(d_l</span><span class="s0">, </span><span class="s1">d_r))</span>
        <span class="s1">assert_equal(b.c.shape</span><span class="s0">, </span><span class="s1">(n + k - </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_string_aliases(self):</span>
        <span class="s1">yy = np.sin(self.xx)</span>

        <span class="s2"># a single string is duplicated</span>
        <span class="s1">b1 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'natural'</span><span class="s1">)</span>
        <span class="s1">b2 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=([(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]))</span>
        <span class="s1">assert_allclose(b1.c</span><span class="s0">, </span><span class="s1">b2.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

        <span class="s2"># two strings are handled</span>
        <span class="s1">b1 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">,</span>
                                <span class="s1">bc_type=(</span><span class="s4">'natural'</span><span class="s0">, </span><span class="s4">'clamped'</span><span class="s1">))</span>
        <span class="s1">b2 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">,</span>
                                <span class="s1">bc_type=([(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]))</span>
        <span class="s1">assert_allclose(b1.c</span><span class="s0">, </span><span class="s1">b2.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

        <span class="s2"># one-sided BCs are OK</span>
        <span class="s1">b1 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">bc_type=(</span><span class="s0">None, </span><span class="s4">'clamped'</span><span class="s1">))</span>
        <span class="s1">b2 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">bc_type=(</span><span class="s0">None, </span><span class="s1">[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)]))</span>
        <span class="s1">assert_allclose(b1.c</span><span class="s0">, </span><span class="s1">b2.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

        <span class="s2"># 'not-a-knot' is equivalent to None</span>
        <span class="s1">b1 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'not-a-knot'</span><span class="s1">)</span>
        <span class="s1">b2 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b1.c</span><span class="s0">, </span><span class="s1">b2.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

        <span class="s2"># unknown strings do not pass</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'typo'</span><span class="s1">)</span>

        <span class="s2"># string aliases are handled for 2D values</span>
        <span class="s1">yy = np.c_[np.sin(self.xx)</span><span class="s0">, </span><span class="s1">np.cos(self.xx)]</span>
        <span class="s1">der_l = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">])]</span>
        <span class="s1">der_r = [(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">])]</span>
        <span class="s1">b2 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=(der_l</span><span class="s0">, </span><span class="s1">der_r))</span>
        <span class="s1">b1 = make_interp_spline(self.xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s0">,</span>
                                <span class="s1">bc_type=(</span><span class="s4">'clamped'</span><span class="s0">, </span><span class="s4">'natural'</span><span class="s1">))</span>
        <span class="s1">assert_allclose(b1.c</span><span class="s0">, </span><span class="s1">b2.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

        <span class="s2"># ... and for N-D values:</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">k</span><span class="s0">, </span><span class="s1">n = </span><span class="s3">3</span><span class="s0">, </span><span class="s3">22</span>
        <span class="s1">x = np.sort(np.random.random(size=n))</span>
        <span class="s1">y = np.random.random(size=(n</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>

        <span class="s2"># now throw in some derivatives</span>
        <span class="s1">d_l = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)))]</span>
        <span class="s1">d_r = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)))]</span>
        <span class="s1">b1 = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc_type=(d_l</span><span class="s0">, </span><span class="s1">d_r))</span>
        <span class="s1">b2 = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'clamped'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b1.c</span><span class="s0">, </span><span class="s1">b2.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_full_matrix(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">k</span><span class="s0">, </span><span class="s1">n = </span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span>
        <span class="s1">x = np.sort(np.random.random(size=n))</span>
        <span class="s1">y = np.random.random(size=n)</span>
        <span class="s1">t = _not_a_knot(x</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">b = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s1">cf = make_interp_full_matr(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">assert_allclose(b.c</span><span class="s0">, </span><span class="s1">cf</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_woodbury(self):</span>
        <span class="s5">''' 
        Random elements in diagonal matrix with blocks in the 
        left lower and right upper corners checking the 
        implementation of Woodbury algorithm. 
        '''</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">201</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
            <span class="s1">offset = int((k - </span><span class="s3">1</span><span class="s1">) / </span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">a = np.diagflat(np.random.random((</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n)))</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">offset + </span><span class="s3">1</span><span class="s1">):</span>
                <span class="s1">a[:-i</span><span class="s0">, </span><span class="s1">i:] += np.diagflat(np.random.random((</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n - i)))</span>
                <span class="s1">a[i:</span><span class="s0">, </span><span class="s1">:-i] += np.diagflat(np.random.random((</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n - i)))</span>
            <span class="s1">ur = np.random.random((offset</span><span class="s0">, </span><span class="s1">offset))</span>
            <span class="s1">a[:offset</span><span class="s0">, </span><span class="s1">-offset:] = ur</span>
            <span class="s1">ll = np.random.random((offset</span><span class="s0">, </span><span class="s1">offset))</span>
            <span class="s1">a[-offset:</span><span class="s0">, </span><span class="s1">:offset] = ll</span>
            <span class="s1">d = np.zeros((k</span><span class="s0">, </span><span class="s1">n))</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">enumerate(range(offset</span><span class="s0">, </span><span class="s1">-offset - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)):</span>
                <span class="s0">if </span><span class="s1">j &lt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">d[i</span><span class="s0">, </span><span class="s1">:j] = np.diagonal(a</span><span class="s0">, </span><span class="s1">offset=j)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">d[i</span><span class="s0">, </span><span class="s1">j:] = np.diagonal(a</span><span class="s0">, </span><span class="s1">offset=j)</span>
            <span class="s1">b = np.random.random(n)</span>
            <span class="s1">assert_allclose(_woodbury_algorithm(d</span><span class="s0">, </span><span class="s1">ur</span><span class="s0">, </span><span class="s1">ll</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">,</span>
                            <span class="s1">np.linalg.solve(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">make_interp_full_matr(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s5">&quot;&quot;&quot;Assemble an spline order k with knots t to interpolate 
    y(x) using full matrices. 
    Not-a-knot BC only. 
 
    This routine is here for testing only (even though it's functional). 
    &quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">x.size == y.size</span>
    <span class="s0">assert </span><span class="s1">t.size == x.size + k + </span><span class="s3">1</span>
    <span class="s1">n = x.size</span>

    <span class="s1">A = np.zeros((n</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=np.float_)</span>

    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(n):</span>
        <span class="s1">xval = x[j]</span>
        <span class="s0">if </span><span class="s1">xval == t[k]:</span>
            <span class="s1">left = k</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">left = np.searchsorted(t</span><span class="s0">, </span><span class="s1">xval) - </span><span class="s3">1</span>

        <span class="s2"># fill a row</span>
        <span class="s1">bb = _bspl.evaluate_all_bspl(t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">xval</span><span class="s0">, </span><span class="s1">left)</span>
        <span class="s1">A[j</span><span class="s0">, </span><span class="s1">left-k:left+</span><span class="s3">1</span><span class="s1">] = bb</span>

    <span class="s1">c = sl.solve(A</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s0">return </span><span class="s1">c</span>


<span class="s0">def </span><span class="s1">make_lsq_full_matrix(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">3</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Make the least-square spline, full matrices.&quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t = map(np.asarray</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t))</span>
    <span class="s1">m = x.size</span>
    <span class="s1">n = t.size - k - </span><span class="s3">1</span>

    <span class="s1">A = np.zeros((m</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=np.float_)</span>

    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(m):</span>
        <span class="s1">xval = x[j]</span>
        <span class="s2"># find interval</span>
        <span class="s0">if </span><span class="s1">xval == t[k]:</span>
            <span class="s1">left = k</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">left = np.searchsorted(t</span><span class="s0">, </span><span class="s1">xval) - </span><span class="s3">1</span>

        <span class="s2"># fill a row</span>
        <span class="s1">bb = _bspl.evaluate_all_bspl(t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">xval</span><span class="s0">, </span><span class="s1">left)</span>
        <span class="s1">A[j</span><span class="s0">, </span><span class="s1">left-k:left+</span><span class="s3">1</span><span class="s1">] = bb</span>

    <span class="s2"># have observation matrix, can solve the LSQ problem</span>
    <span class="s1">B = np.dot(A.T</span><span class="s0">, </span><span class="s1">A)</span>
    <span class="s1">Y = np.dot(A.T</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">c = sl.solve(B</span><span class="s0">, </span><span class="s1">Y)</span>

    <span class="s0">return </span><span class="s1">c</span><span class="s0">, </span><span class="s1">(A</span><span class="s0">, </span><span class="s1">Y)</span>


<span class="s0">class </span><span class="s1">TestLSQ:</span>
    <span class="s2">#</span>
    <span class="s2"># Test make_lsq_spline</span>
    <span class="s2">#</span>
    <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">n</span><span class="s0">, </span><span class="s1">k = </span><span class="s3">13</span><span class="s0">, </span><span class="s3">3</span>
    <span class="s1">x = np.sort(np.random.random(n))</span>
    <span class="s1">y = np.random.random(n)</span>
    <span class="s1">t = _augknt(np.linspace(x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">k)</span>

    <span class="s0">def </span><span class="s1">test_lstsq(self):</span>
        <span class="s2"># check LSQ construction vs a full matrix version</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k = self.x</span><span class="s0">, </span><span class="s1">self.y</span><span class="s0">, </span><span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.k</span>

        <span class="s1">c0</span><span class="s0">, </span><span class="s1">AY = make_lsq_full_matrix(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">b = make_lsq_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">assert_allclose(b.c</span><span class="s0">, </span><span class="s1">c0)</span>
        <span class="s1">assert_equal(b.c.shape</span><span class="s0">, </span><span class="s1">(t.size - k - </span><span class="s3">1</span><span class="s0">,</span><span class="s1">))</span>

        <span class="s2"># also check against numpy.lstsq</span>
        <span class="s1">aa</span><span class="s0">, </span><span class="s1">yy = AY</span>
        <span class="s1">c1</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = np.linalg.lstsq(aa</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">rcond=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.c</span><span class="s0">, </span><span class="s1">c1)</span>

    <span class="s0">def </span><span class="s1">test_weights(self):</span>
        <span class="s2"># weights = 1 is same as None</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k = self.x</span><span class="s0">, </span><span class="s1">self.y</span><span class="s0">, </span><span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.k</span>
        <span class="s1">w = np.ones_like(x)</span>

        <span class="s1">b = make_lsq_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">b_w = make_lsq_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">w=w)</span>

        <span class="s1">assert_allclose(b.t</span><span class="s0">, </span><span class="s1">b_w.t</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.c</span><span class="s0">, </span><span class="s1">b_w.c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_equal(b.k</span><span class="s0">, </span><span class="s1">b_w.k)</span>

    <span class="s0">def </span><span class="s1">test_multiple_rhs(self):</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">n = self.x</span><span class="s0">, </span><span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.k</span><span class="s0">, </span><span class="s1">self.n</span>
        <span class="s1">y = np.random.random(size=(n</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>

        <span class="s1">b = make_lsq_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">assert_equal(b.c.shape</span><span class="s0">, </span><span class="s1">(t.size-k-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_complex(self):</span>
        <span class="s2"># cmplx-valued `y`</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k = self.x</span><span class="s0">, </span><span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.k</span>
        <span class="s1">yc = self.y * (</span><span class="s3">1. </span><span class="s1">+ </span><span class="s3">2.j</span><span class="s1">)</span>

        <span class="s1">b = make_lsq_spline(x</span><span class="s0">, </span><span class="s1">yc</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">b_re = make_lsq_spline(x</span><span class="s0">, </span><span class="s1">yc.real</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">b_im = make_lsq_spline(x</span><span class="s0">, </span><span class="s1">yc.imag</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">assert_allclose(b(x)</span><span class="s0">, </span><span class="s1">b_re(x) + </span><span class="s3">1.j</span><span class="s1">*b_im(x)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-15</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_int_xy(self):</span>
        <span class="s1">x = np.arange(</span><span class="s3">10</span><span class="s1">).astype(np.int_)</span>
        <span class="s1">y = np.arange(</span><span class="s3">10</span><span class="s1">).astype(np.int_)</span>
        <span class="s1">t = _augknt(x</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s2"># Cython chokes on &quot;buffer type mismatch&quot;</span>
        <span class="s1">make_lsq_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sliced_input(self):</span>
        <span class="s2"># Cython code chokes on non C contiguous arrays</span>
        <span class="s1">xx = np.linspace(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>

        <span class="s1">x = xx[::</span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">y = xx[::</span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">t = _augknt(x</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">make_lsq_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_checkfinite(self):</span>
        <span class="s2"># check_finite defaults to True; nans and such trigger a ValueError</span>
        <span class="s1">x = np.arange(</span><span class="s3">12</span><span class="s1">).astype(float)</span>
        <span class="s1">y = x**</span><span class="s3">2</span>
        <span class="s1">t = _augknt(x</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]:</span>
            <span class="s1">y[-</span><span class="s3">1</span><span class="s1">] = z</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">make_lsq_spline</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t)</span>

    <span class="s0">def </span><span class="s1">test_read_only(self):</span>
        <span class="s2"># Check that make_lsq_spline works with read only arrays</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t = self.x</span><span class="s0">, </span><span class="s1">self.y</span><span class="s0">, </span><span class="s1">self.t</span>
        <span class="s1">x.setflags(write=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">y.setflags(write=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">t.setflags(write=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">make_lsq_spline(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">t=t)</span>

<span class="s0">def </span><span class="s1">data_file(basename):</span>
    <span class="s0">return </span><span class="s1">os.path.join(os.path.abspath(os.path.dirname(__file__))</span><span class="s0">,</span>
                        <span class="s4">'data'</span><span class="s0">, </span><span class="s1">basename)</span>


<span class="s0">class </span><span class="s1">TestSmoothingSpline:</span>
    <span class="s2">#</span>
    <span class="s2"># test make_smoothing_spline</span>
    <span class="s2">#</span>
    <span class="s0">def </span><span class="s1">test_invalid_input(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">100</span>
        <span class="s1">x = np.sort(np.random.random_sample(n) * </span><span class="s3">4 </span><span class="s1">- </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">y = x**</span><span class="s3">2 </span><span class="s1">* np.sin(</span><span class="s3">4 </span><span class="s1">* x) + x**</span><span class="s3">3 </span><span class="s1">+ np.random.normal(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s1">n)</span>

        <span class="s2"># ``x`` and ``y`` should have same shapes (1-D array)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_smoothing_spline(x</span><span class="s0">, </span><span class="s1">y[</span><span class="s3">1</span><span class="s1">:])</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_smoothing_spline(x[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_smoothing_spline(x.reshape(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s2"># ``x`` should be an ascending array</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_smoothing_spline(x[::-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">x_dupl = np.copy(x)</span>
        <span class="s1">x_dupl[</span><span class="s3">0</span><span class="s1">] = x_dupl[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">make_smoothing_spline(x_dupl</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s2"># x and y length must be larger than 5</span>
        <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">y = np.ones(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">exception_message = </span><span class="s4">&quot;``x`` and ``y`` length must be larger than 5&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=exception_message):</span>
            <span class="s1">make_smoothing_spline(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_compare_with_GCVSPL(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Data is generated in the following way: 
        &gt;&gt;&gt; np.random.seed(1234) 
        &gt;&gt;&gt; n = 100 
        &gt;&gt;&gt; x = np.sort(np.random.random_sample(n) * 4 - 2) 
        &gt;&gt;&gt; y = np.sin(x) + np.random.normal(scale=.5, size=n) 
        &gt;&gt;&gt; np.savetxt('x.csv', x) 
        &gt;&gt;&gt; np.savetxt('y.csv', y) 
 
        We obtain the result of performing the GCV smoothing splines 
        package (by Woltring, gcvspl) on the sample data points 
        using its version for Octave (https://github.com/srkuberski/gcvspl). 
        In order to use this implementation, one should clone the repository 
        and open the folder in Octave. 
        In Octave, we load up ``x`` and ``y`` (generated from Python code 
        above): 
 
        &gt;&gt;&gt; x = csvread('x.csv'); 
        &gt;&gt;&gt; y = csvread('y.csv'); 
 
        Then, in order to access the implementation, we compile gcvspl files in 
        Octave: 
 
        &gt;&gt;&gt; mex gcvsplmex.c gcvspl.c 
        &gt;&gt;&gt; mex spldermex.c gcvspl.c 
 
        The first function computes the vector of unknowns from the dataset 
        (x, y) while the second one evaluates the spline in certain points 
        with known vector of coefficients. 
 
        &gt;&gt;&gt; c = gcvsplmex( x, y, 2 ); 
        &gt;&gt;&gt; y0 = spldermex( x, c, 2, x, 0 ); 
 
        If we want to compare the results of the gcvspl code, we can save 
        ``y0`` in csv file: 
 
        &gt;&gt;&gt; csvwrite('y0.csv', y0); 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># load the data sample</span>
        <span class="s1">data = np.load(data_file(</span><span class="s4">'gcvspl.npz'</span><span class="s1">))</span>
        <span class="s2"># data points</span>
        <span class="s1">x = data[</span><span class="s4">'x'</span><span class="s1">]</span>
        <span class="s1">y = data[</span><span class="s4">'y'</span><span class="s1">]</span>

        <span class="s1">y_GCVSPL = data[</span><span class="s4">'y_GCVSPL'</span><span class="s1">]</span>
        <span class="s1">y_compr = make_smoothing_spline(x</span><span class="s0">, </span><span class="s1">y)(x)</span>

        <span class="s2"># such tolerance is explained by the fact that the spline is built</span>
        <span class="s2"># using an iterative algorithm for minimizing the GCV criteria. These</span>
        <span class="s2"># algorithms may vary, so the tolerance should be rather low.</span>
        <span class="s1">assert_allclose(y_compr</span><span class="s0">, </span><span class="s1">y_GCVSPL</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_non_regularized_case(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        In case the regularization parameter is 0, the resulting spline 
        is an interpolation spline with natural boundary conditions. 
        &quot;&quot;&quot;</span>
        <span class="s2"># create data sample</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">100</span>
        <span class="s1">x = np.sort(np.random.random_sample(n) * </span><span class="s3">4 </span><span class="s1">- </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">y = x**</span><span class="s3">2 </span><span class="s1">* np.sin(</span><span class="s3">4 </span><span class="s1">* x) + x**</span><span class="s3">3 </span><span class="s1">+ np.random.normal(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s1">n)</span>

        <span class="s1">spline_GCV = make_smoothing_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">lam=</span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s1">spline_interp = make_interp_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">bc_type=</span><span class="s4">'natural'</span><span class="s1">)</span>

        <span class="s1">grid = np.linspace(x[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* n)</span>
        <span class="s1">assert_allclose(spline_GCV(grid)</span><span class="s0">,</span>
                        <span class="s1">spline_interp(grid)</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_weighted_smoothing_spline(self):</span>
        <span class="s2"># create data sample</span>
        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">100</span>
        <span class="s1">x = np.sort(np.random.random_sample(n) * </span><span class="s3">4 </span><span class="s1">- </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">y = x**</span><span class="s3">2 </span><span class="s1">* np.sin(</span><span class="s3">4 </span><span class="s1">* x) + x**</span><span class="s3">3 </span><span class="s1">+ np.random.normal(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s1">n)</span>

        <span class="s1">spl = make_smoothing_spline(x</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s2"># in order not to iterate over all of the indices, we select 10 of</span>
        <span class="s2"># them randomly</span>
        <span class="s0">for </span><span class="s1">ind </span><span class="s0">in </span><span class="s1">np.random.choice(range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">size=</span><span class="s3">10</span><span class="s1">):</span>
            <span class="s1">w = np.ones(n)</span>
            <span class="s1">w[ind] = </span><span class="s3">30.</span>
            <span class="s1">spl_w = make_smoothing_spline(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">w)</span>
            <span class="s2"># check that spline with weight in a certain point is closer to the</span>
            <span class="s2"># original point than the one without weights</span>
            <span class="s1">orig = abs(spl(x[ind]) - y[ind])</span>
            <span class="s1">weighted = abs(spl_w(x[ind]) - y[ind])</span>

            <span class="s0">if </span><span class="s1">orig &lt; weighted:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f'Spline with weights should be closer to the'</span>
                                 <span class="s4">f' points than the original one: </span><span class="s0">{</span><span class="s1">orig</span><span class="s0">:</span><span class="s4">.4</span><span class="s0">} </span><span class="s4">&lt; '</span>
                                 <span class="s4">f'</span><span class="s0">{</span><span class="s1">weighted</span><span class="s0">:</span><span class="s4">.4</span><span class="s0">}</span><span class="s4">'</span><span class="s1">)</span>
</pre>
</body>
</html>