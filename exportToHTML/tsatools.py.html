<html>
<head>
<title>tsatools.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tsatools.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">statsmodels.compat.python </span><span class="s0">import </span><span class="s1">lrange</span><span class="s0">, </span><span class="s1">Literal</span>

<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">DataFrame</span>
<span class="s0">from </span><span class="s1">pandas.tseries </span><span class="s0">import </span><span class="s1">offsets</span>
<span class="s0">from </span><span class="s1">pandas.tseries.frequencies </span><span class="s0">import </span><span class="s1">to_offset</span>

<span class="s0">from </span><span class="s1">statsmodels.tools.data </span><span class="s0">import </span><span class="s1">_is_recarray</span><span class="s0">, </span><span class="s1">_is_using_pandas</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s0">import </span><span class="s1">ValueWarning</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.typing </span><span class="s0">import </span><span class="s1">NDArray</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.validation </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">array_like</span><span class="s0">,</span>
    <span class="s1">bool_like</span><span class="s0">,</span>
    <span class="s1">int_like</span><span class="s0">,</span>
    <span class="s1">string_like</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">__all__ = [</span>
    <span class="s2">&quot;lagmat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lagmat2ds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;add_trend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;duplication_matrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;elimination_matrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;commutation_matrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vec&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vech&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unvec&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unvech&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;freq_to_period&quot;</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s0">def </span><span class="s1">add_trend(x</span><span class="s0">, </span><span class="s1">trend=</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False, </span><span class="s1">has_constant=</span><span class="s2">&quot;skip&quot;</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Add a trend and/or constant to an array. 
 
    Parameters 
    ---------- 
    x : array_like 
        Original array of data. 
    trend : str {'n', 'c', 't', 'ct', 'ctt'} 
        The trend to add. 
 
        * 'n' add no trend. 
        * 'c' add constant only. 
        * 't' add trend only. 
        * 'ct' add constant and linear trend. 
        * 'ctt' add constant and linear and quadratic trend. 
    prepend : bool 
        If True, prepends the new data to the columns of X. 
    has_constant : str {'raise', 'add', 'skip'} 
        Controls what happens when trend is 'c' and a constant column already 
        exists in x. 'raise' will raise an error. 'add' will add a column of 
        1s. 'skip' will return the data without change. 'skip' is the default. 
 
    Returns 
    ------- 
    array_like 
        The original data with the additional trend columns.  If x is a 
        pandas Series or DataFrame, then the trend column names are 'const', 
        'trend' and 'trend_squared'. 
 
    See Also 
    -------- 
    statsmodels.tools.tools.add_constant 
        Add a constant column to an array. 
 
    Notes 
    ----- 
    Returns columns as ['ctt','ct','c'] whenever applicable. There is currently 
    no checking for an existing trend. 
    &quot;&quot;&quot;</span>
    <span class="s1">prepend = bool_like(prepend</span><span class="s0">, </span><span class="s2">&quot;prepend&quot;</span><span class="s1">)</span>
    <span class="s1">trend = string_like(trend</span><span class="s0">, </span><span class="s2">&quot;trend&quot;</span><span class="s0">, </span><span class="s1">options=(</span><span class="s2">&quot;n&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;t&quot;</span><span class="s0">, </span><span class="s2">&quot;ct&quot;</span><span class="s0">, </span><span class="s2">&quot;ctt&quot;</span><span class="s1">))</span>
    <span class="s1">has_constant = string_like(</span>
        <span class="s1">has_constant</span><span class="s0">, </span><span class="s2">&quot;has_constant&quot;</span><span class="s0">, </span><span class="s1">options=(</span><span class="s2">&quot;raise&quot;</span><span class="s0">, </span><span class="s2">&quot;add&quot;</span><span class="s0">, </span><span class="s2">&quot;skip&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s4"># TODO: could be generalized for trend of aribitrary order</span>
    <span class="s1">columns = [</span><span class="s2">&quot;const&quot;</span><span class="s0">, </span><span class="s2">&quot;trend&quot;</span><span class="s0">, </span><span class="s2">&quot;trend_squared&quot;</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">trend == </span><span class="s2">&quot;n&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">x.copy()</span>
    <span class="s0">elif </span><span class="s1">trend == </span><span class="s2">&quot;c&quot;</span><span class="s1">:  </span><span class="s4"># handles structured arrays</span>
        <span class="s1">columns = columns[:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">trendorder = </span><span class="s5">0</span>
    <span class="s0">elif </span><span class="s1">trend == </span><span class="s2">&quot;ct&quot; </span><span class="s0">or </span><span class="s1">trend == </span><span class="s2">&quot;t&quot;</span><span class="s1">:</span>
        <span class="s1">columns = columns[:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">trend == </span><span class="s2">&quot;t&quot;</span><span class="s1">:</span>
            <span class="s1">columns = columns[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">trendorder = </span><span class="s5">1</span>
    <span class="s0">elif </span><span class="s1">trend == </span><span class="s2">&quot;ctt&quot;</span><span class="s1">:</span>
        <span class="s1">trendorder = </span><span class="s5">2</span>

    <span class="s0">if </span><span class="s1">_is_recarray(x):</span>
        <span class="s0">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s0">import </span><span class="s1">recarray_exception</span>

        <span class="s0">raise </span><span class="s1">NotImplementedError(recarray_exception)</span>

    <span class="s1">is_pandas = _is_using_pandas(x</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">is_pandas:</span>
        <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">pd.Series):</span>
            <span class="s1">x = pd.DataFrame(x)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x = x.copy()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">x = np.asanyarray(x)</span>

    <span class="s1">nobs = len(x)</span>
    <span class="s1">trendarr = np.vander(</span>
        <span class="s1">np.arange(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nobs + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span><span class="s0">, </span><span class="s1">trendorder + </span><span class="s5">1</span>
    <span class="s1">)</span>
    <span class="s4"># put in order ctt</span>
    <span class="s1">trendarr = np.fliplr(trendarr)</span>
    <span class="s0">if </span><span class="s1">trend == </span><span class="s2">&quot;t&quot;</span><span class="s1">:</span>
        <span class="s1">trendarr = trendarr[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s2">&quot;c&quot; </span><span class="s0">in </span><span class="s1">trend:</span>
        <span class="s0">if </span><span class="s1">is_pandas:</span>
            <span class="s4"># Mixed type protection</span>
            <span class="s0">def </span><span class="s1">safe_is_const(s):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">np.ptp(s) == </span><span class="s5">0.0 </span><span class="s0">and </span><span class="s1">np.any(s != </span><span class="s5">0.0</span><span class="s1">)</span>
                <span class="s0">except</span><span class="s1">:</span>
                    <span class="s0">return False</span>

            <span class="s1">col_const = x.apply(safe_is_const</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ptp0 = np.ptp(np.asanyarray(x)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">col_is_const = ptp0 == </span><span class="s5">0</span>
            <span class="s1">nz_const = col_is_const &amp; (x[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">col_const = nz_const</span>

        <span class="s0">if </span><span class="s1">np.any(col_const):</span>
            <span class="s0">if </span><span class="s1">has_constant == </span><span class="s2">&quot;raise&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">base_err = </span><span class="s2">&quot;x is constant.&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">columns = np.arange(x.shape[</span><span class="s5">1</span><span class="s1">])[col_const]</span>
                    <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">pd.DataFrame):</span>
                        <span class="s1">columns = x.columns</span>
                    <span class="s1">const_cols = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join([str(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">columns])</span>
                    <span class="s1">base_err = (</span>
                        <span class="s2">&quot;x contains one or more constant columns. Column(s) &quot;</span>
                        <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">const_cols</span><span class="s0">} </span><span class="s2">are constant.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">msg = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">base_err</span><span class="s0">} </span><span class="s2">Adding a constant with trend='</span><span class="s0">{</span><span class="s1">trend</span><span class="s0">}</span><span class="s2">' is not allowed.&quot;</span>
                <span class="s0">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s0">elif </span><span class="s1">has_constant == </span><span class="s2">&quot;skip&quot;</span><span class="s1">:</span>
                <span class="s1">columns = columns[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s1">trendarr = trendarr[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">:]</span>

    <span class="s1">order = </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">prepend </span><span class="s0">else </span><span class="s1">-</span><span class="s5">1</span>
    <span class="s0">if </span><span class="s1">is_pandas:</span>
        <span class="s1">trendarr = pd.DataFrame(trendarr</span><span class="s0">, </span><span class="s1">index=x.index</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s1">x = [trendarr</span><span class="s0">, </span><span class="s1">x]</span>
        <span class="s1">x = pd.concat(x[::order]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">x = [trendarr</span><span class="s0">, </span><span class="s1">x]</span>
        <span class="s1">x = np.column_stack(x[::order])</span>

    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">add_lag(x</span><span class="s0">, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">lags=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">drop=</span><span class="s0">False, </span><span class="s1">insert=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns an array with lags included given an array. 
 
    Parameters 
    ---------- 
    x : array_like 
        An array or NumPy ndarray subclass. Can be either a 1d or 2d array with 
        observations in columns. 
    col : int or None 
        `col` can be an int of the zero-based column index. If it's a 
        1d array `col` can be None. 
    lags : int 
        The number of lags desired. 
    drop : bool 
        Whether to keep the contemporaneous variable for the data. 
    insert : bool or int 
        If True, inserts the lagged values after `col`. If False, appends 
        the data. If int inserts the lags at int. 
 
    Returns 
    ------- 
    array : ndarray 
        Array with lags 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; data = sm.datasets.macrodata.load() 
    &gt;&gt;&gt; data = data.data[['year','quarter','realgdp','cpi']] 
    &gt;&gt;&gt; data = sm.tsa.add_lag(data, 'realgdp', lags=2) 
 
    Notes 
    ----- 
    Trims the array both forward and backward, so that the array returned 
    so that the length of the returned array is len(`X`) - lags. The lags are 
    returned in increasing order, ie., t-1,t-2,...,t-lags 
    &quot;&quot;&quot;</span>
    <span class="s1">lags = int_like(lags</span><span class="s0">, </span><span class="s2">&quot;lags&quot;</span><span class="s1">)</span>
    <span class="s1">drop = bool_like(drop</span><span class="s0">, </span><span class="s2">&quot;drop&quot;</span><span class="s1">)</span>
    <span class="s1">x = array_like(x</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">col </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">col = </span><span class="s5">0</span>

    <span class="s4"># handle negative index</span>
    <span class="s0">if </span><span class="s1">col &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">col = x.shape[</span><span class="s5">1</span><span class="s1">] + col</span>
    <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">x = x[:</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s1">contemp = x[:</span><span class="s0">, </span><span class="s1">col]</span>

    <span class="s0">if </span><span class="s1">insert </span><span class="s0">is True</span><span class="s1">:</span>
        <span class="s1">ins_idx = col + </span><span class="s5">1</span>
    <span class="s0">elif </span><span class="s1">insert </span><span class="s0">is False</span><span class="s1">:</span>
        <span class="s1">ins_idx = x.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">insert &lt; </span><span class="s5">0</span><span class="s1">:  </span><span class="s4"># handle negative index</span>
            <span class="s1">insert = x.shape[</span><span class="s5">1</span><span class="s1">] + insert + </span><span class="s5">1</span>
        <span class="s0">if </span><span class="s1">insert &gt; x.shape[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">insert = x.shape[</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;insert &gt; number of variables, inserting at the&quot;</span>
                <span class="s2">&quot; last position&quot;</span><span class="s0">,</span>
                <span class="s1">ValueWarning</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">ins_idx = insert</span>

    <span class="s1">ndlags = lagmat(contemp</span><span class="s0">, </span><span class="s1">lags</span><span class="s0">, </span><span class="s1">trim=</span><span class="s2">&quot;Both&quot;</span><span class="s1">)</span>
    <span class="s1">first_cols = lrange(ins_idx)</span>
    <span class="s1">last_cols = lrange(ins_idx</span><span class="s0">, </span><span class="s1">x.shape[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">drop:</span>
        <span class="s0">if </span><span class="s1">col </span><span class="s0">in </span><span class="s1">first_cols:</span>
            <span class="s1">first_cols.pop(first_cols.index(col))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">last_cols.pop(last_cols.index(col))</span>
    <span class="s0">return </span><span class="s1">np.column_stack((x[lags:</span><span class="s0">, </span><span class="s1">first_cols]</span><span class="s0">, </span><span class="s1">ndlags</span><span class="s0">, </span><span class="s1">x[lags:</span><span class="s0">, </span><span class="s1">last_cols]))</span>


<span class="s0">def </span><span class="s1">detrend(x</span><span class="s0">, </span><span class="s1">order=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Detrend an array with a trend of given order along axis 0 or 1. 
 
    Parameters 
    ---------- 
    x : array_like, 1d or 2d 
        Data, if 2d, then each row or column is independently detrended with 
        the same trendorder, but independent trend estimates. 
    order : int 
        The polynomial order of the trend, zero is constant, one is 
        linear trend, two is quadratic trend. 
    axis : int 
        Axis can be either 0, observations by rows, or 1, observations by 
        columns. 
 
    Returns 
    ------- 
    ndarray 
        The detrended series is the residual of the linear regression of the 
        data on the trend of given order. 
    &quot;&quot;&quot;</span>
    <span class="s1">order = int_like(order</span><span class="s0">, </span><span class="s2">&quot;order&quot;</span><span class="s1">)</span>
    <span class="s1">axis = int_like(axis</span><span class="s0">, </span><span class="s2">&quot;axis&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">int(axis) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">x = x.T</span>
    <span class="s0">elif </span><span class="s1">x.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s2">&quot;x.ndim &gt; 2 is not implemented until it is needed&quot;</span>
        <span class="s1">)</span>

    <span class="s1">nobs = x.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">order == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># Special case demean</span>
        <span class="s1">resid = x - x.mean(axis=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">trends = np.vander(np.arange(float(nobs))</span><span class="s0">, </span><span class="s1">N=order + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">beta = np.linalg.pinv(trends).dot(x)</span>
        <span class="s1">resid = x - np.dot(trends</span><span class="s0">, </span><span class="s1">beta)</span>

    <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">int(axis) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">resid = resid.T</span>

    <span class="s0">return </span><span class="s1">resid</span>


<span class="s0">def </span><span class="s1">lagmat(x</span><span class="s0">,</span>
           <span class="s1">maxlag: int</span><span class="s0">,</span>
           <span class="s1">trim: Literal[</span><span class="s2">&quot;forward&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s0">, </span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s2">&quot;none&quot;</span><span class="s1">]=</span><span class="s2">'forward'</span><span class="s0">,</span>
           <span class="s1">original: Literal[</span><span class="s2">&quot;ex&quot;</span><span class="s0">, </span><span class="s2">&quot;sep&quot;</span><span class="s0">, </span><span class="s2">&quot;in&quot;</span><span class="s1">]=</span><span class="s2">&quot;ex&quot;</span><span class="s0">,</span>
           <span class="s1">use_pandas: bool=</span><span class="s0">False</span>
           <span class="s1">)-&gt; NDArray | DataFrame | tuple[NDArray</span><span class="s0">, </span><span class="s1">NDArray] | tuple[DataFrame</span><span class="s0">, </span><span class="s1">DataFrame]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Create 2d array of lags. 
 
    Parameters 
    ---------- 
    x : array_like 
        Data; if 2d, observation in rows and variables in columns. 
    maxlag : int 
        All lags from zero to maxlag are included. 
    trim : {'forward', 'backward', 'both', 'none', None} 
        The trimming method to use. 
 
        * 'forward' : trim invalid observations in front. 
        * 'backward' : trim invalid initial observations. 
        * 'both' : trim invalid observations on both sides. 
        * 'none', None : no trimming of observations. 
    original : {'ex','sep','in'} 
        How the original is treated. 
 
        * 'ex' : drops the original array returning only the lagged values. 
        * 'in' : returns the original array and the lagged values as a single 
          array. 
        * 'sep' : returns a tuple (original array, lagged values). The original 
                  array is truncated to have the same number of rows as 
                  the returned lagmat. 
    use_pandas : bool 
        If true, returns a DataFrame when the input is a pandas 
        Series or DataFrame.  If false, return numpy ndarrays. 
 
    Returns 
    ------- 
    lagmat : ndarray 
        The array with lagged observations. 
    y : ndarray, optional 
        Only returned if original == 'sep'. 
 
    Notes 
    ----- 
    When using a pandas DataFrame or Series with use_pandas=True, trim can only 
    be 'forward' or 'both' since it is not possible to consistently extend 
    index values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from statsmodels.tsa.tsatools import lagmat 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; X = np.arange(1,7).reshape(-1,2) 
    &gt;&gt;&gt; lagmat(X, maxlag=2, trim=&quot;forward&quot;, original='in') 
    array([[ 1.,  2.,  0.,  0.,  0.,  0.], 
       [ 3.,  4.,  1.,  2.,  0.,  0.], 
       [ 5.,  6.,  3.,  4.,  1.,  2.]]) 
 
    &gt;&gt;&gt; lagmat(X, maxlag=2, trim=&quot;backward&quot;, original='in') 
    array([[ 5.,  6.,  3.,  4.,  1.,  2.], 
       [ 0.,  0.,  5.,  6.,  3.,  4.], 
       [ 0.,  0.,  0.,  0.,  5.,  6.]]) 
 
    &gt;&gt;&gt; lagmat(X, maxlag=2, trim=&quot;both&quot;, original='in') 
    array([[ 5.,  6.,  3.,  4.,  1.,  2.]]) 
 
    &gt;&gt;&gt; lagmat(X, maxlag=2, trim=&quot;none&quot;, original='in') 
    array([[ 1.,  2.,  0.,  0.,  0.,  0.], 
       [ 3.,  4.,  1.,  2.,  0.,  0.], 
       [ 5.,  6.,  3.,  4.,  1.,  2.], 
       [ 0.,  0.,  5.,  6.,  3.,  4.], 
       [ 0.,  0.,  0.,  0.,  5.,  6.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">maxlag = int_like(maxlag</span><span class="s0">, </span><span class="s2">&quot;maxlag&quot;</span><span class="s1">)</span>
    <span class="s1">use_pandas = bool_like(use_pandas</span><span class="s0">, </span><span class="s2">&quot;use_pandas&quot;</span><span class="s1">)</span>
    <span class="s1">trim = string_like(</span>
        <span class="s1">trim</span><span class="s0">,</span>
        <span class="s2">&quot;trim&quot;</span><span class="s0">,</span>
        <span class="s1">optional=</span><span class="s0">True,</span>
        <span class="s1">options=(</span><span class="s2">&quot;forward&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s0">, </span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s2">&quot;none&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">original = string_like(original</span><span class="s0">, </span><span class="s2">&quot;original&quot;</span><span class="s0">, </span><span class="s1">options=(</span><span class="s2">&quot;ex&quot;</span><span class="s0">, </span><span class="s2">&quot;sep&quot;</span><span class="s0">, </span><span class="s2">&quot;in&quot;</span><span class="s1">))</span>

    <span class="s4"># TODO:  allow list of lags additional to maxlag</span>
    <span class="s1">orig = x</span>
    <span class="s1">x = array_like(x</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">is_pandas = _is_using_pandas(orig</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">use_pandas</span>
    <span class="s1">trim = </span><span class="s2">&quot;none&quot; </span><span class="s0">if </span><span class="s1">trim </span><span class="s0">is None else </span><span class="s1">trim</span>
    <span class="s1">trim = trim.lower()</span>
    <span class="s0">if </span><span class="s1">is_pandas </span><span class="s0">and </span><span class="s1">trim </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;trim cannot be 'none' or 'backward' when used on &quot;</span>
            <span class="s2">&quot;Series or DataFrames&quot;</span>
        <span class="s1">)</span>

    <span class="s1">dropidx = </span><span class="s5">0</span>
    <span class="s1">nobs</span><span class="s0">, </span><span class="s1">nvar = x.shape</span>
    <span class="s0">if </span><span class="s1">original </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;ex&quot;</span><span class="s0">, </span><span class="s2">&quot;sep&quot;</span><span class="s1">]:</span>
        <span class="s1">dropidx = nvar</span>
    <span class="s0">if </span><span class="s1">maxlag &gt;= nobs:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;maxlag should be &lt; nobs&quot;</span><span class="s1">)</span>
    <span class="s1">lm = np.zeros((nobs + maxlag</span><span class="s0">, </span><span class="s1">nvar * (maxlag + </span><span class="s5">1</span><span class="s1">)))</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">int(maxlag + </span><span class="s5">1</span><span class="s1">)):</span>
        <span class="s1">lm[</span>
        <span class="s1">maxlag - k: nobs + maxlag - k</span><span class="s0">,</span>
        <span class="s1">nvar * (maxlag - k): nvar * (maxlag - k + </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">] = x</span>

    <span class="s0">if </span><span class="s1">trim </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;forward&quot;</span><span class="s1">):</span>
        <span class="s1">startobs = </span><span class="s5">0</span>
    <span class="s0">elif </span><span class="s1">trim </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;backward&quot;</span><span class="s0">, </span><span class="s2">&quot;both&quot;</span><span class="s1">):</span>
        <span class="s1">startobs = maxlag</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;trim option not valid&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">trim </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s1">):</span>
        <span class="s1">stopobs = len(lm)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">stopobs = nobs</span>

    <span class="s0">if </span><span class="s1">is_pandas:</span>
        <span class="s1">x = orig</span>
        <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">DataFrame):</span>
            <span class="s1">x_columns = [str(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">x.columns]</span>
            <span class="s0">if </span><span class="s1">len(set(x_columns)) != x.shape[</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Columns names must be distinct after conversion to string &quot;</span>
                    <span class="s2">&quot;(if not already strings).&quot;</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x_columns = [str(x.name)]</span>
        <span class="s1">columns = [str(col) </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">x_columns]</span>
        <span class="s0">for </span><span class="s1">lag </span><span class="s0">in </span><span class="s1">range(maxlag):</span>
            <span class="s1">lag_str = str(lag + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">columns.extend([str(col) + </span><span class="s2">&quot;.L.&quot; </span><span class="s1">+ lag_str </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">x_columns])</span>
        <span class="s1">lm = DataFrame(lm[:stopobs]</span><span class="s0">, </span><span class="s1">index=x.index</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s1">lags = lm.iloc[startobs:]</span>
        <span class="s0">if </span><span class="s1">original </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;sep&quot;</span><span class="s0">, </span><span class="s2">&quot;ex&quot;</span><span class="s1">):</span>
            <span class="s1">leads = lags[x_columns]</span>
            <span class="s1">lags = lags.drop(x_columns</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">lags = lm[startobs:stopobs</span><span class="s0">, </span><span class="s1">dropidx:]</span>
        <span class="s0">if </span><span class="s1">original == </span><span class="s2">&quot;sep&quot;</span><span class="s1">:</span>
            <span class="s1">leads = lm[startobs:stopobs</span><span class="s0">, </span><span class="s1">:dropidx]</span>

    <span class="s0">if </span><span class="s1">original == </span><span class="s2">&quot;sep&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">lags</span><span class="s0">, </span><span class="s1">leads</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">lags</span>


<span class="s0">def </span><span class="s1">lagmat2ds(</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">maxlag0</span><span class="s0">, </span><span class="s1">maxlagex=</span><span class="s0">None, </span><span class="s1">dropex=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">trim=</span><span class="s2">&quot;forward&quot;</span><span class="s0">, </span><span class="s1">use_pandas=</span><span class="s0">False</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Generate lagmatrix for 2d array, columns arranged by variables. 
 
    Parameters 
    ---------- 
    x : array_like 
        Data, 2d. Observations in rows and variables in columns. 
    maxlag0 : int 
        The first variable all lags from zero to maxlag are included. 
    maxlagex : {None, int} 
        The max lag for all other variables all lags from zero to maxlag are 
        included. 
    dropex : int 
        Exclude first dropex lags from other variables. For all variables, 
        except the first, lags from dropex to maxlagex are included. 
    trim : str 
        The trimming method to use. 
 
        * 'forward' : trim invalid observations in front. 
        * 'backward' : trim invalid initial observations. 
        * 'both' : trim invalid observations on both sides. 
        * 'none' : no trimming of observations. 
    use_pandas : bool 
        If true, returns a DataFrame when the input is a pandas 
        Series or DataFrame.  If false, return numpy ndarrays. 
 
    Returns 
    ------- 
    ndarray 
        The array with lagged observations, columns ordered by variable. 
 
    Notes 
    ----- 
    Inefficient implementation for unequal lags, implemented for convenience. 
    &quot;&quot;&quot;</span>
    <span class="s1">maxlag0 = int_like(maxlag0</span><span class="s0">, </span><span class="s2">&quot;maxlag0&quot;</span><span class="s1">)</span>
    <span class="s1">maxlagex = int_like(maxlagex</span><span class="s0">, </span><span class="s2">&quot;maxlagex&quot;</span><span class="s0">, </span><span class="s1">optional=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">trim = string_like(</span>
        <span class="s1">trim</span><span class="s0">,</span>
        <span class="s2">&quot;trim&quot;</span><span class="s0">,</span>
        <span class="s1">optional=</span><span class="s0">True,</span>
        <span class="s1">options=(</span><span class="s2">&quot;forward&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s0">, </span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s2">&quot;none&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">maxlagex </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">maxlagex = maxlag0</span>
    <span class="s1">maxlag = max(maxlag0</span><span class="s0">, </span><span class="s1">maxlagex)</span>
    <span class="s1">is_pandas = _is_using_pandas(x</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">is_pandas:</span>
            <span class="s1">x = pd.DataFrame(x)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x = x[:</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s0">elif </span><span class="s1">x.ndim == </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">x.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Only supports 1 and 2-dimensional data.&quot;</span><span class="s1">)</span>

    <span class="s1">nobs</span><span class="s0">, </span><span class="s1">nvar = x.shape</span>

    <span class="s0">if </span><span class="s1">is_pandas </span><span class="s0">and </span><span class="s1">use_pandas:</span>
        <span class="s1">lags = lagmat(</span>
            <span class="s1">x.iloc[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">maxlag</span><span class="s0">, </span><span class="s1">trim=trim</span><span class="s0">, </span><span class="s1">original=</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s1">use_pandas=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">lagsli = [lags.iloc[:</span><span class="s0">, </span><span class="s1">: maxlag0 + </span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nvar):</span>
            <span class="s1">lags = lagmat(</span>
                <span class="s1">x.iloc[:</span><span class="s0">, </span><span class="s1">k]</span><span class="s0">, </span><span class="s1">maxlag</span><span class="s0">, </span><span class="s1">trim=trim</span><span class="s0">, </span><span class="s1">original=</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s1">use_pandas=</span><span class="s0">True</span>
            <span class="s1">)</span>
            <span class="s1">lagsli.append(lags.iloc[:</span><span class="s0">, </span><span class="s1">dropex : maxlagex + </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">pd.concat(lagsli</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">is_pandas:</span>
        <span class="s1">x = np.asanyarray(x)</span>

    <span class="s1">lagsli = [</span>
        <span class="s1">lagmat(x[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">maxlag</span><span class="s0">, </span><span class="s1">trim=trim</span><span class="s0">, </span><span class="s1">original=</span><span class="s2">&quot;in&quot;</span><span class="s1">)[:</span><span class="s0">, </span><span class="s1">: maxlag0 + </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">]</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nvar):</span>
        <span class="s1">lagsli.append(</span>
            <span class="s1">lagmat(x[:</span><span class="s0">, </span><span class="s1">k]</span><span class="s0">, </span><span class="s1">maxlag</span><span class="s0">, </span><span class="s1">trim=trim</span><span class="s0">, </span><span class="s1">original=</span><span class="s2">&quot;in&quot;</span><span class="s1">)[</span>
                <span class="s1">:</span><span class="s0">, </span><span class="s1">dropex : maxlagex + </span><span class="s5">1</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">np.column_stack(lagsli)</span>


<span class="s0">def </span><span class="s1">vec(mat):</span>
    <span class="s0">return </span><span class="s1">mat.ravel(</span><span class="s2">&quot;F&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">vech(mat):</span>
    <span class="s4"># Gets Fortran-order</span>
    <span class="s0">return </span><span class="s1">mat.T.take(_triu_indices(len(mat)))</span>


<span class="s4"># tril/triu/diag, suitable for ndarray.take</span>


<span class="s0">def </span><span class="s1">_tril_indices(n):</span>
    <span class="s1">rows</span><span class="s0">, </span><span class="s1">cols = np.tril_indices(n)</span>
    <span class="s0">return </span><span class="s1">rows * n + cols</span>


<span class="s0">def </span><span class="s1">_triu_indices(n):</span>
    <span class="s1">rows</span><span class="s0">, </span><span class="s1">cols = np.triu_indices(n)</span>
    <span class="s0">return </span><span class="s1">rows * n + cols</span>


<span class="s0">def </span><span class="s1">_diag_indices(n):</span>
    <span class="s1">rows</span><span class="s0">, </span><span class="s1">cols = np.diag_indices(n)</span>
    <span class="s0">return </span><span class="s1">rows * n + cols</span>


<span class="s0">def </span><span class="s1">unvec(v):</span>
    <span class="s1">k = int(np.sqrt(len(v)))</span>
    <span class="s0">assert </span><span class="s1">k * k == len(v)</span>
    <span class="s0">return </span><span class="s1">v.reshape((k</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">&quot;F&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">unvech(v):</span>
    <span class="s4"># quadratic formula, correct fp error</span>
    <span class="s1">rows = </span><span class="s5">0.5 </span><span class="s1">* (-</span><span class="s5">1 </span><span class="s1">+ np.sqrt(</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">8 </span><span class="s1">* len(v)))</span>
    <span class="s1">rows = int(np.round(rows))</span>

    <span class="s1">result = np.zeros((rows</span><span class="s0">, </span><span class="s1">rows))</span>
    <span class="s1">result[np.triu_indices(rows)] = v</span>
    <span class="s1">result = result + result.T</span>

    <span class="s4"># divide diagonal elements by 2</span>
    <span class="s1">result[np.diag_indices(rows)] /= </span><span class="s5">2</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">duplication_matrix(n):</span>
    <span class="s3">&quot;&quot;&quot; 
    Create duplication matrix D_n which satisfies vec(S) = D_n vech(S) for 
    symmetric matrix S 
 
    Returns 
    ------- 
    D_n : ndarray 
    &quot;&quot;&quot;</span>
    <span class="s1">n = int_like(n</span><span class="s0">, </span><span class="s2">&quot;n&quot;</span><span class="s1">)</span>
    <span class="s1">tmp = np.eye(n * (n + </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">np.array([unvech(x).ravel() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tmp]).T</span>


<span class="s0">def </span><span class="s1">elimination_matrix(n):</span>
    <span class="s3">&quot;&quot;&quot; 
    Create the elimination matrix L_n which satisfies vech(M) = L_n vec(M) for 
    any matrix M 
 
    Parameters 
    ---------- 
 
    Returns 
    ------- 
    &quot;&quot;&quot;</span>
    <span class="s1">n = int_like(n</span><span class="s0">, </span><span class="s2">&quot;n&quot;</span><span class="s1">)</span>
    <span class="s1">vech_indices = vec(np.tril(np.ones((n</span><span class="s0">, </span><span class="s1">n))))</span>
    <span class="s0">return </span><span class="s1">np.eye(n * n)[vech_indices != </span><span class="s5">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">commutation_matrix(p</span><span class="s0">, </span><span class="s1">q):</span>
    <span class="s3">&quot;&quot;&quot; 
    Create the commutation matrix K_{p,q} satisfying vec(A') = K_{p,q} vec(A) 
 
    Parameters 
    ---------- 
    p : int 
    q : int 
 
    Returns 
    ------- 
    K : ndarray (pq x pq) 
    &quot;&quot;&quot;</span>
    <span class="s1">p = int_like(p</span><span class="s0">, </span><span class="s2">&quot;p&quot;</span><span class="s1">)</span>
    <span class="s1">q = int_like(q</span><span class="s0">, </span><span class="s2">&quot;q&quot;</span><span class="s1">)</span>

    <span class="s1">K = np.eye(p * q)</span>
    <span class="s1">indices = np.arange(p * q).reshape((p</span><span class="s0">, </span><span class="s1">q)</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">&quot;F&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">K.take(indices.ravel()</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_ar_transparams(params):</span>
    <span class="s3">&quot;&quot;&quot; 
    Transforms params to induce stationarity/invertability. 
 
    Parameters 
    ---------- 
    params : array_like 
        The AR coefficients 
 
    Reference 
    --------- 
    Jones(1980) 
    &quot;&quot;&quot;</span>
    <span class="s1">newparams = np.tanh(params / </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">tmp = np.tanh(params / </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">len(params)):</span>
        <span class="s1">a = newparams[j]</span>
        <span class="s0">for </span><span class="s1">kiter </span><span class="s0">in </span><span class="s1">range(j):</span>
            <span class="s1">tmp[kiter] -= a * newparams[j - kiter - </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">newparams[:j] = tmp[:j]</span>
    <span class="s0">return </span><span class="s1">newparams</span>


<span class="s0">def </span><span class="s1">_ar_invtransparams(params):</span>
    <span class="s3">&quot;&quot;&quot; 
    Inverse of the Jones reparameterization 
 
    Parameters 
    ---------- 
    params : array_like 
        The transformed AR coefficients 
    &quot;&quot;&quot;</span>
    <span class="s1">params = params.copy()</span>
    <span class="s1">tmp = params.copy()</span>
    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(len(params) - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">a = params[j]</span>
        <span class="s0">for </span><span class="s1">kiter </span><span class="s0">in </span><span class="s1">range(j):</span>
            <span class="s1">tmp[kiter] = (params[kiter] + a * params[j - kiter - </span><span class="s5">1</span><span class="s1">]) / (</span>
                <span class="s5">1 </span><span class="s1">- a ** </span><span class="s5">2</span>
            <span class="s1">)</span>
        <span class="s1">params[:j] = tmp[:j]</span>
    <span class="s1">invarcoefs = </span><span class="s5">2 </span><span class="s1">* np.arctanh(params)</span>
    <span class="s0">return </span><span class="s1">invarcoefs</span>


<span class="s0">def </span><span class="s1">_ma_transparams(params):</span>
    <span class="s3">&quot;&quot;&quot; 
    Transforms params to induce stationarity/invertability. 
 
    Parameters 
    ---------- 
    params : ndarray 
        The ma coeffecients of an (AR)MA model. 
 
    Reference 
    --------- 
    Jones(1980) 
    &quot;&quot;&quot;</span>
    <span class="s1">newparams = ((</span><span class="s5">1 </span><span class="s1">- np.exp(-params)) / (</span><span class="s5">1 </span><span class="s1">+ np.exp(-params))).copy()</span>
    <span class="s1">tmp = ((</span><span class="s5">1 </span><span class="s1">- np.exp(-params)) / (</span><span class="s5">1 </span><span class="s1">+ np.exp(-params))).copy()</span>

    <span class="s4"># levinson-durbin to get macf</span>
    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">len(params)):</span>
        <span class="s1">b = newparams[j]</span>
        <span class="s0">for </span><span class="s1">kiter </span><span class="s0">in </span><span class="s1">range(j):</span>
            <span class="s1">tmp[kiter] += b * newparams[j - kiter - </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">newparams[:j] = tmp[:j]</span>
    <span class="s0">return </span><span class="s1">newparams</span>


<span class="s0">def </span><span class="s1">_ma_invtransparams(macoefs):</span>
    <span class="s3">&quot;&quot;&quot; 
    Inverse of the Jones reparameterization 
 
    Parameters 
    ---------- 
    params : ndarray 
        The transformed MA coefficients 
    &quot;&quot;&quot;</span>
    <span class="s1">tmp = macoefs.copy()</span>
    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(len(macoefs) - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">b = macoefs[j]</span>
        <span class="s0">for </span><span class="s1">kiter </span><span class="s0">in </span><span class="s1">range(j):</span>
            <span class="s1">tmp[kiter] = (macoefs[kiter] - b * macoefs[j - kiter - </span><span class="s5">1</span><span class="s1">]) / (</span>
                <span class="s5">1 </span><span class="s1">- b ** </span><span class="s5">2</span>
            <span class="s1">)</span>
        <span class="s1">macoefs[:j] = tmp[:j]</span>
    <span class="s1">invmacoefs = -np.log((</span><span class="s5">1 </span><span class="s1">- macoefs) / (</span><span class="s5">1 </span><span class="s1">+ macoefs))</span>
    <span class="s0">return </span><span class="s1">invmacoefs</span>


<span class="s0">def </span><span class="s1">unintegrate_levels(x</span><span class="s0">, </span><span class="s1">d):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns the successive differences needed to unintegrate the series. 
 
    Parameters 
    ---------- 
    x : array_like 
        The original series 
    d : int 
        The number of differences of the differenced series. 
 
    Returns 
    ------- 
    y : array_like 
        The increasing differences from 0 to d-1 of the first d elements 
        of x. 
 
    See Also 
    -------- 
    unintegrate 
    &quot;&quot;&quot;</span>
    <span class="s1">d = int_like(d</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">)</span>
    <span class="s1">x = x[:d]</span>
    <span class="s0">return </span><span class="s1">np.asarray([np.diff(x</span><span class="s0">, </span><span class="s1">d - i)[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(d</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)])</span>


<span class="s0">def </span><span class="s1">unintegrate(x</span><span class="s0">, </span><span class="s1">levels):</span>
    <span class="s3">&quot;&quot;&quot; 
    After taking n-differences of a series, return the original series 
 
    Parameters 
    ---------- 
    x : array_like 
        The n-th differenced series 
    levels : list 
        A list of the first-value in each differenced series, for 
        [first-difference, second-difference, ..., n-th difference] 
 
    Returns 
    ------- 
    y : array_like 
        The original series de-differenced 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.array([1, 3, 9., 19, 8.]) 
    &gt;&gt;&gt; levels = unintegrate_levels(x, 2) 
    &gt;&gt;&gt; levels 
    array([ 1.,  2.]) 
    &gt;&gt;&gt; unintegrate(np.diff(x, 2), levels) 
    array([  1.,   3.,   9.,  19.,   8.]) 
    &quot;&quot;&quot;</span>
    <span class="s1">levels = list(levels)[:]  </span><span class="s4"># copy</span>
    <span class="s0">if </span><span class="s1">len(levels) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">x0 = levels.pop(-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">unintegrate(np.cumsum(np.r_[x0</span><span class="s0">, </span><span class="s1">x])</span><span class="s0">, </span><span class="s1">levels)</span>
    <span class="s1">x0 = levels[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">np.cumsum(np.r_[x0</span><span class="s0">, </span><span class="s1">x])</span>


<span class="s0">def </span><span class="s1">freq_to_period(freq: str | offsets.DateOffset) -&gt; int:</span>
    <span class="s3">&quot;&quot;&quot; 
    Convert a pandas frequency to a periodicity 
 
    Parameters 
    ---------- 
    freq : str or offset 
        Frequency to convert 
 
    Returns 
    ------- 
    int 
        Periodicity of freq 
 
    Notes 
    ----- 
    Annual maps to 1, quarterly maps to 4, monthly to 12, weekly to 52. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance(freq</span><span class="s0">, </span><span class="s1">offsets.DateOffset):</span>
        <span class="s1">freq = to_offset(freq)  </span><span class="s4"># go ahead and standardize</span>
    <span class="s0">assert </span><span class="s1">isinstance(freq</span><span class="s0">, </span><span class="s1">offsets.DateOffset)</span>
    <span class="s1">freq = freq.rule_code.upper()</span>

    <span class="s0">if </span><span class="s1">freq == </span><span class="s2">&quot;A&quot; </span><span class="s0">or </span><span class="s1">freq.startswith((</span><span class="s2">&quot;A-&quot;</span><span class="s0">, </span><span class="s2">&quot;AS-&quot;</span><span class="s1">)):</span>
        <span class="s0">return </span><span class="s5">1</span>
    <span class="s0">elif </span><span class="s1">freq == </span><span class="s2">&quot;Q&quot; </span><span class="s0">or </span><span class="s1">freq.startswith((</span><span class="s2">&quot;Q-&quot;</span><span class="s0">, </span><span class="s2">&quot;QS-&quot;</span><span class="s1">)):</span>
        <span class="s0">return </span><span class="s5">4</span>
    <span class="s0">elif </span><span class="s1">freq == </span><span class="s2">&quot;M&quot; </span><span class="s0">or </span><span class="s1">freq.startswith((</span><span class="s2">&quot;M-&quot;</span><span class="s0">, </span><span class="s2">&quot;MS&quot;</span><span class="s1">)):</span>
        <span class="s0">return </span><span class="s5">12</span>
    <span class="s0">elif </span><span class="s1">freq == </span><span class="s2">&quot;W&quot; </span><span class="s0">or </span><span class="s1">freq.startswith(</span><span class="s2">&quot;W-&quot;</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s5">52</span>
    <span class="s0">elif </span><span class="s1">freq == </span><span class="s2">&quot;D&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s5">7</span>
    <span class="s0">elif </span><span class="s1">freq == </span><span class="s2">&quot;B&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s5">5</span>
    <span class="s0">elif </span><span class="s1">freq == </span><span class="s2">&quot;H&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s5">24</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s4"># pragma : no cover</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;freq {} not understood. Please report if you &quot;</span>
            <span class="s2">&quot;think this is in error.&quot;</span><span class="s1">.format(freq)</span>
        <span class="s1">)</span>
</pre>
</body>
</html>