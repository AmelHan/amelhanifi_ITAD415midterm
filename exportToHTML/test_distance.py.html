<html>
<head>
<title>test_distance.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_distance.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Author: Damian Eads</span>
<span class="s0"># Date: April 17, 2008</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2008 Damian Eads</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions</span>
<span class="s0"># are met:</span>
<span class="s0">#</span>
<span class="s0"># 1. Redistributions of source code must retain the above copyright</span>
<span class="s0">#    notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#</span>
<span class="s0"># 2. Redistributions in binary form must reproduce the above</span>
<span class="s0">#    copyright notice, this list of conditions and the following</span>
<span class="s0">#    disclaimer in the documentation and/or other materials provided</span>
<span class="s0">#    with the distribution.</span>
<span class="s0">#</span>
<span class="s0"># 3. The name of the author may not be used to endorse or promote</span>
<span class="s0">#    products derived from this software without specific prior</span>
<span class="s0">#    written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS</span>
<span class="s0"># OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0"># ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</span>
<span class="s0"># DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="s0"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE</span>
<span class="s0"># GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<span class="s0"># WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="s0"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="s0"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os.path</span>

<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps</span><span class="s2">, </span><span class="s1">partial</span>
<span class="s2">import </span><span class="s1">weakref</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">numpy.linalg </span><span class="s2">import </span><span class="s1">norm</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(verbose</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">,</span>
                           <span class="s1">assert_array_equal</span><span class="s2">, </span><span class="s1">assert_equal</span><span class="s2">,</span>
                           <span class="s1">assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">,</span>
                           <span class="s1">break_cycles</span><span class="s2">, </span><span class="s1">IS_PYPY)</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">scipy.spatial.distance </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">squareform</span><span class="s2">, </span><span class="s1">pdist</span><span class="s2">, </span><span class="s1">cdist</span><span class="s2">, </span><span class="s1">num_obs_y</span><span class="s2">, </span><span class="s1">num_obs_dm</span><span class="s2">, </span><span class="s1">is_valid_dm</span><span class="s2">, </span><span class="s1">is_valid_y</span><span class="s2">,</span>
    <span class="s1">_validate_vector</span><span class="s2">, </span><span class="s1">_METRICS_NAMES)</span>

<span class="s0"># these were missing: chebyshev cityblock</span>
<span class="s0"># jensenshannon  and seuclidean are referenced by string name.</span>
<span class="s2">from </span><span class="s1">scipy.spatial.distance </span><span class="s2">import </span><span class="s1">(braycurtis</span><span class="s2">, </span><span class="s1">canberra</span><span class="s2">, </span><span class="s1">chebyshev</span><span class="s2">, </span><span class="s1">cityblock</span><span class="s2">,</span>
                                    <span class="s1">correlation</span><span class="s2">, </span><span class="s1">cosine</span><span class="s2">, </span><span class="s1">dice</span><span class="s2">, </span><span class="s1">euclidean</span><span class="s2">,</span>
                                    <span class="s1">hamming</span><span class="s2">, </span><span class="s1">jaccard</span><span class="s2">, </span><span class="s1">jensenshannon</span><span class="s2">,</span>
                                    <span class="s1">kulczynski1</span><span class="s2">, </span><span class="s1">mahalanobis</span><span class="s2">,</span>
                                    <span class="s1">minkowski</span><span class="s2">, </span><span class="s1">rogerstanimoto</span><span class="s2">,</span>
                                    <span class="s1">russellrao</span><span class="s2">, </span><span class="s1">seuclidean</span><span class="s2">, </span><span class="s1">sokalmichener</span><span class="s2">,  </span><span class="s0"># noqa: F401</span>
                                    <span class="s1">sokalsneath</span><span class="s2">, </span><span class="s1">sqeuclidean</span><span class="s2">, </span><span class="s1">yule)</span>


<span class="s1">@pytest.fixture(params=_METRICS_NAMES</span><span class="s2">, </span><span class="s1">scope=</span><span class="s3">&quot;session&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">metric(request):</span>
    <span class="s4">&quot;&quot;&quot; 
    Fixture for all metrics in scipy.spatial.distance 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s1">_filenames = [</span>
              <span class="s3">&quot;cdist-X1.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;cdist-X2.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-boolean-inp.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-chebyshev-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-chebyshev-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-cityblock-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-cityblock-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-correlation-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-correlation-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-cosine-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-cosine-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-double-inp.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-euclidean-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-euclidean-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-hamming-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-jaccard-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-jensenshannon-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-jensenshannon-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-minkowski-3.2-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-minkowski-3.2-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-minkowski-5.8-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-seuclidean-ml-iris.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-seuclidean-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;pdist-spearman-ml.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;random-bool-data.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;random-double-data.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;random-int-data.txt&quot;</span><span class="s2">,</span>
              <span class="s3">&quot;random-uint-data.txt&quot;</span><span class="s2">,</span>
              <span class="s1">]</span>

<span class="s1">_tdist = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">662</span><span class="s2">, </span><span class="s5">877</span><span class="s2">, </span><span class="s5">255</span><span class="s2">, </span><span class="s5">412</span><span class="s2">, </span><span class="s5">996</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">662</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">295</span><span class="s2">, </span><span class="s5">468</span><span class="s2">, </span><span class="s5">268</span><span class="s2">, </span><span class="s5">400</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">877</span><span class="s2">, </span><span class="s5">295</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">754</span><span class="s2">, </span><span class="s5">564</span><span class="s2">, </span><span class="s5">138</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">255</span><span class="s2">, </span><span class="s5">468</span><span class="s2">, </span><span class="s5">754</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">219</span><span class="s2">, </span><span class="s5">869</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">412</span><span class="s2">, </span><span class="s5">268</span><span class="s2">, </span><span class="s5">564</span><span class="s2">, </span><span class="s5">219</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">669</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">996</span><span class="s2">, </span><span class="s5">400</span><span class="s2">, </span><span class="s5">138</span><span class="s2">, </span><span class="s5">869</span><span class="s2">, </span><span class="s5">669</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'double'</span><span class="s1">)</span>

<span class="s1">_ytdist = squareform(_tdist)</span>

<span class="s0"># A hashmap of expected output arrays for the tests. These arrays</span>
<span class="s0"># come from a list of text files, which are read prior to testing.</span>
<span class="s0"># Each test loads inputs and outputs from this dictionary.</span>
<span class="s1">eo = {}</span>


<span class="s2">def </span><span class="s1">load_testing_files():</span>
    <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">_filenames:</span>
        <span class="s1">name = fn.replace(</span><span class="s3">&quot;.txt&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).replace(</span><span class="s3">&quot;-ml&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">fqfn = os.path.join(os.path.dirname(__file__)</span><span class="s2">, </span><span class="s3">'data'</span><span class="s2">, </span><span class="s1">fn)</span>
        <span class="s1">fp = open(fqfn)</span>
        <span class="s1">eo[name] = np.loadtxt(fp)</span>
        <span class="s1">fp.close()</span>
    <span class="s1">eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">] = np.bool_(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
    <span class="s1">eo[</span><span class="s3">'random-bool-data'</span><span class="s1">] = np.bool_(eo[</span><span class="s3">'random-bool-data'</span><span class="s1">])</span>
    <span class="s1">eo[</span><span class="s3">'random-float32-data'</span><span class="s1">] = np.float32(eo[</span><span class="s3">'random-double-data'</span><span class="s1">])</span>
    <span class="s1">eo[</span><span class="s3">'random-int-data'</span><span class="s1">] = np.int_(eo[</span><span class="s3">'random-int-data'</span><span class="s1">])</span>
    <span class="s1">eo[</span><span class="s3">'random-uint-data'</span><span class="s1">] = np.uint(eo[</span><span class="s3">'random-uint-data'</span><span class="s1">])</span>


<span class="s1">load_testing_files()</span>


<span class="s2">def </span><span class="s1">_is_32bit():</span>
    <span class="s2">return </span><span class="s1">np.intp(</span><span class="s5">0</span><span class="s1">).itemsize &lt; </span><span class="s5">8</span>


<span class="s2">def </span><span class="s1">_chk_asarrays(arrays</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">arrays = [np.asanyarray(a) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays]</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s0"># np &lt; 1.10 ravel removes subclass from arrays</span>
        <span class="s1">arrays = [np.ravel(a) </span><span class="s2">if </span><span class="s1">a.ndim != </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">a</span>
                  <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays]</span>
        <span class="s1">axis = </span><span class="s5">0</span>
    <span class="s1">arrays = tuple(np.atleast_1d(a) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays)</span>
    <span class="s2">if </span><span class="s1">axis &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">all(a.ndim == arrays[</span><span class="s5">0</span><span class="s1">].ndim </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;array ndim must be the same for neg axis&quot;</span><span class="s1">)</span>
        <span class="s1">axis = range(arrays[</span><span class="s5">0</span><span class="s1">].ndim)[axis]</span>
    <span class="s2">return </span><span class="s1">arrays + (axis</span><span class="s2">,</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_chk_weights(arrays</span><span class="s2">, </span><span class="s1">weights=</span><span class="s2">None, </span><span class="s1">axis=</span><span class="s2">None,</span>
                 <span class="s1">force_weights=</span><span class="s2">False, </span><span class="s1">simplify_weights=</span><span class="s2">True,</span>
                 <span class="s1">pos_only=</span><span class="s2">False, </span><span class="s1">neg_check=</span><span class="s2">False,</span>
                 <span class="s1">nan_screen=</span><span class="s2">False, </span><span class="s1">mask_screen=</span><span class="s2">False,</span>
                 <span class="s1">ddof=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">chked = _chk_asarrays(arrays</span><span class="s2">, </span><span class="s1">axis=axis)</span>
    <span class="s1">arrays</span><span class="s2">, </span><span class="s1">axis = chked[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">chked[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">simplify_weights = simplify_weights </span><span class="s2">and not </span><span class="s1">force_weights</span>
    <span class="s2">if not </span><span class="s1">force_weights </span><span class="s2">and </span><span class="s1">mask_screen:</span>
        <span class="s1">force_weights = any(np.ma.getmask(a) </span><span class="s2">is not </span><span class="s1">np.ma.nomask </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays)</span>

    <span class="s2">if </span><span class="s1">nan_screen:</span>
        <span class="s1">has_nans = [np.isnan(np.sum(a)) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays]</span>
        <span class="s2">if </span><span class="s1">any(has_nans):</span>
            <span class="s1">mask_screen = </span><span class="s2">True</span>
            <span class="s1">force_weights = </span><span class="s2">True</span>
            <span class="s1">arrays = tuple(np.ma.masked_invalid(a) </span><span class="s2">if </span><span class="s1">has_nan </span><span class="s2">else </span><span class="s1">a</span>
                           <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">has_nan </span><span class="s2">in </span><span class="s1">zip(arrays</span><span class="s2">, </span><span class="s1">has_nans))</span>

    <span class="s2">if </span><span class="s1">weights </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">weights = np.asanyarray(weights)</span>
    <span class="s2">elif </span><span class="s1">force_weights:</span>
        <span class="s1">weights = np.ones(arrays[</span><span class="s5">0</span><span class="s1">].shape[axis])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">arrays + (weights</span><span class="s2">, </span><span class="s1">axis)</span>

    <span class="s2">if </span><span class="s1">ddof:</span>
        <span class="s1">weights = _freq_weights(weights)</span>

    <span class="s2">if </span><span class="s1">mask_screen:</span>
        <span class="s1">weights = _weight_masked(arrays</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s1">axis)</span>

    <span class="s2">if not </span><span class="s1">all(weights.shape == (a.shape[axis]</span><span class="s2">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;weights shape must match arrays along axis&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">neg_check </span><span class="s2">and </span><span class="s1">(weights &lt; </span><span class="s5">0</span><span class="s1">).any():</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;weights cannot be negative&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">pos_only:</span>
        <span class="s1">pos_weights = np.nonzero(weights &gt; </span><span class="s5">0</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">pos_weights.size &lt; weights.size:</span>
            <span class="s1">arrays = tuple(np.take(a</span><span class="s2">, </span><span class="s1">pos_weights</span><span class="s2">, </span><span class="s1">axis=axis) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays)</span>
            <span class="s1">weights = weights[pos_weights]</span>
    <span class="s2">if </span><span class="s1">simplify_weights </span><span class="s2">and </span><span class="s1">(weights == </span><span class="s5">1</span><span class="s1">).all():</span>
        <span class="s1">weights = </span><span class="s2">None</span>
    <span class="s2">return </span><span class="s1">arrays + (weights</span><span class="s2">, </span><span class="s1">axis)</span>


<span class="s2">def </span><span class="s1">_freq_weights(weights):</span>
    <span class="s2">if </span><span class="s1">weights </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">weights</span>
    <span class="s1">int_weights = weights.astype(int)</span>
    <span class="s2">if </span><span class="s1">(weights != int_weights).any():</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;frequency (integer count-type) weights required %s&quot; </span><span class="s1">% weights)</span>
    <span class="s2">return </span><span class="s1">int_weights</span>


<span class="s2">def </span><span class="s1">_weight_masked(arrays</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s1">axis):</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">axis = </span><span class="s5">0</span>
    <span class="s1">weights = np.asanyarray(weights)</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays:</span>
        <span class="s1">axis_mask = np.ma.getmask(a)</span>
        <span class="s2">if </span><span class="s1">axis_mask </span><span class="s2">is </span><span class="s1">np.ma.nomask:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">a.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">not_axes = tuple(i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(a.ndim) </span><span class="s2">if </span><span class="s1">i != axis)</span>
            <span class="s1">axis_mask = axis_mask.any(axis=not_axes)</span>
        <span class="s1">weights *= </span><span class="s5">1 </span><span class="s1">- axis_mask.astype(int)</span>
    <span class="s2">return </span><span class="s1">weights</span>


<span class="s2">def </span><span class="s1">_rand_split(arrays</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">split_per</span><span class="s2">, </span><span class="s1">seed=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0"># Coerce `arrays` to float64 if integer, to avoid nan-to-integer issues</span>
    <span class="s1">arrays = [arr.astype(np.float64) </span><span class="s2">if </span><span class="s1">np.issubdtype(arr.dtype</span><span class="s2">, </span><span class="s1">np.integer)</span>
              <span class="s2">else </span><span class="s1">arr </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrays]</span>

    <span class="s0"># inverse operation for stats.collapse_weights</span>
    <span class="s1">weights = np.array(weights</span><span class="s2">, </span><span class="s1">dtype=np.float64)  </span><span class="s0"># modified inplace; need a copy</span>
    <span class="s1">seeded_rand = np.random.RandomState(seed)</span>

    <span class="s2">def </span><span class="s1">mytake(a</span><span class="s2">, </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s1">record = np.asanyarray(np.take(a</span><span class="s2">, </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">axis=axis))</span>
        <span class="s2">return </span><span class="s1">record.reshape([a.shape[i] </span><span class="s2">if </span><span class="s1">i != axis </span><span class="s2">else </span><span class="s5">1</span>
                               <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(a.ndim)])</span>

    <span class="s1">n_obs = arrays[</span><span class="s5">0</span><span class="s1">].shape[axis]</span>
    <span class="s2">assert </span><span class="s1">all(a.shape[axis] == n_obs </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays)</span><span class="s2">, </span><span class="s3">&quot;data must be aligned on sample axis&quot;</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(int(split_per) * n_obs):</span>
        <span class="s1">split_ix = seeded_rand.randint(n_obs + i)</span>
        <span class="s1">prev_w = weights[split_ix]</span>
        <span class="s1">q = seeded_rand.rand()</span>
        <span class="s1">weights[split_ix] = q * prev_w</span>
        <span class="s1">weights = np.append(weights</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1. </span><span class="s1">- q) * prev_w)</span>
        <span class="s1">arrays = [np.append(a</span><span class="s2">, </span><span class="s1">mytake(a</span><span class="s2">, </span><span class="s1">split_ix</span><span class="s2">, </span><span class="s1">axis=axis)</span><span class="s2">,</span>
                            <span class="s1">axis=axis) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays]</span>
    <span class="s2">return </span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">weights</span>


<span class="s2">def </span><span class="s1">_rough_check(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">compare_assert=partial(assert_allclose</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">w=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">check_a = key(a)</span>
    <span class="s1">check_b = key(b)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">np.array(check_a != check_b).any():  </span><span class="s0"># try strict equality for string types</span>
            <span class="s1">compare_assert(check_a</span><span class="s2">, </span><span class="s1">check_b)</span>
    <span class="s2">except </span><span class="s1">AttributeError:  </span><span class="s0"># masked array</span>
        <span class="s1">compare_assert(check_a</span><span class="s2">, </span><span class="s1">check_b)</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):  </span><span class="s0"># nested data structure</span>
        <span class="s2">for </span><span class="s1">a_i</span><span class="s2">, </span><span class="s1">b_i </span><span class="s2">in </span><span class="s1">zip(check_a</span><span class="s2">, </span><span class="s1">check_b):</span>
            <span class="s1">_rough_check(a_i</span><span class="s2">, </span><span class="s1">b_i</span><span class="s2">, </span><span class="s1">compare_assert=compare_assert)</span>

<span class="s0"># diff from test_stats:</span>
<span class="s0">#  n_args=2, weight_arg='w', default_axis=None</span>
<span class="s0">#  ma_safe = False, nan_safe = False</span>
<span class="s2">def </span><span class="s1">_weight_checked(fn</span><span class="s2">, </span><span class="s1">n_args=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">default_axis=</span><span class="s2">None, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">weight_arg=</span><span class="s3">'w'</span><span class="s2">,</span>
                    <span class="s1">squeeze=</span><span class="s2">True, </span><span class="s1">silent=</span><span class="s2">False,</span>
                    <span class="s1">ones_test=</span><span class="s2">True, </span><span class="s1">const_test=</span><span class="s2">True, </span><span class="s1">dup_test=</span><span class="s2">True,</span>
                    <span class="s1">split_test=</span><span class="s2">True, </span><span class="s1">dud_test=</span><span class="s2">True, </span><span class="s1">ma_safe=</span><span class="s2">False, </span><span class="s1">ma_very_safe=</span><span class="s2">False, </span><span class="s1">nan_safe=</span><span class="s2">False,</span>
                    <span class="s1">split_per=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">seed=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">compare_assert=partial(assert_allclose</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)):</span>
    <span class="s4">&quot;&quot;&quot;runs fn on its arguments 2 or 3 ways, checks that the results are the same, 
       then returns the same thing it would have returned before&quot;&quot;&quot;</span>
    <span class="s1">@wraps(fn)</span>
    <span class="s2">def </span><span class="s1">wrapped(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">result = fn(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">arrays = args[:n_args]</span>
        <span class="s1">rest = args[n_args:]</span>
        <span class="s1">weights = kwargs.get(weight_arg</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">axis = kwargs.get(</span><span class="s3">'axis'</span><span class="s2">, </span><span class="s1">default_axis)</span>

        <span class="s1">chked = _chk_weights(arrays</span><span class="s2">, </span><span class="s1">weights=weights</span><span class="s2">, </span><span class="s1">axis=axis</span><span class="s2">, </span><span class="s1">force_weights=</span><span class="s2">True, </span><span class="s1">mask_screen=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">arrays</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s1">axis = chked[:-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">chked[-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">chked[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">squeeze:</span>
            <span class="s1">arrays = [np.atleast_1d(a.squeeze()) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays]</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s0"># WEIGHTS CHECK 1: EQUAL WEIGHTED OBESERVATIONS</span>
            <span class="s1">args = tuple(arrays) + rest</span>
            <span class="s2">if </span><span class="s1">ones_test:</span>
                <span class="s1">kwargs[weight_arg] = weights</span>
                <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
            <span class="s2">if </span><span class="s1">const_test:</span>
                <span class="s1">kwargs[weight_arg] = weights * </span><span class="s5">101.0</span>
                <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
                <span class="s1">kwargs[weight_arg] = weights * </span><span class="s5">0.101</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
                <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s2">raise </span><span class="s1">type(e)((e</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">weights)) </span><span class="s2">from </span><span class="s1">e</span>

            <span class="s0"># WEIGHTS CHECK 2: ADDL 0-WEIGHTED OBS</span>
            <span class="s2">if </span><span class="s1">dud_test:</span>
                <span class="s0"># add randomly resampled rows, weighted at 0</span>
                <span class="s1">dud_arrays</span><span class="s2">, </span><span class="s1">dud_weights = _rand_split(arrays</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">split_per=split_per</span><span class="s2">, </span><span class="s1">seed=seed)</span>
                <span class="s1">dud_weights[:weights.size] = weights  </span><span class="s0"># not exactly 1 because of masked arrays</span>
                <span class="s1">dud_weights[weights.size:] = </span><span class="s5">0</span>
                <span class="s1">dud_args = tuple(dud_arrays) + rest</span>
                <span class="s1">kwargs[weight_arg] = dud_weights</span>
                <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*dud_args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
                <span class="s0"># increase the value of those 0-weighted rows</span>
                <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">dud_arrays:</span>
                    <span class="s1">indexer = [slice(</span><span class="s2">None</span><span class="s1">)] * a.ndim</span>
                    <span class="s1">indexer[axis] = slice(weights.size</span><span class="s2">, None</span><span class="s1">)</span>
                    <span class="s1">indexer = tuple(indexer)</span>
                    <span class="s1">a[indexer] = a[indexer] * </span><span class="s5">101</span>
                <span class="s1">dud_args = tuple(dud_arrays) + rest</span>
                <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*dud_args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
                <span class="s0"># set those 0-weighted rows to NaNs</span>
                <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">dud_arrays:</span>
                    <span class="s1">indexer = [slice(</span><span class="s2">None</span><span class="s1">)] * a.ndim</span>
                    <span class="s1">indexer[axis] = slice(weights.size</span><span class="s2">, None</span><span class="s1">)</span>
                    <span class="s1">indexer = tuple(indexer)</span>
                    <span class="s1">a[indexer] = a[indexer] * np.nan</span>
                <span class="s2">if </span><span class="s1">kwargs.get(</span><span class="s3">&quot;nan_policy&quot;</span><span class="s2">, None</span><span class="s1">) == </span><span class="s3">&quot;omit&quot; </span><span class="s2">and </span><span class="s1">nan_safe:</span>
                    <span class="s1">dud_args = tuple(dud_arrays) + rest</span>
                    <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*dud_args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
                <span class="s0"># mask out those nan values</span>
                <span class="s2">if </span><span class="s1">ma_safe:</span>
                    <span class="s1">dud_arrays = [np.ma.masked_invalid(a) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">dud_arrays]</span>
                    <span class="s1">dud_args = tuple(dud_arrays) + rest</span>
                    <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*dud_args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
                    <span class="s2">if </span><span class="s1">ma_very_safe:</span>
                        <span class="s1">kwargs[weight_arg] = </span><span class="s2">None</span>
                        <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*dud_args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
                <span class="s2">del </span><span class="s1">dud_arrays</span><span class="s2">, </span><span class="s1">dud_args</span><span class="s2">, </span><span class="s1">dud_weights</span>

            <span class="s0"># WEIGHTS CHECK 3: DUPLICATE DATA (DUMB SPLITTING)</span>
            <span class="s2">if </span><span class="s1">dup_test:</span>
                <span class="s1">dup_arrays = [np.append(a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis=axis) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays]</span>
                <span class="s1">dup_weights = np.append(weights</span><span class="s2">, </span><span class="s1">weights) / </span><span class="s5">2.0</span>
                <span class="s1">dup_args = tuple(dup_arrays) + rest</span>
                <span class="s1">kwargs[weight_arg] = dup_weights</span>
                <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*dup_args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
                <span class="s2">del </span><span class="s1">dup_args</span><span class="s2">, </span><span class="s1">dup_arrays</span><span class="s2">, </span><span class="s1">dup_weights</span>

            <span class="s0"># WEIGHT CHECK 3: RANDOM SPLITTING</span>
            <span class="s2">if </span><span class="s1">split_test </span><span class="s2">and </span><span class="s1">split_per &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">split_arrays</span><span class="s2">, </span><span class="s1">split_weights = _rand_split(arrays</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">split_per=split_per</span><span class="s2">, </span><span class="s1">seed=seed)</span>
                <span class="s1">split_args = tuple(split_arrays) + rest</span>
                <span class="s1">kwargs[weight_arg] = split_weights</span>
                <span class="s1">_rough_check(result</span><span class="s2">, </span><span class="s1">fn(*split_args</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">, </span><span class="s1">key=key)</span>
        <span class="s2">except </span><span class="s1">NotImplementedError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s0"># when some combination of arguments makes weighting impossible,</span>
            <span class="s0">#  this is the desired response</span>
            <span class="s2">if not </span><span class="s1">silent:</span>
                <span class="s1">warnings.warn(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">fn.__name__</span><span class="s2">} </span><span class="s3">NotImplemented weights: </span><span class="s2">{</span><span class="s1">e</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span>
    <span class="s2">return </span><span class="s1">wrapped</span>


<span class="s1">wcdist = _weight_checked(cdist</span><span class="s2">, </span><span class="s1">default_axis=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">squeeze=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">wcdist_no_const = _weight_checked(cdist</span><span class="s2">, </span><span class="s1">default_axis=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">squeeze=</span><span class="s2">False, </span><span class="s1">const_test=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">wpdist = _weight_checked(pdist</span><span class="s2">, </span><span class="s1">default_axis=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">squeeze=</span><span class="s2">False, </span><span class="s1">n_args=</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">wpdist_no_const = _weight_checked(pdist</span><span class="s2">, </span><span class="s1">default_axis=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">squeeze=</span><span class="s2">False, </span><span class="s1">const_test=</span><span class="s2">False, </span><span class="s1">n_args=</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">wrogerstanimoto = _weight_checked(rogerstanimoto)</span>
<span class="s1">wmatching = whamming = _weight_checked(hamming</span><span class="s2">, </span><span class="s1">dud_test=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">wyule = _weight_checked(yule)</span>
<span class="s1">wdice = _weight_checked(dice)</span>
<span class="s1">wcityblock = _weight_checked(cityblock)</span>
<span class="s1">wchebyshev = _weight_checked(chebyshev)</span>
<span class="s1">wcosine = _weight_checked(cosine)</span>
<span class="s1">wcorrelation = _weight_checked(correlation)</span>
<span class="s1">wkulczynski1 = _weight_checked(kulczynski1)</span>
<span class="s1">wjaccard = _weight_checked(jaccard)</span>
<span class="s1">weuclidean = _weight_checked(euclidean</span><span class="s2">, </span><span class="s1">const_test=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">wsqeuclidean = _weight_checked(sqeuclidean</span><span class="s2">, </span><span class="s1">const_test=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">wbraycurtis = _weight_checked(braycurtis)</span>
<span class="s1">wcanberra = _weight_checked(canberra</span><span class="s2">, </span><span class="s1">const_test=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">wsokalsneath = _weight_checked(sokalsneath)</span>
<span class="s1">wsokalmichener = _weight_checked(sokalmichener)</span>
<span class="s1">wrussellrao = _weight_checked(russellrao)</span>


<span class="s2">class </span><span class="s1">TestCdist:</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rnd_eo_names = [</span><span class="s3">'random-float32-data'</span><span class="s2">, </span><span class="s3">'random-int-data'</span><span class="s2">,</span>
                             <span class="s3">'random-uint-data'</span><span class="s2">, </span><span class="s3">'random-double-data'</span><span class="s2">,</span>
                             <span class="s3">'random-bool-data'</span><span class="s1">]</span>
        <span class="s1">self.valid_upcasts = {</span><span class="s3">'bool'</span><span class="s1">: [np.uint</span><span class="s2">, </span><span class="s1">np.int_</span><span class="s2">, </span><span class="s1">np.float32</span><span class="s2">, </span><span class="s1">np.double]</span><span class="s2">,</span>
                              <span class="s3">'uint'</span><span class="s1">: [np.int_</span><span class="s2">, </span><span class="s1">np.float32</span><span class="s2">, </span><span class="s1">np.double]</span><span class="s2">,</span>
                              <span class="s3">'int'</span><span class="s1">: [np.float32</span><span class="s2">, </span><span class="s1">np.double]</span><span class="s2">,</span>
                              <span class="s3">'float32'</span><span class="s1">: [np.double]}</span>

    <span class="s2">def </span><span class="s1">test_cdist_extra_args(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># Tests that args and kwargs are correctly handled</span>

        <span class="s1">X1 = [[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s2">, </span><span class="s5">3.4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s2">, </span><span class="s5">4.4</span><span class="s1">]]</span>
        <span class="s1">X2 = [[</span><span class="s5">7.</span><span class="s2">, </span><span class="s5">5.</span><span class="s2">, </span><span class="s5">8.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">7.5</span><span class="s2">, </span><span class="s5">5.8</span><span class="s2">, </span><span class="s5">8.4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">5.5</span><span class="s2">, </span><span class="s5">5.8</span><span class="s2">, </span><span class="s5">4.4</span><span class="s1">]]</span>
        <span class="s1">kwargs = {</span><span class="s3">&quot;N0tV4l1D_p4raM&quot;</span><span class="s1">: </span><span class="s5">3.14</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">: np.arange(</span><span class="s5">3</span><span class="s1">)}</span>
        <span class="s1">args = [</span><span class="s5">3.14</span><span class="s1">] * </span><span class="s5">200</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=eval(metric)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=eval(metric)</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">test_cdist_extra_args_custom(self):</span>
        <span class="s0"># Tests that args and kwargs are correctly handled</span>
        <span class="s0"># also for custom metric</span>
        <span class="s2">def </span><span class="s1">_my_metric(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">kwarg2=</span><span class="s5">2</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">arg + kwarg + kwarg2</span>

        <span class="s1">X1 = [[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s2">, </span><span class="s5">3.4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s2">, </span><span class="s5">4.4</span><span class="s1">]]</span>
        <span class="s1">X2 = [[</span><span class="s5">7.</span><span class="s2">, </span><span class="s5">5.</span><span class="s2">, </span><span class="s5">8.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">7.5</span><span class="s2">, </span><span class="s5">5.8</span><span class="s2">, </span><span class="s5">8.4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">5.5</span><span class="s2">, </span><span class="s5">5.8</span><span class="s2">, </span><span class="s5">4.4</span><span class="s1">]]</span>
        <span class="s1">kwargs = {</span><span class="s3">&quot;N0tV4l1D_p4raM&quot;</span><span class="s1">: </span><span class="s5">3.14</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">: np.arange(</span><span class="s5">3</span><span class="s1">)}</span>
        <span class="s1">args = [</span><span class="s5">3.14</span><span class="s1">] * </span><span class="s5">200</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">2.2</span><span class="s2">, </span><span class="s1">kwarg2=</span><span class="s5">3.3</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">2.2</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">2.2</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s5">2.2</span><span class="s2">, </span><span class="s5">3.3</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s5">2.2</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">2.2</span><span class="s2">, </span><span class="s1">kwarg2=</span><span class="s5">3.3</span><span class="s1">)</span>

        <span class="s0"># this should work</span>
        <span class="s1">assert_allclose(cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=_my_metric</span><span class="s2">,</span>
                              <span class="s1">arg=</span><span class="s5">1.1</span><span class="s2">, </span><span class="s1">kwarg2=</span><span class="s5">3.3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">5.4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdist_euclidean_random_unicode(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X1 = eo[</span><span class="s3">'cdist-X1'</span><span class="s1">]</span>
        <span class="s1">X2 = eo[</span><span class="s3">'cdist-X2'</span><span class="s1">]</span>
        <span class="s1">Y1 = wcdist_no_const(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s3">'euclidean'</span><span class="s1">)</span>
        <span class="s1">Y2 = wcdist_no_const(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s3">'test_euclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y1</span><span class="s2">, </span><span class="s1">Y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;p&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.25</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1.23</span><span class="s2">,</span>
                                   <span class="s5">2.0</span><span class="s2">, </span><span class="s5">3.8</span><span class="s2">, </span><span class="s5">4.6</span><span class="s2">, </span><span class="s1">np.inf])</span>
    <span class="s2">def </span><span class="s1">test_cdist_minkowski_random(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s1">eps = </span><span class="s5">1e-13</span>
        <span class="s1">X1 = eo[</span><span class="s3">'cdist-X1'</span><span class="s1">]</span>
        <span class="s1">X2 = eo[</span><span class="s3">'cdist-X2'</span><span class="s1">]</span>
        <span class="s1">Y1 = wcdist_no_const(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">Y2 = wcdist_no_const(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s3">'test_minkowski'</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">assert_allclose(Y1</span><span class="s2">, </span><span class="s1">Y2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdist_cosine_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-14</span>
        <span class="s1">X1 = eo[</span><span class="s3">'cdist-X1'</span><span class="s1">]</span>
        <span class="s1">X2 = eo[</span><span class="s3">'cdist-X2'</span><span class="s1">]</span>
        <span class="s1">Y1 = wcdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s3">'cosine'</span><span class="s1">)</span>

        <span class="s0"># Naive implementation</span>
        <span class="s2">def </span><span class="s1">norms(X):</span>
            <span class="s2">return </span><span class="s1">np.linalg.norm(X</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">).reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">Y2 = </span><span class="s5">1 </span><span class="s1">- np.dot((X1 / norms(X1))</span><span class="s2">, </span><span class="s1">(X2 / norms(X2)).T)</span>

        <span class="s1">assert_allclose(Y1</span><span class="s2">, </span><span class="s1">Y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdist_mahalanobis(self):</span>
        <span class="s0"># 1-dimensional observations</span>
        <span class="s1">x1 = np.array([[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s1">]])</span>
        <span class="s1">x2 = np.array([[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">5</span><span class="s1">]])</span>
        <span class="s1">dist = cdist(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'mahalanobis'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">4.5</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">[np.sqrt(</span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">2</span><span class="s1">)]])</span>

        <span class="s0"># 2-dimensional observations</span>
        <span class="s1">x1 = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>
        <span class="s1">x2 = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">]])</span>
        <span class="s1">dist = cdist(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'mahalanobis'</span><span class="s1">)</span>
        <span class="s1">rt2 = np.sqrt(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist</span><span class="s2">, </span><span class="s1">[[rt2</span><span class="s2">, </span><span class="s1">rt2</span><span class="s2">, </span><span class="s1">rt2]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* rt2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]])</span>

        <span class="s0"># Too few observations</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cdist([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'mahalanobis'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdist_custom_notdouble(self):</span>
        <span class="s2">class </span><span class="s1">myclass:</span>
            <span class="s2">pass</span>

        <span class="s2">def </span><span class="s1">_my_metric(x</span><span class="s2">, </span><span class="s1">y):</span>
            <span class="s2">if not </span><span class="s1">isinstance(x[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">myclass) </span><span class="s2">or not </span><span class="s1">isinstance(y[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">myclass):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Type has been changed&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s5">1.123</span>
        <span class="s1">data = np.array([[myclass()]]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s1">cdist_y = cdist(data</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">metric=_my_metric)</span>
        <span class="s1">right_y = </span><span class="s5">1.123</span>
        <span class="s1">assert_equal(cdist_y</span><span class="s2">, </span><span class="s1">right_y</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_calling_conventions(self</span><span class="s2">, </span><span class="s1">X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">eps=</span><span class="s5">1e-07</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># helper function for test_cdist_calling_conventions</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">y1 = cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">y2 = cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=eval(metric)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">y3 = cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">e_cls = e.__class__</span>
            <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">print(e_cls.__name__)</span>
                <span class="s1">print(e)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(e_cls):</span>
                <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(e_cls):</span>
                <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=eval(metric)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(e_cls):</span>
                <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdist_calling_conventions(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># Ensures that specifying the metric with a str or scipy function</span>
        <span class="s0"># gives the same behaviour (i.e. same result or same exception).</span>
        <span class="s0"># NOTE: The correctness should be checked within each metric tests.</span>
        <span class="s2">for </span><span class="s1">eo_name </span><span class="s2">in </span><span class="s1">self.rnd_eo_names:</span>
            <span class="s0"># subsampling input data to speed-up tests</span>
            <span class="s0"># NOTE: num samples needs to be &gt; than dimensions for mahalanobis</span>
            <span class="s1">X1 = eo[eo_name][::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">X2 = eo[eo_name][</span><span class="s5">1</span><span class="s1">::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s3">&quot;testing: &quot;</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s3">&quot; with: &quot;</span><span class="s2">, </span><span class="s1">eo_name)</span>
            <span class="s2">if </span><span class="s1">metric </span><span class="s2">in </span><span class="s1">{</span><span class="s3">'dice'</span><span class="s2">, </span><span class="s3">'yule'</span><span class="s2">,</span>
                          <span class="s3">'rogerstanimoto'</span><span class="s2">,</span>
                          <span class="s3">'russellrao'</span><span class="s2">, </span><span class="s3">'sokalmichener'</span><span class="s2">,</span>
                          <span class="s3">'sokalsneath'</span><span class="s2">,</span>
                          <span class="s3">'kulczynski1'</span><span class="s1">} </span><span class="s2">and </span><span class="s3">'bool' </span><span class="s2">not in </span><span class="s1">eo_name:</span>
                <span class="s0"># python version permits non-bools e.g. for fuzzy logic</span>
                <span class="s2">continue</span>
            <span class="s1">self._check_calling_conventions(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric)</span>

            <span class="s0"># Testing built-in metrics with extra args</span>
            <span class="s2">if </span><span class="s1">metric == </span><span class="s3">&quot;seuclidean&quot;</span><span class="s1">:</span>
                <span class="s1">X12 = np.vstack([X1</span><span class="s2">, </span><span class="s1">X2]).astype(np.double)</span>
                <span class="s1">V = np.var(X12</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">self._check_calling_conventions(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">V=V)</span>
            <span class="s2">elif </span><span class="s1">metric == </span><span class="s3">&quot;mahalanobis&quot;</span><span class="s1">:</span>
                <span class="s1">X12 = np.vstack([X1</span><span class="s2">, </span><span class="s1">X2]).astype(np.double)</span>
                <span class="s1">V = np.atleast_2d(np.cov(X12.T))</span>
                <span class="s1">VI = np.array(np.linalg.inv(V).T)</span>
                <span class="s1">self._check_calling_conventions(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">VI=VI)</span>

    <span class="s2">def </span><span class="s1">test_cdist_dtype_equivalence(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># Tests that the result is not affected by type up-casting</span>
        <span class="s1">eps = </span><span class="s5">1e-07</span>
        <span class="s1">tests = [(eo[</span><span class="s3">'random-bool-data'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.valid_upcasts[</span><span class="s3">'bool'</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(eo[</span><span class="s3">'random-uint-data'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.valid_upcasts[</span><span class="s3">'uint'</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(eo[</span><span class="s3">'random-int-data'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.valid_upcasts[</span><span class="s3">'int'</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(eo[</span><span class="s3">'random-float32-data'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.valid_upcasts[</span><span class="s3">'float32'</span><span class="s1">])]</span>
        <span class="s2">for </span><span class="s1">test </span><span class="s2">in </span><span class="s1">tests:</span>
            <span class="s1">X1 = test[</span><span class="s5">0</span><span class="s1">][::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">X2 = test[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">y1 = cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric=metric)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">e_cls = e.__class__</span>
                <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s1">print(e_cls.__name__)</span>
                    <span class="s1">print(e)</span>
                <span class="s2">for </span><span class="s1">new_type </span><span class="s2">in </span><span class="s1">test[</span><span class="s5">1</span><span class="s1">]:</span>
                    <span class="s1">X1new = new_type(X1)</span>
                    <span class="s1">X2new = new_type(X2)</span>
                    <span class="s2">with </span><span class="s1">pytest.raises(e_cls):</span>
                        <span class="s1">cdist(X1new</span><span class="s2">, </span><span class="s1">X2new</span><span class="s2">, </span><span class="s1">metric=metric)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">new_type </span><span class="s2">in </span><span class="s1">test[</span><span class="s5">1</span><span class="s1">]:</span>
                    <span class="s1">y2 = cdist(new_type(X1)</span><span class="s2">, </span><span class="s1">new_type(X2)</span><span class="s2">, </span><span class="s1">metric=metric)</span>
                    <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdist_out(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># Test that out parameter works properly</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X1 = eo[</span><span class="s3">'cdist-X1'</span><span class="s1">]</span>
        <span class="s1">X2 = eo[</span><span class="s3">'cdist-X2'</span><span class="s1">]</span>
        <span class="s1">out_r</span><span class="s2">, </span><span class="s1">out_c = X1.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">X2.shape[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">kwargs = dict()</span>
        <span class="s2">if </span><span class="s1">metric == </span><span class="s3">'minkowski'</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s3">'p'</span><span class="s1">] = </span><span class="s5">1.23</span>
        <span class="s1">out1 = np.empty((out_r</span><span class="s2">, </span><span class="s1">out_c)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">Y1 = cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">Y2 = cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out1</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># test that output is numerically equivalent</span>
        <span class="s1">assert_allclose(Y1</span><span class="s2">, </span><span class="s1">Y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

        <span class="s0"># test that Y_test1 and out1 are the same object</span>
        <span class="s1">assert_(Y2 </span><span class="s2">is </span><span class="s1">out1)</span>

        <span class="s0"># test for incorrect shape</span>
        <span class="s1">out2 = np.empty((out_r-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">out_c+</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out2</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># test for C-contiguous order</span>
        <span class="s1">out3 = np.empty(</span>
            <span class="s1">(</span><span class="s5">2 </span><span class="s1">* out_r</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* out_c)</span><span class="s2">, </span><span class="s1">dtype=np.double)[::</span><span class="s5">2</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">out4 = np.empty((out_r</span><span class="s2">, </span><span class="s1">out_c)</span><span class="s2">, </span><span class="s1">dtype=np.double</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out3</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out4</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># test for incorrect dtype</span>
        <span class="s1">out5 = np.empty((out_r</span><span class="s2">, </span><span class="s1">out_c)</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out5</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_striding(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># test that striding is handled correct with calls to</span>
        <span class="s0"># _copy_array_if_base_present</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X1 = eo[</span><span class="s3">'cdist-X1'</span><span class="s1">][::</span><span class="s5">2</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">X2 = eo[</span><span class="s3">'cdist-X2'</span><span class="s1">][::</span><span class="s5">2</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">X1_copy = X1.copy()</span>
        <span class="s1">X2_copy = X2.copy()</span>

        <span class="s0"># confirm equivalence</span>
        <span class="s1">assert_equal(X1</span><span class="s2">, </span><span class="s1">X1_copy)</span>
        <span class="s1">assert_equal(X2</span><span class="s2">, </span><span class="s1">X2_copy)</span>
        <span class="s0"># confirm contiguity</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">X1.flags.c_contiguous)</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">X2.flags.c_contiguous)</span>
        <span class="s1">assert_(X1_copy.flags.c_contiguous)</span>
        <span class="s1">assert_(X2_copy.flags.c_contiguous)</span>

        <span class="s1">kwargs = dict()</span>
        <span class="s2">if </span><span class="s1">metric == </span><span class="s3">'minkowski'</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s3">'p'</span><span class="s1">] = </span><span class="s5">1.23</span>
        <span class="s1">Y1 = cdist(X1</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">Y2 = cdist(X1_copy</span><span class="s2">, </span><span class="s1">X2_copy</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s0"># test that output is numerically equivalent</span>
        <span class="s1">assert_allclose(Y1</span><span class="s2">, </span><span class="s1">Y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdist_refcount(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s1">x1 = np.random.rand(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">x2 = np.random.rand(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>

        <span class="s1">kwargs = dict()</span>
        <span class="s2">if </span><span class="s1">metric == </span><span class="s3">'minkowski'</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s3">'p'</span><span class="s1">] = </span><span class="s5">1.23</span>

        <span class="s1">out = cdist(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># Check reference counts aren't messed up. If we only hold weak</span>
        <span class="s0"># references, the arrays should be deallocated.</span>
        <span class="s1">weak_refs = [weakref.ref(v) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">out)]</span>
        <span class="s2">del </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">out</span>

        <span class="s2">if </span><span class="s1">IS_PYPY:</span>
            <span class="s1">break_cycles()</span>
        <span class="s2">assert </span><span class="s1">all(weak_ref() </span><span class="s2">is None for </span><span class="s1">weak_ref </span><span class="s2">in </span><span class="s1">weak_refs)</span>


<span class="s2">class </span><span class="s1">TestPdist:</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rnd_eo_names = [</span><span class="s3">'random-float32-data'</span><span class="s2">, </span><span class="s3">'random-int-data'</span><span class="s2">,</span>
                             <span class="s3">'random-uint-data'</span><span class="s2">, </span><span class="s3">'random-double-data'</span><span class="s2">,</span>
                             <span class="s3">'random-bool-data'</span><span class="s1">]</span>
        <span class="s1">self.valid_upcasts = {</span><span class="s3">'bool'</span><span class="s1">: [np.uint</span><span class="s2">, </span><span class="s1">np.int_</span><span class="s2">, </span><span class="s1">np.float32</span><span class="s2">, </span><span class="s1">np.double]</span><span class="s2">,</span>
                              <span class="s3">'uint'</span><span class="s1">: [np.int_</span><span class="s2">, </span><span class="s1">np.float32</span><span class="s2">, </span><span class="s1">np.double]</span><span class="s2">,</span>
                              <span class="s3">'int'</span><span class="s1">: [np.float32</span><span class="s2">, </span><span class="s1">np.double]</span><span class="s2">,</span>
                              <span class="s3">'float32'</span><span class="s1">: [np.double]}</span>

    <span class="s2">def </span><span class="s1">test_pdist_extra_args(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># Tests that args and kwargs are correctly handled</span>
        <span class="s1">X1 = [[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s1">]]</span>
        <span class="s1">kwargs = {</span><span class="s3">&quot;N0tV4l1D_p4raM&quot;</span><span class="s1">: </span><span class="s5">3.14</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">: np.arange(</span><span class="s5">2</span><span class="s1">)}</span>
        <span class="s1">args = [</span><span class="s5">3.14</span><span class="s1">] * </span><span class="s5">200</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric=eval(metric)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric=eval(metric)</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">test_pdist_extra_args_custom(self):</span>
        <span class="s0"># Tests that args and kwargs are correctly handled</span>
        <span class="s0"># also for custom metric</span>
        <span class="s2">def </span><span class="s1">_my_metric(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">kwarg2=</span><span class="s5">2</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">arg + kwarg + kwarg2</span>

        <span class="s1">X1 = [[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s1">]]</span>
        <span class="s1">kwargs = {</span><span class="s3">&quot;N0tV4l1D_p4raM&quot;</span><span class="s1">: </span><span class="s5">3.14</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">: np.arange(</span><span class="s5">2</span><span class="s1">)}</span>
        <span class="s1">args = [</span><span class="s5">3.14</span><span class="s1">] * </span><span class="s5">200</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">2.2</span><span class="s2">, </span><span class="s1">kwarg2=</span><span class="s5">3.3</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">2.2</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">2.2</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s5">2.2</span><span class="s2">, </span><span class="s5">3.3</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s5">2.2</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">_my_metric</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s1">kwarg=</span><span class="s5">2.2</span><span class="s2">, </span><span class="s1">kwarg2=</span><span class="s5">3.3</span><span class="s1">)</span>

        <span class="s0"># these should work</span>
        <span class="s1">assert_allclose(pdist(X1</span><span class="s2">, </span><span class="s1">metric=_my_metric</span><span class="s2">,</span>
                              <span class="s1">arg=</span><span class="s5">1.1</span><span class="s2">, </span><span class="s1">kwarg2=</span><span class="s5">3.3</span><span class="s1">)</span><span class="s2">, </span><span class="s5">5.4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_euclidean_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-07</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-euclidean'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'euclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_euclidean_random_u(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-07</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-euclidean'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'euclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_euclidean_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-07</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-euclidean'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'euclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_euclidean_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-07</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-euclidean'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'test_euclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_euclidean_iris_double(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-euclidean-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'euclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_euclidean_iris_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-5</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'iris'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-euclidean-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'euclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_euclidean_iris_nonC(self):</span>
        <span class="s0"># Test pdist(X, 'test_euclidean') [the non-C implementation] on the</span>
        <span class="s0"># Iris data set.</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-euclidean-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'test_euclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_seuclidean_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-seuclidean'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'seuclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_seuclidean_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-seuclidean'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'seuclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

        <span class="s0"># Check no error is raise when V has float32 dtype (#11171).</span>
        <span class="s1">V = np.var(X</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">Y_test2 = pdist(X</span><span class="s2">, </span><span class="s3">'seuclidean'</span><span class="s2">, </span><span class="s1">V=V)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_seuclidean_random_nonC(self):</span>
        <span class="s0"># Test pdist(X, 'test_sqeuclidean') [the non-C implementation]</span>
        <span class="s1">eps = </span><span class="s5">1e-07</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-seuclidean'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = pdist(X</span><span class="s2">, </span><span class="s3">'test_seuclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_seuclidean_iris(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-seuclidean-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'seuclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_seuclidean_iris_float32(self):</span>
        <span class="s0"># Tests pdist(X, 'seuclidean') on the Iris data set (float32).</span>
        <span class="s1">eps = </span><span class="s5">1e-5</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'iris'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-seuclidean-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'seuclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_seuclidean_iris_nonC(self):</span>
        <span class="s0"># Test pdist(X, 'test_seuclidean') [the non-C implementation] on the</span>
        <span class="s0"># Iris data set.</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-seuclidean-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = pdist(X</span><span class="s2">, </span><span class="s3">'test_seuclidean'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_cosine_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cosine'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'cosine'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_cosine_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cosine'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'cosine'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_cosine_random_nonC(self):</span>
        <span class="s0"># Test pdist(X, 'test_cosine') [the non-C implementation]</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cosine'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist(X</span><span class="s2">, </span><span class="s3">'test_cosine'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_cosine_iris(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-05</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cosine-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'cosine'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">atol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_cosine_iris_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-05</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'iris'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cosine-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'cosine'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">atol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_cosine_iris_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-05</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cosine-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist(X</span><span class="s2">, </span><span class="s3">'test_cosine'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">atol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_cosine_bounds(self):</span>
        <span class="s0"># Test adapted from @joernhees's example at gh-5208: case where</span>
        <span class="s0"># cosine distance used to be negative. XXX: very sensitive to the</span>
        <span class="s0"># specific norm computation.</span>
        <span class="s1">x = np.abs(np.random.RandomState(</span><span class="s5">1337</span><span class="s1">).rand(</span><span class="s5">91</span><span class="s1">))</span>
        <span class="s1">X = np.vstack([x</span><span class="s2">, </span><span class="s1">x])</span>
        <span class="s1">assert_(wpdist(X</span><span class="s2">, </span><span class="s3">'cosine'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] &gt;= </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s1">msg=</span><span class="s3">'cosine distance should be non-negative'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_cityblock_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cityblock'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'cityblock'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_cityblock_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cityblock'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'cityblock'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_cityblock_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cityblock'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'test_cityblock'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_cityblock_iris(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-14</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cityblock-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'cityblock'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_cityblock_iris_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-5</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'iris'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cityblock-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'cityblock'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_cityblock_iris_nonC(self):</span>
        <span class="s0"># Test pdist(X, 'test_cityblock') [the non-C implementation] on the</span>
        <span class="s0"># Iris data set.</span>
        <span class="s1">eps = </span><span class="s5">1e-14</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-cityblock-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'test_cityblock'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_correlation_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-correlation'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'correlation'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_correlation_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-correlation'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'correlation'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_correlation_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-correlation'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist(X</span><span class="s2">, </span><span class="s3">'test_correlation'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_correlation_iris(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-correlation-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'correlation'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_correlation_iris_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = np.float32(eo[</span><span class="s3">'pdist-correlation-iris'</span><span class="s1">])</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'correlation'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_correlation_iris_nonC(self):</span>
        <span class="s2">if </span><span class="s1">sys.maxsize &gt; </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32</span><span class="s1">:</span>
            <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;see gh-16456&quot;</span><span class="s1">)</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-correlation-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist(X</span><span class="s2">, </span><span class="s3">'test_correlation'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;p&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.25</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">3.2</span><span class="s2">, </span><span class="s1">np.inf])</span>
    <span class="s2">def </span><span class="s1">test_pdist_minkowski_random_p(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s1">eps = </span><span class="s5">1e-13</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">Y2 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'test_minkowski'</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">assert_allclose(Y1</span><span class="s2">, </span><span class="s1">Y2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_minkowski_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-3.2'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">3.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_minkowski_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-3.2'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">3.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_minkowski_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-3.2'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'test_minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">3.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_minkowski_3_2_iris(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-3.2-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">3.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_minkowski_3_2_iris_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-5</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'iris'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-3.2-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">3.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_minkowski_3_2_iris_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-3.2-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'test_minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">3.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_minkowski_5_8_iris(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-5.8-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">5.8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_minkowski_5_8_iris_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-5</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'iris'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-5.8-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">5.8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_minkowski_5_8_iris_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-minkowski-5.8-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist_no_const(X</span><span class="s2">, </span><span class="s3">'test_minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">5.8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_mahalanobis(self):</span>
        <span class="s0"># 1-dimensional observations</span>
        <span class="s1">x = np.array([</span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">3.0</span><span class="s2">, </span><span class="s5">5.0</span><span class="s1">]).reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">dist = pdist(x</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'mahalanobis'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">4.5</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">np.sqrt(</span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">4.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">2.0</span><span class="s1">)])</span>

        <span class="s0"># 2-dimensional observations</span>
        <span class="s1">x = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">]])</span>
        <span class="s1">dist = pdist(x</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'mahalanobis'</span><span class="s1">)</span>
        <span class="s1">rt2 = np.sqrt(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist</span><span class="s2">, </span><span class="s1">[rt2</span><span class="s2">, </span><span class="s1">rt2</span><span class="s2">, </span><span class="s1">rt2</span><span class="s2">, </span><span class="s1">rt2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* rt2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* rt2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>

        <span class="s0"># Too few observations</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">wpdist([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'mahalanobis'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_hamming_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-hamming'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'hamming'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_hamming_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-hamming'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'hamming'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_hamming_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-hamming'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist(X</span><span class="s2">, </span><span class="s3">'test_hamming'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_dhamming_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X = np.float64(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-hamming'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'hamming'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_dhamming_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-hamming'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'hamming'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_dhamming_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X = np.float64(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-hamming'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist(X</span><span class="s2">, </span><span class="s3">'test_hamming'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jaccard_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jaccard'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'jaccard'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jaccard_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jaccard'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'jaccard'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jaccard_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jaccard'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist(X</span><span class="s2">, </span><span class="s3">'test_jaccard'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_djaccard_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = np.float64(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jaccard'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'jaccard'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_djaccard_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jaccard'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = wpdist(X</span><span class="s2">, </span><span class="s3">'jaccard'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_djaccard_allzeros(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">Y = pdist(np.zeros((</span><span class="s5">5</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span><span class="s2">, </span><span class="s3">'jaccard'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.zeros(</span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_djaccard_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = np.float64(eo[</span><span class="s3">'pdist-boolean-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jaccard'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = wpdist(X</span><span class="s2">, </span><span class="s3">'test_jaccard'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jensenshannon_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-11</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jensenshannon'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'jensenshannon'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jensenshannon_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jensenshannon'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'jensenshannon'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jensenshannon_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-11</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jensenshannon'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = pdist(X</span><span class="s2">, </span><span class="s3">'test_jensenshannon'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jensenshannon_iris(self):</span>
        <span class="s2">if </span><span class="s1">_is_32bit():</span>
            <span class="s0"># Test failing on 32-bit Linux on Azure otherwise, see gh-12810</span>
            <span class="s1">eps = </span><span class="s5">2.5e-10</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">eps = </span><span class="s5">1e-12</span>

        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jensenshannon-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'jensenshannon'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">atol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jensenshannon_iris_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-06</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'iris'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jensenshannon-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'jensenshannon'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">atol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jensenshannon_iris_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">5e-5</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-jensenshannon-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = pdist(X</span><span class="s2">, </span><span class="s3">'test_jensenshannon'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_djaccard_allzeros_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">Y = pdist(np.zeros((</span><span class="s5">5</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span><span class="s2">, </span><span class="s3">'test_jaccard'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.zeros(</span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_chebyshev_random(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-chebyshev'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'chebyshev'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_chebyshev_random_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-7</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-chebyshev'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'chebyshev'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_chebyshev_random_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">X = eo[</span><span class="s3">'pdist-double-inp'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-chebyshev'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = pdist(X</span><span class="s2">, </span><span class="s3">'test_chebyshev'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_chebyshev_iris(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-14</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-chebyshev-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'chebyshev'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_chebyshev_iris_float32(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-5</span>
        <span class="s1">X = np.float32(eo[</span><span class="s3">'iris'</span><span class="s1">])</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-chebyshev-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s3">'chebyshev'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_chebyshev_iris_nonC(self):</span>
        <span class="s1">eps = </span><span class="s5">1e-14</span>
        <span class="s1">X = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s1">Y_right = eo[</span><span class="s3">'pdist-chebyshev-iris'</span><span class="s1">]</span>
        <span class="s1">Y_test2 = pdist(X</span><span class="s2">, </span><span class="s3">'test_chebyshev'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Y_test2</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

    <span class="s2">def </span><span class="s1">test_pdist_matching_mtica1(self):</span>
        <span class="s0"># Test matching(*,*) with mtica example #1 (nums).</span>
        <span class="s1">m = wmatching(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                      <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">m2 = wmatching(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                       <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">0.6</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">0.6</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_matching_mtica2(self):</span>
        <span class="s0"># Test matching(*,*) with mtica example #2.</span>
        <span class="s1">m = wmatching(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                     <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">m2 = wmatching(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                      <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jaccard_mtica1(self):</span>
        <span class="s1">m = wjaccard(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                     <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">m2 = wjaccard(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                      <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">0.6</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">0.6</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_jaccard_mtica2(self):</span>
        <span class="s1">m = wjaccard(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                     <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">m2 = wjaccard(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                      <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_yule_mtica1(self):</span>
        <span class="s1">m = wyule(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">m2 = wyule(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                   <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_yule_mtica2(self):</span>
        <span class="s1">m = wyule(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">m2 = wyule(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                   <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_dice_mtica1(self):</span>
        <span class="s1">m = wdice(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">m2 = wdice(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                   <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">7</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">7</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_dice_mtica2(self):</span>
        <span class="s1">m = wdice(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">m2 = wdice(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                   <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_sokalsneath_mtica1(self):</span>
        <span class="s1">m = sokalsneath(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">m2 = sokalsneath(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                         <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_sokalsneath_mtica2(self):</span>
        <span class="s1">m = wsokalsneath(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                         <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">m2 = wsokalsneath(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                          <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">4 </span><span class="s1">/ </span><span class="s5">5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">4 </span><span class="s1">/ </span><span class="s5">5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_rogerstanimoto_mtica1(self):</span>
        <span class="s1">m = wrogerstanimoto(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                            <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">m2 = wrogerstanimoto(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_rogerstanimoto_mtica2(self):</span>
        <span class="s1">m = wrogerstanimoto(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                            <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">m2 = wrogerstanimoto(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                             <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">4 </span><span class="s1">/ </span><span class="s5">5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">4 </span><span class="s1">/ </span><span class="s5">5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_russellrao_mtica1(self):</span>
        <span class="s1">m = wrussellrao(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">m2 = wrussellrao(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                         <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_russellrao_mtica2(self):</span>
        <span class="s1">m = wrussellrao(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">m2 = wrussellrao(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span><span class="s2">,</span>
                         <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(m)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_pdist_canberra_match(self):</span>
        <span class="s1">D = eo[</span><span class="s3">'iris'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">print(D.shape</span><span class="s2">, </span><span class="s1">D.dtype)</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">y1 = wpdist_no_const(D</span><span class="s2">, </span><span class="s3">&quot;canberra&quot;</span><span class="s1">)</span>
        <span class="s1">y2 = wpdist_no_const(D</span><span class="s2">, </span><span class="s3">&quot;test_canberra&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_canberra_ticket_711(self):</span>
        <span class="s0"># Test pdist(X, 'canberra') to see if Canberra gives the right result</span>
        <span class="s0"># as reported on gh-1238.</span>
        <span class="s1">eps = </span><span class="s5">1e-8</span>
        <span class="s1">pdist_y = wpdist_no_const(([</span><span class="s5">3.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3.4</span><span class="s1">])</span><span class="s2">, </span><span class="s3">&quot;canberra&quot;</span><span class="s1">)</span>
        <span class="s1">right_y = </span><span class="s5">0.01492537</span>
        <span class="s1">assert_allclose(pdist_y</span><span class="s2">, </span><span class="s1">right_y</span><span class="s2">, </span><span class="s1">atol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_custom_notdouble(self):</span>
        <span class="s0"># tests that when using a custom metric the data type is not altered</span>
        <span class="s2">class </span><span class="s1">myclass:</span>
            <span class="s2">pass</span>

        <span class="s2">def </span><span class="s1">_my_metric(x</span><span class="s2">, </span><span class="s1">y):</span>
            <span class="s2">if not </span><span class="s1">isinstance(x[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">myclass) </span><span class="s2">or not </span><span class="s1">isinstance(y[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">myclass):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Type has been changed&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s5">1.123</span>
        <span class="s1">data = np.array([[myclass()]</span><span class="s2">, </span><span class="s1">[myclass()]]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s1">pdist_y = pdist(data</span><span class="s2">, </span><span class="s1">metric=_my_metric)</span>
        <span class="s1">right_y = </span><span class="s5">1.123</span>
        <span class="s1">assert_equal(pdist_y</span><span class="s2">, </span><span class="s1">right_y</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_calling_conventions(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">eps=</span><span class="s5">1e-07</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># helper function for test_pdist_calling_conventions</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">y1 = pdist(X</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">y2 = pdist(X</span><span class="s2">, </span><span class="s1">metric=eval(metric)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">y3 = pdist(X</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">e_cls = e.__class__</span>
            <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">print(e_cls.__name__)</span>
                <span class="s1">print(e)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(e_cls):</span>
                <span class="s1">pdist(X</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(e_cls):</span>
                <span class="s1">pdist(X</span><span class="s2">, </span><span class="s1">metric=eval(metric)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(e_cls):</span>
                <span class="s1">pdist(X</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_calling_conventions(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># Ensures that specifying the metric with a str or scipy function</span>
        <span class="s0"># gives the same behaviour (i.e. same result or same exception).</span>
        <span class="s0"># NOTE: The correctness should be checked within each metric tests.</span>
        <span class="s0"># NOTE: Extra args should be checked with a dedicated test</span>
        <span class="s2">for </span><span class="s1">eo_name </span><span class="s2">in </span><span class="s1">self.rnd_eo_names:</span>
            <span class="s0"># subsampling input data to speed-up tests</span>
            <span class="s0"># NOTE: num samples needs to be &gt; than dimensions for mahalanobis</span>
            <span class="s1">X = eo[eo_name][::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s3">&quot;testing: &quot;</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s3">&quot; with: &quot;</span><span class="s2">, </span><span class="s1">eo_name)</span>
            <span class="s2">if </span><span class="s1">metric </span><span class="s2">in </span><span class="s1">{</span><span class="s3">'dice'</span><span class="s2">, </span><span class="s3">'yule'</span><span class="s2">, </span><span class="s3">'matching'</span><span class="s2">,</span>
                          <span class="s3">'rogerstanimoto'</span><span class="s2">, </span><span class="s3">'russellrao'</span><span class="s2">, </span><span class="s3">'sokalmichener'</span><span class="s2">,</span>
                          <span class="s3">'sokalsneath'</span><span class="s2">,</span>
                          <span class="s3">'kulczynski1'</span><span class="s1">} </span><span class="s2">and </span><span class="s3">'bool' </span><span class="s2">not in </span><span class="s1">eo_name:</span>
                <span class="s0"># python version permits non-bools e.g. for fuzzy logic</span>
                <span class="s2">continue</span>
            <span class="s1">self._check_calling_conventions(X</span><span class="s2">, </span><span class="s1">metric)</span>

            <span class="s0"># Testing built-in metrics with extra args</span>
            <span class="s2">if </span><span class="s1">metric == </span><span class="s3">&quot;seuclidean&quot;</span><span class="s1">:</span>
                <span class="s1">V = np.var(X.astype(np.double)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">self._check_calling_conventions(X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">V=V)</span>
            <span class="s2">elif </span><span class="s1">metric == </span><span class="s3">&quot;mahalanobis&quot;</span><span class="s1">:</span>
                <span class="s1">V = np.atleast_2d(np.cov(X.astype(np.double).T))</span>
                <span class="s1">VI = np.array(np.linalg.inv(V).T)</span>
                <span class="s1">self._check_calling_conventions(X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">VI=VI)</span>

    <span class="s2">def </span><span class="s1">test_pdist_dtype_equivalence(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># Tests that the result is not affected by type up-casting</span>
        <span class="s1">eps = </span><span class="s5">1e-07</span>
        <span class="s1">tests = [(eo[</span><span class="s3">'random-bool-data'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.valid_upcasts[</span><span class="s3">'bool'</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(eo[</span><span class="s3">'random-uint-data'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.valid_upcasts[</span><span class="s3">'uint'</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(eo[</span><span class="s3">'random-int-data'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.valid_upcasts[</span><span class="s3">'int'</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(eo[</span><span class="s3">'random-float32-data'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.valid_upcasts[</span><span class="s3">'float32'</span><span class="s1">])]</span>
        <span class="s2">for </span><span class="s1">test </span><span class="s2">in </span><span class="s1">tests:</span>
            <span class="s1">X1 = test[</span><span class="s5">0</span><span class="s1">][::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">y1 = pdist(X1</span><span class="s2">, </span><span class="s1">metric=metric)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">e_cls = e.__class__</span>
                <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s1">print(e_cls.__name__)</span>
                    <span class="s1">print(e)</span>
                <span class="s2">for </span><span class="s1">new_type </span><span class="s2">in </span><span class="s1">test[</span><span class="s5">1</span><span class="s1">]:</span>
                    <span class="s1">X2 = new_type(X1)</span>
                    <span class="s2">with </span><span class="s1">pytest.raises(e_cls):</span>
                        <span class="s1">pdist(X2</span><span class="s2">, </span><span class="s1">metric=metric)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">new_type </span><span class="s2">in </span><span class="s1">test[</span><span class="s5">1</span><span class="s1">]:</span>
                    <span class="s1">y2 = pdist(new_type(X1)</span><span class="s2">, </span><span class="s1">metric=metric)</span>
                    <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdist_out(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># Test that out parameter works properly</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X = eo[</span><span class="s3">'random-float32-data'</span><span class="s1">][::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">out_size = int((X.shape[</span><span class="s5">0</span><span class="s1">] * (X.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">)) / </span><span class="s5">2</span><span class="s1">)</span>

        <span class="s1">kwargs = dict()</span>
        <span class="s2">if </span><span class="s1">metric == </span><span class="s3">'minkowski'</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s3">'p'</span><span class="s1">] = </span><span class="s5">1.23</span>
        <span class="s1">out1 = np.empty(out_size</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">Y_right = pdist(X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">Y_test1 = pdist(X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out1</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># test that output is numerically equivalent</span>
        <span class="s1">assert_allclose(Y_test1</span><span class="s2">, </span><span class="s1">Y_right</span><span class="s2">, </span><span class="s1">rtol=eps)</span>

        <span class="s0"># test that Y_test1 and out1 are the same object</span>
        <span class="s1">assert_(Y_test1 </span><span class="s2">is </span><span class="s1">out1)</span>

        <span class="s0"># test for incorrect shape</span>
        <span class="s1">out2 = np.empty(out_size + </span><span class="s5">3</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">pdist(X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out2</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># test for (C-)contiguous output</span>
        <span class="s1">out3 = np.empty(</span><span class="s5">2 </span><span class="s1">* out_size</span><span class="s2">, </span><span class="s1">dtype=np.double)[::</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">pdist(X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out3</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># test for incorrect dtype</span>
        <span class="s1">out5 = np.empty(out_size</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">pdist(X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">out=out5</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_striding(self</span><span class="s2">, </span><span class="s1">metric):</span>
        <span class="s0"># test that striding is handled correct with calls to</span>
        <span class="s0"># _copy_array_if_base_present</span>
        <span class="s1">eps = </span><span class="s5">1e-15</span>
        <span class="s1">X = eo[</span><span class="s3">'random-float32-data'</span><span class="s1">][::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">X_copy = X.copy()</span>

        <span class="s0"># confirm contiguity</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">X.flags.c_contiguous)</span>
        <span class="s1">assert_(X_copy.flags.c_contiguous)</span>

        <span class="s1">kwargs = dict()</span>
        <span class="s2">if </span><span class="s1">metric == </span><span class="s3">'minkowski'</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s3">'p'</span><span class="s1">] = </span><span class="s5">1.23</span>
        <span class="s1">Y1 = pdist(X</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">Y2 = pdist(X_copy</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s0"># test that output is numerically equivalent</span>
        <span class="s1">assert_allclose(Y1</span><span class="s2">, </span><span class="s1">Y2</span><span class="s2">, </span><span class="s1">rtol=eps</span><span class="s2">, </span><span class="s1">verbose=verbose &gt; </span><span class="s5">2</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">TestSomeDistanceFunctions:</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s0"># 1D arrays</span>
        <span class="s1">x = np.array([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">3.0</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">5.0</span><span class="s1">])</span>

        <span class="s1">self.cases = [(x</span><span class="s2">, </span><span class="s1">y)]</span>

    <span class="s2">def </span><span class="s1">test_minkowski(self):</span>
        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">self.cases:</span>
            <span class="s1">dist1 = minkowski(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(dist1</span><span class="s2">, </span><span class="s5">3.0</span><span class="s1">)</span>
            <span class="s1">dist1p5 = minkowski(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">1.5</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(dist1p5</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1.0 </span><span class="s1">+ </span><span class="s5">2.0</span><span class="s1">**</span><span class="s5">1.5</span><span class="s1">)**(</span><span class="s5">2. </span><span class="s1">/ </span><span class="s5">3</span><span class="s1">))</span>
            <span class="s1">dist2 = minkowski(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(dist2</span><span class="s2">, </span><span class="s5">5.0 </span><span class="s1">** </span><span class="s5">0.5</span><span class="s1">)</span>
            <span class="s1">dist0p25 = minkowski(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">0.25</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(dist0p25</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1.0 </span><span class="s1">+ </span><span class="s5">2.0 </span><span class="s1">** </span><span class="s5">0.25</span><span class="s1">) ** </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s0"># Check that casting input to minimum scalar type doesn't affect result</span>
        <span class="s0"># (issue #10262). This could be extended to more test inputs with</span>
        <span class="s0"># np.min_scalar_type(np.max(input_matrix)).</span>
        <span class="s1">a = np.array([</span><span class="s5">352</span><span class="s2">, </span><span class="s5">916</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s5">350</span><span class="s2">, </span><span class="s5">660</span><span class="s1">])</span>
        <span class="s1">assert_equal(minkowski(a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">,</span>
                     <span class="s1">minkowski(a.astype(</span><span class="s3">'uint16'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">b.astype(</span><span class="s3">'uint16'</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">test_euclidean(self):</span>
        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">self.cases:</span>
            <span class="s1">dist = weuclidean(x</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">assert_almost_equal(dist</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">5</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_sqeuclidean(self):</span>
        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">self.cases:</span>
            <span class="s1">dist = wsqeuclidean(x</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">assert_almost_equal(dist</span><span class="s2">, </span><span class="s5">5.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cosine(self):</span>
        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">self.cases:</span>
            <span class="s1">dist = wcosine(x</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">assert_almost_equal(dist</span><span class="s2">, </span><span class="s5">1.0 </span><span class="s1">- </span><span class="s5">18.0 </span><span class="s1">/ (np.sqrt(</span><span class="s5">14</span><span class="s1">) * np.sqrt(</span><span class="s5">27</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">test_correlation(self):</span>
        <span class="s1">xm = np.array([-</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>
        <span class="s1">ym = np.array([-</span><span class="s5">4.0 </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">4.0 </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s5">5.0 </span><span class="s1">- </span><span class="s5">7.0 </span><span class="s1">/ </span><span class="s5">3</span><span class="s1">])</span>
        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">self.cases:</span>
            <span class="s1">dist = wcorrelation(x</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">assert_almost_equal(dist</span><span class="s2">, </span><span class="s5">1.0 </span><span class="s1">- np.dot(xm</span><span class="s2">, </span><span class="s1">ym) / (norm(xm) * norm(ym)))</span>

    <span class="s2">def </span><span class="s1">test_correlation_positive(self):</span>
        <span class="s0"># Regression test for gh-12320 (negative return value due to rounding</span>
        <span class="s1">x = np.array([</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">,</span>
                      <span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">,</span>
                      <span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">,</span>
                      <span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">,</span>
                      <span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>
        <span class="s1">dist = correlation(x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">assert </span><span class="s5">0 </span><span class="s1">&lt;= dist &lt;= </span><span class="s5">10 </span><span class="s1">* np.finfo(np.float64).eps</span>

    <span class="s2">def </span><span class="s1">test_mahalanobis(self):</span>
        <span class="s1">x = np.array([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">3.0</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">5.0</span><span class="s1">])</span>
        <span class="s1">vi = np.array([[</span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">]])</span>
        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">self.cases:</span>
            <span class="s1">dist = mahalanobis(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">vi)</span>
            <span class="s1">assert_almost_equal(dist</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">6.0</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TestSquareForm:</span>
    <span class="s1">checked_dtypes = [np.float64</span><span class="s2">, </span><span class="s1">np.float32</span><span class="s2">, </span><span class="s1">np.int32</span><span class="s2">, </span><span class="s1">np.int8</span><span class="s2">, </span><span class="s1">bool]</span>

    <span class="s2">def </span><span class="s1">test_squareform_matrix(self):</span>
        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">self.checked_dtypes:</span>
            <span class="s1">self.check_squareform_matrix(dtype)</span>

    <span class="s2">def </span><span class="s1">test_squareform_vector(self):</span>
        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">self.checked_dtypes:</span>
            <span class="s1">self.check_squareform_vector(dtype)</span>

    <span class="s2">def </span><span class="s1">check_squareform_matrix(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">A = np.zeros((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">rA = squareform(A)</span>
        <span class="s1">assert_equal(rA.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(rA.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s1">A = np.zeros((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">rA = squareform(A)</span>
        <span class="s1">assert_equal(rA.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(rA.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s1">A = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">4.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">4.2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">rA = squareform(A)</span>
        <span class="s1">assert_equal(rA.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(rA.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">assert_array_equal(rA</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s5">4.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>

    <span class="s2">def </span><span class="s1">check_squareform_vector(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">v = np.zeros((</span><span class="s5">0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">rv = squareform(v)</span>
        <span class="s1">assert_equal(rv.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(rv.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">assert_array_equal(rv</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s1">]])</span>

        <span class="s1">v = np.array([</span><span class="s5">8.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">rv = squareform(v)</span>
        <span class="s1">assert_equal(rv.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(rv.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">assert_array_equal(rv</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">8.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">8.3</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>

    <span class="s2">def </span><span class="s1">test_squareform_multi_matrix(self):</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">):</span>
            <span class="s1">self.check_squareform_multi_matrix(n)</span>

    <span class="s2">def </span><span class="s1">check_squareform_multi_matrix(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">X = np.random.rand(n</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">Y = wpdist_no_const(X)</span>
        <span class="s1">assert_equal(len(Y.shape)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">A = squareform(Y)</span>
        <span class="s1">Yr = squareform(A)</span>
        <span class="s1">s = A.shape</span>
        <span class="s1">k = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">verbose &gt;= </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">print(A.shape</span><span class="s2">, </span><span class="s1">Y.shape</span><span class="s2">, </span><span class="s1">Yr.shape)</span>
        <span class="s1">assert_equal(len(s)</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(Yr.shape)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(s[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">s[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(i + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">s[</span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s2">if </span><span class="s1">i != j:</span>
                    <span class="s1">assert_equal(A[i</span><span class="s2">, </span><span class="s1">j]</span><span class="s2">, </span><span class="s1">Y[k])</span>
                    <span class="s1">k += </span><span class="s5">1</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">assert_equal(A[i</span><span class="s2">, </span><span class="s1">j]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNumObsY:</span>

    <span class="s2">def </span><span class="s1">test_num_obs_y_multi_matrix(self):</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">):</span>
            <span class="s1">X = np.random.rand(n</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
            <span class="s1">Y = wpdist_no_const(X)</span>
            <span class="s1">assert_equal(num_obs_y(Y)</span><span class="s2">, </span><span class="s1">n)</span>

    <span class="s2">def </span><span class="s1">test_num_obs_y_1(self):</span>
        <span class="s0"># Tests num_obs_y(y) on a condensed distance matrix over 1</span>
        <span class="s0"># observations. Expecting exception.</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">self.check_y(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_num_obs_y_2(self):</span>
        <span class="s0"># Tests num_obs_y(y) on a condensed distance matrix over 2</span>
        <span class="s0"># observations.</span>
        <span class="s1">assert_(self.check_y(</span><span class="s5">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_num_obs_y_3(self):</span>
        <span class="s1">assert_(self.check_y(</span><span class="s5">3</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_num_obs_y_4(self):</span>
        <span class="s1">assert_(self.check_y(</span><span class="s5">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_num_obs_y_5_10(self):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">16</span><span class="s1">):</span>
            <span class="s1">self.minit(i)</span>

    <span class="s2">def </span><span class="s1">test_num_obs_y_2_100(self):</span>
        <span class="s0"># Tests num_obs_y(y) on 100 improper condensed distance matrices.</span>
        <span class="s0"># Expecting exception.</span>
        <span class="s1">a = set()</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">16</span><span class="s1">):</span>
            <span class="s1">a.add(n * (n - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">105</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">a:</span>
                <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
                    <span class="s1">self.bad_y(i)</span>

    <span class="s2">def </span><span class="s1">minit(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">assert_(self.check_y(n))</span>

    <span class="s2">def </span><span class="s1">bad_y(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">y = np.random.rand(n)</span>
        <span class="s2">return </span><span class="s1">num_obs_y(y)</span>

    <span class="s2">def </span><span class="s1">check_y(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">return </span><span class="s1">num_obs_y(self.make_y(n)) == n</span>

    <span class="s2">def </span><span class="s1">make_y(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">return </span><span class="s1">np.random.rand((n * (n - </span><span class="s5">1</span><span class="s1">)) // </span><span class="s5">2</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNumObsDM:</span>

    <span class="s2">def </span><span class="s1">test_num_obs_dm_multi_matrix(self):</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">):</span>
            <span class="s1">X = np.random.rand(n</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
            <span class="s1">Y = wpdist_no_const(X)</span>
            <span class="s1">A = squareform(Y)</span>
            <span class="s2">if </span><span class="s1">verbose &gt;= </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">print(A.shape</span><span class="s2">, </span><span class="s1">Y.shape)</span>
            <span class="s1">assert_equal(num_obs_dm(A)</span><span class="s2">, </span><span class="s1">n)</span>

    <span class="s2">def </span><span class="s1">test_num_obs_dm_0(self):</span>
        <span class="s0"># Tests num_obs_dm(D) on a 0x0 distance matrix. Expecting exception.</span>
        <span class="s1">assert_(self.check_D(</span><span class="s5">0</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_num_obs_dm_1(self):</span>
        <span class="s0"># Tests num_obs_dm(D) on a 1x1 distance matrix.</span>
        <span class="s1">assert_(self.check_D(</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_num_obs_dm_2(self):</span>
        <span class="s1">assert_(self.check_D(</span><span class="s5">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_num_obs_dm_3(self):</span>
        <span class="s1">assert_(self.check_D(</span><span class="s5">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_num_obs_dm_4(self):</span>
        <span class="s1">assert_(self.check_D(</span><span class="s5">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">check_D(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">return </span><span class="s1">num_obs_dm(self.make_D(n)) == n</span>

    <span class="s2">def </span><span class="s1">make_D(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">return </span><span class="s1">np.random.rand(n</span><span class="s2">, </span><span class="s1">n)</span>


<span class="s2">def </span><span class="s1">is_valid_dm_throw(D):</span>
    <span class="s2">return </span><span class="s1">is_valid_dm(D</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestIsValidDM:</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_improper_shape_1D_E(self):</span>
        <span class="s1">D = np.zeros((</span><span class="s5">5</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">is_valid_dm_throw((D))</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_improper_shape_1D_F(self):</span>
        <span class="s1">D = np.zeros((</span><span class="s5">5</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_improper_shape_3D_E(self):</span>
        <span class="s1">D = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">is_valid_dm_throw((D))</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_improper_shape_3D_F(self):</span>
        <span class="s1">D = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_nonzero_diagonal_E(self):</span>
        <span class="s1">y = np.random.rand(</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">D = squareform(y)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">5</span><span class="s1">):</span>
            <span class="s1">D[i</span><span class="s2">, </span><span class="s1">i] = </span><span class="s5">2.0</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">is_valid_dm_throw((D))</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_nonzero_diagonal_F(self):</span>
        <span class="s1">y = np.random.rand(</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">D = squareform(y)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">5</span><span class="s1">):</span>
            <span class="s1">D[i</span><span class="s2">, </span><span class="s1">i] = </span><span class="s5">2.0</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_asymmetric_E(self):</span>
        <span class="s1">y = np.random.rand(</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">D = squareform(y)</span>
        <span class="s1">D[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = D[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">is_valid_dm_throw((D))</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_asymmetric_F(self):</span>
        <span class="s1">y = np.random.rand(</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">D = squareform(y)</span>
        <span class="s1">D[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = D[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_correct_1_by_1(self):</span>
        <span class="s1">D = np.zeros((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_correct_2_by_2(self):</span>
        <span class="s1">y = np.random.rand(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">D = squareform(y)</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_correct_3_by_3(self):</span>
        <span class="s1">y = np.random.rand(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">D = squareform(y)</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_correct_4_by_4(self):</span>
        <span class="s1">y = np.random.rand(</span><span class="s5">6</span><span class="s1">)</span>
        <span class="s1">D = squareform(y)</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_dm_correct_5_by_5(self):</span>
        <span class="s1">y = np.random.rand(</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">D = squareform(y)</span>
        <span class="s1">assert_equal(is_valid_dm(D)</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">is_valid_y_throw(y):</span>
    <span class="s2">return </span><span class="s1">is_valid_y(y</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestIsValidY:</span>
    <span class="s0"># If test case name ends on &quot;_E&quot; then an exception is expected for the</span>
    <span class="s0"># given input, if it ends in &quot;_F&quot; then False is expected for the is_valid_y</span>
    <span class="s0"># check.  Otherwise the input is expected to be valid.</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_improper_shape_2D_E(self):</span>
        <span class="s1">y = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">is_valid_y_throw((y))</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_improper_shape_2D_F(self):</span>
        <span class="s1">y = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_valid_y(y)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_improper_shape_3D_E(self):</span>
        <span class="s1">y = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">is_valid_y_throw((y))</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_improper_shape_3D_F(self):</span>
        <span class="s1">y = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_valid_y(y)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_correct_2_by_2(self):</span>
        <span class="s1">y = self.correct_n_by_n(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(is_valid_y(y)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_correct_3_by_3(self):</span>
        <span class="s1">y = self.correct_n_by_n(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(is_valid_y(y)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_correct_4_by_4(self):</span>
        <span class="s1">y = self.correct_n_by_n(</span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(is_valid_y(y)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_correct_5_by_5(self):</span>
        <span class="s1">y = self.correct_n_by_n(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(is_valid_y(y)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_y_2_100(self):</span>
        <span class="s1">a = set()</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">16</span><span class="s1">):</span>
            <span class="s1">a.add(n * (n - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">105</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">a:</span>
                <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
                    <span class="s1">self.bad_y(i)</span>

    <span class="s2">def </span><span class="s1">bad_y(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">y = np.random.rand(n)</span>
        <span class="s2">return </span><span class="s1">is_valid_y(y</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">correct_n_by_n(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">y = np.random.rand((n * (n - </span><span class="s5">1</span><span class="s1">)) // </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">y</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;p&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">10.0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_bad_p(p):</span>
    <span class="s0"># Raise ValueError if p &lt;=0.</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">minkowski([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">minkowski([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_sokalsneath_all_false():</span>
    <span class="s0"># Regression test for ticket #876</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sokalsneath([</span><span class="s2">False, False, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, False, False</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_canberra():</span>
    <span class="s0"># Regression test for ticket #1430.</span>
    <span class="s1">assert_equal(wcanberra([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">6</span><span class="s1">])</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(wcanberra([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_braycurtis():</span>
    <span class="s0"># Regression test for ticket #1430.</span>
    <span class="s1">assert_almost_equal(wbraycurtis([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">6</span><span class="s1">])</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">/ </span><span class="s5">3</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">15</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(wbraycurtis([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">15</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_euclideans():</span>
    <span class="s0"># Regression test for ticket #1328.</span>
    <span class="s1">x1 = np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">x2 = np.array([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>

    <span class="s0"># Basic test of the calculation.</span>
    <span class="s1">assert_almost_equal(wsqeuclidean(x1</span><span class="s2">, </span><span class="s1">x2)</span><span class="s2">, </span><span class="s5">3.0</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(weuclidean(x1</span><span class="s2">, </span><span class="s1">x2)</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>

    <span class="s0"># Check flattening for (1, N) or (N, 1) inputs</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Input vector should be 1-D&quot;</span><span class="s1">):</span>
        <span class="s1">weuclidean(x1[np.newaxis</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">x2[np.newaxis</span><span class="s2">, </span><span class="s1">:])</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s5">3</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Input vector should be 1-D&quot;</span><span class="s1">):</span>
        <span class="s1">wsqeuclidean(x1[np.newaxis</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">x2[np.newaxis</span><span class="s2">, </span><span class="s1">:])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Input vector should be 1-D&quot;</span><span class="s1">):</span>
        <span class="s1">wsqeuclidean(x1[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span><span class="s2">, </span><span class="s1">x2[:</span><span class="s2">, </span><span class="s1">np.newaxis])</span>

    <span class="s0"># Distance metrics only defined for vectors (= 1-D)</span>
    <span class="s1">x = np.arange(</span><span class="s5">4</span><span class="s1">).reshape(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">weuclidean(x</span><span class="s2">, </span><span class="s1">x)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">wsqeuclidean(x</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s0"># Another check, with random data.</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s5">1234567890</span><span class="s1">)</span>
    <span class="s1">x = rs.rand(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">y = rs.rand(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">d1 = weuclidean(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">d2 = wsqeuclidean(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">assert_almost_equal(d1**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">d2</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">14</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_hamming_unequal_length():</span>
    <span class="s0"># Regression test for gh-4290.</span>
    <span class="s1">x = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0"># Used to give an AttributeError from ndarray.mean called on bool</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">whamming(x</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s2">def </span><span class="s1">test_hamming_unequal_length_with_w():</span>
    <span class="s1">u = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">v = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">w = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">msg = </span><span class="s3">&quot;'w' should have the same length as 'u' and 'v'.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">whamming(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">w)</span>


<span class="s2">def </span><span class="s1">test_hamming_string_array():</span>
    <span class="s0"># https://github.com/scikit-learn/scikit-learn/issues/4014</span>
    <span class="s1">a = np.array([</span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">,</span>
                  <span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">,</span>
                  <span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">dtype=</span><span class="s3">'|S4'</span><span class="s1">)</span>
    <span class="s1">b = np.array([</span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">,</span>
                  <span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">,</span>
                  <span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'spam'</span><span class="s2">, </span><span class="s3">'eggs'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">dtype=</span><span class="s3">'|S4'</span><span class="s1">)</span>
    <span class="s1">desired = </span><span class="s5">0.45</span>
    <span class="s1">assert_allclose(whamming(a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_minkowski_w():</span>
    <span class="s0"># Regression test for gh-8142.</span>
    <span class="s1">arr_in = np.array([[</span><span class="s5">83.33333333</span><span class="s2">, </span><span class="s5">100.</span><span class="s2">, </span><span class="s5">83.33333333</span><span class="s2">, </span><span class="s5">100.</span><span class="s2">, </span><span class="s5">36.</span><span class="s2">,</span>
                        <span class="s5">60.</span><span class="s2">, </span><span class="s5">90.</span><span class="s2">, </span><span class="s5">150.</span><span class="s2">, </span><span class="s5">24.</span><span class="s2">, </span><span class="s5">48.</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">[</span><span class="s5">83.33333333</span><span class="s2">, </span><span class="s5">100.</span><span class="s2">, </span><span class="s5">83.33333333</span><span class="s2">, </span><span class="s5">100.</span><span class="s2">, </span><span class="s5">36.</span><span class="s2">,</span>
                        <span class="s5">60.</span><span class="s2">, </span><span class="s5">90.</span><span class="s2">, </span><span class="s5">150.</span><span class="s2">, </span><span class="s5">24.</span><span class="s2">, </span><span class="s5">48.</span><span class="s1">]])</span>
    <span class="s1">p0 = pdist(arr_in</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">w=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">c0 = cdist(arr_in</span><span class="s2">, </span><span class="s1">arr_in</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">w=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">p1 = pdist(arr_in</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">c1 = cdist(arr_in</span><span class="s2">, </span><span class="s1">arr_in</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'minkowski'</span><span class="s2">, </span><span class="s1">p=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">assert_allclose(p0</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-15</span><span class="s1">)</span>
    <span class="s1">assert_allclose(c0</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-15</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sqeuclidean_dtypes():</span>
    <span class="s0"># Assert that sqeuclidean returns the right types of values.</span>
    <span class="s0"># Integer types should be converted to floating for stability.</span>
    <span class="s0"># Floating point types should be the same as the input.</span>
    <span class="s1">x = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">[np.int8</span><span class="s2">, </span><span class="s1">np.int16</span><span class="s2">, </span><span class="s1">np.int32</span><span class="s2">, </span><span class="s1">np.int64]:</span>
        <span class="s1">d = wsqeuclidean(np.asarray(x</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">np.asarray(y</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>
        <span class="s1">assert_(np.issubdtype(d.dtype</span><span class="s2">, </span><span class="s1">np.floating))</span>

    <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">[np.uint8</span><span class="s2">, </span><span class="s1">np.uint16</span><span class="s2">, </span><span class="s1">np.uint32</span><span class="s2">, </span><span class="s1">np.uint64]:</span>
        <span class="s1">umax = np.iinfo(dtype).max</span>
        <span class="s1">d1 = wsqeuclidean([</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.asarray([umax]</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>
        <span class="s1">d2 = wsqeuclidean(np.asarray([umax]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s1">assert_equal(d1</span><span class="s2">, </span><span class="s1">d2)</span>
        <span class="s1">assert_equal(d1</span><span class="s2">, </span><span class="s1">np.float64(umax)**</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">dtypes = [np.float32</span><span class="s2">, </span><span class="s1">np.float64</span><span class="s2">, </span><span class="s1">np.complex64</span><span class="s2">, </span><span class="s1">np.complex128]</span>
    <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'float16'</span><span class="s2">, </span><span class="s3">'float128'</span><span class="s1">]:</span>
        <span class="s0"># These aren't present in older numpy versions; float128 may also not</span>
        <span class="s0"># be present on all platforms.</span>
        <span class="s2">if </span><span class="s1">hasattr(np</span><span class="s2">, </span><span class="s1">dtype):</span>
            <span class="s1">dtypes.append(getattr(np</span><span class="s2">, </span><span class="s1">dtype))</span>

    <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">dtypes:</span>
        <span class="s1">d = wsqeuclidean(np.asarray(x</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">np.asarray(y</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>
        <span class="s1">assert_equal(d.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>


<span class="s2">def </span><span class="s1">test_sokalmichener():</span>
    <span class="s0"># Test that sokalmichener has the same result for bool and int inputs.</span>
    <span class="s1">p = [</span><span class="s2">True, True, False</span><span class="s1">]</span>
    <span class="s1">q = [</span><span class="s2">True, False, True</span><span class="s1">]</span>
    <span class="s1">x = [int(b) </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">p]</span>
    <span class="s1">y = [int(b) </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">q]</span>
    <span class="s1">dist1 = sokalmichener(p</span><span class="s2">, </span><span class="s1">q)</span>
    <span class="s1">dist2 = sokalmichener(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s0"># These should be exactly the same.</span>
    <span class="s1">assert_equal(dist1</span><span class="s2">, </span><span class="s1">dist2)</span>


<span class="s2">def </span><span class="s1">test_sokalmichener_with_weight():</span>
    <span class="s0"># from: | 1 |   | 0 |</span>
    <span class="s0"># to:   | 1 |   | 1 |</span>
    <span class="s0"># weight|   | 1 |   | 0.2</span>
    <span class="s1">ntf = </span><span class="s5">0 </span><span class="s1">* </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">0 </span><span class="s1">* </span><span class="s5">0.2</span>
    <span class="s1">nft = </span><span class="s5">0 </span><span class="s1">* </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">* </span><span class="s5">0.2</span>
    <span class="s1">ntt = </span><span class="s5">1 </span><span class="s1">* </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">0 </span><span class="s1">* </span><span class="s5">0.2</span>
    <span class="s1">nff = </span><span class="s5">0 </span><span class="s1">* </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">0 </span><span class="s1">* </span><span class="s5">0.2</span>
    <span class="s1">expected = </span><span class="s5">2 </span><span class="s1">* (nft + ntf) / (ntt + nff + </span><span class="s5">2 </span><span class="s1">* (nft + ntf))</span>
    <span class="s1">assert_almost_equal(expected</span><span class="s2">, </span><span class="s5">0.2857143</span><span class="s1">)</span>
    <span class="s1">actual = sokalmichener([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">w=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s1">])</span>
    <span class="s1">assert_almost_equal(expected</span><span class="s2">, </span><span class="s1">actual)</span>

    <span class="s1">a1 = [</span><span class="s2">False, False, True, True, True, False, False, True, True, True, True,</span>
          <span class="s2">True, True, False, True, False, False, False, True, True</span><span class="s1">]</span>
    <span class="s1">a2 = [</span><span class="s2">True, True, True, False, False, True, True, True, False, True,</span>
          <span class="s2">True, True, True, True, False, False, False, True, True, True</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">[</span><span class="s5">0.05</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">20.0</span><span class="s1">]:</span>
        <span class="s1">assert_almost_equal(sokalmichener(a2</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">, </span><span class="s1">[w])</span><span class="s2">, </span><span class="s5">0.6666666666666666</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_modifies_input(metric):</span>
    <span class="s0"># test whether cdist or pdist modifies input arrays</span>
    <span class="s1">X1 = np.asarray([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">]</span><span class="s2">,</span>
                     <span class="s1">[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s2">, </span><span class="s5">3.4</span><span class="s1">]</span><span class="s2">,</span>
                     <span class="s1">[</span><span class="s5">2.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s2">, </span><span class="s5">4.4</span><span class="s1">]</span><span class="s2">,</span>
                     <span class="s1">[</span><span class="s5">22.2</span><span class="s2">, </span><span class="s5">23.3</span><span class="s2">, </span><span class="s5">44.4</span><span class="s1">]])</span>
    <span class="s1">X1_copy = X1.copy()</span>
    <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X1</span><span class="s2">, </span><span class="s1">metric)</span>
    <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric)</span>
    <span class="s1">assert_array_equal(X1</span><span class="s2">, </span><span class="s1">X1_copy)</span>


<span class="s2">def </span><span class="s1">test_Xdist_deprecated_args(metric):</span>
    <span class="s0"># testing both cdist and pdist deprecated warnings</span>
    <span class="s1">X1 = np.asarray([[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">]</span><span class="s2">,</span>
                     <span class="s1">[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s2">, </span><span class="s5">3.4</span><span class="s1">]</span><span class="s2">,</span>
                     <span class="s1">[</span><span class="s5">2.2</span><span class="s2">, </span><span class="s5">2.3</span><span class="s2">, </span><span class="s5">4.4</span><span class="s1">]</span><span class="s2">,</span>
                     <span class="s1">[</span><span class="s5">22.2</span><span class="s2">, </span><span class="s5">23.3</span><span class="s2">, </span><span class="s5">44.4</span><span class="s1">]])</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X1</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;p&quot;</span><span class="s2">, </span><span class="s3">&quot;V&quot;</span><span class="s2">, </span><span class="s3">&quot;VI&quot;</span><span class="s1">]:</span>
        <span class="s1">kwargs = {arg: </span><span class="s3">&quot;foo&quot;</span><span class="s1">}</span>

        <span class="s2">if </span><span class="s1">((arg == </span><span class="s3">&quot;V&quot; </span><span class="s2">and </span><span class="s1">metric == </span><span class="s3">&quot;seuclidean&quot;</span><span class="s1">)</span>
                <span class="s2">or </span><span class="s1">(arg == </span><span class="s3">&quot;VI&quot; </span><span class="s2">and </span><span class="s1">metric == </span><span class="s3">&quot;mahalanobis&quot;</span><span class="s1">)</span>
                <span class="s2">or </span><span class="s1">(arg == </span><span class="s3">&quot;p&quot; </span><span class="s2">and </span><span class="s1">metric == </span><span class="s3">&quot;minkowski&quot;</span><span class="s1">)):</span>
            <span class="s2">continue</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">cdist(X1</span><span class="s2">, </span><span class="s1">X1</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">pdist(X1</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">test_Xdist_non_negative_weights(metric):</span>
    <span class="s1">X = eo[</span><span class="s3">'random-float32-data'</span><span class="s1">][::</span><span class="s5">5</span><span class="s2">, </span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">w = np.ones(X.shape[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">w[::</span><span class="s5">5</span><span class="s1">] = -w[::</span><span class="s5">5</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">metric </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'seuclidean'</span><span class="s2">, </span><span class="s3">'mahalanobis'</span><span class="s2">, </span><span class="s3">'jensenshannon'</span><span class="s1">]:</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;not applicable&quot;</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">[metric</span><span class="s2">, </span><span class="s1">eval(metric)</span><span class="s2">, </span><span class="s3">&quot;test_&quot; </span><span class="s1">+ metric]:</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">pdist(X</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">w=w)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cdist(X</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">w=w)</span>


<span class="s2">def </span><span class="s1">test__validate_vector():</span>
    <span class="s1">x = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">y = _validate_vector(x)</span>
    <span class="s1">assert_array_equal(y</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s1">y = _validate_vector(x</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">assert_array_equal(y</span><span class="s2">, </span><span class="s1">x)</span>
    <span class="s1">assert_equal(y.dtype</span><span class="s2">, </span><span class="s1">np.float64)</span>

    <span class="s1">x = [</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">y = _validate_vector(x)</span>
    <span class="s1">assert_equal(y.ndim</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(y</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s1">x = </span><span class="s5">1</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Input vector should be 1-D&quot;</span><span class="s1">):</span>
        <span class="s1">_validate_vector(x)</span>

    <span class="s1">x = np.arange(</span><span class="s5">5</span><span class="s1">).reshape(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Input vector should be 1-D&quot;</span><span class="s1">):</span>
        <span class="s1">_validate_vector(x)</span>

    <span class="s1">x = [[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]]</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Input vector should be 1-D&quot;</span><span class="s1">):</span>
        <span class="s1">_validate_vector(x)</span>

<span class="s2">def </span><span class="s1">test_yule_all_same():</span>
    <span class="s0"># Test yule avoids a divide by zero when exactly equal</span>
    <span class="s1">x = np.ones((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">d = wyule(x[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">d == </span><span class="s5">0.0</span>

    <span class="s1">d = pdist(x</span><span class="s2">, </span><span class="s3">'yule'</span><span class="s1">)</span>
    <span class="s1">assert_equal(d</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.0</span><span class="s1">])</span>

    <span class="s1">d = cdist(x[:</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[:</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'yule'</span><span class="s1">)</span>
    <span class="s1">assert_equal(d</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.0</span><span class="s1">]])</span>


<span class="s2">def </span><span class="s1">test_jensenshannon():</span>
    <span class="s1">assert_almost_equal(jensenshannon([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s5">1.0</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(jensenshannon([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s5">0.46450140402245893</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(jensenshannon([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span>

    <span class="s1">assert_almost_equal(jensenshannon([[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">])</span>
    <span class="s1">assert_almost_equal(jensenshannon([[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">0.0649045</span><span class="s1">])</span>
    <span class="s1">assert_almost_equal(jensenshannon([[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s2">,</span>
                                      <span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(jensenshannon([[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s2">,</span>
                                      <span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.0649045</span><span class="s1">]])</span>

    <span class="s1">a = np.array([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">12</span><span class="s1">]])</span>
    <span class="s1">b = np.array([[</span><span class="s5">13</span><span class="s2">, </span><span class="s5">14</span><span class="s2">, </span><span class="s5">15</span><span class="s2">, </span><span class="s5">16</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">17</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">19</span><span class="s2">, </span><span class="s5">20</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s5">21</span><span class="s2">, </span><span class="s5">22</span><span class="s2">, </span><span class="s5">23</span><span class="s2">, </span><span class="s5">24</span><span class="s1">]])</span>

    <span class="s1">assert_almost_equal(jensenshannon(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">0.1954288</span><span class="s2">, </span><span class="s5">0.1447697</span><span class="s2">, </span><span class="s5">0.1138377</span><span class="s2">, </span><span class="s5">0.0927636</span><span class="s1">])</span>
    <span class="s1">assert_almost_equal(jensenshannon(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">0.1402339</span><span class="s2">, </span><span class="s5">0.0399106</span><span class="s2">, </span><span class="s5">0.0201815</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_gh_17703():</span>
    <span class="s1">arr_1 = np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">arr_2 = np.array([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">expected = dice(arr_1</span><span class="s2">, </span><span class="s1">arr_2)</span>
    <span class="s1">actual = pdist([arr_1</span><span class="s2">, </span><span class="s1">arr_2]</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'dice'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s1">actual = cdist(np.atleast_2d(arr_1)</span><span class="s2">,</span>
                   <span class="s1">np.atleast_2d(arr_2)</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'dice'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>