<html>
<head>
<title>_interface.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_interface.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Abstract linear algebra library. 
 
This module defines a class hierarchy that implements a kind of &quot;lazy&quot; 
matrix representation, called the ``LinearOperator``. It can be used to do 
linear algebra with extremely large sparse or structured matrices, without 
representing those explicitly in memory. Such matrices can be added, 
multiplied, transposed, etc. 
 
As a motivating example, suppose you want have a matrix where almost all of 
the elements have the value one. The standard sparse matrix representation 
skips the storage of zeros, but not ones. By contrast, a LinearOperator is 
able to represent such matrices efficiently. First, we need a compact way to 
represent an all-ones matrix:: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; class Ones(LinearOperator): 
    ...     def __init__(self, shape): 
    ...         super().__init__(dtype=None, shape=shape) 
    ...     def _matvec(self, x): 
    ...         return np.repeat(x.sum(), self.shape[0]) 
 
Instances of this class emulate ``np.ones(shape)``, but using a constant 
amount of storage, independent of ``shape``. The ``_matvec`` method specifies 
how this linear operator multiplies with (operates on) a vector. We can now 
add this operator to a sparse matrix that stores only offsets from one:: 
 
    &gt;&gt;&gt; from scipy.sparse import csr_matrix 
    &gt;&gt;&gt; offsets = csr_matrix([[1, 0, 2], [0, -1, 0], [0, 0, 3]]) 
    &gt;&gt;&gt; A = aslinearoperator(offsets) + Ones(offsets.shape) 
    &gt;&gt;&gt; A.dot([1, 2, 3]) 
    array([13,  4, 15]) 
 
The result is the same as that given by its dense, explicitly-stored 
counterpart:: 
 
    &gt;&gt;&gt; (np.ones(A.shape, A.dtype) + offsets.toarray()).dot([1, 2, 3]) 
    array([13,  4, 15]) 
 
Several algorithms in the ``scipy.sparse`` library are able to operate on 
``LinearOperator`` instances. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">scipy.sparse </span><span class="s2">import </span><span class="s1">issparse</span>
<span class="s2">from </span><span class="s1">scipy.sparse._sputils </span><span class="s2">import </span><span class="s1">isshape</span><span class="s2">, </span><span class="s1">isintlike</span><span class="s2">, </span><span class="s1">asmatrix</span><span class="s2">, </span><span class="s1">is_pydata_spmatrix</span>

<span class="s1">__all__ = [</span><span class="s3">'LinearOperator'</span><span class="s2">, </span><span class="s3">'aslinearoperator'</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">LinearOperator:</span>
    <span class="s0">&quot;&quot;&quot;Common interface for performing matrix vector products 
 
    Many iterative methods (e.g. cg, gmres) do not need to know the 
    individual entries of a matrix to solve a linear system A*x=b. 
    Such solvers only require the computation of matrix vector 
    products, A*v where v is a dense vector.  This class serves as 
    an abstract interface between iterative solvers and matrix-like 
    objects. 
 
    To construct a concrete LinearOperator, either pass appropriate 
    callables to the constructor of this class, or subclass it. 
 
    A subclass must implement either one of the methods ``_matvec`` 
    and ``_matmat``, and the attributes/properties ``shape`` (pair of 
    integers) and ``dtype`` (may be None). It may call the ``__init__`` 
    on this class to have these attributes validated. Implementing 
    ``_matvec`` automatically implements ``_matmat`` (using a naive 
    algorithm) and vice-versa. 
 
    Optionally, a subclass may implement ``_rmatvec`` or ``_adjoint`` 
    to implement the Hermitian adjoint (conjugate transpose). As with 
    ``_matvec`` and ``_matmat``, implementing either ``_rmatvec`` or 
    ``_adjoint`` implements the other automatically. Implementing 
    ``_adjoint`` is preferable; ``_rmatvec`` is mostly there for 
    backwards compatibility. 
 
    Parameters 
    ---------- 
    shape : tuple 
        Matrix dimensions (M, N). 
    matvec : callable f(v) 
        Returns returns A * v. 
    rmatvec : callable f(v) 
        Returns A^H * v, where A^H is the conjugate transpose of A. 
    matmat : callable f(V) 
        Returns A * V, where V is a dense matrix with dimensions (N, K). 
    dtype : dtype 
        Data type of the matrix. 
    rmatmat : callable f(V) 
        Returns A^H * V, where V is a dense matrix with dimensions (M, K). 
 
    Attributes 
    ---------- 
    args : tuple 
        For linear operators describing products etc. of other linear 
        operators, the operands of the binary operation. 
    ndim : int 
        Number of dimensions (this is always 2) 
 
    See Also 
    -------- 
    aslinearoperator : Construct LinearOperators 
 
    Notes 
    ----- 
    The user-defined matvec() function must properly handle the case 
    where v has shape (N,) as well as the (N,1) case.  The shape of 
    the return type is handled internally by LinearOperator. 
 
    LinearOperator instances can also be multiplied, added with each 
    other and exponentiated, all lazily: the result of these operations 
    is always a new, composite LinearOperator, that defers linear 
    operations to the original operators and combines the results. 
 
    More details regarding how to subclass a LinearOperator and several 
    examples of concrete LinearOperator instances can be found in the 
    external project `PyLops &lt;https://pylops.readthedocs.io&gt;`_. 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse.linalg import LinearOperator 
    &gt;&gt;&gt; def mv(v): 
    ...     return np.array([2*v[0], 3*v[1]]) 
    ... 
    &gt;&gt;&gt; A = LinearOperator((2,2), matvec=mv) 
    &gt;&gt;&gt; A 
    &lt;2x2 _CustomLinearOperator with dtype=float64&gt; 
    &gt;&gt;&gt; A.matvec(np.ones(2)) 
    array([ 2.,  3.]) 
    &gt;&gt;&gt; A * np.ones(2) 
    array([ 2.,  3.]) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">ndim = </span><span class="s4">2</span>
    <span class="s5"># Necessary for right matmul with numpy arrays.</span>
    <span class="s1">__array_ufunc__ = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">cls </span><span class="s2">is </span><span class="s1">LinearOperator:</span>
            <span class="s5"># Operate as _CustomLinearOperator factory.</span>
            <span class="s2">return </span><span class="s1">super().__new__(_CustomLinearOperator)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">obj = super().__new__(cls)</span>

            <span class="s2">if </span><span class="s1">(type(obj)._matvec == LinearOperator._matvec</span>
                    <span class="s2">and </span><span class="s1">type(obj)._matmat == LinearOperator._matmat):</span>
                <span class="s1">warnings.warn(</span><span class="s3">&quot;LinearOperator subclass should implement&quot;</span>
                              <span class="s3">&quot; at least one of _matvec and _matmat.&quot;</span><span class="s2">,</span>
                              <span class="s1">category=RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape):</span>
        <span class="s0">&quot;&quot;&quot;Initialize this LinearOperator. 
 
        To be called by subclasses. ``dtype`` may be None; ``shape`` should 
        be convertible to a length-2 tuple. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(dtype)</span>

        <span class="s1">shape = tuple(shape)</span>
        <span class="s2">if not </span><span class="s1">isshape(shape):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;invalid shape </span><span class="s2">{</span><span class="s1">shape</span><span class="s2">!r} </span><span class="s3">(must be 2-d)&quot;</span><span class="s1">)</span>

        <span class="s1">self.dtype = dtype</span>
        <span class="s1">self.shape = shape</span>

    <span class="s2">def </span><span class="s1">_init_dtype(self):</span>
        <span class="s0">&quot;&quot;&quot;Called from subclasses at the end of the __init__ routine. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">v = np.zeros(self.shape[-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">self.dtype = np.asarray(self.matvec(v)).dtype</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Default matrix-matrix multiplication handler. 
 
        Falls back on the user-defined _matvec method, so defining that will 
        define matrix multiplication (though in a very suboptimal way). 
        &quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">np.hstack([self.matvec(col.reshape(-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">X.T])</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Default matrix-vector multiplication handler. 
 
        If self is a linear operator of shape (M, N), then this method will 
        be called on a shape (N,) or (N, 1) ndarray, and should return a 
        shape (M,) or (M, 1) ndarray. 
 
        This default implementation falls back on _matmat, so defining that 
        will define matrix-vector multiplication as well. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.matmat(x.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Matrix-vector multiplication. 
 
        Performs the operation y=A*x where A is an MxN linear 
        operator and x is a column vector or 1-d array. 
 
        Parameters 
        ---------- 
        x : {matrix, ndarray} 
            An array with shape (N,) or (N,1). 
 
        Returns 
        ------- 
        y : {matrix, ndarray} 
            A matrix or ndarray with shape (M,) or (M,1) depending 
            on the type and shape of the x argument. 
 
        Notes 
        ----- 
        This matvec wraps the user-specified matvec routine or overridden 
        _matvec method to ensure that y has the correct shape and type. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">x = np.asanyarray(x)</span>

        <span class="s1">M</span><span class="s2">,</span><span class="s1">N = self.shape</span>

        <span class="s2">if </span><span class="s1">x.shape != (N</span><span class="s2">,</span><span class="s1">) </span><span class="s2">and </span><span class="s1">x.shape != (N</span><span class="s2">,</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'dimension mismatch'</span><span class="s1">)</span>

        <span class="s1">y = self._matvec(x)</span>

        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.matrix):</span>
            <span class="s1">y = asmatrix(y)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">y = np.asarray(y)</span>

        <span class="s2">if </span><span class="s1">x.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">y = y.reshape(M)</span>
        <span class="s2">elif </span><span class="s1">x.ndim == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">y = y.reshape(M</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'invalid shape returned by user-defined matvec()'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Adjoint matrix-vector multiplication. 
 
        Performs the operation y = A^H * x where A is an MxN linear 
        operator and x is a column vector or 1-d array. 
 
        Parameters 
        ---------- 
        x : {matrix, ndarray} 
            An array with shape (M,) or (M,1). 
 
        Returns 
        ------- 
        y : {matrix, ndarray} 
            A matrix or ndarray with shape (N,) or (N,1) depending 
            on the type and shape of the x argument. 
 
        Notes 
        ----- 
        This rmatvec wraps the user-specified rmatvec routine or overridden 
        _rmatvec method to ensure that y has the correct shape and type. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">x = np.asanyarray(x)</span>

        <span class="s1">M</span><span class="s2">,</span><span class="s1">N = self.shape</span>

        <span class="s2">if </span><span class="s1">x.shape != (M</span><span class="s2">,</span><span class="s1">) </span><span class="s2">and </span><span class="s1">x.shape != (M</span><span class="s2">,</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'dimension mismatch'</span><span class="s1">)</span>

        <span class="s1">y = self._rmatvec(x)</span>

        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.matrix):</span>
            <span class="s1">y = asmatrix(y)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">y = np.asarray(y)</span>

        <span class="s2">if </span><span class="s1">x.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">y = y.reshape(N)</span>
        <span class="s2">elif </span><span class="s1">x.ndim == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">y = y.reshape(N</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'invalid shape returned by user-defined rmatvec()'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Default implementation of _rmatvec; defers to adjoint.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">type(self)._adjoint == LinearOperator._adjoint:</span>
            <span class="s5"># _adjoint not overridden, prevent infinite recursion</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.H.matvec(x)</span>

    <span class="s2">def </span><span class="s1">matmat(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Matrix-matrix multiplication. 
 
        Performs the operation y=A*X where A is an MxN linear 
        operator and X dense N*K matrix or ndarray. 
 
        Parameters 
        ---------- 
        X : {matrix, ndarray} 
            An array with shape (N,K). 
 
        Returns 
        ------- 
        Y : {matrix, ndarray} 
            A matrix or ndarray with shape (M,K) depending on 
            the type of the X argument. 
 
        Notes 
        ----- 
        This matmat wraps any user-specified matmat routine or overridden 
        _matmat method to ensure that y has the correct type. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">(issparse(X) </span><span class="s2">or </span><span class="s1">is_pydata_spmatrix(X)):</span>
            <span class="s1">X = np.asanyarray(X)</span>

        <span class="s2">if </span><span class="s1">X.ndim != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'expected 2-d ndarray or matrix, not </span><span class="s2">{</span><span class="s1">X.ndim</span><span class="s2">}</span><span class="s3">-d'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">X.shape[</span><span class="s4">0</span><span class="s1">] != self.shape[</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'dimension mismatch: </span><span class="s2">{</span><span class="s1">self.shape</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">X.shape</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">Y = self._matmat(X)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">issparse(X) </span><span class="s2">or </span><span class="s1">is_pydata_spmatrix(X):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;Unable to multiply a LinearOperator with a sparse matrix.&quot;</span>
                    <span class="s3">&quot; Wrap the matrix in aslinearoperator first.&quot;</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
            <span class="s2">raise</span>

        <span class="s2">if </span><span class="s1">isinstance(Y</span><span class="s2">, </span><span class="s1">np.matrix):</span>
            <span class="s1">Y = asmatrix(Y)</span>

        <span class="s2">return </span><span class="s1">Y</span>

    <span class="s2">def </span><span class="s1">rmatmat(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Adjoint matrix-matrix multiplication. 
 
        Performs the operation y = A^H * x where A is an MxN linear 
        operator and x is a column vector or 1-d array, or 2-d array. 
        The default implementation defers to the adjoint. 
 
        Parameters 
        ---------- 
        X : {matrix, ndarray} 
            A matrix or 2D array. 
 
        Returns 
        ------- 
        Y : {matrix, ndarray} 
            A matrix or 2D array depending on the type of the input. 
 
        Notes 
        ----- 
        This rmatmat wraps the user-specified rmatmat routine. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">(issparse(X) </span><span class="s2">or </span><span class="s1">is_pydata_spmatrix(X)):</span>
            <span class="s1">X = np.asanyarray(X)</span>

        <span class="s2">if </span><span class="s1">X.ndim != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'expected 2-d ndarray or matrix, not %d-d'</span>
                             <span class="s1">% X.ndim)</span>

        <span class="s2">if </span><span class="s1">X.shape[</span><span class="s4">0</span><span class="s1">] != self.shape[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'dimension mismatch: </span><span class="s2">{</span><span class="s1">self.shape</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">X.shape</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">Y = self._rmatmat(X)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">issparse(X) </span><span class="s2">or </span><span class="s1">is_pydata_spmatrix(X):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;Unable to multiply a LinearOperator with a sparse matrix.&quot;</span>
                    <span class="s3">&quot; Wrap the matrix in aslinearoperator() first.&quot;</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
            <span class="s2">raise</span>

        <span class="s2">if </span><span class="s1">isinstance(Y</span><span class="s2">, </span><span class="s1">np.matrix):</span>
            <span class="s1">Y = asmatrix(Y)</span>
        <span class="s2">return </span><span class="s1">Y</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Default implementation of _rmatmat defers to rmatvec or adjoint.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">type(self)._adjoint == LinearOperator._adjoint:</span>
            <span class="s2">return </span><span class="s1">np.hstack([self.rmatvec(col.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">X.T])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.H.matmat(X)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self*x</span>

    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.dot(x)</span>

    <span class="s2">def </span><span class="s1">__truediv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">np.isscalar(other):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Can only divide a linear operator by a scalar.&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">_ScaledLinearOperator(self</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/other)</span>

    <span class="s2">def </span><span class="s1">dot(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Matrix-matrix or matrix-vector multiplication. 
 
        Parameters 
        ---------- 
        x : array_like 
            1-d or 2-d array, representing a vector or matrix. 
 
        Returns 
        ------- 
        Ax : array 
            1-d or 2-d array (depending on the shape of x) that represents 
            the result of applying this linear operator on x. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">LinearOperator):</span>
            <span class="s2">return </span><span class="s1">_ProductLinearOperator(self</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">elif </span><span class="s1">np.isscalar(x):</span>
            <span class="s2">return </span><span class="s1">_ScaledLinearOperator(self</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">issparse(x) </span><span class="s2">and not </span><span class="s1">is_pydata_spmatrix(x):</span>
                <span class="s5"># Sparse matrices shouldn't be converted to numpy arrays.</span>
                <span class="s1">x = np.asarray(x)</span>

            <span class="s2">if </span><span class="s1">x.ndim == </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">x.ndim == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">x.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.matvec(x)</span>
            <span class="s2">elif </span><span class="s1">x.ndim == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.matmat(x)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'expected 1-d or 2-d array or matrix, got %r'</span>
                                 <span class="s1">% x)</span>

    <span class="s2">def </span><span class="s1">__matmul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">np.isscalar(other):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Scalar operands are not allowed, &quot;</span>
                             <span class="s3">&quot;use '*' instead&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.__mul__(other)</span>

    <span class="s2">def </span><span class="s1">__rmatmul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">np.isscalar(other):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Scalar operands are not allowed, &quot;</span>
                             <span class="s3">&quot;use '*' instead&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.__rmul__(other)</span>

    <span class="s2">def </span><span class="s1">__rmul__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">if </span><span class="s1">np.isscalar(x):</span>
            <span class="s2">return </span><span class="s1">_ScaledLinearOperator(self</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._rdot(x)</span>

    <span class="s2">def </span><span class="s1">_rdot(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Matrix-matrix or matrix-vector multiplication from the right. 
 
        Parameters 
        ---------- 
        x : array_like 
            1-d or 2-d array, representing a vector or matrix. 
 
        Returns 
        ------- 
        xA : array 
            1-d or 2-d array (depending on the shape of x) that represents 
            the result of applying this linear operator on x from the right. 
 
        Notes 
        ----- 
        This is copied from dot to implement right multiplication. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">LinearOperator):</span>
            <span class="s2">return </span><span class="s1">_ProductLinearOperator(x</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">elif </span><span class="s1">np.isscalar(x):</span>
            <span class="s2">return </span><span class="s1">_ScaledLinearOperator(self</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">issparse(x) </span><span class="s2">and not </span><span class="s1">is_pydata_spmatrix(x):</span>
                <span class="s5"># Sparse matrices shouldn't be converted to numpy arrays.</span>
                <span class="s1">x = np.asarray(x)</span>

            <span class="s5"># We use transpose instead of rmatvec/rmatmat to avoid</span>
            <span class="s5"># unnecessary complex conjugation if possible.</span>
            <span class="s2">if </span><span class="s1">x.ndim == </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">x.ndim == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">x.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.T.matvec(x.T).T</span>
            <span class="s2">elif </span><span class="s1">x.ndim == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.T.matmat(x.T).T</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'expected 1-d or 2-d array or matrix, got %r'</span>
                                 <span class="s1">% x)</span>

    <span class="s2">def </span><span class="s1">__pow__(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">if </span><span class="s1">np.isscalar(p):</span>
            <span class="s2">return </span><span class="s1">_PowerLinearOperator(self</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">LinearOperator):</span>
            <span class="s2">return </span><span class="s1">_SumLinearOperator(self</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__neg__(self):</span>
        <span class="s2">return </span><span class="s1">_ScaledLinearOperator(self</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.__add__(-x)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">M</span><span class="s2">,</span><span class="s1">N = self.shape</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dt = </span><span class="s3">'unspecified dtype'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dt = </span><span class="s3">'dtype=' </span><span class="s1">+ str(self.dtype)</span>

        <span class="s2">return </span><span class="s3">'&lt;%dx%d %s with %s&gt;' </span><span class="s1">% (M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self.__class__.__name__</span><span class="s2">, </span><span class="s1">dt)</span>

    <span class="s2">def </span><span class="s1">adjoint(self):</span>
        <span class="s0">&quot;&quot;&quot;Hermitian adjoint. 
 
        Returns the Hermitian adjoint of self, aka the Hermitian 
        conjugate or Hermitian transpose. For a complex matrix, the 
        Hermitian adjoint is equal to the conjugate transpose. 
 
        Can be abbreviated self.H instead of self.adjoint(). 
 
        Returns 
        ------- 
        A_H : LinearOperator 
            Hermitian adjoint of self. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._adjoint()</span>

    <span class="s1">H = property(adjoint)</span>

    <span class="s2">def </span><span class="s1">transpose(self):</span>
        <span class="s0">&quot;&quot;&quot;Transpose this linear operator. 
 
        Returns a LinearOperator that represents the transpose of this one. 
        Can be abbreviated self.T instead of self.transpose(). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._transpose()</span>

    <span class="s1">T = property(transpose)</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s0">&quot;&quot;&quot;Default implementation of _adjoint; defers to rmatvec.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">_AdjointLinearOperator(self)</span>

    <span class="s2">def </span><span class="s1">_transpose(self):</span>
        <span class="s0">&quot;&quot;&quot; Default implementation of _transpose; defers to rmatvec + conj&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">_TransposedLinearOperator(self)</span>


<span class="s2">class </span><span class="s1">_CustomLinearOperator(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot;Linear operator defined in terms of user-specified operations.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">matvec</span><span class="s2">, </span><span class="s1">rmatvec=</span><span class="s2">None, </span><span class="s1">matmat=</span><span class="s2">None,</span>
                 <span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">rmatmat=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(dtype</span><span class="s2">, </span><span class="s1">shape)</span>

        <span class="s1">self.args = ()</span>

        <span class="s1">self.__matvec_impl = matvec</span>
        <span class="s1">self.__rmatvec_impl = rmatvec</span>
        <span class="s1">self.__rmatmat_impl = rmatmat</span>
        <span class="s1">self.__matmat_impl = matmat</span>

        <span class="s1">self._init_dtype()</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">if </span><span class="s1">self.__matmat_impl </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__matmat_impl(X)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super()._matmat(X)</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.__matvec_impl(x)</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">func = self.__rmatvec_impl</span>
        <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;rmatvec is not defined&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.__rmatvec_impl(x)</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">if </span><span class="s1">self.__rmatmat_impl </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__rmatmat_impl(X)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super()._rmatmat(X)</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s2">return </span><span class="s1">_CustomLinearOperator(shape=(self.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                                     <span class="s1">matvec=self.__rmatvec_impl</span><span class="s2">,</span>
                                     <span class="s1">rmatvec=self.__matvec_impl</span><span class="s2">,</span>
                                     <span class="s1">matmat=self.__rmatmat_impl</span><span class="s2">,</span>
                                     <span class="s1">rmatmat=self.__matmat_impl</span><span class="s2">,</span>
                                     <span class="s1">dtype=self.dtype)</span>


<span class="s2">class </span><span class="s1">_AdjointLinearOperator(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot;Adjoint of arbitrary Linear Operator&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s1">shape = (A.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">super().__init__(dtype=A.dtype</span><span class="s2">, </span><span class="s1">shape=shape)</span>
        <span class="s1">self.A = A</span>
        <span class="s1">self.args = (A</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.A._rmatvec(x)</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.A._matvec(x)</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.A._rmatmat(x)</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.A._matmat(x)</span>

<span class="s2">class </span><span class="s1">_TransposedLinearOperator(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot;Transposition of arbitrary Linear Operator&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s1">shape = (A.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">super().__init__(dtype=A.dtype</span><span class="s2">, </span><span class="s1">shape=shape)</span>
        <span class="s1">self.A = A</span>
        <span class="s1">self.args = (A</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s5"># NB. np.conj works also on sparse matrices</span>
        <span class="s2">return </span><span class="s1">np.conj(self.A._rmatvec(np.conj(x)))</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.conj(self.A._matvec(np.conj(x)))</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s5"># NB. np.conj works also on sparse matrices</span>
        <span class="s2">return </span><span class="s1">np.conj(self.A._rmatmat(np.conj(x)))</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.conj(self.A._matmat(np.conj(x)))</span>

<span class="s2">def </span><span class="s1">_get_dtype(operators</span><span class="s2">, </span><span class="s1">dtypes=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">dtypes </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">dtypes = []</span>
    <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">operators:</span>
        <span class="s2">if </span><span class="s1">obj </span><span class="s2">is not None and </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">'dtype'</span><span class="s1">):</span>
            <span class="s1">dtypes.append(obj.dtype)</span>
    <span class="s2">return </span><span class="s1">np.result_type(*dtypes)</span>


<span class="s2">class </span><span class="s1">_SumLinearOperator(LinearOperator):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">B):</span>
        <span class="s2">if not </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">LinearOperator) </span><span class="s2">or </span><span class="s1">\</span>
                <span class="s2">not </span><span class="s1">isinstance(B</span><span class="s2">, </span><span class="s1">LinearOperator):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'both operands have to be a LinearOperator'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">A.shape != B.shape:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'cannot add </span><span class="s2">{</span><span class="s1">A</span><span class="s2">} </span><span class="s3">and </span><span class="s2">{</span><span class="s1">B</span><span class="s2">}</span><span class="s3">: shape mismatch'</span><span class="s1">)</span>
        <span class="s1">self.args = (A</span><span class="s2">, </span><span class="s1">B)</span>
        <span class="s1">super().__init__(_get_dtype([A</span><span class="s2">, </span><span class="s1">B])</span><span class="s2">, </span><span class="s1">A.shape)</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">0</span><span class="s1">].matvec(x) + self.args[</span><span class="s4">1</span><span class="s1">].matvec(x)</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">0</span><span class="s1">].rmatvec(x) + self.args[</span><span class="s4">1</span><span class="s1">].rmatvec(x)</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">0</span><span class="s1">].rmatmat(x) + self.args[</span><span class="s4">1</span><span class="s1">].rmatmat(x)</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">0</span><span class="s1">].matmat(x) + self.args[</span><span class="s4">1</span><span class="s1">].matmat(x)</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s1">A</span><span class="s2">, </span><span class="s1">B = self.args</span>
        <span class="s2">return </span><span class="s1">A.H + B.H</span>


<span class="s2">class </span><span class="s1">_ProductLinearOperator(LinearOperator):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">B):</span>
        <span class="s2">if not </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">LinearOperator) </span><span class="s2">or </span><span class="s1">\</span>
                <span class="s2">not </span><span class="s1">isinstance(B</span><span class="s2">, </span><span class="s1">LinearOperator):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'both operands have to be a LinearOperator'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">A.shape[</span><span class="s4">1</span><span class="s1">] != B.shape[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'cannot multiply </span><span class="s2">{</span><span class="s1">A</span><span class="s2">} </span><span class="s3">and </span><span class="s2">{</span><span class="s1">B</span><span class="s2">}</span><span class="s3">: shape mismatch'</span><span class="s1">)</span>
        <span class="s1">super().__init__(_get_dtype([A</span><span class="s2">, </span><span class="s1">B])</span><span class="s2">,</span>
                                                     <span class="s1">(A.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">B.shape[</span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s1">self.args = (A</span><span class="s2">, </span><span class="s1">B)</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">0</span><span class="s1">].matvec(self.args[</span><span class="s4">1</span><span class="s1">].matvec(x))</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">1</span><span class="s1">].rmatvec(self.args[</span><span class="s4">0</span><span class="s1">].rmatvec(x))</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">1</span><span class="s1">].rmatmat(self.args[</span><span class="s4">0</span><span class="s1">].rmatmat(x))</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">0</span><span class="s1">].matmat(self.args[</span><span class="s4">1</span><span class="s1">].matmat(x))</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s1">A</span><span class="s2">, </span><span class="s1">B = self.args</span>
        <span class="s2">return </span><span class="s1">B.H * A.H</span>


<span class="s2">class </span><span class="s1">_ScaledLinearOperator(LinearOperator):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s2">if not </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">LinearOperator):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'LinearOperator expected as A'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">np.isscalar(alpha):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'scalar expected as alpha'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">_ScaledLinearOperator):</span>
            <span class="s1">A</span><span class="s2">, </span><span class="s1">alpha_original = A.args</span>
            <span class="s5"># Avoid in-place multiplication so that we don't accidentally mutate</span>
            <span class="s5"># the original prefactor.</span>
            <span class="s1">alpha = alpha * alpha_original</span>

        <span class="s1">dtype = _get_dtype([A]</span><span class="s2">, </span><span class="s1">[type(alpha)])</span>
        <span class="s1">super().__init__(dtype</span><span class="s2">, </span><span class="s1">A.shape)</span>
        <span class="s1">self.args = (A</span><span class="s2">, </span><span class="s1">alpha)</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">1</span><span class="s1">] * self.args[</span><span class="s4">0</span><span class="s1">].matvec(x)</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.conj(self.args[</span><span class="s4">1</span><span class="s1">]) * self.args[</span><span class="s4">0</span><span class="s1">].rmatvec(x)</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.conj(self.args[</span><span class="s4">1</span><span class="s1">]) * self.args[</span><span class="s4">0</span><span class="s1">].rmatmat(x)</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self.args[</span><span class="s4">1</span><span class="s1">] * self.args[</span><span class="s4">0</span><span class="s1">].matmat(x)</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s1">A</span><span class="s2">, </span><span class="s1">alpha = self.args</span>
        <span class="s2">return </span><span class="s1">A.H * np.conj(alpha)</span>


<span class="s2">class </span><span class="s1">_PowerLinearOperator(LinearOperator):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">if not </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">LinearOperator):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'LinearOperator expected as A'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">A.shape[</span><span class="s4">0</span><span class="s1">] != A.shape[</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'square LinearOperator expected, got %r' </span><span class="s1">% A)</span>
        <span class="s2">if not </span><span class="s1">isintlike(p) </span><span class="s2">or </span><span class="s1">p &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'non-negative integer expected as p'</span><span class="s1">)</span>

        <span class="s1">super().__init__(_get_dtype([A])</span><span class="s2">, </span><span class="s1">A.shape)</span>
        <span class="s1">self.args = (A</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s2">def </span><span class="s1">_power(self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">res = np.array(x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.args[</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">res = fun(res)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self._power(self.args[</span><span class="s4">0</span><span class="s1">].matvec</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self._power(self.args[</span><span class="s4">0</span><span class="s1">].rmatvec</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self._power(self.args[</span><span class="s4">0</span><span class="s1">].rmatmat</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">self._power(self.args[</span><span class="s4">0</span><span class="s1">].matmat</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s1">A</span><span class="s2">, </span><span class="s1">p = self.args</span>
        <span class="s2">return </span><span class="s1">A.H ** p</span>


<span class="s2">class </span><span class="s1">MatrixLinearOperator(LinearOperator):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s1">super().__init__(A.dtype</span><span class="s2">, </span><span class="s1">A.shape)</span>
        <span class="s1">self.A = A</span>
        <span class="s1">self.__adj = </span><span class="s2">None</span>
        <span class="s1">self.args = (A</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">return </span><span class="s1">self.A.dot(X)</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s2">if </span><span class="s1">self.__adj </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.__adj = _AdjointMatrixOperator(self)</span>
        <span class="s2">return </span><span class="s1">self.__adj</span>

<span class="s2">class </span><span class="s1">_AdjointMatrixOperator(MatrixLinearOperator):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">adjoint):</span>
        <span class="s1">self.A = adjoint.A.T.conj()</span>
        <span class="s1">self.__adjoint = adjoint</span>
        <span class="s1">self.args = (adjoint</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">self.shape = adjoint.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">adjoint.shape[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dtype(self):</span>
        <span class="s2">return </span><span class="s1">self.__adjoint.dtype</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s2">return </span><span class="s1">self.__adjoint</span>


<span class="s2">class </span><span class="s1">IdentityOperator(LinearOperator):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(dtype</span><span class="s2">, </span><span class="s1">shape)</span>

    <span class="s2">def </span><span class="s1">_matvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">def </span><span class="s1">_rmatvec(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">def </span><span class="s1">_rmatmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">def </span><span class="s1">_matmat(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">def </span><span class="s1">_adjoint(self):</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">aslinearoperator(A):</span>
    <span class="s0">&quot;&quot;&quot;Return A as a LinearOperator. 
 
    'A' may be any of the following types: 
     - ndarray 
     - matrix 
     - sparse matrix (e.g. csr_matrix, lil_matrix, etc.) 
     - LinearOperator 
     - An object with .shape and .matvec attributes 
 
    See the LinearOperator documentation for additional information. 
 
    Notes 
    ----- 
    If 'A' has no .dtype attribute, the data type is determined by calling 
    :func:`LinearOperator.matvec()` - set the .dtype attribute to prevent this 
    call upon the linear operator creation. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse.linalg import aslinearoperator 
    &gt;&gt;&gt; M = np.array([[1,2,3],[4,5,6]], dtype=np.int32) 
    &gt;&gt;&gt; aslinearoperator(M) 
    &lt;2x3 MatrixLinearOperator with dtype=int32&gt; 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">LinearOperator):</span>
        <span class="s2">return </span><span class="s1">A</span>

    <span class="s2">elif </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">or </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">np.matrix):</span>
        <span class="s2">if </span><span class="s1">A.ndim &gt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'array must have ndim &lt;= 2'</span><span class="s1">)</span>
        <span class="s1">A = np.atleast_2d(np.asarray(A))</span>
        <span class="s2">return </span><span class="s1">MatrixLinearOperator(A)</span>

    <span class="s2">elif </span><span class="s1">issparse(A) </span><span class="s2">or </span><span class="s1">is_pydata_spmatrix(A):</span>
        <span class="s2">return </span><span class="s1">MatrixLinearOperator(A)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">hasattr(A</span><span class="s2">, </span><span class="s3">'shape'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(A</span><span class="s2">, </span><span class="s3">'matvec'</span><span class="s1">):</span>
            <span class="s1">rmatvec = </span><span class="s2">None</span>
            <span class="s1">rmatmat = </span><span class="s2">None</span>
            <span class="s1">dtype = </span><span class="s2">None</span>

            <span class="s2">if </span><span class="s1">hasattr(A</span><span class="s2">, </span><span class="s3">'rmatvec'</span><span class="s1">):</span>
                <span class="s1">rmatvec = A.rmatvec</span>
            <span class="s2">if </span><span class="s1">hasattr(A</span><span class="s2">, </span><span class="s3">'rmatmat'</span><span class="s1">):</span>
                <span class="s1">rmatmat = A.rmatmat</span>
            <span class="s2">if </span><span class="s1">hasattr(A</span><span class="s2">, </span><span class="s3">'dtype'</span><span class="s1">):</span>
                <span class="s1">dtype = A.dtype</span>
            <span class="s2">return </span><span class="s1">LinearOperator(A.shape</span><span class="s2">, </span><span class="s1">A.matvec</span><span class="s2">, </span><span class="s1">rmatvec=rmatvec</span><span class="s2">,</span>
                                  <span class="s1">rmatmat=rmatmat</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'type not understood'</span><span class="s1">)</span>
</pre>
</body>
</html>