<html>
<head>
<title>_spectral_py.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_spectral_py.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Tools for spectral analysis. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">fft </span><span class="s2">as </span><span class="s1">sp_fft</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_signaltools</span>
<span class="s2">from </span><span class="s1">.windows </span><span class="s2">import </span><span class="s1">get_window</span>
<span class="s2">from </span><span class="s1">._spectral </span><span class="s2">import </span><span class="s1">_lombscargle</span>
<span class="s2">from </span><span class="s1">._arraytools </span><span class="s2">import </span><span class="s1">const_ext</span><span class="s2">, </span><span class="s1">even_ext</span><span class="s2">, </span><span class="s1">odd_ext</span><span class="s2">, </span><span class="s1">zero_ext</span>
<span class="s2">import </span><span class="s1">warnings</span>


<span class="s1">__all__ = [</span><span class="s3">'periodogram'</span><span class="s2">, </span><span class="s3">'welch'</span><span class="s2">, </span><span class="s3">'lombscargle'</span><span class="s2">, </span><span class="s3">'csd'</span><span class="s2">, </span><span class="s3">'coherence'</span><span class="s2">,</span>
           <span class="s3">'spectrogram'</span><span class="s2">, </span><span class="s3">'stft'</span><span class="s2">, </span><span class="s3">'istft'</span><span class="s2">, </span><span class="s3">'check_COLA'</span><span class="s2">, </span><span class="s3">'check_NOLA'</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">lombscargle(x</span><span class="s2">,</span>
                <span class="s1">y</span><span class="s2">,</span>
                <span class="s1">freqs</span><span class="s2">,</span>
                <span class="s1">precenter=</span><span class="s2">False,</span>
                <span class="s1">normalize=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    lombscargle(x, y, freqs) 
 
    Computes the Lomb-Scargle periodogram. 
 
    The Lomb-Scargle periodogram was developed by Lomb [1]_ and further 
    extended by Scargle [2]_ to find, and test the significance of weak 
    periodic signals with uneven temporal sampling. 
 
    When *normalize* is False (default) the computed periodogram 
    is unnormalized, it takes the value ``(A**2) * N/4`` for a harmonic 
    signal with amplitude A for sufficiently large N. 
 
    When *normalize* is True the computed periodogram is normalized by 
    the residuals of the data around a constant reference model (at zero). 
 
    Input arrays should be 1-D and will be cast to float64. 
 
    Parameters 
    ---------- 
    x : array_like 
        Sample times. 
    y : array_like 
        Measurement values. 
    freqs : array_like 
        Angular frequencies for output periodogram. 
    precenter : bool, optional 
        Pre-center measurement values by subtracting the mean. 
    normalize : bool, optional 
        Compute normalized periodogram. 
 
    Returns 
    ------- 
    pgram : array_like 
        Lomb-Scargle periodogram. 
 
    Raises 
    ------ 
    ValueError 
        If the input arrays `x` and `y` do not have the same shape. 
 
    See Also 
    -------- 
    istft: Inverse Short Time Fourier Transform 
    check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met 
    welch: Power spectral density by Welch's method 
    spectrogram: Spectrogram by Welch's method 
    csd: Cross spectral density by Welch's method 
 
    Notes 
    ----- 
    This subroutine calculates the periodogram using a slightly 
    modified algorithm due to Townsend [3]_ which allows the 
    periodogram to be calculated using only a single pass through 
    the input arrays for each frequency. 
 
    The algorithm running time scales roughly as O(x * freqs) or O(N^2) 
    for a large number of samples and frequencies. 
 
    References 
    ---------- 
    .. [1] N.R. Lomb &quot;Least-squares frequency analysis of unequally spaced 
           data&quot;, Astrophysics and Space Science, vol 39, pp. 447-462, 1976 
 
    .. [2] J.D. Scargle &quot;Studies in astronomical time series analysis. II - 
           Statistical aspects of spectral analysis of unevenly spaced data&quot;, 
           The Astrophysical Journal, vol 263, pp. 835-853, 1982 
 
    .. [3] R.H.D. Townsend, &quot;Fast calculation of the Lomb-Scargle 
           periodogram using graphics processing units.&quot;, The Astrophysical 
           Journal Supplement Series, vol 191, pp. 247-253, 2010 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    First define some input parameters for the signal: 
 
    &gt;&gt;&gt; A = 2. 
    &gt;&gt;&gt; w0 = 1.  # rad/sec 
    &gt;&gt;&gt; nin = 150 
    &gt;&gt;&gt; nout = 100000 
 
    Randomly generate sample times: 
 
    &gt;&gt;&gt; x = rng.uniform(0, 10*np.pi, nin) 
 
    Plot a sine wave for the selected times: 
 
    &gt;&gt;&gt; y = A * np.cos(w0*x) 
 
    Define the array of frequencies for which to compute the periodogram: 
 
    &gt;&gt;&gt; w = np.linspace(0.01, 10, nout) 
 
    Calculate Lomb-Scargle periodogram: 
 
    &gt;&gt;&gt; import scipy.signal as signal 
    &gt;&gt;&gt; pgram = signal.lombscargle(x, y, w, normalize=True) 
 
    Now make a plot of the input data: 
 
    &gt;&gt;&gt; fig, (ax_t, ax_w) = plt.subplots(2, 1, constrained_layout=True) 
    &gt;&gt;&gt; ax_t.plot(x, y, 'b+') 
    &gt;&gt;&gt; ax_t.set_xlabel('Time [s]') 
 
    Then plot the normalized periodogram: 
 
    &gt;&gt;&gt; ax_w.plot(w, pgram) 
    &gt;&gt;&gt; ax_w.set_xlabel('Angular frequency [rad/s]') 
    &gt;&gt;&gt; ax_w.set_ylabel('Normalized amplitude') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.ascontiguousarray(x</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">y = np.ascontiguousarray(y</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">freqs = np.ascontiguousarray(freqs</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>

    <span class="s2">assert </span><span class="s1">x.ndim == </span><span class="s4">1</span>
    <span class="s2">assert </span><span class="s1">y.ndim == </span><span class="s4">1</span>
    <span class="s2">assert </span><span class="s1">freqs.ndim == </span><span class="s4">1</span>

    <span class="s2">if </span><span class="s1">precenter:</span>
        <span class="s1">pgram = _lombscargle(x</span><span class="s2">, </span><span class="s1">y - y.mean()</span><span class="s2">, </span><span class="s1">freqs)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">pgram = _lombscargle(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">freqs)</span>

    <span class="s2">if </span><span class="s1">normalize:</span>
        <span class="s1">pgram *= </span><span class="s4">2 </span><span class="s1">/ np.dot(y</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s2">return </span><span class="s1">pgram</span>


<span class="s2">def </span><span class="s1">periodogram(x</span><span class="s2">, </span><span class="s1">fs=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">window=</span><span class="s3">'boxcar'</span><span class="s2">, </span><span class="s1">nfft=</span><span class="s2">None, </span><span class="s1">detrend=</span><span class="s3">'constant'</span><span class="s2">,</span>
                <span class="s1">return_onesided=</span><span class="s2">True, </span><span class="s1">scaling=</span><span class="s3">'density'</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Estimate power spectral density using a periodogram. 
 
    Parameters 
    ---------- 
    x : array_like 
        Time series of measurement values 
    fs : float, optional 
        Sampling frequency of the `x` time series. Defaults to 1.0. 
    window : str or tuple or array_like, optional 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be equal to the length 
        of the axis over which the periodogram is computed. Defaults 
        to 'boxcar'. 
    nfft : int, optional 
        Length of the FFT used. If `None` the length of `x` will be 
        used. 
    detrend : str or function or `False`, optional 
        Specifies how to detrend each segment. If `detrend` is a 
        string, it is passed as the `type` argument to the `detrend` 
        function. If it is a function, it takes a segment and returns a 
        detrended segment. If `detrend` is `False`, no detrending is 
        done. Defaults to 'constant'. 
    return_onesided : bool, optional 
        If `True`, return a one-sided spectrum for real data. If 
        `False` return a two-sided spectrum. Defaults to `True`, but for 
        complex data, a two-sided spectrum is always returned. 
    scaling : { 'density', 'spectrum' }, optional 
        Selects between computing the power spectral density ('density') 
        where `Pxx` has units of V**2/Hz and computing the power 
        spectrum ('spectrum') where `Pxx` has units of V**2, if `x` 
        is measured in V and `fs` is measured in Hz. Defaults to 
        'density' 
    axis : int, optional 
        Axis along which the periodogram is computed; the default is 
        over the last axis (i.e. ``axis=-1``). 
 
    Returns 
    ------- 
    f : ndarray 
        Array of sample frequencies. 
    Pxx : ndarray 
        Power spectral density or power spectrum of `x`. 
 
    See Also 
    -------- 
    welch: Estimate power spectral density using Welch's method 
    lombscargle: Lomb-Scargle periodogram for unevenly sampled data 
 
    Notes 
    ----- 
    .. versionadded:: 0.12.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by 
    0.001 V**2/Hz of white noise sampled at 10 kHz. 
 
    &gt;&gt;&gt; fs = 10e3 
    &gt;&gt;&gt; N = 1e5 
    &gt;&gt;&gt; amp = 2*np.sqrt(2) 
    &gt;&gt;&gt; freq = 1234.0 
    &gt;&gt;&gt; noise_power = 0.001 * fs / 2 
    &gt;&gt;&gt; time = np.arange(N) / fs 
    &gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time) 
    &gt;&gt;&gt; x += rng.normal(scale=np.sqrt(noise_power), size=time.shape) 
 
    Compute and plot the power spectral density. 
 
    &gt;&gt;&gt; f, Pxx_den = signal.periodogram(x, fs) 
    &gt;&gt;&gt; plt.semilogy(f, Pxx_den) 
    &gt;&gt;&gt; plt.ylim([1e-7, 1e2]) 
    &gt;&gt;&gt; plt.xlabel('frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]') 
    &gt;&gt;&gt; plt.show() 
 
    If we average the last half of the spectral density, to exclude the 
    peak, we can recover the noise power on the signal. 
 
    &gt;&gt;&gt; np.mean(Pxx_den[25000:]) 
    0.000985320699252543 
 
    Now compute and plot the power spectrum. 
 
    &gt;&gt;&gt; f, Pxx_spec = signal.periodogram(x, fs, 'flattop', scaling='spectrum') 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec)) 
    &gt;&gt;&gt; plt.ylim([1e-4, 1e1]) 
    &gt;&gt;&gt; plt.xlabel('frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('Linear spectrum [V RMS]') 
    &gt;&gt;&gt; plt.show() 
 
    The peak height in the power spectrum is an estimate of the RMS 
    amplitude. 
 
    &gt;&gt;&gt; np.sqrt(Pxx_spec.max()) 
    2.0077340678640727 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.asarray(x)</span>

    <span class="s2">if </span><span class="s1">x.size == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.empty(x.shape)</span><span class="s2">, </span><span class="s1">np.empty(x.shape)</span>

    <span class="s2">if </span><span class="s1">window </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">window = </span><span class="s3">'boxcar'</span>

    <span class="s2">if </span><span class="s1">nfft </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">nperseg = x.shape[axis]</span>
    <span class="s2">elif </span><span class="s1">nfft == x.shape[axis]:</span>
        <span class="s1">nperseg = nfft</span>
    <span class="s2">elif </span><span class="s1">nfft &gt; x.shape[axis]:</span>
        <span class="s1">nperseg = x.shape[axis]</span>
    <span class="s2">elif </span><span class="s1">nfft &lt; x.shape[axis]:</span>
        <span class="s1">s = [np.s_[:]]*len(x.shape)</span>
        <span class="s1">s[axis] = np.s_[:nfft]</span>
        <span class="s1">x = x[tuple(s)]</span>
        <span class="s1">nperseg = nfft</span>
        <span class="s1">nfft = </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">hasattr(window</span><span class="s2">, </span><span class="s3">'size'</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">window.size != nperseg:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'the size of the window must be the same size '</span>
                             <span class="s3">'of the input on the specified axis'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">welch(x</span><span class="s2">, </span><span class="s1">fs=fs</span><span class="s2">, </span><span class="s1">window=window</span><span class="s2">, </span><span class="s1">nperseg=nperseg</span><span class="s2">, </span><span class="s1">noverlap=</span><span class="s4">0</span><span class="s2">,</span>
                 <span class="s1">nfft=nfft</span><span class="s2">, </span><span class="s1">detrend=detrend</span><span class="s2">, </span><span class="s1">return_onesided=return_onesided</span><span class="s2">,</span>
                 <span class="s1">scaling=scaling</span><span class="s2">, </span><span class="s1">axis=axis)</span>


<span class="s2">def </span><span class="s1">welch(x</span><span class="s2">, </span><span class="s1">fs=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">window=</span><span class="s3">'hann'</span><span class="s2">, </span><span class="s1">nperseg=</span><span class="s2">None, </span><span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">nfft=</span><span class="s2">None,</span>
          <span class="s1">detrend=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">return_onesided=</span><span class="s2">True, </span><span class="s1">scaling=</span><span class="s3">'density'</span><span class="s2">,</span>
          <span class="s1">axis=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">average=</span><span class="s3">'mean'</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Estimate power spectral density using Welch's method. 
 
    Welch's method [1]_ computes an estimate of the power spectral 
    density by dividing the data into overlapping segments, computing a 
    modified periodogram for each segment and averaging the 
    periodograms. 
 
    Parameters 
    ---------- 
    x : array_like 
        Time series of measurement values 
    fs : float, optional 
        Sampling frequency of the `x` time series. Defaults to 1.0. 
    window : str or tuple or array_like, optional 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. Defaults 
        to a Hann window. 
    nperseg : int, optional 
        Length of each segment. Defaults to None, but if window is str or 
        tuple, is set to 256, and if window is array_like, is set to the 
        length of the window. 
    noverlap : int, optional 
        Number of points to overlap between segments. If `None`, 
        ``noverlap = nperseg // 2``. Defaults to `None`. 
    nfft : int, optional 
        Length of the FFT used, if a zero padded FFT is desired. If 
        `None`, the FFT length is `nperseg`. Defaults to `None`. 
    detrend : str or function or `False`, optional 
        Specifies how to detrend each segment. If `detrend` is a 
        string, it is passed as the `type` argument to the `detrend` 
        function. If it is a function, it takes a segment and returns a 
        detrended segment. If `detrend` is `False`, no detrending is 
        done. Defaults to 'constant'. 
    return_onesided : bool, optional 
        If `True`, return a one-sided spectrum for real data. If 
        `False` return a two-sided spectrum. Defaults to `True`, but for 
        complex data, a two-sided spectrum is always returned. 
    scaling : { 'density', 'spectrum' }, optional 
        Selects between computing the power spectral density ('density') 
        where `Pxx` has units of V**2/Hz and computing the power 
        spectrum ('spectrum') where `Pxx` has units of V**2, if `x` 
        is measured in V and `fs` is measured in Hz. Defaults to 
        'density' 
    axis : int, optional 
        Axis along which the periodogram is computed; the default is 
        over the last axis (i.e. ``axis=-1``). 
    average : { 'mean', 'median' }, optional 
        Method to use when averaging periodograms. Defaults to 'mean'. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    f : ndarray 
        Array of sample frequencies. 
    Pxx : ndarray 
        Power spectral density or power spectrum of x. 
 
    See Also 
    -------- 
    periodogram: Simple, optionally modified periodogram 
    lombscargle: Lomb-Scargle periodogram for unevenly sampled data 
 
    Notes 
    ----- 
    An appropriate amount of overlap will depend on the choice of window 
    and on your requirements. For the default Hann window an overlap of 
    50% is a reasonable trade off between accurately estimating the 
    signal power, while not over counting any of the data. Narrower 
    windows may require a larger overlap. 
 
    If `noverlap` is 0, this method is equivalent to Bartlett's method 
    [2]_. 
 
    .. versionadded:: 0.12.0 
 
    References 
    ---------- 
    .. [1] P. Welch, &quot;The use of the fast Fourier transform for the 
           estimation of power spectra: A method based on time averaging 
           over short, modified periodograms&quot;, IEEE Trans. Audio 
           Electroacoust. vol. 15, pp. 70-73, 1967. 
    .. [2] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;, 
           Biometrika, vol. 37, pp. 1-16, 1950. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by 
    0.001 V**2/Hz of white noise sampled at 10 kHz. 
 
    &gt;&gt;&gt; fs = 10e3 
    &gt;&gt;&gt; N = 1e5 
    &gt;&gt;&gt; amp = 2*np.sqrt(2) 
    &gt;&gt;&gt; freq = 1234.0 
    &gt;&gt;&gt; noise_power = 0.001 * fs / 2 
    &gt;&gt;&gt; time = np.arange(N) / fs 
    &gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time) 
    &gt;&gt;&gt; x += rng.normal(scale=np.sqrt(noise_power), size=time.shape) 
 
    Compute and plot the power spectral density. 
 
    &gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024) 
    &gt;&gt;&gt; plt.semilogy(f, Pxx_den) 
    &gt;&gt;&gt; plt.ylim([0.5e-3, 1]) 
    &gt;&gt;&gt; plt.xlabel('frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]') 
    &gt;&gt;&gt; plt.show() 
 
    If we average the last half of the spectral density, to exclude the 
    peak, we can recover the noise power on the signal. 
 
    &gt;&gt;&gt; np.mean(Pxx_den[256:]) 
    0.0009924865443739191 
 
    Now compute and plot the power spectrum. 
 
    &gt;&gt;&gt; f, Pxx_spec = signal.welch(x, fs, 'flattop', 1024, scaling='spectrum') 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec)) 
    &gt;&gt;&gt; plt.xlabel('frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('Linear spectrum [V RMS]') 
    &gt;&gt;&gt; plt.show() 
 
    The peak height in the power spectrum is an estimate of the RMS 
    amplitude. 
 
    &gt;&gt;&gt; np.sqrt(Pxx_spec.max()) 
    2.0077340678640727 
 
    If we now introduce a discontinuity in the signal, by increasing the 
    amplitude of a small portion of the signal by 50, we can see the 
    corruption of the mean average power spectral density, but using a 
    median average better estimates the normal behaviour. 
 
    &gt;&gt;&gt; x[int(N//2):int(N//2)+10] *= 50. 
    &gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024) 
    &gt;&gt;&gt; f_med, Pxx_den_med = signal.welch(x, fs, nperseg=1024, average='median') 
    &gt;&gt;&gt; plt.semilogy(f, Pxx_den, label='mean') 
    &gt;&gt;&gt; plt.semilogy(f_med, Pxx_den_med, label='median') 
    &gt;&gt;&gt; plt.ylim([0.5e-3, 1]) 
    &gt;&gt;&gt; plt.xlabel('frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">freqs</span><span class="s2">, </span><span class="s1">Pxx = csd(x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fs=fs</span><span class="s2">, </span><span class="s1">window=window</span><span class="s2">, </span><span class="s1">nperseg=nperseg</span><span class="s2">,</span>
                     <span class="s1">noverlap=noverlap</span><span class="s2">, </span><span class="s1">nfft=nfft</span><span class="s2">, </span><span class="s1">detrend=detrend</span><span class="s2">,</span>
                     <span class="s1">return_onesided=return_onesided</span><span class="s2">, </span><span class="s1">scaling=scaling</span><span class="s2">,</span>
                     <span class="s1">axis=axis</span><span class="s2">, </span><span class="s1">average=average)</span>

    <span class="s2">return </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">Pxx.real</span>


<span class="s2">def </span><span class="s1">csd(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">fs=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">window=</span><span class="s3">'hann'</span><span class="s2">, </span><span class="s1">nperseg=</span><span class="s2">None, </span><span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">nfft=</span><span class="s2">None,</span>
        <span class="s1">detrend=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">return_onesided=</span><span class="s2">True, </span><span class="s1">scaling=</span><span class="s3">'density'</span><span class="s2">,</span>
        <span class="s1">axis=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">average=</span><span class="s3">'mean'</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Estimate the cross power spectral density, Pxy, using Welch's method. 
 
    Parameters 
    ---------- 
    x : array_like 
        Time series of measurement values 
    y : array_like 
        Time series of measurement values 
    fs : float, optional 
        Sampling frequency of the `x` and `y` time series. Defaults 
        to 1.0. 
    window : str or tuple or array_like, optional 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. Defaults 
        to a Hann window. 
    nperseg : int, optional 
        Length of each segment. Defaults to None, but if window is str or 
        tuple, is set to 256, and if window is array_like, is set to the 
        length of the window. 
    noverlap: int, optional 
        Number of points to overlap between segments. If `None`, 
        ``noverlap = nperseg // 2``. Defaults to `None`. 
    nfft : int, optional 
        Length of the FFT used, if a zero padded FFT is desired. If 
        `None`, the FFT length is `nperseg`. Defaults to `None`. 
    detrend : str or function or `False`, optional 
        Specifies how to detrend each segment. If `detrend` is a 
        string, it is passed as the `type` argument to the `detrend` 
        function. If it is a function, it takes a segment and returns a 
        detrended segment. If `detrend` is `False`, no detrending is 
        done. Defaults to 'constant'. 
    return_onesided : bool, optional 
        If `True`, return a one-sided spectrum for real data. If 
        `False` return a two-sided spectrum. Defaults to `True`, but for 
        complex data, a two-sided spectrum is always returned. 
    scaling : { 'density', 'spectrum' }, optional 
        Selects between computing the cross spectral density ('density') 
        where `Pxy` has units of V**2/Hz and computing the cross spectrum 
        ('spectrum') where `Pxy` has units of V**2, if `x` and `y` are 
        measured in V and `fs` is measured in Hz. Defaults to 'density' 
    axis : int, optional 
        Axis along which the CSD is computed for both inputs; the 
        default is over the last axis (i.e. ``axis=-1``). 
    average : { 'mean', 'median' }, optional 
        Method to use when averaging periodograms. If the spectrum is 
        complex, the average is computed separately for the real and 
        imaginary parts. Defaults to 'mean'. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    f : ndarray 
        Array of sample frequencies. 
    Pxy : ndarray 
        Cross spectral density or cross power spectrum of x,y. 
 
    See Also 
    -------- 
    periodogram: Simple, optionally modified periodogram 
    lombscargle: Lomb-Scargle periodogram for unevenly sampled data 
    welch: Power spectral density by Welch's method. [Equivalent to 
           csd(x,x)] 
    coherence: Magnitude squared coherence by Welch's method. 
 
    Notes 
    ----- 
    By convention, Pxy is computed with the conjugate FFT of X 
    multiplied by the FFT of Y. 
 
    If the input series differ in length, the shorter series will be 
    zero-padded to match. 
 
    An appropriate amount of overlap will depend on the choice of window 
    and on your requirements. For the default Hann window an overlap of 
    50% is a reasonable trade off between accurately estimating the 
    signal power, while not over counting any of the data. Narrower 
    windows may require a larger overlap. 
 
    .. versionadded:: 0.16.0 
 
    References 
    ---------- 
    .. [1] P. Welch, &quot;The use of the fast Fourier transform for the 
           estimation of power spectra: A method based on time averaging 
           over short, modified periodograms&quot;, IEEE Trans. Audio 
           Electroacoust. vol. 15, pp. 70-73, 1967. 
    .. [2] Rabiner, Lawrence R., and B. Gold. &quot;Theory and Application of 
           Digital Signal Processing&quot; Prentice-Hall, pp. 414-419, 1975 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Generate two test signals with some common features. 
 
    &gt;&gt;&gt; fs = 10e3 
    &gt;&gt;&gt; N = 1e5 
    &gt;&gt;&gt; amp = 20 
    &gt;&gt;&gt; freq = 1234.0 
    &gt;&gt;&gt; noise_power = 0.001 * fs / 2 
    &gt;&gt;&gt; time = np.arange(N) / fs 
    &gt;&gt;&gt; b, a = signal.butter(2, 0.25, 'low') 
    &gt;&gt;&gt; x = rng.normal(scale=np.sqrt(noise_power), size=time.shape) 
    &gt;&gt;&gt; y = signal.lfilter(b, a, x) 
    &gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time) 
    &gt;&gt;&gt; y += rng.normal(scale=0.1*np.sqrt(noise_power), size=time.shape) 
 
    Compute and plot the magnitude of the cross spectral density. 
 
    &gt;&gt;&gt; f, Pxy = signal.csd(x, y, fs, nperseg=1024) 
    &gt;&gt;&gt; plt.semilogy(f, np.abs(Pxy)) 
    &gt;&gt;&gt; plt.xlabel('frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('CSD [V**2/Hz]') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">freqs</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">Pxy = _spectral_helper(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">fs</span><span class="s2">, </span><span class="s1">window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">nfft</span><span class="s2">,</span>
                                     <span class="s1">detrend</span><span class="s2">, </span><span class="s1">return_onesided</span><span class="s2">, </span><span class="s1">scaling</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">,</span>
                                     <span class="s1">mode=</span><span class="s3">'psd'</span><span class="s1">)</span>

    <span class="s5"># Average over windows.</span>
    <span class="s2">if </span><span class="s1">len(Pxy.shape) &gt;= </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">Pxy.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">Pxy.shape[-</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">average == </span><span class="s3">'median'</span><span class="s1">:</span>
                <span class="s5"># np.median must be passed real arrays for the desired result</span>
                <span class="s1">bias = _median_bias(Pxy.shape[-</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s2">if </span><span class="s1">np.iscomplexobj(Pxy):</span>
                    <span class="s1">Pxy = (np.median(np.real(Pxy)</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>
                           <span class="s1">+ </span><span class="s4">1j </span><span class="s1">* np.median(np.imag(Pxy)</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">Pxy = np.median(Pxy</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">Pxy /= bias</span>
            <span class="s2">elif </span><span class="s1">average == </span><span class="s3">'mean'</span><span class="s1">:</span>
                <span class="s1">Pxy = Pxy.mean(axis=-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'average must be &quot;median&quot; or &quot;mean&quot;, got %s'</span>
                                 <span class="s1">% (average</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">Pxy = np.reshape(Pxy</span><span class="s2">, </span><span class="s1">Pxy.shape[:-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">return </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">Pxy</span>


<span class="s2">def </span><span class="s1">spectrogram(x</span><span class="s2">, </span><span class="s1">fs=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">window=(</span><span class="s3">'tukey'</span><span class="s2">, </span><span class="s4">.25</span><span class="s1">)</span><span class="s2">, </span><span class="s1">nperseg=</span><span class="s2">None, </span><span class="s1">noverlap=</span><span class="s2">None,</span>
                <span class="s1">nfft=</span><span class="s2">None, </span><span class="s1">detrend=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">return_onesided=</span><span class="s2">True,</span>
                <span class="s1">scaling=</span><span class="s3">'density'</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'psd'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Compute a spectrogram with consecutive Fourier transforms. 
 
    Spectrograms can be used as a way of visualizing the change of a 
    nonstationary signal's frequency content over time. 
 
    Parameters 
    ---------- 
    x : array_like 
        Time series of measurement values 
    fs : float, optional 
        Sampling frequency of the `x` time series. Defaults to 1.0. 
    window : str or tuple or array_like, optional 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. 
        Defaults to a Tukey window with shape parameter of 0.25. 
    nperseg : int, optional 
        Length of each segment. Defaults to None, but if window is str or 
        tuple, is set to 256, and if window is array_like, is set to the 
        length of the window. 
    noverlap : int, optional 
        Number of points to overlap between segments. If `None`, 
        ``noverlap = nperseg // 8``. Defaults to `None`. 
    nfft : int, optional 
        Length of the FFT used, if a zero padded FFT is desired. If 
        `None`, the FFT length is `nperseg`. Defaults to `None`. 
    detrend : str or function or `False`, optional 
        Specifies how to detrend each segment. If `detrend` is a 
        string, it is passed as the `type` argument to the `detrend` 
        function. If it is a function, it takes a segment and returns a 
        detrended segment. If `detrend` is `False`, no detrending is 
        done. Defaults to 'constant'. 
    return_onesided : bool, optional 
        If `True`, return a one-sided spectrum for real data. If 
        `False` return a two-sided spectrum. Defaults to `True`, but for 
        complex data, a two-sided spectrum is always returned. 
    scaling : { 'density', 'spectrum' }, optional 
        Selects between computing the power spectral density ('density') 
        where `Sxx` has units of V**2/Hz and computing the power 
        spectrum ('spectrum') where `Sxx` has units of V**2, if `x` 
        is measured in V and `fs` is measured in Hz. Defaults to 
        'density'. 
    axis : int, optional 
        Axis along which the spectrogram is computed; the default is over 
        the last axis (i.e. ``axis=-1``). 
    mode : str, optional 
        Defines what kind of return values are expected. Options are 
        ['psd', 'complex', 'magnitude', 'angle', 'phase']. 'complex' is 
        equivalent to the output of `stft` with no padding or boundary 
        extension. 'magnitude' returns the absolute magnitude of the 
        STFT. 'angle' and 'phase' return the complex angle of the STFT, 
        with and without unwrapping, respectively. 
 
    Returns 
    ------- 
    f : ndarray 
        Array of sample frequencies. 
    t : ndarray 
        Array of segment times. 
    Sxx : ndarray 
        Spectrogram of x. By default, the last axis of Sxx corresponds 
        to the segment times. 
 
    See Also 
    -------- 
    periodogram: Simple, optionally modified periodogram 
    lombscargle: Lomb-Scargle periodogram for unevenly sampled data 
    welch: Power spectral density by Welch's method. 
    csd: Cross spectral density by Welch's method. 
 
    Notes 
    ----- 
    An appropriate amount of overlap will depend on the choice of window 
    and on your requirements. In contrast to welch's method, where the 
    entire data stream is averaged over, one may wish to use a smaller 
    overlap (or perhaps none at all) when computing a spectrogram, to 
    maintain some statistical independence between individual segments. 
    It is for this reason that the default window is a Tukey window with 
    1/8th of a window's length overlap at each end. 
 
    .. versionadded:: 0.16.0 
 
    References 
    ---------- 
    .. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck 
           &quot;Discrete-Time Signal Processing&quot;, Prentice Hall, 1999. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Generate a test signal, a 2 Vrms sine wave whose frequency is slowly 
    modulated around 3kHz, corrupted by white noise of exponentially 
    decreasing magnitude sampled at 10 kHz. 
 
    &gt;&gt;&gt; fs = 10e3 
    &gt;&gt;&gt; N = 1e5 
    &gt;&gt;&gt; amp = 2 * np.sqrt(2) 
    &gt;&gt;&gt; noise_power = 0.01 * fs / 2 
    &gt;&gt;&gt; time = np.arange(N) / float(fs) 
    &gt;&gt;&gt; mod = 500*np.cos(2*np.pi*0.25*time) 
    &gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*3e3*time + mod) 
    &gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power), size=time.shape) 
    &gt;&gt;&gt; noise *= np.exp(-time/5) 
    &gt;&gt;&gt; x = carrier + noise 
 
    Compute and plot the spectrogram. 
 
    &gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs) 
    &gt;&gt;&gt; plt.pcolormesh(t, f, Sxx, shading='gouraud') 
    &gt;&gt;&gt; plt.ylabel('Frequency [Hz]') 
    &gt;&gt;&gt; plt.xlabel('Time [sec]') 
    &gt;&gt;&gt; plt.show() 
 
    Note, if using output that is not one sided, then use the following: 
 
    &gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs, return_onesided=False) 
    &gt;&gt;&gt; plt.pcolormesh(t, fftshift(f), fftshift(Sxx, axes=0), shading='gouraud') 
    &gt;&gt;&gt; plt.ylabel('Frequency [Hz]') 
    &gt;&gt;&gt; plt.xlabel('Time [sec]') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">modelist = [</span><span class="s3">'psd'</span><span class="s2">, </span><span class="s3">'complex'</span><span class="s2">, </span><span class="s3">'magnitude'</span><span class="s2">, </span><span class="s3">'angle'</span><span class="s2">, </span><span class="s3">'phase'</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s2">not in </span><span class="s1">modelist:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'unknown value for mode {}, must be one of {}'</span>
                         <span class="s1">.format(mode</span><span class="s2">, </span><span class="s1">modelist))</span>

    <span class="s5"># need to set default for nperseg before setting default for noverlap below</span>
    <span class="s1">window</span><span class="s2">, </span><span class="s1">nperseg = _triage_segments(window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">,</span>
                                       <span class="s1">input_length=x.shape[axis])</span>

    <span class="s5"># Less overlap than welch, so samples are more statisically independent</span>
    <span class="s2">if </span><span class="s1">noverlap </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">noverlap = nperseg // </span><span class="s4">8</span>

    <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s1">freqs</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">Sxx = _spectral_helper(x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fs</span><span class="s2">, </span><span class="s1">window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">,</span>
                                            <span class="s1">noverlap</span><span class="s2">, </span><span class="s1">nfft</span><span class="s2">, </span><span class="s1">detrend</span><span class="s2">,</span>
                                            <span class="s1">return_onesided</span><span class="s2">, </span><span class="s1">scaling</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">,</span>
                                            <span class="s1">mode=</span><span class="s3">'psd'</span><span class="s1">)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">freqs</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">Sxx = _spectral_helper(x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fs</span><span class="s2">, </span><span class="s1">window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">,</span>
                                            <span class="s1">noverlap</span><span class="s2">, </span><span class="s1">nfft</span><span class="s2">, </span><span class="s1">detrend</span><span class="s2">,</span>
                                            <span class="s1">return_onesided</span><span class="s2">, </span><span class="s1">scaling</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">,</span>
                                            <span class="s1">mode=</span><span class="s3">'stft'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'magnitude'</span><span class="s1">:</span>
            <span class="s1">Sxx = np.abs(Sxx)</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'angle'</span><span class="s2">, </span><span class="s3">'phase'</span><span class="s1">]:</span>
            <span class="s1">Sxx = np.angle(Sxx)</span>
            <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'phase'</span><span class="s1">:</span>
                <span class="s5"># Sxx has one additional dimension for time strides</span>
                <span class="s2">if </span><span class="s1">axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">axis -= </span><span class="s4">1</span>
                <span class="s1">Sxx = np.unwrap(Sxx</span><span class="s2">, </span><span class="s1">axis=axis)</span>

        <span class="s5"># mode =='complex' is same as `stft`, doesn't need modification</span>

    <span class="s2">return </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">Sxx</span>


<span class="s2">def </span><span class="s1">check_COLA(window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">tol=</span><span class="s4">1e-10</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Check whether the Constant OverLap Add (COLA) constraint is met. 
 
    Parameters 
    ---------- 
    window : str or tuple or array_like 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. 
    nperseg : int 
        Length of each segment. 
    noverlap : int 
        Number of points to overlap between segments. 
    tol : float, optional 
        The allowed variance of a bin's weighted sum from the median bin 
        sum. 
 
    Returns 
    ------- 
    verdict : bool 
        `True` if chosen combination satisfies COLA within `tol`, 
        `False` otherwise 
 
    See Also 
    -------- 
    check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met 
    stft: Short Time Fourier Transform 
    istft: Inverse Short Time Fourier Transform 
 
    Notes 
    ----- 
    In order to enable inversion of an STFT via the inverse STFT in 
    `istft`, it is sufficient that the signal windowing obeys the constraint of 
    &quot;Constant OverLap Add&quot; (COLA). This ensures that every point in the input 
    data is equally weighted, thereby avoiding aliasing and allowing full 
    reconstruction. 
 
    Some examples of windows that satisfy COLA: 
        - Rectangular window at overlap of 0, 1/2, 2/3, 3/4, ... 
        - Bartlett window at overlap of 1/2, 3/4, 5/6, ... 
        - Hann window at 1/2, 2/3, 3/4, ... 
        - Any Blackman family window at 2/3 overlap 
        - Any window with ``noverlap = nperseg-1`` 
 
    A very comprehensive list of other windows may be found in [2]_, 
    wherein the COLA condition is satisfied when the &quot;Amplitude 
    Flatness&quot; is unity. 
 
    .. versionadded:: 0.19.0 
 
    References 
    ---------- 
    .. [1] Julius O. Smith III, &quot;Spectral Audio Signal Processing&quot;, W3K 
           Publishing, 2011,ISBN 978-0-9745607-3-1. 
    .. [2] G. Heinzel, A. Ruediger and R. Schilling, &quot;Spectrum and 
           spectral density estimation by the Discrete Fourier transform 
           (DFT), including a comprehensive list of window functions and 
           some new at-top windows&quot;, 2002, 
           http://hdl.handle.net/11858/00-001M-0000-0013-557A-5 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
 
    Confirm COLA condition for rectangular window of 75% (3/4) overlap: 
 
    &gt;&gt;&gt; signal.check_COLA(signal.windows.boxcar(100), 100, 75) 
    True 
 
    COLA is not true for 25% (1/4) overlap, though: 
 
    &gt;&gt;&gt; signal.check_COLA(signal.windows.boxcar(100), 100, 25) 
    False 
 
    &quot;Symmetrical&quot; Hann window (for filter design) is not COLA: 
 
    &gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=True), 120, 60) 
    False 
 
    &quot;Periodic&quot; or &quot;DFT-even&quot; Hann window (for FFT analysis) is COLA for 
    overlap of 1/2, 2/3, 3/4, etc.: 
 
    &gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 60) 
    True 
 
    &gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 80) 
    True 
 
    &gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 90) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nperseg = int(nperseg)</span>

    <span class="s2">if </span><span class="s1">nperseg &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'nperseg must be a positive integer'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">noverlap &gt;= nperseg:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'noverlap must be less than nperseg.'</span><span class="s1">)</span>
    <span class="s1">noverlap = int(noverlap)</span>

    <span class="s2">if </span><span class="s1">isinstance(window</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">type(window) </span><span class="s2">is </span><span class="s1">tuple:</span>
        <span class="s1">win = get_window(window</span><span class="s2">, </span><span class="s1">nperseg)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">win = np.asarray(window)</span>
        <span class="s2">if </span><span class="s1">len(win.shape) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'window must be 1-D'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">win.shape[</span><span class="s4">0</span><span class="s1">] != nperseg:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'window must have length of nperseg'</span><span class="s1">)</span>

    <span class="s1">step = nperseg - noverlap</span>
    <span class="s1">binsums = sum(win[ii*step:(ii+</span><span class="s4">1</span><span class="s1">)*step] </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(nperseg//step))</span>

    <span class="s2">if </span><span class="s1">nperseg % step != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">binsums[:nperseg % step] += win[-(nperseg % step):]</span>

    <span class="s1">deviation = binsums - np.median(binsums)</span>
    <span class="s2">return </span><span class="s1">np.max(np.abs(deviation)) &lt; tol</span>


<span class="s2">def </span><span class="s1">check_NOLA(window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">tol=</span><span class="s4">1e-10</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Check whether the Nonzero Overlap Add (NOLA) constraint is met. 
 
    Parameters 
    ---------- 
    window : str or tuple or array_like 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. 
    nperseg : int 
        Length of each segment. 
    noverlap : int 
        Number of points to overlap between segments. 
    tol : float, optional 
        The allowed variance of a bin's weighted sum from the median bin 
        sum. 
 
    Returns 
    ------- 
    verdict : bool 
        `True` if chosen combination satisfies the NOLA constraint within 
        `tol`, `False` otherwise 
 
    See Also 
    -------- 
    check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met 
    stft: Short Time Fourier Transform 
    istft: Inverse Short Time Fourier Transform 
 
    Notes 
    ----- 
    In order to enable inversion of an STFT via the inverse STFT in 
    `istft`, the signal windowing must obey the constraint of &quot;nonzero 
    overlap add&quot; (NOLA): 
 
    .. math:: \sum_{t}w^{2}[n-tH] \ne 0 
 
    for all :math:`n`, where :math:`w` is the window function, :math:`t` is the 
    frame index, and :math:`H` is the hop size (:math:`H` = `nperseg` - 
    `noverlap`). 
 
    This ensures that the normalization factors in the denominator of the 
    overlap-add inversion equation are not zero. Only very pathological windows 
    will fail the NOLA constraint. 
 
    .. versionadded:: 1.2.0 
 
    References 
    ---------- 
    .. [1] Julius O. Smith III, &quot;Spectral Audio Signal Processing&quot;, W3K 
           Publishing, 2011,ISBN 978-0-9745607-3-1. 
    .. [2] G. Heinzel, A. Ruediger and R. Schilling, &quot;Spectrum and 
           spectral density estimation by the Discrete Fourier transform 
           (DFT), including a comprehensive list of window functions and 
           some new at-top windows&quot;, 2002, 
           http://hdl.handle.net/11858/00-001M-0000-0013-557A-5 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
 
    Confirm NOLA condition for rectangular window of 75% (3/4) overlap: 
 
    &gt;&gt;&gt; signal.check_NOLA(signal.windows.boxcar(100), 100, 75) 
    True 
 
    NOLA is also true for 25% (1/4) overlap: 
 
    &gt;&gt;&gt; signal.check_NOLA(signal.windows.boxcar(100), 100, 25) 
    True 
 
    &quot;Symmetrical&quot; Hann window (for filter design) is also NOLA: 
 
    &gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(120, sym=True), 120, 60) 
    True 
 
    As long as there is overlap, it takes quite a pathological window to fail 
    NOLA: 
 
    &gt;&gt;&gt; w = np.ones(64, dtype=&quot;float&quot;) 
    &gt;&gt;&gt; w[::2] = 0 
    &gt;&gt;&gt; signal.check_NOLA(w, 64, 32) 
    False 
 
    If there is not enough overlap, a window with zeros at the ends will not 
    work: 
 
    &gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 0) 
    False 
    &gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 1) 
    False 
    &gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 2) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nperseg = int(nperseg)</span>

    <span class="s2">if </span><span class="s1">nperseg &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'nperseg must be a positive integer'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">noverlap &gt;= nperseg:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'noverlap must be less than nperseg'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">noverlap &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'noverlap must be a nonnegative integer'</span><span class="s1">)</span>
    <span class="s1">noverlap = int(noverlap)</span>

    <span class="s2">if </span><span class="s1">isinstance(window</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">type(window) </span><span class="s2">is </span><span class="s1">tuple:</span>
        <span class="s1">win = get_window(window</span><span class="s2">, </span><span class="s1">nperseg)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">win = np.asarray(window)</span>
        <span class="s2">if </span><span class="s1">len(win.shape) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'window must be 1-D'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">win.shape[</span><span class="s4">0</span><span class="s1">] != nperseg:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'window must have length of nperseg'</span><span class="s1">)</span>

    <span class="s1">step = nperseg - noverlap</span>
    <span class="s1">binsums = sum(win[ii*step:(ii+</span><span class="s4">1</span><span class="s1">)*step]**</span><span class="s4">2 </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(nperseg//step))</span>

    <span class="s2">if </span><span class="s1">nperseg % step != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">binsums[:nperseg % step] += win[-(nperseg % step):]**</span><span class="s4">2</span>

    <span class="s2">return </span><span class="s1">np.min(binsums) &gt; tol</span>


<span class="s2">def </span><span class="s1">stft(x</span><span class="s2">, </span><span class="s1">fs=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">window=</span><span class="s3">'hann'</span><span class="s2">, </span><span class="s1">nperseg=</span><span class="s4">256</span><span class="s2">, </span><span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">nfft=</span><span class="s2">None,</span>
         <span class="s1">detrend=</span><span class="s2">False, </span><span class="s1">return_onesided=</span><span class="s2">True, </span><span class="s1">boundary=</span><span class="s3">'zeros'</span><span class="s2">, </span><span class="s1">padded=</span><span class="s2">True,</span>
         <span class="s1">axis=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">scaling=</span><span class="s3">'spectrum'</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Compute the Short Time Fourier Transform (STFT). 
 
    STFTs can be used as a way of quantifying the change of a 
    nonstationary signal's frequency and phase content over time. 
 
    Parameters 
    ---------- 
    x : array_like 
        Time series of measurement values 
    fs : float, optional 
        Sampling frequency of the `x` time series. Defaults to 1.0. 
    window : str or tuple or array_like, optional 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. Defaults 
        to a Hann window. 
    nperseg : int, optional 
        Length of each segment. Defaults to 256. 
    noverlap : int, optional 
        Number of points to overlap between segments. If `None`, 
        ``noverlap = nperseg // 2``. Defaults to `None`. When 
        specified, the COLA constraint must be met (see Notes below). 
    nfft : int, optional 
        Length of the FFT used, if a zero padded FFT is desired. If 
        `None`, the FFT length is `nperseg`. Defaults to `None`. 
    detrend : str or function or `False`, optional 
        Specifies how to detrend each segment. If `detrend` is a 
        string, it is passed as the `type` argument to the `detrend` 
        function. If it is a function, it takes a segment and returns a 
        detrended segment. If `detrend` is `False`, no detrending is 
        done. Defaults to `False`. 
    return_onesided : bool, optional 
        If `True`, return a one-sided spectrum for real data. If 
        `False` return a two-sided spectrum. Defaults to `True`, but for 
        complex data, a two-sided spectrum is always returned. 
    boundary : str or None, optional 
        Specifies whether the input signal is extended at both ends, and 
        how to generate the new values, in order to center the first 
        windowed segment on the first input point. This has the benefit 
        of enabling reconstruction of the first input point when the 
        employed window function starts at zero. Valid options are 
        ``['even', 'odd', 'constant', 'zeros', None]``. Defaults to 
        'zeros', for zero padding extension. I.e. ``[1, 2, 3, 4]`` is 
        extended to ``[0, 1, 2, 3, 4, 0]`` for ``nperseg=3``. 
    padded : bool, optional 
        Specifies whether the input signal is zero-padded at the end to 
        make the signal fit exactly into an integer number of window 
        segments, so that all of the signal is included in the output. 
        Defaults to `True`. Padding occurs after boundary extension, if 
        `boundary` is not `None`, and `padded` is `True`, as is the 
        default. 
    axis : int, optional 
        Axis along which the STFT is computed; the default is over the 
        last axis (i.e. ``axis=-1``). 
    scaling: {'spectrum', 'psd'} 
        The default 'spectrum' scaling allows each frequency line of `Zxx` to 
        be interpreted as a magnitude spectrum. The 'psd' option scales each 
        line to a power spectral density - it allows to calculate the signal's 
        energy by numerically integrating over ``abs(Zxx)**2``. 
 
        .. versionadded:: 1.9.0 
 
    Returns 
    ------- 
    f : ndarray 
        Array of sample frequencies. 
    t : ndarray 
        Array of segment times. 
    Zxx : ndarray 
        STFT of `x`. By default, the last axis of `Zxx` corresponds 
        to the segment times. 
 
    See Also 
    -------- 
    istft: Inverse Short Time Fourier Transform 
    check_COLA: Check whether the Constant OverLap Add (COLA) constraint 
                is met 
    check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met 
    welch: Power spectral density by Welch's method. 
    spectrogram: Spectrogram by Welch's method. 
    csd: Cross spectral density by Welch's method. 
    lombscargle: Lomb-Scargle periodogram for unevenly sampled data 
 
    Notes 
    ----- 
    In order to enable inversion of an STFT via the inverse STFT in 
    `istft`, the signal windowing must obey the constraint of &quot;Nonzero 
    OverLap Add&quot; (NOLA), and the input signal must have complete 
    windowing coverage (i.e. ``(x.shape[axis] - nperseg) % 
    (nperseg-noverlap) == 0``). The `padded` argument may be used to 
    accomplish this. 
 
    Given a time-domain signal :math:`x[n]`, a window :math:`w[n]`, and a hop 
    size :math:`H` = `nperseg - noverlap`, the windowed frame at time index 
    :math:`t` is given by 
 
    .. math:: x_{t}[n]=x[n]w[n-tH] 
 
    The overlap-add (OLA) reconstruction equation is given by 
 
    .. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]} 
 
    The NOLA constraint ensures that every normalization term that appears 
    in the denomimator of the OLA reconstruction equation is nonzero. Whether a 
    choice of `window`, `nperseg`, and `noverlap` satisfy this constraint can 
    be tested with `check_NOLA`. 
 
    .. versionadded:: 0.19.0 
 
    References 
    ---------- 
    .. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck 
           &quot;Discrete-Time Signal Processing&quot;, Prentice Hall, 1999. 
    .. [2] Daniel W. Griffin, Jae S. Lim &quot;Signal Estimation from 
           Modified Short-Time Fourier Transform&quot;, IEEE 1984, 
           10.1109/TASSP.1984.1164317 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Generate a test signal, a 2 Vrms sine wave whose frequency is slowly 
    modulated around 3kHz, corrupted by white noise of exponentially 
    decreasing magnitude sampled at 10 kHz. 
 
    &gt;&gt;&gt; fs = 10e3 
    &gt;&gt;&gt; N = 1e5 
    &gt;&gt;&gt; amp = 2 * np.sqrt(2) 
    &gt;&gt;&gt; noise_power = 0.01 * fs / 2 
    &gt;&gt;&gt; time = np.arange(N) / float(fs) 
    &gt;&gt;&gt; mod = 500*np.cos(2*np.pi*0.25*time) 
    &gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*3e3*time + mod) 
    &gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power), 
    ...                    size=time.shape) 
    &gt;&gt;&gt; noise *= np.exp(-time/5) 
    &gt;&gt;&gt; x = carrier + noise 
 
    Compute and plot the STFT's magnitude. 
 
    &gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs, nperseg=1000) 
    &gt;&gt;&gt; plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading='gouraud') 
    &gt;&gt;&gt; plt.title('STFT Magnitude') 
    &gt;&gt;&gt; plt.ylabel('Frequency [Hz]') 
    &gt;&gt;&gt; plt.xlabel('Time [sec]') 
    &gt;&gt;&gt; plt.show() 
 
    Compare the energy of the signal `x` with the energy of its STFT: 
 
    &gt;&gt;&gt; E_x = sum(x**2) / fs  # Energy of x 
    &gt;&gt;&gt; # Calculate a two-sided STFT with PSD scaling: 
    &gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs, nperseg=1000, return_onesided=False, 
    ...                         scaling='psd') 
    &gt;&gt;&gt; # Integrate numerically over abs(Zxx)**2: 
    &gt;&gt;&gt; df, dt = f[1] - f[0], t[1] - t[0] 
    &gt;&gt;&gt; E_Zxx = sum(np.sum(Zxx.real**2 + Zxx.imag**2, axis=0) * df) * dt 
    &gt;&gt;&gt; # The energy is the same, but the numerical errors are quite large: 
    &gt;&gt;&gt; np.isclose(E_x, E_Zxx, rtol=1e-2) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">scaling == </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s1">scaling = </span><span class="s3">'density'</span>
    <span class="s2">elif </span><span class="s1">scaling != </span><span class="s3">'spectrum'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Parameter </span><span class="s2">{</span><span class="s1">scaling=</span><span class="s2">} </span><span class="s3">not in ['spectrum', 'psd']!&quot;</span><span class="s1">)</span>

    <span class="s1">freqs</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">Zxx = _spectral_helper(x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fs</span><span class="s2">, </span><span class="s1">window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">,</span>
                                        <span class="s1">nfft</span><span class="s2">, </span><span class="s1">detrend</span><span class="s2">, </span><span class="s1">return_onesided</span><span class="s2">,</span>
                                        <span class="s1">scaling=scaling</span><span class="s2">, </span><span class="s1">axis=axis</span><span class="s2">,</span>
                                        <span class="s1">mode=</span><span class="s3">'stft'</span><span class="s2">, </span><span class="s1">boundary=boundary</span><span class="s2">,</span>
                                        <span class="s1">padded=padded)</span>

    <span class="s2">return </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">Zxx</span>


<span class="s2">def </span><span class="s1">istft(Zxx</span><span class="s2">, </span><span class="s1">fs=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">window=</span><span class="s3">'hann'</span><span class="s2">, </span><span class="s1">nperseg=</span><span class="s2">None, </span><span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">nfft=</span><span class="s2">None,</span>
          <span class="s1">input_onesided=</span><span class="s2">True, </span><span class="s1">boundary=</span><span class="s2">True, </span><span class="s1">time_axis=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">freq_axis=-</span><span class="s4">2</span><span class="s2">,</span>
          <span class="s1">scaling=</span><span class="s3">'spectrum'</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Perform the inverse Short Time Fourier transform (iSTFT). 
 
    Parameters 
    ---------- 
    Zxx : array_like 
        STFT of the signal to be reconstructed. If a purely real array 
        is passed, it will be cast to a complex data type. 
    fs : float, optional 
        Sampling frequency of the time series. Defaults to 1.0. 
    window : str or tuple or array_like, optional 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. Defaults 
        to a Hann window. Must match the window used to generate the 
        STFT for faithful inversion. 
    nperseg : int, optional 
        Number of data points corresponding to each STFT segment. This 
        parameter must be specified if the number of data points per 
        segment is odd, or if the STFT was padded via ``nfft &gt; 
        nperseg``. If `None`, the value depends on the shape of 
        `Zxx` and `input_onesided`. If `input_onesided` is `True`, 
        ``nperseg=2*(Zxx.shape[freq_axis] - 1)``. Otherwise, 
        ``nperseg=Zxx.shape[freq_axis]``. Defaults to `None`. 
    noverlap : int, optional 
        Number of points to overlap between segments. If `None`, half 
        of the segment length. Defaults to `None`. When specified, the 
        COLA constraint must be met (see Notes below), and should match 
        the parameter used to generate the STFT. Defaults to `None`. 
    nfft : int, optional 
        Number of FFT points corresponding to each STFT segment. This 
        parameter must be specified if the STFT was padded via ``nfft &gt; 
        nperseg``. If `None`, the default values are the same as for 
        `nperseg`, detailed above, with one exception: if 
        `input_onesided` is True and 
        ``nperseg==2*Zxx.shape[freq_axis] - 1``, `nfft` also takes on 
        that value. This case allows the proper inversion of an 
        odd-length unpadded STFT using ``nfft=None``. Defaults to 
        `None`. 
    input_onesided : bool, optional 
        If `True`, interpret the input array as one-sided FFTs, such 
        as is returned by `stft` with ``return_onesided=True`` and 
        `numpy.fft.rfft`. If `False`, interpret the input as a a 
        two-sided FFT. Defaults to `True`. 
    boundary : bool, optional 
        Specifies whether the input signal was extended at its 
        boundaries by supplying a non-`None` ``boundary`` argument to 
        `stft`. Defaults to `True`. 
    time_axis : int, optional 
        Where the time segments of the STFT is located; the default is 
        the last axis (i.e. ``axis=-1``). 
    freq_axis : int, optional 
        Where the frequency axis of the STFT is located; the default is 
        the penultimate axis (i.e. ``axis=-2``). 
    scaling: {'spectrum', 'psd'} 
        The default 'spectrum' scaling allows each frequency line of `Zxx` to 
        be interpreted as a magnitude spectrum. The 'psd' option scales each 
        line to a power spectral density - it allows to calculate the signal's 
        energy by numerically integrating over ``abs(Zxx)**2``. 
 
    Returns 
    ------- 
    t : ndarray 
        Array of output data times. 
    x : ndarray 
        iSTFT of `Zxx`. 
 
    See Also 
    -------- 
    stft: Short Time Fourier Transform 
    check_COLA: Check whether the Constant OverLap Add (COLA) constraint 
                is met 
    check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met 
 
    Notes 
    ----- 
    In order to enable inversion of an STFT via the inverse STFT with 
    `istft`, the signal windowing must obey the constraint of &quot;nonzero 
    overlap add&quot; (NOLA): 
 
    .. math:: \sum_{t}w^{2}[n-tH] \ne 0 
 
    This ensures that the normalization factors that appear in the denominator 
    of the overlap-add reconstruction equation 
 
    .. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]} 
 
    are not zero. The NOLA constraint can be checked with the `check_NOLA` 
    function. 
 
    An STFT which has been modified (via masking or otherwise) is not 
    guaranteed to correspond to a exactly realizible signal. This 
    function implements the iSTFT via the least-squares estimation 
    algorithm detailed in [2]_, which produces a signal that minimizes 
    the mean squared error between the STFT of the returned signal and 
    the modified STFT. 
 
    .. versionadded:: 0.19.0 
 
    References 
    ---------- 
    .. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck 
           &quot;Discrete-Time Signal Processing&quot;, Prentice Hall, 1999. 
    .. [2] Daniel W. Griffin, Jae S. Lim &quot;Signal Estimation from 
           Modified Short-Time Fourier Transform&quot;, IEEE 1984, 
           10.1109/TASSP.1984.1164317 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Generate a test signal, a 2 Vrms sine wave at 50Hz corrupted by 
    0.001 V**2/Hz of white noise sampled at 1024 Hz. 
 
    &gt;&gt;&gt; fs = 1024 
    &gt;&gt;&gt; N = 10*fs 
    &gt;&gt;&gt; nperseg = 512 
    &gt;&gt;&gt; amp = 2 * np.sqrt(2) 
    &gt;&gt;&gt; noise_power = 0.001 * fs / 2 
    &gt;&gt;&gt; time = np.arange(N) / float(fs) 
    &gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*50*time) 
    &gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power), 
    ...                    size=time.shape) 
    &gt;&gt;&gt; x = carrier + noise 
 
    Compute the STFT, and plot its magnitude 
 
    &gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs=fs, nperseg=nperseg) 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading='gouraud') 
    &gt;&gt;&gt; plt.ylim([f[1], f[-1]]) 
    &gt;&gt;&gt; plt.title('STFT Magnitude') 
    &gt;&gt;&gt; plt.ylabel('Frequency [Hz]') 
    &gt;&gt;&gt; plt.xlabel('Time [sec]') 
    &gt;&gt;&gt; plt.yscale('log') 
    &gt;&gt;&gt; plt.show() 
 
    Zero the components that are 10% or less of the carrier magnitude, 
    then convert back to a time series via inverse STFT 
 
    &gt;&gt;&gt; Zxx = np.where(np.abs(Zxx) &gt;= amp/10, Zxx, 0) 
    &gt;&gt;&gt; _, xrec = signal.istft(Zxx, fs) 
 
    Compare the cleaned signal with the original and true carrier signals. 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.plot(time, x, time, xrec, time, carrier) 
    &gt;&gt;&gt; plt.xlim([2, 2.1]) 
    &gt;&gt;&gt; plt.xlabel('Time [sec]') 
    &gt;&gt;&gt; plt.ylabel('Signal') 
    &gt;&gt;&gt; plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier']) 
    &gt;&gt;&gt; plt.show() 
 
    Note that the cleaned signal does not start as abruptly as the original, 
    since some of the coefficients of the transient were also removed: 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.plot(time, x, time, xrec, time, carrier) 
    &gt;&gt;&gt; plt.xlim([0, 0.1]) 
    &gt;&gt;&gt; plt.xlabel('Time [sec]') 
    &gt;&gt;&gt; plt.ylabel('Signal') 
    &gt;&gt;&gt; plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier']) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Make sure input is an ndarray of appropriate complex dtype</span>
    <span class="s1">Zxx = np.asarray(Zxx) + </span><span class="s4">0j</span>
    <span class="s1">freq_axis = int(freq_axis)</span>
    <span class="s1">time_axis = int(time_axis)</span>

    <span class="s2">if </span><span class="s1">Zxx.ndim &lt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Input stft must be at least 2d!'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">freq_axis == time_axis:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Must specify differing time and frequency axes!'</span><span class="s1">)</span>

    <span class="s1">nseg = Zxx.shape[time_axis]</span>

    <span class="s2">if </span><span class="s1">input_onesided:</span>
        <span class="s5"># Assume even segment length</span>
        <span class="s1">n_default = </span><span class="s4">2</span><span class="s1">*(Zxx.shape[freq_axis] - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">n_default = Zxx.shape[freq_axis]</span>

    <span class="s5"># Check windowing parameters</span>
    <span class="s2">if </span><span class="s1">nperseg </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">nperseg = n_default</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">nperseg = int(nperseg)</span>
        <span class="s2">if </span><span class="s1">nperseg &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'nperseg must be a positive integer'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">nfft </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(input_onesided) </span><span class="s2">and </span><span class="s1">(nperseg == n_default + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s5"># Odd nperseg, no FFT padding</span>
            <span class="s1">nfft = nperseg</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nfft = n_default</span>
    <span class="s2">elif </span><span class="s1">nfft &lt; nperseg:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'nfft must be greater than or equal to nperseg.'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">nfft = int(nfft)</span>

    <span class="s2">if </span><span class="s1">noverlap </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">noverlap = nperseg//</span><span class="s4">2</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">noverlap = int(noverlap)</span>
    <span class="s2">if </span><span class="s1">noverlap &gt;= nperseg:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'noverlap must be less than nperseg.'</span><span class="s1">)</span>
    <span class="s1">nstep = nperseg - noverlap</span>

    <span class="s5"># Rearrange axes if necessary</span>
    <span class="s2">if </span><span class="s1">time_axis != Zxx.ndim-</span><span class="s4">1 </span><span class="s2">or </span><span class="s1">freq_axis != Zxx.ndim-</span><span class="s4">2</span><span class="s1">:</span>
        <span class="s5"># Turn negative indices to positive for the call to transpose</span>
        <span class="s2">if </span><span class="s1">freq_axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">freq_axis = Zxx.ndim + freq_axis</span>
        <span class="s2">if </span><span class="s1">time_axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">time_axis = Zxx.ndim + time_axis</span>
        <span class="s1">zouter = list(range(Zxx.ndim))</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">sorted([time_axis</span><span class="s2">, </span><span class="s1">freq_axis]</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">zouter.pop(ax)</span>
        <span class="s1">Zxx = np.transpose(Zxx</span><span class="s2">, </span><span class="s1">zouter+[freq_axis</span><span class="s2">, </span><span class="s1">time_axis])</span>

    <span class="s5"># Get window as array</span>
    <span class="s2">if </span><span class="s1">isinstance(window</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">type(window) </span><span class="s2">is </span><span class="s1">tuple:</span>
        <span class="s1">win = get_window(window</span><span class="s2">, </span><span class="s1">nperseg)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">win = np.asarray(window)</span>
        <span class="s2">if </span><span class="s1">len(win.shape) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'window must be 1-D'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">win.shape[</span><span class="s4">0</span><span class="s1">] != nperseg:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'window must have length of </span><span class="s2">{</span><span class="s1">nperseg</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s1">ifunc = sp_fft.irfft </span><span class="s2">if </span><span class="s1">input_onesided </span><span class="s2">else </span><span class="s1">sp_fft.ifft</span>
    <span class="s1">xsubs = ifunc(Zxx</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">n=nfft)[...</span><span class="s2">, </span><span class="s1">:nperseg</span><span class="s2">, </span><span class="s1">:]</span>

    <span class="s5"># Initialize output and normalization arrays</span>
    <span class="s1">outputlength = nperseg + (nseg-</span><span class="s4">1</span><span class="s1">)*nstep</span>
    <span class="s1">x = np.zeros(list(Zxx.shape[:-</span><span class="s4">2</span><span class="s1">])+[outputlength]</span><span class="s2">, </span><span class="s1">dtype=xsubs.dtype)</span>
    <span class="s1">norm = np.zeros(outputlength</span><span class="s2">, </span><span class="s1">dtype=xsubs.dtype)</span>

    <span class="s2">if </span><span class="s1">np.result_type(win</span><span class="s2">, </span><span class="s1">xsubs) != xsubs.dtype:</span>
        <span class="s1">win = win.astype(xsubs.dtype)</span>

    <span class="s2">if </span><span class="s1">scaling == </span><span class="s3">'spectrum'</span><span class="s1">:</span>
        <span class="s1">xsubs *= win.sum()</span>
    <span class="s2">elif </span><span class="s1">scaling == </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s1">xsubs *= np.sqrt(fs * sum(win**</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Parameter </span><span class="s2">{</span><span class="s1">scaling=</span><span class="s2">} </span><span class="s3">not in ['spectrum', 'psd']!&quot;</span><span class="s1">)</span>

    <span class="s5"># Construct the output from the ifft segments</span>
    <span class="s5"># This loop could perhaps be vectorized/strided somehow...</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(nseg):</span>
        <span class="s5"># Window the ifft</span>
        <span class="s1">x[...</span><span class="s2">, </span><span class="s1">ii*nstep:ii*nstep+nperseg] += xsubs[...</span><span class="s2">, </span><span class="s1">ii] * win</span>
        <span class="s1">norm[...</span><span class="s2">, </span><span class="s1">ii*nstep:ii*nstep+nperseg] += win**</span><span class="s4">2</span>

    <span class="s5"># Remove extension points</span>
    <span class="s2">if </span><span class="s1">boundary:</span>
        <span class="s1">x = x[...</span><span class="s2">, </span><span class="s1">nperseg//</span><span class="s4">2</span><span class="s1">:-(nperseg//</span><span class="s4">2</span><span class="s1">)]</span>
        <span class="s1">norm = norm[...</span><span class="s2">, </span><span class="s1">nperseg//</span><span class="s4">2</span><span class="s1">:-(nperseg//</span><span class="s4">2</span><span class="s1">)]</span>

    <span class="s5"># Divide out normalization where non-tiny</span>
    <span class="s2">if </span><span class="s1">np.sum(norm &gt; </span><span class="s4">1e-10</span><span class="s1">) != len(norm):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;NOLA condition failed, STFT may not be invertible.&quot;</span>
            <span class="s1">+ (</span><span class="s3">&quot; Possibly due to missing boundary&quot; </span><span class="s2">if not </span><span class="s1">boundary </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">x /= np.where(norm &gt; </span><span class="s4">1e-10</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">input_onesided:</span>
        <span class="s1">x = x.real</span>

    <span class="s5"># Put axes back</span>
    <span class="s2">if </span><span class="s1">x.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">time_axis != Zxx.ndim-</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">freq_axis &lt; time_axis:</span>
                <span class="s1">time_axis -= </span><span class="s4">1</span>
            <span class="s1">x = np.moveaxis(x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">time_axis)</span>

    <span class="s1">time = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">])/float(fs)</span>
    <span class="s2">return </span><span class="s1">time</span><span class="s2">, </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">coherence(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">fs=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">window=</span><span class="s3">'hann'</span><span class="s2">, </span><span class="s1">nperseg=</span><span class="s2">None, </span><span class="s1">noverlap=</span><span class="s2">None,</span>
              <span class="s1">nfft=</span><span class="s2">None, </span><span class="s1">detrend=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Estimate the magnitude squared coherence estimate, Cxy, of 
    discrete-time signals X and Y using Welch's method. 
 
    ``Cxy = abs(Pxy)**2/(Pxx*Pyy)``, where `Pxx` and `Pyy` are power 
    spectral density estimates of X and Y, and `Pxy` is the cross 
    spectral density estimate of X and Y. 
 
    Parameters 
    ---------- 
    x : array_like 
        Time series of measurement values 
    y : array_like 
        Time series of measurement values 
    fs : float, optional 
        Sampling frequency of the `x` and `y` time series. Defaults 
        to 1.0. 
    window : str or tuple or array_like, optional 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. Defaults 
        to a Hann window. 
    nperseg : int, optional 
        Length of each segment. Defaults to None, but if window is str or 
        tuple, is set to 256, and if window is array_like, is set to the 
        length of the window. 
    noverlap: int, optional 
        Number of points to overlap between segments. If `None`, 
        ``noverlap = nperseg // 2``. Defaults to `None`. 
    nfft : int, optional 
        Length of the FFT used, if a zero padded FFT is desired. If 
        `None`, the FFT length is `nperseg`. Defaults to `None`. 
    detrend : str or function or `False`, optional 
        Specifies how to detrend each segment. If `detrend` is a 
        string, it is passed as the `type` argument to the `detrend` 
        function. If it is a function, it takes a segment and returns a 
        detrended segment. If `detrend` is `False`, no detrending is 
        done. Defaults to 'constant'. 
    axis : int, optional 
        Axis along which the coherence is computed for both inputs; the 
        default is over the last axis (i.e. ``axis=-1``). 
 
    Returns 
    ------- 
    f : ndarray 
        Array of sample frequencies. 
    Cxy : ndarray 
        Magnitude squared coherence of x and y. 
 
    See Also 
    -------- 
    periodogram: Simple, optionally modified periodogram 
    lombscargle: Lomb-Scargle periodogram for unevenly sampled data 
    welch: Power spectral density by Welch's method. 
    csd: Cross spectral density by Welch's method. 
 
    Notes 
    ----- 
    An appropriate amount of overlap will depend on the choice of window 
    and on your requirements. For the default Hann window an overlap of 
    50% is a reasonable trade off between accurately estimating the 
    signal power, while not over counting any of the data. Narrower 
    windows may require a larger overlap. 
 
    .. versionadded:: 0.16.0 
 
    References 
    ---------- 
    .. [1] P. Welch, &quot;The use of the fast Fourier transform for the 
           estimation of power spectra: A method based on time averaging 
           over short, modified periodograms&quot;, IEEE Trans. Audio 
           Electroacoust. vol. 15, pp. 70-73, 1967. 
    .. [2] Stoica, Petre, and Randolph Moses, &quot;Spectral Analysis of 
           Signals&quot; Prentice Hall, 2005 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Generate two test signals with some common features. 
 
    &gt;&gt;&gt; fs = 10e3 
    &gt;&gt;&gt; N = 1e5 
    &gt;&gt;&gt; amp = 20 
    &gt;&gt;&gt; freq = 1234.0 
    &gt;&gt;&gt; noise_power = 0.001 * fs / 2 
    &gt;&gt;&gt; time = np.arange(N) / fs 
    &gt;&gt;&gt; b, a = signal.butter(2, 0.25, 'low') 
    &gt;&gt;&gt; x = rng.normal(scale=np.sqrt(noise_power), size=time.shape) 
    &gt;&gt;&gt; y = signal.lfilter(b, a, x) 
    &gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time) 
    &gt;&gt;&gt; y += rng.normal(scale=0.1*np.sqrt(noise_power), size=time.shape) 
 
    Compute and plot the coherence. 
 
    &gt;&gt;&gt; f, Cxy = signal.coherence(x, y, fs, nperseg=1024) 
    &gt;&gt;&gt; plt.semilogy(f, Cxy) 
    &gt;&gt;&gt; plt.xlabel('frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('Coherence') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">freqs</span><span class="s2">, </span><span class="s1">Pxx = welch(x</span><span class="s2">, </span><span class="s1">fs=fs</span><span class="s2">, </span><span class="s1">window=window</span><span class="s2">, </span><span class="s1">nperseg=nperseg</span><span class="s2">,</span>
                       <span class="s1">noverlap=noverlap</span><span class="s2">, </span><span class="s1">nfft=nfft</span><span class="s2">, </span><span class="s1">detrend=detrend</span><span class="s2">,</span>
                       <span class="s1">axis=axis)</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">Pyy = welch(y</span><span class="s2">, </span><span class="s1">fs=fs</span><span class="s2">, </span><span class="s1">window=window</span><span class="s2">, </span><span class="s1">nperseg=nperseg</span><span class="s2">, </span><span class="s1">noverlap=noverlap</span><span class="s2">,</span>
                   <span class="s1">nfft=nfft</span><span class="s2">, </span><span class="s1">detrend=detrend</span><span class="s2">, </span><span class="s1">axis=axis)</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">Pxy = csd(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">fs=fs</span><span class="s2">, </span><span class="s1">window=window</span><span class="s2">, </span><span class="s1">nperseg=nperseg</span><span class="s2">,</span>
                 <span class="s1">noverlap=noverlap</span><span class="s2">, </span><span class="s1">nfft=nfft</span><span class="s2">, </span><span class="s1">detrend=detrend</span><span class="s2">, </span><span class="s1">axis=axis)</span>

    <span class="s1">Cxy = np.abs(Pxy)**</span><span class="s4">2 </span><span class="s1">/ Pxx / Pyy</span>

    <span class="s2">return </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">Cxy</span>


<span class="s2">def </span><span class="s1">_spectral_helper(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">fs=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">window=</span><span class="s3">'hann'</span><span class="s2">, </span><span class="s1">nperseg=</span><span class="s2">None, </span><span class="s1">noverlap=</span><span class="s2">None,</span>
                     <span class="s1">nfft=</span><span class="s2">None, </span><span class="s1">detrend=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">return_onesided=</span><span class="s2">True,</span>
                     <span class="s1">scaling=</span><span class="s3">'density'</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'psd'</span><span class="s2">, </span><span class="s1">boundary=</span><span class="s2">None,</span>
                     <span class="s1">padded=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Calculate various forms of windowed FFTs for PSD, CSD, etc. 
 
    This is a helper function that implements the commonality between 
    the stft, psd, csd, and spectrogram functions. It is not designed to 
    be called externally. The windows are not averaged over; the result 
    from each window is returned. 
 
    Parameters 
    ---------- 
    x : array_like 
        Array or sequence containing the data to be analyzed. 
    y : array_like 
        Array or sequence containing the data to be analyzed. If this is 
        the same object in memory as `x` (i.e. ``_spectral_helper(x, 
        x, ...)``), the extra computations are spared. 
    fs : float, optional 
        Sampling frequency of the time series. Defaults to 1.0. 
    window : str or tuple or array_like, optional 
        Desired window to use. If `window` is a string or tuple, it is 
        passed to `get_window` to generate the window values, which are 
        DFT-even by default. See `get_window` for a list of windows and 
        required parameters. If `window` is array_like it will be used 
        directly as the window and its length must be nperseg. Defaults 
        to a Hann window. 
    nperseg : int, optional 
        Length of each segment. Defaults to None, but if window is str or 
        tuple, is set to 256, and if window is array_like, is set to the 
        length of the window. 
    noverlap : int, optional 
        Number of points to overlap between segments. If `None`, 
        ``noverlap = nperseg // 2``. Defaults to `None`. 
    nfft : int, optional 
        Length of the FFT used, if a zero padded FFT is desired. If 
        `None`, the FFT length is `nperseg`. Defaults to `None`. 
    detrend : str or function or `False`, optional 
        Specifies how to detrend each segment. If `detrend` is a 
        string, it is passed as the `type` argument to the `detrend` 
        function. If it is a function, it takes a segment and returns a 
        detrended segment. If `detrend` is `False`, no detrending is 
        done. Defaults to 'constant'. 
    return_onesided : bool, optional 
        If `True`, return a one-sided spectrum for real data. If 
        `False` return a two-sided spectrum. Defaults to `True`, but for 
        complex data, a two-sided spectrum is always returned. 
    scaling : { 'density', 'spectrum' }, optional 
        Selects between computing the cross spectral density ('density') 
        where `Pxy` has units of V**2/Hz and computing the cross 
        spectrum ('spectrum') where `Pxy` has units of V**2, if `x` 
        and `y` are measured in V and `fs` is measured in Hz. 
        Defaults to 'density' 
    axis : int, optional 
        Axis along which the FFTs are computed; the default is over the 
        last axis (i.e. ``axis=-1``). 
    mode: str {'psd', 'stft'}, optional 
        Defines what kind of return values are expected. Defaults to 
        'psd'. 
    boundary : str or None, optional 
        Specifies whether the input signal is extended at both ends, and 
        how to generate the new values, in order to center the first 
        windowed segment on the first input point. This has the benefit 
        of enabling reconstruction of the first input point when the 
        employed window function starts at zero. Valid options are 
        ``['even', 'odd', 'constant', 'zeros', None]``. Defaults to 
        `None`. 
    padded : bool, optional 
        Specifies whether the input signal is zero-padded at the end to 
        make the signal fit exactly into an integer number of window 
        segments, so that all of the signal is included in the output. 
        Defaults to `False`. Padding occurs after boundary extension, if 
        `boundary` is not `None`, and `padded` is `True`. 
 
    Returns 
    ------- 
    freqs : ndarray 
        Array of sample frequencies. 
    t : ndarray 
        Array of times corresponding to each data segment 
    result : ndarray 
        Array of output data, contents dependent on *mode* kwarg. 
 
    Notes 
    ----- 
    Adapted from matplotlib.mlab 
 
    .. versionadded:: 0.16.0 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'psd'</span><span class="s2">, </span><span class="s3">'stft'</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unknown value for mode %s, must be one of: &quot;</span>
                         <span class="s3">&quot;{'psd', 'stft'}&quot; </span><span class="s1">% mode)</span>

    <span class="s1">boundary_funcs = {</span><span class="s3">'even'</span><span class="s1">: even_ext</span><span class="s2">,</span>
                      <span class="s3">'odd'</span><span class="s1">: odd_ext</span><span class="s2">,</span>
                      <span class="s3">'constant'</span><span class="s1">: const_ext</span><span class="s2">,</span>
                      <span class="s3">'zeros'</span><span class="s1">: zero_ext</span><span class="s2">,</span>
                      <span class="s2">None</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span>

    <span class="s2">if </span><span class="s1">boundary </span><span class="s2">not in </span><span class="s1">boundary_funcs:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unknown boundary option '{}', must be one of: {}&quot;</span>
                         <span class="s1">.format(boundary</span><span class="s2">, </span><span class="s1">list(boundary_funcs.keys())))</span>

    <span class="s5"># If x and y are the same object we can save ourselves some computation.</span>
    <span class="s1">same_data = y </span><span class="s2">is </span><span class="s1">x</span>

    <span class="s2">if not </span><span class="s1">same_data </span><span class="s2">and </span><span class="s1">mode != </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;x and y must be equal if mode is 'stft'&quot;</span><span class="s1">)</span>

    <span class="s1">axis = int(axis)</span>

    <span class="s5"># Ensure we have np.arrays, get outdtype</span>
    <span class="s1">x = np.asarray(x)</span>
    <span class="s2">if not </span><span class="s1">same_data:</span>
        <span class="s1">y = np.asarray(y)</span>
        <span class="s1">outdtype = np.result_type(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">np.complex64)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">outdtype = np.result_type(x</span><span class="s2">, </span><span class="s1">np.complex64)</span>

    <span class="s2">if not </span><span class="s1">same_data:</span>
        <span class="s5"># Check if we can broadcast the outer axes together</span>
        <span class="s1">xouter = list(x.shape)</span>
        <span class="s1">youter = list(y.shape)</span>
        <span class="s1">xouter.pop(axis)</span>
        <span class="s1">youter.pop(axis)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">outershape = np.broadcast(np.empty(xouter)</span><span class="s2">, </span><span class="s1">np.empty(youter)).shape</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'x and y cannot be broadcast together.'</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">if </span><span class="s1">same_data:</span>
        <span class="s2">if </span><span class="s1">x.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.empty(x.shape)</span><span class="s2">, </span><span class="s1">np.empty(x.shape)</span><span class="s2">, </span><span class="s1">np.empty(x.shape)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">x.size == </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">y.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">outshape = outershape + (min([x.shape[axis]</span><span class="s2">, </span><span class="s1">y.shape[axis]])</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s1">emptyout = np.moveaxis(np.empty(outshape)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s2">return </span><span class="s1">emptyout</span><span class="s2">, </span><span class="s1">emptyout</span><span class="s2">, </span><span class="s1">emptyout</span>

    <span class="s2">if </span><span class="s1">x.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">axis != -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">x = np.moveaxis(x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">same_data </span><span class="s2">and </span><span class="s1">y.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">y = np.moveaxis(y</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s5"># Check if x and y are the same length, zero-pad if necessary</span>
    <span class="s2">if not </span><span class="s1">same_data:</span>
        <span class="s2">if </span><span class="s1">x.shape[-</span><span class="s4">1</span><span class="s1">] != y.shape[-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">x.shape[-</span><span class="s4">1</span><span class="s1">] &lt; y.shape[-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">pad_shape = list(x.shape)</span>
                <span class="s1">pad_shape[-</span><span class="s4">1</span><span class="s1">] = y.shape[-</span><span class="s4">1</span><span class="s1">] - x.shape[-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">x = np.concatenate((x</span><span class="s2">, </span><span class="s1">np.zeros(pad_shape))</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">pad_shape = list(y.shape)</span>
                <span class="s1">pad_shape[-</span><span class="s4">1</span><span class="s1">] = x.shape[-</span><span class="s4">1</span><span class="s1">] - y.shape[-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">y = np.concatenate((y</span><span class="s2">, </span><span class="s1">np.zeros(pad_shape))</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">nperseg </span><span class="s2">is not None</span><span class="s1">:  </span><span class="s5"># if specified by user</span>
        <span class="s1">nperseg = int(nperseg)</span>
        <span class="s2">if </span><span class="s1">nperseg &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'nperseg must be a positive integer'</span><span class="s1">)</span>

    <span class="s5"># parse window; if array like, then set nperseg = win.shape</span>
    <span class="s1">win</span><span class="s2">, </span><span class="s1">nperseg = _triage_segments(window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">input_length=x.shape[-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">if </span><span class="s1">nfft </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">nfft = nperseg</span>
    <span class="s2">elif </span><span class="s1">nfft &lt; nperseg:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'nfft must be greater than or equal to nperseg.'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">nfft = int(nfft)</span>

    <span class="s2">if </span><span class="s1">noverlap </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">noverlap = nperseg//</span><span class="s4">2</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">noverlap = int(noverlap)</span>
    <span class="s2">if </span><span class="s1">noverlap &gt;= nperseg:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'noverlap must be less than nperseg.'</span><span class="s1">)</span>
    <span class="s1">nstep = nperseg - noverlap</span>

    <span class="s5"># Padding occurs after boundary extension, so that the extended signal ends</span>
    <span class="s5"># in zeros, instead of introducing an impulse at the end.</span>
    <span class="s5"># I.e. if x = [..., 3, 2]</span>
    <span class="s5"># extend then pad -&gt; [..., 3, 2, 2, 3, 0, 0, 0]</span>
    <span class="s5"># pad then extend -&gt; [..., 3, 2, 0, 0, 0, 2, 3]</span>

    <span class="s2">if </span><span class="s1">boundary </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">ext_func = boundary_funcs[boundary]</span>
        <span class="s1">x = ext_func(x</span><span class="s2">, </span><span class="s1">nperseg//</span><span class="s4">2</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">same_data:</span>
            <span class="s1">y = ext_func(y</span><span class="s2">, </span><span class="s1">nperseg//</span><span class="s4">2</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">padded:</span>
        <span class="s5"># Pad to integer number of windowed segments</span>
        <span class="s5"># I.e make x.shape[-1] = nperseg + (nseg-1)*nstep, with integer nseg</span>
        <span class="s1">nadd = (-(x.shape[-</span><span class="s4">1</span><span class="s1">]-nperseg) % nstep) % nperseg</span>
        <span class="s1">zeros_shape = list(x.shape[:-</span><span class="s4">1</span><span class="s1">]) + [nadd]</span>
        <span class="s1">x = np.concatenate((x</span><span class="s2">, </span><span class="s1">np.zeros(zeros_shape))</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">same_data:</span>
            <span class="s1">zeros_shape = list(y.shape[:-</span><span class="s4">1</span><span class="s1">]) + [nadd]</span>
            <span class="s1">y = np.concatenate((y</span><span class="s2">, </span><span class="s1">np.zeros(zeros_shape))</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s5"># Handle detrending and window functions</span>
    <span class="s2">if not </span><span class="s1">detrend:</span>
        <span class="s2">def </span><span class="s1">detrend_func(d):</span>
            <span class="s2">return </span><span class="s1">d</span>
    <span class="s2">elif not </span><span class="s1">hasattr(detrend</span><span class="s2">, </span><span class="s3">'__call__'</span><span class="s1">):</span>
        <span class="s2">def </span><span class="s1">detrend_func(d):</span>
            <span class="s2">return </span><span class="s1">_signaltools.detrend(d</span><span class="s2">, </span><span class="s1">type=detrend</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">axis != -</span><span class="s4">1</span><span class="s1">:</span>
        <span class="s5"># Wrap this function so that it receives a shape that it could</span>
        <span class="s5"># reasonably expect to receive.</span>
        <span class="s2">def </span><span class="s1">detrend_func(d):</span>
            <span class="s1">d = np.moveaxis(d</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis)</span>
            <span class="s1">d = detrend(d)</span>
            <span class="s2">return </span><span class="s1">np.moveaxis(d</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">detrend_func = detrend</span>

    <span class="s2">if </span><span class="s1">np.result_type(win</span><span class="s2">, </span><span class="s1">np.complex64) != outdtype:</span>
        <span class="s1">win = win.astype(outdtype)</span>

    <span class="s2">if </span><span class="s1">scaling == </span><span class="s3">'density'</span><span class="s1">:</span>
        <span class="s1">scale = </span><span class="s4">1.0 </span><span class="s1">/ (fs * (win*win).sum())</span>
    <span class="s2">elif </span><span class="s1">scaling == </span><span class="s3">'spectrum'</span><span class="s1">:</span>
        <span class="s1">scale = </span><span class="s4">1.0 </span><span class="s1">/ win.sum()**</span><span class="s4">2</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown scaling: %r' </span><span class="s1">% scaling)</span>

    <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'stft'</span><span class="s1">:</span>
        <span class="s1">scale = np.sqrt(scale)</span>

    <span class="s2">if </span><span class="s1">return_onesided:</span>
        <span class="s2">if </span><span class="s1">np.iscomplexobj(x):</span>
            <span class="s1">sides = </span><span class="s3">'twosided'</span>
            <span class="s1">warnings.warn(</span><span class="s3">'Input data is complex, switching to '</span>
                          <span class="s3">'return_onesided=False'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sides = </span><span class="s3">'onesided'</span>
            <span class="s2">if not </span><span class="s1">same_data:</span>
                <span class="s2">if </span><span class="s1">np.iscomplexobj(y):</span>
                    <span class="s1">sides = </span><span class="s3">'twosided'</span>
                    <span class="s1">warnings.warn(</span><span class="s3">'Input data is complex, switching to '</span>
                                  <span class="s3">'return_onesided=False'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">sides = </span><span class="s3">'twosided'</span>

    <span class="s2">if </span><span class="s1">sides == </span><span class="s3">'twosided'</span><span class="s1">:</span>
        <span class="s1">freqs = sp_fft.fftfreq(nfft</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/fs)</span>
    <span class="s2">elif </span><span class="s1">sides == </span><span class="s3">'onesided'</span><span class="s1">:</span>
        <span class="s1">freqs = sp_fft.rfftfreq(nfft</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/fs)</span>

    <span class="s5"># Perform the windowed FFTs</span>
    <span class="s1">result = _fft_helper(x</span><span class="s2">, </span><span class="s1">win</span><span class="s2">, </span><span class="s1">detrend_func</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">nfft</span><span class="s2">, </span><span class="s1">sides)</span>

    <span class="s2">if not </span><span class="s1">same_data:</span>
        <span class="s5"># All the same operations on the y data</span>
        <span class="s1">result_y = _fft_helper(y</span><span class="s2">, </span><span class="s1">win</span><span class="s2">, </span><span class="s1">detrend_func</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">nfft</span><span class="s2">,</span>
                               <span class="s1">sides)</span>
        <span class="s1">result = np.conjugate(result) * result_y</span>
    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s1">result = np.conjugate(result) * result</span>

    <span class="s1">result *= scale</span>
    <span class="s2">if </span><span class="s1">sides == </span><span class="s3">'onesided' </span><span class="s2">and </span><span class="s1">mode == </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">nfft % </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">result[...</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:] *= </span><span class="s4">2</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Last point is unpaired Nyquist freq point, don't double</span>
            <span class="s1">result[...</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">] *= </span><span class="s4">2</span>

    <span class="s1">time = np.arange(nperseg/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">x.shape[-</span><span class="s4">1</span><span class="s1">] - nperseg/</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span><span class="s2">,</span>
                     <span class="s1">nperseg - noverlap)/float(fs)</span>
    <span class="s2">if </span><span class="s1">boundary </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">time -= (nperseg/</span><span class="s4">2</span><span class="s1">) / fs</span>

    <span class="s1">result = result.astype(outdtype)</span>

    <span class="s5"># All imaginary parts are zero anyways</span>
    <span class="s2">if </span><span class="s1">same_data </span><span class="s2">and </span><span class="s1">mode != </span><span class="s3">'stft'</span><span class="s1">:</span>
        <span class="s1">result = result.real</span>

    <span class="s5"># Output is going to have new last axis for time/window index, so a</span>
    <span class="s5"># negative axis index shifts down one</span>
    <span class="s2">if </span><span class="s1">axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">axis -= </span><span class="s4">1</span>

    <span class="s5"># Roll frequency axis back to axis where the data came from</span>
    <span class="s1">result = np.moveaxis(result</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis)</span>

    <span class="s2">return </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_fft_helper(x</span><span class="s2">, </span><span class="s1">win</span><span class="s2">, </span><span class="s1">detrend_func</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">nfft</span><span class="s2">, </span><span class="s1">sides):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate windowed FFT, for internal use by 
    `scipy.signal._spectral_helper`. 
 
    This is a helper function that does the main FFT calculation for 
    `_spectral helper`. All input validation is performed there, and the 
    data axis is assumed to be the last axis of x. It is not designed to 
    be called externally. The windows are not averaged over; the result 
    from each window is returned. 
 
    Returns 
    ------- 
    result : ndarray 
        Array of FFT data 
 
    Notes 
    ----- 
    Adapted from matplotlib.mlab 
 
    .. versionadded:: 0.16.0 
    &quot;&quot;&quot;</span>
    <span class="s5"># Created strided array of data segments</span>
    <span class="s2">if </span><span class="s1">nperseg == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">noverlap == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">result = x[...</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s5"># https://stackoverflow.com/a/5568169</span>
        <span class="s1">step = nperseg - noverlap</span>
        <span class="s1">shape = x.shape[:-</span><span class="s4">1</span><span class="s1">]+((x.shape[-</span><span class="s4">1</span><span class="s1">]-noverlap)//step</span><span class="s2">, </span><span class="s1">nperseg)</span>
        <span class="s1">strides = x.strides[:-</span><span class="s4">1</span><span class="s1">]+(step*x.strides[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x.strides[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">result = np.lib.stride_tricks.as_strided(x</span><span class="s2">, </span><span class="s1">shape=shape</span><span class="s2">,</span>
                                                 <span class="s1">strides=strides)</span>

    <span class="s5"># Detrend each data segment individually</span>
    <span class="s1">result = detrend_func(result)</span>

    <span class="s5"># Apply window by multiplication</span>
    <span class="s1">result = win * result</span>

    <span class="s5"># Perform the fft. Acts on last axis by default. Zero-pads automatically</span>
    <span class="s2">if </span><span class="s1">sides == </span><span class="s3">'twosided'</span><span class="s1">:</span>
        <span class="s1">func = sp_fft.fft</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result = result.real</span>
        <span class="s1">func = sp_fft.rfft</span>
    <span class="s1">result = func(result</span><span class="s2">, </span><span class="s1">n=nfft)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_triage_segments(window</span><span class="s2">, </span><span class="s1">nperseg</span><span class="s2">, </span><span class="s1">input_length):</span>
    <span class="s0">&quot;&quot;&quot; 
    Parses window and nperseg arguments for spectrogram and _spectral_helper. 
    This is a helper function, not meant to be called externally. 
 
    Parameters 
    ---------- 
    window : string, tuple, or ndarray 
        If window is specified by a string or tuple and nperseg is not 
        specified, nperseg is set to the default of 256 and returns a window of 
        that length. 
        If instead the window is array_like and nperseg is not specified, then 
        nperseg is set to the length of the window. A ValueError is raised if 
        the user supplies both an array_like window and a value for nperseg but 
        nperseg does not equal the length of the window. 
 
    nperseg : int 
        Length of each segment 
 
    input_length: int 
        Length of input signal, i.e. x.shape[-1]. Used to test for errors. 
 
    Returns 
    ------- 
    win : ndarray 
        window. If function was called with string or tuple than this will hold 
        the actual array used as a window. 
 
    nperseg : int 
        Length of each segment. If window is str or tuple, nperseg is set to 
        256. If window is array_like, nperseg is set to the length of the 
        window. 
    &quot;&quot;&quot;</span>
    <span class="s5"># parse window; if array like, then set nperseg = win.shape</span>
    <span class="s2">if </span><span class="s1">isinstance(window</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">isinstance(window</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s5"># if nperseg not specified</span>
        <span class="s2">if </span><span class="s1">nperseg </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">nperseg = </span><span class="s4">256  </span><span class="s5"># then change to default</span>
        <span class="s2">if </span><span class="s1">nperseg &gt; input_length:</span>
            <span class="s1">warnings.warn(</span><span class="s3">'nperseg = {0:d} is greater than input length '</span>
                          <span class="s3">' = {1:d}, using nperseg = {1:d}'</span>
                          <span class="s1">.format(nperseg</span><span class="s2">, </span><span class="s1">input_length))</span>
            <span class="s1">nperseg = input_length</span>
        <span class="s1">win = get_window(window</span><span class="s2">, </span><span class="s1">nperseg)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">win = np.asarray(window)</span>
        <span class="s2">if </span><span class="s1">len(win.shape) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'window must be 1-D'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">input_length &lt; win.shape[-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'window is longer than input signal'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">nperseg </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">nperseg = win.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">nperseg </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">nperseg != win.shape[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;value specified for nperseg is different&quot;</span>
                                 <span class="s3">&quot; from length of window&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">win</span><span class="s2">, </span><span class="s1">nperseg</span>


<span class="s2">def </span><span class="s1">_median_bias(n):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the bias of the median of a set of periodograms relative to 
    the mean. 
 
    See Appendix B from [1]_ for details. 
 
    Parameters 
    ---------- 
    n : int 
        Numbers of periodograms being averaged. 
 
    Returns 
    ------- 
    bias : float 
        Calculated bias. 
 
    References 
    ---------- 
    .. [1] B. Allen, W.G. Anderson, P.R. Brady, D.A. Brown, J.D.E. Creighton. 
           &quot;FINDCHIRP: an algorithm for detection of gravitational waves from 
           inspiraling compact binaries&quot;, Physical Review D 85, 2012, 
           :arxiv:`gr-qc/0509116` 
    &quot;&quot;&quot;</span>
    <span class="s1">ii_2 = </span><span class="s4">2 </span><span class="s1">* np.arange(</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">(n-</span><span class="s4">1</span><span class="s1">) // </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s4">1 </span><span class="s1">+ np.sum(</span><span class="s4">1. </span><span class="s1">/ (ii_2 + </span><span class="s4">1</span><span class="s1">) - </span><span class="s4">1. </span><span class="s1">/ ii_2)</span>
</pre>
</body>
</html>