<html>
<head>
<title>test_numpy_pickle.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_numpy_pickle.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Test the numpy pickler as a replacement of the standard pickler.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">random</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">gzip</span>
<span class="s2">import </span><span class="s1">zlib</span>
<span class="s2">import </span><span class="s1">bz2</span>
<span class="s2">import </span><span class="s1">pickle</span>
<span class="s2">import </span><span class="s1">socket</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">closing</span>
<span class="s2">import </span><span class="s1">mmap</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">lzma</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">lzma = </span><span class="s2">None</span>

<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">joblib.test.common </span><span class="s2">import </span><span class="s1">np</span><span class="s2">, </span><span class="s1">with_numpy</span><span class="s2">, </span><span class="s1">with_lz4</span><span class="s2">, </span><span class="s1">without_lz4</span>
<span class="s2">from </span><span class="s1">joblib.test.common </span><span class="s2">import </span><span class="s1">with_memory_profiler</span><span class="s2">, </span><span class="s1">memory_used</span>
<span class="s2">from </span><span class="s1">joblib.testing </span><span class="s2">import </span><span class="s1">parametrize</span><span class="s2">, </span><span class="s1">raises</span><span class="s2">, </span><span class="s1">warns</span>

<span class="s3"># numpy_pickle is not a drop-in replacement of pickle, as it takes</span>
<span class="s3"># filenames instead of open files as arguments.</span>
<span class="s2">from </span><span class="s1">joblib </span><span class="s2">import </span><span class="s1">numpy_pickle</span><span class="s2">, </span><span class="s1">register_compressor</span>
<span class="s2">from </span><span class="s1">joblib.test </span><span class="s2">import </span><span class="s1">data</span>

<span class="s2">from </span><span class="s1">joblib.numpy_pickle_utils </span><span class="s2">import </span><span class="s1">_IO_BUFFER_SIZE</span>
<span class="s2">from </span><span class="s1">joblib.numpy_pickle_utils </span><span class="s2">import </span><span class="s1">_detect_compressor</span>
<span class="s2">from </span><span class="s1">joblib.numpy_pickle_utils </span><span class="s2">import </span><span class="s1">_is_numpy_array_byte_order_mismatch</span>
<span class="s2">from </span><span class="s1">joblib.numpy_pickle_utils </span><span class="s2">import </span><span class="s1">_ensure_native_byte_order</span>
<span class="s2">from </span><span class="s1">joblib.compressor </span><span class="s2">import </span><span class="s1">(_COMPRESSORS</span><span class="s2">, </span><span class="s1">_LZ4_PREFIX</span><span class="s2">, </span><span class="s1">CompressorWrapper</span><span class="s2">,</span>
                               <span class="s1">LZ4_NOT_INSTALLED_ERROR</span><span class="s2">, </span><span class="s1">BinaryZlibFile)</span>


<span class="s3">###############################################################################</span>
<span class="s3"># Define a list of standard types.</span>
<span class="s3"># Borrowed from dill, initial author: Micheal McKerns:</span>
<span class="s3"># http://dev.danse.us/trac/pathos/browser/dill/dill_test2.py</span>

<span class="s1">typelist = []</span>

<span class="s3"># testing types</span>
<span class="s1">_none = </span><span class="s2">None</span>
<span class="s1">typelist.append(_none)</span>
<span class="s1">_type = type</span>
<span class="s1">typelist.append(_type)</span>
<span class="s1">_bool = bool(</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">typelist.append(_bool)</span>
<span class="s1">_int = int(</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">typelist.append(_int)</span>
<span class="s1">_float = float(</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">typelist.append(_float)</span>
<span class="s1">_complex = complex(</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">typelist.append(_complex)</span>
<span class="s1">_string = str(</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">typelist.append(_string)</span>
<span class="s1">_tuple = ()</span>
<span class="s1">typelist.append(_tuple)</span>
<span class="s1">_list = []</span>
<span class="s1">typelist.append(_list)</span>
<span class="s1">_dict = {}</span>
<span class="s1">typelist.append(_dict)</span>
<span class="s1">_builtin = len</span>
<span class="s1">typelist.append(_builtin)</span>


<span class="s2">def </span><span class="s1">_function(x):</span>
    <span class="s2">yield </span><span class="s1">x</span>


<span class="s2">class </span><span class="s1">_class:</span>
    <span class="s2">def </span><span class="s1">_method(self):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">_newclass(object):</span>
    <span class="s2">def </span><span class="s1">_method(self):</span>
        <span class="s2">pass</span>


<span class="s1">typelist.append(_function)</span>
<span class="s1">typelist.append(_class)</span>
<span class="s1">typelist.append(_newclass)  </span><span class="s3"># &lt;type 'type'&gt;</span>
<span class="s1">_instance = _class()</span>
<span class="s1">typelist.append(_instance)</span>
<span class="s1">_object = _newclass()</span>
<span class="s1">typelist.append(_object)  </span><span class="s3"># &lt;type 'class'&gt;</span>


<span class="s3">###############################################################################</span>
<span class="s3"># Tests</span>

<span class="s1">@parametrize(</span><span class="s5">'compress'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
<span class="s1">@parametrize(</span><span class="s5">'member'</span><span class="s2">, </span><span class="s1">typelist)</span>
<span class="s2">def </span><span class="s1">test_standard_types(tmpdir</span><span class="s2">, </span><span class="s1">compress</span><span class="s2">, </span><span class="s1">member):</span>
    <span class="s3"># Test pickling and saving with standard types.</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(member</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">compress=compress)</span>
    <span class="s1">_member = numpy_pickle.load(filename)</span>
    <span class="s3"># We compare the pickled instance to the reloaded one only if it</span>
    <span class="s3"># can be compared to a copied one</span>
    <span class="s2">if </span><span class="s1">member == copy.deepcopy(member):</span>
        <span class="s2">assert </span><span class="s1">member == _member</span>


<span class="s2">def </span><span class="s1">test_value_error():</span>
    <span class="s3"># Test inverting the input arguments to dump</span>
    <span class="s2">with </span><span class="s1">raises(ValueError):</span>
        <span class="s1">numpy_pickle.dump(</span><span class="s5">'foo'</span><span class="s2">, </span><span class="s1">dict())</span>


<span class="s1">@parametrize(</span><span class="s5">'wrong_compress'</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">dict()])</span>
<span class="s2">def </span><span class="s1">test_compress_level_error(wrong_compress):</span>
    <span class="s3"># Verify that passing an invalid compress argument raises an error.</span>
    <span class="s1">exception_msg = (</span><span class="s5">'Non valid compress level given: '</span>
                     <span class="s5">'&quot;{0}&quot;'</span><span class="s1">.format(wrong_compress))</span>
    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">numpy_pickle.dump(</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s5">'foo'</span><span class="s2">, </span><span class="s1">compress=wrong_compress)</span>
    <span class="s1">excinfo.match(exception_msg)</span>


<span class="s1">@with_numpy</span>
<span class="s1">@parametrize(</span><span class="s5">'compress'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s5">'zlib'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_numpy_persistence(tmpdir</span><span class="s2">, </span><span class="s1">compress):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">rnd = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">a = rnd.random_sample((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s3"># We use 'a.T' to have a non C-contiguous array.</span>
    <span class="s2">for </span><span class="s1">index</span><span class="s2">, </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">enumerate(((a</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(a.T</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">a)</span><span class="s2">, </span><span class="s1">[a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a])):</span>
        <span class="s1">filenames = numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">compress=compress)</span>

        <span class="s3"># All is cached in one file</span>
        <span class="s2">assert </span><span class="s1">len(filenames) == </span><span class="s4">1</span>
        <span class="s3"># Check that only one file was created</span>
        <span class="s2">assert </span><span class="s1">filenames[</span><span class="s4">0</span><span class="s1">] == filename</span>
        <span class="s3"># Check that this file does exist</span>
        <span class="s2">assert </span><span class="s1">os.path.exists(filenames[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s3"># Unpickle the object</span>
        <span class="s1">obj_ = numpy_pickle.load(filename)</span>
        <span class="s3"># Check that the items are indeed arrays</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">obj_:</span>
            <span class="s2">assert </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
        <span class="s3"># And finally, check that all the values are equal.</span>
        <span class="s1">np.testing.assert_array_equal(np.array(obj)</span><span class="s2">, </span><span class="s1">np.array(obj_))</span>

    <span class="s3"># Now test with an array subclass</span>
    <span class="s1">obj = np.memmap(filename + </span><span class="s5">'mmap'</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'w+'</span><span class="s2">, </span><span class="s1">shape=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">filenames = numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">compress=compress)</span>
    <span class="s3"># All is cached in one file</span>
    <span class="s2">assert </span><span class="s1">len(filenames) == </span><span class="s4">1</span>

    <span class="s1">obj_ = numpy_pickle.load(filename)</span>
    <span class="s2">if </span><span class="s1">(type(obj) </span><span class="s2">is not </span><span class="s1">np.memmap </span><span class="s2">and</span>
            <span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s5">'__array_prepare__'</span><span class="s1">)):</span>
        <span class="s3"># We don't reconstruct memmaps</span>
        <span class="s2">assert </span><span class="s1">isinstance(obj_</span><span class="s2">, </span><span class="s1">type(obj))</span>

    <span class="s1">np.testing.assert_array_equal(obj_</span><span class="s2">, </span><span class="s1">obj)</span>

    <span class="s3"># Test with an object containing multiple numpy arrays</span>
    <span class="s1">obj = ComplexTestObject()</span>
    <span class="s1">filenames = numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">compress=compress)</span>
    <span class="s3"># All is cached in one file</span>
    <span class="s2">assert </span><span class="s1">len(filenames) == </span><span class="s4">1</span>

    <span class="s1">obj_loaded = numpy_pickle.load(filename)</span>
    <span class="s2">assert </span><span class="s1">isinstance(obj_loaded</span><span class="s2">, </span><span class="s1">type(obj))</span>
    <span class="s1">np.testing.assert_array_equal(obj_loaded.array_float</span><span class="s2">, </span><span class="s1">obj.array_float)</span>
    <span class="s1">np.testing.assert_array_equal(obj_loaded.array_int</span><span class="s2">, </span><span class="s1">obj.array_int)</span>
    <span class="s1">np.testing.assert_array_equal(obj_loaded.array_obj</span><span class="s2">, </span><span class="s1">obj.array_obj)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_numpy_persistence_bufferred_array_compression(tmpdir):</span>
    <span class="s1">big_array = np.ones((_IO_BUFFER_SIZE + </span><span class="s4">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(big_array</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">compress=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">arr_reloaded = numpy_pickle.load(filename)</span>

    <span class="s1">np.testing.assert_array_equal(big_array</span><span class="s2">, </span><span class="s1">arr_reloaded)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_memmap_persistence(tmpdir):</span>
    <span class="s1">rnd = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">a = rnd.random_sample(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test1.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(a</span><span class="s2">, </span><span class="s1">filename)</span>
    <span class="s1">b = numpy_pickle.load(filename</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">isinstance(b</span><span class="s2">, </span><span class="s1">np.memmap)</span>

    <span class="s3"># Test with an object containing multiple numpy arrays</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test2.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">obj = ComplexTestObject()</span>
    <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">filename)</span>
    <span class="s1">obj_loaded = numpy_pickle.load(filename</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">isinstance(obj_loaded</span><span class="s2">, </span><span class="s1">type(obj))</span>
    <span class="s2">assert </span><span class="s1">isinstance(obj_loaded.array_float</span><span class="s2">, </span><span class="s1">np.memmap)</span>
    <span class="s2">assert not </span><span class="s1">obj_loaded.array_float.flags.writeable</span>
    <span class="s2">assert </span><span class="s1">isinstance(obj_loaded.array_int</span><span class="s2">, </span><span class="s1">np.memmap)</span>
    <span class="s2">assert not </span><span class="s1">obj_loaded.array_int.flags.writeable</span>
    <span class="s3"># Memory map not allowed for numpy object arrays</span>
    <span class="s2">assert not </span><span class="s1">isinstance(obj_loaded.array_obj</span><span class="s2">, </span><span class="s1">np.memmap)</span>
    <span class="s1">np.testing.assert_array_equal(obj_loaded.array_float</span><span class="s2">,</span>
                                  <span class="s1">obj.array_float)</span>
    <span class="s1">np.testing.assert_array_equal(obj_loaded.array_int</span><span class="s2">,</span>
                                  <span class="s1">obj.array_int)</span>
    <span class="s1">np.testing.assert_array_equal(obj_loaded.array_obj</span><span class="s2">,</span>
                                  <span class="s1">obj.array_obj)</span>

    <span class="s3"># Test we can write in memmapped arrays</span>
    <span class="s1">obj_loaded = numpy_pickle.load(filename</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r+'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">obj_loaded.array_float.flags.writeable</span>
    <span class="s1">obj_loaded.array_float[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">10</span><span class="s1">] = </span><span class="s4">10.0</span>
    <span class="s2">assert </span><span class="s1">obj_loaded.array_int.flags.writeable</span>
    <span class="s1">obj_loaded.array_int[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">10</span><span class="s1">] = </span><span class="s4">10</span>

    <span class="s1">obj_reloaded = numpy_pickle.load(filename</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_array_equal(obj_reloaded.array_float</span><span class="s2">,</span>
                                  <span class="s1">obj_loaded.array_float)</span>
    <span class="s1">np.testing.assert_array_equal(obj_reloaded.array_int</span><span class="s2">,</span>
                                  <span class="s1">obj_loaded.array_int)</span>

    <span class="s3"># Test w+ mode is caught and the mode has switched to r+</span>
    <span class="s1">numpy_pickle.load(filename</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'w+'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">obj_loaded.array_int.flags.writeable</span>
    <span class="s2">assert </span><span class="s1">obj_loaded.array_int.mode == </span><span class="s5">'r+'</span>
    <span class="s2">assert </span><span class="s1">obj_loaded.array_float.flags.writeable</span>
    <span class="s2">assert </span><span class="s1">obj_loaded.array_float.mode == </span><span class="s5">'r+'</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_memmap_persistence_mixed_dtypes(tmpdir):</span>
    <span class="s3"># loading datastructures that have sub-arrays with dtype=object</span>
    <span class="s3"># should not prevent memmapping on fixed size dtype sub-arrays.</span>
    <span class="s1">rnd = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">a = rnd.random_sample(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">b = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s5">'b'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s1">construct = (a</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(construct</span><span class="s2">, </span><span class="s1">filename)</span>
    <span class="s1">a_clone</span><span class="s2">, </span><span class="s1">b_clone = numpy_pickle.load(filename</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>

    <span class="s3"># the floating point array has been memory mapped</span>
    <span class="s2">assert </span><span class="s1">isinstance(a_clone</span><span class="s2">, </span><span class="s1">np.memmap)</span>

    <span class="s3"># the object-dtype array has been loaded in memory</span>
    <span class="s2">assert not </span><span class="s1">isinstance(b_clone</span><span class="s2">, </span><span class="s1">np.memmap)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_masked_array_persistence(tmpdir):</span>
    <span class="s3"># The special-case picker fails, because saving masked_array</span>
    <span class="s3"># not implemented, but it just delegates to the standard pickler.</span>
    <span class="s1">rnd = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">a = rnd.random_sample(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">a = np.ma.masked_greater(a</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(a</span><span class="s2">, </span><span class="s1">filename)</span>
    <span class="s1">b = numpy_pickle.load(filename</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">isinstance(b</span><span class="s2">, </span><span class="s1">np.ma.masked_array)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_compress_mmap_mode_warning(tmpdir):</span>
    <span class="s3"># Test the warning in case of compress + mmap_mode</span>
    <span class="s1">rnd = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">a = rnd.random_sample(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">this_filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(a</span><span class="s2">, </span><span class="s1">this_filename</span><span class="s2">, </span><span class="s1">compress=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">warns(UserWarning) </span><span class="s2">as </span><span class="s1">warninfo:</span>
        <span class="s1">numpy_pickle.load(this_filename</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r+'</span><span class="s1">)</span>
    <span class="s1">debug_msg = </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">.join([str(w) </span><span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">warninfo])</span>
    <span class="s1">warninfo = [w.message </span><span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">warninfo]</span>
    <span class="s2">assert </span><span class="s1">len(warninfo) == </span><span class="s4">1</span><span class="s2">, </span><span class="s1">debug_msg</span>
    <span class="s2">assert </span><span class="s1">(</span>
        <span class="s1">str(warninfo[</span><span class="s4">0</span><span class="s1">]) ==</span>
        <span class="s5">'mmap_mode &quot;r+&quot; is not compatible with compressed '</span>
        <span class="s5">f'file </span><span class="s2">{</span><span class="s1">this_filename</span><span class="s2">}</span><span class="s5">. &quot;r+&quot; flag will be ignored.'</span>
    <span class="s1">)</span>


<span class="s1">@with_numpy</span>
<span class="s1">@parametrize(</span><span class="s5">'cache_size'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_cache_size_warning(tmpdir</span><span class="s2">, </span><span class="s1">cache_size):</span>
    <span class="s3"># Check deprecation warning raised when cache size is not None</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">rnd = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">a = rnd.random_sample((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

    <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">warninfo:</span>
        <span class="s1">numpy_pickle.dump(a</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">cache_size=cache_size)</span>
    <span class="s1">expected_nb_warnings = </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">cache_size </span><span class="s2">is not None else </span><span class="s4">0</span>
    <span class="s2">assert </span><span class="s1">len(warninfo) == expected_nb_warnings</span>
    <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">warninfo:</span>
        <span class="s2">assert </span><span class="s1">w.category == DeprecationWarning</span>
        <span class="s2">assert </span><span class="s1">(str(w.message) ==</span>
                <span class="s5">&quot;Please do not set 'cache_size' in joblib.dump, this &quot;</span>
                <span class="s5">&quot;parameter has no effect and will be removed. You &quot;</span>
                <span class="s5">&quot;used 'cache_size={0}'&quot;</span><span class="s1">.format(cache_size))</span>


<span class="s1">@with_numpy</span>
<span class="s1">@with_memory_profiler</span>
<span class="s1">@parametrize(</span><span class="s5">'compress'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_memory_usage(tmpdir</span><span class="s2">, </span><span class="s1">compress):</span>
    <span class="s3"># Verify memory stays within expected bounds.</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">small_array = np.ones((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
    <span class="s1">big_array = np.ones(shape=</span><span class="s4">100 </span><span class="s1">* int(</span><span class="s4">1e6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>

    <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">(small_array</span><span class="s2">, </span><span class="s1">big_array):</span>
        <span class="s1">size = obj.nbytes / </span><span class="s4">1e6</span>
        <span class="s1">obj_filename = filename + str(np.random.randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">))</span>
        <span class="s1">mem_used = memory_used(numpy_pickle.dump</span><span class="s2">,</span>
                               <span class="s1">obj</span><span class="s2">, </span><span class="s1">obj_filename</span><span class="s2">, </span><span class="s1">compress=compress)</span>

        <span class="s3"># The memory used to dump the object shouldn't exceed the buffer</span>
        <span class="s3"># size used to write array chunks (16MB).</span>
        <span class="s1">write_buf_size = _IO_BUFFER_SIZE + </span><span class="s4">16 </span><span class="s1">* </span><span class="s4">1024 </span><span class="s1">** </span><span class="s4">2 </span><span class="s1">/ </span><span class="s4">1e6</span>
        <span class="s2">assert </span><span class="s1">mem_used &lt;= write_buf_size</span>

        <span class="s1">mem_used = memory_used(numpy_pickle.load</span><span class="s2">, </span><span class="s1">obj_filename)</span>
        <span class="s3"># memory used should be less than array size + buffer size used to</span>
        <span class="s3"># read the array chunk by chunk.</span>
        <span class="s1">read_buf_size = </span><span class="s4">32 </span><span class="s1">+ _IO_BUFFER_SIZE  </span><span class="s3"># MiB</span>
        <span class="s2">assert </span><span class="s1">mem_used &lt; size + read_buf_size</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_compressed_pickle_dump_and_load(tmpdir):</span>
    <span class="s1">expected_list = [np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;i8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&gt;i8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;f8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&gt;f8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s5">'abc'</span><span class="s2">, </span><span class="s1">{</span><span class="s5">'a'</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s5">'b'</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'O'</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">np.arange(</span><span class="s4">256</span><span class="s2">, </span><span class="s1">dtype=np.uint8).tobytes()</span><span class="s2">,</span>
                     <span class="s5">u&quot;C'est l'</span><span class="s2">\xe9</span><span class="s5">t</span><span class="s2">\xe9 </span><span class="s5">!&quot;</span><span class="s1">]</span>

    <span class="s1">fname = tmpdir.join(</span><span class="s5">'temp.pkl.gz'</span><span class="s1">).strpath</span>

    <span class="s1">dumped_filenames = numpy_pickle.dump(expected_list</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">compress=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">len(dumped_filenames) == </span><span class="s4">1</span>
    <span class="s1">result_list = numpy_pickle.load(fname)</span>
    <span class="s2">for </span><span class="s1">result</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">zip(result_list</span><span class="s2">, </span><span class="s1">expected_list):</span>
        <span class="s2">if </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">expected = _ensure_native_byte_order(expected)</span>
            <span class="s2">assert </span><span class="s1">result.dtype == expected.dtype</span>
            <span class="s1">np.testing.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">def </span><span class="s1">_check_pickle(filename</span><span class="s2">, </span><span class="s1">expected_list</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Helper function to test joblib pickle content. 
 
    Note: currently only pickles containing an iterable are supported 
    by this function. 
    &quot;&quot;&quot;</span>
    <span class="s1">version_match = re.match(</span><span class="s5">r'.+py(\d)(\d).+'</span><span class="s2">, </span><span class="s1">filename)</span>
    <span class="s1">py_version_used_for_writing = int(version_match.group(</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">py_version_to_default_pickle_protocol = {</span><span class="s4">2</span><span class="s1">: </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">: </span><span class="s4">3</span><span class="s1">}</span>
    <span class="s1">pickle_reading_protocol = py_version_to_default_pickle_protocol.get(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">pickle_writing_protocol = py_version_to_default_pickle_protocol.get(</span>
        <span class="s1">py_version_used_for_writing</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">pickle_reading_protocol &gt;= pickle_writing_protocol:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">warninfo:</span>
                <span class="s1">warnings.simplefilter(</span><span class="s5">'always'</span><span class="s1">)</span>
                <span class="s1">warnings.filterwarnings(</span>
                    <span class="s5">'ignore'</span><span class="s2">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s2">,</span>
                    <span class="s1">message=</span><span class="s5">'The compiler package is deprecated'</span><span class="s1">)</span>
                <span class="s1">result_list = numpy_pickle.load(filename</span><span class="s2">, </span><span class="s1">mmap_mode=mmap_mode)</span>
            <span class="s1">filename_base = os.path.basename(filename)</span>
            <span class="s1">expected_nb_deprecation_warnings = </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">(</span>
                <span class="s5">&quot;_0.9&quot; </span><span class="s2">in </span><span class="s1">filename_base </span><span class="s2">or </span><span class="s5">&quot;_0.8.4&quot; </span><span class="s2">in </span><span class="s1">filename_base) </span><span class="s2">else </span><span class="s4">0</span>

            <span class="s1">expected_nb_user_warnings = </span><span class="s4">3 </span><span class="s2">if </span><span class="s1">(</span>
                <span class="s1">re.search(</span><span class="s5">&quot;_0.1.+.pkl$&quot;</span><span class="s2">, </span><span class="s1">filename_base) </span><span class="s2">and</span>
                <span class="s1">mmap_mode </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">else </span><span class="s4">0</span>
            <span class="s1">expected_nb_warnings = \</span>
                <span class="s1">expected_nb_deprecation_warnings + expected_nb_user_warnings</span>
            <span class="s2">assert </span><span class="s1">len(warninfo) == expected_nb_warnings</span>

            <span class="s1">deprecation_warnings = [</span>
                <span class="s1">w </span><span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">warninfo </span><span class="s2">if </span><span class="s1">issubclass(</span>
                    <span class="s1">w.category</span><span class="s2">, </span><span class="s1">DeprecationWarning)]</span>
            <span class="s1">user_warnings = [</span>
                <span class="s1">w </span><span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">warninfo </span><span class="s2">if </span><span class="s1">issubclass(</span>
                    <span class="s1">w.category</span><span class="s2">, </span><span class="s1">UserWarning)]</span>
            <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">deprecation_warnings:</span>
                <span class="s2">assert </span><span class="s1">(str(w.message) ==</span>
                        <span class="s5">&quot;The file '{0}' has been generated with a joblib &quot;</span>
                        <span class="s5">&quot;version less than 0.10. Please regenerate this &quot;</span>
                        <span class="s5">&quot;pickle file.&quot;</span><span class="s1">.format(filename))</span>

            <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">user_warnings:</span>
                <span class="s1">escaped_filename = re.escape(filename)</span>
                <span class="s2">assert </span><span class="s1">re.search(</span>
                    <span class="s5">f&quot;memmapped.+</span><span class="s2">{</span><span class="s1">escaped_filename</span><span class="s2">}</span><span class="s5">.+segmentation fault&quot;</span><span class="s2">,</span>
                    <span class="s1">str(w.message))</span>

            <span class="s2">for </span><span class="s1">result</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">zip(result_list</span><span class="s2">, </span><span class="s1">expected_list):</span>
                <span class="s2">if </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
                    <span class="s1">expected = _ensure_native_byte_order(expected)</span>
                    <span class="s2">assert </span><span class="s1">result.dtype == expected.dtype</span>
                    <span class="s1">np.testing.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">assert </span><span class="s1">result == expected</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s3"># When trying to read with python 3 a pickle generated</span>
            <span class="s3"># with python 2 we expect a user-friendly error</span>
            <span class="s2">if </span><span class="s1">py_version_used_for_writing == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">isinstance(exc</span><span class="s2">, </span><span class="s1">ValueError)</span>
                <span class="s1">message = (</span><span class="s5">'You may be trying to read with '</span>
                           <span class="s5">'python 3 a joblib pickle generated with python 2.'</span><span class="s1">)</span>
                <span class="s2">assert </span><span class="s1">message </span><span class="s2">in </span><span class="s1">str(exc)</span>
            <span class="s2">elif </span><span class="s1">filename.endswith(</span><span class="s5">'.lz4'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">with_lz4.args[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s2">assert </span><span class="s1">isinstance(exc</span><span class="s2">, </span><span class="s1">ValueError)</span>
                <span class="s2">assert </span><span class="s1">LZ4_NOT_INSTALLED_ERROR </span><span class="s2">in </span><span class="s1">str(exc)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Pickle protocol used for writing is too high. We expect a</span>
        <span class="s3"># &quot;unsupported pickle protocol&quot; error message</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">numpy_pickle.load(filename)</span>
            <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s5">'Numpy pickle loading should '</span>
                                 <span class="s5">'have raised a ValueError exception'</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">message = </span><span class="s5">'unsupported pickle protocol: {0}'</span><span class="s1">.format(</span>
                <span class="s1">pickle_writing_protocol)</span>
            <span class="s2">assert </span><span class="s1">message </span><span class="s2">in </span><span class="s1">str(e.args)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_joblib_pickle_across_python_versions():</span>
    <span class="s3"># We need to be specific about dtypes in particular endianness</span>
    <span class="s3"># because the pickles can be generated on one architecture and</span>
    <span class="s3"># the tests run on another one. See</span>
    <span class="s3"># https://github.com/joblib/joblib/issues/279.</span>
    <span class="s1">expected_list = [np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;i8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;f8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s5">'abc'</span><span class="s2">, </span><span class="s1">{</span><span class="s5">'a'</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s5">'b'</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'O'</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">np.arange(</span><span class="s4">256</span><span class="s2">, </span><span class="s1">dtype=np.uint8).tobytes()</span><span class="s2">,</span>
                     <span class="s3"># np.matrix is a subclass of np.ndarray, here we want</span>
                     <span class="s3"># to verify this type of object is correctly unpickled</span>
                     <span class="s3"># among versions.</span>
                     <span class="s1">np.matrix([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;i8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s5">u&quot;C'est l'</span><span class="s2">\xe9</span><span class="s5">t</span><span class="s2">\xe9 </span><span class="s5">!&quot;</span><span class="s1">]</span>

    <span class="s3"># Testing all the compressed and non compressed</span>
    <span class="s3"># pickles in joblib/test/data. These pickles were generated by</span>
    <span class="s3"># the joblib/test/data/create_numpy_pickle.py script for the</span>
    <span class="s3"># relevant python, joblib and numpy versions.</span>
    <span class="s1">test_data_dir = os.path.dirname(os.path.abspath(data.__file__))</span>

    <span class="s1">pickle_extensions = (</span><span class="s5">'.pkl'</span><span class="s2">, </span><span class="s5">'.gz'</span><span class="s2">, </span><span class="s5">'.gzip'</span><span class="s2">, </span><span class="s5">'.bz2'</span><span class="s2">, </span><span class="s5">'lz4'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">lzma </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">pickle_extensions += (</span><span class="s5">'.xz'</span><span class="s2">, </span><span class="s5">'.lzma'</span><span class="s1">)</span>
    <span class="s1">pickle_filenames = [os.path.join(test_data_dir</span><span class="s2">, </span><span class="s1">fn)</span>
                        <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">os.listdir(test_data_dir)</span>
                        <span class="s2">if </span><span class="s1">any(fn.endswith(ext) </span><span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">pickle_extensions)]</span>

    <span class="s2">for </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">pickle_filenames:</span>
        <span class="s1">_check_pickle(fname</span><span class="s2">, </span><span class="s1">expected_list)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_joblib_pickle_across_python_versions_with_mmap():</span>
    <span class="s1">expected_list = [np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;i8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;f8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s5">'abc'</span><span class="s2">, </span><span class="s1">{</span><span class="s5">'a'</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s5">'b'</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'O'</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">np.arange(</span><span class="s4">256</span><span class="s2">, </span><span class="s1">dtype=np.uint8).tobytes()</span><span class="s2">,</span>
                     <span class="s3"># np.matrix is a subclass of np.ndarray, here we want</span>
                     <span class="s3"># to verify this type of object is correctly unpickled</span>
                     <span class="s3"># among versions.</span>
                     <span class="s1">np.matrix([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;i8'</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s5">u&quot;C'est l'</span><span class="s2">\xe9</span><span class="s5">t</span><span class="s2">\xe9 </span><span class="s5">!&quot;</span><span class="s1">]</span>

    <span class="s1">test_data_dir = os.path.dirname(os.path.abspath(data.__file__))</span>

    <span class="s1">pickle_filenames = [</span>
        <span class="s1">os.path.join(test_data_dir</span><span class="s2">, </span><span class="s1">fn)</span>
        <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">os.listdir(test_data_dir) </span><span class="s2">if </span><span class="s1">fn.endswith(</span><span class="s5">'.pkl'</span><span class="s1">)]</span>
    <span class="s2">for </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">pickle_filenames:</span>
        <span class="s1">_check_pickle(fname</span><span class="s2">, </span><span class="s1">expected_list</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_numpy_array_byte_order_mismatch_detection():</span>
    <span class="s3"># List of numpy arrays with big endian byteorder.</span>
    <span class="s1">be_arrays = [np.array([(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">)]</span><span class="s2">,</span>
                          <span class="s1">dtype=[(</span><span class="s5">''</span><span class="s2">, </span><span class="s5">'&gt;i8'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">''</span><span class="s2">, </span><span class="s5">'&gt;f8'</span><span class="s1">)])</span><span class="s2">,</span>
                 <span class="s1">np.arange(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&gt;i8'</span><span class="s1">))</span><span class="s2">,</span>
                 <span class="s1">np.arange(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&gt;f8'</span><span class="s1">))]</span>

    <span class="s3"># Verify the byteorder mismatch is correctly detected.</span>
    <span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">be_arrays:</span>
        <span class="s2">if </span><span class="s1">sys.byteorder == </span><span class="s5">'big'</span><span class="s1">:</span>
            <span class="s2">assert not </span><span class="s1">_is_numpy_array_byte_order_mismatch(array)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">_is_numpy_array_byte_order_mismatch(array)</span>
        <span class="s1">converted = _ensure_native_byte_order(array)</span>
        <span class="s2">if </span><span class="s1">converted.dtype.fields:</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">converted.dtype.fields.values():</span>
                <span class="s1">f[</span><span class="s4">0</span><span class="s1">].byteorder == </span><span class="s5">'='</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">converted.dtype.byteorder == </span><span class="s5">&quot;=&quot;</span>

    <span class="s3"># List of numpy arrays with little endian byteorder.</span>
    <span class="s1">le_arrays = [np.array([(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">)]</span><span class="s2">,</span>
                          <span class="s1">dtype=[(</span><span class="s5">''</span><span class="s2">, </span><span class="s5">'&lt;i8'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">''</span><span class="s2">, </span><span class="s5">'&lt;f8'</span><span class="s1">)])</span><span class="s2">,</span>
                 <span class="s1">np.arange(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;i8'</span><span class="s1">))</span><span class="s2">,</span>
                 <span class="s1">np.arange(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s5">'&lt;f8'</span><span class="s1">))]</span>

    <span class="s3"># Verify the byteorder mismatch is correctly detected.</span>
    <span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">le_arrays:</span>
        <span class="s2">if </span><span class="s1">sys.byteorder == </span><span class="s5">'little'</span><span class="s1">:</span>
            <span class="s2">assert not </span><span class="s1">_is_numpy_array_byte_order_mismatch(array)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">_is_numpy_array_byte_order_mismatch(array)</span>
        <span class="s1">converted = _ensure_native_byte_order(array)</span>
        <span class="s2">if </span><span class="s1">converted.dtype.fields:</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">converted.dtype.fields.values():</span>
                <span class="s1">f[</span><span class="s4">0</span><span class="s1">].byteorder == </span><span class="s5">'='</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">converted.dtype.byteorder == </span><span class="s5">&quot;=&quot;</span>


<span class="s1">@parametrize(</span><span class="s5">'compress_tuple'</span><span class="s2">, </span><span class="s1">[(</span><span class="s5">'zlib'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">'gzip'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_compress_tuple_argument(tmpdir</span><span class="s2">, </span><span class="s1">compress_tuple):</span>
    <span class="s3"># Verify the tuple is correctly taken into account.</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(</span><span class="s5">&quot;dummy&quot;</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">,</span>
                      <span class="s1">compress=compress_tuple)</span>
    <span class="s3"># Verify the file contains the right magic number</span>
    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">assert </span><span class="s1">_detect_compressor(f) == compress_tuple[</span><span class="s4">0</span><span class="s1">]</span>


<span class="s1">@parametrize(</span><span class="s5">'compress_tuple,message'</span><span class="s2">,</span>
             <span class="s1">[((</span><span class="s5">'zlib'</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s5">'extra'</span><span class="s1">)</span><span class="s2">,        </span><span class="s3"># wrong compress tuple</span>
               <span class="s5">'Compress argument tuple should contain exactly 2 elements'</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">((</span><span class="s5">'wrong'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,                </span><span class="s3"># wrong compress method</span>
               <span class="s5">'Non valid compression method given: &quot;{}&quot;'</span><span class="s1">.format(</span><span class="s5">'wrong'</span><span class="s1">))</span><span class="s2">,</span>
              <span class="s1">((</span><span class="s5">'zlib'</span><span class="s2">, </span><span class="s5">'wrong'</span><span class="s1">)</span><span class="s2">,           </span><span class="s3"># wrong compress level</span>
               <span class="s5">'Non valid compress level given: &quot;{}&quot;'</span><span class="s1">.format(</span><span class="s5">'wrong'</span><span class="s1">))])</span>
<span class="s2">def </span><span class="s1">test_compress_tuple_argument_exception(tmpdir</span><span class="s2">, </span><span class="s1">compress_tuple</span><span class="s2">, </span><span class="s1">message):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s3"># Verify setting a wrong compress tuple raises a ValueError.</span>
    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">numpy_pickle.dump(</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">compress=compress_tuple)</span>
    <span class="s1">excinfo.match(message)</span>


<span class="s1">@parametrize(</span><span class="s5">'compress_string'</span><span class="s2">, </span><span class="s1">[</span><span class="s5">'zlib'</span><span class="s2">, </span><span class="s5">'gzip'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_compress_string_argument(tmpdir</span><span class="s2">, </span><span class="s1">compress_string):</span>
    <span class="s3"># Verify the string is correctly taken into account.</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(</span><span class="s5">&quot;dummy&quot;</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">,</span>
                      <span class="s1">compress=compress_string)</span>
    <span class="s3"># Verify the file contains the right magic number</span>
    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">assert </span><span class="s1">_detect_compressor(f) == compress_string</span>


<span class="s1">@with_numpy</span>
<span class="s1">@parametrize(</span><span class="s5">'compress'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s1">])</span>
<span class="s1">@parametrize(</span><span class="s5">'cmethod'</span><span class="s2">, </span><span class="s1">_COMPRESSORS)</span>
<span class="s2">def </span><span class="s1">test_joblib_compression_formats(tmpdir</span><span class="s2">, </span><span class="s1">compress</span><span class="s2">, </span><span class="s1">cmethod):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">objects = (np.ones(shape=(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'f8'</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">range(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">{</span><span class="s5">'a'</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">: </span><span class="s5">'b'</span><span class="s1">}</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">cmethod </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;lzma&quot;</span><span class="s2">, </span><span class="s5">&quot;xz&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">lzma </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">pytest.skip(</span><span class="s5">&quot;lzma is support not available&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">cmethod == </span><span class="s5">'lz4' </span><span class="s2">and </span><span class="s1">with_lz4.args[</span><span class="s4">0</span><span class="s1">]:</span>
        <span class="s3"># Skip the test if lz4 is not installed. We here use the with_lz4</span>
        <span class="s3"># skipif fixture whose argument is True when lz4 is not installed</span>
        <span class="s1">pytest.skip(</span><span class="s5">&quot;lz4 is not installed.&quot;</span><span class="s1">)</span>

    <span class="s1">dump_filename = filename + </span><span class="s5">&quot;.&quot; </span><span class="s1">+ cmethod</span>
    <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">objects:</span>
        <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">dump_filename</span><span class="s2">, </span><span class="s1">compress=(cmethod</span><span class="s2">, </span><span class="s1">compress))</span>
        <span class="s3"># Verify the file contains the right magic number</span>
        <span class="s2">with </span><span class="s1">open(dump_filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s2">assert </span><span class="s1">_detect_compressor(f) == cmethod</span>
        <span class="s3"># Verify the reloaded object is correct</span>
        <span class="s1">obj_reloaded = numpy_pickle.load(dump_filename)</span>
        <span class="s2">assert </span><span class="s1">isinstance(obj_reloaded</span><span class="s2">, </span><span class="s1">type(obj))</span>
        <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">np.testing.assert_array_equal(obj_reloaded</span><span class="s2">, </span><span class="s1">obj)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">obj_reloaded == obj</span>


<span class="s2">def </span><span class="s1">_gzip_file_decompress(source_filename</span><span class="s2">, </span><span class="s1">target_filename):</span>
    <span class="s0">&quot;&quot;&quot;Decompress a gzip file.&quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">closing(gzip.GzipFile(source_filename</span><span class="s2">, </span><span class="s5">&quot;rb&quot;</span><span class="s1">)) </span><span class="s2">as </span><span class="s1">fo:</span>
        <span class="s1">buf = fo.read()</span>

    <span class="s2">with </span><span class="s1">open(target_filename</span><span class="s2">, </span><span class="s5">&quot;wb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fo:</span>
        <span class="s1">fo.write(buf)</span>


<span class="s2">def </span><span class="s1">_zlib_file_decompress(source_filename</span><span class="s2">, </span><span class="s1">target_filename):</span>
    <span class="s0">&quot;&quot;&quot;Decompress a zlib file.&quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">open(source_filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fo:</span>
        <span class="s1">buf = zlib.decompress(fo.read())</span>

    <span class="s2">with </span><span class="s1">open(target_filename</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fo:</span>
        <span class="s1">fo.write(buf)</span>


<span class="s1">@parametrize(</span><span class="s5">'extension,decompress'</span><span class="s2">,</span>
             <span class="s1">[(</span><span class="s5">'.z'</span><span class="s2">, </span><span class="s1">_zlib_file_decompress)</span><span class="s2">,</span>
              <span class="s1">(</span><span class="s5">'.gz'</span><span class="s2">, </span><span class="s1">_gzip_file_decompress)])</span>
<span class="s2">def </span><span class="s1">test_load_externally_decompressed_files(tmpdir</span><span class="s2">, </span><span class="s1">extension</span><span class="s2">, </span><span class="s1">decompress):</span>
    <span class="s3"># Test that BinaryZlibFile generates valid gzip and zlib compressed files.</span>
    <span class="s1">obj = </span><span class="s5">&quot;a string to persist&quot;</span>
    <span class="s1">filename_raw = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>

    <span class="s1">filename_compressed = filename_raw + extension</span>
    <span class="s3"># Use automatic extension detection to compress with the right method.</span>
    <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">filename_compressed)</span>

    <span class="s3"># Decompress with the corresponding method</span>
    <span class="s1">decompress(filename_compressed</span><span class="s2">, </span><span class="s1">filename_raw)</span>

    <span class="s3"># Test that the uncompressed pickle can be loaded and</span>
    <span class="s3"># that the result is correct.</span>
    <span class="s1">obj_reloaded = numpy_pickle.load(filename_raw)</span>
    <span class="s2">assert </span><span class="s1">obj == obj_reloaded</span>


<span class="s1">@parametrize(</span><span class="s5">'extension,cmethod'</span><span class="s2">,</span>
             <span class="s3"># valid compressor extensions</span>
             <span class="s1">[(</span><span class="s5">'.z'</span><span class="s2">, </span><span class="s5">'zlib'</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">(</span><span class="s5">'.gz'</span><span class="s2">, </span><span class="s5">'gzip'</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">(</span><span class="s5">'.bz2'</span><span class="s2">, </span><span class="s5">'bz2'</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">(</span><span class="s5">'.lzma'</span><span class="s2">, </span><span class="s5">'lzma'</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">(</span><span class="s5">'.xz'</span><span class="s2">, </span><span class="s5">'xz'</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s3"># invalid compressor extensions</span>
              <span class="s1">(</span><span class="s5">'.pkl'</span><span class="s2">, </span><span class="s5">'not-compressed'</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">(</span><span class="s5">''</span><span class="s2">, </span><span class="s5">'not-compressed'</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_compression_using_file_extension(tmpdir</span><span class="s2">, </span><span class="s1">extension</span><span class="s2">, </span><span class="s1">cmethod):</span>
    <span class="s2">if </span><span class="s1">cmethod </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;lzma&quot;</span><span class="s2">, </span><span class="s5">&quot;xz&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">lzma </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">pytest.skip(</span><span class="s5">&quot;lzma is missing&quot;</span><span class="s1">)</span>
    <span class="s3"># test that compression method corresponds to the given filename extension.</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">obj = </span><span class="s5">&quot;object to dump&quot;</span>

    <span class="s1">dump_fname = filename + extension</span>
    <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">dump_fname)</span>
    <span class="s3"># Verify the file contains the right magic number</span>
    <span class="s2">with </span><span class="s1">open(dump_fname</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">assert </span><span class="s1">_detect_compressor(f) == cmethod</span>
    <span class="s3"># Verify the reloaded object is correct</span>
    <span class="s1">obj_reloaded = numpy_pickle.load(dump_fname)</span>
    <span class="s2">assert </span><span class="s1">isinstance(obj_reloaded</span><span class="s2">, </span><span class="s1">type(obj))</span>
    <span class="s2">assert </span><span class="s1">obj_reloaded == obj</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_file_handle_persistence(tmpdir):</span>
    <span class="s1">objs = [np.random.random((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span><span class="s2">, </span><span class="s5">&quot;some data&quot;</span><span class="s1">]</span>
    <span class="s1">fobjs = [bz2.BZ2File</span><span class="s2">, </span><span class="s1">gzip.GzipFile]</span>
    <span class="s2">if </span><span class="s1">lzma </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">fobjs += [lzma.LZMAFile]</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>

    <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">objs:</span>
        <span class="s2">for </span><span class="s1">fobj </span><span class="s2">in </span><span class="s1">fobjs:</span>
            <span class="s2">with </span><span class="s1">fobj(filename</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">f)</span>

            <span class="s3"># using the same decompressor prevents from internally</span>
            <span class="s3"># decompress again.</span>
            <span class="s2">with </span><span class="s1">fobj(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">obj_reloaded = numpy_pickle.load(f)</span>

            <span class="s3"># when needed, the correct decompressor should be used when</span>
            <span class="s3"># passing a raw file handle.</span>
            <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">obj_reloaded_2 = numpy_pickle.load(f)</span>

            <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
                <span class="s1">np.testing.assert_array_equal(obj_reloaded</span><span class="s2">, </span><span class="s1">obj)</span>
                <span class="s1">np.testing.assert_array_equal(obj_reloaded_2</span><span class="s2">, </span><span class="s1">obj)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">obj_reloaded == obj</span>
                <span class="s2">assert </span><span class="s1">obj_reloaded_2 == obj</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_in_memory_persistence():</span>
    <span class="s1">objs = [np.random.random((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span><span class="s2">, </span><span class="s5">&quot;some data&quot;</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">objs:</span>
        <span class="s1">f = io.BytesIO()</span>
        <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">f)</span>
        <span class="s1">obj_reloaded = numpy_pickle.load(f)</span>
        <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">np.testing.assert_array_equal(obj_reloaded</span><span class="s2">, </span><span class="s1">obj)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">obj_reloaded == obj</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_file_handle_persistence_mmap(tmpdir):</span>
    <span class="s1">obj = np.random.random((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>

    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">f)</span>

    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">obj_reloaded = numpy_pickle.load(f</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r+'</span><span class="s1">)</span>

    <span class="s1">np.testing.assert_array_equal(obj_reloaded</span><span class="s2">, </span><span class="s1">obj)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_file_handle_persistence_compressed_mmap(tmpdir):</span>
    <span class="s1">obj = np.random.random((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>

    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">compress=(</span><span class="s5">'gzip'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>

    <span class="s2">with </span><span class="s1">closing(gzip.GzipFile(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">)) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">with </span><span class="s1">warns(UserWarning) </span><span class="s2">as </span><span class="s1">warninfo:</span>
            <span class="s1">numpy_pickle.load(f</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r+'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">len(warninfo) == </span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">(str(warninfo[</span><span class="s4">0</span><span class="s1">].message) ==</span>
                <span class="s5">'&quot;%(fileobj)r&quot; is not a raw file, mmap_mode &quot;%(mmap_mode)s&quot; '</span>
                <span class="s5">'flag will be ignored.' </span><span class="s1">% {</span><span class="s5">'fileobj'</span><span class="s1">: f</span><span class="s2">, </span><span class="s5">'mmap_mode'</span><span class="s1">: </span><span class="s5">'r+'</span><span class="s1">})</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_file_handle_persistence_in_memory_mmap():</span>
    <span class="s1">obj = np.random.random((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
    <span class="s1">buf = io.BytesIO()</span>

    <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">buf)</span>

    <span class="s2">with </span><span class="s1">warns(UserWarning) </span><span class="s2">as </span><span class="s1">warninfo:</span>
        <span class="s1">numpy_pickle.load(buf</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r+'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">len(warninfo) == </span><span class="s4">1</span>
    <span class="s2">assert </span><span class="s1">(str(warninfo[</span><span class="s4">0</span><span class="s1">].message) ==</span>
            <span class="s5">'In memory persistence is not compatible with mmap_mode '</span>
            <span class="s5">'&quot;%(mmap_mode)s&quot; flag passed. mmap_mode option will be '</span>
            <span class="s5">'ignored.' </span><span class="s1">% {</span><span class="s5">'mmap_mode'</span><span class="s1">: </span><span class="s5">'r+'</span><span class="s1">})</span>


<span class="s1">@parametrize(</span><span class="s5">'data'</span><span class="s2">, </span><span class="s1">[</span><span class="s6">b'a little data as bytes.'</span><span class="s2">,</span>
                      <span class="s3"># More bytes</span>
                      <span class="s4">10000 </span><span class="s1">* </span><span class="s5">&quot;{}&quot;</span><span class="s1">.format(</span>
                          <span class="s1">random.randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">) * </span><span class="s4">1000</span><span class="s1">).encode(</span><span class="s5">'latin-1'</span><span class="s1">)]</span><span class="s2">,</span>
             <span class="s1">ids=[</span><span class="s5">&quot;a little data as bytes.&quot;</span><span class="s2">, </span><span class="s5">&quot;a large data as bytes.&quot;</span><span class="s1">])</span>
<span class="s1">@parametrize(</span><span class="s5">'compress_level'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_binary_zlibfile(tmpdir</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">compress_level):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s3"># Regular cases</span>
    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">with </span><span class="s1">BinaryZlibFile(f</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s2">,</span>
                            <span class="s1">compresslevel=compress_level) </span><span class="s2">as </span><span class="s1">fz:</span>
            <span class="s2">assert </span><span class="s1">fz.writable()</span>
            <span class="s1">fz.write(data)</span>
            <span class="s2">assert </span><span class="s1">fz.fileno() == f.fileno()</span>
            <span class="s2">with </span><span class="s1">raises(io.UnsupportedOperation):</span>
                <span class="s1">fz._check_can_read()</span>

            <span class="s2">with </span><span class="s1">raises(io.UnsupportedOperation):</span>
                <span class="s1">fz._check_can_seek()</span>
        <span class="s2">assert </span><span class="s1">fz.closed</span>
        <span class="s2">with </span><span class="s1">raises(ValueError):</span>
            <span class="s1">fz._check_not_closed()</span>

    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">with </span><span class="s1">BinaryZlibFile(f) </span><span class="s2">as </span><span class="s1">fz:</span>
            <span class="s2">assert </span><span class="s1">fz.readable()</span>
            <span class="s2">assert </span><span class="s1">fz.seekable()</span>
            <span class="s2">assert </span><span class="s1">fz.fileno() == f.fileno()</span>
            <span class="s2">assert </span><span class="s1">fz.read() == data</span>
            <span class="s2">with </span><span class="s1">raises(io.UnsupportedOperation):</span>
                <span class="s1">fz._check_can_write()</span>
            <span class="s2">assert </span><span class="s1">fz.seekable()</span>
            <span class="s1">fz.seek(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">fz.tell() == </span><span class="s4">0</span>
        <span class="s2">assert </span><span class="s1">fz.closed</span>

    <span class="s3"># Test with a filename as input</span>
    <span class="s2">with </span><span class="s1">BinaryZlibFile(filename</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s2">,</span>
                        <span class="s1">compresslevel=compress_level) </span><span class="s2">as </span><span class="s1">fz:</span>
        <span class="s2">assert </span><span class="s1">fz.writable()</span>
        <span class="s1">fz.write(data)</span>

    <span class="s2">with </span><span class="s1">BinaryZlibFile(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fz:</span>
        <span class="s2">assert </span><span class="s1">fz.read() == data</span>
        <span class="s2">assert </span><span class="s1">fz.seekable()</span>

    <span class="s3"># Test without context manager</span>
    <span class="s1">fz = BinaryZlibFile(filename</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s2">, </span><span class="s1">compresslevel=compress_level)</span>
    <span class="s2">assert </span><span class="s1">fz.writable()</span>
    <span class="s1">fz.write(data)</span>
    <span class="s1">fz.close()</span>

    <span class="s1">fz = BinaryZlibFile(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">fz.read() == data</span>
    <span class="s1">fz.close()</span>


<span class="s1">@parametrize(</span><span class="s5">'bad_value'</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s5">'a'</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">{}])</span>
<span class="s2">def </span><span class="s1">test_binary_zlibfile_bad_compression_levels(tmpdir</span><span class="s2">, </span><span class="s1">bad_value):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">BinaryZlibFile(filename</span><span class="s2">, </span><span class="s5">'wb'</span><span class="s2">, </span><span class="s1">compresslevel=bad_value)</span>
    <span class="s1">pattern = re.escape(</span><span class="s5">&quot;'compresslevel' must be an integer between 1 and 9. &quot;</span>
                        <span class="s5">&quot;You provided 'compresslevel={}'&quot;</span><span class="s1">.format(bad_value))</span>
    <span class="s1">excinfo.match(pattern)</span>


<span class="s1">@parametrize(</span><span class="s5">'bad_mode'</span><span class="s2">, </span><span class="s1">[</span><span class="s5">'a'</span><span class="s2">, </span><span class="s5">'x'</span><span class="s2">, </span><span class="s5">'r'</span><span class="s2">, </span><span class="s5">'w'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_binary_zlibfile_invalid_modes(tmpdir</span><span class="s2">, </span><span class="s1">bad_mode):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">BinaryZlibFile(filename</span><span class="s2">, </span><span class="s1">bad_mode)</span>
    <span class="s1">excinfo.match(</span><span class="s5">&quot;Invalid mode&quot;</span><span class="s1">)</span>


<span class="s1">@parametrize(</span><span class="s5">'bad_file'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">{}])</span>
<span class="s2">def </span><span class="s1">test_binary_zlibfile_invalid_filename_type(bad_file):</span>
    <span class="s2">with </span><span class="s1">raises(TypeError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">BinaryZlibFile(bad_file</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">)</span>
    <span class="s1">excinfo.match(</span><span class="s5">&quot;filename must be a str or bytes object, or a file&quot;</span><span class="s1">)</span>


<span class="s3">###############################################################################</span>
<span class="s3"># Test dumping array subclasses</span>
<span class="s2">if </span><span class="s1">np </span><span class="s2">is not None</span><span class="s1">:</span>

    <span class="s2">class </span><span class="s1">SubArray(np.ndarray):</span>

        <span class="s2">def </span><span class="s1">__reduce__(self):</span>
            <span class="s2">return </span><span class="s1">_load_sub_array</span><span class="s2">, </span><span class="s1">(np.asarray(self)</span><span class="s2">, </span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_load_sub_array(arr):</span>
        <span class="s1">d = SubArray(arr.shape)</span>
        <span class="s1">d[:] = arr</span>
        <span class="s2">return </span><span class="s1">d</span>

    <span class="s2">class </span><span class="s1">ComplexTestObject:</span>
        <span class="s0">&quot;&quot;&quot;A complex object containing numpy arrays as attributes.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self):</span>
            <span class="s1">self.array_float = np.arange(</span><span class="s4">100</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'float64'</span><span class="s1">)</span>
            <span class="s1">self.array_int = np.ones(</span><span class="s4">100</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'int32'</span><span class="s1">)</span>
            <span class="s1">self.array_obj = np.array([</span><span class="s5">'a'</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">20.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'object'</span><span class="s1">)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_numpy_subclass(tmpdir):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">a = SubArray((</span><span class="s4">10</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">numpy_pickle.dump(a</span><span class="s2">, </span><span class="s1">filename)</span>
    <span class="s1">c = numpy_pickle.load(filename)</span>
    <span class="s2">assert </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">SubArray)</span>
    <span class="s1">np.testing.assert_array_equal(c</span><span class="s2">, </span><span class="s1">a)</span>


<span class="s2">def </span><span class="s1">test_pathlib(tmpdir):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">value = </span><span class="s4">123</span>
    <span class="s1">numpy_pickle.dump(value</span><span class="s2">, </span><span class="s1">Path(filename))</span>
    <span class="s2">assert </span><span class="s1">numpy_pickle.load(filename) == value</span>
    <span class="s1">numpy_pickle.dump(value</span><span class="s2">, </span><span class="s1">filename)</span>
    <span class="s2">assert </span><span class="s1">numpy_pickle.load(Path(filename)) == value</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_non_contiguous_array_pickling(tmpdir):</span>
    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>

    <span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">[  </span><span class="s3"># Array that triggers a contiguousness issue with nditer,</span>
                    <span class="s3"># see https://github.com/joblib/joblib/pull/352 and see</span>
                    <span class="s3"># https://github.com/joblib/joblib/pull/353</span>
                    <span class="s1">np.asfortranarray([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]])[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">,</span>
                    <span class="s3"># Non contiguous array with works fine with nditer</span>
                    <span class="s1">np.ones((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">order=</span><span class="s5">'F'</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:]]:</span>
        <span class="s2">assert not </span><span class="s1">array.flags.c_contiguous</span>
        <span class="s2">assert not </span><span class="s1">array.flags.f_contiguous</span>
        <span class="s1">numpy_pickle.dump(array</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s1">array_reloaded = numpy_pickle.load(filename)</span>
        <span class="s1">np.testing.assert_array_equal(array_reloaded</span><span class="s2">, </span><span class="s1">array)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_pickle_highest_protocol(tmpdir):</span>
    <span class="s3"># ensure persistence of a numpy array is valid even when using</span>
    <span class="s3"># the pickle HIGHEST_PROTOCOL.</span>
    <span class="s3"># see https://github.com/joblib/joblib/issues/362</span>

    <span class="s1">filename = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">test_array = np.zeros(</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s1">numpy_pickle.dump(test_array</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">protocol=pickle.HIGHEST_PROTOCOL)</span>
    <span class="s1">array_reloaded = numpy_pickle.load(filename)</span>

    <span class="s1">np.testing.assert_array_equal(array_reloaded</span><span class="s2">, </span><span class="s1">test_array)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_pickle_in_socket():</span>
    <span class="s3"># test that joblib can pickle in sockets</span>
    <span class="s1">test_array = np.arange(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">_ADDR = (</span><span class="s5">&quot;localhost&quot;</span><span class="s2">, </span><span class="s4">12345</span><span class="s1">)</span>
    <span class="s1">listener = socket.socket(socket.AF_INET</span><span class="s2">, </span><span class="s1">socket.SOCK_STREAM)</span>
    <span class="s1">listener.bind(_ADDR)</span>
    <span class="s1">listener.listen(</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">socket.create_connection(_ADDR) </span><span class="s2">as </span><span class="s1">client:</span>
        <span class="s1">server</span><span class="s2">, </span><span class="s1">client_addr = listener.accept()</span>

        <span class="s2">with </span><span class="s1">server.makefile(</span><span class="s5">&quot;wb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">sf:</span>
            <span class="s1">numpy_pickle.dump(test_array</span><span class="s2">, </span><span class="s1">sf)</span>

        <span class="s2">with </span><span class="s1">client.makefile(</span><span class="s5">&quot;rb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">cf:</span>
            <span class="s1">array_reloaded = numpy_pickle.load(cf)</span>

        <span class="s1">np.testing.assert_array_equal(array_reloaded</span><span class="s2">, </span><span class="s1">test_array)</span>

        <span class="s3"># Check that a byte-aligned numpy array written in a file can be send</span>
        <span class="s3"># over a socket and then read on the other side</span>
        <span class="s1">bytes_to_send = io.BytesIO()</span>
        <span class="s1">numpy_pickle.dump(test_array</span><span class="s2">, </span><span class="s1">bytes_to_send)</span>
        <span class="s1">server.send(bytes_to_send.getvalue())</span>

        <span class="s2">with </span><span class="s1">client.makefile(</span><span class="s5">&quot;rb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">cf:</span>
            <span class="s1">array_reloaded = numpy_pickle.load(cf)</span>

        <span class="s1">np.testing.assert_array_equal(array_reloaded</span><span class="s2">, </span><span class="s1">test_array)</span>


<span class="s1">@with_numpy</span>
<span class="s2">def </span><span class="s1">test_load_memmap_with_big_offset(tmpdir):</span>
    <span class="s3"># Test that numpy memmap offset is set correctly if greater than</span>
    <span class="s3"># mmap.ALLOCATIONGRANULARITY, see</span>
    <span class="s3"># https://github.com/joblib/joblib/issues/451 and</span>
    <span class="s3"># https://github.com/numpy/numpy/pull/8443 for more details.</span>
    <span class="s1">fname = tmpdir.join(</span><span class="s5">'test.mmap'</span><span class="s1">).strpath</span>
    <span class="s1">size = mmap.ALLOCATIONGRANULARITY</span>
    <span class="s1">obj = [np.zeros(size</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'uint8'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(size</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'uint8'</span><span class="s1">)]</span>
    <span class="s1">numpy_pickle.dump(obj</span><span class="s2">, </span><span class="s1">fname)</span>
    <span class="s1">memmaps = numpy_pickle.load(fname</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">isinstance(memmaps[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.memmap)</span>
    <span class="s2">assert </span><span class="s1">memmaps[</span><span class="s4">1</span><span class="s1">].offset &gt; size</span>
    <span class="s1">np.testing.assert_array_equal(obj</span><span class="s2">, </span><span class="s1">memmaps)</span>


<span class="s2">def </span><span class="s1">test_register_compressor(tmpdir):</span>
    <span class="s3"># Check that registering compressor file works.</span>
    <span class="s1">compressor_name = </span><span class="s5">'test-name'</span>
    <span class="s1">compressor_prefix = </span><span class="s5">'test-prefix'</span>

    <span class="s2">class </span><span class="s1">BinaryCompressorTestFile(io.BufferedIOBase):</span>
        <span class="s2">pass</span>

    <span class="s2">class </span><span class="s1">BinaryCompressorTestWrapper(CompressorWrapper):</span>

        <span class="s2">def </span><span class="s1">__init__(self):</span>
            <span class="s1">CompressorWrapper.__init__(self</span><span class="s2">, </span><span class="s1">obj=BinaryCompressorTestFile</span><span class="s2">,</span>
                                       <span class="s1">prefix=compressor_prefix)</span>

    <span class="s1">register_compressor(compressor_name</span><span class="s2">, </span><span class="s1">BinaryCompressorTestWrapper())</span>

    <span class="s2">assert </span><span class="s1">(_COMPRESSORS[compressor_name].fileobj_factory ==</span>
            <span class="s1">BinaryCompressorTestFile)</span>
    <span class="s2">assert </span><span class="s1">_COMPRESSORS[compressor_name].prefix == compressor_prefix</span>

    <span class="s3"># Remove this dummy compressor file from extra compressors because other</span>
    <span class="s3"># tests might fail because of this</span>
    <span class="s1">_COMPRESSORS.pop(compressor_name)</span>


<span class="s1">@parametrize(</span><span class="s5">'invalid_name'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">{}])</span>
<span class="s2">def </span><span class="s1">test_register_compressor_invalid_name(invalid_name):</span>
    <span class="s3"># Test that registering an invalid compressor name is not allowed.</span>
    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">register_compressor(invalid_name</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">excinfo.match(</span><span class="s5">&quot;Compressor name should be a string&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_register_compressor_invalid_fileobj():</span>
    <span class="s3"># Test that registering an invalid file object is not allowed.</span>

    <span class="s2">class </span><span class="s1">InvalidFileObject():</span>
        <span class="s2">pass</span>

    <span class="s2">class </span><span class="s1">InvalidFileObjectWrapper(CompressorWrapper):</span>
        <span class="s2">def </span><span class="s1">__init__(self):</span>
            <span class="s1">CompressorWrapper.__init__(self</span><span class="s2">, </span><span class="s1">obj=InvalidFileObject</span><span class="s2">,</span>
                                       <span class="s1">prefix=</span><span class="s6">b'prefix'</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">register_compressor(</span><span class="s5">'invalid'</span><span class="s2">, </span><span class="s1">InvalidFileObjectWrapper())</span>

    <span class="s1">excinfo.match(</span><span class="s5">&quot;Compressor 'fileobj_factory' attribute should implement &quot;</span>
                  <span class="s5">&quot;the file object interface&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">AnotherZlibCompressorWrapper(CompressorWrapper):</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">CompressorWrapper.__init__(self</span><span class="s2">, </span><span class="s1">obj=BinaryZlibFile</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s6">b'prefix'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">StandardLibGzipCompressorWrapper(CompressorWrapper):</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">CompressorWrapper.__init__(self</span><span class="s2">, </span><span class="s1">obj=gzip.GzipFile</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s6">b'prefix'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_register_compressor_already_registered():</span>
    <span class="s3"># Test registration of existing compressor files.</span>
    <span class="s1">compressor_name = </span><span class="s5">'test-name'</span>

    <span class="s3"># register a test compressor</span>
    <span class="s1">register_compressor(compressor_name</span><span class="s2">, </span><span class="s1">AnotherZlibCompressorWrapper())</span>

    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">register_compressor(compressor_name</span><span class="s2">,</span>
                            <span class="s1">StandardLibGzipCompressorWrapper())</span>
    <span class="s1">excinfo.match(</span><span class="s5">&quot;Compressor '{}' already registered.&quot;</span>
                  <span class="s1">.format(compressor_name))</span>

    <span class="s1">register_compressor(compressor_name</span><span class="s2">, </span><span class="s1">StandardLibGzipCompressorWrapper()</span><span class="s2">,</span>
                        <span class="s1">force=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">compressor_name </span><span class="s2">in </span><span class="s1">_COMPRESSORS</span>
    <span class="s2">assert </span><span class="s1">_COMPRESSORS[compressor_name].fileobj_factory == gzip.GzipFile</span>

    <span class="s3"># Remove this dummy compressor file from extra compressors because other</span>
    <span class="s3"># tests might fail because of this</span>
    <span class="s1">_COMPRESSORS.pop(compressor_name)</span>


<span class="s1">@with_lz4</span>
<span class="s2">def </span><span class="s1">test_lz4_compression(tmpdir):</span>
    <span class="s3"># Check that lz4 can be used when dependency is available.</span>
    <span class="s2">import </span><span class="s1">lz4.frame</span>
    <span class="s1">compressor = </span><span class="s5">'lz4'</span>
    <span class="s2">assert </span><span class="s1">compressor </span><span class="s2">in </span><span class="s1">_COMPRESSORS</span>
    <span class="s2">assert </span><span class="s1">_COMPRESSORS[compressor].fileobj_factory == lz4.frame.LZ4FrameFile</span>

    <span class="s1">fname = tmpdir.join(</span><span class="s5">'test.pkl'</span><span class="s1">).strpath</span>
    <span class="s1">data = </span><span class="s5">'test data'</span>
    <span class="s1">numpy_pickle.dump(data</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">compress=compressor)</span>

    <span class="s2">with </span><span class="s1">open(fname</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">assert </span><span class="s1">f.read(len(_LZ4_PREFIX)) == _LZ4_PREFIX</span>
    <span class="s2">assert </span><span class="s1">numpy_pickle.load(fname) == data</span>

    <span class="s3"># Test that LZ4 is applied based on file extension</span>
    <span class="s1">numpy_pickle.dump(data</span><span class="s2">, </span><span class="s1">fname + </span><span class="s5">'.lz4'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">open(fname</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">assert </span><span class="s1">f.read(len(_LZ4_PREFIX)) == _LZ4_PREFIX</span>
    <span class="s2">assert </span><span class="s1">numpy_pickle.load(fname) == data</span>


<span class="s1">@without_lz4</span>
<span class="s2">def </span><span class="s1">test_lz4_compression_without_lz4(tmpdir):</span>
    <span class="s3"># Check that lz4 cannot be used when dependency is not available.</span>
    <span class="s1">fname = tmpdir.join(</span><span class="s5">'test.nolz4'</span><span class="s1">).strpath</span>
    <span class="s1">data = </span><span class="s5">'test data'</span>
    <span class="s1">msg = LZ4_NOT_INSTALLED_ERROR</span>
    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">numpy_pickle.dump(data</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">compress=</span><span class="s5">'lz4'</span><span class="s1">)</span>
    <span class="s1">excinfo.match(msg)</span>

    <span class="s2">with </span><span class="s1">raises(ValueError) </span><span class="s2">as </span><span class="s1">excinfo:</span>
        <span class="s1">numpy_pickle.dump(data</span><span class="s2">, </span><span class="s1">fname + </span><span class="s5">'.lz4'</span><span class="s1">)</span>
    <span class="s1">excinfo.match(msg)</span>


<span class="s1">protocols = [pickle.DEFAULT_PROTOCOL]</span>
<span class="s2">if </span><span class="s1">pickle.HIGHEST_PROTOCOL != pickle.DEFAULT_PROTOCOL:</span>
    <span class="s1">protocols.append(pickle.HIGHEST_PROTOCOL)</span>


<span class="s1">@with_numpy</span>
<span class="s1">@parametrize(</span><span class="s5">'protocol'</span><span class="s2">, </span><span class="s1">protocols)</span>
<span class="s2">def </span><span class="s1">test_memmap_alignment_padding(tmpdir</span><span class="s2">, </span><span class="s1">protocol):</span>
    <span class="s3"># Test that memmaped arrays returned by numpy.load are correctly aligned</span>
    <span class="s1">fname = tmpdir.join(</span><span class="s5">'test.mmap'</span><span class="s1">).strpath</span>

    <span class="s1">a = np.random.randn(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">numpy_pickle.dump(a</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">protocol=protocol)</span>
    <span class="s1">memmap = numpy_pickle.load(fname</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">isinstance(memmap</span><span class="s2">, </span><span class="s1">np.memmap)</span>
    <span class="s1">np.testing.assert_array_equal(a</span><span class="s2">, </span><span class="s1">memmap)</span>
    <span class="s2">assert </span><span class="s1">(</span>
        <span class="s1">memmap.ctypes.data % numpy_pickle.NUMPY_ARRAY_ALIGNMENT_BYTES == </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">memmap.flags.aligned</span>

    <span class="s1">array_list = [</span>
        <span class="s1">np.random.randn(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.random.randn(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">np.random.randn(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.random.randn(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">]</span>

    <span class="s3"># On Windows OSError 22 if reusing the same path for memmap ...</span>
    <span class="s1">fname = tmpdir.join(</span><span class="s5">'test1.mmap'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(array_list</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">protocol=protocol)</span>
    <span class="s1">l_reloaded = numpy_pickle.load(fname</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">memmap </span><span class="s2">in </span><span class="s1">enumerate(l_reloaded):</span>
        <span class="s2">assert </span><span class="s1">isinstance(memmap</span><span class="s2">, </span><span class="s1">np.memmap)</span>
        <span class="s1">np.testing.assert_array_equal(array_list[idx]</span><span class="s2">, </span><span class="s1">memmap)</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">memmap.ctypes.data % numpy_pickle.NUMPY_ARRAY_ALIGNMENT_BYTES == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">memmap.flags.aligned</span>

    <span class="s1">array_dict = {</span>
        <span class="s5">'a0'</span><span class="s1">: np.arange(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
        <span class="s5">'a1'</span><span class="s1">: np.arange(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
        <span class="s5">'a2'</span><span class="s1">: np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
        <span class="s5">'a3'</span><span class="s1">: np.arange(</span><span class="s4">7</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
        <span class="s5">'a4'</span><span class="s1">: np.arange(</span><span class="s4">11</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
        <span class="s5">'a5'</span><span class="s1">: np.arange(</span><span class="s4">13</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
        <span class="s5">'a6'</span><span class="s1">: np.arange(</span><span class="s4">17</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
        <span class="s5">'a7'</span><span class="s1">: np.arange(</span><span class="s4">19</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
        <span class="s5">'a8'</span><span class="s1">: np.arange(</span><span class="s4">23</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s3"># On Windows OSError 22 if reusing the same path for memmap ...</span>
    <span class="s1">fname = tmpdir.join(</span><span class="s5">'test2.mmap'</span><span class="s1">).strpath</span>
    <span class="s1">numpy_pickle.dump(array_dict</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">protocol=protocol)</span>
    <span class="s1">d_reloaded = numpy_pickle.load(fname</span><span class="s2">, </span><span class="s1">mmap_mode=</span><span class="s5">'r'</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">memmap </span><span class="s2">in </span><span class="s1">d_reloaded.items():</span>
        <span class="s2">assert </span><span class="s1">isinstance(memmap</span><span class="s2">, </span><span class="s1">np.memmap)</span>
        <span class="s1">np.testing.assert_array_equal(array_dict[key]</span><span class="s2">, </span><span class="s1">memmap)</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">memmap.ctypes.data % numpy_pickle.NUMPY_ARRAY_ALIGNMENT_BYTES == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">memmap.flags.aligned</span>
</pre>
</body>
</html>