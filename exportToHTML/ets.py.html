<html>
<head>
<title>ets.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ets.py</font>
</center></td></tr></table>
<pre><span class="s0">r&quot;&quot;&quot; 
ETS models for time series analysis. 
 
The ETS models are a family of time series models. They can be seen as a 
generalization of simple exponential smoothing to time series that contain 
trends and seasonalities. Additionally, they have an underlying state space 
model. 
 
An ETS model is specified by an error type (E; additive or multiplicative), a 
trend type (T; additive or multiplicative, both damped or undamped, or none), 
and a seasonality type (S; additive or multiplicative or none). 
The following gives a very short summary, a more thorough introduction can be 
found in [1]_. 
 
Denote with :math:`\circ_b` the trend operation (addition or 
multiplication), with :math:`\circ_d` the operation linking trend and dampening 
factor :math:`\phi` (multiplication if trend is additive, power if trend is 
multiplicative), and with :math:`\circ_s` the seasonality operation (addition 
or multiplication). 
Furthermore, let :math:`\ominus` be the respective inverse operation 
(subtraction or division). 
 
With this, it is possible to formulate the ETS models as a forecast equation 
and 3 smoothing equations. The former is used to forecast observations, the 
latter are used to update the internal state. 
 
.. math:: 
 
    \hat{y}_{t|t-1} &amp;= (l_{t-1} \circ_b (b_{t-1}\circ_d \phi))\circ_s s_{t-m}\\ 
    l_{t} &amp;= \alpha (y_{t} \ominus_s s_{t-m}) 
             + (1 - \alpha) (l_{t-1} \circ_b (b_{t-1} \circ_d \phi))\\ 
    b_{t} &amp;= \beta/\alpha (l_{t} \ominus_b l_{t-1}) 
             + (1 - \beta/\alpha) b_{t-1}\\ 
    s_{t} &amp;= \gamma (y_t \ominus_s (l_{t-1} \circ_b (b_{t-1}\circ_d\phi)) 
             + (1 - \gamma) s_{t-m} 
 
The notation here follows [1]_; :math:`l_t` denotes the level at time 
:math:`t`, `b_t` the trend, and `s_t` the seasonal component. :math:`m` is the 
number of seasonal periods, and :math:`\phi` a trend damping factor. 
The parameters :math:`\alpha, \beta, \gamma` are the smoothing parameters, 
which are called ``smoothing_level``, ``smoothing_trend``, and 
``smoothing_seasonal``, respectively. 
 
Note that the formulation above as forecast and smoothing equation does not 
distinguish different error models -- it is the same for additive and 
multiplicative errors. But the different error models lead to different 
likelihood models, and therefore will lead to different fit results. 
 
The error models specify how the true values :math:`y_t` are updated. In the 
additive error model, 
 
.. math:: 
 
    y_t = \hat{y}_{t|t-1} + e_t, 
 
in the multiplicative error model, 
 
.. math:: 
 
    y_t = \hat{y}_{t|t-1}\cdot (1 + e_t). 
 
Using these error models, it is possible to formulate state space equations for 
the ETS models: 
 
.. math:: 
 
   y_t &amp;= Y_t + \eta \cdot e_t\\ 
   l_t &amp;= L_t + \alpha \cdot (M_e \cdot L_t + \kappa_l) \cdot e_t\\ 
   b_t &amp;= B_t + \beta \cdot (M_e \cdot B_t + \kappa_b) \cdot e_t\\ 
   s_t &amp;= S_t + \gamma \cdot (M_e \cdot S_t+\kappa_s)\cdot e_t\\ 
 
with 
 
.. math:: 
 
   B_t &amp;= b_{t-1} \circ_d \phi\\ 
   L_t &amp;= l_{t-1} \circ_b B_t\\ 
   S_t &amp;= s_{t-m}\\ 
   Y_t &amp;= L_t \circ_s S_t, 
 
and 
 
.. math:: 
 
   \eta &amp;= \begin{cases} 
               Y_t\quad\text{if error is multiplicative}\\ 
               1\quad\text{else} 
           \end{cases}\\ 
   M_e &amp;= \begin{cases} 
               1\quad\text{if error is multiplicative}\\ 
               0\quad\text{else} 
           \end{cases}\\ 
 
and, when using the additive error model, 
 
.. math:: 
 
   \kappa_l &amp;= \begin{cases} 
               \frac{1}{S_t}\quad 
               \text{if seasonality is multiplicative}\\ 
               1\quad\text{else} 
           \end{cases}\\ 
   \kappa_b &amp;= \begin{cases} 
               \frac{\kappa_l}{l_{t-1}}\quad 
               \text{if trend is multiplicative}\\ 
               \kappa_l\quad\text{else} 
           \end{cases}\\ 
   \kappa_s &amp;= \begin{cases} 
               \frac{1}{L_t}\quad\text{if seasonality is multiplicative}\\ 
               1\quad\text{else} 
           \end{cases} 
 
When using the multiplicative error model 
 
.. math:: 
 
   \kappa_l &amp;= \begin{cases} 
               0\quad 
               \text{if seasonality is multiplicative}\\ 
               S_t\quad\text{else} 
           \end{cases}\\ 
   \kappa_b &amp;= \begin{cases} 
               \frac{\kappa_l}{l_{t-1}}\quad 
               \text{if trend is multiplicative}\\ 
               \kappa_l + l_{t-1}\quad\text{else} 
           \end{cases}\\ 
   \kappa_s &amp;= \begin{cases} 
               0\quad\text{if seasonality is multiplicative}\\ 
               L_t\quad\text{else} 
           \end{cases} 
 
When fitting an ETS model, the parameters :math:`\alpha, \beta`, \gamma, 
\phi` and the initial states `l_{-1}, b_{-1}, s_{-1}, \ldots, s_{-m}` are 
selected as maximizers of log likelihood. 
 
References 
---------- 
.. [1] Hyndman, R.J., &amp; Athanasopoulos, G. (2019) *Forecasting: 
   principles and practice*, 3rd edition, OTexts: Melbourne, 
   Australia. OTexts.com/fpp3. Accessed on April 19th 2020. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">datetime </span><span class="s2">as </span><span class="s1">dt</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">scipy.stats </span><span class="s2">import </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">rv_continuous</span><span class="s2">, </span><span class="s1">rv_discrete</span>
<span class="s2">from </span><span class="s1">scipy.stats.distributions </span><span class="s2">import </span><span class="s1">rv_frozen</span>

<span class="s2">from </span><span class="s1">statsmodels.base.covtype </span><span class="s2">import </span><span class="s1">descriptions</span>
<span class="s2">import </span><span class="s1">statsmodels.base.wrapper </span><span class="s2">as </span><span class="s1">wrap</span>
<span class="s2">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s2">import </span><span class="s1">forg</span>
<span class="s2">from </span><span class="s1">statsmodels.iolib.table </span><span class="s2">import </span><span class="s1">SimpleTable</span>
<span class="s2">from </span><span class="s1">statsmodels.iolib.tableformatting </span><span class="s2">import </span><span class="s1">fmt_params</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.decorators </span><span class="s2">import </span><span class="s1">cache_readonly</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.tools </span><span class="s2">import </span><span class="s1">Bunch</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.validation </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">array_like</span><span class="s2">,</span>
    <span class="s1">bool_like</span><span class="s2">,</span>
    <span class="s1">int_like</span><span class="s2">,</span>
    <span class="s1">string_like</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">statsmodels.tsa.base.tsa_model </span><span class="s2">as </span><span class="s1">tsbase</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.exponential_smoothing </span><span class="s2">import </span><span class="s1">base</span>
<span class="s2">import </span><span class="s1">statsmodels.tsa.exponential_smoothing._ets_smooth </span><span class="s2">as </span><span class="s1">smooth</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.exponential_smoothing.initialization </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_initialization_simple</span><span class="s2">,</span>
    <span class="s1">_initialization_heuristic</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.tsatools </span><span class="s2">import </span><span class="s1">freq_to_period</span>

<span class="s3"># Implementation details:</span>

<span class="s3"># * The smoothing equations are implemented only for models having all</span>
<span class="s3">#   components (trend, dampening, seasonality). When using other models, the</span>
<span class="s3">#   respective parameters (smoothing and initial parameters) are set to values</span>
<span class="s3">#   that lead to the reduced model (often zero).</span>
<span class="s3">#   The internal model is needed for smoothing (called from fit and loglike),</span>
<span class="s3">#   forecasts, and simulations.</span>
<span class="s3"># * Somewhat related to above: There are 2 sets of parameters: model/external</span>
<span class="s3">#   params, and internal params.</span>
<span class="s3">#   - model params are all parameters necessary for a model, and are for</span>
<span class="s3">#     example passed as argument to the likelihood function or as start_params</span>
<span class="s3">#     to fit</span>
<span class="s3">#   - internal params are what is used internally in the smoothing equations</span>
<span class="s3"># * Regarding fitting, bounds, fixing parameters, and internal parameters, the</span>
<span class="s3">#   overall workflow is the following:</span>
<span class="s3">#   - get start parameters in the form of external parameters (includes fixed</span>
<span class="s3">#     parameters)</span>
<span class="s3">#   - transform external parameters to internal parameters, bounding all that</span>
<span class="s3">#     are missing -&gt; now we have some missing parameters, but potentially also</span>
<span class="s3">#     some user-specified bounds</span>
<span class="s3">#   - set bounds for fixed parameters</span>
<span class="s3">#   - make sure that starting parameters are within bounds</span>
<span class="s3">#   - set up the constraint bounds and function</span>
<span class="s3"># * Since the traditional bounds are nonlinear for beta and gamma, if no bounds</span>
<span class="s3">#   are given, we internally use beta_star and gamma_star for fitting</span>
<span class="s3"># * When estimating initial level and initial seasonal values, one of them has</span>
<span class="s3">#   to be removed in order to have a well posed problem. I am solving this by</span>
<span class="s3">#   fixing the last initial seasonal value to 0 (for additive seasonality) or 1</span>
<span class="s3">#   (for multiplicative seasonality).</span>
<span class="s3">#   For the additive models, this means I have to subtract the last initial</span>
<span class="s3">#   seasonal value from all initial seasonal values and add it to the initial</span>
<span class="s3">#   level; for the multiplicative models I do the same with division and</span>
<span class="s3">#   multiplication</span>


<span class="s2">class </span><span class="s1">ETSModel(base.StateSpaceMLEModel):</span>
    <span class="s0">r&quot;&quot;&quot; 
    ETS models. 
 
    Parameters 
    ---------- 
    endog : array_like 
        The observed time-series process :math:`y` 
    error : str, optional 
        The error model. &quot;add&quot; (default) or &quot;mul&quot;. 
    trend : str or None, optional 
        The trend component model. &quot;add&quot;, &quot;mul&quot;, or None (default). 
    damped_trend : bool, optional 
        Whether or not an included trend component is damped. Default is 
        False. 
    seasonal : str, optional 
        The seasonality model. &quot;add&quot;, &quot;mul&quot;, or None (default). 
    seasonal_periods : int, optional 
        The number of periods in a complete seasonal cycle for seasonal 
        (Holt-Winters) models. For example, 4 for quarterly data with an 
        annual cycle or 7 for daily data with a weekly cycle. Required if 
        `seasonal` is not None. 
    initialization_method : str, optional 
        Method for initialization of the state space model. One of: 
 
        * 'estimated' (default) 
        * 'heuristic' 
        * 'known' 
 
        If 'known' initialization is used, then `initial_level` must be 
        passed, as well as `initial_trend` and `initial_seasonal` if 
        applicable. 
        'heuristic' uses a heuristic based on the data to estimate initial 
        level, trend, and seasonal state. 'estimated' uses the same heuristic 
        as initial guesses, but then estimates the initial states as part of 
        the fitting process.  Default is 'estimated'. 
    initial_level : float, optional 
        The initial level component. Only used if initialization is 'known'. 
    initial_trend : float, optional 
        The initial trend component. Only used if initialization is 'known'. 
    initial_seasonal : array_like, optional 
        The initial seasonal component. An array of length `seasonal_periods`. 
        Only used if initialization is 'known'. 
    bounds : dict or None, optional 
        A dictionary with parameter names as keys and the respective bounds 
        intervals as values (lists/tuples/arrays). 
        The available parameter names are, depending on the model and 
        initialization method: 
 
        * &quot;smoothing_level&quot; 
        * &quot;smoothing_trend&quot; 
        * &quot;smoothing_seasonal&quot; 
        * &quot;damping_trend&quot; 
        * &quot;initial_level&quot; 
        * &quot;initial_trend&quot; 
        * &quot;initial_seasonal.0&quot;, ..., &quot;initial_seasonal.&lt;m-1&gt;&quot; 
 
        The default option is ``None``, in which case the traditional 
        (nonlinear) bounds as described in [1]_ are used. 
 
    Notes 
    ----- 
    The ETS models are a family of time series models. They can be seen as a 
    generalization of simple exponential smoothing to time series that contain 
    trends and seasonalities. Additionally, they have an underlying state 
    space model. 
 
    An ETS model is specified by an error type (E; additive or multiplicative), 
    a trend type (T; additive or multiplicative, both damped or undamped, or 
    none), and a seasonality type (S; additive or multiplicative or none). 
    The following gives a very short summary, a more thorough introduction can 
    be found in [1]_. 
 
    Denote with :math:`\circ_b` the trend operation (addition or 
    multiplication), with :math:`\circ_d` the operation linking trend and 
    dampening factor :math:`\phi` (multiplication if trend is additive, power 
    if trend is multiplicative), and with :math:`\circ_s` the seasonality 
    operation (addition or multiplication). Furthermore, let :math:`\ominus` 
    be the respective inverse operation (subtraction or division). 
 
    With this, it is possible to formulate the ETS models as a forecast 
    equation and 3 smoothing equations. The former is used to forecast 
    observations, the latter are used to update the internal state. 
 
    .. math:: 
 
        \hat{y}_{t|t-1} &amp;= (l_{t-1} \circ_b (b_{t-1}\circ_d \phi)) 
                           \circ_s s_{t-m}\\ 
        l_{t} &amp;= \alpha (y_{t} \ominus_s s_{t-m}) 
                 + (1 - \alpha) (l_{t-1} \circ_b (b_{t-1} \circ_d \phi))\\ 
        b_{t} &amp;= \beta/\alpha (l_{t} \ominus_b l_{t-1}) 
                 + (1 - \beta/\alpha) b_{t-1}\\ 
        s_{t} &amp;= \gamma (y_t \ominus_s (l_{t-1} \circ_b (b_{t-1}\circ_d\phi)) 
                 + (1 - \gamma) s_{t-m} 
 
    The notation here follows [1]_; :math:`l_t` denotes the level at time 
    :math:`t`, `b_t` the trend, and `s_t` the seasonal component. :math:`m` 
    is the number of seasonal periods, and :math:`\phi` a trend damping 
    factor. The parameters :math:`\alpha, \beta, \gamma` are the smoothing 
    parameters, which are called ``smoothing_level``, ``smoothing_trend``, and 
    ``smoothing_seasonal``, respectively. 
 
    Note that the formulation above as forecast and smoothing equation does 
    not distinguish different error models -- it is the same for additive and 
    multiplicative errors. But the different error models lead to different 
    likelihood models, and therefore will lead to different fit results. 
 
    The error models specify how the true values :math:`y_t` are 
    updated. In the additive error model, 
 
    .. math:: 
 
        y_t = \hat{y}_{t|t-1} + e_t, 
 
    in the multiplicative error model, 
 
    .. math:: 
 
        y_t = \hat{y}_{t|t-1}\cdot (1 + e_t). 
 
    Using these error models, it is possible to formulate state space 
    equations for the ETS models: 
 
    .. math:: 
 
       y_t &amp;= Y_t + \eta \cdot e_t\\ 
       l_t &amp;= L_t + \alpha \cdot (M_e \cdot L_t + \kappa_l) \cdot e_t\\ 
       b_t &amp;= B_t + \beta \cdot (M_e \cdot B_t + \kappa_b) \cdot e_t\\ 
       s_t &amp;= S_t + \gamma \cdot (M_e \cdot S_t+\kappa_s)\cdot e_t\\ 
 
    with 
 
    .. math:: 
 
       B_t &amp;= b_{t-1} \circ_d \phi\\ 
       L_t &amp;= l_{t-1} \circ_b B_t\\ 
       S_t &amp;= s_{t-m}\\ 
       Y_t &amp;= L_t \circ_s S_t, 
 
    and 
 
    .. math:: 
 
       \eta &amp;= \begin{cases} 
                   Y_t\quad\text{if error is multiplicative}\\ 
                   1\quad\text{else} 
               \end{cases}\\ 
       M_e &amp;= \begin{cases} 
                   1\quad\text{if error is multiplicative}\\ 
                   0\quad\text{else} 
               \end{cases}\\ 
 
    and, when using the additive error model, 
 
    .. math:: 
 
       \kappa_l &amp;= \begin{cases} 
                   \frac{1}{S_t}\quad 
                   \text{if seasonality is multiplicative}\\ 
                   1\quad\text{else} 
               \end{cases}\\ 
       \kappa_b &amp;= \begin{cases} 
                   \frac{\kappa_l}{l_{t-1}}\quad 
                   \text{if trend is multiplicative}\\ 
                   \kappa_l\quad\text{else} 
               \end{cases}\\ 
       \kappa_s &amp;= \begin{cases} 
                   \frac{1}{L_t}\quad\text{if seasonality is multiplicative}\\ 
                   1\quad\text{else} 
               \end{cases} 
 
    When using the multiplicative error model 
 
    .. math:: 
 
       \kappa_l &amp;= \begin{cases} 
                   0\quad 
                   \text{if seasonality is multiplicative}\\ 
                   S_t\quad\text{else} 
               \end{cases}\\ 
       \kappa_b &amp;= \begin{cases} 
                   \frac{\kappa_l}{l_{t-1}}\quad 
                   \text{if trend is multiplicative}\\ 
                   \kappa_l + l_{t-1}\quad\text{else} 
               \end{cases}\\ 
       \kappa_s &amp;= \begin{cases} 
                   0\quad\text{if seasonality is multiplicative}\\ 
                   L_t\quad\text{else} 
               \end{cases} 
 
    When fitting an ETS model, the parameters :math:`\alpha, \beta`, \gamma, 
    \phi` and the initial states `l_{-1}, b_{-1}, s_{-1}, \ldots, s_{-m}` are 
    selected as maximizers of log likelihood. 
 
    References 
    ---------- 
    .. [1] Hyndman, R.J., &amp; Athanasopoulos, G. (2019) *Forecasting: 
       principles and practice*, 3rd edition, OTexts: Melbourne, 
       Australia. OTexts.com/fpp3. Accessed on April 19th 2020. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">error=</span><span class="s4">&quot;add&quot;</span><span class="s2">,</span>
        <span class="s1">trend=</span><span class="s2">None,</span>
        <span class="s1">damped_trend=</span><span class="s2">False,</span>
        <span class="s1">seasonal=</span><span class="s2">None,</span>
        <span class="s1">seasonal_periods=</span><span class="s2">None,</span>
        <span class="s1">initialization_method=</span><span class="s4">&quot;estimated&quot;</span><span class="s2">,</span>
        <span class="s1">initial_level=</span><span class="s2">None,</span>
        <span class="s1">initial_trend=</span><span class="s2">None,</span>
        <span class="s1">initial_seasonal=</span><span class="s2">None,</span>
        <span class="s1">bounds=</span><span class="s2">None,</span>
        <span class="s1">dates=</span><span class="s2">None,</span>
        <span class="s1">freq=</span><span class="s2">None,</span>
        <span class="s1">missing=</span><span class="s4">&quot;none&quot;</span><span class="s2">,</span>
    <span class="s1">):</span>

        <span class="s1">super().__init__(</span>
            <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=</span><span class="s2">None, </span><span class="s1">dates=dates</span><span class="s2">, </span><span class="s1">freq=freq</span><span class="s2">, </span><span class="s1">missing=missing</span>
        <span class="s1">)</span>

        <span class="s3"># MODEL DEFINITION</span>
        <span class="s3"># ================</span>
        <span class="s1">options = (</span><span class="s4">&quot;add&quot;</span><span class="s2">, </span><span class="s4">&quot;mul&quot;</span><span class="s2">, </span><span class="s4">&quot;additive&quot;</span><span class="s2">, </span><span class="s4">&quot;multiplicative&quot;</span><span class="s1">)</span>
        <span class="s3"># take first three letters of option -&gt; either &quot;add&quot; or &quot;mul&quot;</span>
        <span class="s1">self.error = string_like(error</span><span class="s2">, </span><span class="s4">&quot;error&quot;</span><span class="s2">, </span><span class="s1">options=options)[:</span><span class="s5">3</span><span class="s1">]</span>
        <span class="s1">self.trend = string_like(</span>
            <span class="s1">trend</span><span class="s2">, </span><span class="s4">&quot;trend&quot;</span><span class="s2">, </span><span class="s1">options=options</span><span class="s2">, </span><span class="s1">optional=</span><span class="s2">True</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.trend </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.trend = self.trend[:</span><span class="s5">3</span><span class="s1">]</span>
        <span class="s1">self.damped_trend = bool_like(damped_trend</span><span class="s2">, </span><span class="s4">&quot;damped_trend&quot;</span><span class="s1">)</span>
        <span class="s1">self.seasonal = string_like(</span>
            <span class="s1">seasonal</span><span class="s2">, </span><span class="s4">&quot;seasonal&quot;</span><span class="s2">, </span><span class="s1">options=options</span><span class="s2">, </span><span class="s1">optional=</span><span class="s2">True</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.seasonal </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.seasonal = self.seasonal[:</span><span class="s5">3</span><span class="s1">]</span>

        <span class="s1">self.has_trend = self.trend </span><span class="s2">is not None</span>
        <span class="s1">self.has_seasonal = self.seasonal </span><span class="s2">is not None</span>

        <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
            <span class="s1">self.seasonal_periods = int_like(</span>
                <span class="s1">seasonal_periods</span><span class="s2">, </span><span class="s4">&quot;seasonal_periods&quot;</span><span class="s2">, </span><span class="s1">optional=</span><span class="s2">True</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">seasonal_periods </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.seasonal_periods = freq_to_period(self._index_freq)</span>
            <span class="s2">if </span><span class="s1">self.seasonal_periods &lt;= </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;seasonal_periods must be larger than 1.&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># in case the model has no seasonal component, we internally handle</span>
            <span class="s3"># this as if it had an additive seasonal component with</span>
            <span class="s3"># seasonal_periods=1, but restrict the smoothing parameter to 0 and</span>
            <span class="s3"># set the initial seasonal to 0.</span>
            <span class="s1">self.seasonal_periods = </span><span class="s5">1</span>

        <span class="s3"># reject invalid models</span>
        <span class="s2">if </span><span class="s1">np.any(self.endog &lt;= </span><span class="s5">0</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">self.error == </span><span class="s4">&quot;mul&quot;</span>
            <span class="s2">or </span><span class="s1">self.trend == </span><span class="s4">&quot;mul&quot;</span>
            <span class="s2">or </span><span class="s1">self.seasonal == </span><span class="s4">&quot;mul&quot;</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;endog must be strictly positive when using &quot;</span>
                <span class="s4">&quot;multiplicative error, trend or seasonal components.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.damped_trend </span><span class="s2">and not </span><span class="s1">self.has_trend:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Can only dampen the trend component&quot;</span><span class="s1">)</span>

        <span class="s3"># INITIALIZATION METHOD</span>
        <span class="s3"># =====================</span>
        <span class="s1">self.set_initialization_method(</span>
            <span class="s1">initialization_method</span><span class="s2">,</span>
            <span class="s1">initial_level</span><span class="s2">,</span>
            <span class="s1">initial_trend</span><span class="s2">,</span>
            <span class="s1">initial_seasonal</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s3"># BOUNDS</span>
        <span class="s3"># ======</span>
        <span class="s1">self.set_bounds(bounds)</span>

        <span class="s3"># SMOOTHER</span>
        <span class="s3"># ========</span>
        <span class="s2">if </span><span class="s1">self.trend == </span><span class="s4">&quot;add&quot; </span><span class="s2">or </span><span class="s1">self.trend </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.seasonal == </span><span class="s4">&quot;add&quot; </span><span class="s2">or </span><span class="s1">self.seasonal </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._smoothing_func = smooth._ets_smooth_add_add</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._smoothing_func = smooth._ets_smooth_add_mul</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.seasonal == </span><span class="s4">&quot;add&quot; </span><span class="s2">or </span><span class="s1">self.seasonal </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._smoothing_func = smooth._ets_smooth_mul_add</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._smoothing_func = smooth._ets_smooth_mul_mul</span>

    <span class="s2">def </span><span class="s1">set_initialization_method(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">initialization_method</span><span class="s2">,</span>
        <span class="s1">initial_level=</span><span class="s2">None,</span>
        <span class="s1">initial_trend=</span><span class="s2">None,</span>
        <span class="s1">initial_seasonal=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sets a new initialization method for the state space model. 
 
        Parameters 
        ---------- 
        initialization_method : str, optional 
            Method for initialization of the state space model. One of: 
 
            * 'estimated' (default) 
            * 'heuristic' 
            * 'known' 
 
            If 'known' initialization is used, then `initial_level` must be 
            passed, as well as `initial_trend` and `initial_seasonal` if 
            applicable. 
            'heuristic' uses a heuristic based on the data to estimate initial 
            level, trend, and seasonal state. 'estimated' uses the same 
            heuristic as initial guesses, but then estimates the initial states 
            as part of the fitting process. Default is 'estimated'. 
        initial_level : float, optional 
            The initial level component. Only used if initialization is 
            'known'. 
        initial_trend : float, optional 
            The initial trend component. Only used if initialization is 
            'known'. 
        initial_seasonal : array_like, optional 
            The initial seasonal component. An array of length 
            `seasonal_periods`. Only used if initialization is 'known'. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.initialization_method = string_like(</span>
            <span class="s1">initialization_method</span><span class="s2">,</span>
            <span class="s4">&quot;initialization_method&quot;</span><span class="s2">,</span>
            <span class="s1">options=(</span><span class="s4">&quot;estimated&quot;</span><span class="s2">, </span><span class="s4">&quot;known&quot;</span><span class="s2">, </span><span class="s4">&quot;heuristic&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.initialization_method == </span><span class="s4">&quot;known&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">initial_level </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;`initial_level` argument must be provided&quot;</span>
                    <span class="s4">' when initialization method is set to &quot;known&quot;.'</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.has_trend </span><span class="s2">and </span><span class="s1">initial_trend </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;`initial_trend` argument must be provided&quot;</span>
                    <span class="s4">&quot; for models with a trend component when&quot;</span>
                    <span class="s4">' initialization method is set to &quot;known&quot;.'</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.has_seasonal </span><span class="s2">and </span><span class="s1">initial_seasonal </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;`initial_seasonal` argument must be provided&quot;</span>
                    <span class="s4">&quot; for models with a seasonal component when&quot;</span>
                    <span class="s4">' initialization method is set to &quot;known&quot;.'</span>
                <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.initialization_method == </span><span class="s4">&quot;heuristic&quot;</span><span class="s1">:</span>
            <span class="s1">(</span>
                <span class="s1">initial_level</span><span class="s2">,</span>
                <span class="s1">initial_trend</span><span class="s2">,</span>
                <span class="s1">initial_seasonal</span><span class="s2">,</span>
            <span class="s1">) = _initialization_heuristic(</span>
                <span class="s1">self.endog</span><span class="s2">,</span>
                <span class="s1">trend=self.trend</span><span class="s2">,</span>
                <span class="s1">seasonal=self.seasonal</span><span class="s2">,</span>
                <span class="s1">seasonal_periods=self.seasonal_periods</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.initialization_method == </span><span class="s4">&quot;estimated&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.nobs &lt; </span><span class="s5">10 </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">* (self.seasonal_periods // </span><span class="s5">2</span><span class="s1">):</span>
                <span class="s1">(</span>
                    <span class="s1">initial_level</span><span class="s2">,</span>
                    <span class="s1">initial_trend</span><span class="s2">,</span>
                    <span class="s1">initial_seasonal</span><span class="s2">,</span>
                <span class="s1">) = _initialization_simple(</span>
                    <span class="s1">self.endog</span><span class="s2">,</span>
                    <span class="s1">trend=self.trend</span><span class="s2">,</span>
                    <span class="s1">seasonal=self.seasonal</span><span class="s2">,</span>
                    <span class="s1">seasonal_periods=self.seasonal_periods</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">(</span>
                    <span class="s1">initial_level</span><span class="s2">,</span>
                    <span class="s1">initial_trend</span><span class="s2">,</span>
                    <span class="s1">initial_seasonal</span><span class="s2">,</span>
                <span class="s1">) = _initialization_heuristic(</span>
                    <span class="s1">self.endog</span><span class="s2">,</span>
                    <span class="s1">trend=self.trend</span><span class="s2">,</span>
                    <span class="s1">seasonal=self.seasonal</span><span class="s2">,</span>
                    <span class="s1">seasonal_periods=self.seasonal_periods</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">self.has_trend:</span>
            <span class="s1">initial_trend = </span><span class="s5">0</span>
        <span class="s2">if not </span><span class="s1">self.has_seasonal:</span>
            <span class="s1">initial_seasonal = </span><span class="s5">0</span>
        <span class="s1">self.initial_level = initial_level</span>
        <span class="s1">self.initial_trend = initial_trend</span>
        <span class="s1">self.initial_seasonal = initial_seasonal</span>

        <span class="s3"># we also have to reset the params index dictionaries</span>
        <span class="s1">self._internal_params_index = OrderedDict(</span>
            <span class="s1">zip(self._internal_param_names</span><span class="s2">, </span><span class="s1">np.arange(self._k_params_internal))</span>
        <span class="s1">)</span>
        <span class="s1">self._params_index = OrderedDict(</span>
            <span class="s1">zip(self.param_names</span><span class="s2">, </span><span class="s1">np.arange(self.k_params))</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_bounds(self</span><span class="s2">, </span><span class="s1">bounds):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set bounds for parameter estimation. 
 
        Parameters 
        ---------- 
        bounds : dict or None, optional 
            A dictionary with parameter names as keys and the respective bounds 
            intervals as values (lists/tuples/arrays). 
            The available parameter names are in ``self.param_names``. 
            The default option is ``None``, in which case the traditional 
            (nonlinear) bounds as described in [1]_ are used. 
 
        References 
        ---------- 
        .. [1] Hyndman, R.J., &amp; Athanasopoulos, G. (2019) *Forecasting: 
           principles and practice*, 3rd edition, OTexts: Melbourne, 
           Australia. OTexts.com/fpp3. Accessed on April 19th 2020. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">bounds </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.bounds = {}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(bounds</span><span class="s2">, </span><span class="s1">(dict</span><span class="s2">, </span><span class="s1">OrderedDict)):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;bounds must be a dictionary&quot;</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">bounds:</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">self.param_names:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">f&quot;Invalid key: </span><span class="s2">{</span><span class="s1">key</span><span class="s2">} </span><span class="s4">in bounds dictionary&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">bounds[key] = array_like(</span>
                    <span class="s1">bounds[key]</span><span class="s2">, </span><span class="s4">f&quot;bounds[</span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s4">]&quot;</span><span class="s2">, </span><span class="s1">shape=(</span><span class="s5">2</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">self.bounds = bounds</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">prepare_data(data):</span>
        <span class="s0">&quot;&quot;&quot; 
        Prepare data for use in the state space representation 
        &quot;&quot;&quot;</span>
        <span class="s1">endog = np.array(data.orig_endog</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">endog.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;endog must be 1-dimensional&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">endog.dtype != np.double:</span>
            <span class="s1">endog = np.asarray(data.orig_endog</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s2">return </span><span class="s1">endog</span><span class="s2">, None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nobs_effective(self):</span>
        <span class="s2">return </span><span class="s1">self.nobs</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">k_endog(self):</span>
        <span class="s2">return </span><span class="s5">1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">short_name(self):</span>
        <span class="s1">name = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s1">str(s)[</span><span class="s5">0</span><span class="s1">].upper()</span>
                <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">[self.error</span><span class="s2">, </span><span class="s1">self.trend</span><span class="s2">, </span><span class="s1">self.seasonal]</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.damped_trend:</span>
            <span class="s1">name = name[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">] + </span><span class="s4">&quot;d&quot; </span><span class="s1">+ name[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_param_names(self):</span>
        <span class="s1">param_names = [</span><span class="s4">&quot;smoothing_level&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.has_trend:</span>
            <span class="s1">param_names += [</span><span class="s4">&quot;smoothing_trend&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
            <span class="s1">param_names += [</span><span class="s4">&quot;smoothing_seasonal&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.damped_trend:</span>
            <span class="s1">param_names += [</span><span class="s4">&quot;damping_trend&quot;</span><span class="s1">]</span>

        <span class="s3"># Initialization</span>
        <span class="s2">if </span><span class="s1">self.initialization_method == </span><span class="s4">&quot;estimated&quot;</span><span class="s1">:</span>
            <span class="s1">param_names += [</span><span class="s4">&quot;initial_level&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">self.has_trend:</span>
                <span class="s1">param_names += [</span><span class="s4">&quot;initial_trend&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
                <span class="s1">param_names += [</span>
                    <span class="s4">f&quot;initial_seasonal.</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot;</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.seasonal_periods)</span>
                <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">param_names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">state_names(self):</span>
        <span class="s1">names = [</span><span class="s4">&quot;level&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.has_trend:</span>
            <span class="s1">names += [</span><span class="s4">&quot;trend&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
            <span class="s1">names += [</span><span class="s4">&quot;seasonal&quot;</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">initial_state_names(self):</span>
        <span class="s1">names = [</span><span class="s4">&quot;initial_level&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.has_trend:</span>
            <span class="s1">names += [</span><span class="s4">&quot;initial_trend&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
            <span class="s1">names += [</span>
                <span class="s4">f&quot;initial_seasonal.</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.seasonal_periods)</span>
            <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_smoothing_param_names(self):</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s4">&quot;smoothing_level&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;smoothing_trend&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;smoothing_seasonal&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;damping_trend&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_internal_initial_state_names(self):</span>
        <span class="s1">param_names = [</span>
            <span class="s4">&quot;initial_level&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;initial_trend&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">param_names += [</span>
            <span class="s4">f&quot;initial_seasonal.</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.seasonal_periods)</span>
        <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">param_names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_internal_param_names(self):</span>
        <span class="s2">return </span><span class="s1">self._smoothing_param_names + self._internal_initial_state_names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_k_states(self):</span>
        <span class="s2">return </span><span class="s5">1 </span><span class="s1">+ int(self.has_trend) + int(self.has_seasonal)  </span><span class="s3"># level</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_k_states_internal(self):</span>
        <span class="s2">return </span><span class="s5">2 </span><span class="s1">+ self.seasonal_periods</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_k_smoothing_params(self):</span>
        <span class="s2">return </span><span class="s1">self._k_states + int(self.damped_trend)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_k_initial_states(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s5">1</span>
            <span class="s1">+ int(self.has_trend)</span>
            <span class="s1">+ +int(self.has_seasonal) * self.seasonal_periods</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">k_params(self):</span>
        <span class="s1">k = self._k_smoothing_params</span>
        <span class="s2">if </span><span class="s1">self.initialization_method == </span><span class="s4">&quot;estimated&quot;</span><span class="s1">:</span>
            <span class="s1">k += self._k_initial_states</span>
        <span class="s2">return </span><span class="s1">k</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_k_params_internal(self):</span>
        <span class="s2">return </span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">+ self.seasonal_periods</span>

    <span class="s2">def </span><span class="s1">_internal_params(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s0">&quot;&quot;&quot; 
        Converts a parameter array passed from outside to the internally used 
        full parameter array. 
        &quot;&quot;&quot;</span>
        <span class="s3"># internal params that are not needed are all set to zero, except phi,</span>
        <span class="s3"># which is one</span>
        <span class="s1">internal = np.zeros(self._k_params_internal</span><span class="s2">, </span><span class="s1">dtype=params.dtype)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(self.param_names):</span>
            <span class="s1">internal_idx = self._internal_params_index[name]</span>
            <span class="s1">internal[internal_idx] = params[i]</span>
        <span class="s2">if not </span><span class="s1">self.damped_trend:</span>
            <span class="s1">internal[</span><span class="s5">3</span><span class="s1">] = </span><span class="s5">1  </span><span class="s3"># phi is 4th parameter</span>
        <span class="s2">if </span><span class="s1">self.initialization_method != </span><span class="s4">&quot;estimated&quot;</span><span class="s1">:</span>
            <span class="s1">internal[</span><span class="s5">4</span><span class="s1">] = self.initial_level</span>
            <span class="s1">internal[</span><span class="s5">5</span><span class="s1">] = self.initial_trend</span>
            <span class="s2">if </span><span class="s1">np.isscalar(self.initial_seasonal):</span>
                <span class="s1">internal[</span><span class="s5">6</span><span class="s1">:] = self.initial_seasonal</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># See GH 7893</span>
                <span class="s1">internal[</span><span class="s5">6</span><span class="s1">:] = self.initial_seasonal[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">internal</span>

    <span class="s2">def </span><span class="s1">_model_params(self</span><span class="s2">, </span><span class="s1">internal):</span>
        <span class="s0">&quot;&quot;&quot; 
        Converts internal parameters to model parameters 
        &quot;&quot;&quot;</span>
        <span class="s1">params = np.empty(self.k_params)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(self.param_names):</span>
            <span class="s1">internal_idx = self._internal_params_index[name]</span>
            <span class="s1">params[i] = internal[internal_idx]</span>
        <span class="s2">return </span><span class="s1">params</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_seasonal_index(self):</span>
        <span class="s2">return </span><span class="s5">1 </span><span class="s1">+ int(self.has_trend)</span>

    <span class="s2">def </span><span class="s1">_get_states(self</span><span class="s2">, </span><span class="s1">xhat):</span>
        <span class="s1">states = np.empty((self.nobs</span><span class="s2">, </span><span class="s1">self._k_states))</span>
        <span class="s1">all_names = [</span><span class="s4">&quot;level&quot;</span><span class="s2">, </span><span class="s4">&quot;trend&quot;</span><span class="s2">, </span><span class="s4">&quot;seasonal&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(self.state_names):</span>
            <span class="s1">idx = all_names.index(name)</span>
            <span class="s1">states[:</span><span class="s2">, </span><span class="s1">i] = xhat[:</span><span class="s2">, </span><span class="s1">idx]</span>
        <span class="s2">return </span><span class="s1">states</span>

    <span class="s2">def </span><span class="s1">_get_internal_states(self</span><span class="s2">, </span><span class="s1">states</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s0">&quot;&quot;&quot; 
        Converts a state matrix/dataframe to the (nobs, 2+m) matrix used 
        internally 
        &quot;&quot;&quot;</span>
        <span class="s1">internal_params = self._internal_params(params)</span>
        <span class="s2">if </span><span class="s1">isinstance(states</span><span class="s2">, </span><span class="s1">(pd.Series</span><span class="s2">, </span><span class="s1">pd.DataFrame)):</span>
            <span class="s1">states = states.values</span>
        <span class="s1">internal_states = np.zeros((self.nobs</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ self.seasonal_periods))</span>
        <span class="s1">internal_states[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = states[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.has_trend:</span>
            <span class="s1">internal_states[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = states[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(self.seasonal_periods):</span>
                <span class="s1">internal_states[j:</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ j] = states[</span>
                    <span class="s5">0 </span><span class="s1">: self.nobs - j</span><span class="s2">, </span><span class="s1">self._seasonal_index</span>
                <span class="s1">]</span>
                <span class="s1">internal_states[</span><span class="s5">0</span><span class="s1">:j</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ j] = internal_params[</span><span class="s5">6 </span><span class="s1">: </span><span class="s5">6 </span><span class="s1">+ j][::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">internal_states</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_default_start_params(self):</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s4">&quot;smoothing_level&quot;</span><span class="s1">: </span><span class="s5">0.1</span><span class="s2">,</span>
            <span class="s4">&quot;smoothing_trend&quot;</span><span class="s1">: </span><span class="s5">0.01</span><span class="s2">,</span>
            <span class="s4">&quot;smoothing_seasonal&quot;</span><span class="s1">: </span><span class="s5">0.01</span><span class="s2">,</span>
            <span class="s4">&quot;damping_trend&quot;</span><span class="s1">: </span><span class="s5">0.98</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_start_params(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Default start params in the format of external parameters. 
        This should not be called directly, but by calling 
        ``self.start_params``. 
        &quot;&quot;&quot;</span>
        <span class="s1">params = []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self._smoothing_param_names:</span>
            <span class="s2">if </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.param_names:</span>
                <span class="s1">params.append(self._default_start_params[p])</span>

        <span class="s2">if </span><span class="s1">self.initialization_method == </span><span class="s4">&quot;estimated&quot;</span><span class="s1">:</span>
            <span class="s1">lvl_idx = len(params)</span>
            <span class="s1">params += [self.initial_level]</span>
            <span class="s2">if </span><span class="s1">self.has_trend:</span>
                <span class="s1">params += [self.initial_trend]</span>
            <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
                <span class="s3"># we have to adapt the seasonal values a bit to make sure the</span>
                <span class="s3"># problem is well posed (see implementation notes above)</span>
                <span class="s1">initial_seasonal = self.initial_seasonal</span>
                <span class="s2">if </span><span class="s1">self.seasonal == </span><span class="s4">&quot;mul&quot;</span><span class="s1">:</span>
                    <span class="s1">params[lvl_idx] *= initial_seasonal[-</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">initial_seasonal /= initial_seasonal[-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">params[lvl_idx] += initial_seasonal[-</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">initial_seasonal -= initial_seasonal[-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">params += initial_seasonal.tolist()</span>

        <span class="s2">return </span><span class="s1">np.array(params)</span>

    <span class="s2">def </span><span class="s1">_convert_and_bound_start_params(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s0">&quot;&quot;&quot; 
        This converts start params to internal params, sets internal-only 
        parameters as bounded, sets bounds for fixed parameters, and then makes 
        sure that all start parameters are within the specified bounds. 
        &quot;&quot;&quot;</span>
        <span class="s1">internal_params = self._internal_params(params)</span>
        <span class="s3"># set bounds for missing and fixed</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self._internal_param_names:</span>
            <span class="s1">idx = self._internal_params_index[p]</span>
            <span class="s2">if </span><span class="s1">p </span><span class="s2">not in </span><span class="s1">self.param_names:</span>
                <span class="s3"># any missing parameters are set to the value they got from the</span>
                <span class="s3"># call to _internal_params</span>
                <span class="s1">self.bounds[p] = [internal_params[idx]] * </span><span class="s5">2</span>
            <span class="s2">elif </span><span class="s1">self._has_fixed_params </span><span class="s2">and </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self._fixed_params:</span>
                <span class="s1">self.bounds[p] = [self._fixed_params[p]] * </span><span class="s5">2</span>
            <span class="s3"># make sure everything is within bounds</span>
            <span class="s2">if </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.bounds:</span>
                <span class="s1">internal_params[idx] = np.clip(</span>
                    <span class="s1">internal_params[idx]</span>
                    <span class="s1">+ </span><span class="s5">1e-3</span><span class="s2">,  </span><span class="s3"># try not to start on boundary</span>
                    <span class="s1">*self.bounds[p]</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">internal_params</span>

    <span class="s2">def </span><span class="s1">_setup_bounds(self):</span>
        <span class="s3"># By default, we are using the traditional constraints for the</span>
        <span class="s3"># smoothing parameters if nothing else is specified</span>
        <span class="s3">#</span>
        <span class="s3">#    0 &lt;     alpha     &lt; 1</span>
        <span class="s3">#    0 &lt;   beta/alpha  &lt; 1</span>
        <span class="s3">#    0 &lt; gamma + alpha &lt; 1</span>
        <span class="s3">#  0.8 &lt;      phi      &lt; 0.98</span>
        <span class="s3">#</span>
        <span class="s3"># For initial states, no bounds are the default setting.</span>
        <span class="s3">#</span>
        <span class="s3"># Since the bounds for beta and gamma are not in the simple form of a</span>
        <span class="s3"># constant interval, we will use the parameters beta_star=beta/alpha</span>
        <span class="s3"># and gamma_star=gamma+alpha during fitting.</span>

        <span class="s1">lb = np.zeros(self._k_params_internal) + </span><span class="s5">1e-4</span>
        <span class="s1">ub = np.ones(self._k_params_internal) - </span><span class="s5">1e-4</span>

        <span class="s3"># other bounds for phi and initial states</span>
        <span class="s1">lb[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ub[</span><span class="s5">3</span><span class="s1">] = </span><span class="s5">0.8</span><span class="s2">, </span><span class="s5">0.98</span>
        <span class="s2">if </span><span class="s1">self.initialization_method == </span><span class="s4">&quot;estimated&quot;</span><span class="s1">:</span>
            <span class="s1">lb[</span><span class="s5">4</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">] = -np.inf</span>
            <span class="s1">ub[</span><span class="s5">4</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">] = np.inf</span>
            <span class="s3"># fix the last initial_seasonal to 0 or 1, otherwise the equation</span>
            <span class="s3"># is underdetermined</span>
            <span class="s2">if </span><span class="s1">self.seasonal == </span><span class="s4">&quot;mul&quot;</span><span class="s1">:</span>
                <span class="s1">lb[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ub[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lb[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ub[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span>

        <span class="s3"># set lb and ub for parameters with bounds</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self._internal_param_names:</span>
            <span class="s1">idx = self._internal_params_index[p]</span>
            <span class="s2">if </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.bounds:</span>
                <span class="s1">lb[idx]</span><span class="s2">, </span><span class="s1">ub[idx] = self.bounds[p]</span>

        <span class="s2">return </span><span class="s1">[(lb[i]</span><span class="s2">, </span><span class="s1">ub[i]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._k_params_internal)]</span>

    <span class="s2">def </span><span class="s1">fit(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">start_params=</span><span class="s2">None,</span>
        <span class="s1">maxiter=</span><span class="s5">1000</span><span class="s2">,</span>
        <span class="s1">full_output=</span><span class="s2">True,</span>
        <span class="s1">disp=</span><span class="s2">True,</span>
        <span class="s1">callback=</span><span class="s2">None,</span>
        <span class="s1">return_params=</span><span class="s2">False,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Fit an ETS model by maximizing log-likelihood. 
 
        Log-likelihood is a function of the model parameters :math:`\alpha, 
        \beta, \gamma, \phi` (depending on the chosen model), and, if 
        `initialization_method` was set to `'estimated'` in the constructor, 
        also the initial states :math:`l_{-1}, b_{-1}, s_{-1}, \ldots, s_{-m}`. 
 
        The fit is performed using the L-BFGS algorithm. 
 
        Parameters 
        ---------- 
        start_params : array_like, optional 
            Initial values for parameters that will be optimized. If this is 
            ``None``, default values will be used. 
            The length of this depends on the chosen model. This should contain 
            the parameters in the following order, skipping parameters that do 
            not exist in the chosen model. 
 
            * `smoothing_level` (:math:`\alpha`) 
            * `smoothing_trend` (:math:`\beta`) 
            * `smoothing_seasonal` (:math:`\gamma`) 
            * `damping_trend` (:math:`\phi`) 
 
            If ``initialization_method`` was set to ``'estimated'`` (the 
            default), additionally, the parameters 
 
            * `initial_level` (:math:`l_{-1}`) 
            * `initial_trend` (:math:`l_{-1}`) 
            * `initial_seasonal.0` (:math:`s_{-1}`) 
            * ... 
            * `initial_seasonal.&lt;m-1&gt;` (:math:`s_{-m}`) 
 
            also have to be specified. 
        maxiter : int, optional 
            The maximum number of iterations to perform. 
        full_output : bool, optional 
            Set to True to have all available output in the Results object's 
            mle_retvals attribute. The output is dependent on the solver. 
            See LikelihoodModelResults notes section for more information. 
        disp : bool, optional 
            Set to True to print convergence messages. 
        callback : callable callback(xk), optional 
            Called after each iteration, as callback(xk), where xk is the 
            current parameter vector. 
        return_params : bool, optional 
            Whether or not to return only the array of maximizing parameters. 
            Default is False. 
        **kwargs 
            Additional keyword arguments to pass to the optimizer. 
 
        Returns 
        ------- 
        results : ETSResults 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">start_params </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">start_params = self.start_params</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">start_params = np.asarray(start_params)</span>

        <span class="s2">if </span><span class="s1">self._has_fixed_params </span><span class="s2">and </span><span class="s1">len(self._free_params_index) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">final_params = np.asarray(list(self._fixed_params.values()))</span>
            <span class="s1">mlefit = Bunch(</span>
                <span class="s1">params=start_params</span><span class="s2">, </span><span class="s1">mle_retvals=</span><span class="s2">None, </span><span class="s1">mle_settings=</span><span class="s2">None</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">internal_start_params = self._convert_and_bound_start_params(</span>
                <span class="s1">start_params</span>
            <span class="s1">)</span>
            <span class="s1">bounds = self._setup_bounds()</span>

            <span class="s3"># check if we need to use the starred parameters</span>
            <span class="s1">use_beta_star = </span><span class="s4">&quot;smoothing_trend&quot; </span><span class="s2">not in </span><span class="s1">self.bounds</span>
            <span class="s2">if </span><span class="s1">use_beta_star:</span>
                <span class="s1">internal_start_params[</span><span class="s5">1</span><span class="s1">] /= internal_start_params[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">use_gamma_star = </span><span class="s4">&quot;smoothing_seasonal&quot; </span><span class="s2">not in </span><span class="s1">self.bounds</span>
            <span class="s2">if </span><span class="s1">use_gamma_star:</span>
                <span class="s1">internal_start_params[</span><span class="s5">2</span><span class="s1">] /= </span><span class="s5">1 </span><span class="s1">- internal_start_params[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s3"># check if we have fixed parameters and remove them from the</span>
            <span class="s3"># parameter vector</span>
            <span class="s1">is_fixed = np.zeros(self._k_params_internal</span><span class="s2">, </span><span class="s1">dtype=int)</span>
            <span class="s1">fixed_values = np.empty_like(internal_start_params)</span>
            <span class="s1">params_without_fixed = []</span>
            <span class="s1">kwargs[</span><span class="s4">&quot;bounds&quot;</span><span class="s1">] = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._k_params_internal):</span>
                <span class="s2">if </span><span class="s1">bounds[i][</span><span class="s5">0</span><span class="s1">] == bounds[i][</span><span class="s5">1</span><span class="s1">]:</span>
                    <span class="s1">is_fixed[i] = </span><span class="s2">True</span>
                    <span class="s1">fixed_values[i] = bounds[i][</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">params_without_fixed.append(internal_start_params[i])</span>
                    <span class="s1">kwargs[</span><span class="s4">&quot;bounds&quot;</span><span class="s1">].append(bounds[i])</span>
            <span class="s1">params_without_fixed = np.asarray(params_without_fixed)</span>

            <span class="s3"># pre-allocate memory for smoothing results</span>
            <span class="s1">yhat = np.zeros(self.nobs)</span>
            <span class="s1">xhat = np.zeros((self.nobs</span><span class="s2">, </span><span class="s1">self._k_states_internal))</span>

            <span class="s1">kwargs[</span><span class="s4">&quot;approx_grad&quot;</span><span class="s1">] = </span><span class="s2">True</span>
            <span class="s2">with </span><span class="s1">self.use_internal_loglike():</span>
                <span class="s1">mlefit = super().fit(</span>
                    <span class="s1">params_without_fixed</span><span class="s2">,</span>
                    <span class="s1">fargs=(</span>
                        <span class="s1">yhat</span><span class="s2">,</span>
                        <span class="s1">xhat</span><span class="s2">,</span>
                        <span class="s1">is_fixed</span><span class="s2">,</span>
                        <span class="s1">fixed_values</span><span class="s2">,</span>
                        <span class="s1">use_beta_star</span><span class="s2">,</span>
                        <span class="s1">use_gamma_star</span><span class="s2">,</span>
                    <span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">method=</span><span class="s4">&quot;lbfgs&quot;</span><span class="s2">,</span>
                    <span class="s1">maxiter=maxiter</span><span class="s2">,</span>
                    <span class="s1">full_output=full_output</span><span class="s2">,</span>
                    <span class="s1">disp=disp</span><span class="s2">,</span>
                    <span class="s1">callback=callback</span><span class="s2">,</span>
                    <span class="s1">skip_hessian=</span><span class="s2">True,</span>
                    <span class="s1">**kwargs</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s3"># convert params back</span>
            <span class="s3"># first, insert fixed params</span>
            <span class="s1">fitted_params = np.empty_like(internal_start_params)</span>
            <span class="s1">idx_without_fixed = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._k_params_internal):</span>
                <span class="s2">if </span><span class="s1">is_fixed[i]:</span>
                    <span class="s1">fitted_params[i] = fixed_values[i]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fitted_params[i] = mlefit.params[idx_without_fixed]</span>
                    <span class="s1">idx_without_fixed += </span><span class="s5">1</span>

            <span class="s2">if </span><span class="s1">use_beta_star:</span>
                <span class="s1">fitted_params[</span><span class="s5">1</span><span class="s1">] *= fitted_params[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">use_gamma_star:</span>
                <span class="s1">fitted_params[</span><span class="s5">2</span><span class="s1">] *= </span><span class="s5">1 </span><span class="s1">- fitted_params[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">final_params = self._model_params(fitted_params)</span>

        <span class="s2">if </span><span class="s1">return_params:</span>
            <span class="s2">return </span><span class="s1">final_params</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = self.smooth(final_params)</span>
            <span class="s1">result.mlefit = mlefit</span>
            <span class="s1">result.mle_retvals = mlefit.mle_retvals</span>
            <span class="s1">result.mle_settings = mlefit.mle_settings</span>
            <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_loglike_internal(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">params</span><span class="s2">,</span>
        <span class="s1">yhat</span><span class="s2">,</span>
        <span class="s1">xhat</span><span class="s2">,</span>
        <span class="s1">is_fixed=</span><span class="s2">None,</span>
        <span class="s1">fixed_values=</span><span class="s2">None,</span>
        <span class="s1">use_beta_star=</span><span class="s2">False,</span>
        <span class="s1">use_gamma_star=</span><span class="s2">False,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Log-likelihood function to be called from fit to avoid reallocation of 
        memory. 
 
        Parameters 
        ---------- 
        params : np.ndarray of np.float 
            Model parameters: (alpha, beta, gamma, phi, l[-1], 
            b[-1], s[-1], ..., s[-m]). If there are no fixed values this must 
            be in the format of internal parameters. Otherwise the fixed values 
            are skipped. 
        yhat : np.ndarray 
            Array of size (n,) where fitted values will be written to. 
        xhat : np.ndarray 
            Array of size (n, _k_states_internal) where fitted states will be 
            written to. 
        is_fixed : np.ndarray or None 
            Boolean array indicating values which are fixed during fitting. 
            This must have the full length of internal parameters. 
        fixed_values : np.ndarray or None 
            Array of fixed values (arbitrary values for non-fixed parameters) 
            This must have the full length of internal parameters. 
        use_beta_star : boolean 
            Whether to internally use beta_star as parameter 
        use_gamma_star : boolean 
            Whether to internally use gamma_star as parameter 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">np.iscomplexobj(params):</span>
            <span class="s1">data = np.asarray(self.endog</span><span class="s2">, </span><span class="s1">dtype=complex)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data = self.endog</span>

        <span class="s2">if </span><span class="s1">is_fixed </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">is_fixed = np.zeros(self._k_params_internal</span><span class="s2">, </span><span class="s1">dtype=int)</span>
            <span class="s1">fixed_values = np.empty(</span>
                <span class="s1">self._k_params_internal</span><span class="s2">, </span><span class="s1">dtype=params.dtype</span>
            <span class="s1">)</span>

        <span class="s1">self._smoothing_func(</span>
            <span class="s1">params</span><span class="s2">,</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">yhat</span><span class="s2">,</span>
            <span class="s1">xhat</span><span class="s2">,</span>
            <span class="s1">is_fixed</span><span class="s2">,</span>
            <span class="s1">fixed_values</span><span class="s2">,</span>
            <span class="s1">use_beta_star</span><span class="s2">,</span>
            <span class="s1">use_gamma_star</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">res = self._residuals(yhat</span><span class="s2">, </span><span class="s1">data=data)</span>
        <span class="s1">logL = -self.nobs / </span><span class="s5">2 </span><span class="s1">* (np.log(</span><span class="s5">2 </span><span class="s1">* np.pi * np.mean(res ** </span><span class="s5">2</span><span class="s1">)) + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.error == </span><span class="s4">&quot;mul&quot;</span><span class="s1">:</span>
            <span class="s3"># GH-7331: in some cases, yhat can become negative, so that a</span>
            <span class="s3"># multiplicative model is no longer well-defined. To avoid these</span>
            <span class="s3"># parameterizations, we clip negative values to very small positive</span>
            <span class="s3"># values so that the log-transformation yields very large negative</span>
            <span class="s3"># values.</span>
            <span class="s1">yhat[yhat &lt;= </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1 </span><span class="s1">/ (</span><span class="s5">1e-8 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">+ np.abs(yhat[yhat &lt;= </span><span class="s5">0</span><span class="s1">])))</span>
            <span class="s1">logL -= np.sum(np.log(yhat))</span>
        <span class="s2">return </span><span class="s1">logL</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">use_internal_loglike(self):</span>
        <span class="s1">external_loglike = self.loglike</span>
        <span class="s1">self.loglike = self._loglike_internal</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.loglike = external_loglike</span>

    <span class="s2">def </span><span class="s1">loglike(self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Log-likelihood of model. 
 
        Parameters 
        ---------- 
        params : np.ndarray of np.float 
            Model parameters: (alpha, beta, gamma, phi, l[-1], 
            b[-1], s[-1], ..., s[-m]) 
 
        Notes 
        ----- 
        The log-likelihood of a exponential smoothing model is [1]_: 
 
        .. math:: 
 
           l(\theta, x_0|y) = - \frac{n}{2}(\log(2\pi s^2) + 1) 
                              - \sum\limits_{t=1}^n \log(k_t) 
 
        with 
 
        .. math:: 
 
           s^2 = \frac{1}{n}\sum\limits_{t=1}^n \frac{(\hat{y}_t - y_t)^2}{k_t} 
 
        where :math:`k_t = 1` for the additive error model and :math:`k_t = 
        y_t` for the multiplicative error model. 
 
        References 
        ---------- 
        .. [1] J. K. Ord, A. B. Koehler R. D. and Snyder (1997). Estimation and 
           Prediction for a Class of Dynamic Nonlinear Statistical Models. 
           *Journal of the American Statistical Association*, 92(440), 
           1621-1629 
        &quot;&quot;&quot;</span>
        <span class="s1">params = self._internal_params(np.asarray(params))</span>
        <span class="s1">yhat = np.zeros(self.nobs</span><span class="s2">, </span><span class="s1">dtype=params.dtype)</span>
        <span class="s1">xhat = np.zeros(</span>
            <span class="s1">(self.nobs</span><span class="s2">, </span><span class="s1">self._k_states_internal)</span><span class="s2">, </span><span class="s1">dtype=params.dtype</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._loglike_internal(np.asarray(params)</span><span class="s2">, </span><span class="s1">yhat</span><span class="s2">, </span><span class="s1">xhat)</span>

    <span class="s2">def </span><span class="s1">_residuals(self</span><span class="s2">, </span><span class="s1">yhat</span><span class="s2">, </span><span class="s1">data=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Calculates residuals of a prediction&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">data </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">data = self.endog</span>
        <span class="s2">if </span><span class="s1">self.error == </span><span class="s4">&quot;mul&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(data - yhat) / yhat</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">data - yhat</span>

    <span class="s2">def </span><span class="s1">_smooth(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s0">&quot;&quot;&quot; 
        Exponential smoothing with given parameters 
 
        Parameters 
        ---------- 
        params : array_like 
            Model parameters 
 
        Returns 
        ------- 
        yhat : pd.Series or np.ndarray 
            Predicted values from exponential smoothing. If original data was a 
            ``pd.Series``, returns a ``pd.Series``, else a ``np.ndarray``. 
        xhat : pd.DataFrame or np.ndarray 
            Internal states of exponential smoothing. If original data was a 
            ``pd.Series``, returns a ``pd.DataFrame``, else a ``np.ndarray``. 
        &quot;&quot;&quot;</span>
        <span class="s1">internal_params = self._internal_params(params)</span>
        <span class="s1">yhat = np.zeros(self.nobs)</span>
        <span class="s1">xhat = np.zeros((self.nobs</span><span class="s2">, </span><span class="s1">self._k_states_internal))</span>
        <span class="s1">is_fixed = np.zeros(self._k_params_internal</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">fixed_values = np.empty(self._k_params_internal</span><span class="s2">, </span><span class="s1">dtype=params.dtype)</span>
        <span class="s1">self._smoothing_func(</span>
            <span class="s1">internal_params</span><span class="s2">, </span><span class="s1">self.endog</span><span class="s2">, </span><span class="s1">yhat</span><span class="s2">, </span><span class="s1">xhat</span><span class="s2">, </span><span class="s1">is_fixed</span><span class="s2">, </span><span class="s1">fixed_values</span>
        <span class="s1">)</span>

        <span class="s3"># remove states that are only internal</span>
        <span class="s1">states = self._get_states(xhat)</span>

        <span class="s2">if </span><span class="s1">self.use_pandas:</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">index = self._get_prediction_index(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">self.nobs - </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">yhat = pd.Series(yhat</span><span class="s2">, </span><span class="s1">index=index)</span>
            <span class="s1">statenames = [</span><span class="s4">&quot;level&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">self.has_trend:</span>
                <span class="s1">statenames += [</span><span class="s4">&quot;trend&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
                <span class="s1">statenames += [</span><span class="s4">&quot;seasonal&quot;</span><span class="s1">]</span>
            <span class="s1">states = pd.DataFrame(states</span><span class="s2">, </span><span class="s1">index=index</span><span class="s2">, </span><span class="s1">columns=statenames)</span>
        <span class="s2">return </span><span class="s1">yhat</span><span class="s2">, </span><span class="s1">states</span>

    <span class="s2">def </span><span class="s1">smooth(self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">return_raw=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Exponential smoothing with given parameters 
 
        Parameters 
        ---------- 
        params : array_like 
            Model parameters 
        return_raw : bool, optional 
            Whether to return only the state space results or the full results 
            object. Default is ``False``. 
 
        Returns 
        ------- 
        result : ETSResultsWrapper or tuple 
            If ``return_raw=False``, returns a ETSResultsWrapper 
            object. Otherwise a tuple of arrays or pandas objects, depending on 
            the format of the endog data. 
        &quot;&quot;&quot;</span>
        <span class="s1">params = np.asarray(params)</span>
        <span class="s1">results = self._smooth(params)</span>
        <span class="s2">return </span><span class="s1">self._wrap_results(params</span><span class="s2">, </span><span class="s1">results</span><span class="s2">, </span><span class="s1">return_raw)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_res_classes(self):</span>
        <span class="s2">return </span><span class="s1">{</span><span class="s4">&quot;fit&quot;</span><span class="s1">: (ETSResults</span><span class="s2">, </span><span class="s1">ETSResultsWrapper)}</span>

    <span class="s2">def </span><span class="s1">hessian(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">approx_centered=</span><span class="s2">False, </span><span class="s1">approx_complex_step=</span><span class="s2">True, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Hessian matrix of the likelihood function, evaluated at the given 
        parameters 
 
        Parameters 
        ---------- 
        params : array_like 
            Array of parameters at which to evaluate the hessian. 
        approx_centered : bool 
            Whether to use a centered scheme for finite difference 
            approximation 
        approx_complex_step : bool 
            Whether to use complex step differentiation for approximation 
 
        Returns 
        ------- 
        hessian : ndarray 
            Hessian matrix evaluated at `params` 
 
        Notes 
        ----- 
        This is a numerical approximation. 
        &quot;&quot;&quot;</span>
        <span class="s1">method = kwargs.get(</span><span class="s4">&quot;method&quot;</span><span class="s2">, </span><span class="s4">&quot;approx&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">method == </span><span class="s4">&quot;approx&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">approx_complex_step:</span>
                <span class="s1">hessian = self._hessian_complex_step(params</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">hessian = self._hessian_finite_difference(</span>
                    <span class="s1">params</span><span class="s2">, </span><span class="s1">approx_centered=approx_centered</span><span class="s2">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Invalid Hessian calculation method.&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">hessian</span>

    <span class="s2">def </span><span class="s1">score(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">approx_centered=</span><span class="s2">False, </span><span class="s1">approx_complex_step=</span><span class="s2">True, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">method = kwargs.get(</span><span class="s4">&quot;method&quot;</span><span class="s2">, </span><span class="s4">&quot;approx&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">method == </span><span class="s4">&quot;approx&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">approx_complex_step:</span>
                <span class="s1">score = self._score_complex_step(params</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">score = self._score_finite_difference(</span>
                    <span class="s1">params</span><span class="s2">, </span><span class="s1">approx_centered=approx_centered</span><span class="s2">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Invalid score method.&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">score</span>

    <span class="s2">def </span><span class="s1">update(params</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># Dummy method to make methods copied from statespace.MLEModel work</span>
        <span class="s1">...</span>


<span class="s2">class </span><span class="s1">ETSResults(base.StateSpaceMLEResults):</span>
    <span class="s0">&quot;&quot;&quot; 
    Results from an error, trend, seasonal (ETS) exponential smoothing model 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">results):</span>
        <span class="s1">yhat</span><span class="s2">, </span><span class="s1">xhat = results</span>
        <span class="s1">self._llf = model.loglike(params)</span>
        <span class="s1">self._residuals = model._residuals(yhat)</span>
        <span class="s1">self._fittedvalues = yhat</span>
        <span class="s3"># scale is concentrated in this model formulation and corresponds to</span>
        <span class="s3"># mean squared residuals, see docstring of model.loglike</span>
        <span class="s1">scale = np.mean(self._residuals ** </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">super().__init__(model</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">scale=scale)</span>

        <span class="s3"># get model definition</span>
        <span class="s1">model_definition_attrs = [</span>
            <span class="s4">&quot;short_name&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;error&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;trend&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;seasonal&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;damped_trend&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;has_trend&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;has_seasonal&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;seasonal_periods&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;initialization_method&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">model_definition_attrs:</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">getattr(model</span><span class="s2">, </span><span class="s1">attr))</span>
        <span class="s1">self.param_names = [</span>
            <span class="s4">&quot;%s (fixed)&quot; </span><span class="s1">% name </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.fixed_params </span><span class="s2">else </span><span class="s1">name</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(self.model.param_names </span><span class="s2">or </span><span class="s1">[])</span>
        <span class="s1">]</span>

        <span class="s3"># get fitted states and parameters</span>
        <span class="s1">internal_params = self.model._internal_params(params)</span>
        <span class="s1">self.states = xhat</span>
        <span class="s2">if </span><span class="s1">self.model.use_pandas:</span>
            <span class="s1">states = self.states.iloc</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">states = self.states</span>
        <span class="s1">self.initial_state = np.zeros(model._k_initial_states)</span>

        <span class="s1">self.level = states[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self.initial_level = internal_params[</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s1">self.initial_state[</span><span class="s5">0</span><span class="s1">] = self.initial_level</span>
        <span class="s1">self.alpha = self.params[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self.smoothing_level = self.alpha</span>
        <span class="s2">if </span><span class="s1">self.has_trend:</span>
            <span class="s1">self.slope = states[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.initial_trend = internal_params[</span><span class="s5">5</span><span class="s1">]</span>
            <span class="s1">self.initial_state[</span><span class="s5">1</span><span class="s1">] = self.initial_trend</span>
            <span class="s1">self.beta = self.params[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.smoothing_trend = self.beta</span>
        <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
            <span class="s1">self.season = states[:</span><span class="s2">, </span><span class="s1">self.model._seasonal_index]</span>
            <span class="s3"># See GH 7893</span>
            <span class="s1">self.initial_seasonal = internal_params[</span><span class="s5">6</span><span class="s1">:][::-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.initial_state[</span>
                <span class="s1">self.model._seasonal_index :</span>
            <span class="s1">] = self.initial_seasonal</span>
            <span class="s1">self.gamma = self.params[self.model._seasonal_index]</span>
            <span class="s1">self.smoothing_seasonal = self.gamma</span>
        <span class="s2">if </span><span class="s1">self.damped_trend:</span>
            <span class="s1">self.phi = internal_params[</span><span class="s5">3</span><span class="s1">]</span>
            <span class="s1">self.damping_trend = self.phi</span>

        <span class="s3"># degrees of freedom of model</span>
        <span class="s1">k_free_params = self.k_params - len(self.fixed_params)</span>
        <span class="s1">self.df_model = k_free_params + </span><span class="s5">1</span>

        <span class="s3"># standardized forecasting error</span>
        <span class="s1">self.mean_resid = np.mean(self.resid)</span>
        <span class="s1">self.scale_resid = np.std(self.resid</span><span class="s2">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.standardized_forecasts_error = (</span>
            <span class="s1">self.resid - self.mean_resid</span>
        <span class="s1">) / self.scale_resid</span>

        <span class="s3"># Setup covariance matrix notes dictionary</span>
        <span class="s3"># For now, only support &quot;approx&quot;</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s4">&quot;cov_kwds&quot;</span><span class="s1">):</span>
            <span class="s1">self.cov_kwds = {}</span>
        <span class="s1">self.cov_type = </span><span class="s4">&quot;approx&quot;</span>

        <span class="s3"># Setup the cache</span>
        <span class="s1">self._cache = {}</span>

        <span class="s3"># Handle covariance matrix calculation</span>
        <span class="s1">self._cov_approx_complex_step = </span><span class="s2">True</span>
        <span class="s1">self._cov_approx_centered = </span><span class="s2">False</span>
        <span class="s1">approx_type_str = </span><span class="s4">&quot;complex-step&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._rank = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">self.k_params == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.cov_params_default = np.zeros((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
                <span class="s1">self._rank = </span><span class="s5">0</span>
                <span class="s1">self.cov_kwds[</span><span class="s4">&quot;description&quot;</span><span class="s1">] = </span><span class="s4">&quot;No parameters estimated.&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.cov_params_default = self.cov_params_approx</span>
                <span class="s1">self.cov_kwds[</span><span class="s4">&quot;description&quot;</span><span class="s1">] = descriptions[</span><span class="s4">&quot;approx&quot;</span><span class="s1">].format(</span>
                    <span class="s1">approx_type=approx_type_str</span>
                <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">np.linalg.LinAlgError:</span>
            <span class="s1">self._rank = </span><span class="s5">0</span>
            <span class="s1">k_params = len(self.params)</span>
            <span class="s1">self.cov_params_default = np.zeros((k_params</span><span class="s2">, </span><span class="s1">k_params)) * np.nan</span>
            <span class="s1">self.cov_kwds[</span><span class="s4">&quot;cov_type&quot;</span><span class="s1">] = (</span>
                <span class="s4">&quot;Covariance matrix could not be calculated: singular.&quot;</span>
                <span class="s4">&quot; information matrix.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">nobs_effective(self):</span>
        <span class="s2">return </span><span class="s1">self.nobs</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">fittedvalues(self):</span>
        <span class="s2">return </span><span class="s1">self._fittedvalues</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">resid(self):</span>
        <span class="s2">return </span><span class="s1">self._residuals</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">llf(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        log-likelihood function evaluated at the fitted params 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._llf</span>

    <span class="s2">def </span><span class="s1">_get_prediction_params(self</span><span class="s2">, </span><span class="s1">start_idx):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns internal parameter representation of smoothing parameters and 
        &quot;initial&quot; states for prediction/simulation, that is the states just 
        before the first prediction/simulation step. 
        &quot;&quot;&quot;</span>
        <span class="s1">internal_params = self.model._internal_params(self.params)</span>
        <span class="s2">if </span><span class="s1">start_idx == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">internal_params</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">internal_states = self.model._get_internal_states(</span>
                <span class="s1">self.states</span><span class="s2">, </span><span class="s1">self.params</span>
            <span class="s1">)</span>
            <span class="s1">start_state = np.empty(</span><span class="s5">6 </span><span class="s1">+ self.seasonal_periods)</span>
            <span class="s1">start_state[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">4</span><span class="s1">] = internal_params[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span>
            <span class="s1">start_state[</span><span class="s5">4</span><span class="s1">:] = internal_states[start_idx - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s2">return </span><span class="s1">start_state</span>

    <span class="s2">def </span><span class="s1">_relative_forecast_variance(self</span><span class="s2">, </span><span class="s1">steps):</span>
        <span class="s0">&quot;&quot;&quot; 
        References 
        ---------- 
        .. [1] Hyndman, R.J., &amp; Athanasopoulos, G. (2019) *Forecasting: 
           principles and practice*, 3rd edition, OTexts: Melbourne, 
           Australia. OTexts.com/fpp3. Accessed on April 19th 2020. 
        &quot;&quot;&quot;</span>
        <span class="s1">h = steps</span>
        <span class="s1">alpha = self.smoothing_level</span>
        <span class="s2">if </span><span class="s1">self.has_trend:</span>
            <span class="s1">beta = self.smoothing_trend</span>
        <span class="s2">if </span><span class="s1">self.has_seasonal:</span>
            <span class="s1">gamma = self.smoothing_seasonal</span>
            <span class="s1">m = self.seasonal_periods</span>
            <span class="s1">k = np.asarray((h - </span><span class="s5">1</span><span class="s1">) / m</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s2">if </span><span class="s1">self.damped_trend:</span>
            <span class="s1">phi = self.damping_trend</span>
        <span class="s1">model = self.model.short_name</span>
        <span class="s2">if </span><span class="s1">model == </span><span class="s4">&quot;ANN&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">1 </span><span class="s1">+ alpha ** </span><span class="s5">2 </span><span class="s1">* (h - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">model == </span><span class="s4">&quot;AAN&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">1 </span><span class="s1">+ (h - </span><span class="s5">1</span><span class="s1">) * (</span>
                <span class="s1">alpha ** </span><span class="s5">2 </span><span class="s1">+ alpha * beta * h + beta ** </span><span class="s5">2 </span><span class="s1">* h / </span><span class="s5">6 </span><span class="s1">* (</span><span class="s5">2 </span><span class="s1">* h - </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">model == </span><span class="s4">&quot;AAdN&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s5">1</span>
                <span class="s1">+ alpha ** </span><span class="s5">2 </span><span class="s1">* (h - </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">+ (</span>
                    <span class="s1">(beta * phi * h)</span>
                    <span class="s1">/ ((</span><span class="s5">1 </span><span class="s1">- phi) ** </span><span class="s5">2</span><span class="s1">)</span>
                    <span class="s1">* (</span><span class="s5">2 </span><span class="s1">* alpha * (</span><span class="s5">1 </span><span class="s1">- phi) + beta * phi)</span>
                <span class="s1">)</span>
                <span class="s1">- (</span>
                    <span class="s1">(beta * phi * (</span><span class="s5">1 </span><span class="s1">- phi ** h))</span>
                    <span class="s1">/ ((</span><span class="s5">1 </span><span class="s1">- phi) ** </span><span class="s5">2 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- phi ** </span><span class="s5">2</span><span class="s1">))</span>
                    <span class="s1">* (</span>
                        <span class="s5">2 </span><span class="s1">* alpha * (</span><span class="s5">1 </span><span class="s1">- phi ** </span><span class="s5">2</span><span class="s1">)</span>
                        <span class="s1">+ beta * phi * (</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">* phi - phi ** h)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">model == </span><span class="s4">&quot;ANA&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">1 </span><span class="s1">+ alpha ** </span><span class="s5">2 </span><span class="s1">* (h - </span><span class="s5">1</span><span class="s1">) + gamma * k * (</span><span class="s5">2 </span><span class="s1">* alpha + gamma)</span>
        <span class="s2">elif </span><span class="s1">model == </span><span class="s4">&quot;AAA&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s5">1</span>
                <span class="s1">+ (h - </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">* (</span>
                    <span class="s1">alpha ** </span><span class="s5">2</span>
                    <span class="s1">+ alpha * beta * h</span>
                    <span class="s1">+ (beta ** </span><span class="s5">2</span><span class="s1">) / </span><span class="s5">6 </span><span class="s1">* h * (</span><span class="s5">2 </span><span class="s1">* h - </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">+ gamma * k * (</span><span class="s5">2 </span><span class="s1">* alpha + gamma + beta * m * (k + </span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">model == </span><span class="s4">&quot;AAdA&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s5">1</span>
                <span class="s1">+ alpha ** </span><span class="s5">2 </span><span class="s1">* (h - </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">+ gamma * k * (</span><span class="s5">2 </span><span class="s1">* alpha + gamma)</span>
                <span class="s1">+ (beta * phi * h)</span>
                <span class="s1">/ ((</span><span class="s5">1 </span><span class="s1">- phi) ** </span><span class="s5">2</span><span class="s1">)</span>
                <span class="s1">* (</span><span class="s5">2 </span><span class="s1">* alpha * (</span><span class="s5">1 </span><span class="s1">- phi) + beta * phi)</span>
                <span class="s1">- (</span>
                    <span class="s1">(beta * phi * (</span><span class="s5">1 </span><span class="s1">- phi ** h))</span>
                    <span class="s1">/ ((</span><span class="s5">1 </span><span class="s1">- phi) ** </span><span class="s5">2 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- phi ** </span><span class="s5">2</span><span class="s1">))</span>
                    <span class="s1">* (</span>
                        <span class="s5">2 </span><span class="s1">* alpha * (</span><span class="s5">1 </span><span class="s1">- phi ** </span><span class="s5">2</span><span class="s1">)</span>
                        <span class="s1">+ beta * phi * (</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">* phi - phi ** h)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">+ (</span>
                    <span class="s1">(</span><span class="s5">2 </span><span class="s1">* beta * gamma * phi)</span>
                    <span class="s1">/ ((</span><span class="s5">1 </span><span class="s1">- phi) * (</span><span class="s5">1 </span><span class="s1">- phi ** m))</span>
                    <span class="s1">* (k * (</span><span class="s5">1 </span><span class="s1">- phi ** m) - phi ** m * (</span><span class="s5">1 </span><span class="s1">- phi ** (m * k)))</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">simulate(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">nsimulations</span><span class="s2">,</span>
        <span class="s1">anchor=</span><span class="s2">None,</span>
        <span class="s1">repetitions=</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">random_errors=</span><span class="s2">None,</span>
        <span class="s1">random_state=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Random simulations using the state space formulation. 
 
        Parameters 
        ---------- 
        nsimulations : int 
            The number of simulation steps. 
        anchor : int, str, or datetime, optional 
            First period for simulation. The simulation will be conditional on 
            all existing datapoints prior to the `anchor`.  Type depends on the 
            index of the given `endog` in the model. Two special cases are the 
            strings 'start' and 'end'. `start` refers to beginning the 
            simulation at the first period of the sample (i.e. using the 
            initial values as simulation anchor), and `end` refers to 
            beginning the simulation at the first period after the sample. 
            Integer values can run from 0 to `nobs`, or can be negative to 
            apply negative indexing. Finally, if a date/time index was provided 
            to the model, then this argument can be a date string to parse or a 
            datetime type. Default is 'start'. 
            Note: `anchor` corresponds to the observation right before the 
            `start` observation in the `predict` method. 
        repetitions : int, optional 
            Number of simulated paths to generate. Default is 1 simulated path. 
        random_errors : optional 
            Specifies how the random errors should be obtained. Can be one of 
            the following: 
 
            * ``None``: Random normally distributed values with variance 
              estimated from the fit errors drawn from numpy's standard 
              RNG (can be seeded with the `random_state` argument). This is the 
              default option. 
            * A distribution function from ``scipy.stats``, e.g. 
              ``scipy.stats.norm``: Fits the distribution function to the fit 
              errors and draws from the fitted distribution. 
              Note the difference between ``scipy.stats.norm`` and 
              ``scipy.stats.norm()``, the latter one is a frozen distribution 
              function. 
            * A frozen distribution function from ``scipy.stats``, e.g. 
              ``scipy.stats.norm(scale=2)``: Draws from the frozen distribution 
              function. 
            * A ``np.ndarray`` with shape (`nsimulations`, `repetitions`): Uses 
              the given values as random errors. 
            * ``&quot;bootstrap&quot;``: Samples the random errors from the fit errors. 
 
        random_state : int or np.random.RandomState, optional 
            A seed for the random number generator or a 
            ``np.random.RandomState`` object. Only used if `random_errors` is 
            ``None``. Default is ``None``. 
 
        Returns 
        ------- 
        sim : pd.Series, pd.DataFrame or np.ndarray 
            An ``np.ndarray``, ``pd.Series``, or ``pd.DataFrame`` of simulated 
            values. 
            If the original data was a ``pd.Series`` or ``pd.DataFrame``, `sim` 
            will be a ``pd.Series`` if `repetitions` is 1, and a 
            ``pd.DataFrame`` of shape (`nsimulations`, `repetitions`) else. 
            Otherwise, if `repetitions` is 1, a ``np.ndarray`` of shape 
            (`nsimulations`,) is returned, and if `repetitions` is not 1 a 
            ``np.ndarray`` of shape (`nsimulations`, `repetitions`) is 
            returned. 
        &quot;&quot;&quot;</span>

        <span class="s4">r&quot;&quot;&quot; 
        Implementation notes 
        -------------------- 
        The simulation is based on the state space model of the Holt-Winter's 
        methods. The state space model assumes that the true value at time 
        :math:`t` is randomly distributed around the prediction value. 
        If using the additive error model, this means: 
 
        .. math:: 
 
            y_t &amp;= \hat{y}_{t|t-1} + e_t\\ 
            e_t &amp;\sim \mathcal{N}(0, \sigma^2) 
 
        Using the multiplicative error model: 
 
        .. math:: 
 
            y_t &amp;= \hat{y}_{t|t-1} \cdot (1 + e_t)\\ 
            e_t &amp;\sim \mathcal{N}(0, \sigma^2) 
 
        Inserting these equations into the smoothing equation formulation leads 
        to the state space equations. The notation used here follows 
        [1]_. 
 
        Additionally, 
 
        .. math:: 
 
           B_t = b_{t-1} \circ_d \phi\\ 
           L_t = l_{t-1} \circ_b B_t\\ 
           S_t = s_{t-m}\\ 
           Y_t = L_t \circ_s S_t, 
 
        where :math:`\circ_d` is the operation linking trend and damping 
        parameter (multiplication if the trend is additive, power if the trend 
        is multiplicative), :math:`\circ_b` is the operation linking level and 
        trend (addition if the trend is additive, multiplication if the trend 
        is multiplicative), and :math:'\circ_s` is the operation linking 
        seasonality to the rest. 
 
        The state space equations can then be formulated as 
 
        .. math:: 
 
           y_t = Y_t + \eta \cdot e_t\\ 
           l_t = L_t + \alpha \cdot (M_e \cdot L_t + \kappa_l) \cdot e_t\\ 
           b_t = B_t + \beta \cdot (M_e \cdot B_t+\kappa_b) \cdot e_t\\ 
           s_t = S_t + \gamma \cdot (M_e \cdot S_t + \kappa_s) \cdot e_t\\ 
 
        with 
 
        .. math:: 
 
           \eta &amp;= \begin{cases} 
                       Y_t\quad\text{if error is multiplicative}\\ 
                       1\quad\text{else} 
                   \end{cases}\\ 
           M_e &amp;= \begin{cases} 
                       1\quad\text{if error is multiplicative}\\ 
                       0\quad\text{else} 
                   \end{cases}\\ 
 
        and, when using the additive error model, 
 
        .. math:: 
 
           \kappa_l &amp;= \begin{cases} 
                       \frac{1}{S_t}\quad 
                       \text{if seasonality is multiplicative}\\ 
                       1\quad\text{else} 
                   \end{cases}\\ 
           \kappa_b &amp;= \begin{cases} 
                       \frac{\kappa_l}{l_{t-1}}\quad 
                       \text{if trend is multiplicative}\\ 
                       \kappa_l\quad\text{else} 
                   \end{cases}\\ 
           \kappa_s &amp;= \begin{cases} 
                       \frac{1}{L_t}\quad 
                       \text{if seasonality is multiplicative}\\ 
                       1\quad\text{else} 
                   \end{cases} 
 
        When using the multiplicative error model 
 
        .. math:: 
 
           \kappa_l &amp;= \begin{cases} 
                       0\quad 
                       \text{if seasonality is multiplicative}\\ 
                       S_t\quad\text{else} 
                   \end{cases}\\ 
           \kappa_b &amp;= \begin{cases} 
                       \frac{\kappa_l}{l_{t-1}}\quad 
                       \text{if trend is multiplicative}\\ 
                       \kappa_l + l_{t-1}\quad\text{else} 
                   \end{cases}\\ 
           \kappa_s &amp;= \begin{cases} 
                       0\quad\text{if seasonality is multiplicative}\\ 
                       L_t\quad\text{else} 
                   \end{cases} 
 
        References 
        ---------- 
        .. [1] Hyndman, R.J., &amp; Athanasopoulos, G. (2018) *Forecasting: 
           principles and practice*, 2nd edition, OTexts: Melbourne, 
           Australia. OTexts.com/fpp2. Accessed on February 28th 2020. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Get the starting location</span>
        <span class="s1">start_idx = self._get_prediction_start_index(anchor)</span>

        <span class="s3"># set initial values and obtain parameters</span>
        <span class="s1">start_params = self._get_prediction_params(start_idx)</span>
        <span class="s1">x = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">self.model._k_states_internal))</span>
        <span class="s3"># is fixed and fixed values are dummy arguments</span>
        <span class="s1">is_fixed = np.zeros(len(start_params)</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">fixed_values = np.zeros_like(start_params)</span>
        <span class="s1">(</span>
            <span class="s1">alpha</span><span class="s2">,</span>
            <span class="s1">beta_star</span><span class="s2">,</span>
            <span class="s1">gamma_star</span><span class="s2">,</span>
            <span class="s1">phi</span><span class="s2">,</span>
            <span class="s1">m</span><span class="s2">,</span>
            <span class="s1">_</span><span class="s2">,</span>
        <span class="s1">) = smooth._initialize_ets_smooth(</span>
            <span class="s1">start_params</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">is_fixed</span><span class="s2">, </span><span class="s1">fixed_values</span>
        <span class="s1">)</span>
        <span class="s1">beta = alpha * beta_star</span>
        <span class="s1">gamma = (</span><span class="s5">1 </span><span class="s1">- alpha) * gamma_star</span>
        <span class="s3"># make x a 3 dimensional matrix: first dimension is nsimulations</span>
        <span class="s3"># (number of steps), next is number of states, innermost is repetitions</span>
        <span class="s1">nstates = x.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">x = np.tile(np.reshape(x</span><span class="s2">, </span><span class="s1">(nsimulations</span><span class="s2">, </span><span class="s1">nstates</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">repetitions)</span>
        <span class="s1">y = np.empty((nsimulations</span><span class="s2">, </span><span class="s1">repetitions))</span>

        <span class="s3"># get random error eps</span>
        <span class="s1">sigma = np.sqrt(self.scale)</span>
        <span class="s2">if </span><span class="s1">isinstance(random_errors</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">if </span><span class="s1">random_errors.shape != (nsimulations</span><span class="s2">, </span><span class="s1">repetitions):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;If random is an ndarray, it must have shape &quot;</span>
                    <span class="s4">&quot;(nsimulations, repetitions)!&quot;</span>
                <span class="s1">)</span>
            <span class="s1">eps = random_errors</span>
        <span class="s2">elif </span><span class="s1">random_errors == </span><span class="s4">&quot;bootstrap&quot;</span><span class="s1">:</span>
            <span class="s1">eps = np.random.choice(</span>
                <span class="s1">self.resid</span><span class="s2">, </span><span class="s1">size=(nsimulations</span><span class="s2">, </span><span class="s1">repetitions)</span><span class="s2">, </span><span class="s1">replace=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">random_errors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">random_state </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">eps = np.random.randn(nsimulations</span><span class="s2">, </span><span class="s1">repetitions) * sigma</span>
            <span class="s2">elif </span><span class="s1">isinstance(random_state</span><span class="s2">, </span><span class="s1">int):</span>
                <span class="s1">rng = np.random.RandomState(random_state)</span>
                <span class="s1">eps = rng.randn(nsimulations</span><span class="s2">, </span><span class="s1">repetitions) * sigma</span>
            <span class="s2">elif </span><span class="s1">isinstance(random_state</span><span class="s2">, </span><span class="s1">np.random.RandomState):</span>
                <span class="s1">eps = random_state.randn(nsimulations</span><span class="s2">, </span><span class="s1">repetitions) * sigma</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Argument random_state must be None, an integer, &quot;</span>
                    <span class="s4">&quot;or an instance of np.random.RandomState&quot;</span>
                <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(random_errors</span><span class="s2">, </span><span class="s1">(rv_continuous</span><span class="s2">, </span><span class="s1">rv_discrete)):</span>
            <span class="s1">params = random_errors.fit(self.resid)</span>
            <span class="s1">eps = random_errors.rvs(*params</span><span class="s2">, </span><span class="s1">size=(nsimulations</span><span class="s2">, </span><span class="s1">repetitions))</span>
        <span class="s2">elif </span><span class="s1">isinstance(random_errors</span><span class="s2">, </span><span class="s1">rv_frozen):</span>
            <span class="s1">eps = random_errors.rvs(size=(nsimulations</span><span class="s2">, </span><span class="s1">repetitions))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Argument random_errors has unexpected value!&quot;</span><span class="s1">)</span>

        <span class="s3"># get model settings</span>
        <span class="s1">mul_seasonal = self.seasonal == </span><span class="s4">&quot;mul&quot;</span>
        <span class="s1">mul_trend = self.trend == </span><span class="s4">&quot;mul&quot;</span>
        <span class="s1">mul_error = self.error == </span><span class="s4">&quot;mul&quot;</span>

        <span class="s3"># define trend, damping and seasonality operations</span>
        <span class="s2">if </span><span class="s1">mul_trend:</span>
            <span class="s1">op_b = np.multiply</span>
            <span class="s1">op_d = np.power</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">op_b = np.add</span>
            <span class="s1">op_d = np.multiply</span>
        <span class="s2">if </span><span class="s1">mul_seasonal:</span>
            <span class="s1">op_s = np.multiply</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">op_s = np.add</span>

        <span class="s3"># x translation:</span>
        <span class="s3"># - x[t, 0, :] is level[t]</span>
        <span class="s3"># - x[t, 1, :] is trend[t]</span>
        <span class="s3"># - x[t, 2, :] is seasonal[t]</span>
        <span class="s3"># - x[t, 3, :] is seasonal[t-1]</span>
        <span class="s3"># - x[t, 2+j, :] is seasonal[t-j]</span>
        <span class="s3"># - similarly: x[t-1, 2+m-1, :] is seasonal[t-m]</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(nsimulations):</span>
            <span class="s1">B = op_d(x[t - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">phi)</span>
            <span class="s1">L = op_b(x[t - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">B)</span>
            <span class="s1">S = x[t - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">+ m - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">Y = op_s(L</span><span class="s2">, </span><span class="s1">S)</span>
            <span class="s2">if </span><span class="s1">self.error == </span><span class="s4">&quot;add&quot;</span><span class="s1">:</span>
                <span class="s1">eta = </span><span class="s5">1</span>
                <span class="s1">kappa_l = </span><span class="s5">1 </span><span class="s1">/ S </span><span class="s2">if </span><span class="s1">mul_seasonal </span><span class="s2">else </span><span class="s5">1</span>
                <span class="s1">kappa_b = kappa_l / x[t - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:] </span><span class="s2">if </span><span class="s1">mul_trend </span><span class="s2">else </span><span class="s1">kappa_l</span>
                <span class="s1">kappa_s = </span><span class="s5">1 </span><span class="s1">/ L </span><span class="s2">if </span><span class="s1">mul_seasonal </span><span class="s2">else </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">eta = Y</span>
                <span class="s1">kappa_l = </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">mul_seasonal </span><span class="s2">else </span><span class="s1">S</span>
                <span class="s1">kappa_b = (</span>
                    <span class="s1">kappa_l / x[t - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span>
                    <span class="s2">if </span><span class="s1">mul_trend</span>
                    <span class="s2">else </span><span class="s1">kappa_l + x[t - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span>
                <span class="s1">)</span>
                <span class="s1">kappa_s = </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">mul_seasonal </span><span class="s2">else </span><span class="s1">L</span>

            <span class="s1">y[t</span><span class="s2">, </span><span class="s1">:] = Y + eta * eps[t</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">x[t</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:] = L + alpha * (mul_error * L + kappa_l) * eps[t</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">x[t</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = B + beta * (mul_error * B + kappa_b) * eps[t</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">x[t</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">:] = S + gamma * (mul_error * S + kappa_s) * eps[t</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s3"># update seasonals by shifting previous seasonal right</span>
            <span class="s1">x[t</span><span class="s2">, </span><span class="s5">3</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = x[t - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">:-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">:]</span>

        <span class="s3"># Wrap data / squeeze where appropriate</span>
        <span class="s2">if </span><span class="s1">repetitions &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">names = [</span><span class="s4">&quot;simulation.%d&quot; </span><span class="s1">% num </span><span class="s2">for </span><span class="s1">num </span><span class="s2">in </span><span class="s1">range(repetitions)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">names = </span><span class="s4">&quot;simulation&quot;</span>
        <span class="s2">return </span><span class="s1">self.model._wrap_data(</span>
            <span class="s1">y</span><span class="s2">, </span><span class="s1">start_idx</span><span class="s2">, </span><span class="s1">start_idx + nsimulations - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">names=names</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">forecast(self</span><span class="s2">, </span><span class="s1">steps=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Out-of-sample forecasts 
 
        Parameters 
        ---------- 
        steps : int, str, or datetime, optional 
            If an integer, the number of steps to forecast from the end of the 
            sample. Can also be a date string to parse or a datetime type. 
            However, if the dates index does not have a fixed frequency, steps 
            must be an integer. Default 
 
        Returns 
        ------- 
        forecast : ndarray 
            Array of out of sample forecasts. A (steps x k_endog) array. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._forecast(steps</span><span class="s2">, </span><span class="s4">&quot;end&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_forecast(self</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">anchor):</span>
        <span class="s0">&quot;&quot;&quot; 
        Dynamic prediction/forecasting 
        &quot;&quot;&quot;</span>
        <span class="s3"># forecast is the same as simulation without errors</span>
        <span class="s2">return </span><span class="s1">self.simulate(</span>
            <span class="s1">steps</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">, </span><span class="s1">random_errors=np.zeros((steps</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_handle_prediction_index(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">dynamic</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">index):</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">start = </span><span class="s5">0</span>

        <span class="s3"># Handle start, end, dynamic</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">_ = self.model._get_prediction_index(</span>
            <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">index</span>
        <span class="s1">)</span>
        <span class="s3"># if end was outside of the sample, it is now the last point in the</span>
        <span class="s3"># sample</span>
        <span class="s2">if </span><span class="s1">start &gt; end + out_of_sample + </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Prediction start cannot lie outside of the sample.&quot;</span>
            <span class="s1">)</span>

        <span class="s3"># Handle `dynamic`</span>
        <span class="s2">if </span><span class="s1">isinstance(dynamic</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">dt.datetime</span><span class="s2">, </span><span class="s1">pd.Timestamp)):</span>
            <span class="s1">dynamic</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = self.model._get_index_loc(dynamic)</span>
            <span class="s3"># Convert to offset relative to start</span>
            <span class="s1">dynamic = dynamic - start</span>
        <span class="s2">elif </span><span class="s1">isinstance(dynamic</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s2">if </span><span class="s1">dynamic:</span>
                <span class="s1">dynamic = </span><span class="s5">0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dynamic = end + </span><span class="s5">1 </span><span class="s1">- start</span>

        <span class="s3"># start : index of first predicted value</span>
        <span class="s3"># dynamic : offset to first dynamically predicted value</span>
        <span class="s3">#     -&gt; if dynamic == 0, only dynamic simulations</span>
        <span class="s2">if </span><span class="s1">dynamic == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">start_smooth = </span><span class="s2">None</span>
            <span class="s1">end_smooth = </span><span class="s2">None</span>
            <span class="s1">nsmooth = </span><span class="s5">0</span>
            <span class="s1">start_dynamic = start</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># dynamic simulations from start + dynamic</span>
            <span class="s1">start_smooth = start</span>
            <span class="s1">end_smooth = min(start + dynamic - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">end)</span>
            <span class="s1">nsmooth = max(end_smooth - start_smooth + </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">start_dynamic = start + dynamic</span>
        <span class="s3"># anchor for simulations is one before start_dynamic</span>
        <span class="s2">if </span><span class="s1">start_dynamic == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">anchor_dynamic = </span><span class="s4">&quot;start&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">anchor_dynamic = start_dynamic - </span><span class="s5">1</span>
        <span class="s3"># end is last point in sample, out_of_sample gives number of</span>
        <span class="s3"># simulations out of sample</span>
        <span class="s1">end_dynamic = end + out_of_sample</span>
        <span class="s1">ndynamic = end_dynamic - start_dynamic + </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">start</span><span class="s2">,</span>
            <span class="s1">end</span><span class="s2">,</span>
            <span class="s1">start_smooth</span><span class="s2">,</span>
            <span class="s1">end_smooth</span><span class="s2">,</span>
            <span class="s1">anchor_dynamic</span><span class="s2">,</span>
            <span class="s1">start_dynamic</span><span class="s2">,</span>
            <span class="s1">end_dynamic</span><span class="s2">,</span>
            <span class="s1">nsmooth</span><span class="s2">,</span>
            <span class="s1">ndynamic</span><span class="s2">,</span>
            <span class="s1">index</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">predict(self</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">end=</span><span class="s2">None, </span><span class="s1">dynamic=</span><span class="s2">False, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        In-sample prediction and out-of-sample forecasting 
 
        Parameters 
        ---------- 
        start : int, str, or datetime, optional 
            Zero-indexed observation number at which to start forecasting, 
            i.e., the first forecast is start. Can also be a date string to 
            parse or a datetime type. Default is the the zeroth observation. 
        end : int, str, or datetime, optional 
            Zero-indexed observation number at which to end forecasting, i.e., 
            the last forecast is end. Can also be a date string to 
            parse or a datetime type. However, if the dates index does not 
            have a fixed frequency, end must be an integer index if you 
            want out of sample prediction. Default is the last observation in 
            the sample. 
        dynamic : bool, int, str, or datetime, optional 
            Integer offset relative to `start` at which to begin dynamic 
            prediction. Can also be an absolute date string to parse or a 
            datetime type (these are not interpreted as offsets). 
            Prior to this observation, true endogenous values will be used for 
            prediction; starting with this observation and continuing through 
            the end of prediction, forecasted endogenous values will be used 
            instead. 
        index : pd.Index, optional 
            Optionally an index to associate the predicted results to. If None, 
            an attempt is made to create an index for the predicted results 
            from the model's index or model's row labels. 
 
        Returns 
        ------- 
        forecast : array_like or pd.Series. 
            Array of out of in-sample predictions and / or out-of-sample 
            forecasts. An (npredict,) array. If original data was a pd.Series 
            or DataFrame, a pd.Series is returned. 
        &quot;&quot;&quot;</span>

        <span class="s1">(</span>
            <span class="s1">start</span><span class="s2">,</span>
            <span class="s1">end</span><span class="s2">,</span>
            <span class="s1">start_smooth</span><span class="s2">,</span>
            <span class="s1">end_smooth</span><span class="s2">,</span>
            <span class="s1">anchor_dynamic</span><span class="s2">,</span>
            <span class="s1">_</span><span class="s2">,</span>
            <span class="s1">end_dynamic</span><span class="s2">,</span>
            <span class="s1">nsmooth</span><span class="s2">,</span>
            <span class="s1">ndynamic</span><span class="s2">,</span>
            <span class="s1">index</span><span class="s2">,</span>
        <span class="s1">) = self._handle_prediction_index(start</span><span class="s2">, </span><span class="s1">dynamic</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">index)</span>

        <span class="s1">y = np.empty(nsmooth + ndynamic)</span>

        <span class="s3"># In sample nondynamic prediction: smoothing</span>
        <span class="s2">if </span><span class="s1">nsmooth &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">y[</span><span class="s5">0</span><span class="s1">:nsmooth] = self.fittedvalues[start_smooth : end_smooth + </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s3"># Out of sample/dynamic prediction: forecast</span>
        <span class="s2">if </span><span class="s1">ndynamic &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">y[nsmooth:] = self._forecast(ndynamic</span><span class="s2">, </span><span class="s1">anchor_dynamic)</span>

        <span class="s3"># when we are doing out of sample only prediction, start &gt; end + 1, and</span>
        <span class="s3"># we only want to output beginning at start</span>
        <span class="s2">if </span><span class="s1">start &gt; end + </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">ndiscard = start - (end + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">y = y[ndiscard:]</span>

        <span class="s3"># Wrap data / squeeze where appropriate</span>
        <span class="s2">return </span><span class="s1">self.model._wrap_data(y</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end_dynamic)</span>

    <span class="s2">def </span><span class="s1">get_prediction(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">start=</span><span class="s2">None,</span>
        <span class="s1">end=</span><span class="s2">None,</span>
        <span class="s1">dynamic=</span><span class="s2">False,</span>
        <span class="s1">index=</span><span class="s2">None,</span>
        <span class="s1">method=</span><span class="s2">None,</span>
        <span class="s1">simulate_repetitions=</span><span class="s5">1000</span><span class="s2">,</span>
        <span class="s1">**simulate_kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculates mean prediction and prediction intervals. 
 
        Parameters 
        ---------- 
        start : int, str, or datetime, optional 
            Zero-indexed observation number at which to start forecasting, 
            i.e., the first forecast is start. Can also be a date string to 
            parse or a datetime type. Default is the the zeroth observation. 
        end : int, str, or datetime, optional 
            Zero-indexed observation number at which to end forecasting, i.e., 
            the last forecast is end. Can also be a date string to 
            parse or a datetime type. However, if the dates index does not 
            have a fixed frequency, end must be an integer index if you 
            want out of sample prediction. Default is the last observation in 
            the sample. 
        dynamic : bool, int, str, or datetime, optional 
            Integer offset relative to `start` at which to begin dynamic 
            prediction. Can also be an absolute date string to parse or a 
            datetime type (these are not interpreted as offsets). 
            Prior to this observation, true endogenous values will be used for 
            prediction; starting with this observation and continuing through 
            the end of prediction, forecasted endogenous values will be used 
            instead. 
        index : pd.Index, optional 
            Optionally an index to associate the predicted results to. If None, 
            an attempt is made to create an index for the predicted results 
            from the model's index or model's row labels. 
        method : str or None, optional 
            Method to use for calculating prediction intervals. 'exact' 
            (default, if available) or 'simulated'. 
        simulate_repetitions : int, optional 
            Number of simulation repetitions for calculating prediction 
            intervals when ``method='simulated'``. Default is 1000. 
        **simulate_kwargs : 
            Additional arguments passed to the ``simulate`` method. 
 
        Returns 
        ------- 
        PredictionResults 
            Predicted mean values and prediction intervals 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">PredictionResultsWrapper(</span>
            <span class="s1">PredictionResults(</span>
                <span class="s1">self</span><span class="s2">,</span>
                <span class="s1">start</span><span class="s2">,</span>
                <span class="s1">end</span><span class="s2">,</span>
                <span class="s1">dynamic</span><span class="s2">,</span>
                <span class="s1">index</span><span class="s2">,</span>
                <span class="s1">method</span><span class="s2">,</span>
                <span class="s1">simulate_repetitions</span><span class="s2">,</span>
                <span class="s1">**simulate_kwargs</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">summary(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Summarize the fitted model 
 
        Parameters 
        ---------- 
        alpha : float, optional 
            Significance level for the confidence intervals. Default is 0.05. 
        start : int, optional 
            Integer of the start observation. Default is 0. 
 
        Returns 
        ------- 
        summary : Summary instance 
            This holds the summary table and text, which can be printed or 
            converted to various output formats. 
 
        See Also 
        -------- 
        statsmodels.iolib.summary.Summary 
        &quot;&quot;&quot;</span>
        <span class="s1">model_name = </span><span class="s4">f&quot;ETS(</span><span class="s2">{</span><span class="s1">self.short_name</span><span class="s2">}</span><span class="s4">)&quot;</span>

        <span class="s1">summary = super().summary(</span>
            <span class="s1">alpha=alpha</span><span class="s2">,</span>
            <span class="s1">start=start</span><span class="s2">,</span>
            <span class="s1">title=</span><span class="s4">&quot;ETS Results&quot;</span><span class="s2">,</span>
            <span class="s1">model_name=model_name</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.model.initialization_method != </span><span class="s4">&quot;estimated&quot;</span><span class="s1">:</span>
            <span class="s1">params = np.array(self.initial_state)</span>
            <span class="s2">if </span><span class="s1">params.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">params = params[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">names = self.model.initial_state_names</span>
            <span class="s1">param_header = [</span>
                <span class="s4">&quot;initialization method: %s&quot; </span><span class="s1">% self.model.initialization_method</span>
            <span class="s1">]</span>
            <span class="s1">params_stubs = names</span>
            <span class="s1">params_data = [</span>
                <span class="s1">[forg(params[i]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(params))</span>
            <span class="s1">]</span>

            <span class="s1">initial_state_table = SimpleTable(</span>
                <span class="s1">params_data</span><span class="s2">, </span><span class="s1">param_header</span><span class="s2">, </span><span class="s1">params_stubs</span><span class="s2">, </span><span class="s1">txt_fmt=fmt_params</span>
            <span class="s1">)</span>
            <span class="s1">summary.tables.insert(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">initial_state_table)</span>

        <span class="s2">return </span><span class="s1">summary</span>


<span class="s2">class </span><span class="s1">ETSResultsWrapper(wrap.ResultsWrapper):</span>
    <span class="s1">_attrs = {</span>
        <span class="s4">&quot;fittedvalues&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;level&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;resid&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;season&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;slope&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">_wrap_attrs = wrap.union_dicts(</span>
        <span class="s1">tsbase.TimeSeriesResultsWrapper._wrap_attrs</span><span class="s2">, </span><span class="s1">_attrs</span>
    <span class="s1">)</span>
    <span class="s1">_methods = {</span><span class="s4">&quot;predict&quot;</span><span class="s1">: </span><span class="s4">&quot;dates&quot;</span><span class="s2">, </span><span class="s4">&quot;forecast&quot;</span><span class="s1">: </span><span class="s4">&quot;dates&quot;</span><span class="s1">}</span>
    <span class="s1">_wrap_methods = wrap.union_dicts(</span>
        <span class="s1">tsbase.TimeSeriesResultsWrapper._wrap_methods</span><span class="s2">, </span><span class="s1">_methods</span>
    <span class="s1">)</span>


<span class="s1">wrap.populate_wrapper(ETSResultsWrapper</span><span class="s2">, </span><span class="s1">ETSResults)</span>


<span class="s2">class </span><span class="s1">PredictionResults:</span>
    <span class="s0">&quot;&quot;&quot; 
    ETS mean prediction and prediction intervals 
 
    Parameters 
    ---------- 
    results : ETSResults 
        Model estimation results. 
    start : int, str, or datetime, optional 
        Zero-indexed observation number at which to start forecasting, 
        i.e., the first forecast is start. Can also be a date string to 
        parse or a datetime type. Default is the the zeroth observation. 
    end : int, str, or datetime, optional 
        Zero-indexed observation number at which to end forecasting, i.e., 
        the last forecast is end. Can also be a date string to 
        parse or a datetime type. However, if the dates index does not 
        have a fixed frequency, end must be an integer index if you 
        want out of sample prediction. Default is the last observation in 
        the sample. 
    dynamic : bool, int, str, or datetime, optional 
        Integer offset relative to `start` at which to begin dynamic 
        prediction. Can also be an absolute date string to parse or a 
        datetime type (these are not interpreted as offsets). 
        Prior to this observation, true endogenous values will be used for 
        prediction; starting with this observation and continuing through 
        the end of prediction, forecasted endogenous values will be used 
        instead. 
    index : pd.Index, optional 
        Optionally an index to associate the predicted results to. If None, 
        an attempt is made to create an index for the predicted results 
        from the model's index or model's row labels. 
    method : str or None, optional 
        Method to use for calculating prediction intervals. 'exact' (default, 
        if available) or 'simulated'. 
    simulate_repetitions : int, optional 
        Number of simulation repetitions for calculating prediction intervals. 
        Default is 1000. 
    **simulate_kwargs : 
        Additional arguments passed to the ``simulate`` method. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">results</span><span class="s2">,</span>
        <span class="s1">start=</span><span class="s2">None,</span>
        <span class="s1">end=</span><span class="s2">None,</span>
        <span class="s1">dynamic=</span><span class="s2">False,</span>
        <span class="s1">index=</span><span class="s2">None,</span>
        <span class="s1">method=</span><span class="s2">None,</span>
        <span class="s1">simulate_repetitions=</span><span class="s5">1000</span><span class="s2">,</span>
        <span class="s1">**simulate_kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">self.use_pandas = results.model.use_pandas</span>

        <span class="s2">if </span><span class="s1">method </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">exact_available = [</span><span class="s4">&quot;ANN&quot;</span><span class="s2">, </span><span class="s4">&quot;AAN&quot;</span><span class="s2">, </span><span class="s4">&quot;AAdN&quot;</span><span class="s2">, </span><span class="s4">&quot;ANA&quot;</span><span class="s2">, </span><span class="s4">&quot;AAA&quot;</span><span class="s2">, </span><span class="s4">&quot;AAdA&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">results.model.short_name </span><span class="s2">in </span><span class="s1">exact_available:</span>
                <span class="s1">method = </span><span class="s4">&quot;exact&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">method = </span><span class="s4">&quot;simulated&quot;</span>
        <span class="s1">self.method = method</span>

        <span class="s1">(</span>
            <span class="s1">start</span><span class="s2">,</span>
            <span class="s1">end</span><span class="s2">,</span>
            <span class="s1">start_smooth</span><span class="s2">,</span>
            <span class="s1">_</span><span class="s2">,</span>
            <span class="s1">anchor_dynamic</span><span class="s2">,</span>
            <span class="s1">start_dynamic</span><span class="s2">,</span>
            <span class="s1">end_dynamic</span><span class="s2">,</span>
            <span class="s1">nsmooth</span><span class="s2">,</span>
            <span class="s1">ndynamic</span><span class="s2">,</span>
            <span class="s1">index</span><span class="s2">,</span>
        <span class="s1">) = results._handle_prediction_index(start</span><span class="s2">, </span><span class="s1">dynamic</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">index)</span>

        <span class="s1">self.predicted_mean = results.predict(</span>
            <span class="s1">start=start</span><span class="s2">, </span><span class="s1">end=end_dynamic</span><span class="s2">, </span><span class="s1">dynamic=dynamic</span><span class="s2">, </span><span class="s1">index=index</span>
        <span class="s1">)</span>
        <span class="s1">self.row_labels = self.predicted_mean.index</span>
        <span class="s1">self.endog = np.empty(nsmooth + ndynamic) * np.nan</span>
        <span class="s2">if </span><span class="s1">nsmooth &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self.endog[</span><span class="s5">0</span><span class="s1">: (end - start + </span><span class="s5">1</span><span class="s1">)] = results.data.endog[</span>
                <span class="s1">start: (end + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">]</span>
        <span class="s1">self.model = Bunch(</span>
            <span class="s1">data=results.model.data.__class__(</span>
                <span class="s1">endog=self.endog</span><span class="s2">, </span><span class="s1">predict_dates=self.row_labels</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.method == </span><span class="s4">&quot;simulated&quot;</span><span class="s1">:</span>

            <span class="s1">sim_results = []</span>
            <span class="s3"># first, perform &quot;non-dynamic&quot; simulations, i.e. simulations of</span>
            <span class="s3"># only one step, based on the previous step</span>
            <span class="s2">if </span><span class="s1">nsmooth &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">start_smooth == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">anchor = </span><span class="s4">&quot;start&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">anchor = start_smooth - </span><span class="s5">1</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nsmooth):</span>
                    <span class="s1">sim_results.append(</span>
                        <span class="s1">results.simulate(</span>
                            <span class="s5">1</span><span class="s2">,</span>
                            <span class="s1">anchor=anchor</span><span class="s2">,</span>
                            <span class="s1">repetitions=simulate_repetitions</span><span class="s2">,</span>
                            <span class="s1">**simulate_kwargs</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s3"># anchor</span>
                    <span class="s1">anchor = start_smooth + i</span>
            <span class="s2">if </span><span class="s1">ndynamic:</span>
                <span class="s1">sim_results.append(</span>
                    <span class="s1">results.simulate(</span>
                        <span class="s1">ndynamic</span><span class="s2">,</span>
                        <span class="s1">anchor=anchor_dynamic</span><span class="s2">,</span>
                        <span class="s1">repetitions=simulate_repetitions</span><span class="s2">,</span>
                        <span class="s1">**simulate_kwargs</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">sim_results </span><span class="s2">and </span><span class="s1">isinstance(sim_results[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
                <span class="s1">self.simulation_results = pd.concat(sim_results</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.simulation_results = np.concatenate(sim_results</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">self.forecast_variance = self.simulation_results.var(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s3"># method == 'exact'</span>
            <span class="s1">steps = np.ones(ndynamic + nsmooth)</span>
            <span class="s2">if </span><span class="s1">ndynamic &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">steps[</span>
                    <span class="s1">(start_dynamic - min(start_dynamic</span><span class="s2">, </span><span class="s1">start)):</span>
                    <span class="s1">] = range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">ndynamic + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3"># when we are doing out of sample only prediction,</span>
            <span class="s3"># start &gt; end + 1, and</span>
            <span class="s3"># we only want to output beginning at start</span>
            <span class="s2">if </span><span class="s1">start &gt; end + </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">ndiscard = start - (end + </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">steps = steps[ndiscard:]</span>
            <span class="s1">self.forecast_variance = (</span>
                <span class="s1">results.mse * results._relative_forecast_variance(steps)</span>
            <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">var_pred_mean(self):</span>
        <span class="s0">&quot;&quot;&quot;The variance of the predicted mean&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.forecast_variance</span>

    <span class="s2">def </span><span class="s1">pred_int(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculates prediction intervals by performing multiple simulations. 
 
        Parameters 
        ---------- 
        alpha : float, optional 
            The significance level for the prediction interval. Default is 
            0.05, that is, a 95% prediction interval. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.method == </span><span class="s4">&quot;simulated&quot;</span><span class="s1">:</span>
            <span class="s1">simulated_upper_pi = np.quantile(</span>
                <span class="s1">self.simulation_results</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- alpha / </span><span class="s5">2</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span>
            <span class="s1">)</span>
            <span class="s1">simulated_lower_pi = np.quantile(</span>
                <span class="s1">self.simulation_results</span><span class="s2">, </span><span class="s1">alpha / </span><span class="s5">2</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span>
            <span class="s1">)</span>
            <span class="s1">pred_int = np.vstack((simulated_lower_pi</span><span class="s2">, </span><span class="s1">simulated_upper_pi)).T</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">q = norm.ppf(</span><span class="s5">1 </span><span class="s1">- alpha / </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">half_interval_size = q * np.sqrt(self.forecast_variance)</span>
            <span class="s1">pred_int = np.vstack(</span>
                <span class="s1">(</span>
                    <span class="s1">self.predicted_mean - half_interval_size</span><span class="s2">,</span>
                    <span class="s1">self.predicted_mean + half_interval_size</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">).T</span>

        <span class="s2">if </span><span class="s1">self.use_pandas:</span>
            <span class="s1">pred_int = pd.DataFrame(pred_int</span><span class="s2">, </span><span class="s1">index=self.row_labels)</span>
            <span class="s1">names = [</span>
                <span class="s4">f&quot;lower PI (alpha=</span><span class="s2">{</span><span class="s1">alpha</span><span class="s2">:</span><span class="s4">f</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s2">,</span>
                <span class="s4">f&quot;upper PI (alpha=</span><span class="s2">{</span><span class="s1">alpha</span><span class="s2">:</span><span class="s4">f</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
            <span class="s1">pred_int.columns = names</span>
        <span class="s2">return </span><span class="s1">pred_int</span>

    <span class="s2">def </span><span class="s1">summary_frame(self</span><span class="s2">, </span><span class="s1">endog=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s1">):</span>
        <span class="s1">pred_int = np.asarray(self.pred_int(alpha=alpha))</span>
        <span class="s1">to_include = {}</span>
        <span class="s1">to_include[</span><span class="s4">&quot;mean&quot;</span><span class="s1">] = self.predicted_mean</span>
        <span class="s2">if </span><span class="s1">self.method == </span><span class="s4">&quot;simulated&quot;</span><span class="s1">:</span>
            <span class="s1">to_include[</span><span class="s4">&quot;mean_numerical&quot;</span><span class="s1">] = np.mean(</span>
                <span class="s1">self.simulation_results</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span>
            <span class="s1">)</span>
        <span class="s1">to_include[</span><span class="s4">&quot;pi_lower&quot;</span><span class="s1">] = pred_int[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">to_include[</span><span class="s4">&quot;pi_upper&quot;</span><span class="s1">] = pred_int[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">res = pd.DataFrame(</span>
            <span class="s1">to_include</span><span class="s2">, </span><span class="s1">index=self.row_labels</span><span class="s2">, </span><span class="s1">columns=list(to_include.keys())</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">res</span>


<span class="s2">class </span><span class="s1">PredictionResultsWrapper(wrap.ResultsWrapper):</span>
    <span class="s1">_attrs = {</span>
        <span class="s4">&quot;predicted_mean&quot;</span><span class="s1">: </span><span class="s4">&quot;dates&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;simulation_results&quot;</span><span class="s1">: </span><span class="s4">&quot;dates&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;endog&quot;</span><span class="s1">: </span><span class="s4">&quot;dates&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">_wrap_attrs = wrap.union_dicts(_attrs)</span>

    <span class="s1">_methods = {}</span>
    <span class="s1">_wrap_methods = wrap.union_dicts(_methods)</span>


<span class="s1">wrap.populate_wrapper(PredictionResultsWrapper</span><span class="s2">, </span><span class="s1">PredictionResults)  </span><span class="s3"># noqa:E305</span>
</pre>
</body>
</html>