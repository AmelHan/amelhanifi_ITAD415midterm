<html>
<head>
<title>_mio5.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
.s6 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mio5.py</font>
</center></td></tr></table>
<pre><span class="s0">''' Classes for read / write of matlab (TM) 5 files 
 
The matfile specification last found here: 
 
https://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf 
 
(as of December 5 2008) 
 
================================= 
 Note on functions and mat files 
================================= 
 
The document above does not give any hints as to the storage of matlab 
function handles, or anonymous function handles. I had, therefore, to 
guess the format of matlab arrays of ``mxFUNCTION_CLASS`` and 
``mxOPAQUE_CLASS`` by looking at example mat files. 
 
``mxFUNCTION_CLASS`` stores all types of matlab functions. It seems to 
contain a struct matrix with a set pattern of fields. For anonymous 
functions, a sub-fields of one of these fields seems to contain the 
well-named ``mxOPAQUE_CLASS``. This seems to contain: 
 
* array flags as for any matlab matrix 
* 3 int8 strings 
* a matrix 
 
It seems that whenever the mat file contains a ``mxOPAQUE_CLASS`` 
instance, there is also an un-named matrix (name == '') at the end of 
the mat file. I'll call this the ``__function_workspace__`` matrix. 
 
When I saved two anonymous functions in a mat file, or appended another 
anonymous function to the mat file, there was still only one 
``__function_workspace__`` un-named matrix at the end, but larger than 
that for a mat file with a single anonymous function, suggesting that 
the workspaces for the two functions had been merged. 
 
The ``__function_workspace__`` matrix appears to be of double class 
(``mxCLASS_DOUBLE``), but stored as uint8, the memory for which is in 
the format of a mini .mat file, without the first 124 bytes of the file 
header (the description and the subsystem_offset), but with the version 
U2 bytes, and the S2 endian test bytes. There follow 4 zero bytes, 
presumably for 8 byte padding, and then a series of ``miMATRIX`` 
entries, as in a standard mat file. The ``miMATRIX`` entries appear to 
be series of un-named (name == '') matrices, and may also contain arrays 
of this same mini-mat format. 
 
I guess that: 
 
* saving an anonymous function back to a mat file will need the 
  associated ``__function_workspace__`` matrix saved as well for the 
  anonymous function to work correctly. 
* appending to a mat file that has a ``__function_workspace__`` would 
  involve first pulling off this workspace, appending, checking whether 
  there were any more anonymous functions appended, and then somehow 
  merging the relevant workspaces, and saving at the end of the mat 
  file. 
 
The mat files I was playing with are in ``tests/data``: 
 
* sqr.mat 
* parabola.mat 
* some_functions.mat 
 
See ``tests/test_mio.py:test_mio_funcs.py`` for the debugging 
script I was working with. 
 
Small fragments of current code adapted from matfile.py by Heiko 
Henkelmann; parts of the code for simplify_cells=True adapted from 
http://blog.nephics.com/2019/08/28/better-loadmat-for-scipy/. 
'''</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">zlib</span>

<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>

<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">scipy.sparse</span>

<span class="s2">from </span><span class="s1">._byteordercodes </span><span class="s2">import </span><span class="s1">native_code</span><span class="s2">, </span><span class="s1">swapped_code</span>

<span class="s2">from </span><span class="s1">._miobase </span><span class="s2">import </span><span class="s1">(MatFileReader</span><span class="s2">, </span><span class="s1">docfiller</span><span class="s2">, </span><span class="s1">matdims</span><span class="s2">, </span><span class="s1">read_dtype</span><span class="s2">,</span>
                      <span class="s1">arr_to_chars</span><span class="s2">, </span><span class="s1">arr_dtype_number</span><span class="s2">, </span><span class="s1">MatWriteError</span><span class="s2">,</span>
                      <span class="s1">MatReadError</span><span class="s2">, </span><span class="s1">MatReadWarning)</span>

<span class="s3"># Reader object for matlab 5 format variables</span>
<span class="s2">from </span><span class="s1">._mio5_utils </span><span class="s2">import </span><span class="s1">VarReader5</span>

<span class="s3"># Constants and helper objects</span>
<span class="s2">from </span><span class="s1">._mio5_params </span><span class="s2">import </span><span class="s1">(MatlabObject</span><span class="s2">, </span><span class="s1">MatlabFunction</span><span class="s2">, </span><span class="s1">MDTYPES</span><span class="s2">, </span><span class="s1">NP_TO_MTYPES</span><span class="s2">,</span>
                          <span class="s1">NP_TO_MXTYPES</span><span class="s2">, </span><span class="s1">miCOMPRESSED</span><span class="s2">, </span><span class="s1">miMATRIX</span><span class="s2">, </span><span class="s1">miINT8</span><span class="s2">,</span>
                          <span class="s1">miUTF8</span><span class="s2">, </span><span class="s1">miUINT32</span><span class="s2">, </span><span class="s1">mxCELL_CLASS</span><span class="s2">, </span><span class="s1">mxSTRUCT_CLASS</span><span class="s2">,</span>
                          <span class="s1">mxOBJECT_CLASS</span><span class="s2">, </span><span class="s1">mxCHAR_CLASS</span><span class="s2">, </span><span class="s1">mxSPARSE_CLASS</span><span class="s2">,</span>
                          <span class="s1">mxDOUBLE_CLASS</span><span class="s2">, </span><span class="s1">mclass_info</span><span class="s2">, </span><span class="s1">mat_struct)</span>

<span class="s2">from </span><span class="s1">._streams </span><span class="s2">import </span><span class="s1">ZlibInputStream</span>


<span class="s2">def </span><span class="s1">_has_struct(elem):</span>
    <span class="s0">&quot;&quot;&quot;Determine if elem is an array and if first array item is a struct.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(isinstance(elem</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">(elem.size &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(elem.ndim &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">and</span>
            <span class="s1">isinstance(elem[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mat_struct))</span>


<span class="s2">def </span><span class="s1">_inspect_cell_array(ndarray):</span>
    <span class="s0">&quot;&quot;&quot;Construct lists from cell arrays (loaded as numpy ndarrays), recursing 
    into items if they contain mat_struct objects.&quot;&quot;&quot;</span>
    <span class="s1">elem_list = []</span>
    <span class="s2">for </span><span class="s1">sub_elem </span><span class="s2">in </span><span class="s1">ndarray:</span>
        <span class="s2">if </span><span class="s1">isinstance(sub_elem</span><span class="s2">, </span><span class="s1">mat_struct):</span>
            <span class="s1">elem_list.append(_matstruct_to_dict(sub_elem))</span>
        <span class="s2">elif </span><span class="s1">_has_struct(sub_elem):</span>
            <span class="s1">elem_list.append(_inspect_cell_array(sub_elem))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">elem_list.append(sub_elem)</span>
    <span class="s2">return </span><span class="s1">elem_list</span>


<span class="s2">def </span><span class="s1">_matstruct_to_dict(matobj):</span>
    <span class="s0">&quot;&quot;&quot;Construct nested dicts from mat_struct objects.&quot;&quot;&quot;</span>
    <span class="s1">d = {}</span>
    <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">matobj._fieldnames:</span>
        <span class="s1">elem = matobj.__dict__[f]</span>
        <span class="s2">if </span><span class="s1">isinstance(elem</span><span class="s2">, </span><span class="s1">mat_struct):</span>
            <span class="s1">d[f] = _matstruct_to_dict(elem)</span>
        <span class="s2">elif </span><span class="s1">_has_struct(elem):</span>
            <span class="s1">d[f] = _inspect_cell_array(elem)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">d[f] = elem</span>
    <span class="s2">return </span><span class="s1">d</span>


<span class="s2">def </span><span class="s1">_simplify_cells(d):</span>
    <span class="s0">&quot;&quot;&quot;Convert mat objects in dict to nested dicts.&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">d:</span>
        <span class="s2">if </span><span class="s1">isinstance(d[key]</span><span class="s2">, </span><span class="s1">mat_struct):</span>
            <span class="s1">d[key] = _matstruct_to_dict(d[key])</span>
        <span class="s2">elif </span><span class="s1">_has_struct(d[key]):</span>
            <span class="s1">d[key] = _inspect_cell_array(d[key])</span>
    <span class="s2">return </span><span class="s1">d</span>


<span class="s2">class </span><span class="s1">MatFile5Reader(MatFileReader):</span>
    <span class="s0">''' Reader for Mat 5 mat files 
    Adds the following attribute to base class 
 
    uint16_codec - char codec to use for uint16 char arrays 
        (defaults to system default codec) 
 
    Uses variable reader that has the following stardard interface (see 
    abstract class in ``miobase``:: 
 
       __init__(self, file_reader) 
       read_header(self) 
       array_from_header(self) 
 
    and added interface:: 
 
       set_stream(self, stream) 
       read_full_tag(self) 
 
    '''</span>
    <span class="s1">@docfiller</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">mat_stream</span><span class="s2">,</span>
                 <span class="s1">byte_order=</span><span class="s2">None,</span>
                 <span class="s1">mat_dtype=</span><span class="s2">False,</span>
                 <span class="s1">squeeze_me=</span><span class="s2">False,</span>
                 <span class="s1">chars_as_strings=</span><span class="s2">True,</span>
                 <span class="s1">matlab_compatible=</span><span class="s2">False,</span>
                 <span class="s1">struct_as_record=</span><span class="s2">True,</span>
                 <span class="s1">verify_compressed_data_integrity=</span><span class="s2">True,</span>
                 <span class="s1">uint16_codec=</span><span class="s2">None,</span>
                 <span class="s1">simplify_cells=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">'''Initializer for matlab 5 file format reader 
 
    %(matstream_arg)s 
    %(load_args)s 
    %(struct_arg)s 
    uint16_codec : {None, string} 
        Set codec to use for uint16 char arrays (e.g., 'utf-8'). 
        Use system default codec if None 
        '''</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">mat_stream</span><span class="s2">,</span>
            <span class="s1">byte_order</span><span class="s2">,</span>
            <span class="s1">mat_dtype</span><span class="s2">,</span>
            <span class="s1">squeeze_me</span><span class="s2">,</span>
            <span class="s1">chars_as_strings</span><span class="s2">,</span>
            <span class="s1">matlab_compatible</span><span class="s2">,</span>
            <span class="s1">struct_as_record</span><span class="s2">,</span>
            <span class="s1">verify_compressed_data_integrity</span><span class="s2">,</span>
            <span class="s1">simplify_cells)</span>
        <span class="s3"># Set uint16 codec</span>
        <span class="s2">if not </span><span class="s1">uint16_codec:</span>
            <span class="s1">uint16_codec = sys.getdefaultencoding()</span>
        <span class="s1">self.uint16_codec = uint16_codec</span>
        <span class="s3"># placeholders for readers - see initialize_read method</span>
        <span class="s1">self._file_reader = </span><span class="s2">None</span>
        <span class="s1">self._matrix_reader = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">guess_byte_order(self):</span>
        <span class="s0">''' Guess byte order. 
        Sets stream pointer to 0'''</span>
        <span class="s1">self.mat_stream.seek(</span><span class="s4">126</span><span class="s1">)</span>
        <span class="s1">mi = self.mat_stream.read(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.mat_stream.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">mi == </span><span class="s5">b'IM' </span><span class="s2">and </span><span class="s6">'&lt;' </span><span class="s2">or </span><span class="s6">'&gt;'</span>

    <span class="s2">def </span><span class="s1">read_file_header(self):</span>
        <span class="s0">''' Read in mat 5 file header '''</span>
        <span class="s1">hdict = {}</span>
        <span class="s1">hdr_dtype = MDTYPES[self.byte_order][</span><span class="s6">'dtypes'</span><span class="s1">][</span><span class="s6">'file_header'</span><span class="s1">]</span>
        <span class="s1">hdr = read_dtype(self.mat_stream</span><span class="s2">, </span><span class="s1">hdr_dtype)</span>
        <span class="s1">hdict[</span><span class="s6">'__header__'</span><span class="s1">] = hdr[</span><span class="s6">'description'</span><span class="s1">].item().strip(</span><span class="s5">b' </span><span class="s2">\t\n\000</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">v_major = hdr[</span><span class="s6">'version'</span><span class="s1">] &gt;&gt; </span><span class="s4">8</span>
        <span class="s1">v_minor = hdr[</span><span class="s6">'version'</span><span class="s1">] &amp; </span><span class="s4">0xFF</span>
        <span class="s1">hdict[</span><span class="s6">'__version__'</span><span class="s1">] = </span><span class="s6">'%d.%d' </span><span class="s1">% (v_major</span><span class="s2">, </span><span class="s1">v_minor)</span>
        <span class="s2">return </span><span class="s1">hdict</span>

    <span class="s2">def </span><span class="s1">initialize_read(self):</span>
        <span class="s0">''' Run when beginning read of variables 
 
        Sets up readers from parameters in `self` 
        '''</span>
        <span class="s3"># reader for top level stream. We need this extra top-level</span>
        <span class="s3"># reader because we use the matrix_reader object to contain</span>
        <span class="s3"># compressed matrices (so they have their own stream)</span>
        <span class="s1">self._file_reader = VarReader5(self)</span>
        <span class="s3"># reader for matrix streams</span>
        <span class="s1">self._matrix_reader = VarReader5(self)</span>

    <span class="s2">def </span><span class="s1">read_var_header(self):</span>
        <span class="s0">''' Read header, return header, next position 
 
        Header has to define at least .name and .is_global 
 
        Parameters 
        ---------- 
        None 
 
        Returns 
        ------- 
        header : object 
           object that can be passed to self.read_var_array, and that 
           has attributes .name and .is_global 
        next_position : int 
           position in stream of next variable 
        '''</span>
        <span class="s1">mdtype</span><span class="s2">, </span><span class="s1">byte_count = self._file_reader.read_full_tag()</span>
        <span class="s2">if not </span><span class="s1">byte_count &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s6">&quot;Did not read any bytes&quot;</span><span class="s1">)</span>
        <span class="s1">next_pos = self.mat_stream.tell() + byte_count</span>
        <span class="s2">if </span><span class="s1">mdtype == miCOMPRESSED:</span>
            <span class="s3"># Make new stream from compressed data</span>
            <span class="s1">stream = ZlibInputStream(self.mat_stream</span><span class="s2">, </span><span class="s1">byte_count)</span>
            <span class="s1">self._matrix_reader.set_stream(stream)</span>
            <span class="s1">check_stream_limit = self.verify_compressed_data_integrity</span>
            <span class="s1">mdtype</span><span class="s2">, </span><span class="s1">byte_count = self._matrix_reader.read_full_tag()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">check_stream_limit = </span><span class="s2">False</span>
            <span class="s1">self._matrix_reader.set_stream(self.mat_stream)</span>
        <span class="s2">if not </span><span class="s1">mdtype == miMATRIX:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s6">'Expecting miMATRIX type here, got %d' </span><span class="s1">% mdtype)</span>
        <span class="s1">header = self._matrix_reader.read_header(check_stream_limit)</span>
        <span class="s2">return </span><span class="s1">header</span><span class="s2">, </span><span class="s1">next_pos</span>

    <span class="s2">def </span><span class="s1">read_var_array(self</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">process=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">''' Read array, given `header` 
 
        Parameters 
        ---------- 
        header : header object 
           object with fields defining variable header 
        process : {True, False} bool, optional 
           If True, apply recursive post-processing during loading of 
           array. 
 
        Returns 
        ------- 
        arr : array 
           array with post-processing applied or not according to 
           `process`. 
        '''</span>
        <span class="s2">return </span><span class="s1">self._matrix_reader.array_from_header(header</span><span class="s2">, </span><span class="s1">process)</span>

    <span class="s2">def </span><span class="s1">get_variables(self</span><span class="s2">, </span><span class="s1">variable_names=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">''' get variables from stream as dictionary 
 
        variable_names   - optional list of variable names to get 
 
        If variable_names is None, then get all variables in file 
        '''</span>
        <span class="s2">if </span><span class="s1">isinstance(variable_names</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">variable_names = [variable_names]</span>
        <span class="s2">elif </span><span class="s1">variable_names </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">variable_names = list(variable_names)</span>

        <span class="s1">self.mat_stream.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># Here we pass all the parameters in self to the reading objects</span>
        <span class="s1">self.initialize_read()</span>
        <span class="s1">mdict = self.read_file_header()</span>
        <span class="s1">mdict[</span><span class="s6">'__globals__'</span><span class="s1">] = []</span>
        <span class="s2">while not </span><span class="s1">self.end_of_stream():</span>
            <span class="s1">hdr</span><span class="s2">, </span><span class="s1">next_position = self.read_var_header()</span>
            <span class="s1">name = </span><span class="s6">'None' </span><span class="s2">if </span><span class="s1">hdr.name </span><span class="s2">is None else </span><span class="s1">hdr.name.decode(</span><span class="s6">'latin1'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">mdict:</span>
                <span class="s1">warnings.warn(</span><span class="s6">'Duplicate variable name &quot;%s&quot; in stream'</span>
                              <span class="s6">' - replacing previous with new</span><span class="s2">\n</span><span class="s6">'</span>
                              <span class="s6">'Consider mio5.varmats_from_mat to split '</span>
                              <span class="s6">'file into single variable files' </span><span class="s1">% name</span><span class="s2">,</span>
                              <span class="s1">MatReadWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s6">''</span><span class="s1">:</span>
                <span class="s3"># can only be a matlab 7 function workspace</span>
                <span class="s1">name = </span><span class="s6">'__function_workspace__'</span>
                <span class="s3"># We want to keep this raw because mat_dtype processing</span>
                <span class="s3"># will break the format (uint8 as mxDOUBLE_CLASS)</span>
                <span class="s1">process = </span><span class="s2">False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">process = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">variable_names </span><span class="s2">is not None and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">variable_names:</span>
                <span class="s1">self.mat_stream.seek(next_position)</span>
                <span class="s2">continue</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">res = self.read_var_array(hdr</span><span class="s2">, </span><span class="s1">process)</span>
            <span class="s2">except </span><span class="s1">MatReadError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s6">'Unreadable variable &quot;%s&quot;, because &quot;%s&quot;' </span><span class="s1">%</span>
                    <span class="s1">(name</span><span class="s2">, </span><span class="s1">err)</span><span class="s2">,</span>
                    <span class="s1">Warning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
                <span class="s1">res = </span><span class="s6">&quot;Read error: %s&quot; </span><span class="s1">% err</span>
            <span class="s1">self.mat_stream.seek(next_position)</span>
            <span class="s1">mdict[name] = res</span>
            <span class="s2">if </span><span class="s1">hdr.is_global:</span>
                <span class="s1">mdict[</span><span class="s6">'__globals__'</span><span class="s1">].append(name)</span>
            <span class="s2">if </span><span class="s1">variable_names </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">variable_names.remove(name)</span>
                <span class="s2">if </span><span class="s1">len(variable_names) == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">self.simplify_cells:</span>
            <span class="s2">return </span><span class="s1">_simplify_cells(mdict)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">mdict</span>

    <span class="s2">def </span><span class="s1">list_variables(self):</span>
        <span class="s0">''' list variables from stream '''</span>
        <span class="s1">self.mat_stream.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># Here we pass all the parameters in self to the reading objects</span>
        <span class="s1">self.initialize_read()</span>
        <span class="s1">self.read_file_header()</span>
        <span class="s1">vars = []</span>
        <span class="s2">while not </span><span class="s1">self.end_of_stream():</span>
            <span class="s1">hdr</span><span class="s2">, </span><span class="s1">next_position = self.read_var_header()</span>
            <span class="s1">name = </span><span class="s6">'None' </span><span class="s2">if </span><span class="s1">hdr.name </span><span class="s2">is None else </span><span class="s1">hdr.name.decode(</span><span class="s6">'latin1'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s6">''</span><span class="s1">:</span>
                <span class="s3"># can only be a matlab 7 function workspace</span>
                <span class="s1">name = </span><span class="s6">'__function_workspace__'</span>

            <span class="s1">shape = self._matrix_reader.shape_from_header(hdr)</span>
            <span class="s2">if </span><span class="s1">hdr.is_logical:</span>
                <span class="s1">info = </span><span class="s6">'logical'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">info = mclass_info.get(hdr.mclass</span><span class="s2">, </span><span class="s6">'unknown'</span><span class="s1">)</span>
            <span class="s1">vars.append((name</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">info))</span>

            <span class="s1">self.mat_stream.seek(next_position)</span>
        <span class="s2">return </span><span class="s1">vars</span>


<span class="s2">def </span><span class="s1">varmats_from_mat(file_obj):</span>
    <span class="s0">&quot;&quot;&quot; Pull variables out of mat 5 file as a sequence of mat file objects 
 
    This can be useful with a difficult mat file, containing unreadable 
    variables. This routine pulls the variables out in raw form and puts them, 
    unread, back into a file stream for saving or reading. Another use is the 
    pathological case where there is more than one variable of the same name in 
    the file; this routine returns the duplicates, whereas the standard reader 
    will overwrite duplicates in the returned dictionary. 
 
    The file pointer in `file_obj` will be undefined. File pointers for the 
    returned file-like objects are set at 0. 
 
    Parameters 
    ---------- 
    file_obj : file-like 
        file object containing mat file 
 
    Returns 
    ------- 
    named_mats : list 
        list contains tuples of (name, BytesIO) where BytesIO is a file-like 
        object containing mat file contents as for a single variable. The 
        BytesIO contains a string with the original header and a single var. If 
        ``var_file_obj`` is an individual BytesIO instance, then save as a mat 
        file with something like ``open('test.mat', 
        'wb').write(var_file_obj.read())`` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.io 
 
    BytesIO is from the ``io`` module in Python 3, and is ``cStringIO`` for 
    Python &lt; 3. 
 
    &gt;&gt;&gt; mat_fileobj = BytesIO() 
    &gt;&gt;&gt; scipy.io.savemat(mat_fileobj, {'b': np.arange(10), 'a': 'a string'}) 
    &gt;&gt;&gt; varmats = varmats_from_mat(mat_fileobj) 
    &gt;&gt;&gt; sorted([name for name, str_obj in varmats]) 
    ['a', 'b'] 
    &quot;&quot;&quot;</span>
    <span class="s1">rdr = MatFile5Reader(file_obj)</span>
    <span class="s1">file_obj.seek(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s3"># Raw read of top-level file header</span>
    <span class="s1">hdr_len = MDTYPES[native_code][</span><span class="s6">'dtypes'</span><span class="s1">][</span><span class="s6">'file_header'</span><span class="s1">].itemsize</span>
    <span class="s1">raw_hdr = file_obj.read(hdr_len)</span>
    <span class="s3"># Initialize variable reading</span>
    <span class="s1">file_obj.seek(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">rdr.initialize_read()</span>
    <span class="s1">rdr.read_file_header()</span>
    <span class="s1">next_position = file_obj.tell()</span>
    <span class="s1">named_mats = []</span>
    <span class="s2">while not </span><span class="s1">rdr.end_of_stream():</span>
        <span class="s1">start_position = next_position</span>
        <span class="s1">hdr</span><span class="s2">, </span><span class="s1">next_position = rdr.read_var_header()</span>
        <span class="s1">name = </span><span class="s6">'None' </span><span class="s2">if </span><span class="s1">hdr.name </span><span class="s2">is None else </span><span class="s1">hdr.name.decode(</span><span class="s6">'latin1'</span><span class="s1">)</span>
        <span class="s3"># Read raw variable string</span>
        <span class="s1">file_obj.seek(start_position)</span>
        <span class="s1">byte_count = next_position - start_position</span>
        <span class="s1">var_str = file_obj.read(byte_count)</span>
        <span class="s3"># write to stringio object</span>
        <span class="s1">out_obj = BytesIO()</span>
        <span class="s1">out_obj.write(raw_hdr)</span>
        <span class="s1">out_obj.write(var_str)</span>
        <span class="s1">out_obj.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">named_mats.append((name</span><span class="s2">, </span><span class="s1">out_obj))</span>
    <span class="s2">return </span><span class="s1">named_mats</span>


<span class="s2">class </span><span class="s1">EmptyStructMarker:</span>
    <span class="s0">&quot;&quot;&quot; Class to indicate presence of empty matlab struct on output &quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">to_writeable(source):</span>
    <span class="s0">''' Convert input object ``source`` to something we can write 
 
    Parameters 
    ---------- 
    source : object 
 
    Returns 
    ------- 
    arr : None or ndarray or EmptyStructMarker 
        If `source` cannot be converted to something we can write to a matfile, 
        return None.  If `source` is equivalent to an empty dictionary, return 
        ``EmptyStructMarker``.  Otherwise return `source` converted to an 
        ndarray with contents for writing to matfile. 
    '''</span>
    <span class="s2">if </span><span class="s1">isinstance(source</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">return </span><span class="s1">source</span>
    <span class="s2">if </span><span class="s1">source </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return None</span>
    <span class="s2">if </span><span class="s1">hasattr(source</span><span class="s2">, </span><span class="s6">&quot;__array__&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">np.asarray(source)</span>
    <span class="s3"># Objects that implement mappings</span>
    <span class="s1">is_mapping = (hasattr(source</span><span class="s2">, </span><span class="s6">'keys'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(source</span><span class="s2">, </span><span class="s6">'values'</span><span class="s1">) </span><span class="s2">and</span>
                  <span class="s1">hasattr(source</span><span class="s2">, </span><span class="s6">'items'</span><span class="s1">))</span>
    <span class="s3"># Objects that don't implement mappings, but do have dicts</span>
    <span class="s2">if </span><span class="s1">isinstance(source</span><span class="s2">, </span><span class="s1">np.generic):</span>
        <span class="s3"># NumPy scalars are never mappings (PyPy issue workaround)</span>
        <span class="s2">pass</span>
    <span class="s2">elif not </span><span class="s1">is_mapping </span><span class="s2">and </span><span class="s1">hasattr(source</span><span class="s2">, </span><span class="s6">'__dict__'</span><span class="s1">):</span>
        <span class="s1">source = {key: value </span><span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">source.__dict__.items()</span>
                      <span class="s2">if not </span><span class="s1">key.startswith(</span><span class="s6">'_'</span><span class="s1">)}</span>
        <span class="s1">is_mapping = </span><span class="s2">True</span>
    <span class="s2">if </span><span class="s1">is_mapping:</span>
        <span class="s1">dtype = []</span>
        <span class="s1">values = []</span>
        <span class="s2">for </span><span class="s1">field</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">source.items():</span>
            <span class="s2">if </span><span class="s1">(isinstance(field</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and</span>
                    <span class="s1">field[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s6">'_0123456789'</span><span class="s1">):</span>
                <span class="s1">dtype.append((str(field)</span><span class="s2">, </span><span class="s1">object))</span>
                <span class="s1">values.append(value)</span>
        <span class="s2">if </span><span class="s1">dtype:</span>
            <span class="s2">return </span><span class="s1">np.array([tuple(values)]</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">EmptyStructMarker</span>
    <span class="s3"># Next try and convert to an array</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">narr = np.asanyarray(source)</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s1">narr = np.asanyarray(source</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s2">if </span><span class="s1">narr.dtype.type </span><span class="s2">in </span><span class="s1">(object</span><span class="s2">, </span><span class="s1">np.object_) </span><span class="s2">and </span><span class="s1">\</span>
       <span class="s1">narr.shape == () </span><span class="s2">and </span><span class="s1">narr == source:</span>
        <span class="s3"># No interesting conversion possible</span>
        <span class="s2">return None</span>
    <span class="s2">return </span><span class="s1">narr</span>


<span class="s3"># Native byte ordered dtypes for convenience for writers</span>
<span class="s1">NDT_FILE_HDR = MDTYPES[native_code][</span><span class="s6">'dtypes'</span><span class="s1">][</span><span class="s6">'file_header'</span><span class="s1">]</span>
<span class="s1">NDT_TAG_FULL = MDTYPES[native_code][</span><span class="s6">'dtypes'</span><span class="s1">][</span><span class="s6">'tag_full'</span><span class="s1">]</span>
<span class="s1">NDT_TAG_SMALL = MDTYPES[native_code][</span><span class="s6">'dtypes'</span><span class="s1">][</span><span class="s6">'tag_smalldata'</span><span class="s1">]</span>
<span class="s1">NDT_ARRAY_FLAGS = MDTYPES[native_code][</span><span class="s6">'dtypes'</span><span class="s1">][</span><span class="s6">'array_flags'</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">VarWriter5:</span>
    <span class="s0">''' Generic matlab matrix writing class '''</span>
    <span class="s1">mat_tag = np.zeros(()</span><span class="s2">, </span><span class="s1">NDT_TAG_FULL)</span>
    <span class="s1">mat_tag[</span><span class="s6">'mdtype'</span><span class="s1">] = miMATRIX</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file_writer):</span>
        <span class="s1">self.file_stream = file_writer.file_stream</span>
        <span class="s1">self.unicode_strings = file_writer.unicode_strings</span>
        <span class="s1">self.long_field_names = file_writer.long_field_names</span>
        <span class="s1">self.oned_as = file_writer.oned_as</span>
        <span class="s3"># These are used for top level writes, and unset after</span>
        <span class="s1">self._var_name = </span><span class="s2">None</span>
        <span class="s1">self._var_is_global = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">write_bytes(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s1">self.file_stream.write(arr.tobytes(order=</span><span class="s6">'F'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">write_string(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s1">self.file_stream.write(s)</span>

    <span class="s2">def </span><span class="s1">write_element(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">mdtype=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">''' write tag and data '''</span>
        <span class="s2">if </span><span class="s1">mdtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">mdtype = NP_TO_MTYPES[arr.dtype.str[</span><span class="s4">1</span><span class="s1">:]]</span>
        <span class="s3"># Array needs to be in native byte order</span>
        <span class="s2">if </span><span class="s1">arr.dtype.byteorder == swapped_code:</span>
            <span class="s1">arr = arr.byteswap().newbyteorder()</span>
        <span class="s1">byte_count = arr.size*arr.itemsize</span>
        <span class="s2">if </span><span class="s1">byte_count &lt;= </span><span class="s4">4</span><span class="s1">:</span>
            <span class="s1">self.write_smalldata_element(arr</span><span class="s2">, </span><span class="s1">mdtype</span><span class="s2">, </span><span class="s1">byte_count)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.write_regular_element(arr</span><span class="s2">, </span><span class="s1">mdtype</span><span class="s2">, </span><span class="s1">byte_count)</span>

    <span class="s2">def </span><span class="s1">write_smalldata_element(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">mdtype</span><span class="s2">, </span><span class="s1">byte_count):</span>
        <span class="s3"># write tag with embedded data</span>
        <span class="s1">tag = np.zeros(()</span><span class="s2">, </span><span class="s1">NDT_TAG_SMALL)</span>
        <span class="s1">tag[</span><span class="s6">'byte_count_mdtype'</span><span class="s1">] = (byte_count &lt;&lt; </span><span class="s4">16</span><span class="s1">) + mdtype</span>
        <span class="s3"># if arr.tobytes is &lt; 4, the element will be zero-padded as needed.</span>
        <span class="s1">tag[</span><span class="s6">'data'</span><span class="s1">] = arr.tobytes(order=</span><span class="s6">'F'</span><span class="s1">)</span>
        <span class="s1">self.write_bytes(tag)</span>

    <span class="s2">def </span><span class="s1">write_regular_element(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">mdtype</span><span class="s2">, </span><span class="s1">byte_count):</span>
        <span class="s3"># write tag, data</span>
        <span class="s1">tag = np.zeros(()</span><span class="s2">, </span><span class="s1">NDT_TAG_FULL)</span>
        <span class="s1">tag[</span><span class="s6">'mdtype'</span><span class="s1">] = mdtype</span>
        <span class="s1">tag[</span><span class="s6">'byte_count'</span><span class="s1">] = byte_count</span>
        <span class="s1">self.write_bytes(tag)</span>
        <span class="s1">self.write_bytes(arr)</span>
        <span class="s3"># pad to next 64-bit boundary</span>
        <span class="s1">bc_mod_8 = byte_count % </span><span class="s4">8</span>
        <span class="s2">if </span><span class="s1">bc_mod_8:</span>
            <span class="s1">self.file_stream.write(</span><span class="s5">b'</span><span class="s2">\x00</span><span class="s5">' </span><span class="s1">* (</span><span class="s4">8</span><span class="s1">-bc_mod_8))</span>

    <span class="s2">def </span><span class="s1">write_header(self</span><span class="s2">,</span>
                     <span class="s1">shape</span><span class="s2">,</span>
                     <span class="s1">mclass</span><span class="s2">,</span>
                     <span class="s1">is_complex=</span><span class="s2">False,</span>
                     <span class="s1">is_logical=</span><span class="s2">False,</span>
                     <span class="s1">nzmax=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">''' Write header for given data options 
        shape : sequence 
           array shape 
        mclass      - mat5 matrix class 
        is_complex  - True if matrix is complex 
        is_logical  - True if matrix is logical 
        nzmax        - max non zero elements for sparse arrays 
 
        We get the name and the global flag from the object, and reset 
        them to defaults after we've used them 
        '''</span>
        <span class="s3"># get name and is_global from one-shot object store</span>
        <span class="s1">name = self._var_name</span>
        <span class="s1">is_global = self._var_is_global</span>
        <span class="s3"># initialize the top-level matrix tag, store position</span>
        <span class="s1">self._mat_tag_pos = self.file_stream.tell()</span>
        <span class="s1">self.write_bytes(self.mat_tag)</span>
        <span class="s3"># write array flags (complex, global, logical, class, nzmax)</span>
        <span class="s1">af = np.zeros(()</span><span class="s2">, </span><span class="s1">NDT_ARRAY_FLAGS)</span>
        <span class="s1">af[</span><span class="s6">'data_type'</span><span class="s1">] = miUINT32</span>
        <span class="s1">af[</span><span class="s6">'byte_count'</span><span class="s1">] = </span><span class="s4">8</span>
        <span class="s1">flags = is_complex &lt;&lt; </span><span class="s4">3 </span><span class="s1">| is_global &lt;&lt; </span><span class="s4">2 </span><span class="s1">| is_logical &lt;&lt; </span><span class="s4">1</span>
        <span class="s1">af[</span><span class="s6">'flags_class'</span><span class="s1">] = mclass | flags &lt;&lt; </span><span class="s4">8</span>
        <span class="s1">af[</span><span class="s6">'nzmax'</span><span class="s1">] = nzmax</span>
        <span class="s1">self.write_bytes(af)</span>
        <span class="s3"># shape</span>
        <span class="s1">self.write_element(np.array(shape</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s6">'i4'</span><span class="s1">))</span>
        <span class="s3"># write name</span>
        <span class="s1">name = np.asarray(name)</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s6">''</span><span class="s1">:  </span><span class="s3"># empty string zero-terminated</span>
            <span class="s1">self.write_smalldata_element(name</span><span class="s2">, </span><span class="s1">miINT8</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.write_element(name</span><span class="s2">, </span><span class="s1">miINT8)</span>
        <span class="s3"># reset the one-shot store to defaults</span>
        <span class="s1">self._var_name = </span><span class="s6">''</span>
        <span class="s1">self._var_is_global = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">update_matrix_tag(self</span><span class="s2">, </span><span class="s1">start_pos):</span>
        <span class="s1">curr_pos = self.file_stream.tell()</span>
        <span class="s1">self.file_stream.seek(start_pos)</span>
        <span class="s1">byte_count = curr_pos - start_pos - </span><span class="s4">8</span>
        <span class="s2">if </span><span class="s1">byte_count &gt;= </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">MatWriteError(</span><span class="s6">&quot;Matrix too large to save with Matlab &quot;</span>
                                <span class="s6">&quot;5 format&quot;</span><span class="s1">)</span>
        <span class="s1">self.mat_tag[</span><span class="s6">'byte_count'</span><span class="s1">] = byte_count</span>
        <span class="s1">self.write_bytes(self.mat_tag)</span>
        <span class="s1">self.file_stream.seek(curr_pos)</span>

    <span class="s2">def </span><span class="s1">write_top(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">is_global):</span>
        <span class="s0">&quot;&quot;&quot; Write variable at top level of mat file 
 
        Parameters 
        ---------- 
        arr : array_like 
            array-like object to create writer for 
        name : str, optional 
            name as it will appear in matlab workspace 
            default is empty string 
        is_global : {False, True}, optional 
            whether variable will be global on load into matlab 
        &quot;&quot;&quot;</span>
        <span class="s3"># these are set before the top-level header write, and unset at</span>
        <span class="s3"># the end of the same write, because they do not apply for lower levels</span>
        <span class="s1">self._var_is_global = is_global</span>
        <span class="s1">self._var_name = name</span>
        <span class="s3"># write the header and data</span>
        <span class="s1">self.write(arr)</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s0">''' Write `arr` to stream at top and sub levels 
 
        Parameters 
        ---------- 
        arr : array_like 
            array-like object to create writer for 
        '''</span>
        <span class="s3"># store position, so we can update the matrix tag</span>
        <span class="s1">mat_tag_pos = self.file_stream.tell()</span>
        <span class="s3"># First check if these are sparse</span>
        <span class="s2">if </span><span class="s1">scipy.sparse.issparse(arr):</span>
            <span class="s1">self.write_sparse(arr)</span>
            <span class="s1">self.update_matrix_tag(mat_tag_pos)</span>
            <span class="s2">return</span>
        <span class="s3"># Try to convert things that aren't arrays</span>
        <span class="s1">narr = to_writeable(arr)</span>
        <span class="s2">if </span><span class="s1">narr </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s6">'Could not convert %s (type %s) to array'</span>
                            <span class="s1">% (arr</span><span class="s2">, </span><span class="s1">type(arr)))</span>
        <span class="s2">if </span><span class="s1">isinstance(narr</span><span class="s2">, </span><span class="s1">MatlabObject):</span>
            <span class="s1">self.write_object(narr)</span>
        <span class="s2">elif </span><span class="s1">isinstance(narr</span><span class="s2">, </span><span class="s1">MatlabFunction):</span>
            <span class="s2">raise </span><span class="s1">MatWriteError(</span><span class="s6">'Cannot write matlab functions'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">narr </span><span class="s2">is </span><span class="s1">EmptyStructMarker:  </span><span class="s3"># empty struct array</span>
            <span class="s1">self.write_empty_struct()</span>
        <span class="s2">elif </span><span class="s1">narr.dtype.fields:  </span><span class="s3"># struct array</span>
            <span class="s1">self.write_struct(narr)</span>
        <span class="s2">elif </span><span class="s1">narr.dtype.hasobject:  </span><span class="s3"># cell array</span>
            <span class="s1">self.write_cells(narr)</span>
        <span class="s2">elif </span><span class="s1">narr.dtype.kind </span><span class="s2">in </span><span class="s1">(</span><span class="s6">'U'</span><span class="s2">, </span><span class="s6">'S'</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">self.unicode_strings:</span>
                <span class="s1">codec = </span><span class="s6">'UTF8'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">codec = </span><span class="s6">'ascii'</span>
            <span class="s1">self.write_char(narr</span><span class="s2">, </span><span class="s1">codec)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.write_numeric(narr)</span>
        <span class="s1">self.update_matrix_tag(mat_tag_pos)</span>

    <span class="s2">def </span><span class="s1">write_numeric(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s1">imagf = arr.dtype.kind == </span><span class="s6">'c'</span>
        <span class="s1">logif = arr.dtype.kind == </span><span class="s6">'b'</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">mclass = NP_TO_MXTYPES[arr.dtype.str[</span><span class="s4">1</span><span class="s1">:]]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s3"># No matching matlab type, probably complex256 / float128 / float96</span>
            <span class="s3"># Cast data to complex128 / float64.</span>
            <span class="s2">if </span><span class="s1">imagf:</span>
                <span class="s1">arr = arr.astype(</span><span class="s6">'c128'</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">logif:</span>
                <span class="s1">arr = arr.astype(</span><span class="s6">'i1'</span><span class="s1">)  </span><span class="s3"># Should only contain 0/1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">arr = arr.astype(</span><span class="s6">'f8'</span><span class="s1">)</span>
            <span class="s1">mclass = mxDOUBLE_CLASS</span>
        <span class="s1">self.write_header(matdims(arr</span><span class="s2">, </span><span class="s1">self.oned_as)</span><span class="s2">,</span>
                          <span class="s1">mclass</span><span class="s2">,</span>
                          <span class="s1">is_complex=imagf</span><span class="s2">,</span>
                          <span class="s1">is_logical=logif)</span>
        <span class="s2">if </span><span class="s1">imagf:</span>
            <span class="s1">self.write_element(arr.real)</span>
            <span class="s1">self.write_element(arr.imag)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.write_element(arr)</span>

    <span class="s2">def </span><span class="s1">write_char(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">codec=</span><span class="s6">'ascii'</span><span class="s1">):</span>
        <span class="s0">''' Write string array `arr` with given `codec` 
        '''</span>
        <span class="s2">if </span><span class="s1">arr.size == </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">np.all(arr == </span><span class="s6">''</span><span class="s1">):</span>
            <span class="s3"># This an empty string array or a string array containing</span>
            <span class="s3"># only empty strings. Matlab cannot distinguish between a</span>
            <span class="s3"># string array that is empty, and a string array containing</span>
            <span class="s3"># only empty strings, because it stores strings as arrays of</span>
            <span class="s3"># char. There is no way of having an array of char that is</span>
            <span class="s3"># not empty, but contains an empty string. We have to</span>
            <span class="s3"># special-case the array-with-empty-strings because even</span>
            <span class="s3"># empty strings have zero padding, which would otherwise</span>
            <span class="s3"># appear in matlab as a string with a space.</span>
            <span class="s1">shape = (</span><span class="s4">0</span><span class="s2">,</span><span class="s1">) * np.max([arr.ndim</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
            <span class="s1">self.write_header(shape</span><span class="s2">, </span><span class="s1">mxCHAR_CLASS)</span>
            <span class="s1">self.write_smalldata_element(arr</span><span class="s2">, </span><span class="s1">miUTF8</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s3"># non-empty string.</span>
        <span class="s3">#</span>
        <span class="s3"># Convert to char array</span>
        <span class="s1">arr = arr_to_chars(arr)</span>
        <span class="s3"># We have to write the shape directly, because we are going</span>
        <span class="s3"># recode the characters, and the resulting stream of chars</span>
        <span class="s3"># may have a different length</span>
        <span class="s1">shape = arr.shape</span>
        <span class="s1">self.write_header(shape</span><span class="s2">, </span><span class="s1">mxCHAR_CLASS)</span>
        <span class="s2">if </span><span class="s1">arr.dtype.kind == </span><span class="s6">'U' </span><span class="s2">and </span><span class="s1">arr.size:</span>
            <span class="s3"># Make one long string from all the characters. We need to</span>
            <span class="s3"># transpose here, because we're flattening the array, before</span>
            <span class="s3"># we write the bytes. The bytes have to be written in</span>
            <span class="s3"># Fortran order.</span>
            <span class="s1">n_chars = np.prod(shape)</span>
            <span class="s1">st_arr = np.ndarray(shape=()</span><span class="s2">,</span>
                                <span class="s1">dtype=arr_dtype_number(arr</span><span class="s2">, </span><span class="s1">n_chars)</span><span class="s2">,</span>
                                <span class="s1">buffer=arr.T.copy())  </span><span class="s3"># Fortran order</span>
            <span class="s3"># Recode with codec to give byte string</span>
            <span class="s1">st = st_arr.item().encode(codec)</span>
            <span class="s3"># Reconstruct as 1-D byte array</span>
            <span class="s1">arr = np.ndarray(shape=(len(st)</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">dtype=</span><span class="s6">'S1'</span><span class="s2">,</span>
                             <span class="s1">buffer=st)</span>
        <span class="s1">self.write_element(arr</span><span class="s2">, </span><span class="s1">mdtype=miUTF8)</span>

    <span class="s2">def </span><span class="s1">write_sparse(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s0">''' Sparse matrices are 2D 
        '''</span>
        <span class="s1">A = arr.tocsc()  </span><span class="s3"># convert to sparse CSC format</span>
        <span class="s1">A.sort_indices()     </span><span class="s3"># MATLAB expects sorted row indices</span>
        <span class="s1">is_complex = (A.dtype.kind == </span><span class="s6">'c'</span><span class="s1">)</span>
        <span class="s1">is_logical = (A.dtype.kind == </span><span class="s6">'b'</span><span class="s1">)</span>
        <span class="s1">nz = A.nnz</span>
        <span class="s1">self.write_header(matdims(arr</span><span class="s2">, </span><span class="s1">self.oned_as)</span><span class="s2">,</span>
                          <span class="s1">mxSPARSE_CLASS</span><span class="s2">,</span>
                          <span class="s1">is_complex=is_complex</span><span class="s2">,</span>
                          <span class="s1">is_logical=is_logical</span><span class="s2">,</span>
                          <span class="s3"># matlab won't load file with 0 nzmax</span>
                          <span class="s1">nzmax=</span><span class="s4">1 </span><span class="s2">if </span><span class="s1">nz == </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">nz)</span>
        <span class="s1">self.write_element(A.indices.astype(</span><span class="s6">'i4'</span><span class="s1">))</span>
        <span class="s1">self.write_element(A.indptr.astype(</span><span class="s6">'i4'</span><span class="s1">))</span>
        <span class="s1">self.write_element(A.data.real)</span>
        <span class="s2">if </span><span class="s1">is_complex:</span>
            <span class="s1">self.write_element(A.data.imag)</span>

    <span class="s2">def </span><span class="s1">write_cells(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s1">self.write_header(matdims(arr</span><span class="s2">, </span><span class="s1">self.oned_as)</span><span class="s2">,</span>
                          <span class="s1">mxCELL_CLASS)</span>
        <span class="s3"># loop over data, column major</span>
        <span class="s1">A = np.atleast_2d(arr).flatten(</span><span class="s6">'F'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">el </span><span class="s2">in </span><span class="s1">A:</span>
            <span class="s1">self.write(el)</span>

    <span class="s2">def </span><span class="s1">write_empty_struct(self):</span>
        <span class="s1">self.write_header((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">mxSTRUCT_CLASS)</span>
        <span class="s3"># max field name length set to 1 in an example matlab struct</span>
        <span class="s1">self.write_element(np.array(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=np.int32))</span>
        <span class="s3"># Field names element is empty</span>
        <span class="s1">self.write_element(np.array([]</span><span class="s2">, </span><span class="s1">dtype=np.int8))</span>

    <span class="s2">def </span><span class="s1">write_struct(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s1">self.write_header(matdims(arr</span><span class="s2">, </span><span class="s1">self.oned_as)</span><span class="s2">,</span>
                          <span class="s1">mxSTRUCT_CLASS)</span>
        <span class="s1">self._write_items(arr)</span>

    <span class="s2">def </span><span class="s1">_write_items(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s3"># write fieldnames</span>
        <span class="s1">fieldnames = [f[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">arr.dtype.descr]</span>
        <span class="s1">length = max([len(fieldname) </span><span class="s2">for </span><span class="s1">fieldname </span><span class="s2">in </span><span class="s1">fieldnames])+</span><span class="s4">1</span>
        <span class="s1">max_length = (self.long_field_names </span><span class="s2">and </span><span class="s4">64</span><span class="s1">) </span><span class="s2">or </span><span class="s4">32</span>
        <span class="s2">if </span><span class="s1">length &gt; max_length:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s6">&quot;Field names are restricted to %d characters&quot; </span><span class="s1">%</span>
                             <span class="s1">(max_length-</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">self.write_element(np.array([length]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s6">'i4'</span><span class="s1">))</span>
        <span class="s1">self.write_element(</span>
            <span class="s1">np.array(fieldnames</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s6">'S%d' </span><span class="s1">% (length))</span><span class="s2">,</span>
            <span class="s1">mdtype=miINT8)</span>
        <span class="s1">A = np.atleast_2d(arr).flatten(</span><span class="s6">'F'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">el </span><span class="s2">in </span><span class="s1">A:</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fieldnames:</span>
                <span class="s1">self.write(el[f])</span>

    <span class="s2">def </span><span class="s1">write_object(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s0">'''Same as writing structs, except different mx class, and extra 
        classname element after header 
        '''</span>
        <span class="s1">self.write_header(matdims(arr</span><span class="s2">, </span><span class="s1">self.oned_as)</span><span class="s2">,</span>
                          <span class="s1">mxOBJECT_CLASS)</span>
        <span class="s1">self.write_element(np.array(arr.classname</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s6">'S'</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">mdtype=miINT8)</span>
        <span class="s1">self._write_items(arr)</span>


<span class="s2">class </span><span class="s1">MatFile5Writer:</span>
    <span class="s0">''' Class for writing mat5 files '''</span>

    <span class="s1">@docfiller</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file_stream</span><span class="s2">,</span>
                 <span class="s1">do_compression=</span><span class="s2">False,</span>
                 <span class="s1">unicode_strings=</span><span class="s2">False,</span>
                 <span class="s1">global_vars=</span><span class="s2">None,</span>
                 <span class="s1">long_field_names=</span><span class="s2">False,</span>
                 <span class="s1">oned_as=</span><span class="s6">'row'</span><span class="s1">):</span>
        <span class="s0">''' Initialize writer for matlab 5 format files 
 
        Parameters 
        ---------- 
        %(do_compression)s 
        %(unicode_strings)s 
        global_vars : None or sequence of strings, optional 
            Names of variables to be marked as global for matlab 
        %(long_fields)s 
        %(oned_as)s 
        '''</span>
        <span class="s1">self.file_stream = file_stream</span>
        <span class="s1">self.do_compression = do_compression</span>
        <span class="s1">self.unicode_strings = unicode_strings</span>
        <span class="s2">if </span><span class="s1">global_vars:</span>
            <span class="s1">self.global_vars = global_vars</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.global_vars = []</span>
        <span class="s1">self.long_field_names = long_field_names</span>
        <span class="s1">self.oned_as = oned_as</span>
        <span class="s1">self._matrix_writer = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">write_file_header(self):</span>
        <span class="s3"># write header</span>
        <span class="s1">hdr = np.zeros(()</span><span class="s2">, </span><span class="s1">NDT_FILE_HDR)</span>
        <span class="s1">hdr[</span><span class="s6">'description'</span><span class="s1">] = </span><span class="s6">'MATLAB 5.0 MAT-file Platform: %s, Created on: %s' </span><span class="s1">\</span>
            <span class="s1">% (os.name</span><span class="s2">,</span><span class="s1">time.asctime())</span>
        <span class="s1">hdr[</span><span class="s6">'version'</span><span class="s1">] = </span><span class="s4">0x0100</span>
        <span class="s1">hdr[</span><span class="s6">'endian_test'</span><span class="s1">] = np.ndarray(shape=()</span><span class="s2">,</span>
                                      <span class="s1">dtype=</span><span class="s6">'S2'</span><span class="s2">,</span>
                                      <span class="s1">buffer=np.uint16(</span><span class="s4">0x4d49</span><span class="s1">))</span>
        <span class="s1">self.file_stream.write(hdr.tobytes())</span>

    <span class="s2">def </span><span class="s1">put_variables(self</span><span class="s2">, </span><span class="s1">mdict</span><span class="s2">, </span><span class="s1">write_header=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">''' Write variables in `mdict` to stream 
 
        Parameters 
        ---------- 
        mdict : mapping 
           mapping with method ``items`` returns name, contents pairs where 
           ``name`` which will appear in the matlab workspace in file load, and 
           ``contents`` is something writeable to a matlab file, such as a NumPy 
           array. 
        write_header : {None, True, False}, optional 
           If True, then write the matlab file header before writing the 
           variables. If None (the default) then write the file header 
           if we are at position 0 in the stream. By setting False 
           here, and setting the stream position to the end of the file, 
           you can append variables to a matlab file 
        '''</span>
        <span class="s3"># write header if requested, or None and start of file</span>
        <span class="s2">if </span><span class="s1">write_header </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">write_header = self.file_stream.tell() == </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">write_header:</span>
            <span class="s1">self.write_file_header()</span>
        <span class="s1">self._matrix_writer = VarWriter5(self)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">var </span><span class="s2">in </span><span class="s1">mdict.items():</span>
            <span class="s2">if </span><span class="s1">name[</span><span class="s4">0</span><span class="s1">] == </span><span class="s6">'_'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">is_global = name </span><span class="s2">in </span><span class="s1">self.global_vars</span>
            <span class="s2">if </span><span class="s1">self.do_compression:</span>
                <span class="s1">stream = BytesIO()</span>
                <span class="s1">self._matrix_writer.file_stream = stream</span>
                <span class="s1">self._matrix_writer.write_top(var</span><span class="s2">, </span><span class="s1">name.encode(</span><span class="s6">'latin1'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">is_global)</span>
                <span class="s1">out_str = zlib.compress(stream.getvalue())</span>
                <span class="s1">tag = np.empty(()</span><span class="s2">, </span><span class="s1">NDT_TAG_FULL)</span>
                <span class="s1">tag[</span><span class="s6">'mdtype'</span><span class="s1">] = miCOMPRESSED</span>
                <span class="s1">tag[</span><span class="s6">'byte_count'</span><span class="s1">] = len(out_str)</span>
                <span class="s1">self.file_stream.write(tag.tobytes())</span>
                <span class="s1">self.file_stream.write(out_str)</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s3"># not compressing</span>
                <span class="s1">self._matrix_writer.write_top(var</span><span class="s2">, </span><span class="s1">name.encode(</span><span class="s6">'latin1'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">is_global)</span>
</pre>
</body>
</html>