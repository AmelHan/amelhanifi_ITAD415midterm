<html>
<head>
<title>contrast.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
contrast.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">f </span><span class="s0">as </span><span class="s1">fdist</span>
<span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">t </span><span class="s0">as </span><span class="s1">student_t</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.tools </span><span class="s0">import </span><span class="s1">clean0</span><span class="s0">, </span><span class="s1">fullrank</span>
<span class="s0">from </span><span class="s1">statsmodels.stats.multitest </span><span class="s0">import </span><span class="s1">multipletests</span>


<span class="s2">#TODO: should this be public if it's just a container?</span>
<span class="s0">class </span><span class="s1">ContrastResults:</span>
    <span class="s3">&quot;&quot;&quot; 
    Class for results of tests of linear restrictions on coefficients in a model. 
 
    This class functions mainly as a container for `t_test`, `f_test` and 
    `wald_test` for the parameters of a model. 
 
    The attributes depend on the statistical test and are either based on the 
    normal, the t, the F or the chisquare distribution. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">t=</span><span class="s0">None, </span><span class="s1">F=</span><span class="s0">None, </span><span class="s1">sd=</span><span class="s0">None, </span><span class="s1">effect=</span><span class="s0">None, </span><span class="s1">df_denom=</span><span class="s0">None,</span>
                 <span class="s1">df_num=</span><span class="s0">None, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s0">, </span><span class="s1">**kwds):</span>

        <span class="s1">self.effect = effect  </span><span class="s2"># Let it be None for F</span>
        <span class="s0">if </span><span class="s1">F </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.distribution = </span><span class="s5">'F'</span>
            <span class="s1">self.fvalue = F</span>
            <span class="s1">self.statistic = self.fvalue</span>
            <span class="s1">self.df_denom = df_denom</span>
            <span class="s1">self.df_num = df_num</span>
            <span class="s1">self.dist = fdist</span>
            <span class="s1">self.dist_args = (df_num</span><span class="s0">, </span><span class="s1">df_denom)</span>
            <span class="s1">self.pvalue = fdist.sf(F</span><span class="s0">, </span><span class="s1">df_num</span><span class="s0">, </span><span class="s1">df_denom)</span>
        <span class="s0">elif </span><span class="s1">t </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.distribution = </span><span class="s5">'t'</span>
            <span class="s1">self.tvalue = t</span>
            <span class="s1">self.statistic = t  </span><span class="s2"># generic alias</span>
            <span class="s1">self.sd = sd</span>
            <span class="s1">self.df_denom = df_denom</span>
            <span class="s1">self.dist = student_t</span>
            <span class="s1">self.dist_args = (df_denom</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">self.pvalue = self.dist.sf(np.abs(t)</span><span class="s0">, </span><span class="s1">df_denom) * </span><span class="s4">2</span>
        <span class="s0">elif </span><span class="s5">'statistic' </span><span class="s0">in </span><span class="s1">kwds:</span>
            <span class="s2"># TODO: currently targeted to normal distribution, and chi2</span>
            <span class="s1">self.distribution = kwds[</span><span class="s5">'distribution'</span><span class="s1">]</span>
            <span class="s1">self.statistic = kwds[</span><span class="s5">'statistic'</span><span class="s1">]</span>
            <span class="s1">self.tvalue = value = kwds[</span><span class="s5">'statistic'</span><span class="s1">]  </span><span class="s2"># keep alias</span>
            <span class="s2"># TODO: for results instance we decided to use tvalues also for normal</span>
            <span class="s1">self.sd = sd</span>
            <span class="s1">self.dist = getattr(stats</span><span class="s0">, </span><span class="s1">self.distribution)</span>
            <span class="s1">self.dist_args = kwds.get(</span><span class="s5">'dist_args'</span><span class="s0">, </span><span class="s1">())</span>
            <span class="s0">if </span><span class="s1">self.distribution == </span><span class="s5">'chi2'</span><span class="s1">:</span>
                <span class="s1">self.pvalue = self.dist.sf(self.statistic</span><span class="s0">, </span><span class="s1">df_denom)</span>
                <span class="s1">self.df_denom = df_denom</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5">&quot;normal&quot;</span>
                <span class="s1">self.pvalue = np.full_like(value</span><span class="s0">, </span><span class="s1">np.nan)</span>
                <span class="s1">not_nan = ~np.isnan(value)</span>
                <span class="s1">self.pvalue[not_nan] = self.dist.sf(np.abs(value[not_nan])) * </span><span class="s4">2</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.pvalue = np.nan</span>

        <span class="s2"># cleanup</span>
        <span class="s2"># should we return python scalar?</span>
        <span class="s1">self.pvalue = np.squeeze(self.pvalue)</span>

        <span class="s0">if </span><span class="s1">self.effect </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.c_names = [</span><span class="s5">'c%d' </span><span class="s1">% ii </span><span class="s0">for </span><span class="s1">ii </span><span class="s0">in </span><span class="s1">range(len(self.effect))]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.c_names = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">conf_int(self</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns the confidence interval of the value, `effect` of the constraint. 
 
        This is currently only available for t and z tests. 
 
        Parameters 
        ---------- 
        alpha : float, optional 
            The significance level for the confidence interval. 
            ie., The default `alpha` = .05 returns a 95% confidence interval. 
 
        Returns 
        ------- 
        ci : ndarray, (k_constraints, 2) 
            The array has the lower and the upper limit of the confidence 
            interval in the columns. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.effect </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># confidence intervals</span>
            <span class="s1">q = self.dist.ppf(</span><span class="s4">1 </span><span class="s1">- alpha / </span><span class="s4">2.</span><span class="s0">, </span><span class="s1">*self.dist_args)</span>
            <span class="s1">lower = self.effect - q * self.sd</span>
            <span class="s1">upper = self.effect + q * self.sd</span>
            <span class="s0">return </span><span class="s1">np.column_stack((lower</span><span class="s0">, </span><span class="s1">upper))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Confidence Interval not available'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.summary().__str__()</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s1">str(self.__class__) + </span><span class="s5">'</span><span class="s0">\n</span><span class="s5">' </span><span class="s1">+ self.__str__()</span>

    <span class="s0">def </span><span class="s1">summary(self</span><span class="s0">, </span><span class="s1">xname=</span><span class="s0">None, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s0">, </span><span class="s1">title=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Summarize the Results of the hypothesis test 
 
        Parameters 
        ---------- 
        xname : list[str], optional 
            Default is `c_##` for ## in the number of regressors 
        alpha : float 
            significance level for the confidence intervals. Default is 
            alpha = 0.05 which implies a confidence level of 95%. 
        title : str, optional 
            Title for the params table. If not None, then this replaces the 
            default title 
 
        Returns 
        ------- 
        smry : str or Summary instance 
            This contains a parameter results table in the case of t or z test 
            in the same form as the parameter results table in the model 
            results summary. 
            For F or Wald test, the return is a string. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.effect </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># TODO: should also add some extra information, e.g. robust cov ?</span>
            <span class="s2"># TODO: can we infer names for constraints, xname in __init__ ?</span>
            <span class="s0">if </span><span class="s1">title </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">title = </span><span class="s5">'Test for Constraints'</span>
            <span class="s0">elif </span><span class="s1">title == </span><span class="s5">''</span><span class="s1">:</span>
                <span class="s2"># do not add any title,</span>
                <span class="s2"># I think SimpleTable skips on None - check</span>
                <span class="s1">title = </span><span class="s0">None</span>
            <span class="s2"># we have everything for a params table</span>
            <span class="s1">use_t = (self.distribution == </span><span class="s5">'t'</span><span class="s1">)</span>
            <span class="s1">yname=</span><span class="s5">'constraints' </span><span class="s2"># Not used in params_frame</span>
            <span class="s0">if </span><span class="s1">xname </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">xname = self.c_names</span>
            <span class="s0">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s0">import </span><span class="s1">summary_params</span>
            <span class="s1">pvalues = np.atleast_1d(self.pvalue)</span>
            <span class="s1">summ = summary_params((self</span><span class="s0">, </span><span class="s1">self.effect</span><span class="s0">, </span><span class="s1">self.sd</span><span class="s0">, </span><span class="s1">self.statistic</span><span class="s0">,</span>
                                   <span class="s1">pvalues</span><span class="s0">, </span><span class="s1">self.conf_int(alpha))</span><span class="s0">,</span>
                                  <span class="s1">yname=yname</span><span class="s0">, </span><span class="s1">xname=xname</span><span class="s0">, </span><span class="s1">use_t=use_t</span><span class="s0">,</span>
                                  <span class="s1">title=title</span><span class="s0">, </span><span class="s1">alpha=alpha)</span>
            <span class="s0">return </span><span class="s1">summ</span>
        <span class="s0">elif </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">'fvalue'</span><span class="s1">):</span>
            <span class="s2"># TODO: create something nicer for these casee</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s5">'&lt;F test: F=%s, p=%s, df_denom=%.3g, df_num=%.3g&gt;' </span><span class="s1">%</span>
                   <span class="s1">(repr(self.fvalue)</span><span class="s0">, </span><span class="s1">self.pvalue</span><span class="s0">, </span><span class="s1">self.df_denom</span><span class="s0">,</span>
                    <span class="s1">self.df_num))</span>
        <span class="s0">elif </span><span class="s1">self.distribution == </span><span class="s5">'chi2'</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s5">'&lt;Wald test (%s): statistic=%s, p-value=%s, df_denom=%.3g&gt;' </span><span class="s1">%</span>
                   <span class="s1">(self.distribution</span><span class="s0">, </span><span class="s1">self.statistic</span><span class="s0">, </span><span class="s1">self.pvalue</span><span class="s0">,</span>
                    <span class="s1">self.df_denom))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># generic</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s5">'&lt;Wald test: statistic=%s, p-value=%s&gt;' </span><span class="s1">%</span>
                   <span class="s1">(self.statistic</span><span class="s0">, </span><span class="s1">self.pvalue))</span>


    <span class="s0">def </span><span class="s1">summary_frame(self</span><span class="s0">, </span><span class="s1">xname=</span><span class="s0">None, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return the parameter table as a pandas DataFrame 
 
        This is only available for t and normal tests 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.effect </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s2"># we have everything for a params table</span>
            <span class="s1">use_t = (self.distribution == </span><span class="s5">'t'</span><span class="s1">)</span>
            <span class="s1">yname=</span><span class="s5">'constraints'  </span><span class="s2"># Not used in params_frame</span>
            <span class="s0">if </span><span class="s1">xname </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">xname = self.c_names</span>
            <span class="s0">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s0">import </span><span class="s1">summary_params_frame</span>
            <span class="s1">summ = summary_params_frame((self</span><span class="s0">, </span><span class="s1">self.effect</span><span class="s0">, </span><span class="s1">self.sd</span><span class="s0">,</span>
                                         <span class="s1">self.statistic</span><span class="s0">,</span><span class="s1">self.pvalue</span><span class="s0">,</span>
                                         <span class="s1">self.conf_int(alpha))</span><span class="s0">, </span><span class="s1">yname=yname</span><span class="s0">,</span>
                                         <span class="s1">xname=xname</span><span class="s0">, </span><span class="s1">use_t=use_t</span><span class="s0">,</span>
                                         <span class="s1">alpha=alpha)</span>
            <span class="s0">return </span><span class="s1">summ</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># TODO: create something nicer</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'only available for t and z'</span><span class="s1">)</span>



<span class="s0">class </span><span class="s1">Contrast:</span>
    <span class="s3">&quot;&quot;&quot; 
    This class is used to construct contrast matrices in regression models. 
 
    They are specified by a (term, design) pair.  The term, T, is a linear 
    combination of columns of the design matrix. The matrix attribute of 
    Contrast is a contrast matrix C so that 
 
    colspan(dot(D, C)) = colspan(dot(D, dot(pinv(D), T))) 
 
    where pinv(D) is the generalized inverse of D. Further, the matrix 
 
    Tnew = dot(C, D) 
 
    is full rank. The rank attribute is the rank of 
 
    dot(D, dot(pinv(D), T)) 
 
    In a regression model, the contrast tests that E(dot(Tnew, Y)) = 0 
    for each column of Tnew. 
 
    Parameters 
    ---------- 
    term : array_like 
    design : array_like 
 
    Attributes 
    ---------- 
    contrast_matrix 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; from statsmodels.stats.contrast import Contrast 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.random.seed(54321) 
    &gt;&gt;&gt; X = np.random.standard_normal((40,10)) 
    # Get a contrast 
    &gt;&gt;&gt; new_term = np.column_stack((X[:,0], X[:,2])) 
    &gt;&gt;&gt; c = Contrast(new_term, X) 
    &gt;&gt;&gt; test = [[1] + [0]*9, [0]*2 + [1] + [0]*7] 
    &gt;&gt;&gt; np.allclose(c.contrast_matrix, test) 
    True 
 
    Get another contrast 
 
    &gt;&gt;&gt; P = np.dot(X, np.linalg.pinv(X)) 
    &gt;&gt;&gt; resid = np.identity(40) - P 
    &gt;&gt;&gt; noise = np.dot(resid,np.random.standard_normal((40,5))) 
    &gt;&gt;&gt; new_term2 = np.column_stack((noise,X[:,2])) 
    &gt;&gt;&gt; c2 = Contrast(new_term2, X) 
    &gt;&gt;&gt; print(c2.contrast_matrix) 
    [ -1.26424750e-16   8.59467391e-17   1.56384718e-01  -2.60875560e-17 
    -7.77260726e-17  -8.41929574e-18  -7.36359622e-17  -1.39760860e-16 
    1.82976904e-16  -3.75277947e-18] 
 
    Get another contrast 
 
    &gt;&gt;&gt; zero = np.zeros((40,)) 
    &gt;&gt;&gt; new_term3 = np.column_stack((zero,X[:,2])) 
    &gt;&gt;&gt; c3 = Contrast(new_term3, X) 
    &gt;&gt;&gt; test2 = [0]*2 + [1] + [0]*7 
    &gt;&gt;&gt; np.allclose(c3.contrast_matrix, test2) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">_get_matrix(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Gets the contrast_matrix property 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;_contrast_matrix&quot;</span><span class="s1">):</span>
            <span class="s1">self.compute_matrix()</span>
        <span class="s0">return </span><span class="s1">self._contrast_matrix</span>

    <span class="s1">contrast_matrix = property(_get_matrix)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">term</span><span class="s0">, </span><span class="s1">design):</span>
        <span class="s1">self.term = np.asarray(term)</span>
        <span class="s1">self.design = np.asarray(design)</span>

    <span class="s0">def </span><span class="s1">compute_matrix(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a contrast matrix C so that 
 
        colspan(dot(D, C)) = colspan(dot(D, dot(pinv(D), T))) 
 
        where pinv(D) is the generalized inverse of D=design. 
        &quot;&quot;&quot;</span>

        <span class="s1">T = self.term</span>
        <span class="s0">if </span><span class="s1">T.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">T = T[:</span><span class="s0">,None</span><span class="s1">]</span>

        <span class="s1">self.T = clean0(T)</span>
        <span class="s1">self.D = self.design</span>
        <span class="s1">self._contrast_matrix = contrastfromcols(self.T</span><span class="s0">, </span><span class="s1">self.D)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.rank = self.matrix.shape[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s0">except</span><span class="s1">:</span>
            <span class="s1">self.rank = </span><span class="s4">1</span>

<span class="s2">#TODO: fix docstring after usage is settled</span>
<span class="s0">def </span><span class="s1">contrastfromcols(L</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">pseudo=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    From an n x p design matrix D and a matrix L, tries 
    to determine a p x q contrast matrix C which 
    determines a contrast of full rank, i.e. the 
    n x q matrix 
 
    dot(transpose(C), pinv(D)) 
 
    is full rank. 
 
    L must satisfy either L.shape[0] == n or L.shape[1] == p. 
 
    If L.shape[0] == n, then L is thought of as representing 
    columns in the column space of D. 
 
    If L.shape[1] == p, then L is thought of as what is known 
    as a contrast matrix. In this case, this function returns an estimable 
    contrast corresponding to the dot(D, L.T) 
 
    Note that this always produces a meaningful contrast, not always 
    with the intended properties because q is always non-zero unless 
    L is identically 0. That is, it produces a contrast that spans 
    the column space of L (after projection onto the column space of D). 
 
    Parameters 
    ---------- 
    L : array_like 
    D : array_like 
    &quot;&quot;&quot;</span>
    <span class="s1">L = np.asarray(L)</span>
    <span class="s1">D = np.asarray(D)</span>

    <span class="s1">n</span><span class="s0">, </span><span class="s1">p = D.shape</span>

    <span class="s0">if </span><span class="s1">L.shape[</span><span class="s4">0</span><span class="s1">] != n </span><span class="s0">and </span><span class="s1">L.shape[</span><span class="s4">1</span><span class="s1">] != p:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;shape of L and D mismatched&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">pseudo </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">pseudo = np.linalg.pinv(D)    </span><span class="s2"># D^+ \approx= ((dot(D.T,D))^(-1),D.T)</span>

    <span class="s0">if </span><span class="s1">L.shape[</span><span class="s4">0</span><span class="s1">] == n:</span>
        <span class="s1">C = np.dot(pseudo</span><span class="s0">, </span><span class="s1">L).T</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">C = L</span>
        <span class="s1">C = np.dot(pseudo</span><span class="s0">, </span><span class="s1">np.dot(D</span><span class="s0">, </span><span class="s1">C.T)).T</span>

    <span class="s1">Lp = np.dot(D</span><span class="s0">, </span><span class="s1">C.T)</span>

    <span class="s0">if </span><span class="s1">len(Lp.shape) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">Lp.shape = (n</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">np.linalg.matrix_rank(Lp) != Lp.shape[</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s1">Lp = fullrank(Lp)</span>
        <span class="s1">C = np.dot(pseudo</span><span class="s0">, </span><span class="s1">Lp).T</span>

    <span class="s0">return </span><span class="s1">np.squeeze(C)</span>


<span class="s2"># TODO: this is currently a minimal version, stub</span>
<span class="s0">class </span><span class="s1">WaldTestResults:</span>
    <span class="s2"># for F and chi2 tests of joint hypothesis, mainly for vectorized</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">distribution</span><span class="s0">, </span><span class="s1">dist_args</span><span class="s0">, </span><span class="s1">table=</span><span class="s0">None,</span>
                 <span class="s1">pvalues=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.table = table</span>

        <span class="s1">self.distribution = distribution</span>
        <span class="s1">self.statistic = statistic</span>
        <span class="s2">#self.sd = sd</span>
        <span class="s1">self.dist_args = dist_args</span>

        <span class="s2"># The following is because I do not know which we want</span>
        <span class="s0">if </span><span class="s1">table </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.statistic = table[</span><span class="s5">'statistic'</span><span class="s1">].values</span>
            <span class="s1">self.pvalues = table[</span><span class="s5">'pvalue'</span><span class="s1">].values</span>
            <span class="s1">self.df_constraints = table[</span><span class="s5">'df_constraint'</span><span class="s1">].values</span>
            <span class="s0">if </span><span class="s1">self.distribution == </span><span class="s5">'F'</span><span class="s1">:</span>
                <span class="s1">self.df_denom = table[</span><span class="s5">'df_denom'</span><span class="s1">].values</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.distribution == </span><span class="s5">'chi2'</span><span class="s1">:</span>
                <span class="s1">self.dist = stats.chi2</span>
                <span class="s1">self.df_constraints = self.dist_args[</span><span class="s4">0</span><span class="s1">]  </span><span class="s2"># assumes tuple</span>
                <span class="s2"># using dist_args[0] is a bit dangerous,</span>
            <span class="s0">elif </span><span class="s1">self.distribution == </span><span class="s5">'F'</span><span class="s1">:</span>
                <span class="s1">self.dist = stats.f</span>
                <span class="s1">self.df_constraints</span><span class="s0">, </span><span class="s1">self.df_denom = self.dist_args</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">'only F and chi2 are possible distribution'</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">pvalues </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self.pvalues = self.dist.sf(np.abs(statistic)</span><span class="s0">, </span><span class="s1">*dist_args)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.pvalues = pvalues</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">col_names(self):</span>
        <span class="s3">&quot;&quot;&quot;column names for summary table 
        &quot;&quot;&quot;</span>

        <span class="s1">pr_test = </span><span class="s5">&quot;P&gt;%s&quot; </span><span class="s1">% self.distribution</span>
        <span class="s1">col_names = [self.distribution</span><span class="s0">, </span><span class="s1">pr_test</span><span class="s0">, </span><span class="s5">'df constraint'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">self.distribution == </span><span class="s5">'F'</span><span class="s1">:</span>
            <span class="s1">col_names.append(</span><span class="s5">'df denom'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">col_names</span>

    <span class="s0">def </span><span class="s1">summary_frame(self):</span>
        <span class="s2"># needs to be a method for consistency</span>
        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">'_dframe'</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">self._dframe</span>
        <span class="s2"># rename the column nambes, but do not copy data</span>
        <span class="s1">renaming = dict(zip(self.table.columns</span><span class="s0">, </span><span class="s1">self.col_names))</span>
        <span class="s1">self.dframe = self.table.rename(columns=renaming)</span>
        <span class="s0">return </span><span class="s1">self.dframe</span>


    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.summary_frame().to_string()</span>


    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s1">str(self.__class__) + </span><span class="s5">'</span><span class="s0">\n</span><span class="s5">' </span><span class="s1">+ self.__str__()</span>


<span class="s2"># t_test for pairwise comparison and automatic contrast/restrictions</span>


<span class="s0">def </span><span class="s1">_get_pairs_labels(k_level</span><span class="s0">, </span><span class="s1">level_names):</span>
    <span class="s3">&quot;&quot;&quot;helper function for labels for pairwise comparisons 
    &quot;&quot;&quot;</span>
    <span class="s1">idx_pairs_all = np.triu_indices(k_level</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">labels = [</span><span class="s5">'%s-%s' </span><span class="s1">% (level_names[name[</span><span class="s4">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">level_names[name[</span><span class="s4">0</span><span class="s1">]])</span>
              <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">zip(*idx_pairs_all)]</span>
    <span class="s0">return </span><span class="s1">labels</span>

<span class="s0">def </span><span class="s1">_contrast_pairs(k_params</span><span class="s0">, </span><span class="s1">k_level</span><span class="s0">, </span><span class="s1">idx_start):</span>
    <span class="s3">&quot;&quot;&quot;create pairwise contrast for reference coding 
 
    currently not used, 
    using encoding contrast matrix is more general, but requires requires 
    factor information from patsy design_info. 
 
 
    Parameters 
    ---------- 
    k_params : int 
        number of parameters 
    k_level : int 
        number of levels or categories (including reference case) 
    idx_start : int 
        Index of the first parameter of this factor. The restrictions on the 
        factor are inserted as a block in the full restriction matrix starting 
        at column with index `idx_start`. 
 
    Returns 
    ------- 
    contrasts : ndarray 
        restriction matrix with k_params columns and number of rows equal to 
        the number of restrictions. 
    &quot;&quot;&quot;</span>
    <span class="s1">k_level_m1 = k_level - </span><span class="s4">1</span>
    <span class="s1">idx_pairs = np.triu_indices(k_level_m1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">k = len(idx_pairs[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">c_pairs = np.zeros((k</span><span class="s0">, </span><span class="s1">k_level_m1))</span>
    <span class="s1">c_pairs[np.arange(k)</span><span class="s0">, </span><span class="s1">idx_pairs[</span><span class="s4">0</span><span class="s1">]] = -</span><span class="s4">1</span>
    <span class="s1">c_pairs[np.arange(k)</span><span class="s0">, </span><span class="s1">idx_pairs[</span><span class="s4">1</span><span class="s1">]] = </span><span class="s4">1</span>
    <span class="s1">c_reference = np.eye(k_level_m1)</span>
    <span class="s1">c = np.concatenate((c_reference</span><span class="s0">, </span><span class="s1">c_pairs)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">k_all = c.shape[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">contrasts = np.zeros((k_all</span><span class="s0">, </span><span class="s1">k_params))</span>
    <span class="s1">contrasts[:</span><span class="s0">, </span><span class="s1">idx_start : idx_start + k_level_m1] = c</span>

    <span class="s0">return </span><span class="s1">contrasts</span>


<span class="s0">def </span><span class="s1">t_test_multi(result</span><span class="s0">, </span><span class="s1">contrasts</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">'hs'</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s0">, </span><span class="s1">ci_method=</span><span class="s0">None,</span>
                 <span class="s1">contrast_names=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;perform t_test and add multiplicity correction to results dataframe 
 
    Parameters 
    ---------- 
    result results instance 
        results of an estimated model 
    contrasts : ndarray 
        restriction matrix for t_test 
    method : str or list of strings 
        method for multiple testing p-value correction, default is'hs'. 
    alpha : float 
        significance level for multiple testing reject decision. 
    ci_method : None 
        not used yet, will be for multiplicity corrected confidence intervals 
    contrast_names : {list[str], None} 
        If contrast_names are provided, then they are used in the index of the 
        returned dataframe, otherwise some generic default names are created. 
 
    Returns 
    ------- 
    res_df : pandas DataFrame 
        The dataframe contains the results of the t_test and additional columns 
        for multiplicity corrected p-values and boolean indicator for whether 
        the Null hypothesis is rejected. 
    &quot;&quot;&quot;</span>
    <span class="s1">tt = result.t_test(contrasts)</span>
    <span class="s1">res_df = tt.summary_frame(xname=contrast_names)</span>

    <span class="s0">if </span><span class="s1">type(method) </span><span class="s0">is not </span><span class="s1">list:</span>
        <span class="s1">method = [method]</span>
    <span class="s0">for </span><span class="s1">meth </span><span class="s0">in </span><span class="s1">method:</span>
        <span class="s1">mt = multipletests(tt.pvalue</span><span class="s0">, </span><span class="s1">method=meth</span><span class="s0">, </span><span class="s1">alpha=alpha)</span>
        <span class="s1">res_df[</span><span class="s5">'pvalue-%s' </span><span class="s1">% meth] = mt[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">res_df[</span><span class="s5">'reject-%s' </span><span class="s1">% meth] = mt[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">res_df</span>


<span class="s0">class </span><span class="s1">MultiCompResult:</span>
    <span class="s3">&quot;&quot;&quot;class to hold return of t_test_pairwise 
 
    currently just a minimal class to hold attributes. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.__dict__.update(kwargs)</span>


<span class="s0">def </span><span class="s1">_embed_constraints(contrasts</span><span class="s0">, </span><span class="s1">k_params</span><span class="s0">, </span><span class="s1">idx_start</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;helper function to expand constraints to a full restriction matrix 
 
    Parameters 
    ---------- 
    contrasts : ndarray 
        restriction matrix for t_test 
    k_params : int 
        number of parameters 
    idx_start : int 
        Index of the first parameter of this factor. The restrictions on the 
        factor are inserted as a block in the full restriction matrix starting 
        at column with index `idx_start`. 
    index : slice or ndarray 
        Column index if constraints do not form a block in the full restriction 
        matrix, i.e. if parameters that are subject to restrictions are not 
        consecutive in the list of parameters. 
        If index is not None, then idx_start is ignored. 
 
    Returns 
    ------- 
    contrasts : ndarray 
        restriction matrix with k_params columns and number of rows equal to 
        the number of restrictions. 
    &quot;&quot;&quot;</span>

    <span class="s1">k_c</span><span class="s0">, </span><span class="s1">k_p = contrasts.shape</span>
    <span class="s1">c = np.zeros((k_c</span><span class="s0">, </span><span class="s1">k_params))</span>
    <span class="s0">if </span><span class="s1">index </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">c[:</span><span class="s0">, </span><span class="s1">idx_start : idx_start + k_p] = contrasts</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">c[:</span><span class="s0">, </span><span class="s1">index] = contrasts</span>
    <span class="s0">return </span><span class="s1">c</span>


<span class="s0">def </span><span class="s1">_constraints_factor(encoding_matrix</span><span class="s0">, </span><span class="s1">comparison=</span><span class="s5">'pairwise'</span><span class="s0">, </span><span class="s1">k_params=</span><span class="s0">None,</span>
                        <span class="s1">idx_start=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;helper function to create constraints based on encoding matrix 
 
    Parameters 
    ---------- 
    encoding_matrix : ndarray 
        contrast matrix for the encoding of a factor as defined by patsy. 
        The number of rows should be equal to the number of levels or categories 
        of the factor, the number of columns should be equal to the number 
        of parameters for this factor. 
    comparison : str 
        Currently only 'pairwise' is implemented. The restriction matrix 
        can be used for testing the hypothesis that all pairwise differences 
        are zero. 
    k_params : int 
        number of parameters 
    idx_start : int 
        Index of the first parameter of this factor. The restrictions on the 
        factor are inserted as a block in the full restriction matrix starting 
        at column with index `idx_start`. 
 
    Returns 
    ------- 
    contrast : ndarray 
        Contrast or restriction matrix that can be used in hypothesis test 
        of model results. The number of columns is k_params. 
    &quot;&quot;&quot;</span>

    <span class="s1">cm = encoding_matrix</span>
    <span class="s1">k_level</span><span class="s0">, </span><span class="s1">k_p = cm.shape</span>

    <span class="s0">import </span><span class="s1">statsmodels.sandbox.stats.multicomp </span><span class="s0">as </span><span class="s1">mc</span>
    <span class="s0">if </span><span class="s1">comparison </span><span class="s0">in </span><span class="s1">[</span><span class="s5">'pairwise'</span><span class="s0">, </span><span class="s5">'pw'</span><span class="s0">, </span><span class="s5">'pairs'</span><span class="s1">]:</span>
        <span class="s1">c_all = -mc.contrast_allpairs(k_level)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'currentlyonly pairwise comparison'</span><span class="s1">)</span>

    <span class="s1">contrasts = c_all.dot(cm)</span>
    <span class="s0">if </span><span class="s1">k_params </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">idx_start </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;if k_params is not None, then idx_start is &quot;</span>
                             <span class="s5">&quot;required&quot;</span><span class="s1">)</span>
        <span class="s1">contrasts = _embed_constraints(contrasts</span><span class="s0">, </span><span class="s1">k_params</span><span class="s0">, </span><span class="s1">idx_start)</span>
    <span class="s0">return </span><span class="s1">contrasts</span>


<span class="s0">def </span><span class="s1">t_test_pairwise(result</span><span class="s0">, </span><span class="s1">term_name</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">'hs'</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s0">,</span>
                    <span class="s1">factor_labels=</span><span class="s0">None, </span><span class="s1">ignore=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Perform pairwise t_test with multiple testing corrected p-values. 
 
    This uses the formula design_info encoding contrast matrix and should 
    work for all encodings of a main effect. 
 
    Parameters 
    ---------- 
    result : result instance 
        The results of an estimated model with a categorical main effect. 
    term_name : str 
        name of the term for which pairwise comparisons are computed. 
        Term names for categorical effects are created by patsy and 
        correspond to the main part of the exog names. 
    method : {str, list[str]} 
        multiple testing p-value correction, default is 'hs', 
        see stats.multipletesting 
    alpha : float 
        significance level for multiple testing reject decision. 
    factor_labels : {list[str], None} 
        Labels for the factor levels used for pairwise labels. If not 
        provided, then the labels from the formula design_info are used. 
    ignore : bool 
        Turn off some of the exceptions raised by input checks. 
 
    Returns 
    ------- 
    MultiCompResult 
        The results are stored as attributes, the main attributes are the 
        following two. Other attributes are added for debugging purposes 
        or as background information. 
 
        - result_frame : pandas DataFrame with t_test results and multiple 
          testing corrected p-values. 
        - contrasts : matrix of constraints of the null hypothesis in the 
          t_test. 
 
    Notes 
    ----- 
 
    Status: experimental. Currently only checked for treatment coding with 
    and without specified reference level. 
 
    Currently there are no multiple testing corrected confidence intervals 
    available. 
    &quot;&quot;&quot;</span>

    <span class="s1">desinfo = result.model.data.design_info</span>
    <span class="s1">term_idx = desinfo.term_names.index(term_name)</span>
    <span class="s1">term = desinfo.terms[term_idx]</span>
    <span class="s1">idx_start = desinfo.term_slices[term].start</span>
    <span class="s0">if not </span><span class="s1">ignore </span><span class="s0">and </span><span class="s1">len(term.factors) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">'interaction effects not yet supported'</span><span class="s1">)</span>
    <span class="s1">factor = term.factors[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">cat = desinfo.factor_infos[factor].categories</span>
    <span class="s0">if </span><span class="s1">factor_labels </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">len(factor_labels) == len(cat):</span>
            <span class="s1">cat = factor_labels</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;factor_labels has the wrong length, should be %d&quot; </span><span class="s1">% len(cat))</span>


    <span class="s1">k_level = len(cat)</span>
    <span class="s1">cm = desinfo.term_codings[term][</span><span class="s4">0</span><span class="s1">].contrast_matrices[factor].matrix</span>

    <span class="s1">k_params = len(result.params)</span>
    <span class="s1">labels = _get_pairs_labels(k_level</span><span class="s0">, </span><span class="s1">cat)</span>

    <span class="s0">import </span><span class="s1">statsmodels.sandbox.stats.multicomp </span><span class="s0">as </span><span class="s1">mc</span>
    <span class="s1">c_all_pairs = -mc.contrast_allpairs(k_level)</span>
    <span class="s1">contrasts_sub = c_all_pairs.dot(cm)</span>
    <span class="s1">contrasts = _embed_constraints(contrasts_sub</span><span class="s0">, </span><span class="s1">k_params</span><span class="s0">, </span><span class="s1">idx_start)</span>
    <span class="s1">res_df = t_test_multi(result</span><span class="s0">, </span><span class="s1">contrasts</span><span class="s0">, </span><span class="s1">method=method</span><span class="s0">, </span><span class="s1">ci_method=</span><span class="s0">None,</span>
                          <span class="s1">alpha=alpha</span><span class="s0">, </span><span class="s1">contrast_names=labels)</span>
    <span class="s1">res = MultiCompResult(result_frame=res_df</span><span class="s0">,</span>
                          <span class="s1">contrasts=contrasts</span><span class="s0">,</span>
                          <span class="s1">term=term</span><span class="s0">,</span>
                          <span class="s1">contrast_labels=labels</span><span class="s0">,</span>
                          <span class="s1">term_encoding_matrix=cm)</span>
    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_offset_constraint(r_matrix</span><span class="s0">, </span><span class="s1">params_est</span><span class="s0">, </span><span class="s1">params_alt):</span>
    <span class="s3">&quot;&quot;&quot;offset to the value of a linear constraint for new params 
 
    usage: 
    (cm, v) is original constraint 
 
    vo = offset_constraint(cm, res2.params, params_alt) 
    fs = res2.wald_test((cm, v + vo)) 
    nc = fs.statistic * fs.df_num 
 
    &quot;&quot;&quot;</span>
    <span class="s1">diff_est = r_matrix @ params_est</span>
    <span class="s1">diff_alt = r_matrix @ params_alt</span>
    <span class="s0">return </span><span class="s1">diff_est - diff_alt</span>


<span class="s0">def </span><span class="s1">wald_test_noncent(params</span><span class="s0">, </span><span class="s1">r_matrix</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">results</span><span class="s0">, </span><span class="s1">diff=</span><span class="s0">None, </span><span class="s1">joint=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Moncentrality parameter for a wald test in model results 
 
    The null hypothesis is ``diff = r_matrix @ params - value = 0`` 
 
    Parameters 
    ---------- 
    params : ndarray 
        parameters of the model at which to evaluate noncentrality. This can 
        be estimated parameters or parameters under an alternative. 
    r_matrix : ndarray 
        Restriction matrix or contrasts for the Null hypothesis 
    value : None or ndarray 
        Value of the linear combination of parameters under the null 
        hypothesis. If value is None, then it will be replaced by zero. 
    results : Results instance of a model 
        The results instance is used to compute the covariance matrix of the 
        linear constraints using `cov_params. 
    diff : None or ndarray 
        If diff is not None, then it will be used instead of 
        ``diff = r_matrix @ params - value`` 
    joint : bool 
        If joint is True, then the noncentrality parameter for the joint 
        hypothesis will be returned. 
        If joint is True, then an array of noncentrality parameters will be 
        returned, where elements correspond to rows of the restriction matrix. 
        This correspond to the `t_test` in models and is not a quadratic form. 
 
    Returns 
    ------- 
    nc : float or ndarray 
        Noncentrality parameter for Wald tests, correspondig to `wald_test` 
        or `t_test` depending on whether `joint` is true or not. 
        It needs to be divided by nobs to obtain effect size. 
 
 
    Notes 
    ----- 
    Status : experimental, API will likely change 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">diff </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">diff = r_matrix @ params - value  </span><span class="s2"># at parameter under alternative</span>

    <span class="s1">cov_c = results.cov_params(r_matrix=r_matrix)</span>
    <span class="s0">if </span><span class="s1">joint:</span>
        <span class="s1">nc = diff @ np.linalg.solve(cov_c</span><span class="s0">, </span><span class="s1">diff)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">nc = diff / np.sqrt(np.diag(cov_c))</span>
    <span class="s0">return </span><span class="s1">nc</span>


<span class="s0">def </span><span class="s1">wald_test_noncent_generic(params</span><span class="s0">, </span><span class="s1">r_matrix</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">cov_params</span><span class="s0">, </span><span class="s1">diff=</span><span class="s0">None,</span>
                              <span class="s1">joint=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;noncentrality parameter for a wald test 
 
    The null hypothesis is ``diff = r_matrix @ params - value = 0`` 
 
    Parameters 
    ---------- 
    params : ndarray 
        parameters of the model at which to evaluate noncentrality. This can 
        be estimated parameters or parameters under an alternative. 
    r_matrix : ndarray 
        Restriction matrix or contrasts for the Null hypothesis 
 
    value : None or ndarray 
        Value of the linear combination of parameters under the null 
        hypothesis. If value is None, then it will be replace by zero. 
    cov_params : ndarray 
        covariance matrix of the parameter estimates 
    diff : None or ndarray 
        If diff is not None, then it will be used instead of 
        ``diff = r_matrix @ params - value`` 
    joint : bool 
        If joint is True, then the noncentrality parameter for the joint 
        hypothesis will be returned. 
        If joint is True, then an array of noncentrality parameters will be 
        returned, where elements correspond to rows of the restriction matrix. 
        This correspond to the `t_test` in models and is not a quadratic form. 
 
    Returns 
    ------- 
    nc : float or ndarray 
        Noncentrality parameter for Wald tests, correspondig to `wald_test` 
        or `t_test` depending on whether `joint` is true or not. 
        It needs to be divided by nobs to obtain effect size. 
 
 
    Notes 
    ----- 
    Status : experimental, API will likely change 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">value = </span><span class="s4">0</span>
    <span class="s0">if </span><span class="s1">diff </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s2"># at parameter under alternative</span>
        <span class="s1">diff = r_matrix @ params - value</span>

    <span class="s1">c = r_matrix</span>
    <span class="s1">cov_c = c.dot(cov_params).dot(c.T)</span>
    <span class="s0">if </span><span class="s1">joint:</span>
        <span class="s1">nc = diff @ np.linalg.solve(cov_c</span><span class="s0">, </span><span class="s1">diff)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">nc = diff / np.sqrt(np.diag(cov_c))</span>
    <span class="s0">return </span><span class="s1">nc</span>
</pre>
</body>
</html>