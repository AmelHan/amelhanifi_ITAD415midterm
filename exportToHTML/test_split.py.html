<html>
<head>
<title>test_split.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_split.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Test the split module&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">combinations</span><span class="s2">, </span><span class="s1">combinations_with_replacement</span><span class="s2">, </span><span class="s1">permutations</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>
<span class="s2">from </span><span class="s1">scipy.sparse </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">coo_matrix</span><span class="s2">,</span>
    <span class="s1">csc_matrix</span><span class="s2">,</span>
    <span class="s1">csr_matrix</span><span class="s2">,</span>
    <span class="s1">issparse</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">scipy.special </span><span class="s2">import </span><span class="s1">comb</span>

<span class="s2">from </span><span class="s1">sklearn.datasets </span><span class="s2">import </span><span class="s1">load_digits</span><span class="s2">, </span><span class="s1">make_classification</span>
<span class="s2">from </span><span class="s1">sklearn.dummy </span><span class="s2">import </span><span class="s1">DummyClassifier</span>
<span class="s2">from </span><span class="s1">sklearn.model_selection </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">GridSearchCV</span><span class="s2">,</span>
    <span class="s1">GroupKFold</span><span class="s2">,</span>
    <span class="s1">GroupShuffleSplit</span><span class="s2">,</span>
    <span class="s1">KFold</span><span class="s2">,</span>
    <span class="s1">LeaveOneGroupOut</span><span class="s2">,</span>
    <span class="s1">LeaveOneOut</span><span class="s2">,</span>
    <span class="s1">LeavePGroupsOut</span><span class="s2">,</span>
    <span class="s1">LeavePOut</span><span class="s2">,</span>
    <span class="s1">PredefinedSplit</span><span class="s2">,</span>
    <span class="s1">RepeatedKFold</span><span class="s2">,</span>
    <span class="s1">RepeatedStratifiedKFold</span><span class="s2">,</span>
    <span class="s1">ShuffleSplit</span><span class="s2">,</span>
    <span class="s1">StratifiedGroupKFold</span><span class="s2">,</span>
    <span class="s1">StratifiedKFold</span><span class="s2">,</span>
    <span class="s1">StratifiedShuffleSplit</span><span class="s2">,</span>
    <span class="s1">TimeSeriesSplit</span><span class="s2">,</span>
    <span class="s1">check_cv</span><span class="s2">,</span>
    <span class="s1">cross_val_score</span><span class="s2">,</span>
    <span class="s1">train_test_split</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">sklearn.model_selection._split </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_build_repr</span><span class="s2">,</span>
    <span class="s1">_validate_shuffle_split</span><span class="s2">,</span>
    <span class="s1">_yields_constant_splits</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">sklearn.svm </span><span class="s2">import </span><span class="s1">SVC</span>
<span class="s2">from </span><span class="s1">sklearn.tests.test_metadata_routing </span><span class="s2">import </span><span class="s1">assert_request_is_empty</span>
<span class="s2">from </span><span class="s1">sklearn.utils._mocking </span><span class="s2">import </span><span class="s1">MockDataFrame</span>
<span class="s2">from </span><span class="s1">sklearn.utils._testing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">assert_allclose</span><span class="s2">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s2">,</span>
    <span class="s1">assert_array_equal</span><span class="s2">,</span>
    <span class="s1">ignore_warnings</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">sklearn.utils.validation </span><span class="s2">import </span><span class="s1">_num_samples</span>

<span class="s1">NO_GROUP_SPLITTERS = [</span>
    <span class="s1">KFold()</span><span class="s2">,</span>
    <span class="s1">StratifiedKFold()</span><span class="s2">,</span>
    <span class="s1">TimeSeriesSplit()</span><span class="s2">,</span>
    <span class="s1">LeaveOneOut()</span><span class="s2">,</span>
    <span class="s1">LeavePOut(p=</span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">ShuffleSplit()</span><span class="s2">,</span>
    <span class="s1">StratifiedShuffleSplit(test_size=</span><span class="s3">0.5</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">PredefinedSplit([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">RepeatedKFold()</span><span class="s2">,</span>
    <span class="s1">RepeatedStratifiedKFold()</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">GROUP_SPLITTERS = [</span>
    <span class="s1">GroupKFold()</span><span class="s2">,</span>
    <span class="s1">LeavePGroupsOut(n_groups=</span><span class="s3">1</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">StratifiedGroupKFold()</span><span class="s2">,</span>
    <span class="s1">LeaveOneGroupOut()</span><span class="s2">,</span>
    <span class="s1">GroupShuffleSplit()</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">ALL_SPLITTERS = NO_GROUP_SPLITTERS + GROUP_SPLITTERS  </span><span class="s4"># type: ignore</span>

<span class="s1">X = np.ones(</span><span class="s3">10</span><span class="s1">)</span>
<span class="s1">y = np.arange(</span><span class="s3">10</span><span class="s1">) // </span><span class="s3">2</span>
<span class="s1">P_sparse = coo_matrix(np.eye(</span><span class="s3">5</span><span class="s1">))</span>
<span class="s1">test_groups = (</span>
    <span class="s1">np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;2&quot;</span><span class="s2">, </span><span class="s5">&quot;2&quot;</span><span class="s2">, </span><span class="s5">&quot;2&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s1">digits = load_digits()</span>


<span class="s1">@ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_cross_validator_with_default_params():</span>
    <span class="s1">n_samples = </span><span class="s3">4</span>
    <span class="s1">n_unique_groups = </span><span class="s3">4</span>
    <span class="s1">n_splits = </span><span class="s3">2</span>
    <span class="s1">p = </span><span class="s3">2</span>
    <span class="s1">n_shuffle_splits = </span><span class="s3">10  </span><span class="s4"># (the default value)</span>

    <span class="s1">X = np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s1">]])</span>
    <span class="s1">X_1d = np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">y = np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">groups = np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">loo = LeaveOneOut()</span>
    <span class="s1">lpo = LeavePOut(p)</span>
    <span class="s1">kf = KFold(n_splits)</span>
    <span class="s1">skf = StratifiedKFold(n_splits)</span>
    <span class="s1">lolo = LeaveOneGroupOut()</span>
    <span class="s1">lopo = LeavePGroupsOut(p)</span>
    <span class="s1">ss = ShuffleSplit(random_state=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">ps = PredefinedSplit([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])  </span><span class="s4"># n_splits = np of unique folds = 2</span>
    <span class="s1">sgkf = StratifiedGroupKFold(n_splits)</span>

    <span class="s1">loo_repr = </span><span class="s5">&quot;LeaveOneOut()&quot;</span>
    <span class="s1">lpo_repr = </span><span class="s5">&quot;LeavePOut(p=2)&quot;</span>
    <span class="s1">kf_repr = </span><span class="s5">&quot;KFold(n_splits=2, random_state=None, shuffle=False)&quot;</span>
    <span class="s1">skf_repr = </span><span class="s5">&quot;StratifiedKFold(n_splits=2, random_state=None, shuffle=False)&quot;</span>
    <span class="s1">lolo_repr = </span><span class="s5">&quot;LeaveOneGroupOut()&quot;</span>
    <span class="s1">lopo_repr = </span><span class="s5">&quot;LeavePGroupsOut(n_groups=2)&quot;</span>
    <span class="s1">ss_repr = (</span>
        <span class="s5">&quot;ShuffleSplit(n_splits=10, random_state=0, test_size=None, train_size=None)&quot;</span>
    <span class="s1">)</span>
    <span class="s1">ps_repr = </span><span class="s5">&quot;PredefinedSplit(test_fold=array([1, 1, 2, 2]))&quot;</span>
    <span class="s1">sgkf_repr = </span><span class="s5">&quot;StratifiedGroupKFold(n_splits=2, random_state=None, shuffle=False)&quot;</span>

    <span class="s1">n_splits_expected = [</span>
        <span class="s1">n_samples</span><span class="s2">,</span>
        <span class="s1">comb(n_samples</span><span class="s2">, </span><span class="s1">p)</span><span class="s2">,</span>
        <span class="s1">n_splits</span><span class="s2">,</span>
        <span class="s1">n_splits</span><span class="s2">,</span>
        <span class="s1">n_unique_groups</span><span class="s2">,</span>
        <span class="s1">comb(n_unique_groups</span><span class="s2">, </span><span class="s1">p)</span><span class="s2">,</span>
        <span class="s1">n_shuffle_splits</span><span class="s2">,</span>
        <span class="s3">2</span><span class="s2">,</span>
        <span class="s1">n_splits</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(cv</span><span class="s2">, </span><span class="s1">cv_repr) </span><span class="s2">in </span><span class="s1">enumerate(</span>
        <span class="s1">zip(</span>
            <span class="s1">[loo</span><span class="s2">, </span><span class="s1">lpo</span><span class="s2">, </span><span class="s1">kf</span><span class="s2">, </span><span class="s1">skf</span><span class="s2">, </span><span class="s1">lolo</span><span class="s2">, </span><span class="s1">lopo</span><span class="s2">, </span><span class="s1">ss</span><span class="s2">, </span><span class="s1">ps</span><span class="s2">, </span><span class="s1">sgkf]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">loo_repr</span><span class="s2">,</span>
                <span class="s1">lpo_repr</span><span class="s2">,</span>
                <span class="s1">kf_repr</span><span class="s2">,</span>
                <span class="s1">skf_repr</span><span class="s2">,</span>
                <span class="s1">lolo_repr</span><span class="s2">,</span>
                <span class="s1">lopo_repr</span><span class="s2">,</span>
                <span class="s1">ss_repr</span><span class="s2">,</span>
                <span class="s1">ps_repr</span><span class="s2">,</span>
                <span class="s1">sgkf_repr</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s4"># Test if get_n_splits works correctly</span>
        <span class="s2">assert </span><span class="s1">n_splits_expected[i] == cv.get_n_splits(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups)</span>

        <span class="s4"># Test if the cross-validator works as expected even if</span>
        <span class="s4"># the data is 1d</span>
        <span class="s1">np.testing.assert_equal(</span>
            <span class="s1">list(cv.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span><span class="s2">, </span><span class="s1">list(cv.split(X_1d</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span>
        <span class="s1">)</span>
        <span class="s4"># Test that train, test indices returned are integers</span>
        <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">cv.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups):</span>
            <span class="s2">assert </span><span class="s1">np.asarray(train).dtype.kind == </span><span class="s5">&quot;i&quot;</span>
            <span class="s2">assert </span><span class="s1">np.asarray(test).dtype.kind == </span><span class="s5">&quot;i&quot;</span>

        <span class="s4"># Test if the repr works without any errors</span>
        <span class="s2">assert </span><span class="s1">cv_repr == repr(cv)</span>

    <span class="s4"># ValueError for get_n_splits methods</span>
    <span class="s1">msg = </span><span class="s5">&quot;The 'X' parameter should not be None.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">loo.get_n_splits(</span><span class="s2">None, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">lpo.get_n_splits(</span><span class="s2">None, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups)</span>


<span class="s2">def </span><span class="s1">test_2d_y():</span>
    <span class="s4"># smoke test for 2d y and multi-label</span>
    <span class="s1">n_samples = </span><span class="s3">30</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">X = rng.randint(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">size=(n_samples</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">y = rng.randint(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">size=(n_samples</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">y_2d = y.reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">y_multilabel = rng.randint(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">size=(n_samples</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">groups = rng.randint(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">size=(n_samples</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">splitters = [</span>
        <span class="s1">LeaveOneOut()</span><span class="s2">,</span>
        <span class="s1">LeavePOut(p=</span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">KFold()</span><span class="s2">,</span>
        <span class="s1">StratifiedKFold()</span><span class="s2">,</span>
        <span class="s1">RepeatedKFold()</span><span class="s2">,</span>
        <span class="s1">RepeatedStratifiedKFold()</span><span class="s2">,</span>
        <span class="s1">StratifiedGroupKFold()</span><span class="s2">,</span>
        <span class="s1">ShuffleSplit()</span><span class="s2">,</span>
        <span class="s1">StratifiedShuffleSplit(test_size=</span><span class="s3">0.5</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">GroupShuffleSplit()</span><span class="s2">,</span>
        <span class="s1">LeaveOneGroupOut()</span><span class="s2">,</span>
        <span class="s1">LeavePGroupsOut(n_groups=</span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">GroupKFold(n_splits=</span><span class="s3">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">TimeSeriesSplit()</span><span class="s2">,</span>
        <span class="s1">PredefinedSplit(test_fold=groups)</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s2">for </span><span class="s1">splitter </span><span class="s2">in </span><span class="s1">splitters:</span>
        <span class="s1">list(splitter.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span>
        <span class="s1">list(splitter.split(X</span><span class="s2">, </span><span class="s1">y_2d</span><span class="s2">, </span><span class="s1">groups))</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">list(splitter.split(X</span><span class="s2">, </span><span class="s1">y_multilabel</span><span class="s2">, </span><span class="s1">groups))</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">allowed_target_types = (</span><span class="s5">&quot;binary&quot;</span><span class="s2">, </span><span class="s5">&quot;multiclass&quot;</span><span class="s1">)</span>
            <span class="s1">msg = </span><span class="s5">&quot;Supported target types are: {}. Got 'multilabel&quot;</span><span class="s1">.format(</span>
                <span class="s1">allowed_target_types</span>
            <span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">msg </span><span class="s2">in </span><span class="s1">str(e)</span>


<span class="s2">def </span><span class="s1">check_valid_split(train</span><span class="s2">, </span><span class="s1">test</span><span class="s2">, </span><span class="s1">n_samples=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4"># Use python sets to get more informative assertion failure messages</span>
    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = set(train)</span><span class="s2">, </span><span class="s1">set(test)</span>

    <span class="s4"># Train and test split should not overlap</span>
    <span class="s2">assert </span><span class="s1">train.intersection(test) == set()</span>

    <span class="s2">if </span><span class="s1">n_samples </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s4"># Check that the union of train an test split cover all the indices</span>
        <span class="s2">assert </span><span class="s1">train.union(test) == set(range(n_samples))</span>


<span class="s2">def </span><span class="s1">check_cv_coverage(cv</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">expected_n_splits):</span>
    <span class="s1">n_samples = _num_samples(X)</span>
    <span class="s4"># Check that a all the samples appear at least once in a test fold</span>
    <span class="s2">assert </span><span class="s1">cv.get_n_splits(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups) == expected_n_splits</span>

    <span class="s1">collected_test_samples = set()</span>
    <span class="s1">iterations = </span><span class="s3">0</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">cv.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups):</span>
        <span class="s1">check_valid_split(train</span><span class="s2">, </span><span class="s1">test</span><span class="s2">, </span><span class="s1">n_samples=n_samples)</span>
        <span class="s1">iterations += </span><span class="s3">1</span>
        <span class="s1">collected_test_samples.update(test)</span>

    <span class="s4"># Check that the accumulated test samples cover the whole dataset</span>
    <span class="s2">assert </span><span class="s1">iterations == expected_n_splits</span>
    <span class="s2">if </span><span class="s1">n_samples </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">collected_test_samples == set(range(n_samples))</span>


<span class="s2">def </span><span class="s1">test_kfold_valueerrors():</span>
    <span class="s1">X1 = np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]])</span>
    <span class="s1">X2 = np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">9</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]])</span>
    <span class="s4"># Check that errors are raised if there is not enough samples</span>
    <span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">KFold(</span><span class="s3">4</span><span class="s1">).split(X1))</span>

    <span class="s4"># Check that a warning is raised if the least populated class has too few</span>
    <span class="s4"># members.</span>
    <span class="s1">y = np.array([</span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s1">skf_3 = StratifiedKFold(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(Warning</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;The least populated class&quot;</span><span class="s1">):</span>
        <span class="s1">next(skf_3.split(X2</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s1">sgkf_3 = StratifiedGroupKFold(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">naive_groups = np.arange(len(y))</span>
    <span class="s2">with </span><span class="s1">pytest.warns(Warning</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;The least populated class&quot;</span><span class="s1">):</span>
        <span class="s1">next(sgkf_3.split(X2</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">naive_groups))</span>

    <span class="s4"># Check that despite the warning the folds are still computed even</span>
    <span class="s4"># though all the classes are not necessarily represented at on each</span>
    <span class="s4"># side of the split at each split</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">check_cv_coverage(skf_3</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=</span><span class="s2">None, </span><span class="s1">expected_n_splits=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">check_cv_coverage(sgkf_3</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=naive_groups</span><span class="s2">, </span><span class="s1">expected_n_splits=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s4"># Check that errors are raised if all n_groups for individual</span>
    <span class="s4"># classes are less than n_splits.</span>
    <span class="s1">y = np.array([</span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">next(skf_3.split(X2</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">next(sgkf_3.split(X2</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s4"># Error when number of folds is &lt;= 1</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">KFold(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">KFold(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">error_string = </span><span class="s5">&quot;k-fold cross-validation requires at least one train/test split&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_string):</span>
        <span class="s1">StratifiedKFold(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_string):</span>
        <span class="s1">StratifiedKFold(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_string):</span>
        <span class="s1">StratifiedGroupKFold(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_string):</span>
        <span class="s1">StratifiedGroupKFold(</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s4"># When n_splits is not integer:</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">KFold(</span><span class="s3">1.5</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">KFold(</span><span class="s3">2.0</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">StratifiedKFold(</span><span class="s3">1.5</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">StratifiedKFold(</span><span class="s3">2.0</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">StratifiedGroupKFold(</span><span class="s3">1.5</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">StratifiedGroupKFold(</span><span class="s3">2.0</span><span class="s1">)</span>

    <span class="s4"># When shuffle is not  a bool:</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">KFold(n_splits=</span><span class="s3">4</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_kfold_indices():</span>
    <span class="s4"># Check all indices are returned in the test folds</span>
    <span class="s1">X1 = np.ones(</span><span class="s3">18</span><span class="s1">)</span>
    <span class="s1">kf = KFold(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">check_cv_coverage(kf</span><span class="s2">, </span><span class="s1">X1</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">groups=</span><span class="s2">None, </span><span class="s1">expected_n_splits=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s4"># Check all indices are returned in the test folds even when equal-sized</span>
    <span class="s4"># folds are not possible</span>
    <span class="s1">X2 = np.ones(</span><span class="s3">17</span><span class="s1">)</span>
    <span class="s1">kf = KFold(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">check_cv_coverage(kf</span><span class="s2">, </span><span class="s1">X2</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">groups=</span><span class="s2">None, </span><span class="s1">expected_n_splits=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s4"># Check if get_n_splits returns the number of folds</span>
    <span class="s2">assert </span><span class="s3">5 </span><span class="s1">== KFold(</span><span class="s3">5</span><span class="s1">).get_n_splits(X2)</span>


<span class="s2">def </span><span class="s1">test_kfold_no_shuffle():</span>
    <span class="s4"># Manually check that KFold preserves the data ordering on toy datasets</span>
    <span class="s1">X2 = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">9</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]]</span>

    <span class="s1">splits = KFold(</span><span class="s3">2</span><span class="s1">).split(X2[:-</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s1">splits = KFold(</span><span class="s3">2</span><span class="s1">).split(X2)</span>
    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_stratified_kfold_no_shuffle():</span>
    <span class="s4"># Manually check that StratifiedKFold preserves the data ordering as much</span>
    <span class="s4"># as possible on toy datasets in order to avoid hiding sample dependencies</span>
    <span class="s4"># when possible</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = np.ones(</span><span class="s3">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">splits = StratifiedKFold(</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = np.ones(</span><span class="s3">7</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">splits = StratifiedKFold(</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

    <span class="s4"># Check if get_n_splits returns the number of folds</span>
    <span class="s2">assert </span><span class="s3">5 </span><span class="s1">== StratifiedKFold(</span><span class="s3">5</span><span class="s1">).get_n_splits(X</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s4"># Make sure string labels are also supported</span>
    <span class="s1">X = np.ones(</span><span class="s3">7</span><span class="s1">)</span>
    <span class="s1">y1 = [</span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;0&quot;</span><span class="s2">, </span><span class="s5">&quot;0&quot;</span><span class="s2">, </span><span class="s5">&quot;0&quot;</span><span class="s2">, </span><span class="s5">&quot;0&quot;</span><span class="s1">]</span>
    <span class="s1">y2 = [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">np.testing.assert_equal(</span>
        <span class="s1">list(StratifiedKFold(</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y1))</span><span class="s2">, </span><span class="s1">list(StratifiedKFold(</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y2))</span>
    <span class="s1">)</span>

    <span class="s4"># Check equivalence to KFold</span>
    <span class="s1">y = [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">X = np.ones_like(y)</span>
    <span class="s1">np.testing.assert_equal(</span>
        <span class="s1">list(StratifiedKFold(</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y))</span><span class="s2">, </span><span class="s1">list(KFold(</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;shuffle&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;k&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">9</span><span class="s2">, </span><span class="s3">10</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;kfold&quot;</span><span class="s2">, </span><span class="s1">[StratifiedKFold</span><span class="s2">, </span><span class="s1">StratifiedGroupKFold])</span>
<span class="s2">def </span><span class="s1">test_stratified_kfold_ratios(k</span><span class="s2">, </span><span class="s1">shuffle</span><span class="s2">, </span><span class="s1">kfold):</span>
    <span class="s4"># Check that stratified kfold preserves class ratios in individual splits</span>
    <span class="s4"># Repeat with shuffling turned off and on</span>
    <span class="s1">n_samples = </span><span class="s3">1000</span>
    <span class="s1">X = np.ones(n_samples)</span>
    <span class="s1">y = np.array(</span>
        <span class="s1">[</span><span class="s3">4</span><span class="s1">] * int(</span><span class="s3">0.10 </span><span class="s1">* n_samples)</span>
        <span class="s1">+ [</span><span class="s3">0</span><span class="s1">] * int(</span><span class="s3">0.89 </span><span class="s1">* n_samples)</span>
        <span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * int(</span><span class="s3">0.01 </span><span class="s1">* n_samples)</span>
    <span class="s1">)</span>
    <span class="s4"># ensure perfect stratification with StratifiedGroupKFold</span>
    <span class="s1">groups = np.arange(len(y))</span>
    <span class="s1">distr = np.bincount(y) / len(y)</span>

    <span class="s1">test_sizes = []</span>
    <span class="s1">random_state = </span><span class="s2">None if not </span><span class="s1">shuffle </span><span class="s2">else </span><span class="s3">0</span>
    <span class="s1">skf = kfold(k</span><span class="s2">, </span><span class="s1">random_state=random_state</span><span class="s2">, </span><span class="s1">shuffle=shuffle)</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">skf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=groups):</span>
        <span class="s1">assert_allclose(np.bincount(y[train]) / len(train)</span><span class="s2">, </span><span class="s1">distr</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">0.02</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.bincount(y[test]) / len(test)</span><span class="s2">, </span><span class="s1">distr</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">0.02</span><span class="s1">)</span>
        <span class="s1">test_sizes.append(len(test))</span>
    <span class="s2">assert </span><span class="s1">np.ptp(test_sizes) &lt;= </span><span class="s3">1</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;shuffle&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;k&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;kfold&quot;</span><span class="s2">, </span><span class="s1">[StratifiedKFold</span><span class="s2">, </span><span class="s1">StratifiedGroupKFold])</span>
<span class="s2">def </span><span class="s1">test_stratified_kfold_label_invariance(k</span><span class="s2">, </span><span class="s1">shuffle</span><span class="s2">, </span><span class="s1">kfold):</span>
    <span class="s4"># Check that stratified kfold gives the same indices regardless of labels</span>
    <span class="s1">n_samples = </span><span class="s3">100</span>
    <span class="s1">y = np.array(</span>
        <span class="s1">[</span><span class="s3">2</span><span class="s1">] * int(</span><span class="s3">0.10 </span><span class="s1">* n_samples)</span>
        <span class="s1">+ [</span><span class="s3">0</span><span class="s1">] * int(</span><span class="s3">0.89 </span><span class="s1">* n_samples)</span>
        <span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * int(</span><span class="s3">0.01 </span><span class="s1">* n_samples)</span>
    <span class="s1">)</span>
    <span class="s1">X = np.ones(len(y))</span>
    <span class="s4"># ensure perfect stratification with StratifiedGroupKFold</span>
    <span class="s1">groups = np.arange(len(y))</span>

    <span class="s2">def </span><span class="s1">get_splits(y):</span>
        <span class="s1">random_state = </span><span class="s2">None if not </span><span class="s1">shuffle </span><span class="s2">else </span><span class="s3">0</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">(list(train)</span><span class="s2">, </span><span class="s1">list(test))</span>
            <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">kfold(</span>
                <span class="s1">k</span><span class="s2">, </span><span class="s1">random_state=random_state</span><span class="s2">, </span><span class="s1">shuffle=shuffle</span>
            <span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=groups)</span>
        <span class="s1">]</span>

    <span class="s1">splits_base = get_splits(y)</span>
    <span class="s2">for </span><span class="s1">perm </span><span class="s2">in </span><span class="s1">permutations([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]):</span>
        <span class="s1">y_perm = np.take(perm</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s1">splits_perm = get_splits(y_perm)</span>
        <span class="s2">assert </span><span class="s1">splits_perm == splits_base</span>


<span class="s2">def </span><span class="s1">test_kfold_balance():</span>
    <span class="s4"># Check that KFold returns folds with balanced sizes</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">11</span><span class="s2">, </span><span class="s3">17</span><span class="s1">):</span>
        <span class="s1">kf = KFold(</span><span class="s3">5</span><span class="s1">).split(X=np.ones(i))</span>
        <span class="s1">sizes = [len(test) </span><span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">kf]</span>

        <span class="s2">assert </span><span class="s1">(np.max(sizes) - np.min(sizes)) &lt;= </span><span class="s3">1</span>
        <span class="s2">assert </span><span class="s1">np.sum(sizes) == i</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;kfold&quot;</span><span class="s2">, </span><span class="s1">[StratifiedKFold</span><span class="s2">, </span><span class="s1">StratifiedGroupKFold])</span>
<span class="s2">def </span><span class="s1">test_stratifiedkfold_balance(kfold):</span>
    <span class="s4"># Check that KFold returns folds with balanced sizes (only when</span>
    <span class="s4"># stratification is possible)</span>
    <span class="s4"># Repeat with shuffling turned off and on</span>
    <span class="s1">X = np.ones(</span><span class="s3">17</span><span class="s1">)</span>
    <span class="s1">y = [</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">3 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">14</span>
    <span class="s4"># ensure perfect stratification with StratifiedGroupKFold</span>
    <span class="s1">groups = np.arange(len(y))</span>

    <span class="s2">for </span><span class="s1">shuffle </span><span class="s2">in </span><span class="s1">(</span><span class="s2">True, False</span><span class="s1">):</span>
        <span class="s1">cv = kfold(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">shuffle=shuffle)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">11</span><span class="s2">, </span><span class="s3">17</span><span class="s1">):</span>
            <span class="s1">skf = cv.split(X[:i]</span><span class="s2">, </span><span class="s1">y[:i]</span><span class="s2">, </span><span class="s1">groups[:i])</span>
            <span class="s1">sizes = [len(test) </span><span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">skf]</span>

            <span class="s2">assert </span><span class="s1">(np.max(sizes) - np.min(sizes)) &lt;= </span><span class="s3">1</span>
            <span class="s2">assert </span><span class="s1">np.sum(sizes) == i</span>


<span class="s2">def </span><span class="s1">test_shuffle_kfold():</span>
    <span class="s4"># Check the indices are shuffled properly</span>
    <span class="s1">kf = KFold(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">kf2 = KFold(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">kf3 = KFold(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">X = np.ones(</span><span class="s3">300</span><span class="s1">)</span>

    <span class="s1">all_folds = np.zeros(</span><span class="s3">300</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">(tr1</span><span class="s2">, </span><span class="s1">te1)</span><span class="s2">, </span><span class="s1">(tr2</span><span class="s2">, </span><span class="s1">te2)</span><span class="s2">, </span><span class="s1">(tr3</span><span class="s2">, </span><span class="s1">te3) </span><span class="s2">in </span><span class="s1">zip(</span>
        <span class="s1">kf.split(X)</span><span class="s2">, </span><span class="s1">kf2.split(X)</span><span class="s2">, </span><span class="s1">kf3.split(X)</span>
    <span class="s1">):</span>
        <span class="s2">for </span><span class="s1">tr_a</span><span class="s2">, </span><span class="s1">tr_b </span><span class="s2">in </span><span class="s1">combinations((tr1</span><span class="s2">, </span><span class="s1">tr2</span><span class="s2">, </span><span class="s1">tr3)</span><span class="s2">, </span><span class="s3">2</span><span class="s1">):</span>
            <span class="s4"># Assert that there is no complete overlap</span>
            <span class="s2">assert </span><span class="s1">len(np.intersect1d(tr_a</span><span class="s2">, </span><span class="s1">tr_b)) != len(tr1)</span>

        <span class="s4"># Set all test indices in successive iterations of kf2 to 1</span>
        <span class="s1">all_folds[te2] = </span><span class="s3">1</span>

    <span class="s4"># Check that all indices are returned in the different test folds</span>
    <span class="s2">assert </span><span class="s1">sum(all_folds) == </span><span class="s3">300</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;kfold&quot;</span><span class="s2">, </span><span class="s1">[KFold</span><span class="s2">, </span><span class="s1">StratifiedKFold</span><span class="s2">, </span><span class="s1">StratifiedGroupKFold])</span>
<span class="s2">def </span><span class="s1">test_shuffle_kfold_stratifiedkfold_reproducibility(kfold):</span>
    <span class="s1">X = np.ones(</span><span class="s3">15</span><span class="s1">)  </span><span class="s4"># Divisible by 3</span>
    <span class="s1">y = [</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">7 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">8</span>
    <span class="s1">groups_1 = np.arange(len(y))</span>
    <span class="s1">X2 = np.ones(</span><span class="s3">16</span><span class="s1">)  </span><span class="s4"># Not divisible by 3</span>
    <span class="s1">y2 = [</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">8 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">8</span>
    <span class="s1">groups_2 = np.arange(len(y2))</span>

    <span class="s4"># Check that when the shuffle is True, multiple split calls produce the</span>
    <span class="s4"># same split when random_state is int</span>
    <span class="s1">kf = kfold(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">np.testing.assert_equal(</span>
        <span class="s1">list(kf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups_1))</span><span class="s2">, </span><span class="s1">list(kf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups_1))</span>
    <span class="s1">)</span>

    <span class="s4"># Check that when the shuffle is True, multiple split calls often</span>
    <span class="s4"># (not always) produce different splits when random_state is</span>
    <span class="s4"># RandomState instance or None</span>
    <span class="s1">kf = kfold(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=np.random.RandomState(</span><span class="s3">0</span><span class="s1">))</span>
    <span class="s2">for </span><span class="s1">data </span><span class="s2">in </span><span class="s1">zip((X</span><span class="s2">, </span><span class="s1">X2)</span><span class="s2">, </span><span class="s1">(y</span><span class="s2">, </span><span class="s1">y2)</span><span class="s2">, </span><span class="s1">(groups_1</span><span class="s2">, </span><span class="s1">groups_2)):</span>
        <span class="s4"># Test if the two splits are different cv</span>
        <span class="s2">for </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">test_a)</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">test_b) </span><span class="s2">in </span><span class="s1">zip(kf.split(*data)</span><span class="s2">, </span><span class="s1">kf.split(*data)):</span>
            <span class="s4"># cv.split(...) returns an array of tuples, each tuple</span>
            <span class="s4"># consisting of an array with train indices and test indices</span>
            <span class="s4"># Ensure that the splits for data are not same</span>
            <span class="s4"># when random state is not set</span>
            <span class="s2">with </span><span class="s1">pytest.raises(AssertionError):</span>
                <span class="s1">np.testing.assert_array_equal(test_a</span><span class="s2">, </span><span class="s1">test_b)</span>


<span class="s2">def </span><span class="s1">test_shuffle_stratifiedkfold():</span>
    <span class="s4"># Check that shuffling is happening when requested, and for proper</span>
    <span class="s4"># sample coverage</span>
    <span class="s1">X_40 = np.ones(</span><span class="s3">40</span><span class="s1">)</span>
    <span class="s1">y = [</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">20 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">20</span>
    <span class="s1">kf0 = StratifiedKFold(</span><span class="s3">5</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">kf1 = StratifiedKFold(</span><span class="s3">5</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">test0)</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">test1) </span><span class="s2">in </span><span class="s1">zip(kf0.split(X_40</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">kf1.split(X_40</span><span class="s2">, </span><span class="s1">y)):</span>
        <span class="s2">assert </span><span class="s1">set(test0) != set(test1)</span>
    <span class="s1">check_cv_coverage(kf0</span><span class="s2">, </span><span class="s1">X_40</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=</span><span class="s2">None, </span><span class="s1">expected_n_splits=</span><span class="s3">5</span><span class="s1">)</span>

    <span class="s4"># Ensure that we shuffle each class's samples with different</span>
    <span class="s4"># random_state in StratifiedKFold</span>
    <span class="s4"># See https://github.com/scikit-learn/scikit-learn/pull/13124</span>
    <span class="s1">X = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">y = [</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">5 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">5</span>
    <span class="s1">kf1 = StratifiedKFold(</span><span class="s3">5</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">kf2 = StratifiedKFold(</span><span class="s3">5</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">test_set1 = sorted([tuple(s[</span><span class="s3">1</span><span class="s1">]) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">kf1.split(X</span><span class="s2">, </span><span class="s1">y)])</span>
    <span class="s1">test_set2 = sorted([tuple(s[</span><span class="s3">1</span><span class="s1">]) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">kf2.split(X</span><span class="s2">, </span><span class="s1">y)])</span>
    <span class="s2">assert </span><span class="s1">test_set1 != test_set2</span>


<span class="s2">def </span><span class="s1">test_kfold_can_detect_dependent_samples_on_digits():  </span><span class="s4"># see #2372</span>
    <span class="s4"># The digits samples are dependent: they are apparently grouped by authors</span>
    <span class="s4"># although we don't have any information on the groups segment locations</span>
    <span class="s4"># for this data. We can highlight this fact by computing k-fold cross-</span>
    <span class="s4"># validation with and without shuffling: we observe that the shuffling case</span>
    <span class="s4"># wrongly makes the IID assumption and is therefore too optimistic: it</span>
    <span class="s4"># estimates a much higher accuracy (around 0.93) than that the non</span>
    <span class="s4"># shuffling variant (around 0.81).</span>

    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = digits.data[:</span><span class="s3">600</span><span class="s1">]</span><span class="s2">, </span><span class="s1">digits.target[:</span><span class="s3">600</span><span class="s1">]</span>
    <span class="s1">model = SVC(C=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">gamma=</span><span class="s3">0.005</span><span class="s1">)</span>

    <span class="s1">n_splits = </span><span class="s3">3</span>

    <span class="s1">cv = KFold(n_splits=n_splits</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mean_score = cross_val_score(model</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">cv=cv).mean()</span>
    <span class="s2">assert </span><span class="s3">0.92 </span><span class="s1">&gt; mean_score</span>
    <span class="s2">assert </span><span class="s1">mean_score &gt; </span><span class="s3">0.80</span>

    <span class="s4"># Shuffling the data artificially breaks the dependency and hides the</span>
    <span class="s4"># overfitting of the model with regards to the writing style of the authors</span>
    <span class="s4"># by yielding a seriously overestimated score:</span>

    <span class="s1">cv = KFold(n_splits</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">mean_score = cross_val_score(model</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">cv=cv).mean()</span>
    <span class="s2">assert </span><span class="s1">mean_score &gt; </span><span class="s3">0.92</span>

    <span class="s1">cv = KFold(n_splits</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">mean_score = cross_val_score(model</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">cv=cv).mean()</span>
    <span class="s2">assert </span><span class="s1">mean_score &gt; </span><span class="s3">0.92</span>

    <span class="s4"># Similarly, StratifiedKFold should try to shuffle the data as little</span>
    <span class="s4"># as possible (while respecting the balanced class constraints)</span>
    <span class="s4"># and thus be able to detect the dependency by not overestimating</span>
    <span class="s4"># the CV score either. As the digits dataset is approximately balanced</span>
    <span class="s4"># the estimated mean score is close to the score measured with</span>
    <span class="s4"># non-shuffled KFold</span>

    <span class="s1">cv = StratifiedKFold(n_splits)</span>
    <span class="s1">mean_score = cross_val_score(model</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">cv=cv).mean()</span>
    <span class="s2">assert </span><span class="s3">0.94 </span><span class="s1">&gt; mean_score</span>
    <span class="s2">assert </span><span class="s1">mean_score &gt; </span><span class="s3">0.80</span>


<span class="s2">def </span><span class="s1">test_stratified_group_kfold_trivial():</span>
    <span class="s1">sgkf = StratifiedGroupKFold(n_splits=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s4"># Trivial example - groups with the same distribution</span>
    <span class="s1">y = np.array([</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">6 </span><span class="s1">+ [</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">X = np.ones_like(y).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">groups = np.asarray((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">6</span><span class="s1">))</span>
    <span class="s1">distr = np.bincount(y) / len(y)</span>
    <span class="s1">test_sizes = []</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">sgkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups):</span>
        <span class="s4"># check group constraint</span>
        <span class="s2">assert </span><span class="s1">np.intersect1d(groups[train]</span><span class="s2">, </span><span class="s1">groups[test]).size == </span><span class="s3">0</span>
        <span class="s4"># check y distribution</span>
        <span class="s1">assert_allclose(np.bincount(y[train]) / len(train)</span><span class="s2">, </span><span class="s1">distr</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">0.02</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.bincount(y[test]) / len(test)</span><span class="s2">, </span><span class="s1">distr</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">0.02</span><span class="s1">)</span>
        <span class="s1">test_sizes.append(len(test))</span>
    <span class="s2">assert </span><span class="s1">np.ptp(test_sizes) &lt;= </span><span class="s3">1</span>


<span class="s2">def </span><span class="s1">test_stratified_group_kfold_approximate():</span>
    <span class="s4"># Not perfect stratification (even though it is possible) because of</span>
    <span class="s4"># iteration over groups</span>
    <span class="s1">sgkf = StratifiedGroupKFold(n_splits=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">y = np.array([</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">6 </span><span class="s1">+ [</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">X = np.ones_like(y).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">groups = np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span>
    <span class="s1">expected = np.asarray([[</span><span class="s3">0.833</span><span class="s2">, </span><span class="s3">0.166</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.666</span><span class="s2">, </span><span class="s3">0.333</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">]])</span>
    <span class="s1">test_sizes = []</span>
    <span class="s2">for </span><span class="s1">(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">expect_dist </span><span class="s2">in </span><span class="s1">zip(sgkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups)</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># check group constraint</span>
        <span class="s2">assert </span><span class="s1">np.intersect1d(groups[train]</span><span class="s2">, </span><span class="s1">groups[test]).size == </span><span class="s3">0</span>
        <span class="s1">split_dist = np.bincount(y[test]) / len(test)</span>
        <span class="s1">assert_allclose(split_dist</span><span class="s2">, </span><span class="s1">expect_dist</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">0.001</span><span class="s1">)</span>
        <span class="s1">test_sizes.append(len(test))</span>
    <span class="s2">assert </span><span class="s1">np.ptp(test_sizes) &lt;= </span><span class="s3">1</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;y, groups, expected&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">np.array([</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">6 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">6</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">np.asarray([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">np.array([</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">9 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">np.asarray([[</span><span class="s3">0.75</span><span class="s2">, </span><span class="s3">0.25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.75</span><span class="s2">, </span><span class="s3">0.25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.75</span><span class="s2">, </span><span class="s3">0.25</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_stratified_group_kfold_homogeneous_groups(y</span><span class="s2">, </span><span class="s1">groups</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">sgkf = StratifiedGroupKFold(n_splits=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">X = np.ones_like(y).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">expect_dist </span><span class="s2">in </span><span class="s1">zip(sgkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups)</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># check group constraint</span>
        <span class="s2">assert </span><span class="s1">np.intersect1d(groups[train]</span><span class="s2">, </span><span class="s1">groups[test]).size == </span><span class="s3">0</span>
        <span class="s1">split_dist = np.bincount(y[test]) / len(test)</span>
        <span class="s1">assert_allclose(split_dist</span><span class="s2">, </span><span class="s1">expect_dist</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">0.001</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;cls_distr&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.7</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0.8</span><span class="s2">, </span><span class="s3">0.2</span><span class="s1">)])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;n_groups&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">30</span><span class="s2">, </span><span class="s3">70</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_stratified_group_kfold_against_group_kfold(cls_distr</span><span class="s2">, </span><span class="s1">n_groups):</span>
    <span class="s4"># Check that given sufficient amount of samples StratifiedGroupKFold</span>
    <span class="s4"># produces better stratified folds than regular GroupKFold</span>
    <span class="s1">n_splits = </span><span class="s3">5</span>
    <span class="s1">sgkf = StratifiedGroupKFold(n_splits=n_splits)</span>
    <span class="s1">gkf = GroupKFold(n_splits=n_splits)</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">n_points = </span><span class="s3">1000</span>
    <span class="s1">y = rng.choice(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">size=n_points</span><span class="s2">, </span><span class="s1">p=cls_distr)</span>
    <span class="s1">X = np.ones_like(y).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">g = rng.choice(n_groups</span><span class="s2">, </span><span class="s1">n_points)</span>
    <span class="s1">sgkf_folds = sgkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=g)</span>
    <span class="s1">gkf_folds = gkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=g)</span>
    <span class="s1">sgkf_entr = </span><span class="s3">0</span>
    <span class="s1">gkf_entr = </span><span class="s3">0</span>
    <span class="s2">for </span><span class="s1">(sgkf_train</span><span class="s2">, </span><span class="s1">sgkf_test)</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">gkf_test) </span><span class="s2">in </span><span class="s1">zip(sgkf_folds</span><span class="s2">, </span><span class="s1">gkf_folds):</span>
        <span class="s4"># check group constraint</span>
        <span class="s2">assert </span><span class="s1">np.intersect1d(g[sgkf_train]</span><span class="s2">, </span><span class="s1">g[sgkf_test]).size == </span><span class="s3">0</span>
        <span class="s1">sgkf_distr = np.bincount(y[sgkf_test]) / len(sgkf_test)</span>
        <span class="s1">gkf_distr = np.bincount(y[gkf_test]) / len(gkf_test)</span>
        <span class="s1">sgkf_entr += stats.entropy(sgkf_distr</span><span class="s2">, </span><span class="s1">qk=cls_distr)</span>
        <span class="s1">gkf_entr += stats.entropy(gkf_distr</span><span class="s2">, </span><span class="s1">qk=cls_distr)</span>
    <span class="s1">sgkf_entr /= n_splits</span>
    <span class="s1">gkf_entr /= n_splits</span>
    <span class="s2">assert </span><span class="s1">sgkf_entr &lt;= gkf_entr</span>


<span class="s2">def </span><span class="s1">test_shuffle_split():</span>
    <span class="s1">ss1 = ShuffleSplit(test_size=</span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">).split(X)</span>
    <span class="s1">ss2 = ShuffleSplit(test_size=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">).split(X)</span>
    <span class="s1">ss3 = ShuffleSplit(test_size=np.int32(</span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">).split(X)</span>
    <span class="s1">ss4 = ShuffleSplit(test_size=int(</span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">).split(X)</span>
    <span class="s2">for </span><span class="s1">t1</span><span class="s2">, </span><span class="s1">t2</span><span class="s2">, </span><span class="s1">t3</span><span class="s2">, </span><span class="s1">t4 </span><span class="s2">in </span><span class="s1">zip(ss1</span><span class="s2">, </span><span class="s1">ss2</span><span class="s2">, </span><span class="s1">ss3</span><span class="s2">, </span><span class="s1">ss4):</span>
        <span class="s1">assert_array_equal(t1[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t2[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(t2[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t3[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(t3[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t4[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(t1[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t2[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(t2[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t3[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(t3[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t4[</span><span class="s3">1</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;split_class&quot;</span><span class="s2">, </span><span class="s1">[ShuffleSplit</span><span class="s2">, </span><span class="s1">StratifiedShuffleSplit])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;train_size, exp_train, exp_test&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s2">None, </span><span class="s3">9</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">8</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0.8</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_shuffle_split_default_test_size(split_class</span><span class="s2">, </span><span class="s1">train_size</span><span class="s2">, </span><span class="s1">exp_train</span><span class="s2">, </span><span class="s1">exp_test):</span>
    <span class="s4"># Check that the default value has the expected behavior, i.e. 0.1 if both</span>
    <span class="s4"># unspecified or complement train_size unless both are specified.</span>
    <span class="s1">X = np.ones(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">y = np.ones(</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test = next(split_class(train_size=train_size).split(X</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s2">assert </span><span class="s1">len(X_train) == exp_train</span>
    <span class="s2">assert </span><span class="s1">len(X_test) == exp_test</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;train_size, exp_train, exp_test&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s2">None, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">7</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0.7</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_group_shuffle_split_default_test_size(train_size</span><span class="s2">, </span><span class="s1">exp_train</span><span class="s2">, </span><span class="s1">exp_test):</span>
    <span class="s4"># Check that the default value has the expected behavior, i.e. 0.2 if both</span>
    <span class="s4"># unspecified or complement train_size unless both are specified.</span>
    <span class="s1">X = np.ones(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">y = np.ones(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">groups = range(</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test = next(GroupShuffleSplit(train_size=train_size).split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span>

    <span class="s2">assert </span><span class="s1">len(X_train) == exp_train</span>
    <span class="s2">assert </span><span class="s1">len(X_test) == exp_test</span>


<span class="s1">@ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_init():</span>
    <span class="s1">X = np.arange(</span><span class="s3">7</span><span class="s1">)</span>
    <span class="s1">y = np.asarray([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s4"># Check that error is raised if there is a class with only one sample</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">next(StratifiedShuffleSplit(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s4"># Check that error is raised if the test set size is smaller than n_classes</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">next(StratifiedShuffleSplit(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s4"># Check that error is raised if the train set size is smaller than</span>
    <span class="s4"># n_classes</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">next(StratifiedShuffleSplit(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">train_size=</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s1">X = np.arange(</span><span class="s3">9</span><span class="s1">)</span>
    <span class="s1">y = np.asarray([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s4"># Train size or test size too small</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">next(StratifiedShuffleSplit(train_size=</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">next(StratifiedShuffleSplit(test_size=</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y))</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_respects_test_size():</span>
    <span class="s1">y = np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">test_size = </span><span class="s3">5</span>
    <span class="s1">train_size = </span><span class="s3">10</span>
    <span class="s1">sss = StratifiedShuffleSplit(</span>
        <span class="s3">6</span><span class="s2">, </span><span class="s1">test_size=test_size</span><span class="s2">, </span><span class="s1">train_size=train_size</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span>
    <span class="s1">).split(np.ones(len(y))</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">sss:</span>
        <span class="s2">assert </span><span class="s1">len(train) == train_size</span>
        <span class="s2">assert </span><span class="s1">len(test) == test_size</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_iter():</span>
    <span class="s1">ys = [</span>
        <span class="s1">np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">] * </span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">np.array([-</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">800 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">50</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">np.concatenate([[i] * (</span><span class="s3">100 </span><span class="s1">+ i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">11</span><span class="s1">)])</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;1&quot;</span><span class="s2">, </span><span class="s5">&quot;2&quot;</span><span class="s2">, </span><span class="s5">&quot;2&quot;</span><span class="s2">, </span><span class="s5">&quot;2&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s2">, </span><span class="s5">&quot;3&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">ys:</span>
        <span class="s1">sss = StratifiedShuffleSplit(</span><span class="s3">6</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.33</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">).split(</span>
            <span class="s1">np.ones(len(y))</span><span class="s2">, </span><span class="s1">y</span>
        <span class="s1">)</span>
        <span class="s1">y = np.asanyarray(y)  </span><span class="s4"># To make it indexable for y[train]</span>
        <span class="s4"># this is how test-size is computed internally</span>
        <span class="s4"># in _validate_shuffle_split</span>
        <span class="s1">test_size = np.ceil(</span><span class="s3">0.33 </span><span class="s1">* len(y))</span>
        <span class="s1">train_size = len(y) - test_size</span>
        <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">sss:</span>
            <span class="s1">assert_array_equal(np.unique(y[train])</span><span class="s2">, </span><span class="s1">np.unique(y[test]))</span>
            <span class="s4"># Checks if folds keep classes proportions</span>
            <span class="s1">p_train = np.bincount(np.unique(y[train]</span><span class="s2">, </span><span class="s1">return_inverse=</span><span class="s2">True</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]) / float(</span>
                <span class="s1">len(y[train])</span>
            <span class="s1">)</span>
            <span class="s1">p_test = np.bincount(np.unique(y[test]</span><span class="s2">, </span><span class="s1">return_inverse=</span><span class="s2">True</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]) / float(</span>
                <span class="s1">len(y[test])</span>
            <span class="s1">)</span>
            <span class="s1">assert_array_almost_equal(p_train</span><span class="s2">, </span><span class="s1">p_test</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">len(train) + len(test) == y.size</span>
            <span class="s2">assert </span><span class="s1">len(train) == train_size</span>
            <span class="s2">assert </span><span class="s1">len(test) == test_size</span>
            <span class="s1">assert_array_equal(np.intersect1d(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">[])</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_even():</span>
    <span class="s4"># Test the StratifiedShuffleSplit, indices are drawn with a</span>
    <span class="s4"># equal chance</span>
    <span class="s1">n_folds = </span><span class="s3">5</span>
    <span class="s1">n_splits = </span><span class="s3">1000</span>

    <span class="s2">def </span><span class="s1">assert_counts_are_ok(idx_counts</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s4"># Here we test that the distribution of the counts</span>
        <span class="s4"># per index is close enough to a binomial</span>
        <span class="s1">threshold = </span><span class="s3">0.05 </span><span class="s1">/ n_splits</span>
        <span class="s1">bf = stats.binom(n_splits</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s2">for </span><span class="s1">count </span><span class="s2">in </span><span class="s1">idx_counts:</span>
            <span class="s1">prob = bf.pmf(count)</span>
            <span class="s2">assert </span><span class="s1">(</span>
                <span class="s1">prob &gt; threshold</span>
            <span class="s1">)</span><span class="s2">, </span><span class="s5">&quot;An index is not drawn with chance corresponding to even draws&quot;</span>

    <span class="s2">for </span><span class="s1">n_samples </span><span class="s2">in </span><span class="s1">(</span><span class="s3">6</span><span class="s2">, </span><span class="s3">22</span><span class="s1">):</span>
        <span class="s1">groups = np.array((n_samples // </span><span class="s3">2</span><span class="s1">) * [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">splits = StratifiedShuffleSplit(</span>
            <span class="s1">n_splits=n_splits</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">1.0 </span><span class="s1">/ n_folds</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span>
        <span class="s1">)</span>

        <span class="s1">train_counts = [</span><span class="s3">0</span><span class="s1">] * n_samples</span>
        <span class="s1">test_counts = [</span><span class="s3">0</span><span class="s1">] * n_samples</span>
        <span class="s1">n_splits_actual = </span><span class="s3">0</span>
        <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">splits.split(X=np.ones(n_samples)</span><span class="s2">, </span><span class="s1">y=groups):</span>
            <span class="s1">n_splits_actual += </span><span class="s3">1</span>
            <span class="s2">for </span><span class="s1">counter</span><span class="s2">, </span><span class="s1">ids </span><span class="s2">in </span><span class="s1">[(train_counts</span><span class="s2">, </span><span class="s1">train)</span><span class="s2">, </span><span class="s1">(test_counts</span><span class="s2">, </span><span class="s1">test)]:</span>
                <span class="s2">for </span><span class="s1">id </span><span class="s2">in </span><span class="s1">ids:</span>
                    <span class="s1">counter[id] += </span><span class="s3">1</span>
        <span class="s2">assert </span><span class="s1">n_splits_actual == n_splits</span>

        <span class="s1">n_train</span><span class="s2">, </span><span class="s1">n_test = _validate_shuffle_split(</span>
            <span class="s1">n_samples</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">1.0 </span><span class="s1">/ n_folds</span><span class="s2">, </span><span class="s1">train_size=</span><span class="s3">1.0 </span><span class="s1">- (</span><span class="s3">1.0 </span><span class="s1">/ n_folds)</span>
        <span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">len(train) == n_train</span>
        <span class="s2">assert </span><span class="s1">len(test) == n_test</span>
        <span class="s2">assert </span><span class="s1">len(set(train).intersection(test)) == </span><span class="s3">0</span>

        <span class="s1">group_counts = np.unique(groups)</span>
        <span class="s2">assert </span><span class="s1">splits.test_size == </span><span class="s3">1.0 </span><span class="s1">/ n_folds</span>
        <span class="s2">assert </span><span class="s1">n_train + n_test == len(groups)</span>
        <span class="s2">assert </span><span class="s1">len(group_counts) == </span><span class="s3">2</span>
        <span class="s1">ex_test_p = float(n_test) / n_samples</span>
        <span class="s1">ex_train_p = float(n_train) / n_samples</span>

        <span class="s1">assert_counts_are_ok(train_counts</span><span class="s2">, </span><span class="s1">ex_train_p)</span>
        <span class="s1">assert_counts_are_ok(test_counts</span><span class="s2">, </span><span class="s1">ex_test_p)</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_overlap_train_test_bug():</span>
    <span class="s4"># See https://github.com/scikit-learn/scikit-learn/issues/6121 for</span>
    <span class="s4"># the original bug report</span>
    <span class="s1">y = [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">3 </span><span class="s1">+ [</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">] * </span><span class="s3">5</span>
    <span class="s1">X = np.ones_like(y)</span>

    <span class="s1">sss = StratifiedShuffleSplit(n_splits=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(sss.split(X=X</span><span class="s2">, </span><span class="s1">y=y))</span>

    <span class="s4"># no overlap</span>
    <span class="s1">assert_array_equal(np.intersect1d(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">[])</span>

    <span class="s4"># complete partition</span>
    <span class="s1">assert_array_equal(np.union1d(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">np.arange(len(y)))</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_multilabel():</span>
    <span class="s4"># fix for issue 9037</span>
    <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">[</span>
        <span class="s1">np.array([[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">np.array([[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]])</span><span class="s2">,</span>
    <span class="s1">]:</span>
        <span class="s1">X = np.ones_like(y)</span>
        <span class="s1">sss = StratifiedShuffleSplit(n_splits=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(sss.split(X=X</span><span class="s2">, </span><span class="s1">y=y))</span>
        <span class="s1">y_train = y[train]</span>
        <span class="s1">y_test = y[test]</span>

        <span class="s4"># no overlap</span>
        <span class="s1">assert_array_equal(np.intersect1d(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">[])</span>

        <span class="s4"># complete partition</span>
        <span class="s1">assert_array_equal(np.union1d(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">np.arange(len(y)))</span>

        <span class="s4"># correct stratification of entire rows</span>
        <span class="s4"># (by design, here y[:, 0] uniquely determines the entire row of y)</span>
        <span class="s1">expected_ratio = np.mean(y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">expected_ratio == np.mean(y_train[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">expected_ratio == np.mean(y_test[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_multilabel_many_labels():</span>
    <span class="s4"># fix in PR #9922: for multilabel data with &gt; 1000 labels, str(row)</span>
    <span class="s4"># truncates with an ellipsis for elements in positions 4 through</span>
    <span class="s4"># len(row) - 4, so labels were not being correctly split using the powerset</span>
    <span class="s4"># method for transforming a multilabel problem to a multiclass one; this</span>
    <span class="s4"># test checks that this problem is fixed.</span>
    <span class="s1">row_with_many_zeros = [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">] + [</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">1000 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">row_with_many_ones = [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">] + [</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">1000 </span><span class="s1">+ [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">y = np.array([row_with_many_zeros] * </span><span class="s3">10 </span><span class="s1">+ [row_with_many_ones] * </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">X = np.ones_like(y)</span>

    <span class="s1">sss = StratifiedShuffleSplit(n_splits=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(sss.split(X=X</span><span class="s2">, </span><span class="s1">y=y))</span>
    <span class="s1">y_train = y[train]</span>
    <span class="s1">y_test = y[test]</span>

    <span class="s4"># correct stratification of entire rows</span>
    <span class="s4"># (by design, here y[:, 4] uniquely determines the entire row of y)</span>
    <span class="s1">expected_ratio = np.mean(y[:</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">expected_ratio == np.mean(y_train[:</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">expected_ratio == np.mean(y_test[:</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_predefinedsplit_with_kfold_split():</span>
    <span class="s4"># Check that PredefinedSplit can reproduce a split generated by Kfold.</span>
    <span class="s1">folds = np.full(</span><span class="s3">10</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s1">kf_train = []</span>
    <span class="s1">kf_test = []</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(train_ind</span><span class="s2">, </span><span class="s1">test_ind) </span><span class="s2">in </span><span class="s1">enumerate(KFold(</span><span class="s3">5</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">True</span><span class="s1">).split(X)):</span>
        <span class="s1">kf_train.append(train_ind)</span>
        <span class="s1">kf_test.append(test_ind)</span>
        <span class="s1">folds[test_ind] = i</span>
    <span class="s1">ps = PredefinedSplit(folds)</span>
    <span class="s4"># n_splits is simply the no of unique folds</span>
    <span class="s2">assert </span><span class="s1">len(np.unique(folds)) == ps.get_n_splits()</span>
    <span class="s1">ps_train</span><span class="s2">, </span><span class="s1">ps_test = zip(*ps.split())</span>
    <span class="s1">assert_array_equal(ps_train</span><span class="s2">, </span><span class="s1">kf_train)</span>
    <span class="s1">assert_array_equal(ps_test</span><span class="s2">, </span><span class="s1">kf_test)</span>


<span class="s2">def </span><span class="s1">test_group_shuffle_split():</span>
    <span class="s2">for </span><span class="s1">groups_i </span><span class="s2">in </span><span class="s1">test_groups:</span>
        <span class="s1">X = y = np.ones(len(groups_i))</span>
        <span class="s1">n_splits = </span><span class="s3">6</span>
        <span class="s1">test_size = </span><span class="s3">1.0 </span><span class="s1">/ </span><span class="s3">3</span>
        <span class="s1">slo = GroupShuffleSplit(n_splits</span><span class="s2">, </span><span class="s1">test_size=test_size</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s4"># Make sure the repr works</span>
        <span class="s1">repr(slo)</span>

        <span class="s4"># Test that the length is correct</span>
        <span class="s2">assert </span><span class="s1">slo.get_n_splits(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=groups_i) == n_splits</span>

        <span class="s1">l_unique = np.unique(groups_i)</span>
        <span class="s1">l = np.asarray(groups_i)</span>

        <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">slo.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=groups_i):</span>
            <span class="s4"># First test: no train group is in the test set and vice versa</span>
            <span class="s1">l_train_unique = np.unique(l[train])</span>
            <span class="s1">l_test_unique = np.unique(l[test])</span>
            <span class="s2">assert not </span><span class="s1">np.any(np.isin(l[train]</span><span class="s2">, </span><span class="s1">l_test_unique))</span>
            <span class="s2">assert not </span><span class="s1">np.any(np.isin(l[test]</span><span class="s2">, </span><span class="s1">l_train_unique))</span>

            <span class="s4"># Second test: train and test add up to all the data</span>
            <span class="s2">assert </span><span class="s1">l[train].size + l[test].size == l.size</span>

            <span class="s4"># Third test: train and test are disjoint</span>
            <span class="s1">assert_array_equal(np.intersect1d(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">[])</span>

            <span class="s4"># Fourth test:</span>
            <span class="s4"># unique train and test groups are correct, +- 1 for rounding error</span>
            <span class="s2">assert </span><span class="s1">abs(len(l_test_unique) - round(test_size * len(l_unique))) &lt;= </span><span class="s3">1</span>
            <span class="s2">assert </span><span class="s1">(</span>
                <span class="s1">abs(len(l_train_unique) - round((</span><span class="s3">1.0 </span><span class="s1">- test_size) * len(l_unique))) &lt;= </span><span class="s3">1</span>
            <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_leave_one_p_group_out():</span>
    <span class="s1">logo = LeaveOneGroupOut()</span>
    <span class="s1">lpgo_1 = LeavePGroupsOut(n_groups=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">lpgo_2 = LeavePGroupsOut(n_groups=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s4"># Make sure the repr works</span>
    <span class="s2">assert </span><span class="s1">repr(logo) == </span><span class="s5">&quot;LeaveOneGroupOut()&quot;</span>
    <span class="s2">assert </span><span class="s1">repr(lpgo_1) == </span><span class="s5">&quot;LeavePGroupsOut(n_groups=1)&quot;</span>
    <span class="s2">assert </span><span class="s1">repr(lpgo_2) == </span><span class="s5">&quot;LeavePGroupsOut(n_groups=2)&quot;</span>
    <span class="s2">assert </span><span class="s1">repr(LeavePGroupsOut(n_groups=</span><span class="s3">3</span><span class="s1">)) == </span><span class="s5">&quot;LeavePGroupsOut(n_groups=3)&quot;</span>

    <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">(cv</span><span class="s2">, </span><span class="s1">p_groups_out) </span><span class="s2">in </span><span class="s1">enumerate(((logo</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(lpgo_1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(lpgo_2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))):</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">groups_i </span><span class="s2">in </span><span class="s1">enumerate(test_groups):</span>
            <span class="s1">n_groups = len(np.unique(groups_i))</span>
            <span class="s1">n_splits = n_groups </span><span class="s2">if </span><span class="s1">p_groups_out == </span><span class="s3">1 </span><span class="s2">else </span><span class="s1">n_groups * (n_groups - </span><span class="s3">1</span><span class="s1">) / </span><span class="s3">2</span>
            <span class="s1">X = y = np.ones(len(groups_i))</span>

            <span class="s4"># Test that the length is correct</span>
            <span class="s2">assert </span><span class="s1">cv.get_n_splits(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=groups_i) == n_splits</span>

            <span class="s1">groups_arr = np.asarray(groups_i)</span>

            <span class="s4"># Split using the original list / array / list of string groups_i</span>
            <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">cv.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=groups_i):</span>
                <span class="s4"># First test: no train group is in the test set and vice versa</span>
                <span class="s1">assert_array_equal(</span>
                    <span class="s1">np.intersect1d(groups_arr[train]</span><span class="s2">, </span><span class="s1">groups_arr[test]).tolist()</span><span class="s2">, </span><span class="s1">[]</span>
                <span class="s1">)</span>

                <span class="s4"># Second test: train and test add up to all the data</span>
                <span class="s2">assert </span><span class="s1">len(train) + len(test) == len(groups_i)</span>

                <span class="s4"># Third test:</span>
                <span class="s4"># The number of groups in test must be equal to p_groups_out</span>
                <span class="s2">assert </span><span class="s1">np.unique(groups_arr[test]).shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p_groups_out</span>

    <span class="s4"># check get_n_splits() with dummy parameters</span>
    <span class="s2">assert </span><span class="s1">logo.get_n_splits(</span><span class="s2">None, None, </span><span class="s1">[</span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s5">&quot;c&quot;</span><span class="s2">, </span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s5">&quot;c&quot;</span><span class="s1">]) == </span><span class="s3">3</span>
    <span class="s2">assert </span><span class="s1">logo.get_n_splits(groups=[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.1</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.2</span><span class="s1">]) == </span><span class="s3">3</span>
    <span class="s2">assert </span><span class="s1">lpgo_2.get_n_splits(</span><span class="s2">None, None, </span><span class="s1">np.arange(</span><span class="s3">4</span><span class="s1">)) == </span><span class="s3">6</span>
    <span class="s2">assert </span><span class="s1">lpgo_1.get_n_splits(groups=np.arange(</span><span class="s3">4</span><span class="s1">)) == </span><span class="s3">4</span>

    <span class="s4"># raise ValueError if a `groups` parameter is illegal</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">logo.get_n_splits(</span><span class="s2">None, None, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">lpgo_2.get_n_splits(</span><span class="s2">None, None, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">])</span>

    <span class="s1">msg = </span><span class="s5">&quot;The 'groups' parameter should not be None.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">logo.get_n_splits(</span><span class="s2">None, None, None</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">lpgo_1.get_n_splits(</span><span class="s2">None, None, None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_leave_group_out_changing_groups():</span>
    <span class="s4"># Check that LeaveOneGroupOut and LeavePGroupsOut work normally if</span>
    <span class="s4"># the groups variable is changed before calling split</span>
    <span class="s1">groups = np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">X = np.ones(len(groups))</span>
    <span class="s1">groups_changing = np.array(groups</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">lolo = LeaveOneGroupOut().split(X</span><span class="s2">, </span><span class="s1">groups=groups)</span>
    <span class="s1">lolo_changing = LeaveOneGroupOut().split(X</span><span class="s2">, </span><span class="s1">groups=groups)</span>
    <span class="s1">lplo = LeavePGroupsOut(n_groups=</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">groups=groups)</span>
    <span class="s1">lplo_changing = LeavePGroupsOut(n_groups=</span><span class="s3">2</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">groups=groups)</span>
    <span class="s1">groups_changing[:] = </span><span class="s3">0</span>
    <span class="s2">for </span><span class="s1">llo</span><span class="s2">, </span><span class="s1">llo_changing </span><span class="s2">in </span><span class="s1">[(lolo</span><span class="s2">, </span><span class="s1">lolo_changing)</span><span class="s2">, </span><span class="s1">(lplo</span><span class="s2">, </span><span class="s1">lplo_changing)]:</span>
        <span class="s2">for </span><span class="s1">(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">(train_chan</span><span class="s2">, </span><span class="s1">test_chan) </span><span class="s2">in </span><span class="s1">zip(llo</span><span class="s2">, </span><span class="s1">llo_changing):</span>
            <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">train_chan)</span>
            <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">test_chan)</span>

    <span class="s4"># n_splits = no of 2 (p) group combinations of the unique groups = 3C2 = 3</span>
    <span class="s2">assert </span><span class="s3">3 </span><span class="s1">== LeavePGroupsOut(n_groups=</span><span class="s3">2</span><span class="s1">).get_n_splits(X</span><span class="s2">, </span><span class="s1">y=X</span><span class="s2">, </span><span class="s1">groups=groups)</span>
    <span class="s4"># n_splits = no of unique groups (C(uniq_lbls, 1) = n_unique_groups)</span>
    <span class="s2">assert </span><span class="s3">3 </span><span class="s1">== LeaveOneGroupOut().get_n_splits(X</span><span class="s2">, </span><span class="s1">y=X</span><span class="s2">, </span><span class="s1">groups=groups)</span>


<span class="s2">def </span><span class="s1">test_leave_group_out_order_dependence():</span>
    <span class="s4"># Check that LeaveOneGroupOut orders the splits according to the index</span>
    <span class="s4"># of the group left out.</span>
    <span class="s1">groups = np.array([</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">X = np.ones(len(groups))</span>

    <span class="s1">splits = iter(LeaveOneGroupOut().split(X</span><span class="s2">, </span><span class="s1">groups=groups))</span>

    <span class="s1">expected_indices = [</span>
        <span class="s1">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">([</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">expected_train</span><span class="s2">, </span><span class="s1">expected_test </span><span class="s2">in </span><span class="s1">expected_indices:</span>
        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">expected_train)</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">expected_test)</span>


<span class="s2">def </span><span class="s1">test_leave_one_p_group_out_error_on_fewer_number_of_groups():</span>
    <span class="s1">X = y = groups = np.ones(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">msg = re.escape(</span><span class="s5">&quot;Found array with 0 sample(s)&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">next(LeaveOneGroupOut().split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span>

    <span class="s1">X = y = groups = np.ones(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">msg = re.escape(</span>
        <span class="s5">f&quot;The groups parameter contains fewer than 2 unique groups (</span><span class="s2">{</span><span class="s1">groups</span><span class="s2">}</span><span class="s5">).&quot;</span>
        <span class="s5">&quot; LeaveOneGroupOut expects at least 2.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">next(LeaveOneGroupOut().split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span>

    <span class="s1">X = y = groups = np.ones(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">msg = re.escape(</span>
        <span class="s5">&quot;The groups parameter contains fewer than (or equal to) n_groups &quot;</span>
        <span class="s5">f&quot;(3) numbers of unique groups (</span><span class="s2">{</span><span class="s1">groups</span><span class="s2">}</span><span class="s5">). LeavePGroupsOut expects &quot;</span>
        <span class="s5">&quot;that at least n_groups + 1 (4) unique groups &quot;</span>
        <span class="s5">&quot;be present&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">next(LeavePGroupsOut(n_groups=</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span>

    <span class="s1">X = y = groups = np.arange(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">msg = re.escape(</span>
        <span class="s5">&quot;The groups parameter contains fewer than (or equal to) n_groups &quot;</span>
        <span class="s5">f&quot;(3) numbers of unique groups (</span><span class="s2">{</span><span class="s1">groups</span><span class="s2">}</span><span class="s5">). LeavePGroupsOut expects &quot;</span>
        <span class="s5">&quot;that at least n_groups + 1 (4) unique groups &quot;</span>
        <span class="s5">&quot;be present&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">next(LeavePGroupsOut(n_groups=</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span>


<span class="s1">@ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_repeated_cv_value_errors():</span>
    <span class="s4"># n_repeats is not integer or &lt;= 0</span>
    <span class="s2">for </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">(RepeatedKFold</span><span class="s2">, </span><span class="s1">RepeatedStratifiedKFold):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cv(n_repeats=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cv(n_repeats=</span><span class="s3">1.5</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;RepeatedCV&quot;</span><span class="s2">, </span><span class="s1">[RepeatedKFold</span><span class="s2">, </span><span class="s1">RepeatedStratifiedKFold])</span>
<span class="s2">def </span><span class="s1">test_repeated_cv_repr(RepeatedCV):</span>
    <span class="s1">n_splits</span><span class="s2">, </span><span class="s1">n_repeats = </span><span class="s3">2</span><span class="s2">, </span><span class="s3">6</span>
    <span class="s1">repeated_cv = RepeatedCV(n_splits=n_splits</span><span class="s2">, </span><span class="s1">n_repeats=n_repeats)</span>
    <span class="s1">repeated_cv_repr = </span><span class="s5">&quot;{}(n_repeats=6, n_splits=2, random_state=None)&quot;</span><span class="s1">.format(</span>
        <span class="s1">repeated_cv.__class__.__name__</span>
    <span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">repeated_cv_repr == repr(repeated_cv)</span>


<span class="s2">def </span><span class="s1">test_repeated_kfold_determinstic_split():</span>
    <span class="s1">X = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">9</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]]</span>
    <span class="s1">random_state = </span><span class="s3">258173307</span>
    <span class="s1">rkf = RepeatedKFold(n_splits=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">n_repeats=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">random_state=random_state)</span>

    <span class="s4"># split should produce same and deterministic splits on</span>
    <span class="s4"># each call</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
        <span class="s1">splits = rkf.split(X)</span>
        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

        <span class="s2">with </span><span class="s1">pytest.raises(StopIteration):</span>
            <span class="s1">next(splits)</span>


<span class="s2">def </span><span class="s1">test_get_n_splits_for_repeated_kfold():</span>
    <span class="s1">n_splits = </span><span class="s3">3</span>
    <span class="s1">n_repeats = </span><span class="s3">4</span>
    <span class="s1">rkf = RepeatedKFold(n_splits=n_splits</span><span class="s2">, </span><span class="s1">n_repeats=n_repeats)</span>
    <span class="s1">expected_n_splits = n_splits * n_repeats</span>
    <span class="s2">assert </span><span class="s1">expected_n_splits == rkf.get_n_splits()</span>


<span class="s2">def </span><span class="s1">test_get_n_splits_for_repeated_stratified_kfold():</span>
    <span class="s1">n_splits = </span><span class="s3">3</span>
    <span class="s1">n_repeats = </span><span class="s3">4</span>
    <span class="s1">rskf = RepeatedStratifiedKFold(n_splits=n_splits</span><span class="s2">, </span><span class="s1">n_repeats=n_repeats)</span>
    <span class="s1">expected_n_splits = n_splits * n_repeats</span>
    <span class="s2">assert </span><span class="s1">expected_n_splits == rskf.get_n_splits()</span>


<span class="s2">def </span><span class="s1">test_repeated_stratified_kfold_determinstic_split():</span>
    <span class="s1">X = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">9</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]]</span>
    <span class="s1">y = [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">random_state = </span><span class="s3">1944695409</span>
    <span class="s1">rskf = RepeatedStratifiedKFold(n_splits=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">n_repeats=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">random_state=random_state)</span>

    <span class="s4"># split should produce same and deterministic splits on</span>
    <span class="s4"># each call</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
        <span class="s1">splits = rskf.split(X</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

        <span class="s2">with </span><span class="s1">pytest.raises(StopIteration):</span>
            <span class="s1">next(splits)</span>


<span class="s2">def </span><span class="s1">test_train_test_split_errors():</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">train_test_split)</span>

    <span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">train_test_split</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">train_size=</span><span class="s3">1.1</span><span class="s1">)</span>

    <span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">train_test_split</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.6</span><span class="s2">, </span><span class="s1">train_size=</span><span class="s3">0.6</span><span class="s1">)</span>
    <span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">train_test_split</span><span class="s2">,</span>
        <span class="s1">range(</span><span class="s3">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">test_size=np.float32(</span><span class="s3">0.6</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">train_size=np.float32(</span><span class="s3">0.6</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">train_test_split</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s5">&quot;wrong_type&quot;</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">train_test_split</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">train_size=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">train_test_split</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">some_argument=</span><span class="s3">1.1</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">train_test_split</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">42</span><span class="s1">))</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">train_test_split</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">False, </span><span class="s1">stratify=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">match=</span><span class="s5">r&quot;train_size=11 should be either positive and &quot;</span>
        <span class="s5">r&quot;smaller than the number of samples 10 or a &quot;</span>
        <span class="s5">r&quot;float in the \(0, 1\) range&quot;</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">train_test_split(range(</span><span class="s3">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">train_size=</span><span class="s3">11</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;train_size, exp_train, exp_test&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s2">None, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">8</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0.8</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_train_test_split_default_test_size(train_size</span><span class="s2">, </span><span class="s1">exp_train</span><span class="s2">, </span><span class="s1">exp_test):</span>
    <span class="s4"># Check that the default value has the expected behavior, i.e. complement</span>
    <span class="s4"># train_size unless both are specified.</span>
    <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test = train_test_split(X</span><span class="s2">, </span><span class="s1">train_size=train_size)</span>

    <span class="s2">assert </span><span class="s1">len(X_train) == exp_train</span>
    <span class="s2">assert </span><span class="s1">len(X_test) == exp_test</span>


<span class="s2">def </span><span class="s1">test_train_test_split():</span>
    <span class="s1">X = np.arange(</span><span class="s3">100</span><span class="s1">).reshape((</span><span class="s3">10</span><span class="s2">, </span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">X_s = coo_matrix(X)</span>
    <span class="s1">y = np.arange(</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s4"># simple test</span>
    <span class="s1">split = train_test_split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s2">None, </span><span class="s1">train_size=</span><span class="s3">0.5</span><span class="s1">)</span>
    <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test</span><span class="s2">, </span><span class="s1">y_train</span><span class="s2">, </span><span class="s1">y_test = split</span>
    <span class="s2">assert </span><span class="s1">len(y_test) == len(y_train)</span>
    <span class="s4"># test correspondence of X and y</span>
    <span class="s1">assert_array_equal(X_train[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y_train * </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(X_test[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y_test * </span><span class="s3">10</span><span class="s1">)</span>

    <span class="s4"># don't convert lists to anything else by default</span>
    <span class="s1">split = train_test_split(X</span><span class="s2">, </span><span class="s1">X_s</span><span class="s2">, </span><span class="s1">y.tolist())</span>
    <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test</span><span class="s2">, </span><span class="s1">X_s_train</span><span class="s2">, </span><span class="s1">X_s_test</span><span class="s2">, </span><span class="s1">y_train</span><span class="s2">, </span><span class="s1">y_test = split</span>
    <span class="s2">assert </span><span class="s1">isinstance(y_train</span><span class="s2">, </span><span class="s1">list)</span>
    <span class="s2">assert </span><span class="s1">isinstance(y_test</span><span class="s2">, </span><span class="s1">list)</span>

    <span class="s4"># allow nd-arrays</span>
    <span class="s1">X_4d = np.arange(</span><span class="s3">10 </span><span class="s1">* </span><span class="s3">5 </span><span class="s1">* </span><span class="s3">3 </span><span class="s1">* </span><span class="s3">2</span><span class="s1">).reshape(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">y_3d = np.arange(</span><span class="s3">10 </span><span class="s1">* </span><span class="s3">7 </span><span class="s1">* </span><span class="s3">11</span><span class="s1">).reshape(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">11</span><span class="s1">)</span>
    <span class="s1">split = train_test_split(X_4d</span><span class="s2">, </span><span class="s1">y_3d)</span>
    <span class="s2">assert </span><span class="s1">split[</span><span class="s3">0</span><span class="s1">].shape == (</span><span class="s3">7</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">split[</span><span class="s3">1</span><span class="s1">].shape == (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">split[</span><span class="s3">2</span><span class="s1">].shape == (</span><span class="s3">7</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">11</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">split[</span><span class="s3">3</span><span class="s1">].shape == (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">11</span><span class="s1">)</span>

    <span class="s4"># test stratification option</span>
    <span class="s1">y = np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s2">for </span><span class="s1">test_size</span><span class="s2">, </span><span class="s1">exp_test_size </span><span class="s2">in </span><span class="s1">zip([</span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">0.25</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.75</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]):</span>
        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = train_test_split(</span>
            <span class="s1">y</span><span class="s2">, </span><span class="s1">test_size=test_size</span><span class="s2">, </span><span class="s1">stratify=y</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">len(test) == exp_test_size</span>
        <span class="s2">assert </span><span class="s1">len(test) + len(train) == len(y)</span>
        <span class="s4"># check the 1:1 ratio of ones and twos in the data is preserved</span>
        <span class="s2">assert </span><span class="s1">np.sum(train == </span><span class="s3">1</span><span class="s1">) == np.sum(train == </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s4"># test unshuffled split</span>
    <span class="s1">y = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">test_size </span><span class="s2">in </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0.2</span><span class="s1">]:</span>
        <span class="s1">train</span><span class="s2">, </span><span class="s1">test = train_test_split(y</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">False, </span><span class="s1">test_size=test_size)</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">8</span><span class="s2">, </span><span class="s3">9</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_train_test_split_32bit_overflow():</span>
    <span class="s0">&quot;&quot;&quot;Check for integer overflow on 32-bit platforms. 
 
    Non-regression test for: 
    https://github.com/scikit-learn/scikit-learn/issues/20774 
    &quot;&quot;&quot;</span>

    <span class="s4"># A number 'n' big enough for expression 'n * n * train_size' to cause</span>
    <span class="s4"># an overflow for signed 32-bit integer</span>
    <span class="s1">big_number = </span><span class="s3">100000</span>

    <span class="s4"># Definition of 'y' is a part of reproduction - population for at least</span>
    <span class="s4"># one class should be in the same order of magnitude as size of X</span>
    <span class="s1">X = np.arange(big_number)</span>
    <span class="s1">y = X &gt; (</span><span class="s3">0.99 </span><span class="s1">* big_number)</span>

    <span class="s1">split = train_test_split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">stratify=y</span><span class="s2">, </span><span class="s1">train_size=</span><span class="s3">0.25</span><span class="s1">)</span>
    <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test</span><span class="s2">, </span><span class="s1">y_train</span><span class="s2">, </span><span class="s1">y_test = split</span>

    <span class="s2">assert </span><span class="s1">X_train.size + X_test.size == big_number</span>
    <span class="s2">assert </span><span class="s1">y_train.size + y_test.size == big_number</span>


<span class="s1">@ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_train_test_split_pandas():</span>
    <span class="s4"># check train_test_split doesn't destroy pandas dataframe</span>
    <span class="s1">types = [MockDataFrame]</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">DataFrame</span>

        <span class="s1">types.append(DataFrame)</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">pass</span>
    <span class="s2">for </span><span class="s1">InputFeatureType </span><span class="s2">in </span><span class="s1">types:</span>
        <span class="s4"># X dataframe</span>
        <span class="s1">X_df = InputFeatureType(X)</span>
        <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test = train_test_split(X_df)</span>
        <span class="s2">assert </span><span class="s1">isinstance(X_train</span><span class="s2">, </span><span class="s1">InputFeatureType)</span>
        <span class="s2">assert </span><span class="s1">isinstance(X_test</span><span class="s2">, </span><span class="s1">InputFeatureType)</span>


<span class="s2">def </span><span class="s1">test_train_test_split_sparse():</span>
    <span class="s4"># check that train_test_split converts scipy sparse matrices</span>
    <span class="s4"># to csr, as stated in the documentation</span>
    <span class="s1">X = np.arange(</span><span class="s3">100</span><span class="s1">).reshape((</span><span class="s3">10</span><span class="s2">, </span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">sparse_types = [csr_matrix</span><span class="s2">, </span><span class="s1">csc_matrix</span><span class="s2">, </span><span class="s1">coo_matrix]</span>
    <span class="s2">for </span><span class="s1">InputFeatureType </span><span class="s2">in </span><span class="s1">sparse_types:</span>
        <span class="s1">X_s = InputFeatureType(X)</span>
        <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test = train_test_split(X_s)</span>
        <span class="s2">assert </span><span class="s1">issparse(X_train) </span><span class="s2">and </span><span class="s1">X_train.format == </span><span class="s5">&quot;csr&quot;</span>
        <span class="s2">assert </span><span class="s1">issparse(X_test) </span><span class="s2">and </span><span class="s1">X_test.format == </span><span class="s5">&quot;csr&quot;</span>


<span class="s2">def </span><span class="s1">test_train_test_split_mock_pandas():</span>
    <span class="s4"># X mock dataframe</span>
    <span class="s1">X_df = MockDataFrame(X)</span>
    <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test = train_test_split(X_df)</span>
    <span class="s2">assert </span><span class="s1">isinstance(X_train</span><span class="s2">, </span><span class="s1">MockDataFrame)</span>
    <span class="s2">assert </span><span class="s1">isinstance(X_test</span><span class="s2">, </span><span class="s1">MockDataFrame)</span>
    <span class="s1">X_train_arr</span><span class="s2">, </span><span class="s1">X_test_arr = train_test_split(X_df)</span>


<span class="s2">def </span><span class="s1">test_train_test_split_list_input():</span>
    <span class="s4"># Check that when y is a list / list of string labels, it works.</span>
    <span class="s1">X = np.ones(</span><span class="s3">7</span><span class="s1">)</span>
    <span class="s1">y1 = [</span><span class="s5">&quot;1&quot;</span><span class="s1">] * </span><span class="s3">4 </span><span class="s1">+ [</span><span class="s5">&quot;0&quot;</span><span class="s1">] * </span><span class="s3">3</span>
    <span class="s1">y2 = np.hstack((np.ones(</span><span class="s3">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.zeros(</span><span class="s3">3</span><span class="s1">)))</span>
    <span class="s1">y3 = y2.tolist()</span>

    <span class="s2">for </span><span class="s1">stratify </span><span class="s2">in </span><span class="s1">(</span><span class="s2">True, False</span><span class="s1">):</span>
        <span class="s1">X_train1</span><span class="s2">, </span><span class="s1">X_test1</span><span class="s2">, </span><span class="s1">y_train1</span><span class="s2">, </span><span class="s1">y_test1 = train_test_split(</span>
            <span class="s1">X</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">stratify=y1 </span><span class="s2">if </span><span class="s1">stratify </span><span class="s2">else None, </span><span class="s1">random_state=</span><span class="s3">0</span>
        <span class="s1">)</span>
        <span class="s1">X_train2</span><span class="s2">, </span><span class="s1">X_test2</span><span class="s2">, </span><span class="s1">y_train2</span><span class="s2">, </span><span class="s1">y_test2 = train_test_split(</span>
            <span class="s1">X</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">stratify=y2 </span><span class="s2">if </span><span class="s1">stratify </span><span class="s2">else None, </span><span class="s1">random_state=</span><span class="s3">0</span>
        <span class="s1">)</span>
        <span class="s1">X_train3</span><span class="s2">, </span><span class="s1">X_test3</span><span class="s2">, </span><span class="s1">y_train3</span><span class="s2">, </span><span class="s1">y_test3 = train_test_split(</span>
            <span class="s1">X</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">, </span><span class="s1">stratify=y3 </span><span class="s2">if </span><span class="s1">stratify </span><span class="s2">else None, </span><span class="s1">random_state=</span><span class="s3">0</span>
        <span class="s1">)</span>

        <span class="s1">np.testing.assert_equal(X_train1</span><span class="s2">, </span><span class="s1">X_train2)</span>
        <span class="s1">np.testing.assert_equal(y_train2</span><span class="s2">, </span><span class="s1">y_train3)</span>
        <span class="s1">np.testing.assert_equal(X_test1</span><span class="s2">, </span><span class="s1">X_test3)</span>
        <span class="s1">np.testing.assert_equal(y_test3</span><span class="s2">, </span><span class="s1">y_test2)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;test_size, train_size&quot;</span><span class="s2">,</span>
    <span class="s1">[(</span><span class="s3">2.0</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1.0</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.95</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, </span><span class="s3">1j</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">11</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">10</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">8</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_shufflesplit_errors(test_size</span><span class="s2">, </span><span class="s1">train_size):</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">next(ShuffleSplit(test_size=test_size</span><span class="s2">, </span><span class="s1">train_size=train_size).split(X))</span>


<span class="s2">def </span><span class="s1">test_shufflesplit_reproducible():</span>
    <span class="s4"># Check that iterating twice on the ShuffleSplit gives the same</span>
    <span class="s4"># sequence of train-test when the random_state is given</span>
    <span class="s1">ss = ShuffleSplit(random_state=</span><span class="s3">21</span><span class="s1">)</span>
    <span class="s1">assert_array_equal([a </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">ss.split(X)]</span><span class="s2">, </span><span class="s1">[a </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">ss.split(X)])</span>


<span class="s2">def </span><span class="s1">test_stratifiedshufflesplit_list_input():</span>
    <span class="s4"># Check that when y is a list / list of string labels, it works.</span>
    <span class="s1">sss = StratifiedShuffleSplit(test_size=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
    <span class="s1">X = np.ones(</span><span class="s3">7</span><span class="s1">)</span>
    <span class="s1">y1 = [</span><span class="s5">&quot;1&quot;</span><span class="s1">] * </span><span class="s3">4 </span><span class="s1">+ [</span><span class="s5">&quot;0&quot;</span><span class="s1">] * </span><span class="s3">3</span>
    <span class="s1">y2 = np.hstack((np.ones(</span><span class="s3">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.zeros(</span><span class="s3">3</span><span class="s1">)))</span>
    <span class="s1">y3 = y2.tolist()</span>

    <span class="s1">np.testing.assert_equal(list(sss.split(X</span><span class="s2">, </span><span class="s1">y1))</span><span class="s2">, </span><span class="s1">list(sss.split(X</span><span class="s2">, </span><span class="s1">y2)))</span>
    <span class="s1">np.testing.assert_equal(list(sss.split(X</span><span class="s2">, </span><span class="s1">y3))</span><span class="s2">, </span><span class="s1">list(sss.split(X</span><span class="s2">, </span><span class="s1">y2)))</span>


<span class="s2">def </span><span class="s1">test_train_test_split_allow_nans():</span>
    <span class="s4"># Check that train_test_split allows input data with NaNs</span>
    <span class="s1">X = np.arange(</span><span class="s3">200</span><span class="s2">, </span><span class="s1">dtype=np.float64).reshape(</span><span class="s3">10</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">X[</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s1">y = np.repeat([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">X.shape[</span><span class="s3">0</span><span class="s1">] / </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">train_test_split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_check_cv():</span>
    <span class="s1">X = np.ones(</span><span class="s3">9</span><span class="s1">)</span>
    <span class="s1">cv = check_cv(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">classifier=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s4"># Use numpy.testing.assert_equal which recursively compares</span>
    <span class="s4"># lists of lists</span>
    <span class="s1">np.testing.assert_equal(list(KFold(</span><span class="s3">3</span><span class="s1">).split(X))</span><span class="s2">, </span><span class="s1">list(cv.split(X)))</span>

    <span class="s1">y_binary = np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">cv = check_cv(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">y_binary</span><span class="s2">, </span><span class="s1">classifier=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_equal(</span>
        <span class="s1">list(StratifiedKFold(</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y_binary))</span><span class="s2">, </span><span class="s1">list(cv.split(X</span><span class="s2">, </span><span class="s1">y_binary))</span>
    <span class="s1">)</span>

    <span class="s1">y_multiclass = np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">cv = check_cv(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">y_multiclass</span><span class="s2">, </span><span class="s1">classifier=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_equal(</span>
        <span class="s1">list(StratifiedKFold(</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y_multiclass))</span><span class="s2">, </span><span class="s1">list(cv.split(X</span><span class="s2">, </span><span class="s1">y_multiclass))</span>
    <span class="s1">)</span>
    <span class="s4"># also works with 2d multiclass</span>
    <span class="s1">y_multiclass_2d = y_multiclass.reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">cv = check_cv(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">y_multiclass_2d</span><span class="s2">, </span><span class="s1">classifier=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_equal(</span>
        <span class="s1">list(StratifiedKFold(</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y_multiclass_2d))</span><span class="s2">,</span>
        <span class="s1">list(cv.split(X</span><span class="s2">, </span><span class="s1">y_multiclass_2d))</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">assert not </span><span class="s1">np.all(</span>
        <span class="s1">next(StratifiedKFold(</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y_multiclass_2d))[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">== next(KFold(</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y_multiclass_2d))[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">X = np.ones(</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">y_multilabel = np.array(</span>
        <span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]]</span>
    <span class="s1">)</span>
    <span class="s1">cv = check_cv(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">y_multilabel</span><span class="s2">, </span><span class="s1">classifier=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_equal(list(KFold(</span><span class="s3">3</span><span class="s1">).split(X))</span><span class="s2">, </span><span class="s1">list(cv.split(X)))</span>

    <span class="s1">y_multioutput = np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">cv = check_cv(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">y_multioutput</span><span class="s2">, </span><span class="s1">classifier=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_equal(list(KFold(</span><span class="s3">3</span><span class="s1">).split(X))</span><span class="s2">, </span><span class="s1">list(cv.split(X)))</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">check_cv(cv=</span><span class="s5">&quot;lolo&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_cv_iterable_wrapper():</span>
    <span class="s1">kf_iter = KFold().split(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">kf_iter_wrapped = check_cv(kf_iter)</span>
    <span class="s4"># Since the wrapped iterable is enlisted and stored,</span>
    <span class="s4"># split can be called any number of times to produce</span>
    <span class="s4"># consistent results.</span>
    <span class="s1">np.testing.assert_equal(</span>
        <span class="s1">list(kf_iter_wrapped.split(X</span><span class="s2">, </span><span class="s1">y))</span><span class="s2">, </span><span class="s1">list(kf_iter_wrapped.split(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s1">)</span>
    <span class="s4"># If the splits are randomized, successive calls to split yields different</span>
    <span class="s4"># results</span>
    <span class="s1">kf_randomized_iter = KFold(shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">kf_randomized_iter_wrapped = check_cv(kf_randomized_iter)</span>
    <span class="s4"># numpy's assert_array_equal properly compares nested lists</span>
    <span class="s1">np.testing.assert_equal(</span>
        <span class="s1">list(kf_randomized_iter_wrapped.split(X</span><span class="s2">, </span><span class="s1">y))</span><span class="s2">,</span>
        <span class="s1">list(kf_randomized_iter_wrapped.split(X</span><span class="s2">, </span><span class="s1">y))</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">splits_are_equal = </span><span class="s2">True</span>
        <span class="s1">np.testing.assert_equal(</span>
            <span class="s1">list(kf_iter_wrapped.split(X</span><span class="s2">, </span><span class="s1">y))</span><span class="s2">,</span>
            <span class="s1">list(kf_randomized_iter_wrapped.split(X</span><span class="s2">, </span><span class="s1">y))</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">except </span><span class="s1">AssertionError:</span>
        <span class="s1">splits_are_equal = </span><span class="s2">False</span>
    <span class="s2">assert not </span><span class="s1">splits_are_equal</span><span class="s2">, </span><span class="s1">(</span>
        <span class="s5">&quot;If the splits are randomized, &quot;</span>
        <span class="s5">&quot;successive calls to split should yield different results&quot;</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;kfold&quot;</span><span class="s2">, </span><span class="s1">[GroupKFold</span><span class="s2">, </span><span class="s1">StratifiedGroupKFold])</span>
<span class="s2">def </span><span class="s1">test_group_kfold(kfold):</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s4"># Parameters of the test</span>
    <span class="s1">n_groups = </span><span class="s3">15</span>
    <span class="s1">n_samples = </span><span class="s3">1000</span>
    <span class="s1">n_splits = </span><span class="s3">5</span>

    <span class="s1">X = y = np.ones(n_samples)</span>

    <span class="s4"># Construct the test data</span>
    <span class="s1">tolerance = </span><span class="s3">0.05 </span><span class="s1">* n_samples  </span><span class="s4"># 5 percent error allowed</span>
    <span class="s1">groups = rng.randint(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">n_groups</span><span class="s2">, </span><span class="s1">n_samples)</span>

    <span class="s1">ideal_n_groups_per_fold = n_samples // n_splits</span>

    <span class="s1">len(np.unique(groups))</span>
    <span class="s4"># Get the test fold indices from the test set indices of each fold</span>
    <span class="s1">folds = np.zeros(n_samples)</span>
    <span class="s1">lkf = kfold(n_splits=n_splits)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">test) </span><span class="s2">in </span><span class="s1">enumerate(lkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups)):</span>
        <span class="s1">folds[test] = i</span>

    <span class="s4"># Check that folds have approximately the same size</span>
    <span class="s2">assert </span><span class="s1">len(folds) == len(groups)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">np.unique(folds):</span>
        <span class="s2">assert </span><span class="s1">tolerance &gt;= abs(sum(folds == i) - ideal_n_groups_per_fold)</span>

    <span class="s4"># Check that each group appears only in 1 fold</span>
    <span class="s2">for </span><span class="s1">group </span><span class="s2">in </span><span class="s1">np.unique(groups):</span>
        <span class="s2">assert </span><span class="s1">len(np.unique(folds[groups == group])) == </span><span class="s3">1</span>

    <span class="s4"># Check that no group is on both sides of the split</span>
    <span class="s1">groups = np.asarray(groups</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">lkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups):</span>
        <span class="s2">assert </span><span class="s1">len(np.intersect1d(groups[train]</span><span class="s2">, </span><span class="s1">groups[test])) == </span><span class="s3">0</span>

    <span class="s4"># Construct the test data</span>
    <span class="s1">groups = np.array(</span>
        <span class="s1">[</span>
            <span class="s5">&quot;Albert&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Jean&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Bertrand&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Michel&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Jean&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Francis&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Robert&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Michel&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Rachel&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Lois&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Michelle&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Bernard&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Marion&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Laura&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Jean&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Rachel&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Franck&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;John&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Gael&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Anna&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Alix&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Robert&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Marion&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;David&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Tony&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Abel&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Becky&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Madmood&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Cary&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Mary&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Alexandre&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;David&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Francis&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Barack&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Abdoul&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Rasha&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Xi&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;Silvia&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">n_groups = len(np.unique(groups))</span>
    <span class="s1">n_samples = len(groups)</span>
    <span class="s1">n_splits = </span><span class="s3">5</span>
    <span class="s1">tolerance = </span><span class="s3">0.05 </span><span class="s1">* n_samples  </span><span class="s4"># 5 percent error allowed</span>
    <span class="s1">ideal_n_groups_per_fold = n_samples // n_splits</span>

    <span class="s1">X = y = np.ones(n_samples)</span>

    <span class="s4"># Get the test fold indices from the test set indices of each fold</span>
    <span class="s1">folds = np.zeros(n_samples)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">test) </span><span class="s2">in </span><span class="s1">enumerate(lkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups)):</span>
        <span class="s1">folds[test] = i</span>

    <span class="s4"># Check that folds have approximately the same size</span>
    <span class="s2">assert </span><span class="s1">len(folds) == len(groups)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">np.unique(folds):</span>
        <span class="s2">assert </span><span class="s1">tolerance &gt;= abs(sum(folds == i) - ideal_n_groups_per_fold)</span>

    <span class="s4"># Check that each group appears only in 1 fold</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">FutureWarning)</span>
        <span class="s2">for </span><span class="s1">group </span><span class="s2">in </span><span class="s1">np.unique(groups):</span>
            <span class="s2">assert </span><span class="s1">len(np.unique(folds[groups == group])) == </span><span class="s3">1</span>

    <span class="s4"># Check that no group is on both sides of the split</span>
    <span class="s1">groups = np.asarray(groups</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s2">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">lkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups):</span>
        <span class="s2">assert </span><span class="s1">len(np.intersect1d(groups[train]</span><span class="s2">, </span><span class="s1">groups[test])) == </span><span class="s3">0</span>

    <span class="s4"># groups can also be a list</span>
    <span class="s1">cv_iter = list(lkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups.tolist()))</span>
    <span class="s2">for </span><span class="s1">(train1</span><span class="s2">, </span><span class="s1">test1)</span><span class="s2">, </span><span class="s1">(train2</span><span class="s2">, </span><span class="s1">test2) </span><span class="s2">in </span><span class="s1">zip(lkf.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups)</span><span class="s2">, </span><span class="s1">cv_iter):</span>
        <span class="s1">assert_array_equal(train1</span><span class="s2">, </span><span class="s1">train2)</span>
        <span class="s1">assert_array_equal(test1</span><span class="s2">, </span><span class="s1">test2)</span>

    <span class="s4"># Should fail if there are more folds than groups</span>
    <span class="s1">groups = np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">X = y = np.ones(len(groups))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Cannot have number of splits.*greater&quot;</span><span class="s1">):</span>
        <span class="s1">next(GroupKFold(n_splits=</span><span class="s3">3</span><span class="s1">).split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups))</span>


<span class="s2">def </span><span class="s1">test_time_series_cv():</span>
    <span class="s1">X = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">9</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">11</span><span class="s2">, </span><span class="s3">12</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">13</span><span class="s2">, </span><span class="s3">14</span><span class="s1">]]</span>

    <span class="s4"># Should fail if there are more folds than samples</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Cannot have number of folds.*greater&quot;</span><span class="s1">):</span>
        <span class="s1">next(TimeSeriesSplit(n_splits=</span><span class="s3">7</span><span class="s1">).split(X))</span>

    <span class="s1">tscv = TimeSeriesSplit(</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s4"># Manually check that Time Series CV preserves the data</span>
    <span class="s4"># ordering on toy datasets</span>
    <span class="s1">splits = tscv.split(X[:-</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">])</span>

    <span class="s1">splits = TimeSeriesSplit(</span><span class="s3">2</span><span class="s1">).split(X)</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span>

    <span class="s4"># Check get_n_splits returns the correct number of splits</span>
    <span class="s1">splits = TimeSeriesSplit(</span><span class="s3">2</span><span class="s1">).split(X)</span>
    <span class="s1">n_splits_actual = len(list(splits))</span>
    <span class="s2">assert </span><span class="s1">n_splits_actual == tscv.get_n_splits()</span>
    <span class="s2">assert </span><span class="s1">n_splits_actual == </span><span class="s3">2</span>


<span class="s2">def </span><span class="s1">_check_time_series_max_train_size(splits</span><span class="s2">, </span><span class="s1">check_splits</span><span class="s2">, </span><span class="s1">max_train_size):</span>
    <span class="s2">for </span><span class="s1">(train</span><span class="s2">, </span><span class="s1">test)</span><span class="s2">, </span><span class="s1">(check_train</span><span class="s2">, </span><span class="s1">check_test) </span><span class="s2">in </span><span class="s1">zip(splits</span><span class="s2">, </span><span class="s1">check_splits):</span>
        <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">check_test)</span>
        <span class="s2">assert </span><span class="s1">len(check_train) &lt;= max_train_size</span>
        <span class="s1">suffix_start = max(len(train) - max_train_size</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(check_train</span><span class="s2">, </span><span class="s1">train[suffix_start:])</span>


<span class="s2">def </span><span class="s1">test_time_series_max_train_size():</span>
    <span class="s1">X = np.zeros((</span><span class="s3">6</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">3</span><span class="s1">).split(X)</span>
    <span class="s1">check_splits = TimeSeriesSplit(n_splits=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">3</span><span class="s1">).split(X)</span>
    <span class="s1">_check_time_series_max_train_size(splits</span><span class="s2">, </span><span class="s1">check_splits</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s4"># Test for the case where the size of a fold is greater than max_train_size</span>
    <span class="s1">check_splits = TimeSeriesSplit(n_splits=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">2</span><span class="s1">).split(X)</span>
    <span class="s1">_check_time_series_max_train_size(splits</span><span class="s2">, </span><span class="s1">check_splits</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s4"># Test for the case where the size of each fold is less than max_train_size</span>
    <span class="s1">check_splits = TimeSeriesSplit(n_splits=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">5</span><span class="s1">).split(X)</span>
    <span class="s1">_check_time_series_max_train_size(splits</span><span class="s2">, </span><span class="s1">check_splits</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">2</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_time_series_test_size():</span>
    <span class="s1">X = np.zeros((</span><span class="s3">10</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s4"># Test alone</span>
    <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">3</span><span class="s1">).split(X)</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">9</span><span class="s1">])</span>

    <span class="s4"># Test with max_train_size</span>
    <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">4</span><span class="s1">).split(X)</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">8</span><span class="s2">, </span><span class="s3">9</span><span class="s1">])</span>

    <span class="s4"># Should fail with not enough data points for configuration</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Too many splits.*with test_size&quot;</span><span class="s1">):</span>
        <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">5</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">2</span><span class="s1">).split(X)</span>
        <span class="s1">next(splits)</span>


<span class="s2">def </span><span class="s1">test_time_series_gap():</span>
    <span class="s1">X = np.zeros((</span><span class="s3">10</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s4"># Test alone</span>
    <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">gap=</span><span class="s3">2</span><span class="s1">).split(X)</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">9</span><span class="s1">])</span>

    <span class="s4"># Test with max_train_size</span>
    <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">gap=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">2</span><span class="s1">).split(X)</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">8</span><span class="s2">, </span><span class="s3">9</span><span class="s1">])</span>

    <span class="s4"># Test with test_size</span>
    <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">gap=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">max_train_size=</span><span class="s3">4</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">2</span><span class="s1">).split(X)</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">8</span><span class="s2">, </span><span class="s3">9</span><span class="s1">])</span>

    <span class="s4"># Test with additional test_size</span>
    <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">gap=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">3</span><span class="s1">).split(X)</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">])</span>

    <span class="s1">train</span><span class="s2">, </span><span class="s1">test = next(splits)</span>
    <span class="s1">assert_array_equal(train</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(test</span><span class="s2">, </span><span class="s1">[</span><span class="s3">7</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">9</span><span class="s1">])</span>

    <span class="s4"># Verify proper error is thrown</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Too many splits.*and gap&quot;</span><span class="s1">):</span>
        <span class="s1">splits = TimeSeriesSplit(n_splits=</span><span class="s3">4</span><span class="s2">, </span><span class="s1">gap=</span><span class="s3">2</span><span class="s1">).split(X)</span>
        <span class="s1">next(splits)</span>


<span class="s2">def </span><span class="s1">test_nested_cv():</span>
    <span class="s4"># Test if nested cross validation works with different combinations of cv</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = make_classification(n_samples=</span><span class="s3">15</span><span class="s2">, </span><span class="s1">n_classes=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">groups = rng.randint(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">15</span><span class="s1">)</span>

    <span class="s1">cvs = [</span>
        <span class="s1">LeaveOneGroupOut()</span><span class="s2">,</span>
        <span class="s1">StratifiedKFold(n_splits=</span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">LeaveOneOut()</span><span class="s2">,</span>
        <span class="s1">GroupKFold(n_splits=</span><span class="s3">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">StratifiedKFold()</span><span class="s2">,</span>
        <span class="s1">StratifiedGroupKFold()</span><span class="s2">,</span>
        <span class="s1">StratifiedShuffleSplit(n_splits=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">inner_cv</span><span class="s2">, </span><span class="s1">outer_cv </span><span class="s2">in </span><span class="s1">combinations_with_replacement(cvs</span><span class="s2">, </span><span class="s3">2</span><span class="s1">):</span>
        <span class="s1">gs = GridSearchCV(</span>
            <span class="s1">DummyClassifier()</span><span class="s2">,</span>
            <span class="s1">param_grid={</span><span class="s5">&quot;strategy&quot;</span><span class="s1">: [</span><span class="s5">&quot;stratified&quot;</span><span class="s2">, </span><span class="s5">&quot;most_frequent&quot;</span><span class="s1">]}</span><span class="s2">,</span>
            <span class="s1">cv=inner_cv</span><span class="s2">,</span>
            <span class="s1">error_score=</span><span class="s5">&quot;raise&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">cross_val_score(</span>
            <span class="s1">gs</span><span class="s2">, </span><span class="s1">X=X</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">groups=groups</span><span class="s2">, </span><span class="s1">cv=outer_cv</span><span class="s2">, </span><span class="s1">fit_params={</span><span class="s5">&quot;groups&quot;</span><span class="s1">: groups}</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_build_repr():</span>
    <span class="s2">class </span><span class="s1">MockSplitter:</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">c=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s1">self.a = a</span>
            <span class="s1">self.b = b</span>
            <span class="s1">self.c = c</span>

        <span class="s2">def </span><span class="s1">__repr__(self):</span>
            <span class="s2">return </span><span class="s1">_build_repr(self)</span>

    <span class="s2">assert </span><span class="s1">repr(MockSplitter(</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">)) == </span><span class="s5">&quot;MockSplitter(a=5, b=6, c=None)&quot;</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;CVSplitter&quot;</span><span class="s2">, </span><span class="s1">(ShuffleSplit</span><span class="s2">, </span><span class="s1">GroupShuffleSplit</span><span class="s2">, </span><span class="s1">StratifiedShuffleSplit)</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_shuffle_split_empty_trainset(CVSplitter):</span>
    <span class="s1">cv = CVSplitter(test_size=</span><span class="s3">0.99</span><span class="s1">)</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = [[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]  </span><span class="s4"># 1 sample</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">match=(</span>
            <span class="s5">&quot;With n_samples=1, test_size=0.99 and train_size=None, &quot;</span>
            <span class="s5">&quot;the resulting train set will be empty&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">next(cv.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=[</span><span class="s3">1</span><span class="s1">]))</span>


<span class="s2">def </span><span class="s1">test_train_test_split_empty_trainset():</span>
    <span class="s1">(X</span><span class="s2">,</span><span class="s1">) = [[</span><span class="s3">1</span><span class="s1">]]  </span><span class="s4"># 1 sample</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">match=(</span>
            <span class="s5">&quot;With n_samples=1, test_size=0.99 and train_size=None, &quot;</span>
            <span class="s5">&quot;the resulting train set will be empty&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">train_test_split(X</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.99</span><span class="s1">)</span>

    <span class="s1">X = [[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]  </span><span class="s4"># 3 samples, ask for more than 2 thirds</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">match=(</span>
            <span class="s5">&quot;With n_samples=3, test_size=0.67 and train_size=None, &quot;</span>
            <span class="s5">&quot;the resulting train set will be empty&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">train_test_split(X</span><span class="s2">, </span><span class="s1">test_size=</span><span class="s3">0.67</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_leave_one_out_empty_trainset():</span>
    <span class="s4"># LeaveOneGroup out expect at least 2 groups so no need to check</span>
    <span class="s1">cv = LeaveOneOut()</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = [[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]  </span><span class="s4"># 1 sample</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Cannot perform LeaveOneOut with n_samples=1&quot;</span><span class="s1">):</span>
        <span class="s1">next(cv.split(X</span><span class="s2">, </span><span class="s1">y))</span>


<span class="s2">def </span><span class="s1">test_leave_p_out_empty_trainset():</span>
    <span class="s4"># No need to check LeavePGroupsOut</span>
    <span class="s1">cv = LeavePOut(p=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = [[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]  </span><span class="s4"># 2 samples</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;p=2 must be strictly less than the number of samples=2&quot;</span>
    <span class="s1">):</span>
        <span class="s1">next(cv.split(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">groups=[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;Klass&quot;</span><span class="s2">, </span><span class="s1">(KFold</span><span class="s2">, </span><span class="s1">StratifiedKFold</span><span class="s2">, </span><span class="s1">StratifiedGroupKFold))</span>
<span class="s2">def </span><span class="s1">test_random_state_shuffle_false(Klass):</span>
    <span class="s4"># passing a non-default random_state when shuffle=False makes no sense</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;has no effect since shuffle is False&quot;</span><span class="s1">):</span>
        <span class="s1">Klass(</span><span class="s3">3</span><span class="s2">, </span><span class="s1">shuffle=</span><span class="s2">False, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;cv, expected&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(KFold()</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(KFold(shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">123</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedKFold()</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedKFold(shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">123</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedGroupKFold(shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s3">123</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedGroupKFold()</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(RepeatedKFold(random_state=</span><span class="s3">123</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(RepeatedStratifiedKFold(random_state=</span><span class="s3">123</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(ShuffleSplit(random_state=</span><span class="s3">123</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(GroupShuffleSplit(random_state=</span><span class="s3">123</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedShuffleSplit(random_state=</span><span class="s3">123</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(GroupKFold()</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(TimeSeriesSplit()</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(LeaveOneOut()</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(LeaveOneGroupOut()</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(LeavePGroupsOut(n_groups=</span><span class="s3">2</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(LeavePOut(p=</span><span class="s3">2</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(KFold(shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(KFold(shuffle=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedKFold(shuffle=</span><span class="s2">True, </span><span class="s1">random_state=np.random.RandomState(</span><span class="s3">0</span><span class="s1">))</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedKFold(shuffle=</span><span class="s2">True, </span><span class="s1">random_state=np.random.RandomState(</span><span class="s3">0</span><span class="s1">))</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(RepeatedKFold(random_state=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(RepeatedKFold(random_state=np.random.RandomState(</span><span class="s3">0</span><span class="s1">))</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(RepeatedStratifiedKFold(random_state=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(RepeatedStratifiedKFold(random_state=np.random.RandomState(</span><span class="s3">0</span><span class="s1">))</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(ShuffleSplit(random_state=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(ShuffleSplit(random_state=np.random.RandomState(</span><span class="s3">0</span><span class="s1">))</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(GroupShuffleSplit(random_state=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(GroupShuffleSplit(random_state=np.random.RandomState(</span><span class="s3">0</span><span class="s1">))</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedShuffleSplit(random_state=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(StratifiedShuffleSplit(random_state=np.random.RandomState(</span><span class="s3">0</span><span class="s1">))</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_yields_constant_splits(cv</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s2">assert </span><span class="s1">_yields_constant_splits(cv) == expected</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;cv&quot;</span><span class="s2">, </span><span class="s1">ALL_SPLITTERS</span><span class="s2">, </span><span class="s1">ids=[str(cv) </span><span class="s2">for </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">ALL_SPLITTERS])</span>
<span class="s2">def </span><span class="s1">test_splitter_get_metadata_routing(cv):</span>
    <span class="s0">&quot;&quot;&quot;Check get_metadata_routing returns the correct MetadataRouter.&quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">hasattr(cv</span><span class="s2">, </span><span class="s5">&quot;get_metadata_routing&quot;</span><span class="s1">)</span>
    <span class="s1">metadata = cv.get_metadata_routing()</span>
    <span class="s2">if </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">GROUP_SPLITTERS:</span>
        <span class="s2">assert </span><span class="s1">metadata.split.requests[</span><span class="s5">&quot;groups&quot;</span><span class="s1">] </span><span class="s2">is True</span>
    <span class="s2">elif </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">NO_GROUP_SPLITTERS:</span>
        <span class="s2">assert not </span><span class="s1">metadata.split.requests</span>

    <span class="s1">assert_request_is_empty(metadata</span><span class="s2">, </span><span class="s1">exclude=[</span><span class="s5">&quot;split&quot;</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;cv&quot;</span><span class="s2">, </span><span class="s1">ALL_SPLITTERS</span><span class="s2">, </span><span class="s1">ids=[str(cv) </span><span class="s2">for </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">ALL_SPLITTERS])</span>
<span class="s2">def </span><span class="s1">test_splitter_set_split_request(cv):</span>
    <span class="s0">&quot;&quot;&quot;Check set_split_request is defined for group splitters and not for others.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">GROUP_SPLITTERS:</span>
        <span class="s2">assert </span><span class="s1">hasattr(cv</span><span class="s2">, </span><span class="s5">&quot;set_split_request&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">NO_GROUP_SPLITTERS:</span>
        <span class="s2">assert not </span><span class="s1">hasattr(cv</span><span class="s2">, </span><span class="s5">&quot;set_split_request&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>