<html>
<head>
<title>deterministic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
deterministic.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s0">import </span><span class="s1">Appender</span><span class="s0">, </span><span class="s1">is_int_index</span><span class="s0">, </span><span class="s1">to_numpy</span>

<span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABC</span><span class="s0">, </span><span class="s1">abstractmethod</span>
<span class="s0">import </span><span class="s1">datetime </span><span class="s0">as </span><span class="s1">dt</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Hashable</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Optional</span><span class="s0">, </span><span class="s1">Sequence</span><span class="s0">, </span><span class="s1">Set</span><span class="s0">, </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">Type</span><span class="s0">, </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">scipy.linalg </span><span class="s0">import </span><span class="s1">qr</span>

<span class="s0">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s0">import </span><span class="s1">d_or_f</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.validation </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">bool_like</span><span class="s0">,</span>
    <span class="s1">float_like</span><span class="s0">,</span>
    <span class="s1">required_int_like</span><span class="s0">,</span>
    <span class="s1">string_like</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">statsmodels.tsa.tsatools </span><span class="s0">import </span><span class="s1">freq_to_period</span>

<span class="s1">DateLike = Union[dt.datetime</span><span class="s0">, </span><span class="s1">pd.Timestamp</span><span class="s0">, </span><span class="s1">np.datetime64]</span>
<span class="s1">IntLike = Union[int</span><span class="s0">, </span><span class="s1">np.integer]</span>


<span class="s1">START_BEFORE_INDEX_ERR = </span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s2">start is less than the first observation in the index. Values can only be </span><span class="s0">\ 
</span><span class="s2">created for observations after the start of the index. 
&quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">DeterministicTerm(ABC):</span>
    <span class="s3">&quot;&quot;&quot;Abstract Base Class for all Deterministic Terms&quot;&quot;&quot;</span>

    <span class="s4"># Set _is_dummy if the term is a dummy variable process</span>
    <span class="s1">_is_dummy = </span><span class="s0">False</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">is_dummy(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Flag indicating whether the values produced are dummy variables&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._is_dummy</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">in_sample(self</span><span class="s0">, </span><span class="s1">index: Sequence[Hashable]) -&gt; pd.DataFrame:</span>
        <span class="s3">&quot;&quot;&quot; 
        Produce deterministic trends for in-sample fitting. 
 
        Parameters 
        ---------- 
        index : index_like 
            An index-like object. If not an index, it is converted to an 
            index. 
 
        Returns 
        ------- 
        DataFrame 
            A DataFrame containing the deterministic terms. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">index: Sequence[Hashable]</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Sequence[Hashable]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s3">&quot;&quot;&quot; 
        Produce deterministic trends for out-of-sample forecasts 
 
        Parameters 
        ---------- 
        steps : int 
            The number of steps to forecast 
        index : index_like 
            An index-like object. If not an index, it is converted to an 
            index. 
        forecast_index : index_like 
            An Index or index-like object to use for the forecasts. If 
            provided must have steps elements. 
 
        Returns 
        ------- 
        DataFrame 
            A DataFrame containing the deterministic terms. 
        &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;A meaningful string representation of the term&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s1">name: Tuple[Hashable</span><span class="s0">, </span><span class="s1">...] = (type(self).__name__</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">hash(name + self._eq_attr)</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">_eq_attr(self) -&gt; Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s3">&quot;&quot;&quot;tuple of attributes that are used for equality comparison&quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_index_like(index: Sequence[Hashable]) -&gt; pd.Index:</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.Index):</span>
            <span class="s0">return </span><span class="s1">index</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pd.Index(index)</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;index must be a pandas Index or index-like&quot;</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_extend_index(</span>
        <span class="s1">index: pd.Index</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Sequence[Hashable]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.Index:</span>
        <span class="s3">&quot;&quot;&quot;Extend the forecast index&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">forecast_index </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">forecast_index = DeterministicTerm._index_like(forecast_index)</span>
            <span class="s0">assert </span><span class="s1">isinstance(forecast_index</span><span class="s0">, </span><span class="s1">pd.Index)</span>
            <span class="s0">if </span><span class="s1">forecast_index.shape[</span><span class="s5">0</span><span class="s1">] != steps:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;The number of values in forecast_index &quot;</span>
                    <span class="s2">f&quot;(</span><span class="s0">{</span><span class="s1">forecast_index.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">}</span><span class="s2">) must match steps (</span><span class="s0">{</span><span class="s1">steps</span><span class="s0">}</span><span class="s2">).&quot;</span>
                <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">forecast_index</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.PeriodIndex):</span>
            <span class="s0">return </span><span class="s1">pd.period_range(</span>
                <span class="s1">index[-</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">periods=steps</span><span class="s0">, </span><span class="s1">freq=index.freq</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.DatetimeIndex) </span><span class="s0">and </span><span class="s1">index.freq </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">next_obs = pd.date_range(index[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">freq=index.freq</span><span class="s0">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">pd.date_range(next_obs</span><span class="s0">, </span><span class="s1">freq=index.freq</span><span class="s0">, </span><span class="s1">periods=steps)</span>
        <span class="s0">elif </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.RangeIndex):</span>
            <span class="s0">assert </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.RangeIndex)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">step = index.step</span>
                <span class="s1">start = index.stop</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s4"># TODO: Remove after pandas min ver is 1.0.0+</span>
                <span class="s1">step = index[-</span><span class="s5">1</span><span class="s1">] - index[-</span><span class="s5">2</span><span class="s1">] </span><span class="s0">if </span><span class="s1">len(index) &gt; </span><span class="s5">1 </span><span class="s0">else </span><span class="s5">1</span>
                <span class="s1">start = index[-</span><span class="s5">1</span><span class="s1">] + step</span>
            <span class="s1">stop = start + step * steps</span>
            <span class="s0">return </span><span class="s1">pd.RangeIndex(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step=step)</span>
        <span class="s0">elif </span><span class="s1">is_int_index(index) </span><span class="s0">and </span><span class="s1">np.all(np.diff(index) == </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">idx_arr = np.arange(index[-</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">index[-</span><span class="s5">1</span><span class="s1">] + steps + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">pd.Index(idx_arr)</span>
        <span class="s4"># default range index</span>
        <span class="s0">import </span><span class="s1">warnings</span>

        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;Only PeriodIndexes, DatetimeIndexes with a frequency set, &quot;</span>
            <span class="s2">&quot;RangesIndexes, and Index with a unit increment support &quot;</span>
            <span class="s2">&quot;extending. The index is set will contain the position relative &quot;</span>
            <span class="s2">&quot;to the data length.&quot;</span><span class="s0">,</span>
            <span class="s1">UserWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">nobs = index.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">pd.RangeIndex(nobs + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">nobs + steps + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self.__str__() + </span><span class="s2">f&quot; at 0x</span><span class="s0">{</span><span class="s1">id(self)</span><span class="s0">:</span><span class="s2">0x</span><span class="s0">}</span><span class="s2">&quot;</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">type(self)):</span>
            <span class="s1">own_attr = self._eq_attr</span>
            <span class="s1">oth_attr = other._eq_attr</span>
            <span class="s0">if </span><span class="s1">len(own_attr) != len(oth_attr):</span>
                <span class="s0">return False</span>
            <span class="s0">return </span><span class="s1">all([a == b </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">zip(own_attr</span><span class="s0">, </span><span class="s1">oth_attr)])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return False</span>


<span class="s0">class </span><span class="s1">TimeTrendDeterministicTerm(DeterministicTerm</span><span class="s0">, </span><span class="s1">ABC):</span>
    <span class="s3">&quot;&quot;&quot;Abstract Base Class for all Time Trend Deterministic Terms&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">constant: bool = </span><span class="s0">True, </span><span class="s1">order: int = </span><span class="s5">0</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._constant = bool_like(constant</span><span class="s0">, </span><span class="s2">&quot;constant&quot;</span><span class="s1">)</span>
        <span class="s1">self._order = required_int_like(order</span><span class="s0">, </span><span class="s2">&quot;order&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">constant(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Flag indicating that a constant is included&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._constant</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">order(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;Order of the time trend&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._order</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_columns(self) -&gt; List[str]:</span>
        <span class="s1">columns = []</span>
        <span class="s1">trend_names = {</span><span class="s5">1</span><span class="s1">: </span><span class="s2">&quot;trend&quot;</span><span class="s0">, </span><span class="s5">2</span><span class="s1">: </span><span class="s2">&quot;trend_squared&quot;</span><span class="s0">, </span><span class="s5">3</span><span class="s1">: </span><span class="s2">&quot;trend_cubed&quot;</span><span class="s1">}</span>
        <span class="s0">if </span><span class="s1">self._constant:</span>
            <span class="s1">columns.append(</span><span class="s2">&quot;const&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">power </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">self._order + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">power </span><span class="s0">in </span><span class="s1">trend_names:</span>
                <span class="s1">columns.append(trend_names[power])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">columns.append(</span><span class="s2">f&quot;trend**</span><span class="s0">{</span><span class="s1">power</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">columns</span>

    <span class="s0">def </span><span class="s1">_get_terms(self</span><span class="s0">, </span><span class="s1">locs: np.ndarray) -&gt; np.ndarray:</span>
        <span class="s1">nterms = int(self._constant) + self._order</span>
        <span class="s1">terms = np.tile(locs</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nterms))</span>
        <span class="s1">power = np.zeros((</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nterms)</span><span class="s0">, </span><span class="s1">dtype=int)</span>
        <span class="s1">power[</span><span class="s5">0</span><span class="s0">, </span><span class="s1">int(self._constant) :] = np.arange(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">self._order + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">terms **= power</span>
        <span class="s0">return </span><span class="s1">terms</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s1">terms = []</span>
        <span class="s0">if </span><span class="s1">self._constant:</span>
            <span class="s1">terms.append(</span><span class="s2">&quot;Constant&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self._order:</span>
            <span class="s1">terms.append(</span><span class="s2">f&quot;Powers 1 to </span><span class="s0">{</span><span class="s1">self._order + </span><span class="s5">1</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">terms:</span>
            <span class="s1">terms = [</span><span class="s2">&quot;Empty&quot;</span><span class="s1">]</span>
        <span class="s1">terms_str = </span><span class="s2">&quot;,&quot;</span><span class="s1">.join(terms)</span>
        <span class="s0">return </span><span class="s2">f&quot;TimeTrend(</span><span class="s0">{</span><span class="s1">terms_str</span><span class="s0">}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">TimeTrend(TimeTrendDeterministicTerm):</span>
    <span class="s3">&quot;&quot;&quot; 
    Constant and time trend determinstic terms 
 
    Parameters 
    ---------- 
    constant : bool 
        Flag indicating whether a constant should be included. 
    order : int 
        A non-negative int containing the powers to include (1, 2, ..., order). 
 
    See Also 
    -------- 
    DeterministicProcess 
    Seasonality 
    Fourier 
    CalendarTimeTrend 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from statsmodels.datasets import sunspots 
    &gt;&gt;&gt; from statsmodels.tsa.deterministic import TimeTrend 
    &gt;&gt;&gt; data = sunspots.load_pandas().data 
    &gt;&gt;&gt; trend_gen = TimeTrend(True, 3) 
    &gt;&gt;&gt; trend_gen.in_sample(data.index) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">constant: bool = </span><span class="s0">True, </span><span class="s1">order: int = </span><span class="s5">0</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(constant</span><span class="s0">, </span><span class="s1">order)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_string(cls</span><span class="s0">, </span><span class="s1">trend: str) -&gt; </span><span class="s2">&quot;TimeTrend&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Create a TimeTrend from a string description. 
 
        Provided for compatibility with common string names. 
 
        Parameters 
        ---------- 
        trend : {&quot;n&quot;, &quot;c&quot;, &quot;t&quot;, &quot;ct&quot;, &quot;ctt&quot;} 
            The string representation of the time trend. The terms are: 
 
            * &quot;n&quot;: No trend terms 
            * &quot;c&quot;: A constant only 
            * &quot;t&quot;: Linear time trend only 
            * &quot;ct&quot;: A constant and a time trend 
            * &quot;ctt&quot;: A constant, a time trend and a quadratic time trend 
 
        Returns 
        ------- 
        TimeTrend 
            The TimeTrend instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">constant = trend.startswith(</span><span class="s2">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s1">order = </span><span class="s5">0</span>
        <span class="s0">if </span><span class="s2">&quot;tt&quot; </span><span class="s0">in </span><span class="s1">trend:</span>
            <span class="s1">order = </span><span class="s5">2</span>
        <span class="s0">elif </span><span class="s2">&quot;t&quot; </span><span class="s0">in </span><span class="s1">trend:</span>
            <span class="s1">order = </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">cls(constant=constant</span><span class="s0">, </span><span class="s1">order=order)</span>

    <span class="s1">@Appender(DeterministicTerm.in_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">in_sample(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">nobs = index.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">locs = np.arange(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nobs + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">dtype=np.double)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">terms = self._get_terms(locs)</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">columns=self._columns</span><span class="s0">, </span><span class="s1">index=index)</span>

    <span class="s1">@Appender(DeterministicTerm.out_of_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Sequence[Hashable]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">nobs = index.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">fcast_index = self._extend_index(index</span><span class="s0">, </span><span class="s1">steps</span><span class="s0">, </span><span class="s1">forecast_index)</span>
        <span class="s1">locs = np.arange(nobs + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">nobs + steps + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">dtype=np.double)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">terms = self._get_terms(locs)</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">columns=self._columns</span><span class="s0">, </span><span class="s1">index=fcast_index)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_eq_attr(self) -&gt; Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s0">return </span><span class="s1">self._constant</span><span class="s0">, </span><span class="s1">self._order</span>


<span class="s0">class </span><span class="s1">Seasonality(DeterministicTerm):</span>
    <span class="s3">&quot;&quot;&quot; 
    Seasonal dummy deterministic terms 
 
    Parameters 
    ---------- 
    period : int 
        The length of a full cycle. Must be &gt;= 2. 
    initial_period : int 
        The seasonal index of the first observation. 1-indexed so must 
        be in {1, 2, ..., period}. 
 
    See Also 
    -------- 
    DeterministicProcess 
    TimeTrend 
    Fourier 
    CalendarSeasonality 
 
    Examples 
    -------- 
    Solar data has an 11-year cycle 
 
    &gt;&gt;&gt; from statsmodels.datasets import sunspots 
    &gt;&gt;&gt; from statsmodels.tsa.deterministic import Seasonality 
    &gt;&gt;&gt; data = sunspots.load_pandas().data 
    &gt;&gt;&gt; seas_gen = Seasonality(11) 
    &gt;&gt;&gt; seas_gen.in_sample(data.index) 
 
    To start at a season other than 1 
 
    &gt;&gt;&gt; seas_gen = Seasonality(11, initial_period=4) 
    &gt;&gt;&gt; seas_gen.in_sample(data.index) 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_dummy = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">period: int</span><span class="s0">, </span><span class="s1">initial_period: int = </span><span class="s5">1</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._period = required_int_like(period</span><span class="s0">, </span><span class="s2">&quot;period&quot;</span><span class="s1">)</span>
        <span class="s1">self._initial_period = required_int_like(</span>
            <span class="s1">initial_period</span><span class="s0">, </span><span class="s2">&quot;initial_period&quot;</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">period &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;period must be &gt;= 2&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s5">1 </span><span class="s1">&lt;= self._initial_period &lt;= period:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;initial_period must be in {1, 2, ..., period}&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">period(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;The period of the seasonality&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._period</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">initial_period(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;The seasonal index of the first observation&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._initial_period</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_index(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;Seasonality&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a seasonality directly from an index using its frequency. 
 
        Parameters 
        ---------- 
        index : {DatetimeIndex, PeriodIndex} 
            An index with its frequency (`freq`) set. 
 
        Returns 
        ------- 
        Seasonality 
            The initialized Seasonality instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">index = cls._index_like(index)</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.PeriodIndex):</span>
            <span class="s1">freq = index.freq</span>
        <span class="s0">elif </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.DatetimeIndex):</span>
            <span class="s1">freq = index.freq </span><span class="s0">if </span><span class="s1">index.freq </span><span class="s0">else </span><span class="s1">index.inferred_freq</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;index must be a DatetimeIndex or PeriodIndex&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">freq </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;index must have a freq or inferred_freq set&quot;</span><span class="s1">)</span>
        <span class="s1">period = freq_to_period(freq)</span>
        <span class="s0">return </span><span class="s1">cls(period=period)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_eq_attr(self) -&gt; Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s0">return </span><span class="s1">self._period</span><span class="s0">, </span><span class="s1">self._initial_period</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;Seasonality(period=</span><span class="s0">{</span><span class="s1">self._period</span><span class="s0">}</span><span class="s2">)&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_columns(self) -&gt; List[str]:</span>
        <span class="s1">period = self._period</span>
        <span class="s1">columns = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">period + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">columns.append(</span><span class="s2">f&quot;s(</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">,</span><span class="s0">{</span><span class="s1">period</span><span class="s0">}</span><span class="s2">)&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">columns</span>

    <span class="s1">@Appender(DeterministicTerm.in_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">in_sample(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">nobs = index.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">period = self._period</span>
        <span class="s1">term = np.zeros((nobs</span><span class="s0">, </span><span class="s1">period))</span>
        <span class="s1">offset = self._initial_period - </span><span class="s5">1</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(period):</span>
            <span class="s1">col = (i + offset) % period</span>
            <span class="s1">term[i::period</span><span class="s0">, </span><span class="s1">col] = </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(term</span><span class="s0">, </span><span class="s1">columns=self._columns</span><span class="s0">, </span><span class="s1">index=index)</span>

    <span class="s1">@Appender(DeterministicTerm.out_of_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Sequence[Hashable]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">fcast_index = self._extend_index(index</span><span class="s0">, </span><span class="s1">steps</span><span class="s0">, </span><span class="s1">forecast_index)</span>
        <span class="s1">nobs = index.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">period = self._period</span>
        <span class="s1">term = np.zeros((steps</span><span class="s0">, </span><span class="s1">period))</span>
        <span class="s1">offset = self._initial_period - </span><span class="s5">1</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(period):</span>
            <span class="s1">col_loc = (nobs + offset + i) % period</span>
            <span class="s1">term[i::period</span><span class="s0">, </span><span class="s1">col_loc] = </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(term</span><span class="s0">, </span><span class="s1">columns=self._columns</span><span class="s0">, </span><span class="s1">index=fcast_index)</span>


<span class="s0">class </span><span class="s1">FourierDeterministicTerm(DeterministicTerm</span><span class="s0">, </span><span class="s1">ABC):</span>
    <span class="s3">&quot;&quot;&quot;Abstract Base Class for all Fourier Deterministic Terms&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">order: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._order = required_int_like(order</span><span class="s0">, </span><span class="s2">&quot;terms&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">order(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;The order of the Fourier terms included&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._order</span>

    <span class="s0">def </span><span class="s1">_get_terms(self</span><span class="s0">, </span><span class="s1">locs: np.ndarray) -&gt; np.ndarray:</span>
        <span class="s1">locs = </span><span class="s5">2 </span><span class="s1">* np.pi * locs.astype(np.double)</span>
        <span class="s1">terms = np.empty((locs.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">2 </span><span class="s1">* self._order))</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self._order):</span>
            <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">func </span><span class="s0">in </span><span class="s1">enumerate((np.sin</span><span class="s0">, </span><span class="s1">np.cos)):</span>
                <span class="s1">terms[:</span><span class="s0">, </span><span class="s5">2 </span><span class="s1">* i + j] = func((i + </span><span class="s5">1</span><span class="s1">) * locs)</span>
        <span class="s0">return </span><span class="s1">terms</span>


<span class="s0">class </span><span class="s1">Fourier(FourierDeterministicTerm):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Fourier series deterministic terms 
 
    Parameters 
    ---------- 
    period : int 
        The length of a full cycle. Must be &gt;= 2. 
    order : int 
        The number of Fourier components to include. Must be &lt;= 2*period. 
 
    See Also 
    -------- 
    DeterministicProcess 
    TimeTrend 
    Seasonality 
    CalendarFourier 
 
    Notes 
    ----- 
    Both a sine and a cosine term are included for each i=1, ..., order 
 
    .. math:: 
 
       f_{i,s,t} &amp; = \sin\left(2 \pi i \times \frac{t}{m} \right)  \\ 
       f_{i,c,t} &amp; = \cos\left(2 \pi i \times \frac{t}{m} \right) 
 
    where m is the length of the period. 
 
    Examples 
    -------- 
    Solar data has an 11-year cycle 
 
    &gt;&gt;&gt; from statsmodels.datasets import sunspots 
    &gt;&gt;&gt; from statsmodels.tsa.deterministic import Fourier 
    &gt;&gt;&gt; data = sunspots.load_pandas().data 
    &gt;&gt;&gt; fourier_gen = Fourier(11, order=2) 
    &gt;&gt;&gt; fourier_gen.in_sample(data.index) 
    &quot;&quot;&quot;</span>
    <span class="s1">_is_dummy = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">period: float</span><span class="s0">, </span><span class="s1">order: int):</span>
        <span class="s1">super().__init__(order)</span>
        <span class="s1">self._period = float_like(period</span><span class="s0">, </span><span class="s2">&quot;period&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s5">2 </span><span class="s1">* self._order &gt; self._period:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;2 * order must be &lt;= period&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">period(self) -&gt; float:</span>
        <span class="s3">&quot;&quot;&quot;The period of the Fourier terms&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._period</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_columns(self) -&gt; List[str]:</span>
        <span class="s1">period = self._period</span>
        <span class="s1">fmt_period = d_or_f(period).strip()</span>
        <span class="s1">columns = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">self._order + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;sin&quot;</span><span class="s0">, </span><span class="s2">&quot;cos&quot;</span><span class="s1">):</span>
                <span class="s1">columns.append(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">typ</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">,</span><span class="s0">{</span><span class="s1">fmt_period</span><span class="s0">}</span><span class="s2">)&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">columns</span>

    <span class="s1">@Appender(DeterministicTerm.in_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">in_sample(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">nobs = index.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">terms = self._get_terms(np.arange(nobs) / self._period)</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=self._columns)</span>

    <span class="s1">@Appender(DeterministicTerm.out_of_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Sequence[Hashable]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">fcast_index = self._extend_index(index</span><span class="s0">, </span><span class="s1">steps</span><span class="s0">, </span><span class="s1">forecast_index)</span>
        <span class="s1">nobs = index.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">terms = self._get_terms(np.arange(nobs</span><span class="s0">, </span><span class="s1">nobs + steps) / self._period)</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">index=fcast_index</span><span class="s0">, </span><span class="s1">columns=self._columns)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_eq_attr(self) -&gt; Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s0">return </span><span class="s1">self._period</span><span class="s0">, </span><span class="s1">self._order</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;Fourier(period=</span><span class="s0">{</span><span class="s1">self._period</span><span class="s0">}</span><span class="s2">, order=</span><span class="s0">{</span><span class="s1">self._order</span><span class="s0">}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">CalendarDeterministicTerm(DeterministicTerm</span><span class="s0">, </span><span class="s1">ABC):</span>
    <span class="s3">&quot;&quot;&quot;Abstract Base Class for calendar deterministic terms&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">freq: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">index = pd.date_range(</span><span class="s2">&quot;2020-01-01&quot;</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self._freq = index.freq</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;freq is not understood by pandas&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">freq(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;The frequency of the deterministic terms&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._freq.freqstr</span>

    <span class="s0">def </span><span class="s1">_compute_ratio(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.PeriodIndex):</span>
            <span class="s1">index = index.to_timestamp()</span>
        <span class="s1">delta = index - index.to_period(self._freq).to_timestamp()</span>
        <span class="s1">pi = index.to_period(self._freq)</span>
        <span class="s1">gap = (pi + </span><span class="s5">1</span><span class="s1">).to_timestamp() - pi.to_timestamp()</span>
        <span class="s0">return </span><span class="s1">to_numpy(delta) / to_numpy(gap)</span>

    <span class="s0">def </span><span class="s1">_check_index_type(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">index: pd.Index</span><span class="s0">,</span>
        <span class="s1">allowed: Union[Type</span><span class="s0">, </span><span class="s1">Tuple[Type</span><span class="s0">, </span><span class="s1">...]] = (</span>
            <span class="s1">pd.DatetimeIndex</span><span class="s0">,</span>
            <span class="s1">pd.PeriodIndex</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">) -&gt; Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]:</span>
        <span class="s0">if </span><span class="s1">isinstance(allowed</span><span class="s0">, </span><span class="s1">type):</span>
            <span class="s1">allowed = (allowed</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">allowed):</span>
            <span class="s0">if </span><span class="s1">len(allowed) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">allowed_types = </span><span class="s2">&quot;a &quot; </span><span class="s1">+ allowed[</span><span class="s5">0</span><span class="s1">].__name__</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">allowed_types = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(a.__name__ </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">allowed[:-</span><span class="s5">1</span><span class="s1">])</span>
                <span class="s0">if </span><span class="s1">len(allowed) &gt; </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s1">allowed_types += </span><span class="s2">&quot;,&quot;</span>
                <span class="s1">allowed_types += </span><span class="s2">&quot; and &quot; </span><span class="s1">+ allowed[-</span><span class="s5">1</span><span class="s1">].__name__</span>
            <span class="s1">msg = (</span>
                <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} </span><span class="s2">terms can only be computed from &quot;</span>
                <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">allowed_types</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>
        <span class="s0">assert </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex))</span>
        <span class="s0">return </span><span class="s1">index</span>


<span class="s0">class </span><span class="s1">CalendarFourier(CalendarDeterministicTerm</span><span class="s0">, </span><span class="s1">FourierDeterministicTerm):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Fourier series deterministic terms based on calendar time 
 
    Parameters 
    ---------- 
    freq : str 
        A string convertible to a pandas frequency. 
    order : int 
        The number of Fourier components to include. Must be &lt;= 2*period. 
 
    See Also 
    -------- 
    DeterministicProcess 
    CalendarTimeTrend 
    CalendarSeasonality 
    Fourier 
 
    Notes 
    ----- 
    Both a sine and a cosine term are included for each i=1, ..., order 
 
    .. math:: 
 
       f_{i,s,t} &amp; = \sin\left(2 \pi i \tau_t \right)  \\ 
       f_{i,c,t} &amp; = \cos\left(2 \pi i \tau_t \right) 
 
    where m is the length of the period and :math:`\tau_t` is the frequency 
    normalized time.  For example, when freq is &quot;D&quot; then an observation with 
    a timestamp of 12:00:00 would have :math:`\tau_t=0.5`. 
 
    Examples 
    -------- 
    Here we simulate irregularly spaced hourly data and construct the calendar 
    Fourier terms for the data. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import pandas as pd 
    &gt;&gt;&gt; base = pd.Timestamp(&quot;2020-1-1&quot;) 
    &gt;&gt;&gt; gen = np.random.default_rng() 
    &gt;&gt;&gt; gaps = np.cumsum(gen.integers(0, 1800, size=1000)) 
    &gt;&gt;&gt; times = [base + pd.Timedelta(gap, unit=&quot;s&quot;) for gap in gaps] 
    &gt;&gt;&gt; index = pd.DatetimeIndex(pd.to_datetime(times)) 
 
    &gt;&gt;&gt; from statsmodels.tsa.deterministic import CalendarFourier 
    &gt;&gt;&gt; cal_fourier_gen = CalendarFourier(&quot;D&quot;, 2) 
    &gt;&gt;&gt; cal_fourier_gen.in_sample(index) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">freq: str</span><span class="s0">, </span><span class="s1">order: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(freq)</span>
        <span class="s1">FourierDeterministicTerm.__init__(self</span><span class="s0">, </span><span class="s1">order)</span>
        <span class="s1">self._order = required_int_like(order</span><span class="s0">, </span><span class="s2">&quot;terms&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_columns(self) -&gt; List[str]:</span>
        <span class="s1">columns = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">self._order + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;sin&quot;</span><span class="s0">, </span><span class="s2">&quot;cos&quot;</span><span class="s1">):</span>
                <span class="s1">columns.append(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">typ</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">,freq=</span><span class="s0">{</span><span class="s1">self._freq.freqstr</span><span class="s0">}</span><span class="s2">)&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">columns</span>

    <span class="s1">@Appender(DeterministicTerm.in_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">in_sample(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">index = self._check_index_type(index)</span>

        <span class="s1">ratio = self._compute_ratio(index)</span>
        <span class="s1">terms = self._get_terms(ratio)</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=self._columns)</span>

    <span class="s1">@Appender(DeterministicTerm.out_of_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Sequence[Hashable]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">fcast_index = self._extend_index(index</span><span class="s0">, </span><span class="s1">steps</span><span class="s0">, </span><span class="s1">forecast_index)</span>
        <span class="s1">self._check_index_type(fcast_index)</span>
        <span class="s0">assert </span><span class="s1">isinstance(fcast_index</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex))</span>
        <span class="s1">ratio = self._compute_ratio(fcast_index)</span>
        <span class="s1">terms = self._get_terms(ratio)</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">index=fcast_index</span><span class="s0">, </span><span class="s1">columns=self._columns)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_eq_attr(self) -&gt; Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s0">return </span><span class="s1">self._freq.freqstr</span><span class="s0">, </span><span class="s1">self._order</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;Fourier(freq=</span><span class="s0">{</span><span class="s1">self._freq.freqstr</span><span class="s0">}</span><span class="s2">, order=</span><span class="s0">{</span><span class="s1">self._order</span><span class="s0">}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">CalendarSeasonality(CalendarDeterministicTerm):</span>
    <span class="s3">&quot;&quot;&quot; 
    Seasonal dummy deterministic terms based on calendar time 
 
    Parameters 
    ---------- 
    freq : str 
        The frequency of the seasonal effect. 
    period : str 
        The pandas frequency string describing the full period. 
 
    See Also 
    -------- 
    DeterministicProcess 
    CalendarTimeTrend 
    CalendarFourier 
    Seasonality 
 
    Examples 
    -------- 
    Here we simulate irregularly spaced data (in time) and hourly seasonal 
    dummies for the data. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import pandas as pd 
    &gt;&gt;&gt; base = pd.Timestamp(&quot;2020-1-1&quot;) 
    &gt;&gt;&gt; gen = np.random.default_rng() 
    &gt;&gt;&gt; gaps = np.cumsum(gen.integers(0, 1800, size=1000)) 
    &gt;&gt;&gt; times = [base + pd.Timedelta(gap, unit=&quot;s&quot;) for gap in gaps] 
    &gt;&gt;&gt; index = pd.DatetimeIndex(pd.to_datetime(times)) 
 
    &gt;&gt;&gt; from statsmodels.tsa.deterministic import CalendarSeasonality 
    &gt;&gt;&gt; cal_seas_gen = CalendarSeasonality(&quot;H&quot;, &quot;D&quot;) 
    &gt;&gt;&gt; cal_seas_gen.in_sample(index) 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_dummy = </span><span class="s0">True</span>

    <span class="s4"># out_of: freq</span>
    <span class="s1">_supported = {</span>
        <span class="s2">&quot;W&quot;</span><span class="s1">: {</span><span class="s2">&quot;H&quot;</span><span class="s1">: </span><span class="s5">24 </span><span class="s1">* </span><span class="s5">7</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">: </span><span class="s5">7</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;D&quot;</span><span class="s1">: {</span><span class="s2">&quot;H&quot;</span><span class="s1">: </span><span class="s5">24</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;Q&quot;</span><span class="s1">: {</span><span class="s2">&quot;M&quot;</span><span class="s1">: </span><span class="s5">3</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s2">&quot;A&quot;</span><span class="s1">: {</span><span class="s2">&quot;M&quot;</span><span class="s1">: </span><span class="s5">12</span><span class="s0">, </span><span class="s2">&quot;Q&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s1">}</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">freq: str</span><span class="s0">, </span><span class="s1">period: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">freq_options: Set[str] = set()</span>
        <span class="s1">freq_options.update(</span>
            <span class="s1">*[list(val.keys()) </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">self._supported.values()]</span>
        <span class="s1">)</span>
        <span class="s1">period_options = list(self._supported.keys())</span>

        <span class="s1">freq = string_like(</span>
            <span class="s1">freq</span><span class="s0">, </span><span class="s2">&quot;freq&quot;</span><span class="s0">, </span><span class="s1">options=tuple(freq_options)</span><span class="s0">, </span><span class="s1">lower=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s1">period = string_like(</span>
            <span class="s1">period</span><span class="s0">, </span><span class="s2">&quot;period&quot;</span><span class="s0">, </span><span class="s1">options=period_options</span><span class="s0">, </span><span class="s1">lower=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">freq </span><span class="s0">not in </span><span class="s1">self._supported[period]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">f&quot;The combination of freq=</span><span class="s0">{</span><span class="s1">freq</span><span class="s0">} </span><span class="s2">and &quot;</span>
                <span class="s2">f&quot;period=</span><span class="s0">{</span><span class="s1">period</span><span class="s0">} </span><span class="s2">is not supported.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">super().__init__(freq)</span>
        <span class="s1">self._period = period</span>
        <span class="s1">self._freq_str = self._freq.freqstr.split(</span><span class="s2">&quot;-&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">freq(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;The frequency of the deterministic terms&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._freq.freqstr</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">period(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;The full period&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._period</span>

    <span class="s0">def </span><span class="s1">_weekly_to_loc(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s0">if </span><span class="s1">self._freq.freqstr == </span><span class="s2">&quot;H&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">index.hour + </span><span class="s5">24 </span><span class="s1">* index.dayofweek</span>
        <span class="s0">elif </span><span class="s1">self._freq.freqstr == </span><span class="s2">&quot;D&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">index.dayofweek</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s4"># &quot;B&quot;</span>
            <span class="s1">bdays = pd.bdate_range(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s5">10</span><span class="s1">).dayofweek.unique()</span>
            <span class="s1">loc = index.dayofweek</span>
            <span class="s0">if not </span><span class="s1">loc.isin(bdays).all():</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;freq is B but index contains days that are not business &quot;</span>
                    <span class="s2">&quot;days.&quot;</span>
                <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">loc</span>

    <span class="s0">def </span><span class="s1">_daily_to_loc(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">index.hour</span>

    <span class="s0">def </span><span class="s1">_quarterly_to_loc(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">(index.month - </span><span class="s5">1</span><span class="s1">) % </span><span class="s5">3</span>

    <span class="s0">def </span><span class="s1">_annual_to_loc(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s0">if </span><span class="s1">self._freq.freqstr == </span><span class="s2">&quot;M&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">index.month - </span><span class="s5">1</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s4"># &quot;Q&quot;</span>
            <span class="s0">return </span><span class="s1">index.quarter - </span><span class="s5">1</span>

    <span class="s0">def </span><span class="s1">_get_terms(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s0">if </span><span class="s1">self._period == </span><span class="s2">&quot;D&quot;</span><span class="s1">:</span>
            <span class="s1">locs = self._daily_to_loc(index)</span>
        <span class="s0">elif </span><span class="s1">self._period == </span><span class="s2">&quot;W&quot;</span><span class="s1">:</span>
            <span class="s1">locs = self._weekly_to_loc(index)</span>
        <span class="s0">elif </span><span class="s1">self._period == </span><span class="s2">&quot;Q&quot;</span><span class="s1">:</span>
            <span class="s1">locs = self._quarterly_to_loc(index)</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s4"># &quot;A&quot;:</span>
            <span class="s1">locs = self._annual_to_loc(index)</span>
        <span class="s1">full_cycle = self._supported[self._period][self._freq_str]</span>
        <span class="s1">terms = np.zeros((locs.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">full_cycle))</span>
        <span class="s1">terms[np.arange(locs.shape[</span><span class="s5">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">locs] = </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">terms</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_columns(self) -&gt; List[str]:</span>
        <span class="s1">columns = []</span>
        <span class="s1">count = self._supported[self._period][self._freq_str]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(count):</span>
            <span class="s1">columns.append(</span>
                <span class="s2">f&quot;s(</span><span class="s0">{</span><span class="s1">self._freq_str</span><span class="s0">}</span><span class="s2">=</span><span class="s0">{</span><span class="s1">i + </span><span class="s5">1</span><span class="s0">}</span><span class="s2">, period=</span><span class="s0">{</span><span class="s1">self._period</span><span class="s0">}</span><span class="s2">)&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">columns</span>

    <span class="s1">@Appender(DeterministicTerm.in_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">in_sample(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">index = self._check_index_type(index)</span>
        <span class="s1">terms = self._get_terms(index)</span>

        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=self._columns)</span>

    <span class="s1">@Appender(DeterministicTerm.out_of_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Sequence[Hashable]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">fcast_index = self._extend_index(index</span><span class="s0">, </span><span class="s1">steps</span><span class="s0">, </span><span class="s1">forecast_index)</span>
        <span class="s1">self._check_index_type(fcast_index)</span>
        <span class="s0">assert </span><span class="s1">isinstance(fcast_index</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex))</span>
        <span class="s1">terms = self._get_terms(fcast_index)</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">index=fcast_index</span><span class="s0">, </span><span class="s1">columns=self._columns)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_eq_attr(self) -&gt; Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s0">return </span><span class="s1">self._period</span><span class="s0">, </span><span class="s1">self._freq_str</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;Seasonal(freq=</span><span class="s0">{</span><span class="s1">self._freq_str</span><span class="s0">}</span><span class="s2">)&quot;</span>


<span class="s0">class </span><span class="s1">CalendarTimeTrend(CalendarDeterministicTerm</span><span class="s0">, </span><span class="s1">TimeTrendDeterministicTerm):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Constant and time trend determinstic terms based on calendar time 
 
    Parameters 
    ---------- 
    freq : str 
        A string convertible to a pandas frequency. 
    constant : bool 
        Flag indicating whether a constant should be included. 
    order : int 
        A non-negative int containing the powers to include (1, 2, ..., order). 
    base_period : {str, pd.Timestamp}, default None 
        The base period to use when computing the time stamps. This value is 
        treated as 1 and so all other time indices are defined as the number 
        of periods since or before this time stamp. If not provided, defaults 
        to pandas base period for a PeriodIndex. 
 
    See Also 
    -------- 
    DeterministicProcess 
    CalendarFourier 
    CalendarSeasonality 
    TimeTrend 
 
    Notes 
    ----- 
    The time stamp, :math:`\tau_t`, is the number of periods that have elapsed 
    since the base_period. :math:`\tau_t` may be fractional. 
 
    Examples 
    -------- 
    Here we simulate irregularly spaced hourly data and construct the calendar 
    time trend terms for the data. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import pandas as pd 
    &gt;&gt;&gt; base = pd.Timestamp(&quot;2020-1-1&quot;) 
    &gt;&gt;&gt; gen = np.random.default_rng() 
    &gt;&gt;&gt; gaps = np.cumsum(gen.integers(0, 1800, size=1000)) 
    &gt;&gt;&gt; times = [base + pd.Timedelta(gap, unit=&quot;s&quot;) for gap in gaps] 
    &gt;&gt;&gt; index = pd.DatetimeIndex(pd.to_datetime(times)) 
 
    &gt;&gt;&gt; from statsmodels.tsa.deterministic import CalendarTimeTrend 
    &gt;&gt;&gt; cal_trend_gen = CalendarTimeTrend(&quot;D&quot;, True, order=1) 
    &gt;&gt;&gt; cal_trend_gen.in_sample(index) 
 
    Next, we normalize using the first time stamp 
 
    &gt;&gt;&gt; cal_trend_gen = CalendarTimeTrend(&quot;D&quot;, True, order=1, 
    ...                                   base_period=index[0]) 
    &gt;&gt;&gt; cal_trend_gen.in_sample(index) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">freq: str</span><span class="s0">,</span>
        <span class="s1">constant: bool = </span><span class="s0">True,</span>
        <span class="s1">order: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">base_period: Optional[Union[str</span><span class="s0">, </span><span class="s1">DateLike]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(freq)</span>
        <span class="s1">TimeTrendDeterministicTerm.__init__(</span>
            <span class="s1">self</span><span class="s0">, </span><span class="s1">constant=constant</span><span class="s0">, </span><span class="s1">order=order</span>
        <span class="s1">)</span>
        <span class="s1">self._ref_i8 = </span><span class="s5">0</span>
        <span class="s0">if </span><span class="s1">base_period </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">pr = pd.period_range(base_period</span><span class="s0">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">freq=self._freq)</span>
            <span class="s1">self._ref_i8 = pr.asi8[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self._base_period = </span><span class="s0">None if </span><span class="s1">base_period </span><span class="s0">is None else </span><span class="s1">str(base_period)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">base_period(self) -&gt; Optional[str]:</span>
        <span class="s3">&quot;&quot;&quot;The base period&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._base_period</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_string(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">freq: str</span><span class="s0">,</span>
        <span class="s1">trend: str</span><span class="s0">,</span>
        <span class="s1">base_period: Optional[Union[str</span><span class="s0">, </span><span class="s1">DateLike]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;CalendarTimeTrend&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Create a TimeTrend from a string description. 
 
        Provided for compatibility with common string names. 
 
        Parameters 
        ---------- 
        freq : str 
            A string convertible to a pandas frequency. 
        trend : {&quot;n&quot;, &quot;c&quot;, &quot;t&quot;, &quot;ct&quot;, &quot;ctt&quot;} 
            The string representation of the time trend. The terms are: 
 
            * &quot;n&quot;: No trend terms 
            * &quot;c&quot;: A constant only 
            * &quot;t&quot;: Linear time trend only 
            * &quot;ct&quot;: A constant and a time trend 
            * &quot;ctt&quot;: A constant, a time trend and a quadratic time trend 
        base_period : {str, pd.Timestamp}, default None 
            The base period to use when computing the time stamps. This value 
            is treated as 1 and so all other time indices are defined as the 
            number of periods since or before this time stamp. If not 
            provided, defaults to pandas base period for a PeriodIndex. 
 
        Returns 
        ------- 
        TimeTrend 
            The TimeTrend instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">constant = trend.startswith(</span><span class="s2">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s1">order = </span><span class="s5">0</span>
        <span class="s0">if </span><span class="s2">&quot;tt&quot; </span><span class="s0">in </span><span class="s1">trend:</span>
            <span class="s1">order = </span><span class="s5">2</span>
        <span class="s0">elif </span><span class="s2">&quot;t&quot; </span><span class="s0">in </span><span class="s1">trend:</span>
            <span class="s1">order = </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">cls(freq</span><span class="s0">, </span><span class="s1">constant</span><span class="s0">, </span><span class="s1">order</span><span class="s0">, </span><span class="s1">base_period=base_period)</span>

    <span class="s0">def </span><span class="s1">_terms(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]</span><span class="s0">, </span><span class="s1">ratio: np.ndarray</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.DatetimeIndex):</span>
            <span class="s1">index = index.to_period(self._freq)</span>

        <span class="s1">index_i8 = index.asi8</span>
        <span class="s1">index_i8 = index_i8 - self._ref_i8 + </span><span class="s5">1</span>
        <span class="s1">time = index_i8.astype(np.double) + ratio</span>
        <span class="s1">time = time[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">terms = self._get_terms(time)</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">columns=self._columns</span><span class="s0">, </span><span class="s1">index=index)</span>

    <span class="s1">@Appender(DeterministicTerm.in_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">in_sample(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">index = self._check_index_type(index)</span>
        <span class="s1">ratio = self._compute_ratio(index)</span>
        <span class="s0">return </span><span class="s1">self._terms(index</span><span class="s0">, </span><span class="s1">ratio)</span>

    <span class="s1">@Appender(DeterministicTerm.out_of_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Sequence[Hashable]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index_like(index)</span>
        <span class="s1">fcast_index = self._extend_index(index</span><span class="s0">, </span><span class="s1">steps</span><span class="s0">, </span><span class="s1">forecast_index)</span>
        <span class="s1">self._check_index_type(fcast_index)</span>
        <span class="s0">assert </span><span class="s1">isinstance(fcast_index</span><span class="s0">, </span><span class="s1">(pd.PeriodIndex</span><span class="s0">, </span><span class="s1">pd.DatetimeIndex))</span>
        <span class="s1">ratio = self._compute_ratio(fcast_index)</span>
        <span class="s0">return </span><span class="s1">self._terms(fcast_index</span><span class="s0">, </span><span class="s1">ratio)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_eq_attr(self) -&gt; Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s1">attr: Tuple[Hashable</span><span class="s0">, </span><span class="s1">...] = (</span>
            <span class="s1">self._constant</span><span class="s0">,</span>
            <span class="s1">self._order</span><span class="s0">,</span>
            <span class="s1">self._freq.freqstr</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self._base_period </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">attr += (self._base_period</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">attr</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s1">value = TimeTrendDeterministicTerm.__str__(self)</span>
        <span class="s1">value = </span><span class="s2">&quot;Calendar&quot; </span><span class="s1">+ value[:-</span><span class="s5">1</span><span class="s1">] + </span><span class="s2">f&quot;, freq=</span><span class="s0">{</span><span class="s1">self._freq.freqstr</span><span class="s0">}</span><span class="s2">)&quot;</span>
        <span class="s0">if </span><span class="s1">self._base_period </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">value = value[:-</span><span class="s5">1</span><span class="s1">] + </span><span class="s2">f&quot;base_period=</span><span class="s0">{</span><span class="s1">self._base_period</span><span class="s0">}</span><span class="s2">)&quot;</span>
        <span class="s0">return </span><span class="s1">value</span>


<span class="s0">class </span><span class="s1">DeterministicProcess:</span>
    <span class="s3">&quot;&quot;&quot; 
    Container class for deterministic terms. 
 
    Directly supports constants, time trends, and either seasonal dummies or 
    fourier terms for a single cycle. Additional deterministic terms beyond 
    the set that can be directly initialized through the constructor can be 
    added. 
 
    Parameters 
    ---------- 
    index : {Sequence[Hashable], pd.Index} 
        The index of the process. Should usually be the &quot;in-sample&quot; index when 
        used in forecasting applications. 
    period : {float, int}, default None 
        The period of the seasonal or fourier components. Must be an int for 
        seasonal dummies. If not provided, freq is read from index if 
        available. 
    constant : bool, default False 
        Whether to include a constant. 
    order : int, default 0 
        The order of the tim trend to include. For example, 2 will include 
        both linear and quadratic terms. 0 exclude time trend terms. 
    seasonal : bool = False 
        Whether to include seasonal dummies 
    fourier : int = 0 
        The order of the fourier terms to included. 
    additional_terms : Sequence[DeterministicTerm] 
        A sequence of additional deterministic terms to include in the process. 
    drop : bool, default False 
        A flag indicating to check for perfect collinearity and to drop any 
        linearly dependent terms. 
 
    See Also 
    -------- 
    TimeTrend 
    Seasonality 
    Fourier 
    CalendarTimeTrend 
    CalendarSeasonality 
    CalendarFourier 
 
    Notes 
    ----- 
    See the notebook `Deterministic Terms in Time Series Models 
    &lt;../examples/notebooks/generated/deterministics.html&gt;`__ for an overview. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from statsmodels.tsa.deterministic import DeterministicProcess 
    &gt;&gt;&gt; from pandas import date_range 
    &gt;&gt;&gt; index = date_range(&quot;2000-1-1&quot;, freq=&quot;M&quot;, periods=240) 
 
    First a determinstic process with a constant and quadratic time trend. 
 
    &gt;&gt;&gt; dp = DeterministicProcess(index, constant=True, order=2) 
    &gt;&gt;&gt; dp.in_sample().head(3) 
                const  trend  trend_squared 
    2000-01-31    1.0    1.0            1.0 
    2000-02-29    1.0    2.0            4.0 
    2000-03-31    1.0    3.0            9.0 
 
    Seasonal dummies are included by setting seasonal to True. 
 
    &gt;&gt;&gt; dp = DeterministicProcess(index, constant=True, seasonal=True) 
    &gt;&gt;&gt; dp.in_sample().iloc[:3,:5] 
                const  s(2,12)  s(3,12)  s(4,12)  s(5,12) 
    2000-01-31    1.0      0.0      0.0      0.0      0.0 
    2000-02-29    1.0      1.0      0.0      0.0      0.0 
    2000-03-31    1.0      0.0      1.0      0.0      0.0 
 
    Fourier components can be used to alternatively capture seasonal patterns, 
 
    &gt;&gt;&gt; dp = DeterministicProcess(index, constant=True, fourier=2) 
    &gt;&gt;&gt; dp.in_sample().head(3) 
                const  sin(1,12)  cos(1,12)  sin(2,12)  cos(2,12) 
    2000-01-31    1.0   0.000000   1.000000   0.000000        1.0 
    2000-02-29    1.0   0.500000   0.866025   0.866025        0.5 
    2000-03-31    1.0   0.866025   0.500000   0.866025       -0.5 
 
    Multiple Seasonalities can be captured using additional terms. 
 
    &gt;&gt;&gt; from statsmodels.tsa.deterministic import Fourier 
    &gt;&gt;&gt; index = date_range(&quot;2000-1-1&quot;, freq=&quot;D&quot;, periods=5000) 
    &gt;&gt;&gt; fourier = Fourier(period=365.25, order=1) 
    &gt;&gt;&gt; dp = DeterministicProcess(index, period=3, constant=True, 
    ...                           seasonal=True, additional_terms=[fourier]) 
    &gt;&gt;&gt; dp.in_sample().head(3) 
                const  s(2,3)  s(3,3)  sin(1,365.25)  cos(1,365.25) 
    2000-01-01    1.0     0.0     0.0       0.000000       1.000000 
    2000-01-02    1.0     1.0     0.0       0.017202       0.999852 
    2000-01-03    1.0     0.0     1.0       0.034398       0.999408 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">index: Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">period: Optional[Union[float</span><span class="s0">, </span><span class="s1">int]] = </span><span class="s0">None,</span>
        <span class="s1">constant: bool = </span><span class="s0">False,</span>
        <span class="s1">order: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">seasonal: bool = </span><span class="s0">False,</span>
        <span class="s1">fourier: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">additional_terms: Sequence[DeterministicTerm] = ()</span><span class="s0">,</span>
        <span class="s1">drop: bool = </span><span class="s0">False,</span>
    <span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.Index):</span>
            <span class="s1">index = pd.Index(index)</span>
        <span class="s1">self._index = index</span>
        <span class="s1">self._deterministic_terms: List[DeterministicTerm] = []</span>
        <span class="s1">self._extendable = </span><span class="s0">False</span>
        <span class="s1">self._index_freq = </span><span class="s0">None</span>
        <span class="s1">self._validate_index()</span>
        <span class="s1">period = float_like(period</span><span class="s0">, </span><span class="s2">&quot;period&quot;</span><span class="s0">, </span><span class="s1">optional=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self._constant = constant = bool_like(constant</span><span class="s0">, </span><span class="s2">&quot;constant&quot;</span><span class="s1">)</span>
        <span class="s1">self._order = required_int_like(order</span><span class="s0">, </span><span class="s2">&quot;order&quot;</span><span class="s1">)</span>
        <span class="s1">self._seasonal = seasonal = bool_like(seasonal</span><span class="s0">, </span><span class="s2">&quot;seasonal&quot;</span><span class="s1">)</span>
        <span class="s1">self._fourier = required_int_like(fourier</span><span class="s0">, </span><span class="s2">&quot;fourier&quot;</span><span class="s1">)</span>
        <span class="s1">additional_terms = tuple(additional_terms)</span>
        <span class="s1">self._cached_in_sample = </span><span class="s0">None</span>
        <span class="s1">self._drop = bool_like(drop</span><span class="s0">, </span><span class="s2">&quot;drop&quot;</span><span class="s1">)</span>
        <span class="s1">self._additional_terms = additional_terms</span>
        <span class="s0">if </span><span class="s1">constant </span><span class="s0">or </span><span class="s1">order:</span>
            <span class="s1">self._deterministic_terms.append(TimeTrend(constant</span><span class="s0">, </span><span class="s1">order))</span>
        <span class="s0">if </span><span class="s1">seasonal </span><span class="s0">and </span><span class="s1">fourier:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;&quot;&quot;seasonal and fourier can be initialized through the </span><span class="s0">\ 
</span><span class="s2">constructor since these will be necessarily perfectly collinear. Instead, </span><span class="s0">\ 
</span><span class="s2">you can pass additional components using the additional_terms input.&quot;&quot;&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">(seasonal </span><span class="s0">or </span><span class="s1">fourier) </span><span class="s0">and </span><span class="s1">period </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">period </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self._period = period = freq_to_period(self._index_freq)</span>
        <span class="s0">if </span><span class="s1">seasonal:</span>
            <span class="s1">period = required_int_like(period</span><span class="s0">, </span><span class="s2">&quot;period&quot;</span><span class="s1">)</span>
            <span class="s1">self._deterministic_terms.append(Seasonality(period))</span>
        <span class="s0">elif </span><span class="s1">fourier:</span>
            <span class="s1">period = float_like(period</span><span class="s0">, </span><span class="s2">&quot;period&quot;</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">period </span><span class="s0">is not None</span>
            <span class="s1">self._deterministic_terms.append(Fourier(period</span><span class="s0">, </span><span class="s1">order=fourier))</span>
        <span class="s0">for </span><span class="s1">term </span><span class="s0">in </span><span class="s1">additional_terms:</span>
            <span class="s0">if not </span><span class="s1">isinstance(term</span><span class="s0">, </span><span class="s1">DeterministicTerm):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;All additional terms must be instances of subsclasses &quot;</span>
                    <span class="s2">&quot;of DeterministicTerm&quot;</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">term </span><span class="s0">not in </span><span class="s1">self._deterministic_terms:</span>
                <span class="s1">self._deterministic_terms.append(term)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;One or more terms in additional_terms has been added &quot;</span>
                    <span class="s2">&quot;through the parameters of the constructor. Terms must &quot;</span>
                    <span class="s2">&quot;be unique.&quot;</span>
                <span class="s1">)</span>
        <span class="s1">self._period = period</span>
        <span class="s1">self._retain_cols: Optional[List[Hashable]] = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">index(self) -&gt; pd.Index:</span>
        <span class="s3">&quot;&quot;&quot;The index of the process&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._index</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">terms(self) -&gt; List[DeterministicTerm]:</span>
        <span class="s3">&quot;&quot;&quot;The deterministic terms included in the process&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._deterministic_terms</span>

    <span class="s0">def </span><span class="s1">_adjust_dummies(self</span><span class="s0">, </span><span class="s1">terms: List[pd.DataFrame]) -&gt; List[pd.DataFrame]:</span>
        <span class="s1">has_const: Optional[bool] = </span><span class="s0">None</span>
        <span class="s0">for </span><span class="s1">dterm </span><span class="s0">in </span><span class="s1">self._deterministic_terms:</span>
            <span class="s0">if </span><span class="s1">isinstance(dterm</span><span class="s0">, </span><span class="s1">(TimeTrend</span><span class="s0">, </span><span class="s1">CalendarTimeTrend)):</span>
                <span class="s1">has_const = has_const </span><span class="s0">or </span><span class="s1">dterm.constant</span>
        <span class="s0">if </span><span class="s1">has_const </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">has_const = </span><span class="s0">False</span>
            <span class="s0">for </span><span class="s1">term </span><span class="s0">in </span><span class="s1">terms:</span>
                <span class="s1">const_col = (term == term.iloc[</span><span class="s5">0</span><span class="s1">]).all() &amp; (term.iloc[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">has_const = has_const </span><span class="s0">or </span><span class="s1">const_col.any()</span>
        <span class="s1">drop_first = has_const</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">dterm </span><span class="s0">in </span><span class="s1">enumerate(self._deterministic_terms):</span>
            <span class="s1">is_dummy = dterm.is_dummy</span>
            <span class="s0">if </span><span class="s1">is_dummy </span><span class="s0">and </span><span class="s1">drop_first:</span>
                <span class="s4"># drop first</span>
                <span class="s1">terms[i] = terms[i].iloc[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">drop_first = drop_first </span><span class="s0">or </span><span class="s1">is_dummy</span>
        <span class="s0">return </span><span class="s1">terms</span>

    <span class="s0">def </span><span class="s1">_remove_zeros_ones(self</span><span class="s0">, </span><span class="s1">terms: pd.DataFrame) -&gt; pd.DataFrame:</span>
        <span class="s1">all_zero = np.all(terms == </span><span class="s5">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">np.any(all_zero):</span>
            <span class="s1">terms = terms.loc[:</span><span class="s0">, </span><span class="s1">~all_zero]</span>
        <span class="s1">is_constant = terms.max(axis=</span><span class="s5">0</span><span class="s1">) == terms.min(axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">np.sum(is_constant) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># Retain first</span>
            <span class="s1">const_locs = np.where(is_constant)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">is_constant[const_locs[:</span><span class="s5">1</span><span class="s1">]] = </span><span class="s0">False</span>
            <span class="s1">terms = terms.loc[:</span><span class="s0">, </span><span class="s1">~is_constant]</span>
        <span class="s0">return </span><span class="s1">terms</span>

    <span class="s1">@Appender(DeterministicTerm.in_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">in_sample(self) -&gt; pd.DataFrame:</span>
        <span class="s0">if </span><span class="s1">self._cached_in_sample </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._cached_in_sample</span>
        <span class="s1">index = self._index</span>
        <span class="s0">if not </span><span class="s1">self._deterministic_terms:</span>
            <span class="s0">return </span><span class="s1">pd.DataFrame(np.empty((index.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">raw_terms = []</span>
        <span class="s0">for </span><span class="s1">term </span><span class="s0">in </span><span class="s1">self._deterministic_terms:</span>
            <span class="s1">raw_terms.append(term.in_sample(index))</span>

        <span class="s1">raw_terms = self._adjust_dummies(raw_terms)</span>
        <span class="s1">terms: pd.DataFrame = pd.concat(raw_terms</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">terms = self._remove_zeros_ones(terms)</span>
        <span class="s0">if </span><span class="s1">self._drop:</span>
            <span class="s1">terms_arr = to_numpy(terms)</span>
            <span class="s1">res = qr(terms_arr</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;r&quot;</span><span class="s0">, </span><span class="s1">pivoting=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">r = res[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">p = res[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">abs_diag = np.abs(np.diag(r))</span>
            <span class="s1">tol = abs_diag[</span><span class="s5">0</span><span class="s1">] * terms_arr.shape[</span><span class="s5">1</span><span class="s1">] * np.finfo(float).eps</span>
            <span class="s1">rank = int(np.sum(abs_diag &gt; tol))</span>
            <span class="s1">rpx = r.T @ terms_arr</span>
            <span class="s1">keep = [</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">last_rank = </span><span class="s5">1</span>
            <span class="s4"># Find the left-most columns that produce full rank</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">terms_arr.shape[</span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s1">curr_rank = np.linalg.matrix_rank(rpx[: i + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">: i + </span><span class="s5">1</span><span class="s1">])</span>
                <span class="s0">if </span><span class="s1">curr_rank &gt; last_rank:</span>
                    <span class="s1">keep.append(i)</span>
                    <span class="s1">last_rank = curr_rank</span>
                <span class="s0">if </span><span class="s1">curr_rank == rank:</span>
                    <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">len(keep) == rank:</span>
                <span class="s1">terms = terms.iloc[:</span><span class="s0">, </span><span class="s1">keep]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">terms = terms.iloc[:</span><span class="s0">, </span><span class="s1">np.sort(p[:rank])]</span>
        <span class="s1">self._retain_cols = terms.columns</span>
        <span class="s1">self._cached_in_sample = terms</span>
        <span class="s0">return </span><span class="s1">terms</span>

    <span class="s1">@Appender(DeterministicTerm.out_of_sample.__doc__)</span>
    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">forecast_index: Optional[Union[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">pd.Index]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">steps = required_int_like(steps</span><span class="s0">, </span><span class="s2">&quot;steps&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self._drop </span><span class="s0">and </span><span class="s1">self._retain_cols </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.in_sample()</span>
        <span class="s1">index = self._index</span>
        <span class="s0">if not </span><span class="s1">self._deterministic_terms:</span>
            <span class="s0">return </span><span class="s1">pd.DataFrame(np.empty((index.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">raw_terms = []</span>
        <span class="s0">for </span><span class="s1">term </span><span class="s0">in </span><span class="s1">self._deterministic_terms:</span>
            <span class="s1">raw_terms.append(term.out_of_sample(steps</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">forecast_index))</span>
        <span class="s1">terms: pd.DataFrame = pd.concat(raw_terms</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">self._retain_cols </span><span class="s0">is not None</span>
        <span class="s0">if </span><span class="s1">terms.shape[</span><span class="s5">1</span><span class="s1">] != len(self._retain_cols):</span>
            <span class="s1">terms = terms[self._retain_cols]</span>
        <span class="s0">return </span><span class="s1">terms</span>

    <span class="s0">def </span><span class="s1">_extend_time_index(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">stop: pd.Timestamp</span><span class="s0">,</span>
    <span class="s1">) -&gt; Union[pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex]:</span>
        <span class="s1">index = self._index</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.PeriodIndex):</span>
            <span class="s0">return </span><span class="s1">pd.period_range(index[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">end=stop</span><span class="s0">, </span><span class="s1">freq=index.freq)</span>
        <span class="s0">return </span><span class="s1">pd.date_range(start=index[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">end=stop</span><span class="s0">, </span><span class="s1">freq=self._index_freq)</span>

    <span class="s0">def </span><span class="s1">_range_from_range_index(self</span><span class="s0">, </span><span class="s1">start: int</span><span class="s0">, </span><span class="s1">stop: int) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index</span>
        <span class="s1">is_int64_index = is_int_index(index)</span>
        <span class="s0">assert </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.RangeIndex) </span><span class="s0">or </span><span class="s1">is_int64_index</span>
        <span class="s0">if </span><span class="s1">start &lt; index[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(START_BEFORE_INDEX_ERR)</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">pd.RangeIndex):</span>
            <span class="s1">idx_step = index.step</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">idx_step = np.diff(index).max() </span><span class="s0">if </span><span class="s1">len(index) &gt; </span><span class="s5">1 </span><span class="s0">else </span><span class="s5">1</span>
        <span class="s0">if </span><span class="s1">idx_step != </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">((start - index[</span><span class="s5">0</span><span class="s1">]) % idx_step) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">f&quot;The step of the index is not 1 (actual step=</span><span class="s0">{</span><span class="s1">idx_step</span><span class="s0">}</span><span class="s2">).&quot;</span>
                <span class="s2">&quot; start must be in the sequence that would have been &quot;</span>
                <span class="s2">&quot;generated by the index.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_int64_index:</span>
            <span class="s1">new_idx = pd.Index(np.arange(start</span><span class="s0">, </span><span class="s1">stop))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_idx = pd.RangeIndex(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step=idx_step)</span>
        <span class="s0">if </span><span class="s1">new_idx[-</span><span class="s5">1</span><span class="s1">] &lt;= self._index[-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s4"># In-sample only</span>
            <span class="s1">in_sample = self.in_sample()</span>
            <span class="s1">in_sample = in_sample.loc[new_idx]</span>
            <span class="s0">return </span><span class="s1">in_sample</span>
        <span class="s0">elif </span><span class="s1">new_idx[</span><span class="s5">0</span><span class="s1">] &gt; self._index[-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s4"># Out of-sample only</span>
            <span class="s1">next_value = index[-</span><span class="s5">1</span><span class="s1">] + idx_step</span>
            <span class="s0">if </span><span class="s1">new_idx[</span><span class="s5">0</span><span class="s1">] != next_value:</span>
                <span class="s1">tmp = pd.RangeIndex(next_value</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step=idx_step)</span>
                <span class="s1">oos = self.out_of_sample(tmp.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">forecast_index=tmp)</span>
                <span class="s0">return </span><span class="s1">oos.loc[new_idx]</span>
            <span class="s0">return </span><span class="s1">self.out_of_sample(new_idx.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">forecast_index=new_idx)</span>
        <span class="s4"># Using some from each in and out of sample</span>
        <span class="s1">in_sample_loc = new_idx &lt;= self._index[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">in_sample_idx = new_idx[in_sample_loc]</span>
        <span class="s1">out_of_sample_idx = new_idx[~in_sample_loc]</span>
        <span class="s1">in_sample_exog = self.in_sample().loc[in_sample_idx]</span>
        <span class="s1">oos_exog = self.out_of_sample(</span>
            <span class="s1">steps=out_of_sample_idx.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">forecast_index=out_of_sample_idx</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">pd.concat([in_sample_exog</span><span class="s0">, </span><span class="s1">oos_exog]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_range_from_time_index(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">start: pd.Timestamp</span><span class="s0">, </span><span class="s1">stop: pd.Timestamp</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">index = self._index</span>
        <span class="s0">if </span><span class="s1">isinstance(self._index</span><span class="s0">, </span><span class="s1">pd.PeriodIndex):</span>
            <span class="s0">if </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">pd.Timestamp):</span>
                <span class="s1">start = start.to_period(freq=self._index_freq)</span>
            <span class="s0">if </span><span class="s1">isinstance(stop</span><span class="s0">, </span><span class="s1">pd.Timestamp):</span>
                <span class="s1">stop = stop.to_period(freq=self._index_freq)</span>
        <span class="s0">if </span><span class="s1">start &lt; index[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(START_BEFORE_INDEX_ERR)</span>
        <span class="s0">if </span><span class="s1">stop &lt;= self._index[-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s0">return </span><span class="s1">self.in_sample().loc[start:stop]</span>
        <span class="s1">new_idx = self._extend_time_index(stop)</span>
        <span class="s1">oos_idx = new_idx[new_idx &gt; index[-</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s1">oos = self.out_of_sample(oos_idx.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">oos_idx)</span>
        <span class="s0">if </span><span class="s1">start &gt;= oos_idx[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s0">return </span><span class="s1">oos.loc[start:stop]</span>
        <span class="s1">both = pd.concat([self.in_sample()</span><span class="s0">, </span><span class="s1">oos]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">both.loc[start:stop]</span>

    <span class="s0">def </span><span class="s1">_int_to_timestamp(self</span><span class="s0">, </span><span class="s1">value: int</span><span class="s0">, </span><span class="s1">name: str) -&gt; pd.Timestamp:</span>
        <span class="s0">if </span><span class="s1">value &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">} </span><span class="s2">must be non-negative.&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">value &lt; self._index.shape[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s0">return </span><span class="s1">self._index[value]</span>
        <span class="s1">add_periods = value - (self._index.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) + </span><span class="s5">1</span>
        <span class="s1">index = self._index</span>
        <span class="s0">if </span><span class="s1">isinstance(self._index</span><span class="s0">, </span><span class="s1">pd.PeriodIndex):</span>
            <span class="s1">pr = pd.period_range(</span>
                <span class="s1">index[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">freq=self._index_freq</span><span class="s0">, </span><span class="s1">periods=add_periods</span>
            <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">pr[-</span><span class="s5">1</span><span class="s1">].to_timestamp()</span>
        <span class="s1">dr = pd.date_range(</span>
            <span class="s1">index[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">freq=self._index_freq</span><span class="s0">, </span><span class="s1">periods=add_periods</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">dr[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">range(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">start: Union[IntLike</span><span class="s0">, </span><span class="s1">DateLike</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">,</span>
        <span class="s1">stop: Union[IntLike</span><span class="s0">, </span><span class="s1">DateLike</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s3">&quot;&quot;&quot; 
        Deterministic terms spanning a range of observations 
 
        Parameters 
        ---------- 
        start : {int, str, dt.datetime, pd.Timestamp, np.datetime64} 
            The first observation. 
        stop : {int, str, dt.datetime, pd.Timestamp, np.datetime64} 
            The final observation. Inclusive to match most prediction 
            function in statsmodels. 
 
        Returns 
        ------- 
        DataFrame 
            A data frame of deterministic terms 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self._extendable:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;&quot;&quot;The index in the deterministic process does not </span><span class="s0">\ 
</span><span class="s2">support extension. Only PeriodIndex, DatetimeIndex with a frequency, </span><span class="s0">\ 
</span><span class="s2">RangeIndex, and integral Indexes that start at 0 and have only unit </span><span class="s0">\ 
</span><span class="s2">differences can be extended when producing out-of-sample forecasts. 
&quot;&quot;&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">type(self._index) </span><span class="s0">in </span><span class="s1">(pd.RangeIndex</span><span class="s0">,</span><span class="s1">) </span><span class="s0">or </span><span class="s1">is_int_index(self._index):</span>
            <span class="s1">start = required_int_like(start</span><span class="s0">, </span><span class="s2">&quot;start&quot;</span><span class="s1">)</span>
            <span class="s1">stop = required_int_like(stop</span><span class="s0">, </span><span class="s2">&quot;stop&quot;</span><span class="s1">)</span>
            <span class="s4"># Add 1 to ensure that the end point is inclusive</span>
            <span class="s1">stop += </span><span class="s5">1</span>
            <span class="s0">return </span><span class="s1">self._range_from_range_index(start</span><span class="s0">, </span><span class="s1">stop)</span>
        <span class="s0">if </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">np.integer)):</span>
            <span class="s1">start = self._int_to_timestamp(start</span><span class="s0">, </span><span class="s2">&quot;start&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">start = pd.Timestamp(start)</span>
        <span class="s0">if </span><span class="s1">isinstance(stop</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">np.integer)):</span>
            <span class="s1">stop = self._int_to_timestamp(stop</span><span class="s0">, </span><span class="s2">&quot;stop&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">stop = pd.Timestamp(stop)</span>
        <span class="s0">return </span><span class="s1">self._range_from_time_index(start</span><span class="s0">, </span><span class="s1">stop)</span>

    <span class="s0">def </span><span class="s1">_validate_index(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(self._index</span><span class="s0">, </span><span class="s1">pd.PeriodIndex):</span>
            <span class="s1">self._index_freq = self._index.freq</span>
            <span class="s1">self._extendable = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">isinstance(self._index</span><span class="s0">, </span><span class="s1">pd.DatetimeIndex):</span>
            <span class="s1">self._index_freq = self._index.freq </span><span class="s0">or </span><span class="s1">self._index.inferred_freq</span>
            <span class="s1">self._extendable = self._index_freq </span><span class="s0">is not None</span>
        <span class="s0">elif </span><span class="s1">isinstance(self._index</span><span class="s0">, </span><span class="s1">pd.RangeIndex):</span>
            <span class="s1">self._extendable = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">is_int_index(self._index):</span>
            <span class="s1">self._extendable = self._index[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">np.all(</span>
                <span class="s1">np.diff(self._index) == </span><span class="s5">1</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">apply(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s3">&quot;&quot;&quot; 
        Create an identical determinstic process with a different index 
 
        Parameters 
        ---------- 
        index : index_like 
            An index-like object. If not an index, it is converted to an 
            index. 
 
        Returns 
        ------- 
        DeterministicProcess 
            The deterministic process applied to a different index 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">DeterministicProcess(</span>
            <span class="s1">index</span><span class="s0">,</span>
            <span class="s1">period=self._period</span><span class="s0">,</span>
            <span class="s1">constant=self._constant</span><span class="s0">,</span>
            <span class="s1">order=self._order</span><span class="s0">,</span>
            <span class="s1">seasonal=self._seasonal</span><span class="s0">,</span>
            <span class="s1">fourier=self._fourier</span><span class="s0">,</span>
            <span class="s1">additional_terms=self._additional_terms</span><span class="s0">,</span>
            <span class="s1">drop=self._drop</span><span class="s0">,</span>
        <span class="s1">)</span>
</pre>
</body>
</html>