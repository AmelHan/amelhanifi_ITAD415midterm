<html>
<head>
<title>tsa_model.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tsa_model.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_float_index</span><span class="s0">,</span>
    <span class="s1">is_int_index</span><span class="s0">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">numbers</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">Period</span><span class="s0">,</span>
    <span class="s1">PeriodIndex</span><span class="s0">,</span>
    <span class="s1">RangeIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
    <span class="s1">period_range</span><span class="s0">,</span>
    <span class="s1">to_datetime</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.tseries.frequencies </span><span class="s0">import </span><span class="s1">to_offset</span>

<span class="s0">from </span><span class="s1">statsmodels.base.data </span><span class="s0">import </span><span class="s1">PandasData</span>
<span class="s0">import </span><span class="s1">statsmodels.base.model </span><span class="s0">as </span><span class="s1">base</span>
<span class="s0">import </span><span class="s1">statsmodels.base.wrapper </span><span class="s0">as </span><span class="s1">wrap</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s0">import </span><span class="s1">ValueWarning</span>

<span class="s1">_tsa_doc = </span><span class="s2">&quot;&quot;&quot; 
    %(model)s 
 
    Parameters 
    ---------- 
    %(params)s 
    dates : array_like, optional 
        An array-like object of datetime objects. If a pandas object is given 
        for endog or exog, it is assumed to have a DateIndex. 
    freq : str, optional 
        The frequency of the time-series. A Pandas offset or 'B', 'D', 'W', 
        'M', 'A', or 'Q'. This is optional if dates are given. 
    %(extra_params)s 
    %(extra_sections)s&quot;&quot;&quot;</span>

<span class="s1">_model_doc = </span><span class="s2">&quot;Timeseries model base class&quot;</span>

<span class="s1">_generic_params = base._model_params_doc</span>
<span class="s1">_missing_param_doc = base._missing_param_doc</span>


<span class="s0">def </span><span class="s1">get_index_loc(key</span><span class="s0">, </span><span class="s1">index):</span>
    <span class="s3">&quot;&quot;&quot; 
    Get the location of a specific key in an index 
 
    Parameters 
    ---------- 
    key : label 
        The key for which to find the location if the underlying index is 
        a DateIndex or a location if the underlying index is a RangeIndex 
        or an Index with an integer dtype. 
    index : pd.Index 
        The index to search. 
 
    Returns 
    ------- 
    loc : int 
        The location of the key 
    index : pd.Index 
        The index including the key; this is a copy of the original index 
        unless the index had to be expanded to accommodate `key`. 
    index_was_expanded : bool 
        Whether or not the index was expanded to accommodate `key`. 
 
    Notes 
    ----- 
    If `key` is past the end of of the given index, and the index is either 
    an Index with an integral dtype or a date index, this function extends 
    the index up to and including key, and then returns the location in the 
    new index. 
    &quot;&quot;&quot;</span>
    <span class="s1">base_index = index</span>

    <span class="s1">index = base_index</span>
    <span class="s1">date_index = isinstance(base_index</span><span class="s0">, </span><span class="s1">(PeriodIndex</span><span class="s0">, </span><span class="s1">DatetimeIndex))</span>
    <span class="s1">int_index = is_int_index(base_index)</span>
    <span class="s1">range_index = isinstance(base_index</span><span class="s0">, </span><span class="s1">RangeIndex)</span>
    <span class="s1">index_class = type(base_index)</span>
    <span class="s1">nobs = len(index)</span>

    <span class="s4"># Special handling for RangeIndex</span>
    <span class="s0">if </span><span class="s1">range_index </span><span class="s0">and </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">np.integer)):</span>
        <span class="s4"># Negative indices (that lie in the Index)</span>
        <span class="s0">if </span><span class="s1">key &lt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">-key &lt;= nobs:</span>
            <span class="s1">key = nobs + key</span>
        <span class="s4"># Out-of-sample (note that we include key itself in the new index)</span>
        <span class="s0">elif </span><span class="s1">key &gt; nobs - </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># See gh5835. Remove the except after pandas 0.25 required.</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">base_index_start = base_index.start</span>
                <span class="s1">base_index_step = base_index.step</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s1">base_index_start = base_index._start</span>
                <span class="s1">base_index_step = base_index._step</span>
            <span class="s1">stop = base_index_start + (key + </span><span class="s5">1</span><span class="s1">) * base_index_step</span>
            <span class="s1">index = RangeIndex(</span>
                <span class="s1">start=base_index_start</span><span class="s0">, </span><span class="s1">stop=stop</span><span class="s0">, </span><span class="s1">step=base_index_step</span>
            <span class="s1">)</span>

    <span class="s4"># Special handling for NumericIndex</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s0">not </span><span class="s1">range_index</span>
        <span class="s0">and </span><span class="s1">int_index</span>
        <span class="s0">and not </span><span class="s1">date_index</span>
        <span class="s0">and </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">np.integer))</span>
    <span class="s1">):</span>
        <span class="s4"># Negative indices (that lie in the Index)</span>
        <span class="s0">if </span><span class="s1">key &lt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">-key &lt;= nobs:</span>
            <span class="s1">key = nobs + key</span>
        <span class="s4"># Out-of-sample (note that we include key itself in the new index)</span>
        <span class="s0">elif </span><span class="s1">key &gt; base_index[-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">index = Index(np.arange(base_index[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">int(key + </span><span class="s5">1</span><span class="s1">)))</span>

    <span class="s4"># Special handling for date indexes</span>
    <span class="s0">if </span><span class="s1">date_index:</span>
        <span class="s4"># Use index type to choose creation function</span>
        <span class="s0">if </span><span class="s1">index_class </span><span class="s0">is </span><span class="s1">DatetimeIndex:</span>
            <span class="s1">index_fn = date_range</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">index_fn = period_range</span>
        <span class="s4"># Integer key (i.e. already given a location)</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">np.integer)):</span>
            <span class="s4"># Negative indices (that lie in the Index)</span>
            <span class="s0">if </span><span class="s1">key &lt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">-key &lt; nobs:</span>
                <span class="s1">key = index[nobs + key]</span>
            <span class="s4"># Out-of-sample (note that we include key itself in the new</span>
            <span class="s4"># index)</span>
            <span class="s0">elif </span><span class="s1">key &gt; len(base_index) - </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">index = index_fn(</span>
                    <span class="s1">start=base_index[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">periods=int(key + </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">freq=base_index.freq</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s1">key = index[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">key = index[key]</span>
        <span class="s4"># Other key types (i.e. string date or some datetime-like object)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># Convert the key to the appropriate date-like object</span>
            <span class="s0">if </span><span class="s1">index_class </span><span class="s0">is </span><span class="s1">PeriodIndex:</span>
                <span class="s1">date_key = Period(key</span><span class="s0">, </span><span class="s1">freq=base_index.freq)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">date_key = Timestamp(key)</span>

            <span class="s4"># Out-of-sample</span>
            <span class="s0">if </span><span class="s1">date_key &gt; base_index[-</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s4"># First create an index that may not always include `key`</span>
                <span class="s1">index = index_fn(</span>
                    <span class="s1">start=base_index[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">end=date_key</span><span class="s0">, </span><span class="s1">freq=base_index.freq</span>
                <span class="s1">)</span>

                <span class="s4"># Now make sure we include `key`</span>
                <span class="s0">if not </span><span class="s1">index[-</span><span class="s5">1</span><span class="s1">] == date_key:</span>
                    <span class="s1">index = index_fn(</span>
                        <span class="s1">start=base_index[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">periods=len(index) + </span><span class="s5">1</span><span class="s0">,</span>
                        <span class="s1">freq=base_index.freq</span><span class="s0">,</span>
                    <span class="s1">)</span>

                <span class="s4"># To avoid possible inconsistencies with `get_loc` below,</span>
                <span class="s4"># set the key directly equal to the last index location</span>
                <span class="s1">key = index[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s4"># Get the location</span>
    <span class="s0">if </span><span class="s1">date_index:</span>
        <span class="s4"># (note that get_loc will throw a KeyError if key is invalid)</span>
        <span class="s1">loc = index.get_loc(key)</span>
    <span class="s0">elif </span><span class="s1">int_index </span><span class="s0">or </span><span class="s1">range_index:</span>
        <span class="s4"># For NumericIndex and RangeIndex, key is assumed to be the location</span>
        <span class="s4"># and not an index value (this assumption is required to support</span>
        <span class="s4"># RangeIndex)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">index[key]</span>
        <span class="s4"># We want to raise a KeyError in this case, to keep the exception</span>
        <span class="s4"># consistent across index types.</span>
        <span class="s4"># - Attempting to index with an out-of-bound location (e.g.</span>
        <span class="s4">#   index[10] on an index of length 9) will raise an IndexError</span>
        <span class="s4">#   (as of Pandas 0.22)</span>
        <span class="s4"># - Attemtping to index with a type that cannot be cast to integer</span>
        <span class="s4">#   (e.g. a non-numeric string) will raise a ValueError if the</span>
        <span class="s4">#   index is RangeIndex (otherwise will raise an IndexError)</span>
        <span class="s4">#   (as of Pandas 0.22)</span>
        <span class="s0">except </span><span class="s1">(IndexError</span><span class="s0">, </span><span class="s1">ValueError) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">KeyError(str(e))</span>
        <span class="s1">loc = key</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">loc = index.get_loc(key)</span>

    <span class="s4"># Check if we now have a modified index</span>
    <span class="s1">index_was_expanded = index </span><span class="s0">is not </span><span class="s1">base_index</span>

    <span class="s4"># Return the index through the end of the loc / slice</span>
    <span class="s0">if </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">slice):</span>
        <span class="s1">end = loc.stop - </span><span class="s5">1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">end = loc</span>

    <span class="s0">return </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">index[: end + </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_was_expanded</span>


<span class="s0">def </span><span class="s1">get_index_label_loc(key</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">row_labels):</span>
    <span class="s3">&quot;&quot;&quot; 
    Get the location of a specific key in an index or model row labels 
 
    Parameters 
    ---------- 
    key : label 
        The key for which to find the location if the underlying index is 
        a DateIndex or is only being used as row labels, or a location if 
        the underlying index is a RangeIndex or a NumericIndex. 
    index : pd.Index 
        The index to search. 
    row_labels : pd.Index 
        Row labels to search if key not found in index 
 
    Returns 
    ------- 
    loc : int 
        The location of the key 
    index : pd.Index 
        The index including the key; this is a copy of the original index 
        unless the index had to be expanded to accommodate `key`. 
    index_was_expanded : bool 
        Whether or not the index was expanded to accommodate `key`. 
 
    Notes 
    ----- 
    This function expands on `get_index_loc` by first trying the given 
    base index (or the model's index if the base index was not given) and 
    then falling back to try again with the model row labels as the base 
    index. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">loc</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">index_was_expanded = get_index_loc(key</span><span class="s0">, </span><span class="s1">index)</span>
    <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">np.integer)):</span>
                <span class="s1">loc = row_labels.get_loc(key)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise</span>
            <span class="s4"># Require scalar</span>
            <span class="s4"># Pandas may return a slice if there are multiple matching</span>
            <span class="s4"># locations that are monotonic increasing (otherwise it may</span>
            <span class="s4"># return an array of integer locations, see below).</span>
            <span class="s0">if </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s1">loc = loc.start</span>
            <span class="s0">if </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s4"># Pandas may return a mask (boolean array), for e.g.:</span>
                <span class="s4"># pd.Index(list('abcb')).get_loc('b')</span>
                <span class="s0">if </span><span class="s1">loc.dtype == bool:</span>
                    <span class="s4"># Return the first True value</span>
                    <span class="s4"># (we know there is at least one True value if we're</span>
                    <span class="s4"># here because otherwise the get_loc call would have</span>
                    <span class="s4"># raised an exception)</span>
                    <span class="s1">loc = np.argmax(loc)</span>
                <span class="s4"># Finally, Pandas may return an integer array of</span>
                <span class="s4"># locations that match the given value, for e.g.</span>
                <span class="s4"># pd.DatetimeIndex(['2001-02', '2001-01']).get_loc('2001')</span>
                <span class="s4"># (this appears to be slightly undocumented behavior, since</span>
                <span class="s4"># only int, slice, and mask are mentioned in docs for</span>
                <span class="s4"># pandas.Index.get_loc as of 0.23.4)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">loc = loc[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">if not </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">numbers.Integral):</span>
                <span class="s0">raise</span>

            <span class="s1">index = row_labels[: loc + </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">index_was_expanded = </span><span class="s0">False</span>
        <span class="s0">except</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">e</span>
    <span class="s0">return </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">index_was_expanded</span>


<span class="s0">def </span><span class="s1">get_prediction_index(</span>
    <span class="s1">start</span><span class="s0">,</span>
    <span class="s1">end</span><span class="s0">,</span>
    <span class="s1">nobs</span><span class="s0">,</span>
    <span class="s1">base_index</span><span class="s0">,</span>
    <span class="s1">index=</span><span class="s0">None,</span>
    <span class="s1">silent=</span><span class="s0">False,</span>
    <span class="s1">index_none=</span><span class="s0">False,</span>
    <span class="s1">index_generated=</span><span class="s0">None,</span>
    <span class="s1">data=</span><span class="s0">None,</span>
<span class="s1">) -&gt; tuple[int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">Index | </span><span class="s0">None</span><span class="s1">]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Get the location of a specific key in an index or model row labels 
 
    Parameters 
    ---------- 
    start : label 
        The key at which to start prediction. Depending on the underlying 
        model's index, may be an integer, a date (string, datetime object, 
        pd.Timestamp, or pd.Period object), or some other object in the 
        model's row labels. 
    end : label 
        The key at which to end prediction (note that this key will be 
        *included* in prediction). Depending on the underlying 
        model's index, may be an integer, a date (string, datetime object, 
        pd.Timestamp, or pd.Period object), or some other object in the 
        model's row labels. 
    nobs : int 
    base_index : pd.Index 
 
    index : pd.Index, optional 
        Optionally an index to associate the predicted results to. If None, 
        an attempt is made to create an index for the predicted results 
        from the model's index or model's row labels. 
    silent : bool, optional 
        Argument to silence warnings. 
 
    Returns 
    ------- 
    start : int 
        The index / observation location at which to begin prediction. 
    end : int 
        The index / observation location at which to end in-sample 
        prediction. The maximum value for this is nobs-1. 
    out_of_sample : int 
        The number of observations to forecast after the end of the sample. 
    prediction_index : pd.Index or None 
        The index associated with the prediction results. This index covers 
        the range [start, end + out_of_sample]. If the model has no given 
        index and no given row labels (i.e. endog/exog is not Pandas), then 
        this will be None. 
 
    Notes 
    ----- 
    The arguments `start` and `end` behave differently, depending on if 
    they are integer or not. If either is an integer, then it is assumed 
    to refer to a *location* in the index, not to an index value. On the 
    other hand, if it is a date string or some other type of object, then 
    it is assumed to refer to an index *value*. In all cases, the returned 
    `start` and `end` values refer to index *locations* (so in the former 
    case, the given location is validated and returned whereas in the 
    latter case a location is found that corresponds to the given index 
    value). 
 
    This difference in behavior is necessary to support `RangeIndex`. This 
    is because integers for a RangeIndex could refer either to index values 
    or to index locations in an ambiguous way (while for `NumericIndex`, 
    since we have required them to be full indexes, there is no ambiguity). 
    &quot;&quot;&quot;</span>

    <span class="s4"># Convert index keys (start, end) to index locations and get associated</span>
    <span class="s4"># indexes.</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">start_oos = get_index_label_loc(</span>
            <span class="s1">start</span><span class="s0">, </span><span class="s1">base_index</span><span class="s0">, </span><span class="s1">data.row_labels</span>
        <span class="s1">)</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s0">raise </span><span class="s1">KeyError(</span>
            <span class="s2">&quot;The `start` argument could not be matched to a&quot;</span>
            <span class="s2">&quot; location related to the index of the data.&quot;</span>
        <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">end </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">end = max(start</span><span class="s0">, </span><span class="s1">len(base_index) - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">end</span><span class="s0">, </span><span class="s1">end_index</span><span class="s0">, </span><span class="s1">end_oos = get_index_label_loc(</span>
            <span class="s1">end</span><span class="s0">, </span><span class="s1">base_index</span><span class="s0">, </span><span class="s1">data.row_labels</span>
        <span class="s1">)</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s0">raise </span><span class="s1">KeyError(</span>
            <span class="s2">&quot;The `end` argument could not be matched to a&quot;</span>
            <span class="s2">&quot; location related to the index of the data.&quot;</span>
        <span class="s1">)</span>

    <span class="s4"># Handle slices (if the given index keys cover more than one date)</span>
    <span class="s0">if </span><span class="s1">isinstance(start</span><span class="s0">, </span><span class="s1">slice):</span>
        <span class="s1">start = start.start</span>
    <span class="s0">if </span><span class="s1">isinstance(end</span><span class="s0">, </span><span class="s1">slice):</span>
        <span class="s1">end = end.stop - </span><span class="s5">1</span>

    <span class="s4"># Get the actual index for the prediction</span>
    <span class="s1">prediction_index = end_index[start:]</span>

    <span class="s4"># Validate prediction options</span>
    <span class="s0">if </span><span class="s1">end &lt; start:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Prediction must have `end` after `start`.&quot;</span><span class="s1">)</span>

    <span class="s4"># Handle custom prediction index</span>
    <span class="s4"># First, if we were given an index, check that it's the right size and</span>
    <span class="s4"># use it if so</span>
    <span class="s0">if </span><span class="s1">index </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">len(prediction_index) == len(index):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Invalid `index` provided in prediction.&quot;</span>
                <span class="s2">&quot; Must have length consistent with `start`&quot;</span>
                <span class="s2">&quot; and `end` arguments.&quot;</span>
            <span class="s1">)</span>
        <span class="s4"># But if we weren't given Pandas input, this index will not be</span>
        <span class="s4"># used because the data will not be wrapped; in that case, issue</span>
        <span class="s4"># a warning</span>
        <span class="s0">if not </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">PandasData) </span><span class="s0">and not </span><span class="s1">silent:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;Because the model data (`endog`, `exog`) were&quot;</span>
                <span class="s2">&quot; not given as Pandas objects, the prediction&quot;</span>
                <span class="s2">&quot; output will be Numpy arrays, and the given&quot;</span>
                <span class="s2">&quot; `index` argument will only be used&quot;</span>
                <span class="s2">&quot; internally.&quot;</span><span class="s0">,</span>
                <span class="s1">ValueWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">prediction_index = Index(index)</span>
    <span class="s4"># Now, if we *do not* have a supported index, but we were given some</span>
    <span class="s4"># kind of index...</span>
    <span class="s0">elif </span><span class="s1">index_generated </span><span class="s0">and not </span><span class="s1">index_none:</span>
        <span class="s4"># If we are in sample, and have row labels, use them</span>
        <span class="s0">if </span><span class="s1">data.row_labels </span><span class="s0">is not None and not </span><span class="s1">(start_oos </span><span class="s0">or </span><span class="s1">end_oos):</span>
            <span class="s1">prediction_index = data.row_labels[start : end + </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s4"># Otherwise, warn the user that they will get an NumericIndex</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">silent:</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s2">&quot;No supported index is available.&quot;</span>
                    <span class="s2">&quot; Prediction results will be given with&quot;</span>
                    <span class="s2">&quot; an integer index beginning at `start`.&quot;</span><span class="s0">,</span>
                    <span class="s1">ValueWarning</span><span class="s0">,</span>
                    <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;No supported index is available. In the next&quot;</span>
                <span class="s2">&quot; version, calling this method in a model&quot;</span>
                <span class="s2">&quot; without a supported index will result in an&quot;</span>
                <span class="s2">&quot; exception.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">index_none:</span>
        <span class="s1">prediction_index = </span><span class="s0">None</span>

    <span class="s4"># For backwards compatibility, set `predict_*` values</span>
    <span class="s0">if </span><span class="s1">prediction_index </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">data.predict_start = prediction_index[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">data.predict_end = prediction_index[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">data.predict_dates = prediction_index</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">data.predict_start = </span><span class="s0">None</span>
        <span class="s1">data.predict_end = </span><span class="s0">None</span>
        <span class="s1">data.predict_dates = </span><span class="s0">None</span>

    <span class="s4"># Compute out-of-sample observations</span>
    <span class="s1">out_of_sample = max(end - (nobs - </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">end -= out_of_sample</span>

    <span class="s0">return </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">out_of_sample</span><span class="s0">, </span><span class="s1">prediction_index</span>


<span class="s0">class </span><span class="s1">TimeSeriesModel(base.LikelihoodModel):</span>
    <span class="s1">__doc__ = _tsa_doc % {</span>
        <span class="s2">&quot;model&quot;</span><span class="s1">: _model_doc</span><span class="s0">,</span>
        <span class="s2">&quot;params&quot;</span><span class="s1">: _generic_params</span><span class="s0">,</span>
        <span class="s2">&quot;extra_params&quot;</span><span class="s1">: _missing_param_doc</span><span class="s0">,</span>
        <span class="s2">&quot;extra_sections&quot;</span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">endog</span><span class="s0">, </span><span class="s1">exog=</span><span class="s0">None, </span><span class="s1">dates=</span><span class="s0">None, </span><span class="s1">freq=</span><span class="s0">None, </span><span class="s1">missing=</span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">missing=missing</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Date handling in indexes</span>
        <span class="s1">self._init_dates(dates</span><span class="s0">, </span><span class="s1">freq)</span>

    <span class="s0">def </span><span class="s1">_init_dates(self</span><span class="s0">, </span><span class="s1">dates=</span><span class="s0">None, </span><span class="s1">freq=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Initialize dates 
 
        Parameters 
        ---------- 
        dates : array_like, optional 
            An array like object containing dates. 
        freq : str, tuple, datetime.timedelta, DateOffset or None, optional 
            A frequency specification for either `dates` or the row labels from 
            the endog / exog data. 
 
        Notes 
        ----- 
        Creates `self._index` and related attributes. `self._index` is always 
        a Pandas index, and it is always NumericIndex, DatetimeIndex, or 
        PeriodIndex. 
 
        If Pandas objects, endog / exog may have any type of index. If it is 
        an NumericIndex with values 0, 1, ..., nobs-1 or if it is (coerceable to) 
        a DatetimeIndex or PeriodIndex *with an associated frequency*, then it 
        is called a &quot;supported&quot; index. Otherwise it is called an &quot;unsupported&quot; 
        index. 
 
        Supported indexes are standardized (i.e. a list of date strings is 
        converted to a DatetimeIndex) and the result is put in `self._index`. 
 
        Unsupported indexes are ignored, and a supported NumericIndex is 
        generated and put in `self._index`. Warnings are issued in this case 
        to alert the user if the returned index from some operation (e.g. 
        forecasting) is different from the original data's index. However, 
        whenever possible (e.g. purely in-sample prediction), the original 
        index is returned. 
 
        The benefit of supported indexes is that they allow *forecasting*, i.e. 
        it is possible to extend them in a reasonable way. Thus every model 
        must have an underlying supported index, even if it is just a generated 
        NumericIndex. 
        &quot;&quot;&quot;</span>

        <span class="s4"># Get our index from `dates` if available, otherwise from whatever</span>
        <span class="s4"># Pandas index we might have retrieved from endog, exog</span>
        <span class="s0">if </span><span class="s1">dates </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">index = dates</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">index = self.data.row_labels</span>

        <span class="s4"># Sanity check that we do not have a `freq` without an index</span>
        <span class="s0">if </span><span class="s1">index </span><span class="s0">is None and </span><span class="s1">freq </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Frequency provided without associated index.&quot;</span><span class="s1">)</span>

        <span class="s4"># If an index is available, see if it is a date-based index or if it</span>
        <span class="s4"># can be coerced to one. (If it cannot we'll fall back, below, to an</span>
        <span class="s4"># internal, 0, 1, ... nobs-1 integer index for modeling purposes)</span>
        <span class="s1">inferred_freq = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">index </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s4"># Try to coerce to date-based index</span>
            <span class="s0">if not </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">PeriodIndex)):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s4"># Only try to coerce non-numeric index types (string,</span>
                    <span class="s4"># list of date-times, etc.)</span>
                    <span class="s4"># Note that np.asarray(Float64Index([...])) yields an</span>
                    <span class="s4"># object dtype array in earlier versions of Pandas (and so</span>
                    <span class="s4"># will not have is_numeric_dtype == True), so explicitly</span>
                    <span class="s4"># check for it here. But note also that in very early</span>
                    <span class="s4"># Pandas (~0.12), Float64Index does not exist (and so the</span>
                    <span class="s4"># statsmodels compat makes it an empty tuple, so in that</span>
                    <span class="s4"># case also check if the first element is a float.</span>
                    <span class="s1">_index = np.asarray(index)</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s1">is_numeric_dtype(_index)</span>
                        <span class="s0">or </span><span class="s1">is_float_index(index)</span>
                        <span class="s0">or </span><span class="s1">(isinstance(_index[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">float))</span>
                    <span class="s1">):</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Numeric index given&quot;</span><span class="s1">)</span>
                    <span class="s4"># If a non-index Pandas series was given, only keep its</span>
                    <span class="s4"># values (because we must have a pd.Index type, below, and</span>
                    <span class="s4"># pd.to_datetime will return a Series when passed</span>
                    <span class="s4"># non-list-like objects)</span>
                    <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">Series):</span>
                        <span class="s1">index = index.values</span>
                    <span class="s4"># All coercion is done via pd.to_datetime</span>
                    <span class="s4"># Note: date coercion via pd.to_datetime does not handle</span>
                    <span class="s4"># string versions of PeriodIndex objects most of the time.</span>
                    <span class="s1">_index = to_datetime(index)</span>
                    <span class="s4"># Older versions of Pandas can sometimes fail here and</span>
                    <span class="s4"># return a numpy array - check to make sure it's an index</span>
                    <span class="s0">if not </span><span class="s1">isinstance(_index</span><span class="s0">, </span><span class="s1">Index):</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Could not coerce to date index&quot;</span><span class="s1">)</span>
                    <span class="s1">index = _index</span>
                <span class="s0">except</span><span class="s1">:</span>
                    <span class="s4"># Only want to actually raise an exception if `dates` was</span>
                    <span class="s4"># provided but cannot be coerced. If we got the index from</span>
                    <span class="s4"># the row_labels, we'll just ignore it and use the integer</span>
                    <span class="s4"># index below</span>
                    <span class="s0">if </span><span class="s1">dates </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span>
                            <span class="s2">&quot;Non-date index index provided to&quot;</span>
                            <span class="s2">&quot; `dates` argument.&quot;</span>
                        <span class="s1">)</span>
            <span class="s4"># Now, if we were given, or coerced, a date-based index, make sure</span>
            <span class="s4"># it has an associated frequency</span>
            <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">PeriodIndex)):</span>
                <span class="s4"># If no frequency, try to get an inferred frequency</span>
                <span class="s0">if </span><span class="s1">freq </span><span class="s0">is None and </span><span class="s1">index.freq </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">freq = index.inferred_freq</span>
                    <span class="s4"># If we got an inferred frequncy, alert the user</span>
                    <span class="s0">if </span><span class="s1">freq </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">inferred_freq = </span><span class="s0">True</span>
                        <span class="s0">if </span><span class="s1">freq </span><span class="s0">is not None</span><span class="s1">:</span>
                            <span class="s1">warnings.warn(</span>
                                <span class="s2">&quot;No frequency information was&quot;</span>
                                <span class="s2">&quot; provided, so inferred frequency %s&quot;</span>
                                <span class="s2">&quot; will be used.&quot; </span><span class="s1">% freq</span><span class="s0">,</span>
                                <span class="s1">ValueWarning</span><span class="s0">,</span>
                                <span class="s1">stacklevel = </span><span class="s5">2</span><span class="s0">,</span>
                            <span class="s1">)</span>

                <span class="s4"># Convert the passed freq to a pandas offset object</span>
                <span class="s0">if </span><span class="s1">freq </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">freq = to_offset(freq)</span>

                <span class="s4"># Now, if no frequency information is available from the index</span>
                <span class="s4"># itself or from the `freq` argument, raise an exception</span>
                <span class="s0">if </span><span class="s1">freq </span><span class="s0">is None and </span><span class="s1">index.freq </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s4"># But again, only want to raise the exception if `dates`</span>
                    <span class="s4"># was provided.</span>
                    <span class="s0">if </span><span class="s1">dates </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span>
                            <span class="s2">&quot;No frequency information was&quot;</span>
                            <span class="s2">&quot; provided with date index and no&quot;</span>
                            <span class="s2">&quot; frequency could be inferred.&quot;</span>
                        <span class="s1">)</span>
                <span class="s4"># However, if the index itself has no frequency information but</span>
                <span class="s4"># the `freq` argument is available (or was inferred), construct</span>
                <span class="s4"># a new index with an associated frequency</span>
                <span class="s0">elif </span><span class="s1">freq </span><span class="s0">is not None and </span><span class="s1">index.freq </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">resampled_index = date_range(</span>
                        <span class="s1">start=index[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">end=index[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">freq=freq</span>
                    <span class="s1">)</span>
                    <span class="s0">if not </span><span class="s1">inferred_freq </span><span class="s0">and not </span><span class="s1">resampled_index.equals(index):</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span>
                            <span class="s2">&quot;The given frequency argument could&quot;</span>
                            <span class="s2">&quot; not be matched to the given index.&quot;</span>
                        <span class="s1">)</span>
                    <span class="s1">index = resampled_index</span>
                <span class="s4"># Finally, if the index itself has a frequency and there was</span>
                <span class="s4"># also a given frequency, raise an exception if they are not</span>
                <span class="s4"># equal</span>
                <span class="s0">elif </span><span class="s1">(</span>
                    <span class="s1">freq </span><span class="s0">is not None</span>
                    <span class="s0">and not </span><span class="s1">inferred_freq</span>
                    <span class="s0">and not </span><span class="s1">(index.freq == freq)</span>
                <span class="s1">):</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">&quot;The given frequency argument is&quot;</span>
                        <span class="s2">&quot; incompatible with the given index.&quot;</span>
                    <span class="s1">)</span>
            <span class="s4"># Finally, raise an exception if we could not coerce to date-based</span>
            <span class="s4"># but we were given a frequency argument</span>
            <span class="s0">elif </span><span class="s1">freq </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Given index could not be coerced to dates&quot;</span>
                    <span class="s2">&quot; but `freq` argument was provided.&quot;</span>
                <span class="s1">)</span>

        <span class="s4"># Get attributes of the index</span>
        <span class="s1">has_index = index </span><span class="s0">is not None</span>
        <span class="s1">date_index = isinstance(index</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">PeriodIndex))</span>
        <span class="s1">period_index = isinstance(index</span><span class="s0">, </span><span class="s1">PeriodIndex)</span>
        <span class="s1">int_index = is_int_index(index)</span>
        <span class="s1">range_index = isinstance(index</span><span class="s0">, </span><span class="s1">RangeIndex)</span>
        <span class="s1">has_freq = index.freq </span><span class="s0">is not None if </span><span class="s1">date_index </span><span class="s0">else None</span>
        <span class="s1">increment = Index(range(self.endog.shape[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">is_increment = index.equals(increment) </span><span class="s0">if </span><span class="s1">int_index </span><span class="s0">else None</span>
        <span class="s0">if </span><span class="s1">date_index:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">is_monotonic = index.is_monotonic_increasing</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s4"># Remove after pandas 1.5 is minimum</span>
                <span class="s1">is_monotonic = index.is_monotonic</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">is_monotonic = </span><span class="s0">None</span>

        <span class="s4"># Issue warnings for unsupported indexes</span>
        <span class="s0">if </span><span class="s1">has_index </span><span class="s0">and not </span><span class="s1">(date_index </span><span class="s0">or </span><span class="s1">range_index </span><span class="s0">or </span><span class="s1">is_increment):</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;An unsupported index was provided and will be&quot;</span>
                <span class="s2">&quot; ignored when e.g. forecasting.&quot;</span><span class="s0">,</span>
                <span class="s1">ValueWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">date_index </span><span class="s0">and not </span><span class="s1">has_freq:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;A date index has been provided, but it has no&quot;</span>
                <span class="s2">&quot; associated frequency information and so will be&quot;</span>
                <span class="s2">&quot; ignored when e.g. forecasting.&quot;</span><span class="s0">,</span>
                <span class="s1">ValueWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">date_index </span><span class="s0">and not </span><span class="s1">is_monotonic:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;A date index has been provided, but it is not&quot;</span>
                <span class="s2">&quot; monotonic and so will be ignored when e.g.&quot;</span>
                <span class="s2">&quot; forecasting.&quot;</span><span class="s0">,</span>
                <span class="s1">ValueWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s4"># Construct the internal index</span>
        <span class="s1">index_generated = </span><span class="s0">False</span>
        <span class="s1">valid_index = (</span>
            <span class="s1">(date_index </span><span class="s0">and </span><span class="s1">has_freq </span><span class="s0">and </span><span class="s1">is_monotonic)</span>
            <span class="s0">or </span><span class="s1">(int_index </span><span class="s0">and </span><span class="s1">is_increment)</span>
            <span class="s0">or </span><span class="s1">range_index</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">valid_index:</span>
            <span class="s1">_index = index</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">_index = increment</span>
            <span class="s1">index_generated = </span><span class="s0">True</span>
        <span class="s1">self._index = _index</span>
        <span class="s1">self._index_generated = index_generated</span>
        <span class="s1">self._index_none = index </span><span class="s0">is None</span>
        <span class="s1">self._index_int64 = int_index </span><span class="s0">and not </span><span class="s1">range_index </span><span class="s0">and not </span><span class="s1">date_index</span>
        <span class="s1">self._index_dates = date_index </span><span class="s0">and not </span><span class="s1">index_generated</span>
        <span class="s1">self._index_freq = self._index.freq </span><span class="s0">if </span><span class="s1">self._index_dates </span><span class="s0">else None</span>
        <span class="s1">self._index_inferred_freq = inferred_freq</span>

        <span class="s4"># For backwards compatibility, set data.dates, data.freq</span>
        <span class="s1">self.data.dates = self._index </span><span class="s0">if </span><span class="s1">self._index_dates </span><span class="s0">else None</span>
        <span class="s1">self.data.freq = self._index.freqstr </span><span class="s0">if </span><span class="s1">self._index_dates </span><span class="s0">else None</span>

    <span class="s0">def </span><span class="s1">_get_index_loc(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">base_index=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get the location of a specific key in an index 
 
        Parameters 
        ---------- 
        key : label 
            The key for which to find the location if the underlying index is 
            a DateIndex or a location if the underlying index is a RangeIndex 
            or an NumericIndex. 
        base_index : pd.Index, optional 
            Optionally the base index to search. If None, the model's index is 
            searched. 
 
        Returns 
        ------- 
        loc : int 
            The location of the key 
        index : pd.Index 
            The index including the key; this is a copy of the original index 
            unless the index had to be expanded to accommodate `key`. 
        index_was_expanded : bool 
            Whether or not the index was expanded to accommodate `key`. 
 
        Notes 
        ----- 
        If `key` is past the end of of the given index, and the index is either 
        an NumericIndex or a date index, this function extends the index up to 
        and including key, and then returns the location in the new index. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">base_index </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">base_index = self._index</span>
        <span class="s0">return </span><span class="s1">get_index_loc(key</span><span class="s0">, </span><span class="s1">base_index)</span>

    <span class="s0">def </span><span class="s1">_get_index_label_loc(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">base_index=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get the location of a specific key in an index or model row labels 
 
        Parameters 
        ---------- 
        key : label 
            The key for which to find the location if the underlying index is 
            a DateIndex or is only being used as row labels, or a location if 
            the underlying index is a RangeIndex or an NumericIndex. 
        base_index : pd.Index, optional 
            Optionally the base index to search. If None, the model's index is 
            searched. 
 
        Returns 
        ------- 
        loc : int 
            The location of the key 
        index : pd.Index 
            The index including the key; this is a copy of the original index 
            unless the index had to be expanded to accommodate `key`. 
        index_was_expanded : bool 
            Whether or not the index was expanded to accommodate `key`. 
 
        Notes 
        ----- 
        This method expands on `_get_index_loc` by first trying the given 
        base index (or the model's index if the base index was not given) and 
        then falling back to try again with the model row labels as the base 
        index. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">base_index </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">base_index = self._index</span>
        <span class="s0">return </span><span class="s1">get_index_label_loc(key</span><span class="s0">, </span><span class="s1">base_index</span><span class="s0">, </span><span class="s1">self.data.row_labels)</span>

    <span class="s0">def </span><span class="s1">_get_prediction_index(self</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">None, </span><span class="s1">silent=</span><span class="s0">False</span><span class="s1">) -&gt; tuple[int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">Index | </span><span class="s0">None</span><span class="s1">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Get the location of a specific key in an index or model row labels 
 
        Parameters 
        ---------- 
        start : label 
            The key at which to start prediction. Depending on the underlying 
            model's index, may be an integer, a date (string, datetime object, 
            pd.Timestamp, or pd.Period object), or some other object in the 
            model's row labels. 
        end : label 
            The key at which to end prediction (note that this key will be 
            *included* in prediction). Depending on the underlying 
            model's index, may be an integer, a date (string, datetime object, 
            pd.Timestamp, or pd.Period object), or some other object in the 
            model's row labels. 
        index : pd.Index, optional 
            Optionally an index to associate the predicted results to. If None, 
            an attempt is made to create an index for the predicted results 
            from the model's index or model's row labels. 
        silent : bool, optional 
            Argument to silence warnings. 
 
        Returns 
        ------- 
        start : int 
            The index / observation location at which to begin prediction. 
        end : int 
            The index / observation location at which to end in-sample 
            prediction. The maximum value for this is nobs-1. 
        out_of_sample : int 
            The number of observations to forecast after the end of the sample. 
        prediction_index : pd.Index or None 
            The index associated with the prediction results. This index covers 
            the range [start, end + out_of_sample]. If the model has no given 
            index and no given row labels (i.e. endog/exog is not Pandas), then 
            this will be None. 
 
        Notes 
        ----- 
        The arguments `start` and `end` behave differently, depending on if 
        they are integer or not. If either is an integer, then it is assumed 
        to refer to a *location* in the index, not to an index value. On the 
        other hand, if it is a date string or some other type of object, then 
        it is assumed to refer to an index *value*. In all cases, the returned 
        `start` and `end` values refer to index *locations* (so in the former 
        case, the given location is validated and returned whereas in the 
        latter case a location is found that corresponds to the given index 
        value). 
 
        This difference in behavior is necessary to support `RangeIndex`. This 
        is because integers for a RangeIndex could refer either to index values 
        or to index locations in an ambiguous way (while for `NumericIndex`, 
        since we have required them to be full indexes, there is no ambiguity). 
        &quot;&quot;&quot;</span>
        <span class="s1">nobs = len(self.endog)</span>
        <span class="s0">return </span><span class="s1">get_prediction_index(</span>
            <span class="s1">start</span><span class="s0">,</span>
            <span class="s1">end</span><span class="s0">,</span>
            <span class="s1">nobs</span><span class="s0">,</span>
            <span class="s1">base_index=self._index</span><span class="s0">,</span>
            <span class="s1">index=index</span><span class="s0">,</span>
            <span class="s1">silent=silent</span><span class="s0">,</span>
            <span class="s1">index_none=self._index_none</span><span class="s0">,</span>
            <span class="s1">index_generated=self._index_generated</span><span class="s0">,</span>
            <span class="s1">data=self.data</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_exog_names(self):</span>
        <span class="s0">return </span><span class="s1">self.data.xnames</span>

    <span class="s0">def </span><span class="s1">_set_exog_names(self</span><span class="s0">, </span><span class="s1">vals):</span>
        <span class="s0">if not </span><span class="s1">isinstance(vals</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">vals = [vals]</span>
        <span class="s1">self.data.xnames = vals</span>

    <span class="s4"># TODO: This is an antipattern, fix/remove with VAR</span>
    <span class="s4"># overwrite with writable property for (V)AR models</span>
    <span class="s1">exog_names = property(</span>
        <span class="s1">_get_exog_names</span><span class="s0">,</span>
        <span class="s1">_set_exog_names</span><span class="s0">,</span>
        <span class="s0">None,</span>
        <span class="s2">&quot;The names of the exogenous variables.&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">TimeSeriesModelResults(base.LikelihoodModelResults):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">model</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">normalized_cov_params</span><span class="s0">, </span><span class="s1">scale=</span><span class="s5">1.0</span><span class="s1">):</span>
        <span class="s1">self.data = model.data</span>
        <span class="s1">super().__init__(model</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">normalized_cov_params</span><span class="s0">, </span><span class="s1">scale)</span>


<span class="s0">class </span><span class="s1">TimeSeriesResultsWrapper(wrap.ResultsWrapper):</span>
    <span class="s1">_attrs = {}</span>
    <span class="s1">_wrap_attrs = wrap.union_dicts(</span>
        <span class="s1">base.LikelihoodResultsWrapper._wrap_attrs</span><span class="s0">, </span><span class="s1">_attrs</span>
    <span class="s1">)</span>
    <span class="s1">_methods = {</span><span class="s2">&quot;predict&quot;</span><span class="s1">: </span><span class="s2">&quot;dates&quot;</span><span class="s1">}</span>
    <span class="s1">_wrap_methods = wrap.union_dicts(</span>
        <span class="s1">base.LikelihoodResultsWrapper._wrap_methods</span><span class="s0">, </span><span class="s1">_methods</span>
    <span class="s1">)</span>


<span class="s1">wrap.populate_wrapper(</span>
    <span class="s1">TimeSeriesResultsWrapper</span><span class="s0">, </span><span class="s1">TimeSeriesModelResults  </span><span class="s4"># noqa:E305</span>
<span class="s1">)</span>
</pre>
</body>
</html>