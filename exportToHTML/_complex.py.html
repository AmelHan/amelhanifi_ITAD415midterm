<html>
<head>
<title>_complex.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_complex.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Base classes for low memory simplicial complex structures.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">decimal</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">cache</span>

<span class="s2">import </span><span class="s1">numpy</span>

<span class="s2">from </span><span class="s1">._vertex </span><span class="s2">import </span><span class="s1">(VertexCacheField</span><span class="s2">, </span><span class="s1">VertexCacheIndex)</span>


<span class="s2">class </span><span class="s1">Complex:</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for a simplicial complex described as a cache of vertices 
    together with their connections. 
 
    Important methods: 
        Domain triangulation: 
                Complex.triangulate, Complex.split_generation 
        Triangulating arbitrary points (must be traingulable, 
            may exist outside domain): 
                Complex.triangulate(sample_set) 
        Converting another simplicial complex structure data type to the 
            structure used in Complex (ex. OBJ wavefront) 
                Complex.convert(datatype, data) 
 
    Important objects: 
        HC.V: The cache of vertices and their connection 
        HC.H: Storage structure of all vertex groups 
 
    Parameters 
    ---------- 
    dim : int 
        Spatial dimensionality of the complex R^dim 
    domain : list of tuples, optional 
        The bounds [x_l, x_u]^dim of the hyperrectangle space 
        ex. The default domain is the hyperrectangle [0, 1]^dim 
        Note: The domain must be convex, non-convex spaces can be cut 
              away from this domain using the non-linear 
              g_cons functions to define any arbitrary domain 
              (these domains may also be disconnected from each other) 
    sfield : 
        A scalar function defined in the associated domain f: R^dim --&gt; R 
    sfield_args : tuple 
        Additional arguments to be passed to `sfield` 
    vfield : 
        A scalar function defined in the associated domain 
                       f: R^dim --&gt; R^m 
                   (for example a gradient function of the scalar field) 
    vfield_args : tuple 
        Additional arguments to be passed to vfield 
    symmetry : None or list 
            Specify if the objective function contains symmetric variables. 
            The search space (and therefore performance) is decreased by up to 
            O(n!) times in the fully symmetric case. 
 
            E.g.  f(x) = (x_1 + x_2 + x_3) + (x_4)**2 + (x_5)**2 + (x_6)**2 
 
            In this equation x_2 and x_3 are symmetric to x_1, while x_5 and 
             x_6 are symmetric to x_4, this can be specified to the solver as: 
 
            symmetry = [0,  # Variable 1 
                        0,  # symmetric to variable 1 
                        0,  # symmetric to variable 1 
                        3,  # Variable 4 
                        3,  # symmetric to variable 4 
                        3,  # symmetric to variable 4 
                        ] 
 
    constraints : dict or sequence of dict, optional 
        Constraints definition. 
        Function(s) ``R**n`` in the form:: 
 
            g(x) &lt;= 0 applied as g : R^n -&gt; R^m 
            h(x) == 0 applied as h : R^n -&gt; R^p 
 
        Each constraint is defined in a dictionary with fields: 
 
            type : str 
                Constraint type: 'eq' for equality, 'ineq' for inequality. 
            fun : callable 
                The function defining the constraint. 
            jac : callable, optional 
                The Jacobian of `fun` (only for SLSQP). 
            args : sequence, optional 
                Extra arguments to be passed to the function and Jacobian. 
 
        Equality constraint means that the constraint function result is to 
        be zero whereas inequality means that it is to be 
        non-negative.constraints : dict or sequence of dict, optional 
        Constraints definition. 
        Function(s) ``R**n`` in the form:: 
 
            g(x) &lt;= 0 applied as g : R^n -&gt; R^m 
            h(x) == 0 applied as h : R^n -&gt; R^p 
 
        Each constraint is defined in a dictionary with fields: 
 
            type : str 
                Constraint type: 'eq' for equality, 'ineq' for inequality. 
            fun : callable 
                The function defining the constraint. 
            jac : callable, optional 
                The Jacobian of `fun` (unused). 
            args : sequence, optional 
                Extra arguments to be passed to the function and Jacobian. 
 
        Equality constraint means that the constraint function result is to 
        be zero whereas inequality means that it is to be non-negative. 
 
    workers : int  optional 
        Uses `multiprocessing.Pool &lt;multiprocessing&gt;`) to compute the field 
         functions in parrallel. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dim</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None, </span><span class="s1">sfield=</span><span class="s2">None, </span><span class="s1">sfield_args=()</span><span class="s2">,</span>
                 <span class="s1">symmetry=</span><span class="s2">None, </span><span class="s1">constraints=</span><span class="s2">None, </span><span class="s1">workers=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">self.dim = dim</span>

        <span class="s4"># Domains</span>
        <span class="s1">self.domain = domain</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.bounds = [(float(</span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">float(</span><span class="s3">1.0</span><span class="s1">))</span><span class="s2">, </span><span class="s1">] * dim</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.bounds = domain</span>
        <span class="s1">self.symmetry = symmetry</span>
        <span class="s4">#      here in init to avoid if checks</span>

        <span class="s4"># Field functions</span>
        <span class="s1">self.sfield = sfield</span>
        <span class="s1">self.sfield_args = sfield_args</span>

        <span class="s4"># Process constraints</span>
        <span class="s4"># Constraints</span>
        <span class="s4"># Process constraint dict sequence:</span>
        <span class="s2">if </span><span class="s1">constraints </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.min_cons = constraints</span>
            <span class="s1">self.g_cons = []</span>
            <span class="s1">self.g_args = []</span>
            <span class="s2">if </span><span class="s1">(type(constraints) </span><span class="s2">is not </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">(type(constraints)</span>
                                                     <span class="s2">is not </span><span class="s1">list):</span>
                <span class="s1">constraints = (constraints</span><span class="s2">,</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">cons </span><span class="s2">in </span><span class="s1">constraints:</span>
                <span class="s2">if </span><span class="s1">cons[</span><span class="s5">'type'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s5">'ineq'</span><span class="s1">):</span>
                    <span class="s1">self.g_cons.append(cons[</span><span class="s5">'fun'</span><span class="s1">])</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">self.g_args.append(cons[</span><span class="s5">'args'</span><span class="s1">])</span>
                    <span class="s2">except </span><span class="s1">KeyError:</span>
                        <span class="s1">self.g_args.append(())</span>
            <span class="s1">self.g_cons = tuple(self.g_cons)</span>
            <span class="s1">self.g_args = tuple(self.g_args)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.g_cons = </span><span class="s2">None</span>
            <span class="s1">self.g_args = </span><span class="s2">None</span>

        <span class="s4"># Homology properties</span>
        <span class="s1">self.gen = </span><span class="s3">0</span>
        <span class="s1">self.perm_cycle = </span><span class="s3">0</span>

        <span class="s4"># Every cell is stored in a list of its generation,</span>
        <span class="s4"># ex. the initial cell is stored in self.H[0]</span>
        <span class="s4"># 1st get new cells are stored in self.H[1] etc.</span>
        <span class="s4"># When a cell is sub-generated it is removed from this list</span>

        <span class="s1">self.H = []  </span><span class="s4"># Storage structure of vertex groups</span>

        <span class="s4"># Cache of all vertices</span>
        <span class="s2">if </span><span class="s1">(sfield </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(self.g_cons </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s4"># Initiate a vertex cache and an associated field cache, note that</span>
            <span class="s4"># the field case is always initiated inside the vertex cache if an</span>
            <span class="s4"># associated field scalar field is defined:</span>
            <span class="s2">if </span><span class="s1">sfield </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.V = VertexCacheField(field=sfield</span><span class="s2">, </span><span class="s1">field_args=sfield_args</span><span class="s2">,</span>
                                          <span class="s1">g_cons=self.g_cons</span><span class="s2">,</span>
                                          <span class="s1">g_cons_args=self.g_args</span><span class="s2">,</span>
                                          <span class="s1">workers=workers)</span>
            <span class="s2">elif </span><span class="s1">self.g_cons </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.V = VertexCacheField(field=sfield</span><span class="s2">, </span><span class="s1">field_args=sfield_args</span><span class="s2">,</span>
                                          <span class="s1">g_cons=self.g_cons</span><span class="s2">,</span>
                                          <span class="s1">g_cons_args=self.g_args</span><span class="s2">,</span>
                                          <span class="s1">workers=workers)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.V = VertexCacheIndex()</span>

        <span class="s1">self.V_non_symm = []  </span><span class="s4"># List of non-symmetric vertices</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s2">return </span><span class="s1">self.H</span>

    <span class="s4"># %% Triangulation methods</span>
    <span class="s2">def </span><span class="s1">cyclic_product(self</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">supremum</span><span class="s2">, </span><span class="s1">centroid=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate initial triangulation using cyclic product&quot;&quot;&quot;</span>
        <span class="s4"># Define current hyperrectangle</span>
        <span class="s1">vot = tuple(origin)</span>
        <span class="s1">vut = tuple(supremum)  </span><span class="s4"># Hyperrectangle supremum</span>
        <span class="s1">self.V[vot]</span>
        <span class="s1">vo = self.V[vot]</span>
        <span class="s2">yield </span><span class="s1">vo.x</span>
        <span class="s1">self.V[vut].connect(self.V[vot])</span>
        <span class="s2">yield </span><span class="s1">vut</span>
        <span class="s4"># Cyclic group approach with second x_l --- x_u operation.</span>

        <span class="s4"># These containers store the &quot;lower&quot; and &quot;upper&quot; vertices</span>
        <span class="s4"># corresponding to the origin or supremum of every C2 group.</span>
        <span class="s4"># It has the structure of `dim` times embedded lists each containing</span>
        <span class="s4"># these vertices as the entire complex grows. Bounds[0] has to be done</span>
        <span class="s4"># outside the loops before we have symmetric containers.</span>
        <span class="s4"># NOTE: This means that bounds[0][1] must always exist</span>
        <span class="s1">C0x = [[self.V[vot]]]</span>
        <span class="s1">a_vo = copy.copy(list(origin))</span>
        <span class="s1">a_vo[</span><span class="s3">0</span><span class="s1">] = vut[</span><span class="s3">0</span><span class="s1">]  </span><span class="s4"># Update aN Origin</span>
        <span class="s1">a_vo = self.V[tuple(a_vo)]</span>
        <span class="s4"># self.V[vot].connect(self.V[tuple(a_vo)])</span>
        <span class="s1">self.V[vot].connect(a_vo)</span>
        <span class="s2">yield </span><span class="s1">a_vo.x</span>
        <span class="s1">C1x = [[a_vo]]</span>
        <span class="s4"># C1x = [[self.V[tuple(a_vo)]]]</span>
        <span class="s1">ab_C = []  </span><span class="s4"># Container for a + b operations</span>

        <span class="s4"># Loop over remaining bounds</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(bounds[</span><span class="s3">1</span><span class="s1">:]):</span>
            <span class="s4"># Update lower and upper containers</span>
            <span class="s1">C0x.append([])</span>
            <span class="s1">C1x.append([])</span>
            <span class="s4"># try to access a second bound (if not, C1 is symmetric)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># Early try so that we don't have to copy the cache before</span>
                <span class="s4"># moving on to next C1/C2: Try to add the operation of a new</span>
                <span class="s4"># C2 product by accessing the upper bound</span>
                <span class="s1">x[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s4"># Copy lists for iteration</span>
                <span class="s1">cC0x = [x[:] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">C0x[:i + </span><span class="s3">1</span><span class="s1">]]</span>
                <span class="s1">cC1x = [x[:] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">C1x[:i + </span><span class="s3">1</span><span class="s1">]]</span>
                <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">(VL</span><span class="s2">, </span><span class="s1">VU) </span><span class="s2">in </span><span class="s1">enumerate(zip(cC0x</span><span class="s2">, </span><span class="s1">cC1x)):</span>
                    <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">(vl</span><span class="s2">, </span><span class="s1">vu) </span><span class="s2">in </span><span class="s1">enumerate(zip(VL</span><span class="s2">, </span><span class="s1">VU)):</span>
                        <span class="s4"># Build aN vertices for each lower-upper pair in N:</span>
                        <span class="s1">a_vl = list(vl.x)</span>
                        <span class="s1">a_vu = list(vu.x)</span>
                        <span class="s1">a_vl[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                        <span class="s1">a_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                        <span class="s1">a_vl = self.V[tuple(a_vl)]</span>

                        <span class="s4"># Connect vertices in N to corresponding vertices</span>
                        <span class="s4"># in aN:</span>
                        <span class="s1">vl.connect(a_vl)</span>

                        <span class="s2">yield </span><span class="s1">a_vl.x</span>

                        <span class="s1">a_vu = self.V[tuple(a_vu)]</span>
                        <span class="s4"># Connect vertices in N to corresponding vertices</span>
                        <span class="s4"># in aN:</span>
                        <span class="s1">vu.connect(a_vu)</span>

                        <span class="s4"># Connect new vertex pair in aN:</span>
                        <span class="s1">a_vl.connect(a_vu)</span>

                        <span class="s4"># Connect lower pair to upper (triangulation</span>
                        <span class="s4"># operation of a + b (two arbitrary operations):</span>
                        <span class="s1">vl.connect(a_vu)</span>
                        <span class="s1">ab_C.append((vl</span><span class="s2">, </span><span class="s1">a_vu))</span>

                        <span class="s4"># Update the containers</span>
                        <span class="s1">C0x[i + </span><span class="s3">1</span><span class="s1">].append(vl)</span>
                        <span class="s1">C0x[i + </span><span class="s3">1</span><span class="s1">].append(vu)</span>
                        <span class="s1">C1x[i + </span><span class="s3">1</span><span class="s1">].append(a_vl)</span>
                        <span class="s1">C1x[i + </span><span class="s3">1</span><span class="s1">].append(a_vu)</span>

                        <span class="s4"># Update old containers</span>
                        <span class="s1">C0x[j].append(a_vl)</span>
                        <span class="s1">C1x[j].append(a_vu)</span>

                        <span class="s4"># Yield new points</span>
                        <span class="s2">yield </span><span class="s1">a_vu.x</span>

                <span class="s4"># Try to connect aN lower source of previous a + b</span>
                <span class="s4"># operation with a aN vertex</span>
                <span class="s1">ab_Cc = copy.copy(ab_C)</span>

                <span class="s2">for </span><span class="s1">vp </span><span class="s2">in </span><span class="s1">ab_Cc:</span>
                    <span class="s1">b_v = list(vp[</span><span class="s3">0</span><span class="s1">].x)</span>
                    <span class="s1">ab_v = list(vp[</span><span class="s3">1</span><span class="s1">].x)</span>
                    <span class="s1">b_v[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">ab_v[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">b_v = self.V[tuple(b_v)]  </span><span class="s4"># b + vl</span>
                    <span class="s1">ab_v = self.V[tuple(ab_v)]  </span><span class="s4"># b + a_vl</span>
                    <span class="s4"># Note o---o is already connected</span>
                    <span class="s1">vp[</span><span class="s3">0</span><span class="s1">].connect(ab_v)  </span><span class="s4"># o-s</span>
                    <span class="s1">b_v.connect(ab_v)  </span><span class="s4"># s-s</span>

                    <span class="s4"># Add new list of cross pairs</span>
                    <span class="s1">ab_C.append((vp[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ab_v))</span>
                    <span class="s1">ab_C.append((b_v</span><span class="s2">, </span><span class="s1">ab_v))</span>

            <span class="s2">except </span><span class="s1">IndexError:</span>
                <span class="s1">cC0x = C0x[i]</span>
                <span class="s1">cC1x = C1x[i]</span>
                <span class="s1">VL</span><span class="s2">, </span><span class="s1">VU = cC0x</span><span class="s2">, </span><span class="s1">cC1x</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">(vl</span><span class="s2">, </span><span class="s1">vu) </span><span class="s2">in </span><span class="s1">enumerate(zip(VL</span><span class="s2">, </span><span class="s1">VU)):</span>
                    <span class="s4"># Build aN vertices for each lower-upper pair in N:</span>
                    <span class="s1">a_vu = list(vu.x)</span>
                    <span class="s1">a_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s4"># Connect vertices in N to corresponding vertices</span>
                    <span class="s4"># in aN:</span>
                    <span class="s1">a_vu = self.V[tuple(a_vu)]</span>
                    <span class="s4"># Connect vertices in N to corresponding vertices</span>
                    <span class="s4"># in aN:</span>
                    <span class="s1">vu.connect(a_vu)</span>
                    <span class="s4"># Connect new vertex pair in aN:</span>
                    <span class="s4"># a_vl.connect(a_vu)</span>
                    <span class="s4"># Connect lower pair to upper (triangulation</span>
                    <span class="s4"># operation of a + b (two arbitrary operations):</span>
                    <span class="s1">vl.connect(a_vu)</span>
                    <span class="s1">ab_C.append((vl</span><span class="s2">, </span><span class="s1">a_vu))</span>
                    <span class="s1">C0x[i + </span><span class="s3">1</span><span class="s1">].append(vu)</span>
                    <span class="s1">C1x[i + </span><span class="s3">1</span><span class="s1">].append(a_vu)</span>
                    <span class="s4"># Yield new points</span>
                    <span class="s1">a_vu.connect(self.V[vut])</span>
                    <span class="s2">yield </span><span class="s1">a_vu.x</span>
                    <span class="s1">ab_Cc = copy.copy(ab_C)</span>
                    <span class="s2">for </span><span class="s1">vp </span><span class="s2">in </span><span class="s1">ab_Cc:</span>
                        <span class="s2">if </span><span class="s1">vp[</span><span class="s3">1</span><span class="s1">].x[i] == vut[i]:</span>
                            <span class="s1">ab_v = list(vp[</span><span class="s3">1</span><span class="s1">].x)</span>
                            <span class="s1">ab_v[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                            <span class="s1">ab_v = self.V[tuple(ab_v)]  </span><span class="s4"># b + a_vl</span>
                            <span class="s4"># Note o---o is already connected</span>
                            <span class="s1">vp[</span><span class="s3">0</span><span class="s1">].connect(ab_v)  </span><span class="s4"># o-s</span>

                            <span class="s4"># Add new list of cross pairs</span>
                            <span class="s1">ab_C.append((vp[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ab_v))</span>

        <span class="s4"># Clean class trash</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">C0x</span>
            <span class="s2">del </span><span class="s1">cC0x</span>
            <span class="s2">del </span><span class="s1">C1x</span>
            <span class="s2">del </span><span class="s1">cC1x</span>
            <span class="s2">del </span><span class="s1">ab_C</span>
            <span class="s2">del </span><span class="s1">ab_Cc</span>
        <span class="s2">except </span><span class="s1">UnboundLocalError:</span>
            <span class="s2">pass</span>

        <span class="s4"># Extra yield to ensure that the triangulation is completed</span>
        <span class="s2">if </span><span class="s1">centroid:</span>
            <span class="s1">vo = self.V[vot]</span>
            <span class="s1">vs = self.V[vut]</span>
            <span class="s4"># Disconnect the origin and supremum</span>
            <span class="s1">vo.disconnect(vs)</span>
            <span class="s4"># Build centroid</span>
            <span class="s1">vc = self.split_edge(vot</span><span class="s2">, </span><span class="s1">vut)</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vo.nn:</span>
                <span class="s1">v.connect(vc)</span>
            <span class="s2">yield </span><span class="s1">vc.x</span>
            <span class="s2">return </span><span class="s1">vc.x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">vut</span>
            <span class="s2">return </span><span class="s1">vut</span>

    <span class="s2">def </span><span class="s1">triangulate(self</span><span class="s2">, </span><span class="s1">n=</span><span class="s2">None, </span><span class="s1">symmetry=</span><span class="s2">None, </span><span class="s1">centroid=</span><span class="s2">True,</span>
                    <span class="s1">printout=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Triangulate the initial domain, if n is not None then a limited number 
        of points will be generated 
 
        Parameters 
        ---------- 
        n : int, Number of points to be sampled. 
        symmetry : 
 
            Ex. Dictionary/hashtable 
            f(x) = (x_1 + x_2 + x_3) + (x_4)**2 + (x_5)**2 + (x_6)**2 
 
            symmetry = symmetry[0]: 0,  # Variable 1 
                       symmetry[1]: 0,  # symmetric to variable 1 
                       symmetry[2]: 0,  # symmetric to variable 1 
                       symmetry[3]: 3,  # Variable 4 
                       symmetry[4]: 3,  # symmetric to variable 4 
                       symmetry[5]: 3,  # symmetric to variable 4 
                        } 
        centroid : bool, if True add a central point to the hypercube 
        printout : bool, if True print out results 
 
        NOTES: 
        ------ 
        Rather than using the combinatorial algorithm to connect vertices we 
        make the following observation: 
 
        The bound pairs are similar a C2 cyclic group and the structure is 
        formed using the cartesian product: 
 
        H = C2 x C2 x C2 ... x C2 (dim times) 
 
        So construct any normal subgroup N and consider H/N first, we connect 
        all vertices within N (ex. N is C2 (the first dimension), then we move 
        to a left coset aN (an operation moving around the defined H/N group by 
        for example moving from the lower bound in C2 (dimension 2) to the 
        higher bound in C2. During this operation connection all the vertices. 
        Now repeat the N connections. Note that these elements can be connected 
        in parrallel. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Inherit class arguments</span>
        <span class="s2">if </span><span class="s1">symmetry </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">symmetry = self.symmetry</span>
        <span class="s4"># Build origin and supremum vectors</span>
        <span class="s1">origin = [i[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.bounds]</span>
        <span class="s1">self.origin = origin</span>
        <span class="s1">supremum = [i[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.bounds]</span>

        <span class="s1">self.supremum = supremum</span>

        <span class="s2">if </span><span class="s1">symmetry </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">cbounds = self.bounds</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cbounds = copy.copy(self.bounds)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">enumerate(symmetry):</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s2">is not </span><span class="s1">j:</span>
                    <span class="s4"># pop second entry on second symmetry vars</span>
                    <span class="s1">cbounds[i] = [self.bounds[symmetry[i]][</span><span class="s3">0</span><span class="s1">]]</span>
                    <span class="s4"># Sole (first) entry is the sup value and there is no</span>
                    <span class="s4"># origin:</span>
                    <span class="s1">cbounds[i] = [self.bounds[symmetry[i]][</span><span class="s3">1</span><span class="s1">]]</span>
                    <span class="s2">if </span><span class="s1">(self.bounds[symmetry[i]] </span><span class="s2">is not</span>
                            <span class="s1">self.bounds[symmetry[j]]):</span>
                        <span class="s1">logging.warning(</span><span class="s5">f&quot;Variable </span><span class="s2">{</span><span class="s1">i</span><span class="s2">} </span><span class="s5">was specified as &quot;</span>
                                        <span class="s5">f&quot;symmetetric to variable </span><span class="s2">{</span><span class="s1">j</span><span class="s2">}</span><span class="s5">, however&quot;</span>
                                        <span class="s5">f&quot;, the bounds </span><span class="s2">{</span><span class="s1">i</span><span class="s2">} </span><span class="s5">=&quot;</span>
                                        <span class="s5">f&quot; </span><span class="s2">{</span><span class="s1">self.bounds[symmetry[i]]</span><span class="s2">} </span><span class="s5">and </span><span class="s2">{</span><span class="s1">j</span><span class="s2">}</span><span class="s5">&quot;</span>
                                        <span class="s5">f&quot; =&quot;</span>
                                        <span class="s5">f&quot; </span><span class="s2">{</span><span class="s1">self.bounds[symmetry[j]]</span><span class="s2">} </span><span class="s5">do not &quot;</span>
                                        <span class="s5">f&quot;match, the mismatch was ignored in &quot;</span>
                                        <span class="s5">f&quot;the initial triangulation.&quot;</span><span class="s1">)</span>
                        <span class="s1">cbounds[i] = self.bounds[symmetry[j]]</span>

        <span class="s2">if </span><span class="s1">n </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># Build generator</span>
            <span class="s1">self.cp = self.cyclic_product(cbounds</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">supremum</span><span class="s2">, </span><span class="s1">centroid)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.cp:</span>
                <span class="s1">i</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.triangulated_vectors.append((tuple(self.origin)</span><span class="s2">,</span>
                                                  <span class="s1">tuple(self.supremum)))</span>
            <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">KeyError):</span>
                <span class="s1">self.triangulated_vectors = [(tuple(self.origin)</span><span class="s2">,</span>
                                              <span class="s1">tuple(self.supremum))]</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Check if generator already exists</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.cp</span>
            <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">KeyError):</span>
                <span class="s1">self.cp = self.cyclic_product(cbounds</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">supremum</span><span class="s2">,</span>
                                              <span class="s1">centroid)</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">while </span><span class="s1">len(self.V.cache) &lt; n:</span>
                    <span class="s1">next(self.cp)</span>
            <span class="s2">except </span><span class="s1">StopIteration:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">self.triangulated_vectors.append((tuple(self.origin)</span><span class="s2">,</span>
                                                      <span class="s1">tuple(self.supremum)))</span>
                <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">KeyError):</span>
                    <span class="s1">self.triangulated_vectors = [(tuple(self.origin)</span><span class="s2">,</span>
                                                  <span class="s1">tuple(self.supremum))]</span>

        <span class="s2">if </span><span class="s1">printout:</span>
            <span class="s4"># for v in self.C0():</span>
            <span class="s4">#   v.print_out()</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.V.cache:</span>
                <span class="s1">self.V[v].print_out()</span>

        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">refine(self</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.triangulated_vectors</span>
                <span class="s1">self.refine_all()</span>
                <span class="s2">return</span>
            <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">ae:</span>
                <span class="s2">if </span><span class="s1">str(ae) == </span><span class="s5">&quot;'Complex' object has no attribute &quot; </span><span class="s1">\</span>
                              <span class="s5">&quot;'triangulated_vectors'&quot;</span><span class="s1">:</span>
                    <span class="s1">self.triangulate(symmetry=self.symmetry)</span>
                    <span class="s2">return</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise</span>

        <span class="s1">nt = len(self.V.cache) + n  </span><span class="s4"># Target number of total vertices</span>
        <span class="s4"># In the outer while loop we iterate until we have added an extra `n`</span>
        <span class="s4"># vertices to the complex:</span>
        <span class="s2">while </span><span class="s1">len(self.V.cache) &lt; nt:  </span><span class="s4"># while loop 1</span>
            <span class="s2">try</span><span class="s1">:  </span><span class="s4"># try 1</span>
                <span class="s4"># Try to access triangulated_vectors, this should only be</span>
                <span class="s4"># defined if an initial triangulation has already been</span>
                <span class="s4"># performed:</span>
                <span class="s1">self.triangulated_vectors</span>
                <span class="s4"># Try a usual iteration of the current generator, if it</span>
                <span class="s4"># does not exist or is exhausted then produce a new generator</span>
                <span class="s2">try</span><span class="s1">:  </span><span class="s4"># try 2</span>
                    <span class="s1">next(self.rls)</span>
                <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">StopIteration</span><span class="s2">, </span><span class="s1">KeyError):</span>
                    <span class="s1">vp = self.triangulated_vectors[</span><span class="s3">0</span><span class="s1">]</span>
                    <span class="s1">self.rls = self.refine_local_space(*vp</span><span class="s2">, </span><span class="s1">bounds=self.bounds)</span>
                    <span class="s1">next(self.rls)</span>

            <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">KeyError):</span>
                <span class="s4"># If an initial triangulation has not been completed, then</span>
                <span class="s4"># we start/continue the initial triangulation targeting `nt`</span>
                <span class="s4"># vertices, if nt is greater than the initial number of</span>
                <span class="s4"># vertices then the `refine` routine will move back to try 1.</span>
                <span class="s1">self.triangulate(nt</span><span class="s2">, </span><span class="s1">self.symmetry)</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">refine_all(self</span><span class="s2">, </span><span class="s1">centroids=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Refine the entire domain of the current complex.&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.triangulated_vectors</span>
            <span class="s1">tvs = copy.copy(self.triangulated_vectors)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">vp </span><span class="s2">in </span><span class="s1">enumerate(tvs):</span>
                <span class="s1">self.rls = self.refine_local_space(*vp</span><span class="s2">, </span><span class="s1">bounds=self.bounds)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.rls:</span>
                    <span class="s1">i</span>
        <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">ae:</span>
            <span class="s2">if </span><span class="s1">str(ae) == </span><span class="s5">&quot;'Complex' object has no attribute &quot; </span><span class="s1">\</span>
                          <span class="s5">&quot;'triangulated_vectors'&quot;</span><span class="s1">:</span>
                <span class="s1">self.triangulate(symmetry=self.symmetry</span><span class="s2">, </span><span class="s1">centroid=centroids)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise</span>

        <span class="s4"># This adds a centroid to every new sub-domain generated and defined</span>
        <span class="s4"># by self.triangulated_vectors, in addition the vertices ! to complete</span>
        <span class="s4"># the triangulation</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">refine_local_space(self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">supremum</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">centroid=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s4"># Copy for later removal</span>
        <span class="s1">origin_c = copy.copy(origin)</span>
        <span class="s1">supremum_c = copy.copy(supremum)</span>

        <span class="s4"># Initiate local variables redefined in later inner `for` loop:</span>
        <span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">a_vu = </span><span class="s2">None, None, None</span>

        <span class="s4"># Change the vector orientation so that it is only increasing</span>
        <span class="s1">s_ov = list(origin)</span>
        <span class="s1">s_origin = list(origin)</span>
        <span class="s1">s_sv = list(supremum)</span>
        <span class="s1">s_supremum = list(supremum)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">vi </span><span class="s2">in </span><span class="s1">enumerate(s_origin):</span>
            <span class="s2">if </span><span class="s1">s_ov[i] &gt; s_sv[i]:</span>
                <span class="s1">s_origin[i] = s_sv[i]</span>
                <span class="s1">s_supremum[i] = s_ov[i]</span>

        <span class="s1">vot = tuple(s_origin)</span>
        <span class="s1">vut = tuple(s_supremum)  </span><span class="s4"># Hyperrectangle supremum</span>

        <span class="s1">vo = self.V[vot]  </span><span class="s4"># initiate if doesn't exist yet</span>
        <span class="s1">vs = self.V[vut]</span>
        <span class="s4"># Start by finding the old centroid of the new space:</span>
        <span class="s1">vco = self.split_edge(vo.x</span><span class="s2">, </span><span class="s1">vs.x)  </span><span class="s4"># Split in case not centroid arg</span>

        <span class="s4"># Find set of extreme vertices in current local space</span>
        <span class="s1">sup_set = copy.copy(vco.nn)</span>
        <span class="s4"># Cyclic group approach with second x_l --- x_u operation.</span>

        <span class="s4"># These containers store the &quot;lower&quot; and &quot;upper&quot; vertices</span>
        <span class="s4"># corresponding to the origin or supremum of every C2 group.</span>
        <span class="s4"># It has the structure of `dim` times embedded lists each containing</span>
        <span class="s4"># these vertices as the entire complex grows. Bounds[0] has to be done</span>
        <span class="s4"># outside the loops before we have symmetric containers.</span>
        <span class="s4"># NOTE: This means that bounds[0][1] must always exist</span>

        <span class="s1">a_vl = copy.copy(list(vot))</span>
        <span class="s1">a_vl[</span><span class="s3">0</span><span class="s1">] = vut[</span><span class="s3">0</span><span class="s1">]  </span><span class="s4"># Update aN Origin</span>
        <span class="s2">if </span><span class="s1">tuple(a_vl) </span><span class="s2">not in </span><span class="s1">self.V.cache:</span>
            <span class="s1">vo = self.V[vot]  </span><span class="s4"># initiate if doesn't exist yet</span>
            <span class="s1">vs = self.V[vut]</span>
            <span class="s4"># Start by finding the old centroid of the new space:</span>
            <span class="s1">vco = self.split_edge(vo.x</span><span class="s2">, </span><span class="s1">vs.x)  </span><span class="s4"># Split in case not centroid arg</span>

            <span class="s4"># Find set of extreme vertices in current local space</span>
            <span class="s1">sup_set = copy.copy(vco.nn)</span>
            <span class="s1">a_vl = copy.copy(list(vot))</span>
            <span class="s1">a_vl[</span><span class="s3">0</span><span class="s1">] = vut[</span><span class="s3">0</span><span class="s1">]  </span><span class="s4"># Update aN Origin</span>
            <span class="s1">a_vl = self.V[tuple(a_vl)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">a_vl = self.V[tuple(a_vl)]</span>

        <span class="s1">c_v = self.split_edge(vo.x</span><span class="s2">, </span><span class="s1">a_vl.x)</span>
        <span class="s1">c_v.connect(vco)</span>
        <span class="s2">yield </span><span class="s1">c_v.x</span>
        <span class="s1">Cox = [[vo]]</span>
        <span class="s1">Ccx = [[c_v]]</span>
        <span class="s1">Cux = [[a_vl]]</span>
        <span class="s1">ab_C = []  </span><span class="s4"># Container for a + b operations</span>
        <span class="s1">s_ab_C = []  </span><span class="s4"># Container for symmetric a + b operations</span>

        <span class="s4"># Loop over remaining bounds</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(bounds[</span><span class="s3">1</span><span class="s1">:]):</span>
            <span class="s4"># Update lower and upper containers</span>
            <span class="s1">Cox.append([])</span>
            <span class="s1">Ccx.append([])</span>
            <span class="s1">Cux.append([])</span>
            <span class="s4"># try to access a second bound (if not, C1 is symmetric)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">t_a_vl = list(vot)</span>
                <span class="s1">t_a_vl[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>

                <span class="s4"># New: lists are used anyway, so copy all</span>
                <span class="s4"># %%</span>
                <span class="s4"># Copy lists for iteration</span>
                <span class="s1">cCox = [x[:] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">Cox[:i + </span><span class="s3">1</span><span class="s1">]]</span>
                <span class="s1">cCcx = [x[:] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">Ccx[:i + </span><span class="s3">1</span><span class="s1">]]</span>
                <span class="s1">cCux = [x[:] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">Cux[:i + </span><span class="s3">1</span><span class="s1">]]</span>
                <span class="s4"># Try to connect aN lower source of previous a + b</span>
                <span class="s4"># operation with a aN vertex</span>
                <span class="s1">ab_Cc = copy.copy(ab_C)  </span><span class="s4"># NOTE: We append ab_C in the</span>
                <span class="s4"># (VL, VC, VU) for-loop, but we use the copy of the list in the</span>
                <span class="s4"># ab_Cc for-loop.</span>
                <span class="s1">s_ab_Cc = copy.copy(s_ab_C)</span>

                <span class="s4"># Early try so that we don't have to copy the cache before</span>
                <span class="s4"># moving on to next C1/C2: Try to add the operation of a new</span>
                <span class="s4"># C2 product by accessing the upper bound</span>
                <span class="s2">if </span><span class="s1">tuple(t_a_vl) </span><span class="s2">not in </span><span class="s1">self.V.cache:</span>
                    <span class="s4"># Raise error to continue symmetric refine</span>
                    <span class="s2">raise </span><span class="s1">IndexError</span>
                <span class="s1">t_a_vu = list(vut)</span>
                <span class="s1">t_a_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">tuple(t_a_vu) </span><span class="s2">not in </span><span class="s1">self.V.cache:</span>
                    <span class="s4"># Raise error to continue symmetric refine:</span>
                    <span class="s2">raise </span><span class="s1">IndexError</span>

                <span class="s2">for </span><span class="s1">vectors </span><span class="s2">in </span><span class="s1">s_ab_Cc:</span>
                    <span class="s4"># s_ab_C.append([c_vc, vl, vu, a_vu])</span>
                    <span class="s1">bc_vc = list(vectors[</span><span class="s3">0</span><span class="s1">].x)</span>
                    <span class="s1">b_vl = list(vectors[</span><span class="s3">1</span><span class="s1">].x)</span>
                    <span class="s1">b_vu = list(vectors[</span><span class="s3">2</span><span class="s1">].x)</span>
                    <span class="s1">ba_vu = list(vectors[</span><span class="s3">3</span><span class="s1">].x)</span>

                    <span class="s1">bc_vc[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">b_vl[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">b_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">ba_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>

                    <span class="s1">bc_vc = self.V[tuple(bc_vc)]</span>
                    <span class="s1">bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s2">yield </span><span class="s1">bc_vc</span>

                    <span class="s4"># Split to centre, call this centre group &quot;d = 0.5*a&quot;</span>
                    <span class="s1">d_bc_vc = self.split_edge(vectors[</span><span class="s3">0</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">bc_vc.x)</span>
                    <span class="s1">d_bc_vc.connect(bc_vc)</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">1</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">2</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">3</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s2">yield </span><span class="s1">d_bc_vc.x</span>
                    <span class="s1">b_vl = self.V[tuple(b_vl)]</span>
                    <span class="s1">bc_vc.connect(b_vl)  </span><span class="s4"># Connect aN cross pairs</span>
                    <span class="s1">d_bc_vc.connect(b_vl)  </span><span class="s4"># Connect all to centroid</span>

                    <span class="s2">yield </span><span class="s1">b_vl</span>
                    <span class="s1">b_vu = self.V[tuple(b_vu)]</span>
                    <span class="s1">bc_vc.connect(b_vu)  </span><span class="s4"># Connect aN cross pairs</span>
                    <span class="s1">d_bc_vc.connect(b_vu)  </span><span class="s4"># Connect all to centroid</span>

                    <span class="s1">b_vl_c = self.split_edge(b_vu.x</span><span class="s2">, </span><span class="s1">b_vl.x)</span>
                    <span class="s1">bc_vc.connect(b_vl_c)</span>

                    <span class="s2">yield </span><span class="s1">b_vu</span>
                    <span class="s1">ba_vu = self.V[tuple(ba_vu)]</span>
                    <span class="s1">bc_vc.connect(ba_vu)  </span><span class="s4"># Connect aN cross pairs</span>
                    <span class="s1">d_bc_vc.connect(ba_vu)  </span><span class="s4"># Connect all to centroid</span>

                    <span class="s4"># Split the a + b edge of the initial triangulation:</span>
                    <span class="s1">os_v = self.split_edge(vectors[</span><span class="s3">1</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">ba_vu.x)  </span><span class="s4"># o-s</span>
                    <span class="s1">ss_v = self.split_edge(b_vl.x</span><span class="s2">, </span><span class="s1">ba_vu.x)  </span><span class="s4"># s-s</span>
                    <span class="s1">b_vu_c = self.split_edge(b_vu.x</span><span class="s2">, </span><span class="s1">ba_vu.x)</span>
                    <span class="s1">bc_vc.connect(b_vu_c)</span>
                    <span class="s2">yield </span><span class="s1">os_v.x  </span><span class="s4"># often equal to vco, but not always</span>
                    <span class="s2">yield </span><span class="s1">ss_v.x  </span><span class="s4"># often equal to bc_vu, but not always</span>
                    <span class="s2">yield </span><span class="s1">ba_vu</span>
                    <span class="s4"># Split remaining to centre, call this centre group</span>
                    <span class="s4"># &quot;d = 0.5*a&quot;</span>
                    <span class="s1">d_bc_vc = self.split_edge(vectors[</span><span class="s3">0</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">bc_vc.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s2">yield </span><span class="s1">d_bc_vc.x</span>
                    <span class="s1">d_b_vl = self.split_edge(vectors[</span><span class="s3">1</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">b_vl.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s1">d_bc_vc.connect(d_b_vl)  </span><span class="s4"># Connect dN cross pairs</span>
                    <span class="s2">yield </span><span class="s1">d_b_vl.x</span>
                    <span class="s1">d_b_vu = self.split_edge(vectors[</span><span class="s3">2</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">b_vu.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s1">d_bc_vc.connect(d_b_vu)  </span><span class="s4"># Connect dN cross pairs</span>
                    <span class="s2">yield </span><span class="s1">d_b_vu.x</span>
                    <span class="s1">d_ba_vu = self.split_edge(vectors[</span><span class="s3">3</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">ba_vu.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s1">d_bc_vc.connect(d_ba_vu)  </span><span class="s4"># Connect dN cross pairs</span>
                    <span class="s2">yield </span><span class="s1">d_ba_vu</span>

                    <span class="s4"># comb = [c_vc, vl, vu, a_vl, a_vu,</span>
                    <span class="s4">#       bc_vc, b_vl, b_vu, ba_vl, ba_vu]</span>
                    <span class="s1">comb = [vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">a_vu</span><span class="s2">,</span>
                            <span class="s1">b_vl</span><span class="s2">, </span><span class="s1">b_vu</span><span class="s2">, </span><span class="s1">ba_vu]</span>
                    <span class="s1">comb_iter = itertools.combinations(comb</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">vecs </span><span class="s2">in </span><span class="s1">comb_iter:</span>
                        <span class="s1">self.split_edge(vecs[</span><span class="s3">0</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">vecs[</span><span class="s3">1</span><span class="s1">].x)</span>
                    <span class="s4"># Add new list of cross pairs</span>
                    <span class="s1">ab_C.append((d_bc_vc</span><span class="s2">, </span><span class="s1">vectors[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b_vl</span><span class="s2">, </span><span class="s1">a_vu</span><span class="s2">, </span><span class="s1">ba_vu))</span>
                    <span class="s1">ab_C.append((d_bc_vc</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">b_vl</span><span class="s2">, </span><span class="s1">a_vu</span><span class="s2">, </span><span class="s1">ba_vu))  </span><span class="s4"># = prev</span>

                <span class="s2">for </span><span class="s1">vectors </span><span class="s2">in </span><span class="s1">ab_Cc:</span>
                    <span class="s1">bc_vc = list(vectors[</span><span class="s3">0</span><span class="s1">].x)</span>
                    <span class="s1">b_vl = list(vectors[</span><span class="s3">1</span><span class="s1">].x)</span>
                    <span class="s1">b_vu = list(vectors[</span><span class="s3">2</span><span class="s1">].x)</span>
                    <span class="s1">ba_vl = list(vectors[</span><span class="s3">3</span><span class="s1">].x)</span>
                    <span class="s1">ba_vu = list(vectors[</span><span class="s3">4</span><span class="s1">].x)</span>
                    <span class="s1">bc_vc[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">b_vl[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">b_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">ba_vl[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">ba_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">bc_vc = self.V[tuple(bc_vc)]</span>
                    <span class="s1">bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s2">yield </span><span class="s1">bc_vc</span>

                    <span class="s4"># Split to centre, call this centre group &quot;d = 0.5*a&quot;</span>
                    <span class="s1">d_bc_vc = self.split_edge(vectors[</span><span class="s3">0</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">bc_vc.x)</span>
                    <span class="s1">d_bc_vc.connect(bc_vc)</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">1</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">2</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">3</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">4</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s2">yield </span><span class="s1">d_bc_vc.x</span>
                    <span class="s1">b_vl = self.V[tuple(b_vl)]</span>
                    <span class="s1">bc_vc.connect(b_vl)  </span><span class="s4"># Connect aN cross pairs</span>
                    <span class="s1">d_bc_vc.connect(b_vl)  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s2">yield </span><span class="s1">b_vl</span>
                    <span class="s1">b_vu = self.V[tuple(b_vu)]</span>
                    <span class="s1">bc_vc.connect(b_vu)  </span><span class="s4"># Connect aN cross pairs</span>
                    <span class="s1">d_bc_vc.connect(b_vu)  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s2">yield </span><span class="s1">b_vu</span>
                    <span class="s1">ba_vl = self.V[tuple(ba_vl)]</span>
                    <span class="s1">bc_vc.connect(ba_vl)  </span><span class="s4"># Connect aN cross pairs</span>
                    <span class="s1">d_bc_vc.connect(ba_vl)  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">self.split_edge(b_vu.x</span><span class="s2">, </span><span class="s1">ba_vl.x)</span>
                    <span class="s2">yield </span><span class="s1">ba_vl</span>
                    <span class="s1">ba_vu = self.V[tuple(ba_vu)]</span>
                    <span class="s1">bc_vc.connect(ba_vu)  </span><span class="s4"># Connect aN cross pairs</span>
                    <span class="s1">d_bc_vc.connect(ba_vu)  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s4"># Split the a + b edge of the initial triangulation:</span>
                    <span class="s1">os_v = self.split_edge(vectors[</span><span class="s3">1</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">ba_vu.x)  </span><span class="s4"># o-s</span>
                    <span class="s1">ss_v = self.split_edge(b_vl.x</span><span class="s2">, </span><span class="s1">ba_vu.x)  </span><span class="s4"># s-s</span>
                    <span class="s2">yield </span><span class="s1">os_v.x  </span><span class="s4"># often equal to vco, but not always</span>
                    <span class="s2">yield </span><span class="s1">ss_v.x  </span><span class="s4"># often equal to bc_vu, but not always</span>
                    <span class="s2">yield </span><span class="s1">ba_vu</span>
                    <span class="s4"># Split remaining to centre, call this centre group</span>
                    <span class="s4"># &quot;d = 0.5*a&quot;</span>
                    <span class="s1">d_bc_vc = self.split_edge(vectors[</span><span class="s3">0</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">bc_vc.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s2">yield </span><span class="s1">d_bc_vc.x</span>
                    <span class="s1">d_b_vl = self.split_edge(vectors[</span><span class="s3">1</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">b_vl.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s1">d_bc_vc.connect(d_b_vl)  </span><span class="s4"># Connect dN cross pairs</span>
                    <span class="s2">yield </span><span class="s1">d_b_vl.x</span>
                    <span class="s1">d_b_vu = self.split_edge(vectors[</span><span class="s3">2</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">b_vu.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s1">d_bc_vc.connect(d_b_vu)  </span><span class="s4"># Connect dN cross pairs</span>
                    <span class="s2">yield </span><span class="s1">d_b_vu.x</span>
                    <span class="s1">d_ba_vl = self.split_edge(vectors[</span><span class="s3">3</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">ba_vl.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s1">d_bc_vc.connect(d_ba_vl)  </span><span class="s4"># Connect dN cross pairs</span>
                    <span class="s2">yield </span><span class="s1">d_ba_vl</span>
                    <span class="s1">d_ba_vu = self.split_edge(vectors[</span><span class="s3">4</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">ba_vu.x)</span>
                    <span class="s1">d_bc_vc.connect(vco)  </span><span class="s4"># NOTE: Unneeded?</span>
                    <span class="s1">d_bc_vc.connect(d_ba_vu)  </span><span class="s4"># Connect dN cross pairs</span>
                    <span class="s2">yield </span><span class="s1">d_ba_vu</span>
                    <span class="s1">c_vc</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">a_vl</span><span class="s2">, </span><span class="s1">a_vu = vectors</span>

                    <span class="s1">comb = [vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">a_vl</span><span class="s2">, </span><span class="s1">a_vu</span><span class="s2">,</span>
                            <span class="s1">b_vl</span><span class="s2">, </span><span class="s1">b_vu</span><span class="s2">, </span><span class="s1">ba_vl</span><span class="s2">, </span><span class="s1">ba_vu]</span>
                    <span class="s1">comb_iter = itertools.combinations(comb</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">vecs </span><span class="s2">in </span><span class="s1">comb_iter:</span>
                        <span class="s1">self.split_edge(vecs[</span><span class="s3">0</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">vecs[</span><span class="s3">1</span><span class="s1">].x)</span>

                    <span class="s4"># Add new list of cross pairs</span>
                    <span class="s1">ab_C.append((bc_vc</span><span class="s2">, </span><span class="s1">b_vl</span><span class="s2">, </span><span class="s1">b_vu</span><span class="s2">, </span><span class="s1">ba_vl</span><span class="s2">, </span><span class="s1">ba_vu))</span>
                    <span class="s1">ab_C.append((d_bc_vc</span><span class="s2">, </span><span class="s1">d_b_vl</span><span class="s2">, </span><span class="s1">d_b_vu</span><span class="s2">, </span><span class="s1">d_ba_vl</span><span class="s2">, </span><span class="s1">d_ba_vu))</span>
                    <span class="s1">ab_C.append((d_bc_vc</span><span class="s2">, </span><span class="s1">vectors[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b_vl</span><span class="s2">, </span><span class="s1">a_vu</span><span class="s2">, </span><span class="s1">ba_vu))</span>
                    <span class="s1">ab_C.append((d_bc_vc</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">b_vu</span><span class="s2">, </span><span class="s1">a_vl</span><span class="s2">, </span><span class="s1">ba_vl))</span>

                <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">(VL</span><span class="s2">, </span><span class="s1">VC</span><span class="s2">, </span><span class="s1">VU) </span><span class="s2">in </span><span class="s1">enumerate(zip(cCox</span><span class="s2">, </span><span class="s1">cCcx</span><span class="s2">, </span><span class="s1">cCux)):</span>
                    <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">(vl</span><span class="s2">, </span><span class="s1">vc</span><span class="s2">, </span><span class="s1">vu) </span><span class="s2">in </span><span class="s1">enumerate(zip(VL</span><span class="s2">, </span><span class="s1">VC</span><span class="s2">, </span><span class="s1">VU)):</span>
                        <span class="s4"># Build aN vertices for each lower-upper C3 group in N:</span>
                        <span class="s1">a_vl = list(vl.x)</span>
                        <span class="s1">a_vu = list(vu.x)</span>
                        <span class="s1">a_vl[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                        <span class="s1">a_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                        <span class="s1">a_vl = self.V[tuple(a_vl)]</span>
                        <span class="s1">a_vu = self.V[tuple(a_vu)]</span>
                        <span class="s4"># Note, build (a + vc) later for consistent yields</span>
                        <span class="s4"># Split the a + b edge of the initial triangulation:</span>
                        <span class="s1">c_vc = self.split_edge(vl.x</span><span class="s2">, </span><span class="s1">a_vu.x)</span>
                        <span class="s1">self.split_edge(vl.x</span><span class="s2">, </span><span class="s1">vu.x)  </span><span class="s4"># Equal to vc</span>
                        <span class="s4"># Build cN vertices for each lower-upper C3 group in N:</span>
                        <span class="s1">c_vc.connect(vco)</span>
                        <span class="s1">c_vc.connect(vc)</span>
                        <span class="s1">c_vc.connect(vl)  </span><span class="s4"># Connect c + ac operations</span>
                        <span class="s1">c_vc.connect(vu)  </span><span class="s4"># Connect c + ac operations</span>
                        <span class="s1">c_vc.connect(a_vl)  </span><span class="s4"># Connect c + ac operations</span>
                        <span class="s1">c_vc.connect(a_vu)  </span><span class="s4"># Connect c + ac operations</span>
                        <span class="s2">yield </span><span class="s1">c_vc.x</span>
                        <span class="s1">c_vl = self.split_edge(vl.x</span><span class="s2">, </span><span class="s1">a_vl.x)</span>
                        <span class="s1">c_vl.connect(vco)</span>
                        <span class="s1">c_vc.connect(c_vl)  </span><span class="s4"># Connect cN group vertices</span>
                        <span class="s2">yield </span><span class="s1">c_vl.x</span>
                        <span class="s4"># yield at end of loop:</span>
                        <span class="s1">c_vu = self.split_edge(vu.x</span><span class="s2">, </span><span class="s1">a_vu.x)</span>
                        <span class="s1">c_vu.connect(vco)</span>
                        <span class="s4"># Connect remaining cN group vertices</span>
                        <span class="s1">c_vc.connect(c_vu)  </span><span class="s4"># Connect cN group vertices</span>
                        <span class="s2">yield </span><span class="s1">c_vu.x</span>

                        <span class="s1">a_vc = self.split_edge(a_vl.x</span><span class="s2">, </span><span class="s1">a_vu.x)  </span><span class="s4"># is (a + vc) ?</span>
                        <span class="s1">a_vc.connect(vco)</span>
                        <span class="s1">a_vc.connect(c_vc)</span>

                        <span class="s4"># Storage for connecting c + ac operations:</span>
                        <span class="s1">ab_C.append((c_vc</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">a_vl</span><span class="s2">, </span><span class="s1">a_vu))</span>

                        <span class="s4"># Update the containers</span>
                        <span class="s1">Cox[i + </span><span class="s3">1</span><span class="s1">].append(vl)</span>
                        <span class="s1">Cox[i + </span><span class="s3">1</span><span class="s1">].append(vc)</span>
                        <span class="s1">Cox[i + </span><span class="s3">1</span><span class="s1">].append(vu)</span>
                        <span class="s1">Ccx[i + </span><span class="s3">1</span><span class="s1">].append(c_vl)</span>
                        <span class="s1">Ccx[i + </span><span class="s3">1</span><span class="s1">].append(c_vc)</span>
                        <span class="s1">Ccx[i + </span><span class="s3">1</span><span class="s1">].append(c_vu)</span>
                        <span class="s1">Cux[i + </span><span class="s3">1</span><span class="s1">].append(a_vl)</span>
                        <span class="s1">Cux[i + </span><span class="s3">1</span><span class="s1">].append(a_vc)</span>
                        <span class="s1">Cux[i + </span><span class="s3">1</span><span class="s1">].append(a_vu)</span>

                        <span class="s4"># Update old containers</span>
                        <span class="s1">Cox[j].append(c_vl)  </span><span class="s4"># !</span>
                        <span class="s1">Cox[j].append(a_vl)</span>
                        <span class="s1">Ccx[j].append(c_vc)  </span><span class="s4"># !</span>
                        <span class="s1">Ccx[j].append(a_vc)  </span><span class="s4"># !</span>
                        <span class="s1">Cux[j].append(c_vu)  </span><span class="s4"># !</span>
                        <span class="s1">Cux[j].append(a_vu)</span>

                        <span class="s4"># Yield new points</span>
                        <span class="s2">yield </span><span class="s1">a_vc.x</span>

            <span class="s2">except </span><span class="s1">IndexError:</span>
                <span class="s2">for </span><span class="s1">vectors </span><span class="s2">in </span><span class="s1">ab_Cc:</span>
                    <span class="s1">ba_vl = list(vectors[</span><span class="s3">3</span><span class="s1">].x)</span>
                    <span class="s1">ba_vu = list(vectors[</span><span class="s3">4</span><span class="s1">].x)</span>
                    <span class="s1">ba_vl[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">ba_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">ba_vu = self.V[tuple(ba_vu)]</span>
                    <span class="s2">yield </span><span class="s1">ba_vu</span>
                    <span class="s1">d_bc_vc = self.split_edge(vectors[</span><span class="s3">1</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">ba_vu.x)  </span><span class="s4"># o-s</span>
                    <span class="s2">yield </span><span class="s1">ba_vu</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">1</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">2</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">3</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s1">d_bc_vc.connect(vectors[</span><span class="s3">4</span><span class="s1">])  </span><span class="s4"># Connect all to centroid</span>
                    <span class="s2">yield </span><span class="s1">d_bc_vc.x</span>
                    <span class="s1">ba_vl = self.V[tuple(ba_vl)]</span>
                    <span class="s2">yield </span><span class="s1">ba_vl</span>
                    <span class="s1">d_ba_vl = self.split_edge(vectors[</span><span class="s3">3</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">ba_vl.x)</span>
                    <span class="s1">d_ba_vu = self.split_edge(vectors[</span><span class="s3">4</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">ba_vu.x)</span>
                    <span class="s1">d_ba_vc = self.split_edge(d_ba_vl.x</span><span class="s2">, </span><span class="s1">d_ba_vu.x)</span>
                    <span class="s2">yield </span><span class="s1">d_ba_vl</span>
                    <span class="s2">yield </span><span class="s1">d_ba_vu</span>
                    <span class="s2">yield </span><span class="s1">d_ba_vc</span>
                    <span class="s1">c_vc</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">a_vl</span><span class="s2">, </span><span class="s1">a_vu = vectors</span>
                    <span class="s1">comb = [vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">a_vl</span><span class="s2">, </span><span class="s1">a_vu</span><span class="s2">,</span>
                            <span class="s1">ba_vl</span><span class="s2">,</span>
                            <span class="s1">ba_vu]</span>
                    <span class="s1">comb_iter = itertools.combinations(comb</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">vecs </span><span class="s2">in </span><span class="s1">comb_iter:</span>
                        <span class="s1">self.split_edge(vecs[</span><span class="s3">0</span><span class="s1">].x</span><span class="s2">, </span><span class="s1">vecs[</span><span class="s3">1</span><span class="s1">].x)</span>

                <span class="s4"># Copy lists for iteration</span>
                <span class="s1">cCox = Cox[i]</span>
                <span class="s1">cCcx = Ccx[i]</span>
                <span class="s1">cCux = Cux[i]</span>
                <span class="s1">VL</span><span class="s2">, </span><span class="s1">VC</span><span class="s2">, </span><span class="s1">VU = cCox</span><span class="s2">, </span><span class="s1">cCcx</span><span class="s2">, </span><span class="s1">cCux</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">(vl</span><span class="s2">, </span><span class="s1">vc</span><span class="s2">, </span><span class="s1">vu) </span><span class="s2">in </span><span class="s1">enumerate(zip(VL</span><span class="s2">, </span><span class="s1">VC</span><span class="s2">, </span><span class="s1">VU)):</span>
                    <span class="s4"># Build aN vertices for each lower-upper pair in N:</span>
                    <span class="s1">a_vu = list(vu.x)</span>
                    <span class="s1">a_vu[i + </span><span class="s3">1</span><span class="s1">] = vut[i + </span><span class="s3">1</span><span class="s1">]</span>

                    <span class="s4"># Connect vertices in N to corresponding vertices</span>
                    <span class="s4"># in aN:</span>
                    <span class="s1">a_vu = self.V[tuple(a_vu)]</span>
                    <span class="s2">yield </span><span class="s1">a_vl.x</span>
                    <span class="s4"># Split the a + b edge of the initial triangulation:</span>
                    <span class="s1">c_vc = self.split_edge(vl.x</span><span class="s2">, </span><span class="s1">a_vu.x)</span>
                    <span class="s1">self.split_edge(vl.x</span><span class="s2">, </span><span class="s1">vu.x)  </span><span class="s4"># Equal to vc</span>
                    <span class="s1">c_vc.connect(vco)</span>
                    <span class="s1">c_vc.connect(vc)</span>
                    <span class="s1">c_vc.connect(vl)  </span><span class="s4"># Connect c + ac operations</span>
                    <span class="s1">c_vc.connect(vu)  </span><span class="s4"># Connect c + ac operations</span>
                    <span class="s1">c_vc.connect(a_vu)  </span><span class="s4"># Connect c + ac operations</span>
                    <span class="s2">yield </span><span class="s1">(c_vc.x)</span>
                    <span class="s1">c_vu = self.split_edge(vu.x</span><span class="s2">,</span>
                                           <span class="s1">a_vu.x)  </span><span class="s4"># yield at end of loop</span>
                    <span class="s1">c_vu.connect(vco)</span>
                    <span class="s4"># Connect remaining cN group vertices</span>
                    <span class="s1">c_vc.connect(c_vu)  </span><span class="s4"># Connect cN group vertices</span>
                    <span class="s2">yield </span><span class="s1">(c_vu.x)</span>

                    <span class="s4"># Update the containers</span>
                    <span class="s1">Cox[i + </span><span class="s3">1</span><span class="s1">].append(vu)</span>
                    <span class="s1">Ccx[i + </span><span class="s3">1</span><span class="s1">].append(c_vu)</span>
                    <span class="s1">Cux[i + </span><span class="s3">1</span><span class="s1">].append(a_vu)</span>

                    <span class="s4"># Update old containers</span>
                    <span class="s1">s_ab_C.append([c_vc</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">a_vu])</span>

                    <span class="s2">yield </span><span class="s1">a_vu.x</span>

        <span class="s4"># Clean class trash</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">Cox</span>
            <span class="s2">del </span><span class="s1">Ccx</span>
            <span class="s2">del </span><span class="s1">Cux</span>
            <span class="s2">del </span><span class="s1">ab_C</span>
            <span class="s2">del </span><span class="s1">ab_Cc</span>
        <span class="s2">except </span><span class="s1">UnboundLocalError:</span>
            <span class="s2">pass</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.triangulated_vectors.remove((tuple(origin_c)</span><span class="s2">,</span>
                                              <span class="s1">tuple(supremum_c)))</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s4"># Turn this into a logging warning?</span>
            <span class="s2">pass</span>
        <span class="s4"># Add newly triangulated vectors:</span>
        <span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">sup_set:</span>
            <span class="s1">self.triangulated_vectors.append((tuple(vco.x)</span><span class="s2">, </span><span class="s1">tuple(vs.x)))</span>

        <span class="s4"># Extra yield to ensure that the triangulation is completed</span>
        <span class="s2">if </span><span class="s1">centroid:</span>
            <span class="s1">vcn_set = set()</span>
            <span class="s1">c_nn_lists = []</span>
            <span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">sup_set:</span>
                <span class="s4"># Build centroid</span>
                <span class="s1">c_nn = self.vpool(vco.x</span><span class="s2">, </span><span class="s1">vs.x)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">c_nn.remove(vcn_set)</span>
                <span class="s2">except </span><span class="s1">KeyError:</span>
                    <span class="s2">pass</span>
                <span class="s1">c_nn_lists.append(c_nn)</span>

            <span class="s2">for </span><span class="s1">c_nn </span><span class="s2">in </span><span class="s1">c_nn_lists:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">c_nn.remove(vcn_set)</span>
                <span class="s2">except </span><span class="s1">KeyError:</span>
                    <span class="s2">pass</span>

            <span class="s2">for </span><span class="s1">vs</span><span class="s2">, </span><span class="s1">c_nn </span><span class="s2">in </span><span class="s1">zip(sup_set</span><span class="s2">, </span><span class="s1">c_nn_lists):</span>
                <span class="s4"># Build centroid</span>
                <span class="s1">vcn = self.split_edge(vco.x</span><span class="s2">, </span><span class="s1">vs.x)</span>
                <span class="s1">vcn_set.add(vcn)</span>
                <span class="s2">try</span><span class="s1">:  </span><span class="s4"># Shouldn't be needed?</span>
                    <span class="s1">c_nn.remove(vcn_set)</span>
                <span class="s2">except </span><span class="s1">KeyError:</span>
                    <span class="s2">pass</span>
                <span class="s2">for </span><span class="s1">vnn </span><span class="s2">in </span><span class="s1">c_nn:</span>
                    <span class="s1">vcn.connect(vnn)</span>
                <span class="s2">yield </span><span class="s1">vcn.x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">pass</span>

        <span class="s2">yield </span><span class="s1">vut</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">refine_star(self</span><span class="s2">, </span><span class="s1">v):</span>
        <span class="s0">&quot;&quot;&quot;Refine the star domain of a vertex `v`.&quot;&quot;&quot;</span>
        <span class="s4"># Copy lists before iteration</span>
        <span class="s1">vnn = copy.copy(v.nn)</span>
        <span class="s1">v1nn = []</span>
        <span class="s1">d_v0v1_set = set()</span>
        <span class="s2">for </span><span class="s1">v1 </span><span class="s2">in </span><span class="s1">vnn:</span>
            <span class="s1">v1nn.append(copy.copy(v1.nn))</span>

        <span class="s2">for </span><span class="s1">v1</span><span class="s2">, </span><span class="s1">v1nn </span><span class="s2">in </span><span class="s1">zip(vnn</span><span class="s2">, </span><span class="s1">v1nn):</span>
            <span class="s1">vnnu = v1nn.intersection(vnn)</span>

            <span class="s1">d_v0v1 = self.split_edge(v.x</span><span class="s2">, </span><span class="s1">v1.x)</span>
            <span class="s2">for </span><span class="s1">o_d_v0v1 </span><span class="s2">in </span><span class="s1">d_v0v1_set:</span>
                <span class="s1">d_v0v1.connect(o_d_v0v1)</span>
            <span class="s1">d_v0v1_set.add(d_v0v1)</span>
            <span class="s2">for </span><span class="s1">v2 </span><span class="s2">in </span><span class="s1">vnnu:</span>
                <span class="s1">d_v1v2 = self.split_edge(v1.x</span><span class="s2">, </span><span class="s1">v2.x)</span>
                <span class="s1">d_v0v1.connect(d_v1v2)</span>
        <span class="s2">return</span>

    <span class="s1">@cache</span>
    <span class="s2">def </span><span class="s1">split_edge(self</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">, </span><span class="s1">v2):</span>
        <span class="s1">v1 = self.V[v1]</span>
        <span class="s1">v2 = self.V[v2]</span>
        <span class="s4"># Destroy original edge, if it exists:</span>
        <span class="s1">v1.disconnect(v2)</span>
        <span class="s4"># Compute vertex on centre of edge:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">vct = (v2.x_a - v1.x_a) / </span><span class="s3">2.0 </span><span class="s1">+ v1.x_a</span>
        <span class="s2">except </span><span class="s1">TypeError:  </span><span class="s4"># Allow for decimal operations</span>
            <span class="s1">vct = (v2.x_a - v1.x_a) / decimal.Decimal(</span><span class="s3">2.0</span><span class="s1">) + v1.x_a</span>

        <span class="s1">vc = self.V[tuple(vct)]</span>
        <span class="s4"># Connect to original 2 vertices to the new centre vertex</span>
        <span class="s1">vc.connect(v1)</span>
        <span class="s1">vc.connect(v2)</span>
        <span class="s2">return </span><span class="s1">vc</span>

    <span class="s2">def </span><span class="s1">vpool(self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">supremum):</span>
        <span class="s1">vot = tuple(origin)</span>
        <span class="s1">vst = tuple(supremum)</span>
        <span class="s4"># Initiate vertices in case they don't exist</span>
        <span class="s1">vo = self.V[vot]</span>
        <span class="s1">vs = self.V[vst]</span>

        <span class="s4"># Remove origin - supremum disconnect</span>

        <span class="s4"># Find the lower/upper bounds of the refinement hyperrectangle</span>
        <span class="s1">bl = list(vot)</span>
        <span class="s1">bu = list(vst)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(voi</span><span class="s2">, </span><span class="s1">vsi) </span><span class="s2">in </span><span class="s1">enumerate(zip(vot</span><span class="s2">, </span><span class="s1">vst)):</span>
            <span class="s2">if </span><span class="s1">bl[i] &gt; vsi:</span>
                <span class="s1">bl[i] = vsi</span>
            <span class="s2">if </span><span class="s1">bu[i] &lt; voi:</span>
                <span class="s1">bu[i] = voi</span>

        <span class="s4">#      NOTE: This is mostly done with sets/lists because we aren't sure</span>
        <span class="s4">#            how well the numpy arrays will scale to thousands of</span>
        <span class="s4">#             dimensions.</span>
        <span class="s1">vn_pool = set()</span>
        <span class="s1">vn_pool.update(vo.nn)</span>
        <span class="s1">vn_pool.update(vs.nn)</span>
        <span class="s1">cvn_pool = copy.copy(vn_pool)</span>
        <span class="s2">for </span><span class="s1">vn </span><span class="s2">in </span><span class="s1">cvn_pool:</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">xi </span><span class="s2">in </span><span class="s1">enumerate(vn.x):</span>
                <span class="s2">if </span><span class="s1">bl[i] &lt;= xi &lt;= bu[i]:</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">vn_pool.remove(vn)</span>
                    <span class="s2">except </span><span class="s1">KeyError:</span>
                        <span class="s2">pass  </span><span class="s4"># NOTE: Not all neigbouds are in initial pool</span>
        <span class="s2">return </span><span class="s1">vn_pool</span>

    <span class="s2">def </span><span class="s1">vf_to_vv(self</span><span class="s2">, </span><span class="s1">vertices</span><span class="s2">, </span><span class="s1">simplices):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert a vertex-face mesh to a vertex-vertex mesh used by this class 
 
        Parameters 
        ---------- 
        vertices : list 
            Vertices 
        simplices : list 
            Simplices 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.dim &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">simplices:</span>
                <span class="s1">edges = itertools.combinations(s</span><span class="s2">, </span><span class="s1">self.dim)</span>
                <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">edges:</span>
                    <span class="s1">self.V[tuple(vertices[e[</span><span class="s3">0</span><span class="s1">]])].connect(</span>
                        <span class="s1">self.V[tuple(vertices[e[</span><span class="s3">1</span><span class="s1">]])])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">simplices:</span>
                <span class="s1">self.V[tuple(vertices[e[</span><span class="s3">0</span><span class="s1">]])].connect(</span>
                    <span class="s1">self.V[tuple(vertices[e[</span><span class="s3">1</span><span class="s1">]])])</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">connect_vertex_non_symm(self</span><span class="s2">, </span><span class="s1">v_x</span><span class="s2">, </span><span class="s1">near=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adds a vertex at coords v_x to the complex that is not symmetric to the 
        initial triangulation and sub-triangulation. 
 
        If near is specified (for example; a star domain or collections of 
        cells known to contain v) then only those simplices containd in near 
        will be searched, this greatly speeds up the process. 
 
        If near is not specified this method will search the entire simplicial 
        complex structure. 
 
        Parameters 
        ---------- 
        v_x : tuple 
            Coordinates of non-symmetric vertex 
        near : set or list 
            List of vertices, these are points near v to check for 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">near </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">star = self.V</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">star = near</span>
        <span class="s4"># Create the vertex origin</span>
        <span class="s2">if </span><span class="s1">tuple(v_x) </span><span class="s2">in </span><span class="s1">self.V.cache:</span>
            <span class="s2">if </span><span class="s1">self.V[v_x] </span><span class="s2">in </span><span class="s1">self.V_non_symm:</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return</span>

        <span class="s1">self.V[v_x]</span>
        <span class="s1">found_nn = </span><span class="s2">False</span>
        <span class="s1">S_rows = []</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">star:</span>
            <span class="s1">S_rows.append(v.x)</span>

        <span class="s1">S_rows = numpy.array(S_rows)</span>
        <span class="s1">A = numpy.array(S_rows) - numpy.array(v_x)</span>
        <span class="s4"># Iterate through all the possible simplices of S_rows</span>
        <span class="s2">for </span><span class="s1">s_i </span><span class="s2">in </span><span class="s1">itertools.combinations(range(S_rows.shape[</span><span class="s3">0</span><span class="s1">])</span><span class="s2">,</span>
                                          <span class="s1">r=self.dim + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s4"># Check if connected, else s_i is not a simplex</span>
            <span class="s1">valid_simplex = </span><span class="s2">True</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">itertools.combinations(s_i</span><span class="s2">, </span><span class="s1">r=</span><span class="s3">2</span><span class="s1">):</span>
                <span class="s4"># Every combination of vertices must be connected, we check of</span>
                <span class="s4"># the current iteration of all combinations of s_i are</span>
                <span class="s4"># connected we break the loop if it is not.</span>
                <span class="s2">if </span><span class="s1">((self.V[tuple(S_rows[i[</span><span class="s3">1</span><span class="s1">]])] </span><span class="s2">not in</span>
                        <span class="s1">self.V[tuple(S_rows[i[</span><span class="s3">0</span><span class="s1">]])].nn)</span>
                    <span class="s2">and </span><span class="s1">(self.V[tuple(S_rows[i[</span><span class="s3">0</span><span class="s1">]])] </span><span class="s2">not in</span>
                         <span class="s1">self.V[tuple(S_rows[i[</span><span class="s3">1</span><span class="s1">]])].nn)):</span>
                    <span class="s1">valid_simplex = </span><span class="s2">False</span>
                    <span class="s2">break</span>

            <span class="s1">S = S_rows[tuple([s_i])]</span>
            <span class="s2">if </span><span class="s1">valid_simplex:</span>
                <span class="s2">if </span><span class="s1">self.deg_simplex(S</span><span class="s2">, </span><span class="s1">proj=</span><span class="s2">None</span><span class="s1">):</span>
                    <span class="s1">valid_simplex = </span><span class="s2">False</span>

            <span class="s4"># If s_i is a valid simplex we can test if v_x is inside si</span>
            <span class="s2">if </span><span class="s1">valid_simplex:</span>
                <span class="s4"># Find the A_j0 value from the precalculated values</span>
                <span class="s1">A_j0 = A[tuple([s_i])]</span>
                <span class="s2">if </span><span class="s1">self.in_simplex(S</span><span class="s2">, </span><span class="s1">v_x</span><span class="s2">, </span><span class="s1">A_j0):</span>
                    <span class="s1">found_nn = </span><span class="s2">True</span>
                    <span class="s4"># breaks the main for loop, s_i is the target simplex:</span>
                    <span class="s2">break</span>

        <span class="s4"># Connect the simplex to point</span>
        <span class="s2">if </span><span class="s1">found_nn:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">s_i:</span>
                <span class="s1">self.V[v_x].connect(self.V[tuple(S_rows[i])])</span>
        <span class="s4"># Attached the simplex to storage for all non-symmetric vertices</span>
        <span class="s1">self.V_non_symm.append(self.V[v_x])</span>
        <span class="s4"># this bool value indicates a successful connection if True:</span>
        <span class="s2">return </span><span class="s1">found_nn</span>

    <span class="s2">def </span><span class="s1">in_simplex(self</span><span class="s2">, </span><span class="s1">S</span><span class="s2">, </span><span class="s1">v_x</span><span class="s2">, </span><span class="s1">A_j0=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Check if a vector v_x is in simplex `S`. 
 
        Parameters 
        ---------- 
        S : array_like 
            Array containing simplex entries of vertices as rows 
        v_x : 
            A candidate vertex 
        A_j0 : array, optional, 
            Allows for A_j0 to be pre-calculated 
 
        Returns 
        ------- 
        res : boolean 
            True if `v_x` is in `S` 
        &quot;&quot;&quot;</span>
        <span class="s1">A_11 = numpy.delete(S</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">) - S[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s1">sign_det_A_11 = numpy.sign(numpy.linalg.det(A_11))</span>
        <span class="s2">if </span><span class="s1">sign_det_A_11 == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s4"># NOTE: We keep the variable A_11, but we loop through A_jj</span>
            <span class="s4"># ind=</span>
            <span class="s4"># while sign_det_A_11 == 0:</span>
            <span class="s4">#    A_11 = numpy.delete(S, ind, 0) - S[ind]</span>
            <span class="s4">#    sign_det_A_11 = numpy.sign(numpy.linalg.det(A_11))</span>

            <span class="s1">sign_det_A_11 = -</span><span class="s3">1  </span><span class="s4"># TODO: Choose another det of j instead?</span>
            <span class="s4"># TODO: Unlikely to work in many cases</span>

        <span class="s2">if </span><span class="s1">A_j0 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">A_j0 = S - v_x</span>

        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">range(self.dim + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">det_A_jj = (-</span><span class="s3">1</span><span class="s1">)**d * sign_det_A_11</span>
            <span class="s4"># TODO: Note that scipy might be faster to add as an optional</span>
            <span class="s4">#       dependency</span>
            <span class="s1">sign_det_A_j0 = numpy.sign(numpy.linalg.det(numpy.delete(A_j0</span><span class="s2">, </span><span class="s1">d</span><span class="s2">,</span>
                                                                     <span class="s3">0</span><span class="s1">)))</span>
            <span class="s4"># TODO: Note if sign_det_A_j0 == then the point is coplanar to the</span>
            <span class="s4">#       current simplex facet, so perhaps return True and attach?</span>
            <span class="s2">if </span><span class="s1">det_A_jj == sign_det_A_j0:</span>
                <span class="s2">continue</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return False</span>

        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">deg_simplex(self</span><span class="s2">, </span><span class="s1">S</span><span class="s2">, </span><span class="s1">proj=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Test a simplex S for degeneracy (linear dependence in R^dim). 
 
        Parameters 
        ---------- 
        S : np.array 
            Simplex with rows as vertex vectors 
        proj : array, optional, 
            If the projection S[1:] - S[0] is already 
            computed it can be added as an optional argument. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Strategy: we test all combination of faces, if any of the</span>
        <span class="s4"># determinants are zero then the vectors lie on the same face and is</span>
        <span class="s4"># therefore linearly dependent in the space of R^dim</span>
        <span class="s2">if </span><span class="s1">proj </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">proj = S[</span><span class="s3">1</span><span class="s1">:] - S[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s4"># TODO: Is checking the projection of one vertex against faces of other</span>
        <span class="s4">#       vertices sufficient? Or do we need to check more vertices in</span>
        <span class="s4">#       dimensions higher than 2?</span>
        <span class="s4"># TODO: Literature seems to suggest using proj.T, but why is this</span>
        <span class="s4">#       needed?</span>
        <span class="s2">if </span><span class="s1">numpy.linalg.det(proj) == </span><span class="s3">0.0</span><span class="s1">:  </span><span class="s4"># TODO: Repalace with tolerance?</span>
            <span class="s2">return True  </span><span class="s4"># Simplex is degenerate</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return False  </span><span class="s4"># Simplex is not degenerate</span>
</pre>
</body>
</html>