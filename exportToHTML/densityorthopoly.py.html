<html>
<head>
<title>densityorthopoly.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
densityorthopoly.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0"># some cut and paste characters are not ASCII</span>
<span class="s2">'''density estimation based on orthogonal polynomials 
 
 
Author: Josef Perktold 
Created: 2011-05017 
License: BSD 
 
2 versions work: based on Fourier, FPoly, and chebychev T, ChebyTPoly 
also hermite polynomials, HPoly, works 
other versions need normalization 
 
 
TODO: 
 
* check fourier case again:  base is orthonormal, 
  but needs offsetfact = 0 and does not integrate to 1, rescaled looks good 
* hermite: works but DensityOrthoPoly requires currently finite bounds 
  I use it with offsettfactor 0.5 in example 
* not implemented methods: 
  - add bonafide density correction 
  - add transformation to domain of polynomial base - DONE 
    possible problem: what is the behavior at the boundary, 
    offsetfact requires more work, check different cases, add as option 
    moved to polynomial class by default, as attribute 
* convert examples to test cases 
* need examples with large density on boundary, beta ? 
* organize poly classes in separate module, check new numpy.polynomials, 
  polyvander 
* MISE measures, order selection, ... 
 
enhancements: 
  * other polynomial bases: especially for open and half open support 
  * wavelets 
  * local or piecewise approximations 
 
 
'''</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">stats</span><span class="s3">, </span><span class="s1">integrate</span><span class="s3">, </span><span class="s1">special</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>


<span class="s1">sqr2 = np.sqrt(</span><span class="s4">2.</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">FPoly:</span>
    <span class="s2">'''Orthonormal (for weight=1) Fourier Polynomial on [0,1] 
 
    orthonormal polynomial but density needs corfactor that I do not see what 
    it is analytically 
 
    parameterization on [0,1] from 
 
    Sam Efromovich: Orthogonal series density estimation, 
    2010 John Wiley &amp; Sons, Inc. WIREs Comp Stat 2010 2 467-476 
 
 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">order):</span>
        <span class="s1">self.order = order</span>
        <span class="s1">self.domain = (</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.intdomain = self.domain</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">if </span><span class="s1">self.order == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.ones_like(x)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">sqr2 * np.cos(np.pi * self.order * x)</span>

<span class="s3">class </span><span class="s1">F2Poly:</span>
    <span class="s2">'''Orthogonal (for weight=1) Fourier Polynomial on [0,pi] 
 
    is orthogonal but first component does not square-integrate to 1 
    final result seems to need a correction factor of sqrt(pi) 
    _corfactor = sqrt(pi) from integrating the density 
 
    Parameterization on [0, pi] from 
 
    Peter Hall, Cross-Validation and the Smoothing of Orthogonal Series Density 
    Estimators, JOURNAL OF MULTIVARIATE ANALYSIS 21, 189-206 (1987) 
 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">order):</span>
        <span class="s1">self.order = order</span>
        <span class="s1">self.domain = (</span><span class="s4">0</span><span class="s3">, </span><span class="s1">np.pi)</span>
        <span class="s1">self.intdomain = self.domain</span>
        <span class="s1">self.offsetfactor = </span><span class="s4">0</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">if </span><span class="s1">self.order == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.ones_like(x) / np.sqrt(np.pi)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">sqr2 * np.cos(self.order * x) / np.sqrt(np.pi)</span>

<span class="s3">class </span><span class="s1">ChebyTPoly:</span>
    <span class="s2">'''Orthonormal (for weight=1) Chebychev Polynomial on (-1,1) 
 
 
    Notes 
    ----- 
    integration requires to stay away from boundary, offsetfactor &gt; 0 
    maybe this implies that we cannot use it for densities that are &gt; 0 at 
    boundary ??? 
 
    or maybe there is a mistake close to the boundary, sometimes integration works. 
 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">order):</span>
        <span class="s1">self.order = order</span>
        <span class="s3">from </span><span class="s1">scipy.special </span><span class="s3">import </span><span class="s1">chebyt</span>
        <span class="s1">self.poly = chebyt(order)</span>
        <span class="s1">self.domain = (-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.intdomain = (-</span><span class="s4">1</span><span class="s1">+</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s4">1</span><span class="s1">-</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s0">#not sure if I need this, in integration nans are possible  on the boundary</span>
        <span class="s1">self.offsetfactor = </span><span class="s4">0.01  </span><span class="s0">#required for integration</span>


    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">if </span><span class="s1">self.order == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.ones_like(x) / (</span><span class="s4">1</span><span class="s1">-x**</span><span class="s4">2</span><span class="s1">)**(</span><span class="s4">1</span><span class="s1">/</span><span class="s4">4.</span><span class="s1">) /np.sqrt(np.pi)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.poly(x) / (</span><span class="s4">1</span><span class="s1">-x**</span><span class="s4">2</span><span class="s1">)**(</span><span class="s4">1</span><span class="s1">/</span><span class="s4">4.</span><span class="s1">) /np.sqrt(np.pi) *np.sqrt(</span><span class="s4">2</span><span class="s1">)</span>


<span class="s1">logpi2 = np.log(np.pi)/</span><span class="s4">2</span>

<span class="s3">class </span><span class="s1">HPoly:</span>
    <span class="s2">'''Orthonormal (for weight=1) Hermite Polynomial, uses finite bounds 
 
    for current use with DensityOrthoPoly domain is defined as [-6,6] 
 
    '''</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">order):</span>
        <span class="s1">self.order = order</span>
        <span class="s3">from </span><span class="s1">scipy.special </span><span class="s3">import </span><span class="s1">hermite</span>
        <span class="s1">self.poly = hermite(order)</span>
        <span class="s1">self.domain = (-</span><span class="s4">6</span><span class="s3">, </span><span class="s1">+</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">self.offsetfactor = </span><span class="s4">0.5  </span><span class="s0"># note this is</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">k = self.order</span>

        <span class="s1">lnfact = -(</span><span class="s4">1.</span><span class="s1">/</span><span class="s4">2</span><span class="s1">)*(k*np.log(</span><span class="s4">2.</span><span class="s1">) + special.gammaln(k+</span><span class="s4">1</span><span class="s1">) + logpi2) - x*x/</span><span class="s4">2</span>
        <span class="s1">fact = np.exp(lnfact)</span>

        <span class="s3">return </span><span class="s1">self.poly(x) * fact</span>

<span class="s3">def </span><span class="s1">polyvander(x</span><span class="s3">, </span><span class="s1">polybase</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">5</span><span class="s1">):</span>
    <span class="s1">polyarr = np.column_stack([polybase(i)(x) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(order)])</span>
    <span class="s3">return </span><span class="s1">polyarr</span>

<span class="s3">def </span><span class="s1">inner_cont(polys</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">, </span><span class="s1">weight=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">'''inner product of continuous function (with weight=1) 
 
    Parameters 
    ---------- 
    polys : list of callables 
        polynomial instances 
    lower : float 
        lower integration limit 
    upper : float 
        upper integration limit 
    weight : callable or None 
        weighting function 
 
    Returns 
    ------- 
    innp : ndarray 
        symmetric 2d square array with innerproduct of all function pairs 
    err : ndarray 
        numerical error estimate from scipy.integrate.quad, same dimension as innp 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import chebyt 
    &gt;&gt;&gt; polys = [chebyt(i) for i in range(4)] 
    &gt;&gt;&gt; r, e = inner_cont(polys, -1, 1) 
    &gt;&gt;&gt; r 
    array([[ 2.        ,  0.        , -0.66666667,  0.        ], 
           [ 0.        ,  0.66666667,  0.        , -0.4       ], 
           [-0.66666667,  0.        ,  0.93333333,  0.        ], 
           [ 0.        , -0.4       ,  0.        ,  0.97142857]]) 
 
    '''</span>
    <span class="s1">n_polys = len(polys)</span>
    <span class="s1">innerprod = np.empty((n_polys</span><span class="s3">, </span><span class="s1">n_polys))</span>
    <span class="s1">innerprod.fill(np.nan)</span>
    <span class="s1">interr = np.zeros((n_polys</span><span class="s3">, </span><span class="s1">n_polys))</span>

    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n_polys):</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(i+</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">p1 = polys[i]</span>
            <span class="s1">p2 = polys[j]</span>
            <span class="s3">if </span><span class="s1">weight </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">innp</span><span class="s3">, </span><span class="s1">err = integrate.quad(</span><span class="s3">lambda </span><span class="s1">x: p1(x)*p2(x)*weight(x)</span><span class="s3">,</span>
                                       <span class="s1">lower</span><span class="s3">, </span><span class="s1">upper)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">innp</span><span class="s3">, </span><span class="s1">err = integrate.quad(</span><span class="s3">lambda </span><span class="s1">x: p1(x)*p2(x)</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper)</span>
            <span class="s1">innerprod[i</span><span class="s3">,</span><span class="s1">j] = innp</span>
            <span class="s1">interr[i</span><span class="s3">,</span><span class="s1">j] = err</span>
            <span class="s3">if not </span><span class="s1">i == j:</span>
                <span class="s1">innerprod[j</span><span class="s3">,</span><span class="s1">i] = innp</span>
                <span class="s1">interr[j</span><span class="s3">,</span><span class="s1">i] = err</span>

    <span class="s3">return </span><span class="s1">innerprod</span><span class="s3">, </span><span class="s1">interr</span>


<span class="s3">def </span><span class="s1">is_orthonormal_cont(polys</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-08</span><span class="s1">):</span>
    <span class="s2">'''check whether functions are orthonormal 
 
    Parameters 
    ---------- 
    polys : list of polynomials or function 
 
    Returns 
    ------- 
    is_orthonormal : bool 
        is False if the innerproducts are not close to 0 or 1 
 
    Notes 
    ----- 
    this stops as soon as the first deviation from orthonormality is found. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import chebyt 
    &gt;&gt;&gt; polys = [chebyt(i) for i in range(4)] 
    &gt;&gt;&gt; r, e = inner_cont(polys, -1, 1) 
    &gt;&gt;&gt; r 
    array([[ 2.        ,  0.        , -0.66666667,  0.        ], 
           [ 0.        ,  0.66666667,  0.        , -0.4       ], 
           [-0.66666667,  0.        ,  0.93333333,  0.        ], 
           [ 0.        , -0.4       ,  0.        ,  0.97142857]]) 
    &gt;&gt;&gt; is_orthonormal_cont(polys, -1, 1, atol=1e-6) 
    False 
 
    &gt;&gt;&gt; polys = [ChebyTPoly(i) for i in range(4)] 
    &gt;&gt;&gt; r, e = inner_cont(polys, -1, 1) 
    &gt;&gt;&gt; r 
    array([[  1.00000000e+00,   0.00000000e+00,  -9.31270888e-14, 
              0.00000000e+00], 
           [  0.00000000e+00,   1.00000000e+00,   0.00000000e+00, 
             -9.47850712e-15], 
           [ -9.31270888e-14,   0.00000000e+00,   1.00000000e+00, 
              0.00000000e+00], 
           [  0.00000000e+00,  -9.47850712e-15,   0.00000000e+00, 
              1.00000000e+00]]) 
    &gt;&gt;&gt; is_orthonormal_cont(polys, -1, 1, atol=1e-6) 
    True 
 
    '''</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(polys)):</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(i+</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">p1 = polys[i]</span>
            <span class="s1">p2 = polys[j]</span>
            <span class="s1">innerprod = integrate.quad(</span><span class="s3">lambda </span><span class="s1">x: p1(x)*p2(x)</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s0">#print i,j, innerprod</span>
            <span class="s3">if not </span><span class="s1">np.allclose(innerprod</span><span class="s3">, </span><span class="s1">i==j</span><span class="s3">, </span><span class="s1">rtol=rtol</span><span class="s3">, </span><span class="s1">atol=atol):</span>
                <span class="s3">return False</span>
    <span class="s3">return True</span>



<span class="s0">#new versions</span>


<span class="s3">class </span><span class="s1">DensityOrthoPoly:</span>
    <span class="s2">'''Univariate density estimation by orthonormal series expansion 
 
 
    Uses an orthonormal polynomial basis to approximate a univariate density. 
 
 
    currently all arguments can be given to fit, I might change it to requiring 
    arguments in __init__ instead. 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">polybase=</span><span class="s3">None, </span><span class="s1">order=</span><span class="s4">5</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">polybase </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.polybase = polybase</span>
            <span class="s1">self.polys = polys = [polybase(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(order)]</span>
        <span class="s0">#try:</span>
        <span class="s0">#self.offsetfac = 0.05</span>
        <span class="s0">#self.offsetfac = polys[0].offsetfactor #polys maybe not defined yet</span>
        <span class="s1">self._corfactor = </span><span class="s4">1</span>
        <span class="s1">self._corshift = </span><span class="s4">0</span>


    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">polybase=</span><span class="s3">None, </span><span class="s1">order=</span><span class="s4">5</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">'''estimate the orthogonal polynomial approximation to the density 
 
        '''</span>
        <span class="s3">if </span><span class="s1">polybase </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">polys = self.polys[:order]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.polybase = polybase</span>
            <span class="s1">self.polys = polys = [polybase(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(order)]</span>

        <span class="s0">#move to init ?</span>
        <span class="s3">if not </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s5">'offsetfac'</span><span class="s1">):</span>
            <span class="s1">self.offsetfac = polys[</span><span class="s4">0</span><span class="s1">].offsetfactor</span>


        <span class="s1">xmin</span><span class="s3">, </span><span class="s1">xmax = x.min()</span><span class="s3">, </span><span class="s1">x.max()</span>
        <span class="s3">if </span><span class="s1">limits </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.offset = offset = (xmax - xmin) * self.offsetfac</span>
            <span class="s1">limits = self.limits = (xmin - offset</span><span class="s3">, </span><span class="s1">xmax + offset)</span>

        <span class="s1">interval_length = limits[</span><span class="s4">1</span><span class="s1">] - limits[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">xinterval = xmax - xmin</span>
        <span class="s0"># need to cover (half-)open intervalls</span>
        <span class="s1">self.shrink = </span><span class="s4">1. </span><span class="s1">/ interval_length </span><span class="s0">#xinterval/interval_length</span>
        <span class="s1">offset = (interval_length - xinterval ) / </span><span class="s4">2.</span>
        <span class="s1">self.shift = xmin - offset</span>

        <span class="s1">self.x = x = self._transform(x)</span>

        <span class="s1">coeffs = [(p(x)).mean() </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">polys]</span>
        <span class="s1">self.coeffs = coeffs</span>
        <span class="s1">self.polys = polys</span>
        <span class="s1">self._verify()  </span><span class="s0">#verify that it is a proper density</span>

        <span class="s3">return </span><span class="s1">self </span><span class="s0">#coeffs, polys</span>

    <span class="s3">def </span><span class="s1">evaluate(self</span><span class="s3">, </span><span class="s1">xeval</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">xeval = self._transform(xeval)</span>
        <span class="s3">if </span><span class="s1">order </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">order = len(self.polys)</span>
        <span class="s1">res = sum(c*p(xeval) </span><span class="s3">for </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p </span><span class="s3">in </span><span class="s1">list(zip(self.coeffs</span><span class="s3">, </span><span class="s1">self.polys))[:order])</span>
        <span class="s1">res = self._correction(res)</span>
        <span class="s3">return </span><span class="s1">res</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">xeval):</span>
        <span class="s2">'''alias for evaluate, except no order argument'''</span>
        <span class="s3">return </span><span class="s1">self.evaluate(xeval)</span>

    <span class="s3">def </span><span class="s1">_verify(self):</span>
        <span class="s2">'''check for bona fide density correction 
 
        currently only checks that density integrates to 1 
 
`       non-negativity - NotImplementedYet 
        '''</span>
        <span class="s0">#watch out for circular/recursive usage</span>

        <span class="s0">#evaluate uses domain of data, we stay offset away from bounds</span>
        <span class="s1">intdomain = self.limits </span><span class="s0">#self.polys[0].intdomain</span>
        <span class="s1">self._corfactor = </span><span class="s4">1.</span><span class="s1">/integrate.quad(self.evaluate</span><span class="s3">, </span><span class="s1">*intdomain)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">#self._corshift = 0</span>
        <span class="s0">#self._corfactor</span>
        <span class="s3">return </span><span class="s1">self._corfactor</span>



    <span class="s3">def </span><span class="s1">_correction(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s2">'''bona fide density correction 
 
        affine shift of density to make it into a proper density 
 
        '''</span>
        <span class="s3">if </span><span class="s1">self._corfactor != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">x *= self._corfactor</span>

        <span class="s3">if </span><span class="s1">self._corshift != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">x += self._corshift</span>

        <span class="s3">return </span><span class="s1">x</span>

    <span class="s3">def </span><span class="s1">_transform(self</span><span class="s3">, </span><span class="s1">x): </span><span class="s0"># limits=None):</span>
        <span class="s2">'''transform observation to the domain of the density 
 
 
        uses shrink and shift attribute which are set in fit to stay 
 
 
        '''</span>

        <span class="s0">#use domain from first instance</span>
        <span class="s0">#class does not have domain  self.polybase.domain[0] AttributeError</span>
        <span class="s1">domain = self.polys[</span><span class="s4">0</span><span class="s1">].domain</span>

        <span class="s1">ilen = (domain[</span><span class="s4">1</span><span class="s1">] - domain[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">shift = self.shift - domain[</span><span class="s4">0</span><span class="s1">]/self.shrink/ilen</span>
        <span class="s1">shrink = self.shrink * ilen</span>

        <span class="s3">return </span><span class="s1">(x - shift) * shrink</span>


<span class="s0">#old version as a simple function</span>
<span class="s3">def </span><span class="s1">density_orthopoly(x</span><span class="s3">, </span><span class="s1">polybase</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">5</span><span class="s3">, </span><span class="s1">xeval=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">#polybase = legendre  #chebyt #hermitenorm#</span>
    <span class="s0">#polybase = chebyt</span>
    <span class="s0">#polybase = FPoly</span>
    <span class="s0">#polybase = ChtPoly</span>
    <span class="s0">#polybase = hermite</span>
    <span class="s0">#polybase = HPoly</span>

    <span class="s3">if </span><span class="s1">xeval </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">xeval = np.linspace(x.min()</span><span class="s3">,</span><span class="s1">x.max()</span><span class="s3">,</span><span class="s4">50</span><span class="s1">)</span>

    <span class="s0">#polys = [legendre(i) for i in range(order)]</span>
    <span class="s1">polys = [polybase(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(order)]</span>
    <span class="s0">#coeffs = [(p(x)*(1-x**2)**(-1/2.)).mean() for p in polys]</span>
    <span class="s0">#coeffs = [(p(x)*np.exp(-x*x)).mean() for p in polys]</span>
    <span class="s1">coeffs = [(p(x)).mean() </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">polys]</span>
    <span class="s1">res = sum(c*p(xeval) </span><span class="s3">for </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p </span><span class="s3">in </span><span class="s1">zip(coeffs</span><span class="s3">, </span><span class="s1">polys))</span>
    <span class="s0">#res *= (1-xeval**2)**(-1/2.)</span>
    <span class="s0">#res *= np.exp(-xeval**2./2)</span>
    <span class="s3">return </span><span class="s1">res</span><span class="s3">, </span><span class="s1">xeval</span><span class="s3">, </span><span class="s1">coeffs</span><span class="s3">, </span><span class="s1">polys</span>



<span class="s3">if </span><span class="s1">__name__ == </span><span class="s5">'__main__'</span><span class="s1">:</span>

    <span class="s1">examples = [</span><span class="s5">'chebyt'</span><span class="s3">, </span><span class="s5">'fourier'</span><span class="s3">, </span><span class="s5">'hermite'</span><span class="s1">]</span><span class="s0">#[2]</span>

    <span class="s1">nobs = </span><span class="s4">10000</span>

    <span class="s3">import </span><span class="s1">matplotlib.pyplot </span><span class="s3">as </span><span class="s1">plt</span>
    <span class="s3">from </span><span class="s1">statsmodels.distributions.mixture_rvs </span><span class="s3">import </span><span class="s1">(</span>
                                                <span class="s1">mixture_rvs</span><span class="s3">, </span><span class="s1">MixtureDistribution)</span>

    <span class="s0">#np.random.seed(12345)</span>
<span class="s0">##    obs_dist = mixture_rvs([1/3.,2/3.], size=nobs, dist=[stats.norm, stats.norm],</span>
<span class="s0">##                   kwargs = (dict(loc=-1,scale=.5),dict(loc=1,scale=.75)))</span>
    <span class="s1">mix_kwds = (dict(loc=-</span><span class="s4">0.5</span><span class="s3">,</span><span class="s1">scale=</span><span class="s4">.5</span><span class="s1">)</span><span class="s3">,</span><span class="s1">dict(loc=</span><span class="s4">1</span><span class="s3">,</span><span class="s1">scale=</span><span class="s4">.2</span><span class="s1">))</span>
    <span class="s1">obs_dist = mixture_rvs([</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3.</span><span class="s3">,</span><span class="s4">2</span><span class="s1">/</span><span class="s4">3.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">size=nobs</span><span class="s3">, </span><span class="s1">dist=[stats.norm</span><span class="s3">, </span><span class="s1">stats.norm]</span><span class="s3">,</span>
                   <span class="s1">kwargs=mix_kwds)</span>
    <span class="s1">mix = MixtureDistribution()</span>

    <span class="s0">#obs_dist = np.random.randn(nobs)/4. #np.sqrt(2)</span>


    <span class="s3">if </span><span class="s5">&quot;chebyt_&quot; </span><span class="s3">in </span><span class="s1">examples: </span><span class="s0"># needed for Cheby example below</span>
        <span class="s0">#obs_dist = np.clip(obs_dist, -2, 2)/2.01</span>
        <span class="s0">#chebyt [0,1]</span>
        <span class="s1">obs_dist = obs_dist[(obs_dist&gt;-</span><span class="s4">2</span><span class="s1">) &amp; (obs_dist&lt;</span><span class="s4">2</span><span class="s1">)]/</span><span class="s4">2.0 </span><span class="s0">#/4. + 2/4.0</span>
        <span class="s0">#fourier [0,1]</span>
        <span class="s0">#obs_dist = obs_dist[(obs_dist&gt;-2) &amp; (obs_dist&lt;2)]/4. + 2/4.0</span>
        <span class="s1">f_hat</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">, </span><span class="s1">coeffs</span><span class="s3">, </span><span class="s1">polys = density_orthopoly(obs_dist</span><span class="s3">, </span><span class="s1">ChebyTPoly</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">20</span><span class="s3">, </span><span class="s1">xeval=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s0">#f_hat /= f_hat.sum() * (grid.max() - grid.min())/len(grid)</span>
        <span class="s1">f_hat0 = f_hat</span>
        <span class="s1">fint = integrate.trapz(f_hat</span><span class="s3">, </span><span class="s1">grid)</span><span class="s0"># dx=(grid.max() - grid.min())/len(grid))</span>
        <span class="s0">#f_hat -= fint/2.</span>
        <span class="s1">print(</span><span class="s5">'f_hat.min()'</span><span class="s3">, </span><span class="s1">f_hat.min())</span>
        <span class="s1">f_hat = (f_hat - f_hat.min()) </span><span class="s0">#/ f_hat.max() - f_hat.min</span>
        <span class="s1">fint2 = integrate.trapz(f_hat</span><span class="s3">, </span><span class="s1">grid)</span><span class="s0"># dx=(grid.max() - grid.min())/len(grid))</span>
        <span class="s1">print(</span><span class="s5">'fint2'</span><span class="s3">, </span><span class="s1">fint</span><span class="s3">, </span><span class="s1">fint2)</span>
        <span class="s1">f_hat /= fint2</span>

        <span class="s0"># note that this uses a *huge* grid by default</span>
        <span class="s0">#f_hat, grid = kdensityfft(emp_dist, kernel=&quot;gauss&quot;, bw=&quot;scott&quot;)</span>

        <span class="s0"># check the plot</span>

        <span class="s1">doplot = </span><span class="s4">0</span>
        <span class="s3">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.hist(obs_dist</span><span class="s3">, </span><span class="s1">bins=</span><span class="s4">50</span><span class="s3">, </span><span class="s1">normed=</span><span class="s3">True, </span><span class="s1">color=</span><span class="s5">'red'</span><span class="s1">)</span>
            <span class="s1">plt.plot(grid</span><span class="s3">, </span><span class="s1">f_hat</span><span class="s3">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">color=</span><span class="s5">'black'</span><span class="s1">)</span>
            <span class="s1">plt.plot(grid</span><span class="s3">, </span><span class="s1">f_hat0</span><span class="s3">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">color=</span><span class="s5">'g'</span><span class="s1">)</span>
            <span class="s1">plt.show()</span>

        <span class="s3">for </span><span class="s1">i</span><span class="s3">,</span><span class="s1">p </span><span class="s3">in </span><span class="s1">enumerate(polys[:</span><span class="s4">5</span><span class="s1">]):</span>
            <span class="s3">for </span><span class="s1">j</span><span class="s3">,</span><span class="s1">p2 </span><span class="s3">in </span><span class="s1">enumerate(polys[:</span><span class="s4">5</span><span class="s1">]):</span>
                <span class="s1">print(i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">integrate.quad(</span><span class="s3">lambda </span><span class="s1">x: p(x)*p2(x)</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s3">,</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">polys:</span>
            <span class="s1">print(integrate.quad(</span><span class="s3">lambda </span><span class="s1">x: p(x)**</span><span class="s4">2</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s3">,</span><span class="s4">1</span><span class="s1">))</span>


    <span class="s0">#examples using the new class</span>

    <span class="s3">if </span><span class="s5">&quot;chebyt&quot; </span><span class="s3">in </span><span class="s1">examples:</span>
        <span class="s1">dop = DensityOrthoPoly().fit(obs_dist</span><span class="s3">, </span><span class="s1">ChebyTPoly</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">grid = np.linspace(obs_dist.min()</span><span class="s3">, </span><span class="s1">obs_dist.max())</span>
        <span class="s1">xf = dop(grid)</span>
        <span class="s0">#print('np.max(np.abs(xf - f_hat0))', np.max(np.abs(xf - f_hat0))</span>
        <span class="s1">dopint = integrate.quad(dop</span><span class="s3">, </span><span class="s1">*dop.limits)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">print(</span><span class="s5">'dop F integral'</span><span class="s3">, </span><span class="s1">dopint)</span>
        <span class="s1">mpdf = mix.pdf(grid</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3.</span><span class="s3">,</span><span class="s4">2</span><span class="s1">/</span><span class="s4">3.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dist=[stats.norm</span><span class="s3">, </span><span class="s1">stats.norm]</span><span class="s3">,</span>
                   <span class="s1">kwargs=mix_kwds)</span>

        <span class="s1">doplot = </span><span class="s4">1</span>
        <span class="s3">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">plt.hist(obs_dist</span><span class="s3">, </span><span class="s1">bins=</span><span class="s4">50</span><span class="s3">, </span><span class="s1">normed=</span><span class="s3">True, </span><span class="s1">color=</span><span class="s5">'red'</span><span class="s1">)</span>
            <span class="s1">plt.plot(grid</span><span class="s3">, </span><span class="s1">xf</span><span class="s3">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">color=</span><span class="s5">'black'</span><span class="s1">)</span>
            <span class="s1">plt.plot(grid</span><span class="s3">, </span><span class="s1">mpdf</span><span class="s3">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">color=</span><span class="s5">'green'</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'using Chebychev polynomials'</span><span class="s1">)</span>
            <span class="s0">#plt.show()</span>

    <span class="s3">if </span><span class="s5">&quot;fourier&quot; </span><span class="s3">in </span><span class="s1">examples:</span>
        <span class="s1">dop = DensityOrthoPoly()</span>
        <span class="s1">dop.offsetfac = </span><span class="s4">0.5</span>
        <span class="s1">dop = dop.fit(obs_dist</span><span class="s3">, </span><span class="s1">F2Poly</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">grid = np.linspace(obs_dist.min()</span><span class="s3">, </span><span class="s1">obs_dist.max())</span>
        <span class="s1">xf = dop(grid)</span>
        <span class="s0">#print(np.max(np.abs(xf - f_hat0))</span>
        <span class="s1">dopint = integrate.quad(dop</span><span class="s3">, </span><span class="s1">*dop.limits)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">print(</span><span class="s5">'dop F integral'</span><span class="s3">, </span><span class="s1">dopint)</span>
        <span class="s1">mpdf = mix.pdf(grid</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3.</span><span class="s3">,</span><span class="s4">2</span><span class="s1">/</span><span class="s4">3.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dist=[stats.norm</span><span class="s3">, </span><span class="s1">stats.norm]</span><span class="s3">,</span>
                   <span class="s1">kwargs=mix_kwds)</span>

        <span class="s1">doplot = </span><span class="s4">1</span>
        <span class="s3">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">plt.hist(obs_dist</span><span class="s3">, </span><span class="s1">bins=</span><span class="s4">50</span><span class="s3">, </span><span class="s1">normed=</span><span class="s3">True, </span><span class="s1">color=</span><span class="s5">'red'</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'using Fourier polynomials'</span><span class="s1">)</span>
            <span class="s1">plt.plot(grid</span><span class="s3">, </span><span class="s1">xf</span><span class="s3">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">color=</span><span class="s5">'black'</span><span class="s1">)</span>
            <span class="s1">plt.plot(grid</span><span class="s3">, </span><span class="s1">mpdf</span><span class="s3">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">color=</span><span class="s5">'green'</span><span class="s1">)</span>
            <span class="s0">#plt.show()</span>

        <span class="s0">#check orthonormality:</span>
        <span class="s1">print(np.max(np.abs(inner_cont(dop.polys[:</span><span class="s4">5</span><span class="s1">]</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] -np.eye(</span><span class="s4">5</span><span class="s1">))))</span>

    <span class="s3">if </span><span class="s5">&quot;hermite&quot; </span><span class="s3">in </span><span class="s1">examples:</span>
        <span class="s1">dop = DensityOrthoPoly()</span>
        <span class="s1">dop.offsetfac = </span><span class="s4">0</span>
        <span class="s1">dop = dop.fit(obs_dist</span><span class="s3">, </span><span class="s1">HPoly</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">grid = np.linspace(obs_dist.min()</span><span class="s3">, </span><span class="s1">obs_dist.max())</span>
        <span class="s1">xf = dop(grid)</span>
        <span class="s0">#print(np.max(np.abs(xf - f_hat0))</span>
        <span class="s1">dopint = integrate.quad(dop</span><span class="s3">, </span><span class="s1">*dop.limits)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">print(</span><span class="s5">'dop F integral'</span><span class="s3">, </span><span class="s1">dopint)</span>

        <span class="s1">mpdf = mix.pdf(grid</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3.</span><span class="s3">,</span><span class="s4">2</span><span class="s1">/</span><span class="s4">3.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dist=[stats.norm</span><span class="s3">, </span><span class="s1">stats.norm]</span><span class="s3">,</span>
                   <span class="s1">kwargs=mix_kwds)</span>

        <span class="s1">doplot = </span><span class="s4">1</span>
        <span class="s3">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">plt.hist(obs_dist</span><span class="s3">, </span><span class="s1">bins=</span><span class="s4">50</span><span class="s3">, </span><span class="s1">normed=</span><span class="s3">True, </span><span class="s1">color=</span><span class="s5">'red'</span><span class="s1">)</span>
            <span class="s1">plt.plot(grid</span><span class="s3">, </span><span class="s1">xf</span><span class="s3">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">color=</span><span class="s5">'black'</span><span class="s1">)</span>
            <span class="s1">plt.plot(grid</span><span class="s3">, </span><span class="s1">mpdf</span><span class="s3">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">color=</span><span class="s5">'green'</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'using Hermite polynomials'</span><span class="s1">)</span>
            <span class="s1">plt.show()</span>

        <span class="s0">#check orthonormality:</span>
        <span class="s1">print(np.max(np.abs(inner_cont(dop.polys[:</span><span class="s4">5</span><span class="s1">]</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] -np.eye(</span><span class="s4">5</span><span class="s1">))))</span>


    <span class="s0">#check orthonormality</span>

    <span class="s1">hpolys = [HPoly(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">)]</span>
    <span class="s1">inn = inner_cont(hpolys</span><span class="s3">, </span><span class="s1">-</span><span class="s4">6</span><span class="s3">, </span><span class="s4">6</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">print(np.max(np.abs(inn - np.eye(</span><span class="s4">5</span><span class="s1">))))</span>
    <span class="s1">print((inn*</span><span class="s4">100000</span><span class="s1">).astype(int))</span>

    <span class="s3">from </span><span class="s1">scipy.special </span><span class="s3">import </span><span class="s1">hermite</span><span class="s3">, </span><span class="s1">chebyt</span>
    <span class="s1">htpolys = [hermite(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">)]</span>
    <span class="s1">innt = inner_cont(htpolys</span><span class="s3">, </span><span class="s1">-</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">print((innt*</span><span class="s4">100000</span><span class="s1">).astype(int))</span>

    <span class="s1">polysc = [chebyt(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">)]</span>
    <span class="s1">r</span><span class="s3">, </span><span class="s1">e = inner_cont(polysc</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">weight=</span><span class="s3">lambda </span><span class="s1">x: (</span><span class="s4">1</span><span class="s1">-x*x)**(-</span><span class="s4">1</span><span class="s1">/</span><span class="s4">2.</span><span class="s1">))</span>
    <span class="s1">print(np.max(np.abs(r - np.diag(np.diag(r)))))</span>
</pre>
</body>
</html>