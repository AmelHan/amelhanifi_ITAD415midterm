<html>
<head>
<title>test_dynamic_factor_mq_frbny_nowcast.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_dynamic_factor_mq_frbny_nowcast.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">scipy.io </span><span class="s0">import </span><span class="s1">matlab</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span>

<span class="s0">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s0">import </span><span class="s1">initialization</span><span class="s0">, </span><span class="s1">dynamic_factor_mq</span>

<span class="s2"># Load dataset</span>
<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>
<span class="s1">results_path = os.path.join(current_path</span><span class="s0">, </span><span class="s3">'results'</span><span class="s0">, </span><span class="s3">'frbny_nowcast'</span><span class="s1">)</span>
<span class="s1">data_path = os.path.join(results_path</span><span class="s0">, </span><span class="s3">'Nowcasting'</span><span class="s0">, </span><span class="s3">'data'</span><span class="s0">, </span><span class="s3">'US'</span><span class="s1">)</span>
<span class="s1">us_data = pd.read_csv(os.path.join(data_path</span><span class="s0">, </span><span class="s3">'2016-06-29.csv'</span><span class="s1">))</span>
<span class="s1">us_data.index = pd.PeriodIndex(us_data.Date.tolist()</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">'M'</span><span class="s1">)</span>
<span class="s0">del </span><span class="s1">us_data[</span><span class="s3">'Date'</span><span class="s1">]</span>
<span class="s1">us_data_update = pd.read_csv(os.path.join(data_path</span><span class="s0">, </span><span class="s3">'2016-07-29.csv'</span><span class="s1">))</span>
<span class="s1">us_data_update.index = pd.PeriodIndex(us_data_update.Date.tolist()</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">'M'</span><span class="s1">)</span>
<span class="s0">del </span><span class="s1">us_data_update[</span><span class="s3">'Date'</span><span class="s1">]</span>

<span class="s2"># Some definitions to re-use</span>
<span class="s1">BLOCK_FACTORS_KP1 = {</span>
    <span class="s3">'CPIAUCSL'</span><span class="s1">: [</span><span class="s3">'global'</span><span class="s0">, </span><span class="s3">'test1'</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s3">'UNRATE'</span><span class="s1">: [</span><span class="s3">'global'</span><span class="s0">, </span><span class="s3">'test2'</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s3">'PAYEMS'</span><span class="s1">: [</span><span class="s3">'global'</span><span class="s0">, </span><span class="s3">'test2'</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s3">'RSAFS'</span><span class="s1">: [</span><span class="s3">'global'</span><span class="s0">, </span><span class="s3">'test1'</span><span class="s0">, </span><span class="s3">'test2'</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s3">'TTLCONS'</span><span class="s1">: [</span><span class="s3">'global'</span><span class="s0">, </span><span class="s3">'test1'</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s3">'TCU'</span><span class="s1">: [</span><span class="s3">'global'</span><span class="s0">, </span><span class="s3">'test2'</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s3">'GDPC1'</span><span class="s1">: [</span><span class="s3">'global'</span><span class="s0">, </span><span class="s3">'test1'</span><span class="s0">, </span><span class="s3">'test2'</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s3">'ULCNFB'</span><span class="s1">: [</span><span class="s3">'global'</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">}</span>
<span class="s1">BLOCK_FACTOR_ORDERS_KP1 = {</span>
    <span class="s3">'global'</span><span class="s1">: </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s3">'test1'</span><span class="s1">: </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s3">'test2'</span><span class="s1">: </span><span class="s4">1</span>
<span class="s1">}</span>
<span class="s1">BLOCK_FACTOR_ORDERS_KP2 = {</span>
    <span class="s3">'global'</span><span class="s1">: </span><span class="s4">2</span><span class="s0">,</span>
    <span class="s3">'test1'</span><span class="s1">: </span><span class="s4">2</span><span class="s0">,</span>
    <span class="s3">'test2'</span><span class="s1">: </span><span class="s4">2</span>
<span class="s1">}</span>
<span class="s1">BLOCK_FACTOR_MULTIPLICITIES_KP2 = {</span>
    <span class="s3">'global'</span><span class="s1">: </span><span class="s4">2</span><span class="s0">,</span>
    <span class="s3">'test1'</span><span class="s1">: </span><span class="s4">2</span><span class="s0">,</span>
    <span class="s3">'test2'</span><span class="s1">: </span><span class="s4">2</span>
<span class="s1">}</span>


<span class="s1">@pytest.fixture(scope=</span><span class="s3">&quot;module&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">matlab_results():</span>
    <span class="s2"># Get estimation output from FRBNY programs</span>
    <span class="s1">results = {}</span>

    <span class="s2"># DFM results with a single block of factors</span>
    <span class="s0">for </span><span class="s1">run </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'111'</span><span class="s0">, </span><span class="s3">'112'</span><span class="s0">, </span><span class="s3">'11F'</span><span class="s0">, </span><span class="s3">'221'</span><span class="s0">, </span><span class="s3">'222'</span><span class="s0">, </span><span class="s3">'22F'</span><span class="s1">]:</span>
        <span class="s1">res = matlab.loadmat(os.path.join(results_path</span><span class="s0">, </span><span class="s3">f'test_dfm_</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">.mat'</span><span class="s1">))</span>

        <span class="s2"># The FRBNY version orders the idiosyncratic AR(1) factors differently,</span>
        <span class="s2"># so we need to re-order the initial state mean and covariance matrix</span>
        <span class="s1">k_factors = res[</span><span class="s3">'Spec'</span><span class="s1">][</span><span class="s3">'k'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">factor_orders = res[</span><span class="s3">'Spec'</span><span class="s1">][</span><span class="s3">'p'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">_factor_orders = max(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">factor_orders)</span>

        <span class="s1">idio = k_factors * _factor_orders + </span><span class="s4">3</span>
        <span class="s1">ix = np.r_[np.arange(idio)</span><span class="s0">,</span>
                   <span class="s1">idio + np.arange(</span><span class="s4">10</span><span class="s1">).reshape(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s1">).ravel(order=</span><span class="s3">'F'</span><span class="s1">)]</span>
        <span class="s1">initial_state = res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'Z_0'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][ix]</span>
        <span class="s1">initial_state_cov = res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'V_0'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][ix][:</span><span class="s0">, </span><span class="s1">ix]</span>

        <span class="s2"># In the 2-factor case, we want both factors in a single block</span>
        <span class="s0">if </span><span class="s1">k_factors == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">factor_orders = {(</span><span class="s3">'0'</span><span class="s0">, </span><span class="s3">'1'</span><span class="s1">): factor_orders}</span>

        <span class="s1">results[run] = {</span>
            <span class="s3">'k_endog_M'</span><span class="s1">: </span><span class="s4">3</span><span class="s0">,</span>
            <span class="s3">'factors'</span><span class="s1">: k_factors</span><span class="s0">,</span>
            <span class="s3">'factor_orders'</span><span class="s1">: factor_orders</span><span class="s0">,</span>
            <span class="s3">'factor_multiplicities'</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s3">'params'</span><span class="s1">: res[</span><span class="s3">'params'</span><span class="s1">][:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'llf'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'loglik'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'initial_state'</span><span class="s1">: initial_state</span><span class="s0">,</span>
            <span class="s3">'initial_state_cov'</span><span class="s1">: initial_state_cov</span><span class="s0">,</span>
            <span class="s3">'smoothed_forecasts'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'x_sm'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]}</span>

    <span class="s2"># News output with a single block of factors</span>
    <span class="s0">for </span><span class="s1">run </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'112'</span><span class="s0">, </span><span class="s3">'222'</span><span class="s1">]:</span>
        <span class="s1">res = matlab.loadmat(os.path.join(results_path</span><span class="s0">,</span>
                                          <span class="s3">f'test_news_</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">.mat'</span><span class="s1">))</span>

        <span class="s2"># The FRBNY version orders the idiosyncratic AR(1) factors differently,</span>
        <span class="s2"># so we need to re-order the initial state mean and covariance matrix</span>
        <span class="s1">k_factors = res[</span><span class="s3">'Spec'</span><span class="s1">][</span><span class="s3">'k'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">factor_orders = res[</span><span class="s3">'Spec'</span><span class="s1">][</span><span class="s3">'p'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">_factor_orders = max(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">factor_orders)</span>

        <span class="s1">idio = k_factors * _factor_orders + </span><span class="s4">3</span>
        <span class="s1">ix = np.r_[np.arange(idio)</span><span class="s0">,</span>
                   <span class="s1">idio + np.arange(</span><span class="s4">10</span><span class="s1">).reshape(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s1">).ravel(order=</span><span class="s3">'F'</span><span class="s1">)]</span>
        <span class="s1">initial_state = res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'Z_0'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][ix]</span>
        <span class="s1">initial_state_cov = res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'V_0'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][ix][:</span><span class="s0">, </span><span class="s1">ix]</span>

        <span class="s2"># In the 2-factor case, we want both factors in a single block</span>
        <span class="s0">if </span><span class="s1">k_factors == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">factor_orders = {(</span><span class="s3">'0'</span><span class="s0">, </span><span class="s3">'1'</span><span class="s1">): factor_orders}</span>

        <span class="s1">results[</span><span class="s3">f'news_</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">'</span><span class="s1">] = {</span>
            <span class="s3">'k_endog_M'</span><span class="s1">: </span><span class="s4">3</span><span class="s0">,</span>
            <span class="s3">'factors'</span><span class="s1">: k_factors</span><span class="s0">,</span>
            <span class="s3">'factor_orders'</span><span class="s1">: factor_orders</span><span class="s0">,</span>
            <span class="s3">'factor_multiplicities'</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s3">'params'</span><span class="s1">: res[</span><span class="s3">'params'</span><span class="s1">][:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'initial_state'</span><span class="s1">: initial_state</span><span class="s0">,</span>
            <span class="s3">'initial_state_cov'</span><span class="s1">: initial_state_cov</span><span class="s0">,</span>
            <span class="s3">'revision_impacts'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'impact_revisions'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'weight'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'weight'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'news_table'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'news_table'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]}</span>

    <span class="s2"># DFM results with three blocks of factors</span>
    <span class="s0">for </span><span class="s1">run </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'111'</span><span class="s0">, </span><span class="s3">'112'</span><span class="s0">, </span><span class="s3">'221'</span><span class="s0">, </span><span class="s3">'222'</span><span class="s1">]:</span>
        <span class="s1">res = matlab.loadmat(os.path.join(results_path</span><span class="s0">,</span>
                                          <span class="s3">f'test_dfm_blocks_</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">.mat'</span><span class="s1">))</span>

        <span class="s2"># The FRBNY version orders the idiosyncratic AR(1) factors differently,</span>
        <span class="s2"># so we need to re-order the initial state mean and covariance matrix</span>
        <span class="s1">k_factors = res[</span><span class="s3">'Spec'</span><span class="s1">][</span><span class="s3">'k'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">factor_order = res[</span><span class="s3">'Spec'</span><span class="s1">][</span><span class="s3">'p'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">_factor_order = max(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">factor_order)</span>

        <span class="s1">idio = </span><span class="s4">3 </span><span class="s1">* k_factors * _factor_order + </span><span class="s4">6</span>
        <span class="s1">ix = np.r_[np.arange(idio)</span><span class="s0">,</span>
                   <span class="s1">idio + np.arange(</span><span class="s4">10</span><span class="s1">).reshape(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s1">).ravel(order=</span><span class="s3">'F'</span><span class="s1">)]</span>
        <span class="s1">initial_state = res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'Z_0'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][ix]</span>
        <span class="s1">initial_state_cov = res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'V_0'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][ix][:</span><span class="s0">, </span><span class="s1">ix]</span>

        <span class="s2"># Setup factors / blocks</span>
        <span class="s0">if </span><span class="s1">k_factors == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">factors = BLOCK_FACTORS_KP1.copy()</span>
            <span class="s1">factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()</span>
            <span class="s1">factor_multiplicities = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">factors = BLOCK_FACTORS_KP1.copy()</span>
            <span class="s1">factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()</span>
            <span class="s1">factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()</span>

        <span class="s1">results[</span><span class="s3">f'block_</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">'</span><span class="s1">] = {</span>
            <span class="s3">'k_endog_M'</span><span class="s1">: </span><span class="s4">6</span><span class="s0">,</span>
            <span class="s3">'factors'</span><span class="s1">: factors</span><span class="s0">,</span>
            <span class="s3">'factor_orders'</span><span class="s1">: factor_orders</span><span class="s0">,</span>
            <span class="s3">'factor_multiplicities'</span><span class="s1">: factor_multiplicities</span><span class="s0">,</span>
            <span class="s3">'params'</span><span class="s1">: res[</span><span class="s3">'params'</span><span class="s1">][:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'llf'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'loglik'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'initial_state'</span><span class="s1">: initial_state</span><span class="s0">,</span>
            <span class="s3">'initial_state_cov'</span><span class="s1">: initial_state_cov</span><span class="s0">,</span>
            <span class="s3">'smoothed_forecasts'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'x_sm'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]}</span>

    <span class="s2"># News output with three blocks of factors</span>
    <span class="s0">for </span><span class="s1">run </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'112'</span><span class="s0">, </span><span class="s3">'222'</span><span class="s1">]:</span>
        <span class="s1">res = matlab.loadmat(os.path.join(results_path</span><span class="s0">,</span>
                                          <span class="s3">f'test_news_blocks_</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">.mat'</span><span class="s1">))</span>

        <span class="s2"># The FRBNY version orders the idiosyncratic AR(1) factors differently,</span>
        <span class="s2"># so we need to re-order the initial state mean and covariance matrix</span>
        <span class="s1">k_factors = res[</span><span class="s3">'Spec'</span><span class="s1">][</span><span class="s3">'k'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">factor_order = res[</span><span class="s3">'Spec'</span><span class="s1">][</span><span class="s3">'p'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">_factor_order = max(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">factor_order)</span>

        <span class="s1">idio = </span><span class="s4">3 </span><span class="s1">* k_factors * _factor_order + </span><span class="s4">6</span>
        <span class="s1">ix = np.r_[np.arange(idio)</span><span class="s0">,</span>
                   <span class="s1">idio + np.arange(</span><span class="s4">10</span><span class="s1">).reshape(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s1">).ravel(order=</span><span class="s3">'F'</span><span class="s1">)]</span>
        <span class="s1">initial_state = res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'Z_0'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][ix]</span>
        <span class="s1">initial_state_cov = res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'V_0'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">][ix][:</span><span class="s0">, </span><span class="s1">ix]</span>

        <span class="s2"># Setup factors / blocks</span>
        <span class="s0">if </span><span class="s1">k_factors == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">factors = BLOCK_FACTORS_KP1.copy()</span>
            <span class="s1">factor_orders = BLOCK_FACTOR_ORDERS_KP1.copy()</span>
            <span class="s1">factor_multiplicities = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">factors = BLOCK_FACTORS_KP1.copy()</span>
            <span class="s1">factor_orders = BLOCK_FACTOR_ORDERS_KP2.copy()</span>
            <span class="s1">factor_multiplicities = BLOCK_FACTOR_MULTIPLICITIES_KP2.copy()</span>

        <span class="s1">results[</span><span class="s3">f'news_block_</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">'</span><span class="s1">] = {</span>
            <span class="s3">'k_endog_M'</span><span class="s1">: </span><span class="s4">6</span><span class="s0">,</span>
            <span class="s3">'factors'</span><span class="s1">: factors</span><span class="s0">,</span>
            <span class="s3">'factor_orders'</span><span class="s1">: factor_orders</span><span class="s0">,</span>
            <span class="s3">'factor_multiplicities'</span><span class="s1">: factor_multiplicities</span><span class="s0">,</span>
            <span class="s3">'params'</span><span class="s1">: res[</span><span class="s3">'params'</span><span class="s1">][:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'initial_state'</span><span class="s1">: initial_state</span><span class="s0">,</span>
            <span class="s3">'initial_state_cov'</span><span class="s1">: initial_state_cov</span><span class="s0">,</span>
            <span class="s3">'revision_impacts'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'impact_revisions'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'weight'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'weight'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">'news_table'</span><span class="s1">: res[</span><span class="s3">'Res'</span><span class="s1">][</span><span class="s3">'news_table'</span><span class="s1">][</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]}</span>

    <span class="s2"># Construct the test dataset</span>
    <span class="s0">def </span><span class="s1">get_data(us_data</span><span class="s0">, </span><span class="s1">mean_M=</span><span class="s0">None, </span><span class="s1">std_M=</span><span class="s0">None, </span><span class="s1">mean_Q=</span><span class="s0">None, </span><span class="s1">std_Q=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">dta_M = us_data[[</span><span class="s3">'CPIAUCSL'</span><span class="s0">, </span><span class="s3">'UNRATE'</span><span class="s0">, </span><span class="s3">'PAYEMS'</span><span class="s0">, </span><span class="s3">'RSAFS'</span><span class="s0">, </span><span class="s3">'TTLCONS'</span><span class="s0">,</span>
                         <span class="s3">'TCU'</span><span class="s1">]].copy()</span>
        <span class="s1">dta_Q = us_data[[</span><span class="s3">'GDPC1'</span><span class="s0">, </span><span class="s3">'ULCNFB'</span><span class="s1">]].copy().resample(</span><span class="s3">'Q'</span><span class="s1">).last()</span>

        <span class="s1">dta_M[</span><span class="s3">'CPIAUCSL'</span><span class="s1">] = (dta_M[</span><span class="s3">'CPIAUCSL'</span><span class="s1">] /</span>
                             <span class="s1">dta_M[</span><span class="s3">'CPIAUCSL'</span><span class="s1">].shift(</span><span class="s4">1</span><span class="s1">) - </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">100</span>
        <span class="s1">dta_M[</span><span class="s3">'UNRATE'</span><span class="s1">] = dta_M[</span><span class="s3">'UNRATE'</span><span class="s1">].diff()</span>
        <span class="s1">dta_M[</span><span class="s3">'PAYEMS'</span><span class="s1">] = dta_M[</span><span class="s3">'PAYEMS'</span><span class="s1">].diff()</span>
        <span class="s1">dta_M[</span><span class="s3">'TCU'</span><span class="s1">] = dta_M[</span><span class="s3">'TCU'</span><span class="s1">].diff()</span>
        <span class="s1">dta_M[</span><span class="s3">'RSAFS'</span><span class="s1">] = (dta_M[</span><span class="s3">'RSAFS'</span><span class="s1">] /</span>
                          <span class="s1">dta_M[</span><span class="s3">'RSAFS'</span><span class="s1">].shift(</span><span class="s4">1</span><span class="s1">) - </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">100</span>
        <span class="s1">dta_M[</span><span class="s3">'TTLCONS'</span><span class="s1">] = (dta_M[</span><span class="s3">'TTLCONS'</span><span class="s1">] /</span>
                            <span class="s1">dta_M[</span><span class="s3">'TTLCONS'</span><span class="s1">].shift(</span><span class="s4">1</span><span class="s1">) - </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">100</span>
        <span class="s1">dta_Q = ((dta_Q / dta_Q.shift(</span><span class="s4">1</span><span class="s1">))**</span><span class="s4">4 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">100</span>

        <span class="s1">start = </span><span class="s3">'2000'</span>
        <span class="s1">dta_M = dta_M.loc[start:]</span>
        <span class="s1">dta_Q = dta_Q.loc[start:]</span>

        <span class="s1">first_ix = dta_M.first_valid_index()</span>
        <span class="s1">last_ix = dta_M.last_valid_index()</span>
        <span class="s1">dta_M = dta_M.loc[first_ix:last_ix]</span>

        <span class="s1">first_ix = dta_Q.first_valid_index()</span>
        <span class="s1">last_ix = dta_Q.last_valid_index()</span>
        <span class="s1">dta_Q = dta_Q.loc[first_ix:last_ix]</span>

        <span class="s0">return </span><span class="s1">dta_M</span><span class="s0">, </span><span class="s1">dta_Q</span>

    <span class="s2"># Usual test dataset</span>
    <span class="s1">endog_M</span><span class="s0">, </span><span class="s1">endog_Q = get_data(us_data)</span>
    <span class="s2"># Updated test dataset (for computing the news)</span>
    <span class="s1">updated_M</span><span class="s0">, </span><span class="s1">updated_Q = get_data(us_data_update)</span>

    <span class="s0">return </span><span class="s1">endog_M</span><span class="s0">, </span><span class="s1">endog_Q</span><span class="s0">, </span><span class="s1">results</span><span class="s0">, </span><span class="s1">updated_M</span><span class="s0">, </span><span class="s1">updated_Q</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;run&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'111'</span><span class="s0">, </span><span class="s3">'112'</span><span class="s0">, </span><span class="s3">'11F'</span><span class="s0">, </span><span class="s3">'221'</span><span class="s0">, </span><span class="s3">'222'</span><span class="s0">, </span><span class="s3">'22F'</span><span class="s0">,</span>
                                 <span class="s3">'block_111'</span><span class="s0">, </span><span class="s3">'block_112'</span><span class="s0">, </span><span class="s3">'block_221'</span><span class="s0">,</span>
                                 <span class="s3">'block_222'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_known(matlab_results</span><span class="s0">, </span><span class="s1">run):</span>
    <span class="s1">endog_M</span><span class="s0">, </span><span class="s1">endog_Q = matlab_results[:</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">results = matlab_results[</span><span class="s4">2</span><span class="s1">][run]</span>

    <span class="s2"># Construct the model</span>
    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
            <span class="s1">endog_M.iloc[:</span><span class="s0">, </span><span class="s1">:results[</span><span class="s3">'k_endog_M'</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s0">,</span>
            <span class="s1">factors=results[</span><span class="s3">'factors'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">factor_orders=results[</span><span class="s3">'factor_orders'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">factor_multiplicities=results[</span><span class="s3">'factor_multiplicities'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">idiosyncratic_ar1=</span><span class="s0">True, </span><span class="s1">init_t0=</span><span class="s0">True, </span><span class="s1">obs_cov_diag=</span><span class="s0">True,</span>
            <span class="s1">standardize=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">mod.initialize_known(results[</span><span class="s3">'initial_state'</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">results[</span><span class="s3">'initial_state_cov'</span><span class="s1">])</span>
    <span class="s1">res = mod.smooth(results[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cov_type=</span><span class="s3">'none'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.llf - mod.loglike_constant</span><span class="s0">, </span><span class="s1">results[</span><span class="s3">'llf'</span><span class="s1">])</span>
    <span class="s1">assert_allclose(res.filter_results.smoothed_forecasts.T[</span><span class="s4">1</span><span class="s1">:]</span><span class="s0">,</span>
                    <span class="s1">results[</span><span class="s3">'smoothed_forecasts'</span><span class="s1">][:-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">original_scale=</span><span class="s0">False</span><span class="s1">).iloc[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">results[</span><span class="s3">'smoothed_forecasts'</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;run&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'11'</span><span class="s0">, </span><span class="s3">'22'</span><span class="s0">, </span><span class="s3">'block_11'</span><span class="s0">, </span><span class="s3">'block_22'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_emstep1(matlab_results</span><span class="s0">, </span><span class="s1">run):</span>
    <span class="s2"># Test that our EM step gets params2 from params1</span>
    <span class="s2"># Uses our default method for the observation equation, which is an</span>
    <span class="s2"># optimized version of the method presented in Bańbura and Modugno (2014)</span>
    <span class="s2"># (e.g. our version doesn't require the loop over T or the Kronecker</span>
    <span class="s2"># product)</span>
    <span class="s1">endog_M</span><span class="s0">, </span><span class="s1">endog_Q = matlab_results[:</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">results1 = matlab_results[</span><span class="s4">2</span><span class="s1">][</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">1'</span><span class="s1">]</span>
    <span class="s1">results2 = matlab_results[</span><span class="s4">2</span><span class="s1">][</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">run</span><span class="s0">}</span><span class="s3">2'</span><span class="s1">]</span>

    <span class="s2"># Construct the model</span>
    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
            <span class="s1">endog_M.iloc[:</span><span class="s0">, </span><span class="s1">:results1[</span><span class="s3">'k_endog_M'</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s0">,</span>
            <span class="s1">factors=results1[</span><span class="s3">'factors'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">factor_orders=results1[</span><span class="s3">'factor_orders'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">factor_multiplicities=results1[</span><span class="s3">'factor_multiplicities'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">idiosyncratic_ar1=</span><span class="s0">True, </span><span class="s1">init_t0=</span><span class="s0">True, </span><span class="s1">obs_cov_diag=</span><span class="s0">True,</span>
            <span class="s1">standardize=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">init = initialization.Initialization(</span>
        <span class="s1">mod.k_states</span><span class="s0">, </span><span class="s3">'known'</span><span class="s0">, </span><span class="s1">constant=results1[</span><span class="s3">'initial_state'</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">stationary_cov=results1[</span><span class="s3">'initial_state_cov'</span><span class="s1">])</span>
    <span class="s1">res2</span><span class="s0">, </span><span class="s1">params2 = mod._em_iteration(results1[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">init=init</span><span class="s0">,</span>
                                      <span class="s1">mstep_method=</span><span class="s3">'missing'</span><span class="s1">)</span>

    <span class="s2"># Test parameters</span>
    <span class="s1">true2 = results2[</span><span class="s3">'params'</span><span class="s1">]</span>
    <span class="s1">assert_allclose(params2[mod._p[</span><span class="s3">'loadings'</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">true2[mod._p[</span><span class="s3">'loadings'</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(params2[mod._p[</span><span class="s3">'factor_ar'</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">true2[mod._p[</span><span class="s3">'factor_ar'</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(params2[mod._p[</span><span class="s3">'factor_cov'</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">true2[mod._p[</span><span class="s3">'factor_cov'</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(params2[mod._p[</span><span class="s3">'idiosyncratic_ar1'</span><span class="s1">]]</span><span class="s0">,</span>
                    <span class="s1">true2[mod._p[</span><span class="s3">'idiosyncratic_ar1'</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(params2[mod._p[</span><span class="s3">'idiosyncratic_var'</span><span class="s1">]]</span><span class="s0">,</span>
                    <span class="s1">true2[mod._p[</span><span class="s3">'idiosyncratic_var'</span><span class="s1">]])</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1&quot;</span><span class="s0">,</span>
    <span class="s1">[(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(BLOCK_FACTORS_KP1.copy()</span><span class="s0">, </span><span class="s1">BLOCK_FACTOR_ORDERS_KP1.copy()</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(BLOCK_FACTORS_KP1.copy()</span><span class="s0">, </span><span class="s1">BLOCK_FACTOR_ORDERS_KP1.copy()</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(BLOCK_FACTORS_KP1.copy()</span><span class="s0">, </span><span class="s1">BLOCK_FACTOR_ORDERS_KP2.copy()</span><span class="s0">,</span>
        <span class="s1">BLOCK_FACTOR_MULTIPLICITIES_KP2</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(BLOCK_FACTORS_KP1.copy()</span><span class="s0">, </span><span class="s1">BLOCK_FACTOR_ORDERS_KP2.copy()</span><span class="s0">,</span>
        <span class="s1">BLOCK_FACTOR_MULTIPLICITIES_KP2</span><span class="s0">, False</span><span class="s1">)])</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">'ignore::UserWarning'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_emstep_methods_missing(matlab_results</span><span class="s0">, </span><span class="s1">k_factors</span><span class="s0">, </span><span class="s1">factor_orders</span><span class="s0">,</span>
                                <span class="s1">factor_multiplicities</span><span class="s0">, </span><span class="s1">idiosyncratic_ar1):</span>
    <span class="s2"># Test that in the case of missing data, the direct and optimized EM step</span>
    <span class="s2"># methods for the observation equation give identical results across a</span>
    <span class="s2"># variety of parameterizations</span>
    <span class="s1">endog_M = matlab_results[</span><span class="s4">0</span><span class="s1">].iloc[:</span><span class="s0">, </span><span class="s1">:</span><span class="s4">10</span><span class="s1">]</span>
    <span class="s1">endog_Q = matlab_results[</span><span class="s4">1</span><span class="s1">].iloc[:</span><span class="s0">, </span><span class="s1">:</span><span class="s4">10</span><span class="s1">]</span>

    <span class="s2"># Construct the model</span>
    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
            <span class="s1">endog_M</span><span class="s0">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s0">, </span><span class="s1">factors=k_factors</span><span class="s0">,</span>
            <span class="s1">factor_orders=factor_orders</span><span class="s0">,</span>
            <span class="s1">factor_multiplicities=factor_multiplicities</span><span class="s0">,</span>
            <span class="s1">idiosyncratic_ar1=idiosyncratic_ar1</span><span class="s0">, </span><span class="s1">standardize=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s0">True</span>

    <span class="s1">params0 = mod.start_params</span>
    <span class="s1">_</span><span class="s0">, </span><span class="s1">params1 = mod._em_iteration(params0</span><span class="s0">, </span><span class="s1">mstep_method=</span><span class="s3">'missing'</span><span class="s1">)</span>

    <span class="s2"># Now double-check the observation equation M step for identical H and</span>
    <span class="s2"># Lambda directly</span>
    <span class="s1">mod.update(params1)</span>
    <span class="s1">res = mod.ssm.smooth()</span>

    <span class="s1">a = res.smoothed_state.T[...</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s1">cov_a = res.smoothed_state_cov.transpose(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">Eaa = cov_a + np.matmul(a</span><span class="s0">, </span><span class="s1">a.transpose(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">Lambda</span><span class="s0">, </span><span class="s1">H = mod._em_maximization_obs_missing(res</span><span class="s0">, </span><span class="s1">Eaa</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">compute_H=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;k_factors,factor_orders,factor_multiplicities,idiosyncratic_ar1&quot;</span><span class="s0">,</span>
    <span class="s1">[(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s1">{(</span><span class="s3">'0'</span><span class="s0">, </span><span class="s3">'1'</span><span class="s0">, </span><span class="s3">'2'</span><span class="s1">): </span><span class="s4">6</span><span class="s1">}</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s1">{(</span><span class="s3">'0'</span><span class="s0">, </span><span class="s3">'1'</span><span class="s0">, </span><span class="s3">'2'</span><span class="s1">): </span><span class="s4">6</span><span class="s1">}</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(BLOCK_FACTORS_KP1.copy()</span><span class="s0">, </span><span class="s1">BLOCK_FACTOR_ORDERS_KP1.copy()</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(BLOCK_FACTORS_KP1.copy()</span><span class="s0">, </span><span class="s1">BLOCK_FACTOR_ORDERS_KP1.copy()</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(BLOCK_FACTORS_KP1.copy()</span><span class="s0">, </span><span class="s1">BLOCK_FACTOR_ORDERS_KP2.copy()</span><span class="s0">,</span>
        <span class="s1">BLOCK_FACTOR_MULTIPLICITIES_KP2</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(BLOCK_FACTORS_KP1.copy()</span><span class="s0">, </span><span class="s1">BLOCK_FACTOR_ORDERS_KP2.copy()</span><span class="s0">,</span>
        <span class="s1">BLOCK_FACTOR_MULTIPLICITIES_KP2</span><span class="s0">, False</span><span class="s1">)])</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">'ignore::UserWarning'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_emstep_methods_nonmissing(matlab_results</span><span class="s0">, </span><span class="s1">k_factors</span><span class="s0">, </span><span class="s1">factor_orders</span><span class="s0">,</span>
                                   <span class="s1">factor_multiplicities</span><span class="s0">, </span><span class="s1">idiosyncratic_ar1):</span>
    <span class="s2"># Test that in the case of non-missing data, our three EM step methods for</span>
    <span class="s2"># the observation equation (nonmissing, missing_direct, missing) give</span>
    <span class="s2"># identical results across a variety of parameterizations</span>
    <span class="s2"># Note that including quarterly series will always imply missing values,</span>
    <span class="s2"># so we have to only provide monthly series</span>
    <span class="s1">dta_M = matlab_results[</span><span class="s4">0</span><span class="s1">].iloc[:</span><span class="s0">, </span><span class="s1">:</span><span class="s4">8</span><span class="s1">]</span>
    <span class="s1">dta_M = (dta_M - dta_M.mean()) / dta_M.std()</span>
    <span class="s1">endog_M = dta_M.interpolate().fillna(method=</span><span class="s3">'backfill'</span><span class="s1">)</span>

    <span class="s2"># Remove the quarterly endog-&gt;factor maps</span>
    <span class="s0">if </span><span class="s1">isinstance(k_factors</span><span class="s0">, </span><span class="s1">dict):</span>
        <span class="s0">if </span><span class="s3">'GDPC1' </span><span class="s0">in </span><span class="s1">k_factors:</span>
            <span class="s0">del </span><span class="s1">k_factors[</span><span class="s3">'GDPC1'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s3">'ULCNFB' </span><span class="s0">in </span><span class="s1">k_factors:</span>
            <span class="s0">del </span><span class="s1">k_factors[</span><span class="s3">'ULCNFB'</span><span class="s1">]</span>

    <span class="s2"># Construct the model</span>
    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
        <span class="s1">endog_M</span><span class="s0">, </span><span class="s1">factors=k_factors</span><span class="s0">, </span><span class="s1">factor_orders=factor_orders</span><span class="s0">,</span>
        <span class="s1">factor_multiplicities=factor_multiplicities</span><span class="s0">,</span>
        <span class="s1">idiosyncratic_ar1=idiosyncratic_ar1)</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s0">True</span>

    <span class="s1">params0 = mod.start_params</span>
    <span class="s1">_</span><span class="s0">, </span><span class="s1">params1 = mod._em_iteration(params0</span><span class="s0">, </span><span class="s1">mstep_method=</span><span class="s3">'missing'</span><span class="s1">)</span>
    <span class="s1">_</span><span class="s0">, </span><span class="s1">params1_nonmissing = mod._em_iteration(</span>
        <span class="s1">params0</span><span class="s0">, </span><span class="s1">mstep_method=</span><span class="s3">'nonmissing'</span><span class="s1">)</span>

    <span class="s1">assert_allclose(params1_nonmissing</span><span class="s0">, </span><span class="s1">params1</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2"># Now double-check the observation equation M step for identical H and</span>
    <span class="s2"># Lambda directly</span>
    <span class="s1">mod.update(params1)</span>
    <span class="s1">res = mod.ssm.smooth()</span>

    <span class="s1">a = res.smoothed_state.T[...</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s1">cov_a = res.smoothed_state_cov.transpose(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">Eaa = cov_a + np.matmul(a</span><span class="s0">, </span><span class="s1">a.transpose(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">Lambda</span><span class="s0">, </span><span class="s1">H = mod._em_maximization_obs_missing(res</span><span class="s0">, </span><span class="s1">Eaa</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">compute_H=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">Lambda_nonmissing</span><span class="s0">, </span><span class="s1">H_nonmissing = mod._em_maximization_obs_nonmissing(</span>
        <span class="s1">res</span><span class="s0">, </span><span class="s1">Eaa</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">compute_H=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">assert_allclose(Lambda_nonmissing</span><span class="s0">, </span><span class="s1">Lambda</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-13</span><span class="s1">)</span>
    <span class="s1">assert_allclose(H_nonmissing</span><span class="s0">, </span><span class="s1">H</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;run&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'news_112'</span><span class="s0">, </span><span class="s3">'news_222'</span><span class="s0">, </span><span class="s3">'news_block_112'</span><span class="s0">,</span>
                                 <span class="s3">'news_block_222'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_news(matlab_results</span><span class="s0">, </span><span class="s1">run):</span>
    <span class="s1">endog_M</span><span class="s0">, </span><span class="s1">endog_Q = matlab_results[:</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">results = matlab_results[</span><span class="s4">2</span><span class="s1">][run]</span>
    <span class="s1">updated_M</span><span class="s0">, </span><span class="s1">updated_Q = matlab_results[-</span><span class="s4">2</span><span class="s1">:]</span>

    <span class="s2"># Construct the base model</span>
    <span class="s1">mod1 = dynamic_factor_mq.DynamicFactorMQ(</span>
        <span class="s1">endog_M.iloc[:</span><span class="s0">, </span><span class="s1">:results[</span><span class="s3">'k_endog_M'</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s0">,</span>
        <span class="s1">factors=results[</span><span class="s3">'factors'</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">factor_orders=results[</span><span class="s3">'factor_orders'</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">factor_multiplicities=results[</span><span class="s3">'factor_multiplicities'</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">idiosyncratic_ar1=</span><span class="s0">True, </span><span class="s1">init_t0=</span><span class="s0">True, </span><span class="s1">obs_cov_diag=</span><span class="s0">True,</span>
        <span class="s1">standardize=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">mod1.initialize_known(results[</span><span class="s3">'initial_state'</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">results[</span><span class="s3">'initial_state_cov'</span><span class="s1">])</span>
    <span class="s1">res1 = mod1.smooth(results[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cov_type=</span><span class="s3">'none'</span><span class="s1">)</span>

    <span class="s2"># Construct the updated model</span>
    <span class="s1">res2 = res1.apply(updated_M.iloc[:</span><span class="s0">, </span><span class="s1">:results[</span><span class="s3">'k_endog_M'</span><span class="s1">]]</span><span class="s0">,</span>
                      <span class="s1">endog_quarterly=updated_Q</span><span class="s0">, </span><span class="s1">retain_standardization=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s2"># Compute the news</span>
    <span class="s1">news = res2.news(res1</span><span class="s0">, </span><span class="s1">impact_date=</span><span class="s3">'2016-09'</span><span class="s0">, </span><span class="s1">comparison_type=</span><span class="s3">'previous'</span><span class="s1">)</span>

    <span class="s1">assert_allclose(news.revision_impacts.loc[</span><span class="s3">'2016-09'</span><span class="s0">, </span><span class="s3">'GDPC1'</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">results[</span><span class="s3">'revision_impacts'</span><span class="s1">])</span>

    <span class="s1">columns = [</span><span class="s3">'forecast (prev)'</span><span class="s0">, </span><span class="s3">'observed'</span><span class="s0">, </span><span class="s3">'weight'</span><span class="s0">, </span><span class="s3">'impact'</span><span class="s1">]</span>
    <span class="s1">actual = news.details_by_impact.loc[</span><span class="s3">'2016-09'</span><span class="s0">, </span><span class="s3">'GDPC1'</span><span class="s1">][columns]</span>
    <span class="s1">assert_allclose(actual.loc[(</span><span class="s3">'2016-06'</span><span class="s0">, </span><span class="s3">'CPIAUCSL'</span><span class="s1">)]</span><span class="s0">,</span>
                    <span class="s1">results[</span><span class="s3">'news_table'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual.loc[(</span><span class="s3">'2016-06'</span><span class="s0">, </span><span class="s3">'UNRATE'</span><span class="s1">)]</span><span class="s0">,</span>
                    <span class="s1">results[</span><span class="s3">'news_table'</span><span class="s1">][</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual.loc[(</span><span class="s3">'2016-06'</span><span class="s0">, </span><span class="s3">'PAYEMS'</span><span class="s1">)]</span><span class="s0">,</span>
                    <span class="s1">results[</span><span class="s3">'news_table'</span><span class="s1">][</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">mod1.k_endog_M == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s1">i = </span><span class="s4">6</span>
        <span class="s1">assert_allclose(actual.loc[(</span><span class="s3">'2016-06'</span><span class="s0">, </span><span class="s3">'RSAFS'</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s1">results[</span><span class="s3">'news_table'</span><span class="s1">][</span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">assert_allclose(actual.loc[(</span><span class="s3">'2016-05'</span><span class="s0">, </span><span class="s3">'TTLCONS'</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s1">results[</span><span class="s3">'news_table'</span><span class="s1">][</span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">assert_allclose(actual.loc[(</span><span class="s3">'2016-06'</span><span class="s0">, </span><span class="s3">'TCU'</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s1">results[</span><span class="s3">'news_table'</span><span class="s1">][</span><span class="s4">5</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">i = </span><span class="s4">3</span>
    <span class="s1">assert_allclose(actual.loc[(</span><span class="s3">'2016-06'</span><span class="s0">, </span><span class="s3">'GDPC1'</span><span class="s1">)]</span><span class="s0">,</span>
                    <span class="s1">results[</span><span class="s3">'news_table'</span><span class="s1">][i])</span>
</pre>
</body>
</html>