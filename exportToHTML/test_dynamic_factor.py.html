<html>
<head>
<title>test_dynamic_factor.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_dynamic_factor.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for VARMAX models 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_raises</span><span class="s2">, </span><span class="s1">assert_allclose</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">dynamic_factor</span>
<span class="s2">from </span><span class="s1">.results </span><span class="s2">import </span><span class="s1">results_varmax</span><span class="s2">, </span><span class="s1">results_dynamic_factor</span>
<span class="s2">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s2">import </span><span class="s1">forg</span>

<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>

<span class="s1">output_path = os.path.join(</span><span class="s3">'results'</span><span class="s2">, </span><span class="s3">'results_dynamic_factor_stata.csv'</span><span class="s1">)</span>
<span class="s1">output_results = pd.read_csv(os.path.join(current_path</span><span class="s2">, </span><span class="s1">output_path))</span>


<span class="s2">class </span><span class="s1">CheckDynamicFactor:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors</span><span class="s2">, </span><span class="s1">factor_order</span><span class="s2">, </span><span class="s1">cov_type=</span><span class="s3">'approx'</span><span class="s2">,</span>
                    <span class="s1">included_vars=[</span><span class="s3">'dln_inv'</span><span class="s2">, </span><span class="s3">'dln_inc'</span><span class="s2">, </span><span class="s3">'dln_consump'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">demean=</span><span class="s2">False, </span><span class="s1">filter=</span><span class="s2">True, </span><span class="s1">**kwargs):</span>
        <span class="s1">cls.true = true</span>
        <span class="s4"># 1960:Q1 - 1982:Q4</span>
        <span class="s1">dta = pd.DataFrame(</span>
            <span class="s1">results_varmax.lutkepohl_data</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">'inv'</span><span class="s2">, </span><span class="s3">'inc'</span><span class="s2">, </span><span class="s3">'consump'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=pd.date_range(</span><span class="s3">'1960-01-01'</span><span class="s2">, </span><span class="s3">'1982-10-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">))</span>

        <span class="s1">dta[</span><span class="s3">'dln_inv'</span><span class="s1">] = np.log(dta[</span><span class="s3">'inv'</span><span class="s1">]).diff()</span>
        <span class="s1">dta[</span><span class="s3">'dln_inc'</span><span class="s1">] = np.log(dta[</span><span class="s3">'inc'</span><span class="s1">]).diff()</span>
        <span class="s1">dta[</span><span class="s3">'dln_consump'</span><span class="s1">] = np.log(dta[</span><span class="s3">'consump'</span><span class="s1">]).diff()</span>

        <span class="s1">endog = dta.loc[</span><span class="s3">'1960-04-01'</span><span class="s1">:</span><span class="s3">'1978-10-01'</span><span class="s2">, </span><span class="s1">included_vars]</span>

        <span class="s2">if </span><span class="s1">demean:</span>
            <span class="s1">endog -= dta.iloc[</span><span class="s5">1</span><span class="s1">:][included_vars].mean()</span>

        <span class="s1">cls.model = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">k_factors=k_factors</span><span class="s2">,</span>
                                                 <span class="s1">factor_order=factor_order</span><span class="s2">,</span>
                                                 <span class="s1">**kwargs)</span>

        <span class="s2">if </span><span class="s1">filter:</span>
            <span class="s1">cls.results = cls.model.smooth(true[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cov_type=cov_type)</span>

    <span class="s2">def </span><span class="s1">test_params(self):</span>
        <span class="s4"># Smoke test to make sure the start_params are well-defined and</span>
        <span class="s4"># lead to a well-defined model</span>
        <span class="s1">self.model.filter(self.model.start_params)</span>
        <span class="s4"># Similarly a smoke test for param_names</span>
        <span class="s1">assert_equal(len(self.model.start_params)</span><span class="s2">, </span><span class="s1">len(self.model.param_names))</span>
        <span class="s4"># Finally make sure the transform and untransform do their job</span>
        <span class="s1">actual = self.model.transform_params(</span>
            <span class="s1">self.model.untransform_params(self.model.start_params))</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">self.model.start_params)</span>
        <span class="s4"># Also in the case of enforce stationarity = False</span>
        <span class="s1">self.model.enforce_stationarity = </span><span class="s2">False</span>
        <span class="s1">actual = self.model.transform_params(</span>
            <span class="s1">self.model.untransform_params(self.model.start_params))</span>
        <span class="s1">self.model.enforce_stationarity = </span><span class="s2">True</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">self.model.start_params)</span>

    <span class="s2">def </span><span class="s1">test_results(self</span><span class="s2">, </span><span class="s1">close_figures):</span>
        <span class="s4"># Smoke test for creating the summary</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">self.results.summary()</span>

        <span class="s4"># Test cofficient matrix creation</span>
        <span class="s4">#  (via a different, more direct, method)</span>
        <span class="s2">if </span><span class="s1">self.model.factor_order &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">model = self.model</span>
            <span class="s1">k_factors = model.k_factors</span>
            <span class="s1">pft_params = self.results.params[model._params_factor_transition]</span>
            <span class="s1">coefficients = np.array(pft_params).reshape(</span>
                <span class="s1">k_factors</span><span class="s2">, </span><span class="s1">k_factors * model.factor_order)</span>
            <span class="s1">coefficient_matrices = np.array([</span>
                <span class="s1">coefficients[:self.model.k_factors</span><span class="s2">,</span>
                             <span class="s1">i*self.model.k_factors:(i+</span><span class="s5">1</span><span class="s1">)*self.model.k_factors]</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.factor_order)</span>
            <span class="s1">])</span>
            <span class="s1">assert_equal(</span>
                <span class="s1">self.results.coefficient_matrices_var</span><span class="s2">,</span>
                <span class="s1">coefficient_matrices)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_equal(self.results.coefficient_matrices_var</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.matplotlib</span>
    <span class="s2">def </span><span class="s1">test_plot_coefficients_of_determination(self</span><span class="s2">, </span><span class="s1">close_figures):</span>
        <span class="s4"># Smoke test for plot_coefficients_of_determination</span>
        <span class="s1">self.results.plot_coefficients_of_determination()</span>

    <span class="s2">def </span><span class="s1">test_no_enforce(self):</span>
        <span class="s2">return</span>
        <span class="s4"># Test that nothing goes wrong when we do not enforce stationarity</span>
        <span class="s1">params = self.model.untransform_params(self.true[</span><span class="s3">'params'</span><span class="s1">])</span>
        <span class="s1">params[self.model._params_transition] = (</span>
            <span class="s1">self.true[</span><span class="s3">'params'</span><span class="s1">][self.model._params_transition])</span>
        <span class="s1">self.model.enforce_stationarity = </span><span class="s2">False</span>
        <span class="s1">results = self.model.filter(params</span><span class="s2">, </span><span class="s1">transformed=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.model.enforce_stationarity = </span><span class="s2">True</span>
        <span class="s1">assert_allclose(results.llf</span><span class="s2">, </span><span class="s1">self.results.llf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self</span><span class="s2">, </span><span class="s1">init_powell=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">'always'</span><span class="s1">)</span>
            <span class="s1">start_params = self.model.start_params</span>
            <span class="s2">if </span><span class="s1">init_powell:</span>
                <span class="s1">results = self.model.fit(method=</span><span class="s3">'powell'</span><span class="s2">,</span>
                                         <span class="s1">maxiter=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">start_params = results.params</span>
            <span class="s1">results = self.model.fit(start_params</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">1000</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">results = self.model.fit(results.params</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'nm'</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">1000</span><span class="s2">,</span>
                                     <span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">results.llf &gt; self.results.llf:</span>
                <span class="s1">assert_allclose(results.llf</span><span class="s2">, </span><span class="s1">self.results.llf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(self.results.llf</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s4"># We only get 3 digits from Stata</span>
        <span class="s1">assert_allclose(self.results.aic</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'aic'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># We only get 3 digits from Stata</span>
        <span class="s1">assert_allclose(self.results.bic</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'bic'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Tests predict + forecast</span>
        <span class="s1">self.results.predict(end=</span><span class="s3">'1982-10-01'</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results.predict(end=</span><span class="s3">'1982-10-01'</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'predict'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Tests predict + dynamic predict + forecast</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results.predict(end=</span><span class="s3">'1982-10-01'</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s3">'1961-01-01'</span><span class="s2">,</span>
                                 <span class="s1">**kwargs)</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'dynamic_predict'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDynamicFactor(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a dynamic factor model with 1 AR(2) factor 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_dfm.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_dfm_1'</span><span class="s2">, </span><span class="s3">'predict_dfm_2'</span><span class="s2">, </span><span class="s3">'predict_dfm_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_dfm_1'</span><span class="s2">, </span><span class="s3">'dyn_predict_dfm_2'</span><span class="s2">, </span><span class="s3">'dyn_predict_dfm_3'</span><span class="s1">]]</span>
        <span class="s1">super(TestDynamicFactor</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'bse_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDynamicFactor2(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a dynamic factor model with two VAR(1) factors 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_dfm2.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_dfm2_1'</span><span class="s2">, </span><span class="s3">'predict_dfm2_2'</span><span class="s2">, </span><span class="s3">'predict_dfm2_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_dfm2_1'</span><span class="s2">, </span><span class="s3">'dyn_predict_dfm2_2'</span><span class="s2">, </span><span class="s3">'dyn_predict_dfm2_3'</span><span class="s1">]]</span>
        <span class="s1">super(TestDynamicFactor2</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s4"># Stata's MLE on this model does not converge, so no reason to check</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># Stata's MLE on this model does not converge, and four of their</span>
        <span class="s4"># params do not even have bse (possibly they are still at starting</span>
        <span class="s4"># values?), so no reason to check this</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s4"># Stata uses 9 df (i.e. 9 params) here instead of 13, because since the</span>
        <span class="s4"># model did not coverge, 4 of the parameters are not fully estimated</span>
        <span class="s4"># (possibly they are still at starting values?) so the AIC is off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># Stata uses 9 df (i.e. 9 params) here instead of 13, because since the</span>
        <span class="s4"># model did not coverge, 4 of the parameters are not fully estimated</span>
        <span class="s4"># (possibly they are still at starting values?) so the BIC is off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Make sure we have the right number of tables</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">len(tables)</span><span class="s2">,</span>
            <span class="s5">2 </span><span class="s1">+ self.model.k_endog + self.model.k_factors + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span>
            <span class="s3">r'Model:.*DynamicFactor\(factors=2, order=1\)'</span><span class="s2">,</span>
            <span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset_loading = self.model.k_factors * i</span>
            <span class="s1">table = tables[i + </span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">7</span><span class="s1">)</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'loading.f1 +' </span><span class="s1">+ forg(params[offset_loading + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'loading.f2 +' </span><span class="s1">+ forg(params[offset_loading + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>

        <span class="s4"># For each factor, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_factors):</span>
            <span class="s1">offset = (self.model.k_endog * (self.model.k_factors + </span><span class="s5">1</span><span class="s1">) +</span>
                      <span class="s1">i * self.model.k_factors)</span>
            <span class="s1">table = tables[self.model.k_endog + i + </span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for factor equation f%d' </span><span class="s1">% (i+</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">7</span><span class="s1">)</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.f1 +' </span><span class="s1">+ forg(params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.f2 +' </span><span class="s1">+ forg(params[offset + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">table)</span>

        <span class="s4"># Check the Error covariance matrix output</span>
        <span class="s1">table = tables[</span><span class="s5">2 </span><span class="s1">+ self.model.k_endog + self.model.k_factors]</span>

        <span class="s4"># -&gt; Make sure we have the right table / table name</span>
        <span class="s1">name = self.model.endog_names[i]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>

        <span class="s4"># -&gt; Make sure it's the right size</span>
        <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">8</span><span class="s1">)</span>

        <span class="s4"># -&gt; Check that we have the right coefficients</span>
        <span class="s1">offset = self.model.k_endog * self.model.k_factors</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">iname = self.model.endog_names[i]</span>
            <span class="s1">iparam = forg(params[offset + i]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'sigma2.%s +%s' </span><span class="s1">% (iname</span><span class="s2">, </span><span class="s1">iparam)</span><span class="s2">, </span><span class="s1">table)</span>


<span class="s2">class </span><span class="s1">TestDynamicFactor_exog1(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a dynamic factor model with 1 exogenous regressor: a constant 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_dfm_exog1.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_dfm_exog1_1'</span><span class="s2">,</span>
            <span class="s3">'predict_dfm_exog1_2'</span><span class="s2">,</span>
            <span class="s3">'predict_dfm_exog1_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_dfm_exog1_1'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_exog1_2'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_exog1_3'</span><span class="s1">]]</span>
        <span class="s1">exog = np.ones((</span><span class="s5">75</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">super(TestDynamicFactor_exog1</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">exog = np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">super(TestDynamicFactor_exog1</span><span class="s2">, </span><span class="s1">self).test_predict(exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s1">exog = np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">super(TestDynamicFactor_exog1</span><span class="s2">, </span><span class="s1">self).test_dynamic_predict(exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDynamicFactor_exog2(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a dynamic factor model with 2 exogenous regressors: a constant 
    and a time-trend 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_dfm_exog2.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_dfm_exog2_1'</span><span class="s2">,</span>
            <span class="s3">'predict_dfm_exog2_2'</span><span class="s2">,</span>
            <span class="s3">'predict_dfm_exog2_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_dfm_exog2_1'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_exog2_2'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_exog2_3'</span><span class="s1">]]</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">75</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(np.arange(</span><span class="s5">75</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestDynamicFactor_exog2</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">(np.arange(</span><span class="s5">75</span><span class="s2">, </span><span class="s5">75</span><span class="s1">+</span><span class="s5">16</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestDynamicFactor_exog2</span><span class="s2">, </span><span class="s1">self).test_predict(exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">(np.arange(</span><span class="s5">75</span><span class="s2">, </span><span class="s5">75</span><span class="s1">+</span><span class="s5">16</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestDynamicFactor_exog2</span><span class="s2">, </span><span class="s1">self).test_dynamic_predict(exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Make sure we have the right number of tables</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">len(tables)</span><span class="s2">,</span>
            <span class="s5">2 </span><span class="s1">+ self.model.k_endog + self.model.k_factors + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Model:.*DynamicFactor\(factors=1, order=1\)'</span><span class="s2">,</span>
                         <span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(re.search(</span><span class="s3">r'.*2 regressors'</span><span class="s2">, </span><span class="s1">tables[</span><span class="s5">0</span><span class="s1">]) </span><span class="s2">is None, False</span><span class="s1">)</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset_loading = self.model.k_factors * i</span>
            <span class="s1">offset_exog = self.model.k_factors * self.model.k_endog</span>
            <span class="s1">table = tables[i + </span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">8</span><span class="s1">)</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'loading.f1 +' </span><span class="s1">+ forg(params[offset_loading + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'beta.const +' </span><span class="s1">+ forg(params[offset_exog + i*</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'beta.x1 +' </span><span class="s1">+ forg(params[offset_exog + i*</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>

        <span class="s4"># For each factor, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_factors):</span>
            <span class="s1">offset = (self.model.k_endog * (self.model.k_factors + </span><span class="s5">3</span><span class="s1">) +</span>
                      <span class="s1">i * self.model.k_factors)</span>
            <span class="s1">table = tables[self.model.k_endog + i + </span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for factor equation f%d' </span><span class="s1">% (i+</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.f1 +' </span><span class="s1">+ forg(params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">table)</span>

        <span class="s4"># Check the Error covariance matrix output</span>
        <span class="s1">table = tables[</span><span class="s5">2 </span><span class="s1">+ self.model.k_endog + self.model.k_factors]</span>

        <span class="s4"># -&gt; Make sure we have the right table / table name</span>
        <span class="s1">name = self.model.endog_names[i]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>

        <span class="s4"># -&gt; Make sure it's the right size</span>
        <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">8</span><span class="s1">)</span>

        <span class="s4"># -&gt; Check that we have the right coefficients</span>
        <span class="s1">offset = self.model.k_endog * (self.model.k_factors + </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">iname = self.model.endog_names[i]</span>
            <span class="s1">iparam = forg(params[offset + i]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'sigma2.%s +%s' </span><span class="s1">% (iname</span><span class="s2">, </span><span class="s1">iparam)</span><span class="s2">, </span><span class="s1">table)</span>


<span class="s2">class </span><span class="s1">TestDynamicFactor_general_errors(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a dynamic factor model where errors are as general as possible, 
    meaning: 
 
    - Errors are vector autocorrelated, VAR(1) 
    - Innovations are correlated 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_dfm_gen.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_dfm_gen_1'</span><span class="s2">, </span><span class="s3">'predict_dfm_gen_2'</span><span class="s2">, </span><span class="s3">'predict_dfm_gen_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_dfm_gen_1'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_gen_2'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_gen_3'</span><span class="s1">]]</span>
        <span class="s1">super(TestDynamicFactor_general_errors</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">error_var=</span><span class="s2">True,</span>
            <span class="s1">error_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">'unstructured'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()</span>
        <span class="s1">assert_allclose(bse[:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">][:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[-</span><span class="s5">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">][-</span><span class="s5">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">3e-4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skip(</span><span class="s3">&quot;Known failure, no sequence of optimizers has been &quot;</span>
                      <span class="s3">&quot;found which can achieve the maximum.&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s4"># The following gets us to llf=546.53, which is still not good enough</span>
        <span class="s4"># llf = 300.842477412</span>
        <span class="s4"># res = mod.fit(method='lbfgs', maxiter=10000)</span>
        <span class="s4"># llf = 460.26576722</span>
        <span class="s4"># res = mod.fit(res.params, method='nm', maxiter=10000, maxfev=10000)</span>
        <span class="s4"># llf = 542.245718508</span>
        <span class="s4"># res = mod.fit(res.params, method='lbfgs', maxiter=10000)</span>
        <span class="s4"># llf = 544.035160955</span>
        <span class="s4"># res = mod.fit(res.params, method='nm', maxiter=10000, maxfev=10000)</span>
        <span class="s4"># llf = 557.442240083</span>
        <span class="s4"># res = mod.fit(res.params, method='lbfgs', maxiter=10000)</span>
        <span class="s4"># llf = 558.199513262</span>
        <span class="s4"># res = mod.fit(res.params, method='nm', maxiter=10000, maxfev=10000)</span>
        <span class="s4"># llf = 559.049076604</span>
        <span class="s4"># res = mod.fit(res.params, method='nm', maxiter=10000, maxfev=10000)</span>
        <span class="s4"># llf = 559.049076604</span>
        <span class="s4"># ...</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Make sure we have the right number of tables</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">len(tables)</span><span class="s2">,</span>
            <span class="s5">2 </span><span class="s1">+ self.model.k_endog + self.model.k_factors +</span>
            <span class="s1">self.model.k_endog + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Model:.*DynamicFactor\(factors=1, order=1\)'</span><span class="s2">,</span>
                         <span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'.*VAR\(1\) errors'</span><span class="s2">, </span><span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset_loading = self.model.k_factors * i</span>
            <span class="s1">table = tables[i + </span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s1">pattern = </span><span class="s3">'loading.f1 +' </span><span class="s1">+ forg(params[offset_loading + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">re.search(pattern</span><span class="s2">, </span><span class="s1">table)</span>

        <span class="s4"># For each factor, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_factors):</span>
            <span class="s1">offset = (self.model.k_endog * self.model.k_factors +</span>
                      <span class="s5">6 </span><span class="s1">+ i * self.model.k_factors)</span>
            <span class="s1">table = tables[</span><span class="s5">2 </span><span class="s1">+ self.model.k_endog + i]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for factor equation f%d' </span><span class="s1">% (i+</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.f1 +' </span><span class="s1">+ forg(params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">table)</span>

        <span class="s4"># For each error equation, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset = (self.model.k_endog * (self.model.k_factors + i) +</span>
                      <span class="s5">6 </span><span class="s1">+ self.model.k_factors)</span>
            <span class="s1">table = tables[</span><span class="s5">2 </span><span class="s1">+ self.model.k_endog + self.model.k_factors + i]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Results for error equation e\(%s\)' </span><span class="s1">% name</span><span class="s2">,</span>
                             <span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">8</span><span class="s1">)</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
                <span class="s1">name = self.model.endog_names[j]</span>
                <span class="s1">pattern = </span><span class="s3">r'L1.e\(%s\) +%s' </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">forg(params[offset + j]</span><span class="s2">,</span>
                                                          <span class="s1">prec=</span><span class="s5">4</span><span class="s1">))</span>
                <span class="s2">assert </span><span class="s1">re.search(pattern</span><span class="s2">, </span><span class="s1">table)</span>

        <span class="s4"># Check the Error covariance matrix output</span>
        <span class="s1">table = tables[</span><span class="s5">2 </span><span class="s1">+ self.model.k_endog +</span>
                       <span class="s1">self.model.k_factors + self.model.k_endog]</span>

        <span class="s4"># -&gt; Make sure we have the right table / table name</span>
        <span class="s1">name = self.model.endog_names[i]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>

        <span class="s4"># -&gt; Make sure it's the right size</span>
        <span class="s1">assert_equal(len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">, </span><span class="s5">11</span><span class="s1">)</span>

        <span class="s4"># -&gt; Check that we have the right coefficients</span>
        <span class="s1">offset = self.model.k_endog * self.model.k_factors</span>
        <span class="s2">assert </span><span class="s1">re.search(</span>
            <span class="s3">r'cov.chol\[1,1\] +' </span><span class="s1">+ forg(params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">re.search(</span>
            <span class="s3">r'cov.chol\[2,1\] +' </span><span class="s1">+ forg(params[offset + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">re.search(</span>
            <span class="s3">r'cov.chol\[2,2\] +' </span><span class="s1">+ forg(params[offset + </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">re.search(</span>
            <span class="s3">r'cov.chol\[3,1\] +' </span><span class="s1">+ forg(params[offset+</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">re.search(</span>
            <span class="s3">r'cov.chol\[3,2\] +' </span><span class="s1">+ forg(params[offset+</span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">re.search(</span>
            <span class="s3">r'cov.chol\[3,3\] +' </span><span class="s1">+ forg(params[offset + </span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">table)</span>


<span class="s2">class </span><span class="s1">TestDynamicFactor_ar2_errors(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a dynamic factor model where errors are as general as possible, 
    meaning: 
 
    - Errors are vector autocorrelated, VAR(1) 
    - Innovations are correlated 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_dfm_ar2.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_dfm_ar2_1'</span><span class="s2">, </span><span class="s3">'predict_dfm_ar2_2'</span><span class="s2">, </span><span class="s3">'predict_dfm_ar2_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_dfm_ar2_1'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_ar2_2'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_ar2_3'</span><span class="s1">]]</span>
        <span class="s1">super(TestDynamicFactor_ar2_errors</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">error_order=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()</span>
        <span class="s1">assert_allclose(bse</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s4"># Depending on the system, this test can reach a greater precision,</span>
            <span class="s4"># but for cross-platform results keep it at 1e-2</span>
            <span class="s1">mod = self.model</span>
            <span class="s1">res1 = mod.fit(maxiter=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">optim_score=</span><span class="s3">'approx'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">res = mod.fit(</span>
                <span class="s1">res1.params</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'nm'</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">10000</span><span class="s2">,</span>
                <span class="s1">optim_score=</span><span class="s3">'approx'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s4"># Added rtol to catch spurious failures on some platforms</span>
            <span class="s1">assert_allclose(res.llf</span><span class="s2">, </span><span class="s1">self.results.llf</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDynamicFactor_scalar_error(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a dynamic factor model where innovations are uncorrelated and 
    are forced to have the same variance. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_dfm_scalar.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_dfm_scalar_1'</span><span class="s2">, </span><span class="s3">'predict_dfm_scalar_2'</span><span class="s2">,</span>
            <span class="s3">'predict_dfm_scalar_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_dfm_scalar_1'</span><span class="s2">, </span><span class="s3">'dyn_predict_dfm_scalar_2'</span><span class="s2">,</span>
            <span class="s3">'dyn_predict_dfm_scalar_3'</span><span class="s1">]]</span>
        <span class="s1">exog = np.ones((</span><span class="s5">75</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">super(TestDynamicFactor_scalar_error</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s2">,</span>
            <span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">'scalar'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()</span>
        <span class="s1">assert_allclose(bse</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">exog = np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">super(TestDynamicFactor_scalar_error</span><span class="s2">, </span><span class="s1">self).test_predict(exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s1">exog = np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">super(TestDynamicFactor_scalar_error</span><span class="s2">,</span>
              <span class="s1">self).test_dynamic_predict(exog=exog)</span>


<span class="s2">class </span><span class="s1">TestStaticFactor(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a static factor model (i.e. factors are not autocorrelated). 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_sfm.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_sfm_1'</span><span class="s2">, </span><span class="s3">'predict_sfm_2'</span><span class="s2">, </span><span class="s3">'predict_sfm_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_sfm_1'</span><span class="s2">, </span><span class="s3">'dyn_predict_sfm_2'</span><span class="s2">, </span><span class="s3">'dyn_predict_sfm_3'</span><span class="s1">]]</span>
        <span class="s1">super(TestStaticFactor</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()</span>
        <span class="s1">assert_allclose(bse</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># Stata uses 5 df (i.e. 5 params) here instead of 6, because one param</span>
        <span class="s4"># is basically zero.</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestSUR(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a seemingly unrelated regression model (i.e. no factors) with 
    errors cross-sectionally, but not auto-, correlated 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_sur.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_sur_1'</span><span class="s2">, </span><span class="s3">'predict_sur_2'</span><span class="s2">, </span><span class="s3">'predict_sur_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_sur_1'</span><span class="s2">, </span><span class="s3">'dyn_predict_sur_2'</span><span class="s2">, </span><span class="s3">'dyn_predict_sur_3'</span><span class="s1">]]</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">75</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(np.arange(</span><span class="s5">75</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestSUR</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">0</span><span class="s2">,</span>
            <span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">'unstructured'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()</span>
        <span class="s1">assert_allclose(bse[:</span><span class="s5">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">][:</span><span class="s5">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">(np.arange(</span><span class="s5">75</span><span class="s2">, </span><span class="s5">75</span><span class="s1">+</span><span class="s5">16</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestSUR</span><span class="s2">, </span><span class="s1">self).test_predict(exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">(np.arange(</span><span class="s5">75</span><span class="s2">, </span><span class="s5">75</span><span class="s1">+</span><span class="s5">16</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestSUR</span><span class="s2">, </span><span class="s1">self).test_dynamic_predict(exog=exog)</span>


<span class="s2">class </span><span class="s1">TestSUR_autocorrelated_errors(CheckDynamicFactor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test for a seemingly unrelated regression model (i.e. no factors) where 
    the errors are vector autocorrelated, but innovations are uncorrelated. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_dynamic_factor.lutkepohl_sur_auto.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'predict_sur_auto_1'</span><span class="s2">, </span><span class="s3">'predict_sur_auto_2'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = output_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_sur_auto_1'</span><span class="s2">, </span><span class="s3">'dyn_predict_sur_auto_2'</span><span class="s1">]]</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">75</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(np.arange(</span><span class="s5">75</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestSUR_autocorrelated_errors</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
            <span class="s1">error_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">error_var=</span><span class="s2">True,</span>
            <span class="s1">error_cov_type=</span><span class="s3">'diagonal'</span><span class="s2">,</span>
            <span class="s1">included_vars=[</span><span class="s3">'dln_inv'</span><span class="s2">, </span><span class="s3">'dln_inc'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()</span>
        <span class="s1">assert_allclose(bse</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">(np.arange(</span><span class="s5">75</span><span class="s2">, </span><span class="s5">75</span><span class="s1">+</span><span class="s5">16</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestSUR_autocorrelated_errors</span><span class="s2">, </span><span class="s1">self).test_predict(exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">(np.arange(</span><span class="s5">75</span><span class="s2">, </span><span class="s5">75</span><span class="s1">+</span><span class="s5">16</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestSUR_autocorrelated_errors</span><span class="s2">,</span>
              <span class="s1">self).test_dynamic_predict(exog=exog)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s1">super(TestSUR_autocorrelated_errors</span><span class="s2">, </span><span class="s1">self).test_mle(init_powell=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_misspecification():</span>
    <span class="s4"># Tests for model specification and misspecification exceptions</span>
    <span class="s1">endog = np.arange(</span><span class="s5">20</span><span class="s1">).reshape(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s4"># Too few endog</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">dynamic_factor.DynamicFactor</span><span class="s2">, </span><span class="s1">endog[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s4"># Too many factors</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">dynamic_factor.DynamicFactor</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># Bad error_cov_type specification</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">dynamic_factor.DynamicFactor</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">''</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_miscellaneous():</span>
    <span class="s4"># Initialization with 1-dimensional exog array</span>
    <span class="s1">exog = np.arange(</span><span class="s5">75</span><span class="s1">)</span>
    <span class="s1">mod = CheckDynamicFactor()</span>
    <span class="s1">mod.setup_class(true=</span><span class="s2">None, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s2">,</span>
                    <span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">filter=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">exog = pd.Series(np.arange(</span><span class="s5">75</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">index=pd.date_range(start=</span><span class="s3">'1960-04-01'</span><span class="s2">,</span>
                                         <span class="s1">end=</span><span class="s3">'1978-10-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">))</span>
    <span class="s1">mod = CheckDynamicFactor()</span>
    <span class="s1">mod.setup_class(</span>
        <span class="s1">true=</span><span class="s2">None, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">filter=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_predict_custom_index():</span>
    <span class="s1">np.random.seed(</span><span class="s5">328423</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.random.normal(size=(</span><span class="s5">50</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)))</span>
    <span class="s1">mod = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth(mod.start_params)</span>
    <span class="s1">out = res.predict(start=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">end=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">'a'</span><span class="s1">])</span>
    <span class="s1">assert_equal(out.index.equals(pd.Index([</span><span class="s3">'a'</span><span class="s1">]))</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_forecast_exog():</span>
    <span class="s4"># Test forecasting with various shapes of `exog`</span>
    <span class="s1">nobs = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones((nobs</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)) * </span><span class="s5">2.0</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s1">mod = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">,</span>
                                       <span class="s1">factor_order=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth(np.r_[[</span><span class="s5">0</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">])</span>

    <span class="s4"># 1-step-ahead, valid</span>
    <span class="s1">exog_fcast_scalar = </span><span class="s5">1.</span>
    <span class="s1">exog_fcast_1dim = np.ones(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">exog_fcast_2dim = np.ones((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_scalar)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_1dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_2dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s4"># h-steps-ahead, valid</span>
    <span class="s1">h = </span><span class="s5">10</span>
    <span class="s1">exog_fcast_1dim = np.ones(h)</span>
    <span class="s1">exog_fcast_2dim = np.ones((h</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">assert_allclose(res.forecast(h</span><span class="s2">, </span><span class="s1">exog=exog_fcast_1dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(h</span><span class="s2">, </span><span class="s1">exog=exog_fcast_2dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s4"># h-steps-ahead, invalid</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=</span><span class="s5">1.</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=np.ones((h</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2):</span>
    <span class="s1">attrs = [</span>
        <span class="s3">'k_factors'</span><span class="s2">, </span><span class="s3">'factor_order'</span><span class="s2">, </span><span class="s3">'error_order'</span><span class="s2">, </span><span class="s3">'error_var'</span><span class="s2">,</span>
        <span class="s3">'error_cov_type'</span><span class="s2">, </span><span class="s3">'enforce_stationarity'</span><span class="s2">, </span><span class="s3">'mle_regression'</span><span class="s2">, </span><span class="s3">'k_params'</span><span class="s1">]</span>

    <span class="s1">ssm_attrs = [</span>
        <span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'k_endog'</span><span class="s2">, </span><span class="s3">'k_states'</span><span class="s2">, </span><span class="s3">'k_posdef'</span><span class="s2">, </span><span class="s3">'obs_intercept'</span><span class="s2">, </span><span class="s3">'design'</span><span class="s2">,</span>
        <span class="s3">'obs_cov'</span><span class="s2">, </span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s3">'transition'</span><span class="s2">, </span><span class="s3">'selection'</span><span class="s2">, </span><span class="s3">'state_cov'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">assert_equal(getattr(mod2</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(mod</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">ssm_attrs:</span>
        <span class="s1">assert_equal(getattr(mod2.ssm</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(mod.ssm</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_equal(mod2._get_init_kwds()</span><span class="s2">, </span><span class="s1">mod._get_init_kwds())</span>


<span class="s2">def </span><span class="s1">test_recreate_model():</span>
    <span class="s1">nobs = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones((nobs</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)) * </span><span class="s5">2.0</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s1">k_factors = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">factor_orders = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">error_orders = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">error_vars = [</span><span class="s2">False, True</span><span class="s1">]</span>
    <span class="s1">error_cov_types = [</span><span class="s3">'diagonal'</span><span class="s2">, </span><span class="s3">'scalar'</span><span class="s1">]</span>

    <span class="s2">import </span><span class="s1">itertools</span>
    <span class="s1">names = [</span><span class="s3">'k_factors'</span><span class="s2">, </span><span class="s3">'factor_order'</span><span class="s2">, </span><span class="s3">'error_order'</span><span class="s2">, </span><span class="s3">'error_var'</span><span class="s2">,</span>
             <span class="s3">'error_cov_type'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">itertools.product(k_factors</span><span class="s2">, </span><span class="s1">factor_orders</span><span class="s2">, </span><span class="s1">error_orders</span><span class="s2">,</span>
                                     <span class="s1">error_vars</span><span class="s2">, </span><span class="s1">error_cov_types):</span>
        <span class="s1">kwargs = dict(zip(names</span><span class="s2">, </span><span class="s1">element))</span>

        <span class="s1">mod = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod2 = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                                            <span class="s1">**mod._get_init_kwds())</span>
        <span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2)</span>


<span class="s2">def </span><span class="s1">test_append_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">200</span><span class="s1">).reshape(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">exog = np.ones(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">params = [</span><span class="s5">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">]</span>

    <span class="s1">mod1 = dynamic_factor.DynamicFactor(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = dynamic_factor.DynamicFactor(</span>
        <span class="s1">endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s1">res3 = res2.append(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_equal(res1.specification</span><span class="s2">, </span><span class="s1">res3.specification)</span>

    <span class="s1">assert_allclose(res3.cov_params_default</span><span class="s2">, </span><span class="s1">res2.cov_params_default)</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'llf'</span><span class="s2">, </span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_extend_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">200</span><span class="s1">).reshape(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">exog = np.ones(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">params = [</span><span class="s5">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">]</span>

    <span class="s1">mod1 = dynamic_factor.DynamicFactor(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = dynamic_factor.DynamicFactor(</span>
        <span class="s1">endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s1">res3 = res2.extend(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_allclose(res3.llf_obs</span><span class="s2">, </span><span class="s1">res1.llf_obs[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">desired = getattr(res1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">desired </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">desired = desired[...</span><span class="s2">, </span><span class="s5">50</span><span class="s1">:]</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_apply_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">200</span><span class="s1">).reshape(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">exog = np.ones(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">params = [</span><span class="s5">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">]</span>

    <span class="s1">mod1 = dynamic_factor.DynamicFactor(</span>
        <span class="s1">endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = dynamic_factor.DynamicFactor(</span>
        <span class="s1">endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>

    <span class="s1">res3 = res2.apply(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>

    <span class="s1">assert_equal(res1.specification</span><span class="s2">, </span><span class="s1">res3.specification)</span>

    <span class="s1">assert_allclose(res3.cov_params_default</span><span class="s2">, </span><span class="s1">res2.cov_params_default)</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'llf'</span><span class="s2">, </span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_start_params_nans():</span>
    <span class="s1">ix = pd.date_range(</span><span class="s3">'1960-01-01'</span><span class="s2">, </span><span class="s3">'1982-10-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">)</span>
    <span class="s1">dta = np.log(pd.DataFrame(</span>
        <span class="s1">results_varmax.lutkepohl_data</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">'inv'</span><span class="s2">, </span><span class="s3">'inc'</span><span class="s2">, </span><span class="s3">'consump'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">index=ix)).diff().iloc[</span><span class="s5">1</span><span class="s1">:]</span>

    <span class="s1">endog1 = dta.iloc[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">mod1 = dynamic_factor.DynamicFactor(endog1</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">endog2 = dta.copy()</span>
    <span class="s1">endog2.iloc[-</span><span class="s5">1</span><span class="s1">:] = np.nan</span>
    <span class="s1">mod2 = dynamic_factor.DynamicFactor(endog2</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">assert_allclose(mod2.start_params</span><span class="s2">, </span><span class="s1">mod1.start_params)</span>
</pre>
</body>
</html>