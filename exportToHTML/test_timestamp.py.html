<html>
<head>
<title>test_timestamp.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_timestamp.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; test the scalar Timestamp &quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">calendar</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
    <span class="s1">timezone</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">locale</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">unicodedata</span>

<span class="s2">from </span><span class="s1">dateutil.tz </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">tzlocal</span><span class="s2">,</span>
    <span class="s1">tzutc</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">hypothesis </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">given</span><span class="s2">,</span>
    <span class="s1">strategies </span><span class="s2">as </span><span class="s1">st</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">pytz</span>
<span class="s2">from </span><span class="s1">pytz </span><span class="s2">import </span><span class="s1">utc</span>

<span class="s2">from </span><span class="s1">pandas._libs.tslibs.dtypes </span><span class="s2">import </span><span class="s1">NpyDatetimeUnit</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.timezones </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">dateutil_gettz </span><span class="s2">as </span><span class="s1">gettz</span><span class="s2">,</span>
    <span class="s1">get_timezone</span><span class="s2">,</span>
    <span class="s1">maybe_get_tz</span><span class="s2">,</span>
    <span class="s1">tz_compare</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.compat </span><span class="s2">import </span><span class="s1">IS64</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">OutOfBoundsDatetime</span>
<span class="s2">import </span><span class="s1">pandas.util._test_decorators </span><span class="s2">as </span><span class="s1">td</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>

<span class="s2">from </span><span class="s1">pandas.tseries </span><span class="s2">import </span><span class="s1">offsets</span>
<span class="s2">from </span><span class="s1">pandas.tseries.frequencies </span><span class="s2">import </span><span class="s1">to_offset</span>


<span class="s2">class </span><span class="s1">TestTimestampProperties:</span>
    <span class="s2">def </span><span class="s1">test_properties_business(self):</span>
        <span class="s1">freq = to_offset(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>

        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2017-10-01&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts.dayofweek == </span><span class="s4">6</span>
        <span class="s2">assert </span><span class="s1">ts.day_of_week == </span><span class="s4">6</span>
        <span class="s2">assert </span><span class="s1">ts.is_month_start  </span><span class="s5"># not a weekday</span>
        <span class="s2">assert not </span><span class="s1">freq.is_month_start(ts)</span>
        <span class="s2">assert </span><span class="s1">freq.is_month_start(ts + Timedelta(days=</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">assert not </span><span class="s1">freq.is_quarter_start(ts)</span>
        <span class="s2">assert </span><span class="s1">freq.is_quarter_start(ts + Timedelta(days=</span><span class="s4">1</span><span class="s1">))</span>

        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2017-09-30&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts.dayofweek == </span><span class="s4">5</span>
        <span class="s2">assert </span><span class="s1">ts.day_of_week == </span><span class="s4">5</span>
        <span class="s2">assert </span><span class="s1">ts.is_month_end</span>
        <span class="s2">assert not </span><span class="s1">freq.is_month_end(ts)</span>
        <span class="s2">assert </span><span class="s1">freq.is_month_end(ts - Timedelta(days=</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">ts.is_quarter_end</span>
        <span class="s2">assert not </span><span class="s1">freq.is_quarter_end(ts)</span>
        <span class="s2">assert </span><span class="s1">freq.is_quarter_end(ts - Timedelta(days=</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;attr, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s4">2014</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;day&quot;</span><span class="s2">, </span><span class="s4">31</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;hour&quot;</span><span class="s2">, </span><span class="s4">23</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;minute&quot;</span><span class="s2">, </span><span class="s4">59</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;second&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;microsecond&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;nanosecond&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;dayofweek&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;day_of_week&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;quarter&quot;</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;dayofyear&quot;</span><span class="s2">, </span><span class="s4">365</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;day_of_year&quot;</span><span class="s2">, </span><span class="s4">365</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;week&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;daysinmonth&quot;</span><span class="s2">, </span><span class="s4">31</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fields(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s5"># GH 10050</span>
        <span class="s5"># GH 13303</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2014-12-31 23:59:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">result = getattr(ts</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s5"># that we are int like</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">int)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_millisecond_raises(self</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2014-12-31 23:59:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">msg = </span><span class="s3">&quot;'Timestamp' object has no attribute 'millisecond'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts.millisecond</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;start&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;is_month_start&quot;</span><span class="s2">, </span><span class="s3">&quot;is_quarter_start&quot;</span><span class="s2">, </span><span class="s3">&quot;is_year_start&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_is_start(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2014-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">assert </span><span class="s1">getattr(ts</span><span class="s2">, </span><span class="s1">start)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;end&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;is_month_end&quot;</span><span class="s2">, </span><span class="s3">&quot;is_year_end&quot;</span><span class="s2">, </span><span class="s3">&quot;is_quarter_end&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_is_end(self</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2014-12-31 23:59:59&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">assert </span><span class="s1">getattr(ts</span><span class="s2">, </span><span class="s1">end)</span>

    <span class="s5"># GH 12806</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;data&quot;</span><span class="s2">,</span>
        <span class="s1">[Timestamp(</span><span class="s3">&quot;2017-08-28 23:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2017-08-28 23:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;EST&quot;</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s5"># error: Unsupported operand types for + (&quot;List[None]&quot; and &quot;List[str]&quot;)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;time_locale&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None</span><span class="s1">] + tm.get_locales()  </span><span class="s5"># type: ignore[operator]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_names(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">time_locale):</span>
        <span class="s5"># GH 17354</span>
        <span class="s5"># Test .day_name(), .month_name</span>
        <span class="s2">if </span><span class="s1">time_locale </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">expected_day = </span><span class="s3">&quot;Monday&quot;</span>
            <span class="s1">expected_month = </span><span class="s3">&quot;August&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">tm.set_locale(time_locale</span><span class="s2">, </span><span class="s1">locale.LC_TIME):</span>
                <span class="s1">expected_day = calendar.day_name[</span><span class="s4">0</span><span class="s1">].capitalize()</span>
                <span class="s1">expected_month = calendar.month_name[</span><span class="s4">8</span><span class="s1">].capitalize()</span>

        <span class="s1">result_day = data.day_name(time_locale)</span>
        <span class="s1">result_month = data.month_name(time_locale)</span>

        <span class="s5"># Work around https://github.com/pandas-dev/pandas/issues/22342</span>
        <span class="s5"># different normalizations</span>
        <span class="s1">expected_day = unicodedata.normalize(</span><span class="s3">&quot;NFD&quot;</span><span class="s2">, </span><span class="s1">expected_day)</span>
        <span class="s1">expected_month = unicodedata.normalize(</span><span class="s3">&quot;NFD&quot;</span><span class="s2">, </span><span class="s1">expected_month)</span>

        <span class="s1">result_day = unicodedata.normalize(</span><span class="s3">&quot;NFD&quot;</span><span class="s2">, </span><span class="s1">result_day)</span>
        <span class="s1">result_month = unicodedata.normalize(</span><span class="s3">&quot;NFD&quot;</span><span class="s2">, </span><span class="s1">result_month)</span>

        <span class="s2">assert </span><span class="s1">result_day == expected_day</span>
        <span class="s2">assert </span><span class="s1">result_month == expected_month</span>

        <span class="s5"># Test NaT</span>
        <span class="s1">nan_ts = Timestamp(NaT)</span>
        <span class="s2">assert </span><span class="s1">np.isnan(nan_ts.day_name(time_locale))</span>
        <span class="s2">assert </span><span class="s1">np.isnan(nan_ts.month_name(time_locale))</span>

    <span class="s2">def </span><span class="s1">test_is_leap_year(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s2">if not </span><span class="s1">IS64 </span><span class="s2">and </span><span class="s1">tz == tzlocal():</span>
            <span class="s5"># https://github.com/dateutil/dateutil/issues/197</span>
            <span class="s1">pytest.skip(</span>
                <span class="s3">&quot;tzlocal() on a 32 bit platform causes internal overflow errors&quot;</span>
            <span class="s1">)</span>
        <span class="s5"># GH 13727</span>
        <span class="s1">dt = Timestamp(</span><span class="s3">&quot;2000-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">assert </span><span class="s1">dt.is_leap_year</span>
        <span class="s2">assert </span><span class="s1">isinstance(dt.is_leap_year</span><span class="s2">, </span><span class="s1">bool)</span>

        <span class="s1">dt = Timestamp(</span><span class="s3">&quot;1999-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">assert not </span><span class="s1">dt.is_leap_year</span>

        <span class="s1">dt = Timestamp(</span><span class="s3">&quot;2004-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">assert </span><span class="s1">dt.is_leap_year</span>

        <span class="s1">dt = Timestamp(</span><span class="s3">&quot;2100-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">assert not </span><span class="s1">dt.is_leap_year</span>

    <span class="s2">def </span><span class="s1">test_woy_boundary(self):</span>
        <span class="s5"># make sure weeks at year boundaries are correct</span>
        <span class="s1">d = datetime(</span><span class="s4">2013</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)</span>
        <span class="s1">result = Timestamp(d).week</span>
        <span class="s1">expected = </span><span class="s4">1  </span><span class="s5"># ISO standard</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">d = datetime(</span><span class="s4">2008</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">28</span><span class="s1">)</span>
        <span class="s1">result = Timestamp(d).week</span>
        <span class="s1">expected = </span><span class="s4">52  </span><span class="s5"># ISO standard</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">d = datetime(</span><span class="s4">2009</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)</span>
        <span class="s1">result = Timestamp(d).week</span>
        <span class="s1">expected = </span><span class="s4">53  </span><span class="s5"># ISO standard</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">d = datetime(</span><span class="s4">2010</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">result = Timestamp(d).week</span>
        <span class="s1">expected = </span><span class="s4">53  </span><span class="s5"># ISO standard</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">d = datetime(</span><span class="s4">2010</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">result = Timestamp(d).week</span>
        <span class="s1">expected = </span><span class="s4">53  </span><span class="s5"># ISO standard</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(datetime(*args)).week</span>
                <span class="s2">for </span><span class="s1">args </span><span class="s2">in </span><span class="s1">[(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2005</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2005</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">(result == [</span><span class="s4">52</span><span class="s2">, </span><span class="s4">52</span><span class="s2">, </span><span class="s4">53</span><span class="s2">, </span><span class="s4">53</span><span class="s1">]).all()</span>

    <span class="s2">def </span><span class="s1">test_resolution(self):</span>
        <span class="s5"># GH#21336, GH#21365</span>
        <span class="s1">dt = Timestamp(</span><span class="s3">&quot;2100-01-01 00:00:00.000000000&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">dt.resolution == Timedelta(nanoseconds=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># Check that the attribute is available on the class, mirroring</span>
        <span class="s5">#  the stdlib datetime behavior</span>
        <span class="s2">assert </span><span class="s1">Timestamp.resolution == Timedelta(nanoseconds=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">dt.as_unit(</span><span class="s3">&quot;us&quot;</span><span class="s1">).resolution == Timedelta(microseconds=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">dt.as_unit(</span><span class="s3">&quot;ms&quot;</span><span class="s1">).resolution == Timedelta(milliseconds=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">dt.as_unit(</span><span class="s3">&quot;s&quot;</span><span class="s1">).resolution == Timedelta(seconds=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date_string, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;0000-2-29&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;0000-3-1&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;1582-10-14&quot;</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;-0040-1-1&quot;</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2023-06-18&quot;</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dow_historic(self</span><span class="s2">, </span><span class="s1">date_string</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s5"># GH 53738</span>
        <span class="s1">ts = Timestamp(date_string)</span>
        <span class="s1">dow = ts.weekday()</span>
        <span class="s2">assert </span><span class="s1">dow == expected</span>

    <span class="s1">@given(</span>
        <span class="s1">ts=st.datetimes()</span><span class="s2">,</span>
        <span class="s1">sign=st.sampled_from([</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dow_parametric(self</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">sign):</span>
        <span class="s5"># GH 53738</span>
        <span class="s1">ts = (</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">sign</span><span class="s2">}{</span><span class="s1">str(ts.year).zfill(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s3">f&quot;-</span><span class="s2">{</span><span class="s1">str(ts.month).zfill(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s3">f&quot;-</span><span class="s2">{</span><span class="s1">str(ts.day).zfill(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
        <span class="s1">result = Timestamp(ts).weekday()</span>
        <span class="s1">expected = (</span>
            <span class="s1">(np.datetime64(ts) - np.datetime64(</span><span class="s3">&quot;1970-01-01&quot;</span><span class="s1">)).astype(</span><span class="s3">&quot;int64&quot;</span><span class="s1">) - </span><span class="s4">4</span>
        <span class="s1">) % </span><span class="s4">7</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">class </span><span class="s1">TestTimestamp:</span>
    <span class="s2">def </span><span class="s1">test_default_to_stdlib_utc(self):</span>
        <span class="s2">assert </span><span class="s1">Timestamp.utcnow().tz </span><span class="s2">is </span><span class="s1">timezone.utc</span>
        <span class="s2">assert </span><span class="s1">Timestamp.now(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).tz </span><span class="s2">is </span><span class="s1">timezone.utc</span>
        <span class="s2">assert </span><span class="s1">Timestamp(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).tz </span><span class="s2">is </span><span class="s1">timezone.utc</span>

    <span class="s2">def </span><span class="s1">test_tz(self):</span>
        <span class="s1">tstr = </span><span class="s3">&quot;2014-02-01 09:00&quot;</span>
        <span class="s1">ts = Timestamp(tstr)</span>
        <span class="s1">local = ts.tz_localize(</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">local.hour == </span><span class="s4">9</span>
        <span class="s2">assert </span><span class="s1">local == Timestamp(tstr</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span>
        <span class="s1">conv = local.tz_convert(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">conv == Timestamp(</span><span class="s3">&quot;2014-01-31 19:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">conv.hour == </span><span class="s4">19</span>

        <span class="s5"># preserves nanosecond</span>
        <span class="s1">ts = Timestamp(tstr) + offsets.Nano(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">local = ts.tz_localize(</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">local.hour == </span><span class="s4">9</span>
        <span class="s2">assert </span><span class="s1">local.nanosecond == </span><span class="s4">5</span>
        <span class="s1">conv = local.tz_convert(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">conv.nanosecond == </span><span class="s4">5</span>
        <span class="s2">assert </span><span class="s1">conv.hour == </span><span class="s4">19</span>

    <span class="s2">def </span><span class="s1">test_utc_z_designator(self):</span>
        <span class="s2">assert </span><span class="s1">get_timezone(Timestamp(</span><span class="s3">&quot;2014-11-02 01:00Z&quot;</span><span class="s1">).tzinfo) </span><span class="s2">is </span><span class="s1">timezone.utc</span>

    <span class="s2">def </span><span class="s1">test_asm8(self):</span>
        <span class="s1">ns = [Timestamp.min._value</span><span class="s2">, </span><span class="s1">Timestamp.max._value</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]</span>

        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">ns:</span>
            <span class="s2">assert </span><span class="s1">(</span>
                <span class="s1">Timestamp(n).asm8.view(</span><span class="s3">&quot;i8&quot;</span><span class="s1">) == np.datetime64(n</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">).view(</span><span class="s3">&quot;i8&quot;</span><span class="s1">) == n</span>
            <span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">Timestamp(</span><span class="s3">&quot;nat&quot;</span><span class="s1">).asm8.view(</span><span class="s3">&quot;i8&quot;</span><span class="s1">) == np.datetime64(</span><span class="s3">&quot;nat&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">).view(</span><span class="s3">&quot;i8&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_class_ops_pytz(self):</span>
        <span class="s2">def </span><span class="s1">compare(x</span><span class="s2">, </span><span class="s1">y):</span>
            <span class="s2">assert </span><span class="s1">int((Timestamp(x)._value - Timestamp(y)._value) / </span><span class="s4">1e9</span><span class="s1">) == </span><span class="s4">0</span>

        <span class="s1">compare(Timestamp.now()</span><span class="s2">, </span><span class="s1">datetime.now())</span>
        <span class="s1">compare(Timestamp.now(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime.now(pytz.timezone(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)))</span>
        <span class="s1">compare(Timestamp.utcnow()</span><span class="s2">, </span><span class="s1">datetime.now(timezone.utc))</span>
        <span class="s1">compare(Timestamp.today()</span><span class="s2">, </span><span class="s1">datetime.today())</span>
        <span class="s1">current_time = calendar.timegm(datetime.now().utctimetuple())</span>

        <span class="s1">ts_utc = Timestamp.utcfromtimestamp(current_time)</span>
        <span class="s2">assert </span><span class="s1">ts_utc.timestamp() == current_time</span>
        <span class="s1">compare(</span>
            <span class="s1">Timestamp.fromtimestamp(current_time)</span><span class="s2">, </span><span class="s1">datetime.fromtimestamp(current_time)</span>
        <span class="s1">)</span>
        <span class="s1">compare(</span>
            <span class="s5"># Support tz kwarg in Timestamp.fromtimestamp</span>
            <span class="s1">Timestamp.fromtimestamp(current_time</span><span class="s2">, </span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime.fromtimestamp(current_time</span><span class="s2">, </span><span class="s1">utc)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">compare(</span>
            <span class="s5"># Support tz kwarg in Timestamp.fromtimestamp</span>
            <span class="s1">Timestamp.fromtimestamp(current_time</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime.fromtimestamp(current_time</span><span class="s2">, </span><span class="s1">utc)</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">date_component = datetime.now(timezone.utc)</span>
        <span class="s1">time_component = (date_component + timedelta(minutes=</span><span class="s4">10</span><span class="s1">)).time()</span>
        <span class="s1">compare(</span>
            <span class="s1">Timestamp.combine(date_component</span><span class="s2">, </span><span class="s1">time_component)</span><span class="s2">,</span>
            <span class="s1">datetime.combine(date_component</span><span class="s2">, </span><span class="s1">time_component)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_class_ops_dateutil(self):</span>
        <span class="s2">def </span><span class="s1">compare(x</span><span class="s2">, </span><span class="s1">y):</span>
            <span class="s2">assert </span><span class="s1">(</span>
                <span class="s1">int(</span>
                    <span class="s1">np.round(Timestamp(x)._value / </span><span class="s4">1e9</span><span class="s1">)</span>
                    <span class="s1">- np.round(Timestamp(y)._value / </span><span class="s4">1e9</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">== </span><span class="s4">0</span>
            <span class="s1">)</span>

        <span class="s1">compare(Timestamp.now()</span><span class="s2">, </span><span class="s1">datetime.now())</span>
        <span class="s1">compare(Timestamp.now(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime.now(tzutc()))</span>
        <span class="s1">compare(Timestamp.utcnow()</span><span class="s2">, </span><span class="s1">datetime.now(timezone.utc))</span>
        <span class="s1">compare(Timestamp.today()</span><span class="s2">, </span><span class="s1">datetime.today())</span>
        <span class="s1">current_time = calendar.timegm(datetime.now().utctimetuple())</span>

        <span class="s1">ts_utc = Timestamp.utcfromtimestamp(current_time)</span>
        <span class="s2">assert </span><span class="s1">ts_utc.timestamp() == current_time</span>

        <span class="s1">compare(</span>
            <span class="s1">Timestamp.fromtimestamp(current_time)</span><span class="s2">, </span><span class="s1">datetime.fromtimestamp(current_time)</span>
        <span class="s1">)</span>

        <span class="s1">date_component = datetime.now(timezone.utc)</span>
        <span class="s1">time_component = (date_component + timedelta(minutes=</span><span class="s4">10</span><span class="s1">)).time()</span>
        <span class="s1">compare(</span>
            <span class="s1">Timestamp.combine(date_component</span><span class="s2">, </span><span class="s1">time_component)</span><span class="s2">,</span>
            <span class="s1">datetime.combine(date_component</span><span class="s2">, </span><span class="s1">time_component)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_basics_nanos(self):</span>
        <span class="s1">val = np.int64(</span><span class="s4">946_684_800_000_000_000</span><span class="s1">).view(</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">stamp = Timestamp(val.view(</span><span class="s3">&quot;i8&quot;</span><span class="s1">) + </span><span class="s4">500</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">stamp.year == </span><span class="s4">2000</span>
        <span class="s2">assert </span><span class="s1">stamp.month == </span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">stamp.microsecond == </span><span class="s4">0</span>
        <span class="s2">assert </span><span class="s1">stamp.nanosecond == </span><span class="s4">500</span>

        <span class="s5"># GH 14415</span>
        <span class="s1">val = np.iinfo(np.int64).min + </span><span class="s4">80_000_000_000_000</span>
        <span class="s1">stamp = Timestamp(val)</span>
        <span class="s2">assert </span><span class="s1">stamp.year == </span><span class="s4">1677</span>
        <span class="s2">assert </span><span class="s1">stamp.month == </span><span class="s4">9</span>
        <span class="s2">assert </span><span class="s1">stamp.day == </span><span class="s4">21</span>
        <span class="s2">assert </span><span class="s1">stamp.microsecond == </span><span class="s4">145224</span>
        <span class="s2">assert </span><span class="s1">stamp.nanosecond == </span><span class="s4">192</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;value, check_kwargs&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">946688461000000000</span><span class="s2">, </span><span class="s1">{}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">946688461000000000 </span><span class="s1">/ </span><span class="s4">1000</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;us&quot;</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">946688461000000000 </span><span class="s1">/ </span><span class="s4">1_000_000</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;ms&quot;</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">946688461000000000 </span><span class="s1">/ </span><span class="s4">1_000_000_000</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;s&quot;</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">10957</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;h&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">(</span><span class="s4">946688461000000000 </span><span class="s1">+ </span><span class="s4">500000</span><span class="s1">) / </span><span class="s4">1000000000</span><span class="s2">,</span>
                <span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">499</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">: </span><span class="s4">964</span><span class="s1">}</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">(</span><span class="s4">946688461000000000 </span><span class="s1">+ </span><span class="s4">500000000</span><span class="s1">) / </span><span class="s4">1000000000</span><span class="s2">,</span>
                <span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">500000</span><span class="s1">}</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[(</span><span class="s4">946688461000000000 </span><span class="s1">+ </span><span class="s4">500000</span><span class="s1">) / </span><span class="s4">1000000</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">500</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[(</span><span class="s4">946688461000000000 </span><span class="s1">+ </span><span class="s4">500000</span><span class="s1">) / </span><span class="s4">1000</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">500</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[(</span><span class="s4">946688461000000000 </span><span class="s1">+ </span><span class="s4">500000000</span><span class="s1">) / </span><span class="s4">1000000</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">500000</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">946688461000000000 </span><span class="s1">/ </span><span class="s4">1000.0 </span><span class="s1">+ </span><span class="s4">5</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">946688461000000000 </span><span class="s1">/ </span><span class="s4">1000.0 </span><span class="s1">+ </span><span class="s4">5000</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">5000</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">946688461000000000 </span><span class="s1">/ </span><span class="s4">1000000.0 </span><span class="s1">+ </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">500</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">946688461000000000 </span><span class="s1">/ </span><span class="s4">1000000.0 </span><span class="s1">+ </span><span class="s4">0.005</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">946688461000000000 </span><span class="s1">/ </span><span class="s4">1000000000.0 </span><span class="s1">+ </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">500000</span><span class="s1">}]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">10957 </span><span class="s1">+ </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;h&quot;</span><span class="s1">: </span><span class="s4">12</span><span class="s1">}]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_unit(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">check_kwargs):</span>
        <span class="s2">def </span><span class="s1">check(value</span><span class="s2">, </span><span class="s1">unit=</span><span class="s2">None, </span><span class="s1">h=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">s=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">us=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">ns=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">stamp = Timestamp(value</span><span class="s2">, </span><span class="s1">unit=unit)</span>
            <span class="s2">assert </span><span class="s1">stamp.year == </span><span class="s4">2000</span>
            <span class="s2">assert </span><span class="s1">stamp.month == </span><span class="s4">1</span>
            <span class="s2">assert </span><span class="s1">stamp.day == </span><span class="s4">1</span>
            <span class="s2">assert </span><span class="s1">stamp.hour == h</span>
            <span class="s2">if </span><span class="s1">unit != </span><span class="s3">&quot;D&quot;</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">stamp.minute == </span><span class="s4">1</span>
                <span class="s2">assert </span><span class="s1">stamp.second == s</span>
                <span class="s2">assert </span><span class="s1">stamp.microsecond == us</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">stamp.minute == </span><span class="s4">0</span>
                <span class="s2">assert </span><span class="s1">stamp.second == </span><span class="s4">0</span>
                <span class="s2">assert </span><span class="s1">stamp.microsecond == </span><span class="s4">0</span>
            <span class="s2">assert </span><span class="s1">stamp.nanosecond == ns</span>

        <span class="s1">check(value</span><span class="s2">, </span><span class="s1">**check_kwargs)</span>

    <span class="s2">def </span><span class="s1">test_roundtrip(self):</span>
        <span class="s5"># test value to string and back conversions</span>
        <span class="s5"># further test accessors</span>
        <span class="s1">base = Timestamp(</span><span class="s3">&quot;20140101 00:00:00&quot;</span><span class="s1">).as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>

        <span class="s1">result = Timestamp(base._value + Timedelta(</span><span class="s3">&quot;5ms&quot;</span><span class="s1">)._value)</span>
        <span class="s2">assert </span><span class="s1">result == Timestamp(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">base</span><span class="s2">}</span><span class="s3">.005000&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.microsecond == </span><span class="s4">5000</span>

        <span class="s1">result = Timestamp(base._value + Timedelta(</span><span class="s3">&quot;5us&quot;</span><span class="s1">)._value)</span>
        <span class="s2">assert </span><span class="s1">result == Timestamp(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">base</span><span class="s2">}</span><span class="s3">.000005&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.microsecond == </span><span class="s4">5</span>

        <span class="s1">result = Timestamp(base._value + Timedelta(</span><span class="s3">&quot;5ns&quot;</span><span class="s1">)._value)</span>
        <span class="s2">assert </span><span class="s1">result == Timestamp(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">base</span><span class="s2">}</span><span class="s3">.000000005&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.nanosecond == </span><span class="s4">5</span>
        <span class="s2">assert </span><span class="s1">result.microsecond == </span><span class="s4">0</span>

        <span class="s1">result = Timestamp(base._value + Timedelta(</span><span class="s3">&quot;6ms 5us&quot;</span><span class="s1">)._value)</span>
        <span class="s2">assert </span><span class="s1">result == Timestamp(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">base</span><span class="s2">}</span><span class="s3">.006005&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.microsecond == </span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">6 </span><span class="s1">* </span><span class="s4">1000</span>

        <span class="s1">result = Timestamp(base._value + Timedelta(</span><span class="s3">&quot;200ms 5us&quot;</span><span class="s1">)._value)</span>
        <span class="s2">assert </span><span class="s1">result == Timestamp(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">base</span><span class="s2">}</span><span class="s3">.200005&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.microsecond == </span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">200 </span><span class="s1">* </span><span class="s4">1000</span>

    <span class="s2">def </span><span class="s1">test_hash_equivalent(self):</span>
        <span class="s1">d = {datetime(</span><span class="s4">2011</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">): </span><span class="s4">5</span><span class="s1">}</span>
        <span class="s1">stamp = Timestamp(datetime(</span><span class="s4">2011</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">d[stamp] == </span><span class="s4">5</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;timezone, year, month, day, hour&quot;</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">&quot;America/Chicago&quot;</span><span class="s2">, </span><span class="s4">2013</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;America/Santiago&quot;</span><span class="s2">, </span><span class="s4">2021</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">23</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_hash_timestamp_with_fold(self</span><span class="s2">, </span><span class="s1">timezone</span><span class="s2">, </span><span class="s1">year</span><span class="s2">, </span><span class="s1">month</span><span class="s2">, </span><span class="s1">day</span><span class="s2">, </span><span class="s1">hour):</span>
        <span class="s5"># see gh-33931</span>
        <span class="s1">test_timezone = gettz(timezone)</span>
        <span class="s1">transition_1 = Timestamp(</span>
            <span class="s1">year=year</span><span class="s2">,</span>
            <span class="s1">month=month</span><span class="s2">,</span>
            <span class="s1">day=day</span><span class="s2">,</span>
            <span class="s1">hour=hour</span><span class="s2">,</span>
            <span class="s1">minute=</span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">fold=</span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">tzinfo=test_timezone</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">transition_2 = Timestamp(</span>
            <span class="s1">year=year</span><span class="s2">,</span>
            <span class="s1">month=month</span><span class="s2">,</span>
            <span class="s1">day=day</span><span class="s2">,</span>
            <span class="s1">hour=hour</span><span class="s2">,</span>
            <span class="s1">minute=</span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">fold=</span><span class="s4">1</span><span class="s2">,</span>
            <span class="s1">tzinfo=test_timezone</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">hash(transition_1) == hash(transition_2)</span>


<span class="s2">class </span><span class="s1">TestTimestampNsOperations:</span>
    <span class="s2">def </span><span class="s1">test_nanosecond_string_parsing(self):</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2013-05-01 07:15:45.123456789&quot;</span><span class="s1">)</span>
        <span class="s5"># GH 7878</span>
        <span class="s1">expected_repr = </span><span class="s3">&quot;2013-05-01 07:15:45.123456789&quot;</span>
        <span class="s1">expected_value = </span><span class="s4">1_367_392_545_123_456_789</span>
        <span class="s2">assert </span><span class="s1">ts._value == expected_value</span>
        <span class="s2">assert </span><span class="s1">expected_repr </span><span class="s2">in </span><span class="s1">repr(ts)</span>

        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2013-05-01 07:15:45.123456789+09:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts._value == expected_value - </span><span class="s4">9 </span><span class="s1">* </span><span class="s4">3600 </span><span class="s1">* </span><span class="s4">1_000_000_000</span>
        <span class="s2">assert </span><span class="s1">expected_repr </span><span class="s2">in </span><span class="s1">repr(ts)</span>

        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2013-05-01 07:15:45.123456789&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts._value == expected_value</span>
        <span class="s2">assert </span><span class="s1">expected_repr </span><span class="s2">in </span><span class="s1">repr(ts)</span>

        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2013-05-01 07:15:45.123456789&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts._value == expected_value + </span><span class="s4">4 </span><span class="s1">* </span><span class="s4">3600 </span><span class="s1">* </span><span class="s4">1_000_000_000</span>
        <span class="s2">assert </span><span class="s1">expected_repr </span><span class="s2">in </span><span class="s1">repr(ts)</span>

        <span class="s5"># GH 10041</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;20130501T071545.123456789&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts._value == expected_value</span>
        <span class="s2">assert </span><span class="s1">expected_repr </span><span class="s2">in </span><span class="s1">repr(ts)</span>

    <span class="s2">def </span><span class="s1">test_nanosecond_timestamp(self):</span>
        <span class="s5"># GH 7610</span>
        <span class="s1">expected = </span><span class="s4">1_293_840_000_000_000_005</span>
        <span class="s1">t = Timestamp(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s1">) + offsets.Nano(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">repr(t) == </span><span class="s3">&quot;Timestamp('2011-01-01 00:00:00.000000005')&quot;</span>
        <span class="s2">assert </span><span class="s1">t._value == expected</span>
        <span class="s2">assert </span><span class="s1">t.nanosecond == </span><span class="s4">5</span>

        <span class="s1">t = Timestamp(t)</span>
        <span class="s2">assert </span><span class="s1">repr(t) == </span><span class="s3">&quot;Timestamp('2011-01-01 00:00:00.000000005')&quot;</span>
        <span class="s2">assert </span><span class="s1">t._value == expected</span>
        <span class="s2">assert </span><span class="s1">t.nanosecond == </span><span class="s4">5</span>

        <span class="s1">t = Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00.000000005&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">repr(t) == </span><span class="s3">&quot;Timestamp('2011-01-01 00:00:00.000000005')&quot;</span>
        <span class="s2">assert </span><span class="s1">t._value == expected</span>
        <span class="s2">assert </span><span class="s1">t.nanosecond == </span><span class="s4">5</span>

        <span class="s1">expected = </span><span class="s4">1_293_840_000_000_000_010</span>
        <span class="s1">t = t + offsets.Nano(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">repr(t) == </span><span class="s3">&quot;Timestamp('2011-01-01 00:00:00.000000010')&quot;</span>
        <span class="s2">assert </span><span class="s1">t._value == expected</span>
        <span class="s2">assert </span><span class="s1">t.nanosecond == </span><span class="s4">10</span>

        <span class="s1">t = Timestamp(t)</span>
        <span class="s2">assert </span><span class="s1">repr(t) == </span><span class="s3">&quot;Timestamp('2011-01-01 00:00:00.000000010')&quot;</span>
        <span class="s2">assert </span><span class="s1">t._value == expected</span>
        <span class="s2">assert </span><span class="s1">t.nanosecond == </span><span class="s4">10</span>

        <span class="s1">t = Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00.000000010&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">repr(t) == </span><span class="s3">&quot;Timestamp('2011-01-01 00:00:00.000000010')&quot;</span>
        <span class="s2">assert </span><span class="s1">t._value == expected</span>
        <span class="s2">assert </span><span class="s1">t.nanosecond == </span><span class="s4">10</span>


<span class="s2">class </span><span class="s1">TestTimestampToJulianDate:</span>
    <span class="s2">def </span><span class="s1">test_compare_1700(self):</span>
        <span class="s1">r = Timestamp(</span><span class="s3">&quot;1700-06-23&quot;</span><span class="s1">).to_julian_date()</span>
        <span class="s2">assert </span><span class="s1">r == </span><span class="s4">2_342_145.5</span>

    <span class="s2">def </span><span class="s1">test_compare_2000(self):</span>
        <span class="s1">r = Timestamp(</span><span class="s3">&quot;2000-04-12&quot;</span><span class="s1">).to_julian_date()</span>
        <span class="s2">assert </span><span class="s1">r == </span><span class="s4">2_451_646.5</span>

    <span class="s2">def </span><span class="s1">test_compare_2100(self):</span>
        <span class="s1">r = Timestamp(</span><span class="s3">&quot;2100-08-12&quot;</span><span class="s1">).to_julian_date()</span>
        <span class="s2">assert </span><span class="s1">r == </span><span class="s4">2_488_292.5</span>

    <span class="s2">def </span><span class="s1">test_compare_hour01(self):</span>
        <span class="s1">r = Timestamp(</span><span class="s3">&quot;2000-08-12T01:00:00&quot;</span><span class="s1">).to_julian_date()</span>
        <span class="s2">assert </span><span class="s1">r == </span><span class="s4">2_451_768.5416666666666666</span>

    <span class="s2">def </span><span class="s1">test_compare_hour13(self):</span>
        <span class="s1">r = Timestamp(</span><span class="s3">&quot;2000-08-12T13:00:00&quot;</span><span class="s1">).to_julian_date()</span>
        <span class="s2">assert </span><span class="s1">r == </span><span class="s4">2_451_769.0416666666666666</span>


<span class="s2">class </span><span class="s1">TestTimestampConversion:</span>
    <span class="s2">def </span><span class="s1">test_conversion(self):</span>
        <span class="s5"># GH#9255</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s1">).as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>

        <span class="s1">result = ts.to_pydatetime()</span>
        <span class="s1">expected = datetime(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>
        <span class="s2">assert </span><span class="s1">type(result) == type(expected)</span>

        <span class="s1">result = ts.to_datetime64()</span>
        <span class="s1">expected = np.datetime64(ts._value</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>
        <span class="s2">assert </span><span class="s1">type(result) == type(expected)</span>
        <span class="s2">assert </span><span class="s1">result.dtype == expected.dtype</span>

    <span class="s2">def </span><span class="s1">test_to_pydatetime_fold(self):</span>
        <span class="s5"># GH#45087</span>
        <span class="s1">tzstr = </span><span class="s3">&quot;dateutil/usr/share/zoneinfo/America/Chicago&quot;</span>
        <span class="s1">ts = Timestamp(year=</span><span class="s4">2013</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">11</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">hour=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">minute=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fold=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=tzstr)</span>
        <span class="s1">dt = ts.to_pydatetime()</span>
        <span class="s2">assert </span><span class="s1">dt.fold == </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">test_to_pydatetime_nonzero_nano(self):</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2011-01-01 9:00:00.123456789&quot;</span><span class="s1">)</span>

        <span class="s5"># Warn the user of data loss (nanoseconds).</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning):</span>
            <span class="s1">expected = datetime(</span><span class="s4">2011</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">123456</span><span class="s1">)</span>
            <span class="s1">result = ts.to_pydatetime()</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_timestamp_to_datetime(self):</span>
        <span class="s1">stamp = Timestamp(</span><span class="s3">&quot;20090415&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">dtval = stamp.to_pydatetime()</span>
        <span class="s2">assert </span><span class="s1">stamp == dtval</span>
        <span class="s2">assert </span><span class="s1">stamp.tzinfo == dtval.tzinfo</span>

    <span class="s2">def </span><span class="s1">test_timestamp_to_datetime_dateutil(self):</span>
        <span class="s1">stamp = Timestamp(</span><span class="s3">&quot;20090415&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;dateutil/US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">dtval = stamp.to_pydatetime()</span>
        <span class="s2">assert </span><span class="s1">stamp == dtval</span>
        <span class="s2">assert </span><span class="s1">stamp.tzinfo == dtval.tzinfo</span>

    <span class="s2">def </span><span class="s1">test_timestamp_to_datetime_explicit_pytz(self):</span>
        <span class="s1">stamp = Timestamp(</span><span class="s3">&quot;20090415&quot;</span><span class="s2">, </span><span class="s1">tz=pytz.timezone(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">))</span>
        <span class="s1">dtval = stamp.to_pydatetime()</span>
        <span class="s2">assert </span><span class="s1">stamp == dtval</span>
        <span class="s2">assert </span><span class="s1">stamp.tzinfo == dtval.tzinfo</span>

    <span class="s1">@td.skip_if_windows</span>
    <span class="s2">def </span><span class="s1">test_timestamp_to_datetime_explicit_dateutil(self):</span>
        <span class="s1">stamp = Timestamp(</span><span class="s3">&quot;20090415&quot;</span><span class="s2">, </span><span class="s1">tz=gettz(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">))</span>
        <span class="s1">dtval = stamp.to_pydatetime()</span>
        <span class="s2">assert </span><span class="s1">stamp == dtval</span>
        <span class="s2">assert </span><span class="s1">stamp.tzinfo == dtval.tzinfo</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_bijective(self):</span>
        <span class="s5"># Ensure that converting to datetime and back only loses precision</span>
        <span class="s5"># by going from nanoseconds to microseconds.</span>
        <span class="s1">exp_warning = </span><span class="s2">None if </span><span class="s1">Timestamp.max.nanosecond == </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">UserWarning</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(exp_warning):</span>
            <span class="s1">pydt_max = Timestamp.max.to_pydatetime()</span>

        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">Timestamp(pydt_max).as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)._value / </span><span class="s4">1000</span>
            <span class="s1">== Timestamp.max._value / </span><span class="s4">1000</span>
        <span class="s1">)</span>

        <span class="s1">exp_warning = </span><span class="s2">None if </span><span class="s1">Timestamp.min.nanosecond == </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">UserWarning</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(exp_warning):</span>
            <span class="s1">pydt_min = Timestamp.min.to_pydatetime()</span>

        <span class="s5"># The next assertion can be enabled once GH#39221 is merged</span>
        <span class="s5">#  assert pydt_min &lt; Timestamp.min  # this is bc nanos are dropped</span>
        <span class="s1">tdus = timedelta(microseconds=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">pydt_min + tdus &gt; Timestamp.min</span>

        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">Timestamp(pydt_min + tdus).as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)._value / </span><span class="s4">1000</span>
            <span class="s1">== Timestamp.min._value / </span><span class="s4">1000</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_period_tz_warning(self):</span>
        <span class="s5"># GH#21333 make sure a warning is issued when timezone</span>
        <span class="s5"># info is lost</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2009-04-15 16:17:18&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning):</span>
            <span class="s5"># warning that timezone info will be lost</span>
            <span class="s1">ts.to_period(</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_numpy_alias(self):</span>
        <span class="s5"># GH 24653: alias .to_numpy() for scalars</span>
        <span class="s1">ts = Timestamp(datetime.now())</span>
        <span class="s2">assert </span><span class="s1">ts.to_datetime64() == ts.to_numpy()</span>

        <span class="s5"># GH#44460</span>
        <span class="s1">msg = </span><span class="s3">&quot;dtype and copy arguments are ignored&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts.to_numpy(</span><span class="s3">&quot;M8[s]&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts.to_numpy(copy=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">SubDatetime(datetime):</span>
    <span class="s2">pass</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;lh,rh&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(SubDatetime(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timedelta(hours=</span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(Timedelta(hours=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">SubDatetime(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dt_subclass_add_timedelta(lh</span><span class="s2">, </span><span class="s1">rh):</span>
    <span class="s5"># GH#25851</span>
    <span class="s5"># ensure that subclassed datetime works for</span>
    <span class="s5"># Timedelta operations</span>
    <span class="s1">result = lh + rh</span>
    <span class="s1">expected = SubDatetime(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">class </span><span class="s1">TestNonNano:</span>
    <span class="s1">@pytest.fixture(params=[</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">reso(self</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">return </span><span class="s1">request.param</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">dt64(self</span><span class="s2">, </span><span class="s1">reso):</span>
        <span class="s5"># cases that are in-bounds for nanosecond, so we can compare against</span>
        <span class="s5">#  the existing implementation.</span>
        <span class="s2">return </span><span class="s1">np.datetime64(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">reso)</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">ts(self</span><span class="s2">, </span><span class="s1">dt64):</span>
        <span class="s2">return </span><span class="s1">Timestamp._from_dt64(dt64)</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">ts_tz(self</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">tz_aware_fixture):</span>
        <span class="s1">tz = maybe_get_tz(tz_aware_fixture)</span>
        <span class="s2">return </span><span class="s1">Timestamp._from_value_and_reso(ts._value</span><span class="s2">, </span><span class="s1">ts._creso</span><span class="s2">, </span><span class="s1">tz)</span>

    <span class="s2">def </span><span class="s1">test_non_nano_construction(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">reso):</span>
        <span class="s2">assert </span><span class="s1">ts._value == dt64.view(</span><span class="s3">&quot;i8&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">reso == </span><span class="s3">&quot;s&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">ts._creso == NpyDatetimeUnit.NPY_FR_s.value</span>
        <span class="s2">elif </span><span class="s1">reso == </span><span class="s3">&quot;ms&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">ts._creso == NpyDatetimeUnit.NPY_FR_ms.value</span>
        <span class="s2">elif </span><span class="s1">reso == </span><span class="s3">&quot;us&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">ts._creso == NpyDatetimeUnit.NPY_FR_us.value</span>

    <span class="s2">def </span><span class="s1">test_non_nano_fields(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">alt = Timestamp(dt64)</span>

        <span class="s2">assert </span><span class="s1">ts.year == alt.year</span>
        <span class="s2">assert </span><span class="s1">ts.month == alt.month</span>
        <span class="s2">assert </span><span class="s1">ts.day == alt.day</span>
        <span class="s2">assert </span><span class="s1">ts.hour == ts.minute == ts.second == ts.microsecond == </span><span class="s4">0</span>
        <span class="s2">assert </span><span class="s1">ts.nanosecond == </span><span class="s4">0</span>

        <span class="s2">assert </span><span class="s1">ts.to_julian_date() == alt.to_julian_date()</span>
        <span class="s2">assert </span><span class="s1">ts.weekday() == alt.weekday()</span>
        <span class="s2">assert </span><span class="s1">ts.isoweekday() == alt.isoweekday()</span>

    <span class="s2">def </span><span class="s1">test_start_end_fields(self</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s2">assert </span><span class="s1">ts.is_year_start</span>
        <span class="s2">assert </span><span class="s1">ts.is_quarter_start</span>
        <span class="s2">assert </span><span class="s1">ts.is_month_start</span>
        <span class="s2">assert not </span><span class="s1">ts.is_year_end</span>
        <span class="s2">assert not </span><span class="s1">ts.is_month_end</span>
        <span class="s2">assert not </span><span class="s1">ts.is_month_end</span>

        <span class="s5"># 2016-01-01 is a Friday, so is year/quarter/month start with this freq</span>
        <span class="s2">assert </span><span class="s1">ts.is_year_start</span>
        <span class="s2">assert </span><span class="s1">ts.is_quarter_start</span>
        <span class="s2">assert </span><span class="s1">ts.is_month_start</span>
        <span class="s2">assert not </span><span class="s1">ts.is_year_end</span>
        <span class="s2">assert not </span><span class="s1">ts.is_month_end</span>
        <span class="s2">assert not </span><span class="s1">ts.is_month_end</span>

    <span class="s2">def </span><span class="s1">test_day_name(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">alt = Timestamp(dt64)</span>
        <span class="s2">assert </span><span class="s1">ts.day_name() == alt.day_name()</span>

    <span class="s2">def </span><span class="s1">test_month_name(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">alt = Timestamp(dt64)</span>
        <span class="s2">assert </span><span class="s1">ts.month_name() == alt.month_name()</span>

    <span class="s2">def </span><span class="s1">test_tz_convert(self</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">ts = Timestamp._from_value_and_reso(ts._value</span><span class="s2">, </span><span class="s1">ts._creso</span><span class="s2">, </span><span class="s1">utc)</span>

        <span class="s1">tz = pytz.timezone(</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span>
        <span class="s1">result = ts.tz_convert(tz)</span>

        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result._creso == ts._creso</span>
        <span class="s2">assert </span><span class="s1">tz_compare(result.tz</span><span class="s2">, </span><span class="s1">tz)</span>

    <span class="s2">def </span><span class="s1">test_repr(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">alt = Timestamp(dt64)</span>

        <span class="s2">assert </span><span class="s1">str(ts) == str(alt)</span>
        <span class="s2">assert </span><span class="s1">repr(ts) == repr(alt)</span>

    <span class="s2">def </span><span class="s1">test_comparison(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">alt = Timestamp(dt64)</span>

        <span class="s2">assert </span><span class="s1">ts == dt64</span>
        <span class="s2">assert </span><span class="s1">dt64 == ts</span>
        <span class="s2">assert </span><span class="s1">ts == alt</span>
        <span class="s2">assert </span><span class="s1">alt == ts</span>

        <span class="s2">assert not </span><span class="s1">ts != dt64</span>
        <span class="s2">assert not </span><span class="s1">dt64 != ts</span>
        <span class="s2">assert not </span><span class="s1">ts != alt</span>
        <span class="s2">assert not </span><span class="s1">alt != ts</span>

        <span class="s2">assert not </span><span class="s1">ts &lt; dt64</span>
        <span class="s2">assert not </span><span class="s1">dt64 &lt; ts</span>
        <span class="s2">assert not </span><span class="s1">ts &lt; alt</span>
        <span class="s2">assert not </span><span class="s1">alt &lt; ts</span>

        <span class="s2">assert not </span><span class="s1">ts &gt; dt64</span>
        <span class="s2">assert not </span><span class="s1">dt64 &gt; ts</span>
        <span class="s2">assert not </span><span class="s1">ts &gt; alt</span>
        <span class="s2">assert not </span><span class="s1">alt &gt; ts</span>

        <span class="s2">assert </span><span class="s1">ts &gt;= dt64</span>
        <span class="s2">assert </span><span class="s1">dt64 &gt;= ts</span>
        <span class="s2">assert </span><span class="s1">ts &gt;= alt</span>
        <span class="s2">assert </span><span class="s1">alt &gt;= ts</span>

        <span class="s2">assert </span><span class="s1">ts &lt;= dt64</span>
        <span class="s2">assert </span><span class="s1">dt64 &lt;= ts</span>
        <span class="s2">assert </span><span class="s1">ts &lt;= alt</span>
        <span class="s2">assert </span><span class="s1">alt &lt;= ts</span>

    <span class="s2">def </span><span class="s1">test_cmp_cross_reso(self):</span>
        <span class="s5"># numpy gets this wrong because of silent overflow</span>
        <span class="s1">dt64 = np.datetime64(</span><span class="s4">9223372800</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s1">)  </span><span class="s5"># won't fit in M8[ns]</span>
        <span class="s1">ts = Timestamp._from_dt64(dt64)</span>

        <span class="s5"># subtracting 3600*24 gives a datetime64 that _can_ fit inside the</span>
        <span class="s5">#  nanosecond implementation bounds.</span>
        <span class="s1">other = Timestamp(dt64 - </span><span class="s4">3600 </span><span class="s1">* </span><span class="s4">24</span><span class="s1">).as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">other &lt; ts</span>
        <span class="s2">assert </span><span class="s1">other.asm8 &gt; ts.asm8  </span><span class="s5"># &lt;- numpy gets this wrong</span>
        <span class="s2">assert </span><span class="s1">ts &gt; other</span>
        <span class="s2">assert </span><span class="s1">ts.asm8 &lt; other.asm8  </span><span class="s5"># &lt;- numpy gets this wrong</span>
        <span class="s2">assert not </span><span class="s1">other == ts</span>
        <span class="s2">assert </span><span class="s1">ts != other</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s3">&quot;Dispatches to np.datetime64 which is wrong&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_cmp_cross_reso_reversed_dt64(self):</span>
        <span class="s1">dt64 = np.datetime64(</span><span class="s4">106752</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)  </span><span class="s5"># won't fit in M8[ns]</span>
        <span class="s1">ts = Timestamp._from_dt64(dt64)</span>
        <span class="s1">other = Timestamp(dt64 - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">other.asm8 &lt; ts</span>

    <span class="s2">def </span><span class="s1">test_pickle(self</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">tz_aware_fixture):</span>
        <span class="s1">tz = tz_aware_fixture</span>
        <span class="s1">tz = maybe_get_tz(tz)</span>
        <span class="s1">ts = Timestamp._from_value_and_reso(ts._value</span><span class="s2">, </span><span class="s1">ts._creso</span><span class="s2">, </span><span class="s1">tz)</span>
        <span class="s1">rt = tm.round_trip_pickle(ts)</span>
        <span class="s2">assert </span><span class="s1">rt._creso == ts._creso</span>
        <span class="s2">assert </span><span class="s1">rt == ts</span>

    <span class="s2">def </span><span class="s1">test_normalize(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">alt = Timestamp(dt64)</span>
        <span class="s1">result = ts.normalize()</span>
        <span class="s2">assert </span><span class="s1">result._creso == ts._creso</span>
        <span class="s2">assert </span><span class="s1">result == alt.normalize()</span>

    <span class="s2">def </span><span class="s1">test_asm8(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">rt = ts.asm8</span>
        <span class="s2">assert </span><span class="s1">rt == dt64</span>
        <span class="s2">assert </span><span class="s1">rt.dtype == dt64.dtype</span>

    <span class="s2">def </span><span class="s1">test_to_numpy(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">res = ts.to_numpy()</span>
        <span class="s2">assert </span><span class="s1">res == dt64</span>
        <span class="s2">assert </span><span class="s1">res.dtype == dt64.dtype</span>

    <span class="s2">def </span><span class="s1">test_to_datetime64(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">res = ts.to_datetime64()</span>
        <span class="s2">assert </span><span class="s1">res == dt64</span>
        <span class="s2">assert </span><span class="s1">res.dtype == dt64.dtype</span>

    <span class="s2">def </span><span class="s1">test_timestamp(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">alt = Timestamp(dt64)</span>
        <span class="s2">assert </span><span class="s1">ts.timestamp() == alt.timestamp()</span>

    <span class="s2">def </span><span class="s1">test_to_period(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">alt = Timestamp(dt64)</span>
        <span class="s2">assert </span><span class="s1">ts.to_period(</span><span class="s3">&quot;D&quot;</span><span class="s1">) == alt.to_period(</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;td&quot;</span><span class="s2">, </span><span class="s1">[timedelta(days=</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timedelta(days=</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.timedelta64(</span><span class="s4">4</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_addsub_timedeltalike_non_nano(self</span><span class="s2">, </span><span class="s1">dt64</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">td):</span>
        <span class="s1">exp_reso = max(ts._creso</span><span class="s2">, </span><span class="s1">Timedelta(td)._creso)</span>

        <span class="s1">result = ts - td</span>
        <span class="s1">expected = Timestamp(dt64) - td</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result._creso == exp_reso</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = ts + td</span>
        <span class="s1">expected = Timestamp(dt64) + td</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result._creso == exp_reso</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = td + ts</span>
        <span class="s1">expected = td + Timestamp(dt64)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result._creso == exp_reso</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_addsub_offset(self</span><span class="s2">, </span><span class="s1">ts_tz):</span>
        <span class="s5"># specifically non-Tick offset</span>
        <span class="s1">off = offsets.YearEnd(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">result = ts_tz + off</span>

        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result._creso == ts_tz._creso</span>
        <span class="s2">if </span><span class="s1">ts_tz.month == </span><span class="s4">12 </span><span class="s2">and </span><span class="s1">ts_tz.day == </span><span class="s4">31</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">result.year == ts_tz.year + </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">result.year == ts_tz.year</span>
        <span class="s2">assert </span><span class="s1">result.day == </span><span class="s4">31</span>
        <span class="s2">assert </span><span class="s1">result.month == </span><span class="s4">12</span>
        <span class="s2">assert </span><span class="s1">tz_compare(result.tz</span><span class="s2">, </span><span class="s1">ts_tz.tz)</span>

        <span class="s1">result = ts_tz - off</span>

        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result._creso == ts_tz._creso</span>
        <span class="s2">assert </span><span class="s1">result.year == ts_tz.year - </span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">result.day == </span><span class="s4">31</span>
        <span class="s2">assert </span><span class="s1">result.month == </span><span class="s4">12</span>
        <span class="s2">assert </span><span class="s1">tz_compare(result.tz</span><span class="s2">, </span><span class="s1">ts_tz.tz)</span>

    <span class="s2">def </span><span class="s1">test_sub_datetimelike_mismatched_reso(self</span><span class="s2">, </span><span class="s1">ts_tz):</span>
        <span class="s5"># case with non-lossy rounding</span>
        <span class="s1">ts = ts_tz</span>

        <span class="s5"># choose a unit for `other` that doesn't match ts_tz's;</span>
        <span class="s5">#  this construction ensures we get cases with other._creso &lt; ts._creso</span>
        <span class="s5">#  and cases with other._creso &gt; ts._creso</span>
        <span class="s1">unit = {</span>
            <span class="s1">NpyDatetimeUnit.NPY_FR_us.value: </span><span class="s3">&quot;ms&quot;</span><span class="s2">,</span>
            <span class="s1">NpyDatetimeUnit.NPY_FR_ms.value: </span><span class="s3">&quot;s&quot;</span><span class="s2">,</span>
            <span class="s1">NpyDatetimeUnit.NPY_FR_s.value: </span><span class="s3">&quot;us&quot;</span><span class="s2">,</span>
        <span class="s1">}[ts._creso]</span>
        <span class="s1">other = ts.as_unit(unit)</span>
        <span class="s2">assert </span><span class="s1">other._creso != ts._creso</span>

        <span class="s1">result = ts - other</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timedelta)</span>
        <span class="s2">assert </span><span class="s1">result._value == </span><span class="s4">0</span>
        <span class="s2">assert </span><span class="s1">result._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>

        <span class="s1">result = other - ts</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timedelta)</span>
        <span class="s2">assert </span><span class="s1">result._value == </span><span class="s4">0</span>
        <span class="s2">assert </span><span class="s1">result._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>

        <span class="s2">if </span><span class="s1">ts._creso &lt; other._creso:</span>
            <span class="s5"># Case where rounding is lossy</span>
            <span class="s1">other2 = other + Timedelta._from_value_and_reso(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">other._creso)</span>
            <span class="s1">exp = ts.as_unit(other.unit) - other2</span>

            <span class="s1">res = ts - other2</span>
            <span class="s2">assert </span><span class="s1">res == exp</span>
            <span class="s2">assert </span><span class="s1">res._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>

            <span class="s1">res = other2 - ts</span>
            <span class="s2">assert </span><span class="s1">res == -exp</span>
            <span class="s2">assert </span><span class="s1">res._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ts2 = ts + Timedelta._from_value_and_reso(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ts._creso)</span>
            <span class="s1">exp = ts2 - other.as_unit(ts2.unit)</span>

            <span class="s1">res = ts2 - other</span>
            <span class="s2">assert </span><span class="s1">res == exp</span>
            <span class="s2">assert </span><span class="s1">res._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>
            <span class="s1">res = other - ts2</span>
            <span class="s2">assert </span><span class="s1">res == -exp</span>
            <span class="s2">assert </span><span class="s1">res._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>

    <span class="s2">def </span><span class="s1">test_sub_timedeltalike_mismatched_reso(self</span><span class="s2">, </span><span class="s1">ts_tz):</span>
        <span class="s5"># case with non-lossy rounding</span>
        <span class="s1">ts = ts_tz</span>

        <span class="s5"># choose a unit for `other` that doesn't match ts_tz's;</span>
        <span class="s5">#  this construction ensures we get cases with other._creso &lt; ts._creso</span>
        <span class="s5">#  and cases with other._creso &gt; ts._creso</span>
        <span class="s1">unit = {</span>
            <span class="s1">NpyDatetimeUnit.NPY_FR_us.value: </span><span class="s3">&quot;ms&quot;</span><span class="s2">,</span>
            <span class="s1">NpyDatetimeUnit.NPY_FR_ms.value: </span><span class="s3">&quot;s&quot;</span><span class="s2">,</span>
            <span class="s1">NpyDatetimeUnit.NPY_FR_s.value: </span><span class="s3">&quot;us&quot;</span><span class="s2">,</span>
        <span class="s1">}[ts._creso]</span>
        <span class="s1">other = Timedelta(</span><span class="s4">0</span><span class="s1">).as_unit(unit)</span>
        <span class="s2">assert </span><span class="s1">other._creso != ts._creso</span>

        <span class="s1">result = ts + other</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == ts</span>
        <span class="s2">assert </span><span class="s1">result._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>

        <span class="s1">result = other + ts</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == ts</span>
        <span class="s2">assert </span><span class="s1">result._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>

        <span class="s2">if </span><span class="s1">ts._creso &lt; other._creso:</span>
            <span class="s5"># Case where rounding is lossy</span>
            <span class="s1">other2 = other + Timedelta._from_value_and_reso(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">other._creso)</span>
            <span class="s1">exp = ts.as_unit(other.unit) + other2</span>
            <span class="s1">res = ts + other2</span>
            <span class="s2">assert </span><span class="s1">res == exp</span>
            <span class="s2">assert </span><span class="s1">res._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>
            <span class="s1">res = other2 + ts</span>
            <span class="s2">assert </span><span class="s1">res == exp</span>
            <span class="s2">assert </span><span class="s1">res._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ts2 = ts + Timedelta._from_value_and_reso(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ts._creso)</span>
            <span class="s1">exp = ts2 + other.as_unit(ts2.unit)</span>

            <span class="s1">res = ts2 + other</span>
            <span class="s2">assert </span><span class="s1">res == exp</span>
            <span class="s2">assert </span><span class="s1">res._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>
            <span class="s1">res = other + ts2</span>
            <span class="s2">assert </span><span class="s1">res == exp</span>
            <span class="s2">assert </span><span class="s1">res._creso == max(ts._creso</span><span class="s2">, </span><span class="s1">other._creso)</span>

    <span class="s2">def </span><span class="s1">test_addition_doesnt_downcast_reso(self):</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/pull/48748#pullrequestreview-1122635413</span>
        <span class="s1">ts = Timestamp(year=</span><span class="s4">2022</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">microsecond=</span><span class="s4">999999</span><span class="s1">).as_unit(</span><span class="s3">&quot;us&quot;</span><span class="s1">)</span>
        <span class="s1">td = Timedelta(microseconds=</span><span class="s4">1</span><span class="s1">).as_unit(</span><span class="s3">&quot;us&quot;</span><span class="s1">)</span>
        <span class="s1">res = ts + td</span>
        <span class="s2">assert </span><span class="s1">res._creso == ts._creso</span>

    <span class="s2">def </span><span class="s1">test_sub_timedelta64_mismatched_reso(self</span><span class="s2">, </span><span class="s1">ts_tz):</span>
        <span class="s1">ts = ts_tz</span>

        <span class="s1">res = ts + np.timedelta64(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s1">exp = ts.as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">) + np.timedelta64(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">exp == res</span>
        <span class="s2">assert </span><span class="s1">exp._creso == NpyDatetimeUnit.NPY_FR_ns.value</span>

    <span class="s2">def </span><span class="s1">test_min(self</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s2">assert </span><span class="s1">ts.min &lt;= ts</span>
        <span class="s2">assert </span><span class="s1">ts.min._creso == ts._creso</span>
        <span class="s2">assert </span><span class="s1">ts.min._value == NaT._value + </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">test_max(self</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s2">assert </span><span class="s1">ts.max &gt;= ts</span>
        <span class="s2">assert </span><span class="s1">ts.max._creso == ts._creso</span>
        <span class="s2">assert </span><span class="s1">ts.max._value == np.iinfo(np.int64).max</span>

    <span class="s2">def </span><span class="s1">test_resolution(self</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s1">expected = Timedelta._from_value_and_reso(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ts._creso)</span>
        <span class="s1">result = ts.resolution</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>
        <span class="s2">assert </span><span class="s1">result._creso == expected._creso</span>

    <span class="s2">def </span><span class="s1">test_out_of_ns_bounds(self):</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/issues/51060</span>
        <span class="s1">result = Timestamp(-</span><span class="s4">52700112000</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == Timestamp(</span><span class="s3">&quot;0300-01-01&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.to_numpy() == np.datetime64(</span><span class="s3">&quot;0300-01-01T00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_timestamp_class_min_max_resolution():</span>
    <span class="s5"># when accessed on the class (as opposed to an instance), we default</span>
    <span class="s5">#  to nanoseconds</span>
    <span class="s2">assert </span><span class="s1">Timestamp.min == Timestamp(NaT._value + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">Timestamp.min._creso == NpyDatetimeUnit.NPY_FR_ns.value</span>

    <span class="s2">assert </span><span class="s1">Timestamp.max == Timestamp(np.iinfo(np.int64).max)</span>
    <span class="s2">assert </span><span class="s1">Timestamp.max._creso == NpyDatetimeUnit.NPY_FR_ns.value</span>

    <span class="s2">assert </span><span class="s1">Timestamp.resolution == Timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">Timestamp.resolution._creso == NpyDatetimeUnit.NPY_FR_ns.value</span>


<span class="s2">class </span><span class="s1">TestAsUnit:</span>
    <span class="s2">def </span><span class="s1">test_as_unit(self):</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;1970-01-01&quot;</span><span class="s1">).as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts.unit == </span><span class="s3">&quot;ns&quot;</span>

        <span class="s2">assert </span><span class="s1">ts.as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">) </span><span class="s2">is </span><span class="s1">ts</span>

        <span class="s1">res = ts.as_unit(</span><span class="s3">&quot;us&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res._value == ts._value // </span><span class="s4">1000</span>
        <span class="s2">assert </span><span class="s1">res._creso == NpyDatetimeUnit.NPY_FR_us.value</span>

        <span class="s1">rt = res.as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">rt._value == ts._value</span>
        <span class="s2">assert </span><span class="s1">rt._creso == ts._creso</span>

        <span class="s1">res = ts.as_unit(</span><span class="s3">&quot;ms&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res._value == ts._value // </span><span class="s4">1_000_000</span>
        <span class="s2">assert </span><span class="s1">res._creso == NpyDatetimeUnit.NPY_FR_ms.value</span>

        <span class="s1">rt = res.as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">rt._value == ts._value</span>
        <span class="s2">assert </span><span class="s1">rt._creso == ts._creso</span>

        <span class="s1">res = ts.as_unit(</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res._value == ts._value // </span><span class="s4">1_000_000_000</span>
        <span class="s2">assert </span><span class="s1">res._creso == NpyDatetimeUnit.NPY_FR_s.value</span>

        <span class="s1">rt = res.as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">rt._value == ts._value</span>
        <span class="s2">assert </span><span class="s1">rt._creso == ts._creso</span>

    <span class="s2">def </span><span class="s1">test_as_unit_overflows(self):</span>
        <span class="s5"># microsecond that would be just out of bounds for nano</span>
        <span class="s1">us = </span><span class="s4">9223372800000000</span>
        <span class="s1">ts = Timestamp._from_value_and_reso(us</span><span class="s2">, </span><span class="s1">NpyDatetimeUnit.NPY_FR_us.value</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Cannot cast 2262-04-12 00:00:00 to unit='ns' without overflow&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts.as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>

        <span class="s1">res = ts.as_unit(</span><span class="s3">&quot;ms&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res._value == us // </span><span class="s4">1000</span>
        <span class="s2">assert </span><span class="s1">res._creso == NpyDatetimeUnit.NPY_FR_ms.value</span>

    <span class="s2">def </span><span class="s1">test_as_unit_rounding(self):</span>
        <span class="s1">ts = Timestamp(</span><span class="s4">1_500_000</span><span class="s1">)  </span><span class="s5"># i.e. 1500 microseconds</span>
        <span class="s1">res = ts.as_unit(</span><span class="s3">&quot;ms&quot;</span><span class="s1">)</span>

        <span class="s1">expected = Timestamp(</span><span class="s4">1_000_000</span><span class="s1">)  </span><span class="s5"># i.e. 1 millisecond</span>
        <span class="s2">assert </span><span class="s1">res == expected</span>

        <span class="s2">assert </span><span class="s1">res._creso == NpyDatetimeUnit.NPY_FR_ms.value</span>
        <span class="s2">assert </span><span class="s1">res._value == </span><span class="s4">1</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Cannot losslessly convert units&quot;</span><span class="s1">):</span>
            <span class="s1">ts.as_unit(</span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s1">round_ok=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_as_unit_non_nano(self):</span>
        <span class="s5"># case where we are going neither to nor from nano</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">).as_unit(</span><span class="s3">&quot;ms&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts.year == </span><span class="s4">1970</span>
        <span class="s2">assert </span><span class="s1">ts.month == </span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">ts.day == </span><span class="s4">2</span>
        <span class="s2">assert </span><span class="s1">ts.hour == ts.minute == ts.second == ts.microsecond == ts.nanosecond == </span><span class="s4">0</span>

        <span class="s1">res = ts.as_unit(</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res._value == </span><span class="s4">24 </span><span class="s1">* </span><span class="s4">3600</span>
        <span class="s2">assert </span><span class="s1">res.year == </span><span class="s4">1970</span>
        <span class="s2">assert </span><span class="s1">res.month == </span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">res.day == </span><span class="s4">2</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">res.hour</span>
            <span class="s1">== res.minute</span>
            <span class="s1">== res.second</span>
            <span class="s1">== res.microsecond</span>
            <span class="s1">== res.nanosecond</span>
            <span class="s1">== </span><span class="s4">0</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_delimited_date():</span>
    <span class="s5"># https://github.com/pandas-dev/pandas/issues/50231</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">result = Timestamp(</span><span class="s3">&quot;13-01-2000&quot;</span><span class="s1">)</span>
    <span class="s1">expected = Timestamp(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">13</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">def </span><span class="s1">test_utctimetuple():</span>
    <span class="s5"># GH 32174</span>
    <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
    <span class="s1">result = ts.utctimetuple()</span>
    <span class="s1">expected = time.struct_time((</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">def </span><span class="s1">test_negative_dates():</span>
    <span class="s5"># https://github.com/pandas-dev/pandas/issues/50787</span>
    <span class="s1">ts = Timestamp(</span><span class="s3">&quot;-2000-01-01&quot;</span><span class="s1">)</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot; not yet supported on Timestamps which are outside the range of &quot;</span>
        <span class="s3">&quot;Python's standard library. For now, please call the components you need &quot;</span>
        <span class="s3">r&quot;\(such as `.year` and `.month`\) and construct your string from there.$&quot;</span>
    <span class="s1">)</span>
    <span class="s1">func = </span><span class="s3">&quot;^strftime&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=func + msg):</span>
        <span class="s1">ts.strftime(</span><span class="s3">&quot;%Y&quot;</span><span class="s1">)</span>

    <span class="s1">msg = (</span>
        <span class="s3">&quot; not yet supported on Timestamps which &quot;</span>
        <span class="s3">&quot;are outside the range of Python's standard library. &quot;</span>
    <span class="s1">)</span>
    <span class="s1">func = </span><span class="s3">&quot;^date&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=func + msg):</span>
        <span class="s1">ts.date()</span>
    <span class="s1">func = </span><span class="s3">&quot;^isocalendar&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=func + msg):</span>
        <span class="s1">ts.isocalendar()</span>
    <span class="s1">func = </span><span class="s3">&quot;^timetuple&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=func + msg):</span>
        <span class="s1">ts.timetuple()</span>
    <span class="s1">func = </span><span class="s3">&quot;^toordinal&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=func + msg):</span>
        <span class="s1">ts.toordinal()</span>
</pre>
</body>
</html>