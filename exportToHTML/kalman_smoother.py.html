<html>
<head>
<title>kalman_smoother.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
kalman_smoother.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
State Space Representation and Kalman Filter, Smoother 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">SimpleNamespace</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.representation </span><span class="s2">import </span><span class="s1">OptionWrapper</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.kalman_filter </span><span class="s2">import </span><span class="s1">(KalmanFilter</span><span class="s2">,</span>
                                                      <span class="s1">FilterResults)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.tools </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">reorder_missing_matrix</span><span class="s2">, </span><span class="s1">reorder_missing_vector</span><span class="s2">, </span><span class="s1">copy_index_matrix)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">tools</span><span class="s2">, </span><span class="s1">initialization</span>

<span class="s1">SMOOTHER_STATE = </span><span class="s3">0x01              </span><span class="s4"># Durbin and Koopman (2012), Chapter 4.4.2</span>
<span class="s1">SMOOTHER_STATE_COV = </span><span class="s3">0x02          </span><span class="s4"># ibid., Chapter 4.4.3</span>
<span class="s1">SMOOTHER_DISTURBANCE = </span><span class="s3">0x04        </span><span class="s4"># ibid., Chapter 4.5</span>
<span class="s1">SMOOTHER_DISTURBANCE_COV = </span><span class="s3">0x08    </span><span class="s4"># ibid., Chapter 4.5</span>
<span class="s1">SMOOTHER_STATE_AUTOCOV = </span><span class="s3">0x10      </span><span class="s4"># ibid., Chapter 4.7</span>
<span class="s1">SMOOTHER_ALL = (</span>
    <span class="s1">SMOOTHER_STATE | SMOOTHER_STATE_COV | SMOOTHER_DISTURBANCE |</span>
    <span class="s1">SMOOTHER_DISTURBANCE_COV | SMOOTHER_STATE_AUTOCOV</span>
<span class="s1">)</span>

<span class="s1">SMOOTH_CONVENTIONAL = </span><span class="s3">0x01</span>
<span class="s1">SMOOTH_CLASSICAL = </span><span class="s3">0x02</span>
<span class="s1">SMOOTH_ALTERNATIVE = </span><span class="s3">0x04</span>
<span class="s1">SMOOTH_UNIVARIATE = </span><span class="s3">0x08</span>


<span class="s2">class </span><span class="s1">KalmanSmoother(KalmanFilter):</span>
    <span class="s0">r&quot;&quot;&quot; 
    State space representation of a time series process, with Kalman filter 
    and smoother. 
 
    Parameters 
    ---------- 
    k_endog : {array_like, int} 
        The observed time-series process :math:`y` if array like or the 
        number of variables in the process if an integer. 
    k_states : int 
        The dimension of the unobserved state process. 
    k_posdef : int, optional 
        The dimension of a guaranteed positive definite covariance matrix 
        describing the shocks in the measurement equation. Must be less than 
        or equal to `k_states`. Default is `k_states`. 
    results_class : class, optional 
        Default results class to use to save filtering output. Default is 
        `SmootherResults`. If specified, class must extend from 
        `SmootherResults`. 
    **kwargs 
        Keyword arguments may be used to provide default values for state space 
        matrices, for Kalman filtering options, or for Kalman smoothing 
        options. See `Representation` for more details. 
    &quot;&quot;&quot;</span>

    <span class="s1">smoother_outputs = [</span>
        <span class="s5">'smoother_state'</span><span class="s2">, </span><span class="s5">'smoother_state_cov'</span><span class="s2">, </span><span class="s5">'smoother_state_autocov'</span><span class="s2">,</span>
        <span class="s5">'smoother_disturbance'</span><span class="s2">, </span><span class="s5">'smoother_disturbance_cov'</span><span class="s2">, </span><span class="s5">'smoother_all'</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s1">smoother_state = OptionWrapper(</span><span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s1">SMOOTHER_STATE)</span>
    <span class="s1">smoother_state_cov = OptionWrapper(</span><span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s1">SMOOTHER_STATE_COV)</span>
    <span class="s1">smoother_disturbance = (</span>
        <span class="s1">OptionWrapper(</span><span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s1">SMOOTHER_DISTURBANCE)</span>
    <span class="s1">)</span>
    <span class="s1">smoother_disturbance_cov = (</span>
        <span class="s1">OptionWrapper(</span><span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s1">SMOOTHER_DISTURBANCE_COV)</span>
    <span class="s1">)</span>
    <span class="s1">smoother_state_autocov = (</span>
        <span class="s1">OptionWrapper(</span><span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s1">SMOOTHER_STATE_AUTOCOV)</span>
    <span class="s1">)</span>
    <span class="s1">smoother_all = OptionWrapper(</span><span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s1">SMOOTHER_ALL)</span>

    <span class="s1">smooth_methods = [</span>
        <span class="s5">'smooth_conventional'</span><span class="s2">, </span><span class="s5">'smooth_alternative'</span><span class="s2">, </span><span class="s5">'smooth_classical'</span>
    <span class="s1">]</span>

    <span class="s1">smooth_conventional = OptionWrapper(</span><span class="s5">'smooth_method'</span><span class="s2">, </span><span class="s1">SMOOTH_CONVENTIONAL)</span>
    <span class="s5">&quot;&quot;&quot; 
    (bool) Flag for conventional (Durbin and Koopman, 2012) Kalman smoothing. 
    &quot;&quot;&quot;</span>
    <span class="s1">smooth_alternative = OptionWrapper(</span><span class="s5">'smooth_method'</span><span class="s2">, </span><span class="s1">SMOOTH_ALTERNATIVE)</span>
    <span class="s5">&quot;&quot;&quot; 
    (bool) Flag for alternative (modified Bryson-Frazier) smoothing. 
    &quot;&quot;&quot;</span>
    <span class="s1">smooth_classical = OptionWrapper(</span><span class="s5">'smooth_method'</span><span class="s2">, </span><span class="s1">SMOOTH_CLASSICAL)</span>
    <span class="s5">&quot;&quot;&quot; 
    (bool) Flag for classical (see e.g. Anderson and Moore, 1979) smoothing. 
    &quot;&quot;&quot;</span>
    <span class="s1">smooth_univariate = OptionWrapper(</span><span class="s5">'smooth_method'</span><span class="s2">, </span><span class="s1">SMOOTH_UNIVARIATE)</span>
    <span class="s5">&quot;&quot;&quot; 
    (bool) Flag for univariate smoothing (uses modified Bryson-Frazier timing). 
    &quot;&quot;&quot;</span>

    <span class="s4"># Default smoother options</span>
    <span class="s1">smoother_output = SMOOTHER_ALL</span>
    <span class="s1">smooth_method = </span><span class="s3">0</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">k_endog</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s2">None, </span><span class="s1">results_class=</span><span class="s2">None,</span>
                 <span class="s1">kalman_smoother_classes=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Set the default results class</span>
        <span class="s2">if </span><span class="s1">results_class </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">results_class = SmootherResults</span>

        <span class="s4"># Extract keyword arguments to-be-used later</span>
        <span class="s1">keys = [</span><span class="s5">'smoother_output'</span><span class="s1">] + KalmanSmoother.smoother_outputs</span>
        <span class="s1">smoother_output_kwargs = {key: kwargs.pop(key) </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys</span>
                                  <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">kwargs}</span>
        <span class="s1">keys = [</span><span class="s5">'smooth_method'</span><span class="s1">] + KalmanSmoother.smooth_methods</span>
        <span class="s1">smooth_method_kwargs = {key: kwargs.pop(key) </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys</span>
                                <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">kwargs}</span>

        <span class="s4"># Initialize the base class</span>
        <span class="s1">super(KalmanSmoother</span><span class="s2">, </span><span class="s1">self).__init__(</span>
            <span class="s1">k_endog</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s1">k_posdef</span><span class="s2">, </span><span class="s1">results_class=results_class</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s4"># Options</span>
        <span class="s1">self.prefix_kalman_smoother_map = (</span>
            <span class="s1">kalman_smoother_classes</span>
            <span class="s2">if </span><span class="s1">kalman_smoother_classes </span><span class="s2">is not None</span>
            <span class="s2">else </span><span class="s1">tools.prefix_kalman_smoother_map.copy())</span>

        <span class="s4"># Setup the underlying Kalman smoother storage</span>
        <span class="s1">self._kalman_smoothers = {}</span>

        <span class="s4"># Set the smoother options</span>
        <span class="s1">self.set_smoother_output(**smoother_output_kwargs)</span>
        <span class="s1">self.set_smooth_method(**smooth_method_kwargs)</span>

    <span class="s2">def </span><span class="s1">_clone_kwargs(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># See Representation._clone_kwargs for docstring</span>
        <span class="s1">kwargs = super(KalmanSmoother</span><span class="s2">, </span><span class="s1">self)._clone_kwargs(endog</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Get defaults for options</span>
        <span class="s1">kwargs.setdefault(</span><span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s1">self.smoother_output)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s5">'smooth_method'</span><span class="s2">, </span><span class="s1">self.smooth_method)</span>

        <span class="s2">return </span><span class="s1">kwargs</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_kalman_smoother(self):</span>
        <span class="s1">prefix = self.prefix</span>
        <span class="s2">if </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">self._kalman_smoothers:</span>
            <span class="s2">return </span><span class="s1">self._kalman_smoothers[prefix]</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_initialize_smoother(self</span><span class="s2">, </span><span class="s1">smoother_output=</span><span class="s2">None, </span><span class="s1">smooth_method=</span><span class="s2">None,</span>
                             <span class="s1">prefix=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">smoother_output </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">smoother_output = self.smoother_output</span>
        <span class="s2">if </span><span class="s1">smooth_method </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">smooth_method = self.smooth_method</span>

        <span class="s4"># Make sure we have the required Kalman filter</span>
        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">create_filter</span><span class="s2">, </span><span class="s1">create_statespace = (</span>
            <span class="s1">self._initialize_filter(prefix</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">)</span>

        <span class="s4"># Determine if we need to (re-)create the smoother</span>
        <span class="s4"># (definitely need to recreate if we recreated the filter)</span>
        <span class="s1">create_smoother = (create_filter </span><span class="s2">or</span>
                           <span class="s1">prefix </span><span class="s2">not in </span><span class="s1">self._kalman_smoothers)</span>
        <span class="s2">if not </span><span class="s1">create_smoother:</span>
            <span class="s1">kalman_smoother = self._kalman_smoothers[prefix]</span>

            <span class="s1">create_smoother = (kalman_smoother.kfilter </span><span class="s2">is not</span>
                               <span class="s1">self._kalman_filters[prefix])</span>

        <span class="s4"># If the dtype-specific _kalman_smoother does not exist (or if we</span>
        <span class="s4"># need to re-create it), create it</span>
        <span class="s2">if </span><span class="s1">create_smoother:</span>
            <span class="s4"># Setup the smoother</span>
            <span class="s1">cls = self.prefix_kalman_smoother_map[prefix]</span>
            <span class="s1">self._kalman_smoothers[prefix] = cls(</span>
                <span class="s1">self._statespaces[prefix]</span><span class="s2">, </span><span class="s1">self._kalman_filters[prefix]</span><span class="s2">,</span>
                <span class="s1">smoother_output</span><span class="s2">, </span><span class="s1">smooth_method</span>
            <span class="s1">)</span>
        <span class="s4"># Otherwise, update the smoother parameters</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._kalman_smoothers[prefix].set_smoother_output(</span>
                <span class="s1">smoother_output</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s1">self._kalman_smoothers[prefix].set_smooth_method(smooth_method)</span>

        <span class="s2">return </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">create_smoother</span><span class="s2">, </span><span class="s1">create_filter</span><span class="s2">, </span><span class="s1">create_statespace</span>

    <span class="s2">def </span><span class="s1">set_smoother_output(self</span><span class="s2">, </span><span class="s1">smoother_output=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the smoother output 
 
        The smoother can produce several types of results. The smoother output 
        variable controls which are calculated and returned. 
 
        Parameters 
        ---------- 
        smoother_output : int, optional 
            Bitmask value to set the smoother output to. See notes for details. 
        **kwargs 
            Keyword arguments may be used to influence the smoother output by 
            setting individual boolean flags. See notes for details. 
 
        Notes 
        ----- 
        The smoother output is defined by a collection of boolean flags, and 
        is internally stored as a bitmask. The methods available are: 
 
        SMOOTHER_STATE = 0x01 
            Calculate and return the smoothed states. 
        SMOOTHER_STATE_COV = 0x02 
            Calculate and return the smoothed state covariance matrices. 
        SMOOTHER_STATE_AUTOCOV = 0x10 
            Calculate and return the smoothed state lag-one autocovariance 
            matrices. 
        SMOOTHER_DISTURBANCE = 0x04 
            Calculate and return the smoothed state and observation 
            disturbances. 
        SMOOTHER_DISTURBANCE_COV = 0x08 
            Calculate and return the covariance matrices for the smoothed state 
            and observation disturbances. 
        SMOOTHER_ALL 
            Calculate and return all results. 
 
        If the bitmask is set directly via the `smoother_output` argument, then 
        the full method must be provided. 
 
        If keyword arguments are used to set individual boolean flags, then 
        the lowercase of the method must be used as an argument name, and the 
        value is the desired value of the boolean flag (True or False). 
 
        Note that the smoother output may also be specified by directly 
        modifying the class attributes which are defined similarly to the 
        keyword arguments. 
 
        The default smoother output is SMOOTHER_ALL. 
 
        If performance is a concern, only those results which are needed should 
        be specified as any results that are not specified will not be 
        calculated. For example, if the smoother output is set to only include 
        SMOOTHER_STATE, the smoother operates much more quickly than if all 
        output is required. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import statsmodels.tsa.statespace.kalman_smoother as ks 
        &gt;&gt;&gt; mod = ks.KalmanSmoother(1,1) 
        &gt;&gt;&gt; mod.smoother_output 
        15 
        &gt;&gt;&gt; mod.set_smoother_output(smoother_output=0) 
        &gt;&gt;&gt; mod.smoother_state = True 
        &gt;&gt;&gt; mod.smoother_output 
        1 
        &gt;&gt;&gt; mod.smoother_state 
        True 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">smoother_output </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.smoother_output = smoother_output</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">KalmanSmoother.smoother_outputs:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">kwargs[name])</span>

    <span class="s2">def </span><span class="s1">set_smooth_method(self</span><span class="s2">, </span><span class="s1">smooth_method=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Set the smoothing method 
 
        The smoothing method can be used to override the Kalman smoother 
        approach used. By default, the Kalman smoother used depends on the 
        Kalman filter method. 
 
        Parameters 
        ---------- 
        smooth_method : int, optional 
            Bitmask value to set the filter method to. See notes for details. 
        **kwargs 
            Keyword arguments may be used to influence the filter method by 
            setting individual boolean flags. See notes for details. 
 
        Notes 
        ----- 
        The smoothing method is defined by a collection of boolean flags, and 
        is internally stored as a bitmask. The methods available are: 
 
        SMOOTH_CONVENTIONAL = 0x01 
            Default Kalman smoother, as presented in Durbin and Koopman, 2012 
            chapter 4. 
        SMOOTH_CLASSICAL = 0x02 
            Classical Kalman smoother, as presented in Anderson and Moore, 1979 
            or Durbin and Koopman, 2012 chapter 4.6.1. 
        SMOOTH_ALTERNATIVE = 0x04 
            Modified Bryson-Frazier Kalman smoother method; this is identical 
            to the conventional method of Durbin and Koopman, 2012, except that 
            an additional intermediate step is included. 
        SMOOTH_UNIVARIATE = 0x08 
            Univariate Kalman smoother, as presented in Durbin and Koopman, 
            2012 chapter 6, except with modified Bryson-Frazier timing. 
 
        Practically speaking, these methods should all produce the same output 
        but different computational implications, numerical stability 
        implications, or internal timing assumptions. 
 
        Note that only the first method is available if using a Scipy version 
        older than 0.16. 
 
        If the bitmask is set directly via the `smooth_method` argument, then 
        the full method must be provided. 
 
        If keyword arguments are used to set individual boolean flags, then 
        the lowercase of the method must be used as an argument name, and the 
        value is the desired value of the boolean flag (True or False). 
 
        Note that the filter method may also be specified by directly modifying 
        the class attributes which are defined similarly to the keyword 
        arguments. 
 
        The default filtering method is SMOOTH_CONVENTIONAL. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10)) 
        &gt;&gt;&gt; mod.smooth_method 
        1 
        &gt;&gt;&gt; mod.filter_conventional 
        True 
        &gt;&gt;&gt; mod.filter_univariate = True 
        &gt;&gt;&gt; mod.smooth_method 
        17 
        &gt;&gt;&gt; mod.set_smooth_method(filter_univariate=False, 
                                  filter_collapsed=True) 
        &gt;&gt;&gt; mod.smooth_method 
        33 
        &gt;&gt;&gt; mod.set_smooth_method(smooth_method=1) 
        &gt;&gt;&gt; mod.filter_conventional 
        True 
        &gt;&gt;&gt; mod.filter_univariate 
        False 
        &gt;&gt;&gt; mod.filter_collapsed 
        False 
        &gt;&gt;&gt; mod.filter_univariate = True 
        &gt;&gt;&gt; mod.smooth_method 
        17 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">smooth_method </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.smooth_method = smooth_method</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">KalmanSmoother.smooth_methods:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">kwargs[name])</span>

    <span class="s2">def </span><span class="s1">_smooth(self</span><span class="s2">, </span><span class="s1">smoother_output=</span><span class="s2">None, </span><span class="s1">smooth_method=</span><span class="s2">None, </span><span class="s1">prefix=</span><span class="s2">None,</span>
                <span class="s1">complex_step=</span><span class="s2">False, </span><span class="s1">results=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Initialize the smoother</span>
        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">create_smoother</span><span class="s2">, </span><span class="s1">create_filter</span><span class="s2">, </span><span class="s1">create_statespace = (</span>
            <span class="s1">self._initialize_smoother(</span>
                <span class="s1">smoother_output</span><span class="s2">, </span><span class="s1">smooth_method</span><span class="s2">, </span><span class="s1">prefix=prefix</span><span class="s2">, </span><span class="s1">**kwargs</span>
            <span class="s1">))</span>

        <span class="s4"># Check that the filter and statespace weren't just recreated</span>
        <span class="s2">if </span><span class="s1">create_filter </span><span class="s2">or </span><span class="s1">create_statespace:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Passed settings forced re-creation of the'</span>
                             <span class="s5">' Kalman filter. Please run `_filter` before'</span>
                             <span class="s5">' running `_smooth`.'</span><span class="s1">)</span>

        <span class="s4"># Get the appropriate smoother</span>
        <span class="s1">smoother = self._kalman_smoothers[prefix]</span>

        <span class="s4"># Run the smoother</span>
        <span class="s1">smoother()</span>

        <span class="s2">return </span><span class="s1">smoother</span>

    <span class="s2">def </span><span class="s1">smooth(self</span><span class="s2">, </span><span class="s1">smoother_output=</span><span class="s2">None, </span><span class="s1">smooth_method=</span><span class="s2">None, </span><span class="s1">results=</span><span class="s2">None,</span>
               <span class="s1">run_filter=</span><span class="s2">True, </span><span class="s1">prefix=</span><span class="s2">None, </span><span class="s1">complex_step=</span><span class="s2">False,</span>
               <span class="s1">update_representation=</span><span class="s2">True, </span><span class="s1">update_filter=</span><span class="s2">True,</span>
               <span class="s1">update_smoother=</span><span class="s2">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply the Kalman smoother to the statespace model. 
 
        Parameters 
        ---------- 
        smoother_output : int, optional 
            Determines which Kalman smoother output calculate. Default is all 
            (including state, disturbances, and all covariances). 
        results : class or object, optional 
            If a class, then that class is instantiated and returned with the 
            result of both filtering and smoothing. 
            If an object, then that object is updated with the smoothing data. 
            If None, then a SmootherResults object is returned with both 
            filtering and smoothing results. 
        run_filter : bool, optional 
            Whether or not to run the Kalman filter prior to smoothing. Default 
            is True. 
        prefix : str 
            The prefix of the datatype. Usually only used internally. 
 
        Returns 
        ------- 
        SmootherResults object 
        &quot;&quot;&quot;</span>

        <span class="s4"># Run the filter</span>
        <span class="s1">kfilter = self._filter(**kwargs)</span>

        <span class="s4"># Create the results object</span>
        <span class="s1">results = self.results_class(self)</span>
        <span class="s2">if </span><span class="s1">update_representation:</span>
            <span class="s1">results.update_representation(self)</span>
        <span class="s2">if </span><span class="s1">update_filter:</span>
            <span class="s1">results.update_filter(kfilter)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># (even if we don't update all filter results, still need to</span>
            <span class="s4"># update this)</span>
            <span class="s1">results.nobs_diffuse = kfilter.nobs_diffuse</span>

        <span class="s4"># Run the smoother</span>
        <span class="s2">if </span><span class="s1">smoother_output </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">smoother_output = self.smoother_output</span>
        <span class="s1">smoother = self._smooth(smoother_output</span><span class="s2">, </span><span class="s1">results=results</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Update the results</span>
        <span class="s2">if </span><span class="s1">update_smoother:</span>
            <span class="s1">results.update_smoother(smoother)</span>

        <span class="s2">return </span><span class="s1">results</span>


<span class="s2">class </span><span class="s1">SmootherResults(FilterResults):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Results from applying the Kalman smoother and/or filter to a state space 
    model. 
 
    Parameters 
    ---------- 
    model : Representation 
        A Statespace representation 
 
    Attributes 
    ---------- 
    nobs : int 
        Number of observations. 
    k_endog : int 
        The dimension of the observation series. 
    k_states : int 
        The dimension of the unobserved state process. 
    k_posdef : int 
        The dimension of a guaranteed positive definite covariance matrix 
        describing the shocks in the measurement equation. 
    dtype : dtype 
        Datatype of representation matrices 
    prefix : str 
        BLAS prefix of representation matrices 
    shapes : dictionary of name:tuple 
        A dictionary recording the shapes of each of the representation 
        matrices as tuples. 
    endog : ndarray 
        The observation vector. 
    design : ndarray 
        The design matrix, :math:`Z`. 
    obs_intercept : ndarray 
        The intercept for the observation equation, :math:`d`. 
    obs_cov : ndarray 
        The covariance matrix for the observation equation :math:`H`. 
    transition : ndarray 
        The transition matrix, :math:`T`. 
    state_intercept : ndarray 
        The intercept for the transition equation, :math:`c`. 
    selection : ndarray 
        The selection matrix, :math:`R`. 
    state_cov : ndarray 
        The covariance matrix for the state equation :math:`Q`. 
    missing : array of bool 
        An array of the same size as `endog`, filled with boolean values that 
        are True if the corresponding entry in `endog` is NaN and False 
        otherwise. 
    nmissing : array of int 
        An array of size `nobs`, where the ith entry is the number (between 0 
        and k_endog) of NaNs in the ith row of the `endog` array. 
    time_invariant : bool 
        Whether or not the representation matrices are time-invariant 
    initialization : str 
        Kalman filter initialization method. 
    initial_state : array_like 
        The state vector used to initialize the Kalamn filter. 
    initial_state_cov : array_like 
        The state covariance matrix used to initialize the Kalamn filter. 
    filter_method : int 
        Bitmask representing the Kalman filtering method 
    inversion_method : int 
        Bitmask representing the method used to invert the forecast error 
        covariance matrix. 
    stability_method : int 
        Bitmask representing the methods used to promote numerical stability in 
        the Kalman filter recursions. 
    conserve_memory : int 
        Bitmask representing the selected memory conservation method. 
    tolerance : float 
        The tolerance at which the Kalman filter determines convergence to 
        steady-state. 
    loglikelihood_burn : int 
        The number of initial periods during which the loglikelihood is not 
        recorded. 
    converged : bool 
        Whether or not the Kalman filter converged. 
    period_converged : int 
        The time period in which the Kalman filter converged. 
    filtered_state : ndarray 
        The filtered state vector at each time period. 
    filtered_state_cov : ndarray 
        The filtered state covariance matrix at each time period. 
    predicted_state : ndarray 
        The predicted state vector at each time period. 
    predicted_state_cov : ndarray 
        The predicted state covariance matrix at each time period. 
    kalman_gain : ndarray 
        The Kalman gain at each time period. 
    forecasts : ndarray 
        The one-step-ahead forecasts of observations at each time period. 
    forecasts_error : ndarray 
        The forecast errors at each time period. 
    forecasts_error_cov : ndarray 
        The forecast error covariance matrices at each time period. 
    loglikelihood : ndarray 
        The loglikelihood values at each time period. 
    collapsed_forecasts : ndarray 
        If filtering using collapsed observations, stores the one-step-ahead 
        forecasts of collapsed observations at each time period. 
    collapsed_forecasts_error : ndarray 
        If filtering using collapsed observations, stores the one-step-ahead 
        forecast errors of collapsed observations at each time period. 
    collapsed_forecasts_error_cov : ndarray 
        If filtering using collapsed observations, stores the one-step-ahead 
        forecast error covariance matrices of collapsed observations at each 
        time period. 
    standardized_forecast_error : ndarray 
        The standardized forecast errors 
    smoother_output : int 
        Bitmask representing the generated Kalman smoothing output 
    scaled_smoothed_estimator : ndarray 
        The scaled smoothed estimator at each time period. 
    scaled_smoothed_estimator_cov : ndarray 
        The scaled smoothed estimator covariance matrices at each time period. 
    smoothing_error : ndarray 
        The smoothing error covariance matrices at each time period. 
    smoothed_state : ndarray 
        The smoothed state at each time period. 
    smoothed_state_cov : ndarray 
        The smoothed state covariance matrices at each time period. 
    smoothed_state_autocov : ndarray 
        The smoothed state lago-one autocovariance matrices at each time 
        period: :math:`Cov(\alpha_{t+1}, \alpha_t)`. 
    smoothed_measurement_disturbance : ndarray 
        The smoothed measurement at each time period. 
    smoothed_state_disturbance : ndarray 
        The smoothed state at each time period. 
    smoothed_measurement_disturbance_cov : ndarray 
        The smoothed measurement disturbance covariance matrices at each time 
        period. 
    smoothed_state_disturbance_cov : ndarray 
        The smoothed state disturbance covariance matrices at each time period. 
    &quot;&quot;&quot;</span>

    <span class="s1">_smoother_attributes = [</span>
        <span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s5">'scaled_smoothed_estimator'</span><span class="s2">,</span>
        <span class="s5">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s5">'smoothing_error'</span><span class="s2">,</span>
        <span class="s5">'smoothed_state'</span><span class="s2">, </span><span class="s5">'smoothed_state_cov'</span><span class="s2">, </span><span class="s5">'smoothed_state_autocov'</span><span class="s2">,</span>
        <span class="s5">'smoothed_measurement_disturbance'</span><span class="s2">, </span><span class="s5">'smoothed_state_disturbance'</span><span class="s2">,</span>
        <span class="s5">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
        <span class="s5">'smoothed_state_disturbance_cov'</span><span class="s2">, </span><span class="s5">'innovations_transition'</span>
    <span class="s1">]</span>

    <span class="s1">_smoother_options = KalmanSmoother.smoother_outputs</span>

    <span class="s1">_attributes = FilterResults._model_attributes + _smoother_attributes</span>

    <span class="s2">def </span><span class="s1">update_representation(self</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">only_options=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the results to match a given model 
 
        Parameters 
        ---------- 
        model : Representation 
            The model object from which to take the updated values. 
        only_options : bool, optional 
            If set to true, only the smoother and filter options are updated, 
            and the state space representation is not updated. Default is 
            False. 
 
        Notes 
        ----- 
        This method is rarely required except for internal usage. 
        &quot;&quot;&quot;</span>
        <span class="s1">super(SmootherResults</span><span class="s2">, </span><span class="s1">self).update_representation(model</span><span class="s2">, </span><span class="s1">only_options)</span>

        <span class="s4"># Save the options as boolean variables</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._smoother_options:</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">getattr(model</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, None</span><span class="s1">))</span>

        <span class="s4"># Initialize holders for smoothed forecasts</span>
        <span class="s1">self._smoothed_forecasts = </span><span class="s2">None</span>
        <span class="s1">self._smoothed_forecasts_error = </span><span class="s2">None</span>
        <span class="s1">self._smoothed_forecasts_error_cov = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">update_smoother(self</span><span class="s2">, </span><span class="s1">smoother):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the smoother results 
 
        Parameters 
        ---------- 
        smoother : KalmanSmoother 
            The model object from which to take the updated values. 
 
        Notes 
        ----- 
        This method is rarely required except for internal usage. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Copy the appropriate output</span>
        <span class="s1">attributes = []</span>

        <span class="s4"># Since update_representation will already have been called, we can</span>
        <span class="s4"># use the boolean options smoother_* and know they match the smoother</span>
        <span class="s4"># itself</span>
        <span class="s2">if </span><span class="s1">self.smoother_state </span><span class="s2">or </span><span class="s1">self.smoother_disturbance:</span>
            <span class="s1">attributes.append(</span><span class="s5">'scaled_smoothed_estimator'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.smoother_state_cov </span><span class="s2">or </span><span class="s1">self.smoother_disturbance_cov:</span>
            <span class="s1">attributes.append(</span><span class="s5">'scaled_smoothed_estimator_cov'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.smoother_state:</span>
            <span class="s1">attributes.append(</span><span class="s5">'smoothed_state'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.smoother_state_cov:</span>
            <span class="s1">attributes.append(</span><span class="s5">'smoothed_state_cov'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.smoother_state_autocov:</span>
            <span class="s1">attributes.append(</span><span class="s5">'smoothed_state_autocov'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.smoother_disturbance:</span>
            <span class="s1">attributes += [</span>
                <span class="s5">'smoothing_error'</span><span class="s2">,</span>
                <span class="s5">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
                <span class="s5">'smoothed_state_disturbance'</span>
            <span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.smoother_disturbance_cov:</span>
            <span class="s1">attributes += [</span>
                <span class="s5">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
                <span class="s5">'smoothed_state_disturbance_cov'</span>
            <span class="s1">]</span>

        <span class="s1">has_missing = np.sum(self.nmissing) &gt; </span><span class="s3">0</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._smoother_attributes:</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s5">'smoother_output'</span><span class="s1">:</span>
                <span class="s2">pass</span>
            <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">attributes:</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'smoothing_error'</span><span class="s2">,</span>
                            <span class="s5">'smoothed_measurement_disturbance'</span><span class="s1">]:</span>
                    <span class="s1">vector = getattr(smoother</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, None</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">vector </span><span class="s2">is not None and </span><span class="s1">has_missing:</span>
                        <span class="s1">vector = np.array(reorder_missing_vector(</span>
                            <span class="s1">vector</span><span class="s2">, </span><span class="s1">self.missing</span><span class="s2">, </span><span class="s1">prefix=self.prefix))</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">vector = np.array(vector</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">vector)</span>
                <span class="s2">elif </span><span class="s1">name == </span><span class="s5">'smoothed_measurement_disturbance_cov'</span><span class="s1">:</span>
                    <span class="s1">matrix = getattr(smoother</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, None</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">matrix </span><span class="s2">is not None and </span><span class="s1">has_missing:</span>
                        <span class="s1">matrix = reorder_missing_matrix(</span>
                            <span class="s1">matrix</span><span class="s2">, </span><span class="s1">self.missing</span><span class="s2">, </span><span class="s1">reorder_rows=</span><span class="s2">True,</span>
                            <span class="s1">reorder_cols=</span><span class="s2">True, </span><span class="s1">prefix=self.prefix)</span>
                        <span class="s4"># In the missing data case, we want to set the missing</span>
                        <span class="s4"># components equal to their unconditional distribution</span>
                        <span class="s1">copy_index_matrix(</span>
                            <span class="s1">self.obs_cov</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">self.missing</span><span class="s2">,</span>
                            <span class="s1">index_rows=</span><span class="s2">True, </span><span class="s1">index_cols=</span><span class="s2">True, </span><span class="s1">inplace=</span><span class="s2">True,</span>
                            <span class="s1">prefix=self.prefix)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">matrix = np.array(matrix</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">matrix)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">,</span>
                            <span class="s1">np.array(getattr(smoother</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">self.innovations_transition = (</span>
            <span class="s1">np.array(smoother.innovations_transition</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">))</span>

        <span class="s4"># Diffuse objects</span>
        <span class="s1">self.scaled_smoothed_diffuse_estimator = </span><span class="s2">None</span>
        <span class="s1">self.scaled_smoothed_diffuse1_estimator_cov = </span><span class="s2">None</span>
        <span class="s1">self.scaled_smoothed_diffuse2_estimator_cov = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.nobs_diffuse &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.scaled_smoothed_diffuse_estimator = np.array(</span>
                <span class="s1">smoother.scaled_smoothed_diffuse_estimator</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.scaled_smoothed_diffuse1_estimator_cov = np.array(</span>
                <span class="s1">smoother.scaled_smoothed_diffuse1_estimator_cov</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.scaled_smoothed_diffuse2_estimator_cov = np.array(</span>
                <span class="s1">smoother.scaled_smoothed_diffuse2_estimator_cov</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s4"># Adjustments</span>

        <span class="s4"># For r_t (and similarly for N_t), what was calculated was</span>
        <span class="s4"># r_T, ..., r_{-1}. We only want r_0, ..., r_T</span>
        <span class="s4"># so exclude the appropriate element so that the time index is</span>
        <span class="s4"># consistent with the other returned output</span>
        <span class="s4"># r_t stored such that scaled_smoothed_estimator[0] == r_{-1}</span>
        <span class="s1">start = </span><span class="s3">1</span>
        <span class="s1">end = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s5">'scaled_smoothed_estimator' </span><span class="s2">in </span><span class="s1">attributes:</span>
            <span class="s1">self.scaled_smoothed_estimator_presample = (</span>
                <span class="s1">self.scaled_smoothed_estimator[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">self.scaled_smoothed_estimator = (</span>
                <span class="s1">self.scaled_smoothed_estimator[:</span><span class="s2">, </span><span class="s1">start:end]</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s5">'scaled_smoothed_estimator_cov' </span><span class="s2">in </span><span class="s1">attributes:</span>
            <span class="s1">self.scaled_smoothed_estimator_cov_presample = (</span>
                <span class="s1">self.scaled_smoothed_estimator_cov[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">self.scaled_smoothed_estimator_cov = (</span>
                <span class="s1">self.scaled_smoothed_estimator_cov[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">start:end]</span>
            <span class="s1">)</span>

        <span class="s4"># Clear the smoothed forecasts</span>
        <span class="s1">self._smoothed_forecasts = </span><span class="s2">None</span>
        <span class="s1">self._smoothed_forecasts_error = </span><span class="s2">None</span>
        <span class="s1">self._smoothed_forecasts_error_cov = </span><span class="s2">None</span>

        <span class="s4"># Note: if we concentrated out the scale, need to adjust the</span>
        <span class="s4"># loglikelihood values and all of the covariance matrices and the</span>
        <span class="s4"># values that depend on the covariance matrices</span>
        <span class="s2">if </span><span class="s1">self.filter_concentrated </span><span class="s2">and </span><span class="s1">self.model._scale </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.smoothed_state_cov *= self.scale</span>
            <span class="s1">self.smoothed_state_autocov *= self.scale</span>
            <span class="s1">self.smoothed_state_disturbance_cov *= self.scale</span>
            <span class="s1">self.smoothed_measurement_disturbance_cov *= self.scale</span>
            <span class="s1">self.scaled_smoothed_estimator_presample /= self.scale</span>
            <span class="s1">self.scaled_smoothed_estimator /= self.scale</span>
            <span class="s1">self.scaled_smoothed_estimator_cov_presample /= self.scale</span>
            <span class="s1">self.scaled_smoothed_estimator_cov /= self.scale</span>
            <span class="s1">self.smoothing_error /= self.scale</span>

        <span class="s4"># Cache</span>
        <span class="s1">self.__smoothed_state_autocovariance = {}</span>

    <span class="s2">def </span><span class="s1">_smoothed_state_autocovariance(self</span><span class="s2">, </span><span class="s1">shift</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">,</span>
                                       <span class="s1">extend_kwargs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute &quot;forward&quot; autocovariances, Cov(t, t+j) 
 
        Parameters 
        ---------- 
        shift : int 
            The number of period to shift forwards when computing the 
            autocovariance. This has the opposite sign as `lag` from the 
            `smoothed_state_autocovariance` method. 
        start : int, optional 
            The start of the interval (inclusive) of autocovariances to compute 
            and return. 
        end : int, optional 
            The end of the interval (exclusive) autocovariances to compute and 
            return. Note that since it is an exclusive endpoint, the returned 
            autocovariances do not include the value at this index. 
        extend_kwargs : dict, optional 
            Keyword arguments containing updated state space system matrices 
            for handling out-of-sample autocovariance computations in 
            time-varying state space models. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">extend_kwargs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">extend_kwargs = {}</span>

        <span class="s4"># Size of returned array in the time dimension</span>
        <span class="s1">n = end - start</span>

        <span class="s4"># Get number of post-sample periods we need to create an extended</span>
        <span class="s4"># model to compute</span>
        <span class="s2">if </span><span class="s1">shift == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">max_insample = self.nobs - shift</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">max_insample = self.nobs - shift + </span><span class="s3">1</span>
        <span class="s1">n_postsample = max(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">end - max_insample)</span>

        <span class="s4"># Get full in-sample arrays</span>
        <span class="s2">if </span><span class="s1">shift != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">L = self.innovations_transition</span>
            <span class="s1">P = self.predicted_state_cov</span>
            <span class="s1">N = self.scaled_smoothed_estimator_cov</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">acov = self.smoothed_state_cov</span>

        <span class="s4"># If applicable, append out-of-sample arrays</span>
        <span class="s2">if </span><span class="s1">n_postsample &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s4"># Note: we need 1 less than the number of post</span>
            <span class="s1">endog = np.zeros((n_postsample</span><span class="s2">, </span><span class="s1">self.k_endog)) * np.nan</span>
            <span class="s1">mod = self.model.extend(endog</span><span class="s2">, </span><span class="s1">start=self.nobs</span><span class="s2">, </span><span class="s1">**extend_kwargs)</span>
            <span class="s1">mod.initialize_known(self.predicted_state[...</span><span class="s2">, </span><span class="s1">self.nobs]</span><span class="s2">,</span>
                                 <span class="s1">self.predicted_state_cov[...</span><span class="s2">, </span><span class="s1">self.nobs])</span>
            <span class="s1">res = mod.smooth()</span>

            <span class="s2">if </span><span class="s1">shift != </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">start_insample = max(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">start)</span>
                <span class="s1">L = np.concatenate((L[...</span><span class="s2">, </span><span class="s1">start_insample:]</span><span class="s2">,</span>
                                    <span class="s1">res.innovations_transition)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">P = np.concatenate((P[...</span><span class="s2">, </span><span class="s1">start_insample:]</span><span class="s2">,</span>
                                    <span class="s1">res.predicted_state_cov[...</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:])</span><span class="s2">,</span>
                                   <span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">N = np.concatenate((N[...</span><span class="s2">, </span><span class="s1">start_insample:]</span><span class="s2">,</span>
                                    <span class="s1">res.scaled_smoothed_estimator_cov)</span><span class="s2">,</span>
                                   <span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">end -= start_insample</span>
                <span class="s1">start -= start_insample</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">acov = np.concatenate((acov</span><span class="s2">, </span><span class="s1">res.predicted_state_cov)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">shift != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s4"># Subset to appropriate start, end</span>
            <span class="s1">start_insample = max(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">start)</span>
            <span class="s1">LT = L[...</span><span class="s2">, </span><span class="s1">start_insample:end + shift - </span><span class="s3">1</span><span class="s1">].T</span>
            <span class="s1">P = P[...</span><span class="s2">, </span><span class="s1">start_insample:end + shift].T</span>
            <span class="s1">N = N[...</span><span class="s2">, </span><span class="s1">start_insample:end + shift - </span><span class="s3">1</span><span class="s1">].T</span>

            <span class="s4"># Intermediate computations</span>
            <span class="s1">tmpLT = np.eye(self.k_states)[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">length = P.shape[</span><span class="s3">0</span><span class="s1">] - shift  </span><span class="s4"># this is the required length of LT</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">shift + </span><span class="s3">1</span><span class="s1">):</span>
                <span class="s1">tmpLT = LT[shift - i:length + shift - i] @ tmpLT</span>
            <span class="s1">eye = np.eye(self.k_states)[</span><span class="s2">None, </span><span class="s1">...]</span>

            <span class="s4"># Compute the autocovariance</span>
            <span class="s1">acov = np.zeros((n</span><span class="s2">, </span><span class="s1">self.k_states</span><span class="s2">, </span><span class="s1">self.k_states))</span>
            <span class="s1">acov[:start_insample - start] = np.nan</span>
            <span class="s1">acov[start_insample - start:] = (</span>
                <span class="s1">P[:-shift] @ tmpLT @ (eye - N[shift - </span><span class="s3">1</span><span class="s1">:] @ P[shift:]))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">acov = acov.T[start:end]</span>

        <span class="s2">return </span><span class="s1">acov</span>

    <span class="s2">def </span><span class="s1">smoothed_state_autocovariance(self</span><span class="s2">, </span><span class="s1">lag=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">t=</span><span class="s2">None, </span><span class="s1">start=</span><span class="s2">None,</span>
                                      <span class="s1">end=</span><span class="s2">None, </span><span class="s1">extend_kwargs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Compute state vector autocovariances, conditional on the full dataset 
 
        Computes: 
 
        .. math:: 
 
            Cov(\alpha_t - \hat \alpha_t, \alpha_{t - j} - \hat \alpha_{t - j}) 
 
        where the `lag` argument gives the value for :math:`j`. Thus when 
        the `lag` argument is positive, the autocovariance is between the 
        current and previous periods, while if `lag` is negative the 
        autocovariance is between the current and future periods. 
 
        Parameters 
        ---------- 
        lag : int, optional 
            The number of period to shift when computing the autocovariance. 
            Default is 1. 
        t : int, optional 
            A specific period for which to compute and return the 
            autocovariance. Cannot be used in combination with `start` or 
            `end`. See the Returns section for details on how this 
            parameter affects what is what is returned. 
        start : int, optional 
            The start of the interval (inclusive) of autocovariances to compute 
            and return. Cannot be used in combination with the `t` argument. 
            See the Returns section for details on how this parameter affects 
            what is what is returned. Default is 0. 
        end : int, optional 
            The end of the interval (exclusive) autocovariances to compute and 
            return. Note that since it is an exclusive endpoint, the returned 
            autocovariances do not include the value at this index. Cannot be 
            used in combination with the `t` argument. See the Returns section 
            for details on how this parameter affects what is what is returned 
            and what the default value is. 
        extend_kwargs : dict, optional 
            Keyword arguments containing updated state space system matrices 
            for handling out-of-sample autocovariance computations in 
            time-varying state space models. 
 
        Returns 
        ------- 
        acov : ndarray 
            Array of autocovariance matrices. If the argument `t` is not 
            provided, then it is shaped `(k_states, k_states, n)`, while if `t` 
            given then the third axis is dropped and the array is shaped 
            `(k_states, k_states)`. 
 
            The output under the default case differs somewhat based on the 
            state space model and the sign of the lag. To see how these cases 
            differ, denote the output at each time point as Cov(t, t-j). Then: 
 
            - If `lag &gt; 0` (and the model is either time-varying or 
              time-invariant), then the returned array is shaped `(*, *, nobs)` 
              and each entry [:, :, t] contains Cov(t, t-j). However, the model 
              does not have enough information to compute autocovariances in 
              the pre-sample period, so that we cannot compute Cov(1, 1-lag), 
              Cov(2, 2-lag), ..., Cov(lag, 0). Thus the first `lag` entries 
              have all values set to NaN. 
 
            - If the model is time-invariant and `lag &lt; -1` or if `lag` is 
              0 or -1, and the model is either time-invariant or time-varying, 
              then the returned array is shaped `(*, *, nobs)` and each 
              entry [:, :, t] contains Cov(t, t+j). Moreover, all entries are 
              available (i.e. there are no NaNs). 
 
            - If the model is time-varying and `lag &lt; -1` and `extend_kwargs` 
              is not provided, then the returned array is shaped 
              `(*, *, nobs - lag + 1)`. 
 
            - However, if the model is time-varying and `lag &lt; -1`, then 
              `extend_kwargs` can be provided with `lag - 1` additional 
              matrices so that the returned array is shaped `(*, *, nobs)` as 
              usual. 
 
            More generally, the dimension of the last axis will be 
            `start - end`. 
 
        Notes 
        ----- 
        This method computes: 
 
        .. math:: 
 
            Cov(\alpha_t - \hat \alpha_t, \alpha_{t - j} - \hat \alpha_{t - j}) 
 
        where the `lag` argument determines the autocovariance order :math:`j`, 
        and `lag` is an integer (positive, zero, or negative). This method 
        cannot compute values associated with time points prior to the sample, 
        and so it returns a matrix of NaN values for these time points. 
        For example, if `start=0` and `lag=2`, then assuming the output is 
        assigned to the variable `acov`, we will have `acov[..., 0]` and 
        `acov[..., 1]` as matrices filled with NaN values. 
 
        Based only on the &quot;current&quot; results object (i.e. the Kalman smoother 
        applied to the sample), there is not enough information to compute 
        Cov(t, t+j) for the last `lag - 1` observations of the sample. However, 
        the values can be computed for these time points using the transition 
        equation of the state space representation, and so for time-invariant 
        state space models we do compute these values. For time-varying models, 
        this can also be done, but updated state space matrices for the 
        out-of-sample time points must be provided via the `extend_kwargs` 
        argument. 
 
        See [1]_, Chapter 4.7, for all details about how these autocovariances 
        are computed. 
 
        The `t` and `start`/`end` parameters compute and return only the 
        requested autocovariances. As a result, using these parameters is 
        recommended to reduce the computational burden, particularly if the 
        number of observations and/or the dimension of the state vector is 
        large. 
 
        References 
        ---------- 
        .. [1] Durbin, James, and Siem Jan Koopman. 2012. 
               Time Series Analysis by State Space Methods: Second Edition. 
               Oxford University Press. 
        &quot;&quot;&quot;</span>
        <span class="s4"># We can cache the results for time-invariant models</span>
        <span class="s1">cache_key = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">extend_kwargs </span><span class="s2">is None or </span><span class="s1">len(extend_kwargs) == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">cache_key = (lag</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span>

        <span class="s4"># Short-circuit for a cache-hit</span>
        <span class="s2">if </span><span class="s1">(cache_key </span><span class="s2">is not None and</span>
                <span class="s1">cache_key </span><span class="s2">in </span><span class="s1">self.__smoothed_state_autocovariance):</span>
            <span class="s2">return </span><span class="s1">self.__smoothed_state_autocovariance[cache_key]</span>

        <span class="s4"># Switch to only positive values for `lag`</span>
        <span class="s1">forward_autocovariances = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">lag &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">lag = -lag</span>
            <span class="s1">forward_autocovariances = </span><span class="s2">True</span>

        <span class="s4"># Handle `t`</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None and </span><span class="s1">(start </span><span class="s2">is not None or </span><span class="s1">end </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Cannot specify both `t` and `start` or `end`.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">start = t</span>
            <span class="s1">end = t + </span><span class="s3">1</span>

        <span class="s4"># Defaults</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">start = </span><span class="s3">0</span>
        <span class="s2">if </span><span class="s1">end </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">forward_autocovariances </span><span class="s2">and </span><span class="s1">lag &gt; </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">extend_kwargs </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">end = self.nobs - lag + </span><span class="s3">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">end = self.nobs</span>
        <span class="s2">if </span><span class="s1">extend_kwargs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">extend_kwargs = {}</span>

        <span class="s4"># Sanity checks</span>
        <span class="s2">if </span><span class="s1">start &lt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">end &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Negative `t`, `start`, or `end` is not allowed.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">end &lt; start:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'`end` must be after `start`'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">lag == </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">self.smoothed_state_cov </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s5">'Cannot return smoothed state covariances'</span>
                               <span class="s5">' if those values have not been computed by'</span>
                               <span class="s5">' Kalman smoothing.'</span><span class="s1">)</span>

        <span class="s4"># We already have in-sample (+1 out-of-sample) smoothed covariances</span>
        <span class="s2">if </span><span class="s1">lag == </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">end &lt;= self.nobs + </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">acov = self.smoothed_state_cov</span>
            <span class="s2">if </span><span class="s1">end == self.nobs + </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">acov = np.concatenate(</span>
                    <span class="s1">(acov[...</span><span class="s2">, </span><span class="s1">start:]</span><span class="s2">, </span><span class="s1">self.predicted_state_cov[...</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">:])</span><span class="s2">,</span>
                    <span class="s1">axis=</span><span class="s3">2</span><span class="s1">).T</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">acov = acov.T[start:end]</span>
        <span class="s4"># In-sample, we can compute up to Cov(T, T+1) or Cov(T+1, T) and down</span>
        <span class="s4"># to Cov(1, 2) or Cov(2, 1). So:</span>
        <span class="s4"># - For lag=1 we set Cov(1, 0) = np.nan and then can compute up to T-1</span>
        <span class="s4">#   in-sample values Cov(2, 1), ..., Cov(T, T-1) and the first</span>
        <span class="s4">#   out-of-sample value Cov(T+1, T)</span>
        <span class="s2">elif </span><span class="s1">(lag == </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">self.smoothed_state_autocov </span><span class="s2">is not None and</span>
                <span class="s2">not </span><span class="s1">forward_autocovariances </span><span class="s2">and </span><span class="s1">end &lt;= self.nobs + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s4"># nans = np.zeros((self.k_states, self.k_states, lag)) * np.nan</span>
            <span class="s4"># acov = np.concatenate((nans, self.smoothed_state_autocov),</span>
            <span class="s4">#                       axis=2).transpose(2, 0, 1)[start:end]</span>
            <span class="s2">if </span><span class="s1">start == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">nans = np.zeros((self.k_states</span><span class="s2">, </span><span class="s1">self.k_states</span><span class="s2">, </span><span class="s1">lag)) * np.nan</span>
                <span class="s1">acov = np.concatenate(</span>
                    <span class="s1">(nans</span><span class="s2">, </span><span class="s1">self.smoothed_state_autocov[...</span><span class="s2">, </span><span class="s1">:end - </span><span class="s3">1</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">acov = self.smoothed_state_autocov[...</span><span class="s2">, </span><span class="s1">start - </span><span class="s3">1</span><span class="s1">:end - </span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">acov = acov.transpose(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s4"># - For lag=-1 we can compute T in-sample values, Cov(1, 2), ...,</span>
        <span class="s4">#   Cov(T, T+1) but we cannot compute the first out-of-sample value</span>
        <span class="s4">#   Cov(T+1, T+2).</span>
        <span class="s2">elif </span><span class="s1">(lag == </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">self.smoothed_state_autocov </span><span class="s2">is not None and</span>
                <span class="s1">forward_autocovariances </span><span class="s2">and </span><span class="s1">end &lt; self.nobs + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">acov = self.smoothed_state_autocov.T[start:end]</span>
        <span class="s4"># Otherwise, we need to compute additional values at the end of the</span>
        <span class="s4"># sample</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">forward_autocovariances:</span>
                <span class="s4"># Cov(t, t + lag), t = start, ..., end</span>
                <span class="s1">acov = self._smoothed_state_autocovariance(</span>
                    <span class="s1">lag</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">extend_kwargs=extend_kwargs)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Cov(t, t + lag)' = Cov(t + lag, t),</span>
                <span class="s4"># with t = start - lag, ..., end - lag</span>
                <span class="s1">out = self._smoothed_state_autocovariance(</span>
                    <span class="s1">lag</span><span class="s2">, </span><span class="s1">start - lag</span><span class="s2">, </span><span class="s1">end - lag</span><span class="s2">, </span><span class="s1">extend_kwargs=extend_kwargs)</span>
                <span class="s1">acov = out.transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s4"># Squeeze the last axis or else reshape to have the same axis</span>
        <span class="s4"># definitions as e.g. smoothed_state_cov</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">acov = acov[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">acov = acov.transpose(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s4"># Fill in the cache, if applicable</span>
        <span class="s2">if </span><span class="s1">cache_key </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.__smoothed_state_autocovariance[cache_key] = acov</span>

        <span class="s2">return </span><span class="s1">acov</span>

    <span class="s2">def </span><span class="s1">news(self</span><span class="s2">, </span><span class="s1">previous</span><span class="s2">, </span><span class="s1">t=</span><span class="s2">None, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">end=</span><span class="s2">None,</span>
             <span class="s1">revised=</span><span class="s2">None, </span><span class="s1">design=</span><span class="s2">None, </span><span class="s1">state_index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Compute the news and impacts associated with a data release 
 
        Parameters 
        ---------- 
        previous : SmootherResults 
            Prior results object relative to which to compute the news. This 
            results object must have identical state space representation for 
            the prior sample period so that the only difference is that this 
            results object has updates to the observed data. 
        t : int, optional 
            A specific period for which to compute the news. Cannot be used in 
            combination with `start` or `end`. 
        start : int, optional 
            The start of the interval (inclusive) of news to compute. Cannot be 
            used in combination with the `t` argument. Default is the last 
            period of the sample (`nobs - 1`). 
        end : int, optional 
            The end of the interval (exclusive) of news to compute. Note that 
            since it is an exclusive endpoint, the returned news do not include 
            the value at this index. Cannot be used in combination with the `t` 
            argument. 
        design : array, optional 
            Design matrix for the period `t` in time-varying models. If this 
            model has a time-varying design matrix, and the argument `t` is out 
            of this model's sample, then a new design matrix for period `t` 
            must be provided. Unused otherwise. 
        state_index : array_like, optional 
            An optional index specifying a subset of states to use when 
            constructing the impacts of revisions and news. For example, if 
            `state_index=[0, 1]` is passed, then only the impacts to the 
            observed variables arising from the impacts to the first two 
            states will be returned. 
 
        Returns 
        ------- 
        news_results : SimpleNamespace 
            News and impacts associated with a data release. Includes the 
            following attributes: 
 
            - `update_impacts`: update to forecasts of impacted variables from 
              the news. It is equivalent to E[y^i | post] - E[y^i | revision], 
              where y^i are the variables of interest. In [1]_, this is 
              described as &quot;revision&quot; in equation (17). 
            - `revision_impacts`: update to forecasts of variables impacted 
              variables from data revisions. It is 
              E[y^i | revision] - E[y^i | previous], and does not have a 
              specific notation in [1]_, since there for simplicity they assume 
              that there are no revisions. 
            - `news`: the unexpected component of the updated data. Denoted 
              I = y^u - E[y^u | previous], where y^u are the data points that 
              were newly incorporated in a data release (but not including 
              revisions to data points that already existed in the previous 
              release). In [1]_, this is described as &quot;news&quot; in equation (17). 
            - `revisions` 
            - `gain`: the gain matrix associated with the &quot;Kalman-like&quot; update 
              from the news, E[y I'] E[I I']^{-1}. In [1]_, this can be found 
              in the equation For E[y_{k,t_k} \mid I_{v+1}] in the middle of 
              page 17. 
            - `revision_weights` 
            - `update_forecasts`: forecasts of the updated periods used to 
              construct the news, E[y^u | previous]. 
            - `update_realized`: realizations of the updated periods used to 
              construct the news, y^u. 
            - `revised_prev` 
            - `revised` 
            - `prev_impacted_forecasts`: previous forecast of the periods of 
              interest, E[y^i | previous]. 
            - `post_impacted_forecasts`: forecast of the periods of interest 
              after taking into account both revisions and updates, 
              E[y^i | post]. 
            - `revision_results`: results object that updates the `previous` 
              results to take into account data revisions. 
            - `revisions_ix`: list of `(t, i)` positions of revisions in endog 
            - `updates_ix`: list of `(t, i)` positions of updates to endog 
 
        Notes 
        ----- 
        This method computes the effect of new data (e.g. from a new data 
        release) on smoothed forecasts produced by a state space model, as 
        described in [1]_. It also computes the effect of revised data on 
        smoothed forecasts. 
 
        References 
        ---------- 
        .. [1] Babura, Marta and Modugno, Michele. 2010. 
               &quot;Maximum likelihood estimation of factor models on data sets 
               with arbitrary pattern of missing data.&quot; 
               No 1189, Working Paper Series, European Central Bank. 
               https://EconPapers.repec.org/RePEc:ecb:ecbwps:20101189. 
        .. [2] Babura, Marta, and Michele Modugno. 
               &quot;Maximum likelihood estimation of factor models on datasets with 
               arbitrary pattern of missing data.&quot; 
               Journal of Applied Econometrics 29, no. 1 (2014): 133-160. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># Handle `t`</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None and </span><span class="s1">(start </span><span class="s2">is not None or </span><span class="s1">end </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Cannot specify both `t` and `start` or `end`.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">start = t</span>
            <span class="s1">end = t + </span><span class="s3">1</span>

        <span class="s4"># Defaults</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">start = self.nobs - </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">end </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">end = self.nobs</span>

        <span class="s4"># Sanity checks</span>
        <span class="s2">if </span><span class="s1">start &lt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">end &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Negative `t`, `start`, or `end` is not allowed.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">end &lt;= start:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'`end` must be after `start`'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.smoothed_state_cov </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Cannot compute news without having applied the'</span>
                             <span class="s5">' Kalman smoother first.'</span><span class="s1">)</span>

        <span class="s1">error_ss = (</span><span class="s5">'This results object has %s and so it does not appear to'</span>
                    <span class="s5">' by an extension of `previous`. Can only compute the'</span>
                    <span class="s5">' news by comparing this results set to previous results'</span>
                    <span class="s5">' objects.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.nobs &lt; previous.nobs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(error_ss % </span><span class="s5">'fewer observations than'</span>
                             <span class="s5">' `previous`'</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">(self.k_endog == previous.k_endog </span><span class="s2">and</span>
                <span class="s1">self.k_states == previous.k_states </span><span class="s2">and</span>
                <span class="s1">self.k_posdef == previous.k_posdef):</span>
            <span class="s2">raise </span><span class="s1">ValueError(error_ss % </span><span class="s5">'different state space dimensions than'</span>
                             <span class="s5">' `previous`'</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.model.shapes.keys():</span>
            <span class="s2">if </span><span class="s1">key == </span><span class="s5">'obs'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">tv = getattr(self</span><span class="s2">, </span><span class="s1">key).shape[-</span><span class="s3">1</span><span class="s1">] &gt; </span><span class="s3">1</span>
            <span class="s1">tv_prev = getattr(previous</span><span class="s2">, </span><span class="s1">key).shape[-</span><span class="s3">1</span><span class="s1">] &gt; </span><span class="s3">1</span>
            <span class="s2">if </span><span class="s1">tv </span><span class="s2">and not </span><span class="s1">tv_prev:</span>
                <span class="s2">raise </span><span class="s1">ValueError(error_ss % </span><span class="s5">f'time-varying </span><span class="s2">{</span><span class="s1">key</span><span class="s2">} </span><span class="s5">while'</span>
                                 <span class="s5">' `previous` does not'</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">tv </span><span class="s2">and </span><span class="s1">tv_prev:</span>
                <span class="s2">raise </span><span class="s1">ValueError(error_ss % </span><span class="s5">f'time-invariant </span><span class="s2">{</span><span class="s1">key</span><span class="s2">} </span><span class="s5">while'</span>
                                 <span class="s5">' `previous` does not'</span><span class="s1">)</span>

        <span class="s4"># Standardize</span>
        <span class="s2">if </span><span class="s1">state_index </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">state_index = np.atleast_1d(</span>
                <span class="s1">np.sort(np.array(state_index</span><span class="s2">, </span><span class="s1">dtype=int)))</span>

        <span class="s4"># We cannot forecast out-of-sample periods in a time-varying model</span>
        <span class="s2">if </span><span class="s1">end &gt; self.nobs </span><span class="s2">and not </span><span class="s1">self.model.time_invariant:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s5">'Cannot compute the impacts of news on periods'</span>
                               <span class="s5">' outside of the sample in time-varying'</span>
                               <span class="s5">' models.'</span><span class="s1">)</span>

        <span class="s4"># For time-varying case, figure out extension kwargs</span>
        <span class="s1">extend_kwargs = {}</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.model.shapes.keys():</span>
            <span class="s2">if </span><span class="s1">key == </span><span class="s5">'obs'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">mat = getattr(self</span><span class="s2">, </span><span class="s1">key)</span>
            <span class="s1">prev_mat = getattr(previous</span><span class="s2">, </span><span class="s1">key)</span>
            <span class="s2">if </span><span class="s1">mat.shape[-</span><span class="s3">1</span><span class="s1">] &gt; prev_mat.shape[-</span><span class="s3">1</span><span class="s1">]:</span>
                <span class="s1">extend_kwargs[key] = mat[...</span><span class="s2">, </span><span class="s1">prev_mat.shape[-</span><span class="s3">1</span><span class="s1">]:]</span>

        <span class="s4"># Figure out which indices have changed</span>
        <span class="s1">revisions_ix</span><span class="s2">, </span><span class="s1">updates_ix = previous.model.diff_endog(self.endog.T)</span>

        <span class="s4"># Compute prev / post impact forecasts</span>
        <span class="s1">prev_impacted_forecasts = previous.predict(</span>
            <span class="s1">start=start</span><span class="s2">, </span><span class="s1">end=end</span><span class="s2">, </span><span class="s1">**extend_kwargs).smoothed_forecasts</span>
        <span class="s1">post_impacted_forecasts = self.predict(</span>
            <span class="s1">start=start</span><span class="s2">, </span><span class="s1">end=end).smoothed_forecasts</span>

        <span class="s4"># Get revision weights, impacts, and forecasts</span>
        <span class="s2">if </span><span class="s1">len(revisions_ix) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">revised_endog = self.endog[:</span><span class="s2">, </span><span class="s1">:previous.nobs].copy()</span>
            <span class="s1">revised_endog[previous.missing.astype(bool)] = np.nan</span>

            <span class="s4"># Compute the revisions</span>
            <span class="s1">revised_j</span><span class="s2">, </span><span class="s1">revised_p = zip(*revisions_ix)</span>
            <span class="s1">compute_j = np.arange(revised_j[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">revised_j[-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">revised_prev = previous.endog.T[compute_j]</span>
            <span class="s1">revised = revised_endog.T[compute_j]</span>
            <span class="s1">revisions = (revised - revised_prev)</span>

            <span class="s4"># Compute the weights of the smoothed state vector</span>
            <span class="s1">compute_t = np.arange(start</span><span class="s2">, </span><span class="s1">end)</span>
            <span class="s1">ix = np.ix_(compute_t</span><span class="s2">, </span><span class="s1">compute_j)</span>

            <span class="s4"># Construct a model from which we can create weights for impacts</span>
            <span class="s4"># through `end`</span>
            <span class="s4"># Construct endog for the new model</span>
            <span class="s1">tmp_endog = revised_endog.T.copy()</span>
            <span class="s1">tmp_nobs = max(end</span><span class="s2">, </span><span class="s1">previous.nobs)</span>
            <span class="s1">oos_nobs = tmp_nobs - previous.nobs</span>
            <span class="s2">if </span><span class="s1">oos_nobs &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">tmp_endog = np.concatenate([</span>
                    <span class="s1">tmp_endog</span><span class="s2">, </span><span class="s1">np.zeros((oos_nobs</span><span class="s2">, </span><span class="s1">self.k_endog)) * np.nan</span>
                <span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>

            <span class="s4"># Copy time-varying matrices (required by clone)</span>
            <span class="s1">clone_kwargs = {}</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.model.shapes.keys():</span>
                <span class="s2">if </span><span class="s1">key == </span><span class="s5">'obs'</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s1">mat = getattr(self</span><span class="s2">, </span><span class="s1">key)</span>
                <span class="s2">if </span><span class="s1">mat.shape[-</span><span class="s3">1</span><span class="s1">] &gt; </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">clone_kwargs[key] = mat[...</span><span class="s2">, </span><span class="s1">:tmp_nobs]</span>

            <span class="s1">rev_mod = previous.model.clone(tmp_endog</span><span class="s2">, </span><span class="s1">**clone_kwargs)</span>
            <span class="s1">init = initialization.Initialization.from_results(self)</span>
            <span class="s1">rev_mod.initialize(init)</span>
            <span class="s1">revision_results = rev_mod.smooth()</span>

            <span class="s1">smoothed_state_weights</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = (</span>
                <span class="s1">tools._compute_smoothed_state_weights(</span>
                    <span class="s1">rev_mod</span><span class="s2">, </span><span class="s1">compute_t=compute_t</span><span class="s2">, </span><span class="s1">compute_j=compute_j</span><span class="s2">,</span>
                    <span class="s1">compute_prior_weights=</span><span class="s2">False, </span><span class="s1">scale=previous.scale))</span>
            <span class="s1">smoothed_state_weights = smoothed_state_weights[ix]</span>

            <span class="s4"># Convert the weights in terms of smoothed forecasts</span>
            <span class="s4"># t, j, m, p, i</span>
            <span class="s1">ZT = rev_mod.design.T</span>
            <span class="s2">if </span><span class="s1">ZT.shape[</span><span class="s3">0</span><span class="s1">] &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">ZT = ZT[compute_t]</span>

            <span class="s4"># Subset the states used for the impacts if applicable</span>
            <span class="s2">if </span><span class="s1">state_index </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">ZT = ZT[:</span><span class="s2">, </span><span class="s1">state_index</span><span class="s2">, </span><span class="s1">:]</span>
                <span class="s1">smoothed_state_weights = (</span>
                    <span class="s1">smoothed_state_weights[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">state_index])</span>

            <span class="s4"># Multiplication gives: t, j, m, p * t, j, m, p, k</span>
            <span class="s4"># Sum along axis=2 gives: t, j, p, k</span>
            <span class="s4"># Transpose to: t, j, k, p (i.e. like t, j, m, p but with k instead</span>
            <span class="s4"># of m)</span>
            <span class="s1">revision_weights = np.nansum(</span>
                <span class="s1">smoothed_state_weights[...</span><span class="s2">, None</span><span class="s1">]</span>
                <span class="s1">* ZT[:</span><span class="s2">, None, </span><span class="s1">:</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">).transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>

            <span class="s4"># Multiplication gives: t, j, k, p * t, j, k, p</span>
            <span class="s4"># Sum along axes 1, 3 gives: t, k</span>
            <span class="s4"># This is also a valid way to compute impacts, but it employes</span>
            <span class="s4"># unnecessary multiplications with zeros; it is better to use the</span>
            <span class="s4"># below method that flattens the revision indices before computing</span>
            <span class="s4"># the impacts</span>
            <span class="s4"># revision_impacts = np.nansum(</span>
            <span class="s4">#     revision_weights * revisions[None, :, None, :], axis=(1, 3))</span>

            <span class="s4"># Flatten the weights and revisions along the revised j, k</span>
            <span class="s4"># dimensions so that we only retain the actual revision elements</span>
            <span class="s1">ix_j = revised_j - revised_j[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s4"># Shape is: t, k, j * p</span>
            <span class="s4"># Note: have to transpose first so that the two advanced indexes</span>
            <span class="s4"># are next to each other, so that &quot;the dimensions from the</span>
            <span class="s4"># advanced indexing operations are inserted into the result</span>
            <span class="s4"># array at the same spot as they were in the initial array&quot;</span>
            <span class="s4"># (see https://numpy.org/doc/stable/user/basics.indexing.html,</span>
            <span class="s4"># &quot;Combining advanced and basic indexing&quot;)</span>
            <span class="s1">revision_weights = (</span>
                <span class="s1">revision_weights.transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">ix_j</span><span class="s2">, </span><span class="s1">revised_p])</span>
            <span class="s4"># Shape is j * k</span>
            <span class="s1">revisions = revisions[ix_j</span><span class="s2">, </span><span class="s1">revised_p]</span>
            <span class="s4"># Shape is t, k</span>
            <span class="s1">revision_impacts = revision_weights @ revisions</span>

            <span class="s4"># Similarly, flatten the revised and revised_prev series</span>
            <span class="s1">revised = revised[ix_j</span><span class="s2">, </span><span class="s1">revised_p]</span>
            <span class="s1">revised_prev = revised_prev[ix_j</span><span class="s2">, </span><span class="s1">revised_p]</span>

            <span class="s4"># Squeeze if `t` argument used</span>
            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">revision_weights = revision_weights[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">revision_impacts = revision_impacts[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">revised_endog = </span><span class="s2">None</span>
            <span class="s1">revised = </span><span class="s2">None</span>
            <span class="s1">revised_prev = </span><span class="s2">None</span>
            <span class="s1">revisions = </span><span class="s2">None</span>
            <span class="s1">revision_weights = </span><span class="s2">None</span>
            <span class="s1">revision_impacts = </span><span class="s2">None</span>
            <span class="s1">revision_results = </span><span class="s2">None</span>

        <span class="s4"># Now handle updates</span>
        <span class="s2">if </span><span class="s1">len(updates_ix) &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s4"># Figure out which time points we need forecast errors for</span>
            <span class="s1">update_t</span><span class="s2">, </span><span class="s1">update_k = zip(*updates_ix)</span>
            <span class="s1">update_start_t = np.min(update_t)</span>
            <span class="s1">update_end_t = np.max(update_t)</span>

            <span class="s2">if </span><span class="s1">revision_results </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">forecasts = previous.predict(</span>
                    <span class="s1">start=update_start_t</span><span class="s2">, </span><span class="s1">end=update_end_t + </span><span class="s3">1</span><span class="s2">,</span>
                    <span class="s1">**extend_kwargs).smoothed_forecasts.T</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">forecasts = revision_results.predict(</span>
                    <span class="s1">start=update_start_t</span><span class="s2">,</span>
                    <span class="s1">end=update_end_t + </span><span class="s3">1</span><span class="s1">).smoothed_forecasts.T</span>
            <span class="s1">realized = self.endog.T[update_start_t:update_end_t + </span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">forecasts_error = realized - forecasts</span>

            <span class="s4"># Now subset forecast errors to only the (time, endog) elements</span>
            <span class="s4"># that are updates</span>
            <span class="s1">ix_t = update_t - update_start_t</span>
            <span class="s1">update_realized = realized[ix_t</span><span class="s2">, </span><span class="s1">update_k]</span>
            <span class="s1">update_forecasts = forecasts[ix_t</span><span class="s2">, </span><span class="s1">update_k]</span>
            <span class="s1">update_forecasts_error = forecasts_error[ix_t</span><span class="s2">, </span><span class="s1">update_k]</span>

            <span class="s4"># Get the gains associated with each of the periods</span>
            <span class="s2">if </span><span class="s1">self.design.shape[</span><span class="s3">2</span><span class="s1">] == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">design = self.design[...</span><span class="s2">, </span><span class="s3">0</span><span class="s1">][</span><span class="s2">None, </span><span class="s1">...]</span>
            <span class="s2">elif </span><span class="s1">end &lt;= self.nobs:</span>
                <span class="s1">design = self.design[...</span><span class="s2">, </span><span class="s1">start:end].transpose(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Note: this case is no longer possible, since above we raise</span>
                <span class="s4"># ValueError for time-varying case with end &gt; self.nobs</span>
                <span class="s2">if </span><span class="s1">design </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Model has time-varying design matrix, so'</span>
                                     <span class="s5">' an updated time-varying matrix for'</span>
                                     <span class="s5">' period `t` is required.'</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">design.ndim == </span><span class="s3">2</span><span class="s1">:</span>
                    <span class="s1">design = design[</span><span class="s2">None, </span><span class="s1">...]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">design = design.transpose(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>

            <span class="s1">state_gain = previous.smoothed_state_gain(</span>
                <span class="s1">updates_ix</span><span class="s2">, </span><span class="s1">start=start</span><span class="s2">, </span><span class="s1">end=end</span><span class="s2">, </span><span class="s1">extend_kwargs=extend_kwargs)</span>

            <span class="s4"># Subset the states used for the impacts if applicable</span>
            <span class="s2">if </span><span class="s1">state_index </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">design = design[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">state_index]</span>
                <span class="s1">state_gain = state_gain[:</span><span class="s2">, </span><span class="s1">state_index]</span>

            <span class="s4"># Compute the gain in terms of observed variables</span>
            <span class="s1">obs_gain = design @ state_gain</span>

            <span class="s4"># Get the news</span>
            <span class="s1">update_impacts = obs_gain @ update_forecasts_error</span>

            <span class="s4"># Squeeze if `t` argument used</span>
            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">obs_gain = obs_gain[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">update_impacts = update_impacts[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">update_impacts = </span><span class="s2">None</span>
            <span class="s1">update_forecasts = </span><span class="s2">None</span>
            <span class="s1">update_realized = </span><span class="s2">None</span>
            <span class="s1">update_forecasts_error = </span><span class="s2">None</span>
            <span class="s1">obs_gain = </span><span class="s2">None</span>

        <span class="s4"># Results</span>
        <span class="s1">out = SimpleNamespace(</span>
            <span class="s4"># update to forecast of impacted variables from news</span>
            <span class="s4"># = E[y^i | post] - E[y^i | revision] = weight @ news</span>
            <span class="s1">update_impacts=update_impacts</span><span class="s2">,</span>
            <span class="s4"># update to forecast of variables of interest from revisions</span>
            <span class="s4"># = E[y^i | revision] - E[y^i | previous]</span>
            <span class="s1">revision_impacts=revision_impacts</span><span class="s2">,</span>
            <span class="s4"># news = A = y^u - E[y^u | previous]</span>
            <span class="s1">news=update_forecasts_error</span><span class="s2">,</span>
            <span class="s4"># revivions y^r(updated) - y^r(previous)</span>
            <span class="s1">revisions=revisions</span><span class="s2">,</span>
            <span class="s4"># gain matrix = E[y A'] E[A A']^{-1}</span>
            <span class="s1">gain=obs_gain</span><span class="s2">,</span>
            <span class="s4"># weights on observations for the smoothed signal</span>
            <span class="s1">revision_weights=revision_weights</span><span class="s2">,</span>
            <span class="s4"># forecasts of the updated periods used to construct the news</span>
            <span class="s4"># = E[y^u | revised]</span>
            <span class="s1">update_forecasts=update_forecasts</span><span class="s2">,</span>
            <span class="s4"># realizations of the updated periods used to construct the news</span>
            <span class="s4"># = y^u</span>
            <span class="s1">update_realized=update_realized</span><span class="s2">,</span>
            <span class="s4"># revised observations of the periods that were revised</span>
            <span class="s4"># = y^r_{revised}</span>
            <span class="s1">revised=revised</span><span class="s2">,</span>
            <span class="s4"># previous observations of the periods that were revised</span>
            <span class="s4"># = y^r_{previous}</span>
            <span class="s1">revised_prev=revised_prev</span><span class="s2">,</span>
            <span class="s4"># previous forecast of the periods of interest, E[y^i | previous]</span>
            <span class="s1">prev_impacted_forecasts=prev_impacted_forecasts</span><span class="s2">,</span>
            <span class="s4"># post. forecast of the periods of interest, E[y^i | post]</span>
            <span class="s1">post_impacted_forecasts=post_impacted_forecasts</span><span class="s2">,</span>
            <span class="s4"># results object associated with the revision</span>
            <span class="s1">revision_results=revision_results</span><span class="s2">,</span>
            <span class="s4"># list of (x, y) positions of revisions to endog</span>
            <span class="s1">revisions_ix=revisions_ix</span><span class="s2">,</span>
            <span class="s4"># list of (x, y) positions of updates to endog</span>
            <span class="s1">updates_ix=updates_ix</span><span class="s2">,</span>
            <span class="s4"># index of state variables used to compute impacts</span>
            <span class="s1">state_index=state_index)</span>

        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">smoothed_state_gain(self</span><span class="s2">, </span><span class="s1">updates_ix</span><span class="s2">, </span><span class="s1">t=</span><span class="s2">None, </span><span class="s1">start=</span><span class="s2">None,</span>
                            <span class="s1">end=</span><span class="s2">None, </span><span class="s1">extend_kwargs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Cov(\tilde \alpha_{t}, I) Var(I, I)^{-1} 
 
        where I is a vector of forecast errors associated with 
        `update_indices`. 
 
        Parameters 
        ---------- 
        updates_ix : list 
            List of indices `(t, i)`, where `t` denotes a zero-indexed time 
            location and `i` denotes a zero-indexed endog variable. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Handle `t`</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None and </span><span class="s1">(start </span><span class="s2">is not None or </span><span class="s1">end </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Cannot specify both `t` and `start` or `end`.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">start = t</span>
            <span class="s1">end = t + </span><span class="s3">1</span>

        <span class="s4"># Defaults</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">start = self.nobs - </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">end </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">end = self.nobs</span>
        <span class="s2">if </span><span class="s1">extend_kwargs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">extend_kwargs = {}</span>

        <span class="s4"># Sanity checks</span>
        <span class="s2">if </span><span class="s1">start &lt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">end &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Negative `t`, `start`, or `end` is not allowed.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">end &lt;= start:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'`end` must be after `start`'</span><span class="s1">)</span>

        <span class="s4"># Dimensions</span>
        <span class="s1">n_periods = end - start</span>
        <span class="s1">n_updates = len(updates_ix)</span>

        <span class="s4"># Helper to get possibly matrix that is possibly time-varying</span>
        <span class="s2">def </span><span class="s1">get_mat(which</span><span class="s2">, </span><span class="s1">t):</span>
            <span class="s1">mat = getattr(self</span><span class="s2">, </span><span class="s1">which)</span>
            <span class="s2">if </span><span class="s1">mat.shape[-</span><span class="s3">1</span><span class="s1">] &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">t &lt; self.nobs:</span>
                    <span class="s1">out = mat[...</span><span class="s2">, </span><span class="s1">t]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(which </span><span class="s2">not in </span><span class="s1">extend_kwargs </span><span class="s2">or</span>
                            <span class="s1">extend_kwargs[which].shape[-</span><span class="s3">1</span><span class="s1">] &lt;= t - self.nobs):</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f'Model has time-varying </span><span class="s2">{</span><span class="s1">which</span><span class="s2">}</span><span class="s5">'</span>
                                         <span class="s5">' matrix, so an updated time-varying'</span>
                                         <span class="s5">' matrix for the extension period is'</span>
                                         <span class="s5">' required.'</span><span class="s1">)</span>
                    <span class="s1">out = extend_kwargs[which][...</span><span class="s2">, </span><span class="s1">t - self.nobs]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">out = mat[...</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s4"># Helper to get Cov(\tilde \alpha_{t}, I)</span>
        <span class="s2">def </span><span class="s1">get_cov_state_revision(t):</span>
            <span class="s1">tmp1 = np.zeros((self.k_states</span><span class="s2">, </span><span class="s1">n_updates))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n_updates):</span>
                <span class="s1">t_i</span><span class="s2">, </span><span class="s1">k_i = updates_ix[i]</span>
                <span class="s1">acov = self.smoothed_state_autocovariance(</span>
                    <span class="s1">lag=t - t_i</span><span class="s2">, </span><span class="s1">t=t</span><span class="s2">, </span><span class="s1">extend_kwargs=extend_kwargs)</span>
                <span class="s1">Z_i = get_mat(</span><span class="s5">'design'</span><span class="s2">, </span><span class="s1">t_i)</span>
                <span class="s1">tmp1[:</span><span class="s2">, </span><span class="s1">i:i + </span><span class="s3">1</span><span class="s1">] = acov @ Z_i[k_i:k_i + </span><span class="s3">1</span><span class="s1">].T</span>
            <span class="s2">return </span><span class="s1">tmp1</span>

        <span class="s4"># Compute Cov(\tilde \alpha_{t}, I)</span>
        <span class="s1">tmp1 = np.zeros((n_periods</span><span class="s2">, </span><span class="s1">self.k_states</span><span class="s2">, </span><span class="s1">n_updates))</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">range(start</span><span class="s2">, </span><span class="s1">end):</span>
            <span class="s1">tmp1[s - start] = get_cov_state_revision(s)</span>

        <span class="s4"># Compute Var(I)</span>
        <span class="s1">tmp2 = np.zeros((n_updates</span><span class="s2">, </span><span class="s1">n_updates))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n_updates):</span>
            <span class="s1">t_i</span><span class="s2">, </span><span class="s1">k_i = updates_ix[i]</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(i + </span><span class="s3">1</span><span class="s1">):</span>
                <span class="s1">t_j</span><span class="s2">, </span><span class="s1">k_j = updates_ix[j]</span>

                <span class="s1">Z_i = get_mat(</span><span class="s5">'design'</span><span class="s2">, </span><span class="s1">t_i)</span>
                <span class="s1">Z_j = get_mat(</span><span class="s5">'design'</span><span class="s2">, </span><span class="s1">t_j)</span>

                <span class="s1">acov = self.smoothed_state_autocovariance(</span>
                    <span class="s1">lag=t_i - t_j</span><span class="s2">, </span><span class="s1">t=t_i</span><span class="s2">, </span><span class="s1">extend_kwargs=extend_kwargs)</span>
                <span class="s1">tmp2[i</span><span class="s2">, </span><span class="s1">j] = tmp2[j</span><span class="s2">, </span><span class="s1">i] = np.squeeze(</span>
                    <span class="s1">Z_i[k_i:k_i + </span><span class="s3">1</span><span class="s1">] @ acov @ Z_j[k_j:k_j + </span><span class="s3">1</span><span class="s1">].T</span>
                <span class="s1">)</span>

                <span class="s2">if </span><span class="s1">t_i == t_j:</span>
                    <span class="s1">H = get_mat(</span><span class="s5">'obs_cov'</span><span class="s2">, </span><span class="s1">t_i)</span>

                    <span class="s2">if </span><span class="s1">i == j:</span>
                        <span class="s1">tmp2[i</span><span class="s2">, </span><span class="s1">j] += H[k_i</span><span class="s2">, </span><span class="s1">k_j]</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">tmp2[i</span><span class="s2">, </span><span class="s1">j] += H[k_i</span><span class="s2">, </span><span class="s1">k_j]</span>
                        <span class="s1">tmp2[j</span><span class="s2">, </span><span class="s1">i] += H[k_i</span><span class="s2">, </span><span class="s1">k_j]</span>

        <span class="s4"># Gain</span>
        <span class="s1">gain = tmp1 @ np.linalg.inv(tmp2)</span>

        <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">gain = gain[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s2">return </span><span class="s1">gain</span>

    <span class="s2">def </span><span class="s1">_get_smoothed_forecasts(self):</span>
        <span class="s2">if </span><span class="s1">self._smoothed_forecasts </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># Initialize empty arrays</span>
            <span class="s1">self._smoothed_forecasts = np.zeros(self.forecasts.shape</span><span class="s2">,</span>
                                                <span class="s1">dtype=self.dtype)</span>
            <span class="s1">self._smoothed_forecasts_error = (</span>
                <span class="s1">np.zeros(self.forecasts_error.shape</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
            <span class="s1">)</span>
            <span class="s1">self._smoothed_forecasts_error_cov = (</span>
                <span class="s1">np.zeros(self.forecasts_error_cov.shape</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
            <span class="s1">)</span>

            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.nobs):</span>
                <span class="s1">design_t = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">self.design.shape[</span><span class="s3">2</span><span class="s1">] == </span><span class="s3">1 </span><span class="s2">else </span><span class="s1">t</span>
                <span class="s1">obs_cov_t = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">self.obs_cov.shape[</span><span class="s3">2</span><span class="s1">] == </span><span class="s3">1 </span><span class="s2">else </span><span class="s1">t</span>
                <span class="s1">obs_intercept_t = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">self.obs_intercept.shape[</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">1 </span><span class="s2">else </span><span class="s1">t</span>

                <span class="s1">mask = ~self.missing[:</span><span class="s2">, </span><span class="s1">t].astype(bool)</span>
                <span class="s4"># We can recover forecasts</span>
                <span class="s1">self._smoothed_forecasts[:</span><span class="s2">, </span><span class="s1">t] = np.dot(</span>
                    <span class="s1">self.design[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">design_t]</span><span class="s2">, </span><span class="s1">self.smoothed_state[:</span><span class="s2">, </span><span class="s1">t]</span>
                <span class="s1">) + self.obs_intercept[:</span><span class="s2">, </span><span class="s1">obs_intercept_t]</span>
                <span class="s2">if </span><span class="s1">self.nmissing[t] &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">self._smoothed_forecasts_error[:</span><span class="s2">, </span><span class="s1">t] = np.nan</span>
                <span class="s1">self._smoothed_forecasts_error[mask</span><span class="s2">, </span><span class="s1">t] = (</span>
                    <span class="s1">self.endog[mask</span><span class="s2">, </span><span class="s1">t] - self._smoothed_forecasts[mask</span><span class="s2">, </span><span class="s1">t]</span>
                <span class="s1">)</span>
                <span class="s1">self._smoothed_forecasts_error_cov[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">t] = np.dot(</span>
                    <span class="s1">np.dot(self.design[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">design_t]</span><span class="s2">,</span>
                           <span class="s1">self.smoothed_state_cov[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">t])</span><span class="s2">,</span>
                    <span class="s1">self.design[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">design_t].T</span>
                <span class="s1">) + self.obs_cov[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">obs_cov_t]</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self._smoothed_forecasts</span><span class="s2">,</span>
            <span class="s1">self._smoothed_forecasts_error</span><span class="s2">,</span>
            <span class="s1">self._smoothed_forecasts_error_cov</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">smoothed_forecasts(self):</span>
        <span class="s2">return </span><span class="s1">self._get_smoothed_forecasts()[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">smoothed_forecasts_error(self):</span>
        <span class="s2">return </span><span class="s1">self._get_smoothed_forecasts()[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">smoothed_forecasts_error_cov(self):</span>
        <span class="s2">return </span><span class="s1">self._get_smoothed_forecasts()[</span><span class="s3">2</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">get_smoothed_decomposition(self</span><span class="s2">, </span><span class="s1">decomposition_of=</span><span class="s5">'smoothed_state'</span><span class="s2">,</span>
                                   <span class="s1">state_index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Decompose smoothed output into contributions from observations 
 
        Parameters 
        ---------- 
        decomposition_of : {&quot;smoothed_state&quot;, &quot;smoothed_signal&quot;} 
            The object to perform a decomposition of. If it is set to 
            &quot;smoothed_state&quot;, then the elements of the smoothed state vector 
            are decomposed into the contributions of each observation. If it 
            is set to &quot;smoothed_signal&quot;, then the predictions of the 
            observation vector based on the smoothed state vector are 
            decomposed. Default is &quot;smoothed_state&quot;. 
        state_index : array_like, optional 
            An optional index specifying a subset of states to use when 
            constructing the decomposition of the &quot;smoothed_signal&quot;. For 
            example, if `state_index=[0, 1]` is passed, then only the 
            contributions of observed variables to the smoothed signal arising 
            from the first two states will be returned. Note that if not all 
            states are used, the contributions will not sum to the smoothed 
            signal. Default is to use all states. 
 
        Returns 
        ------- 
        data_contributions : array 
            Contributions of observations to the decomposed object. If the 
            smoothed state is being decomposed, then `data_contributions` are 
            shaped `(nobs, k_states, nobs, k_endog)`, where the 
            `(t, m, j, p)`-th element is the contribution of the `p`-th 
            observation at time `j` to the `m`-th state at time `t`. If the 
            smoothed signal is being decomposed, then `data_contributions` are 
            shaped `(nobs, k_endog, nobs, k_endog)`, where the 
            `(t, k, j, p)`-th element is the contribution of the `p`-th 
            observation at time `j` to the smoothed prediction of the `k`-th 
            observation at time `t`. 
        obs_intercept_contributions : array 
            Contributions of the observation intercept to the decomposed 
            object. If the smoothed state is being decomposed, then 
            `obs_intercept_contributions` are shaped 
            `(nobs, k_states, nobs, k_endog)`, where the `(t, m, j, p)`-th 
            element is the contribution of the `p`-th observation intercept at 
            time `j` to the `m`-th state at time `t`. If the smoothed signal 
            is being decomposed, then `obs_intercept_contributions` are shaped 
            `(nobs, k_endog, nobs, k_endog)`, where the `(t, k, j, p)`-th 
            element is the contribution of the `p`-th observation at time `j` 
            to the smoothed prediction of the `k`-th observation at time `t`. 
        state_intercept_contributions : array 
            Contributions of the state intercept to the decomposed object. If 
            the smoothed state is being decomposed, then 
            `state_intercept_contributions` are shaped 
            `(nobs, k_states, nobs, k_states)`, where the `(t, m, j, l)`-th 
            element is the contribution of the `l`-th state intercept at 
            time `j` to the `m`-th state at time `t`. If the smoothed signal 
            is being decomposed, then `state_intercept_contributions` are 
            shaped `(nobs, k_endog, nobs, k_endog)`, where the 
            `(t, k, j, l)`-th element is the contribution of the `p`-th 
            observation at time `j` to the smoothed prediction of the `k`-th 
            observation at time `t`. 
        prior_contributions : array 
            Contributions of the prior to the decomposed object. If the 
            smoothed state is being decomposed, then `prior_contributions` are 
            shaped `(nobs, k_states, k_states)`, where the `(t, m, l)`-th 
            element is the contribution of the `l`-th element of the prior 
            mean to the `m`-th state at time `t`. If the smoothed signal is 
            being decomposed, then `prior_contributions` are shaped 
            `(nobs, k_endog, k_states)`, where the `(t, k, l)`-th 
            element is the contribution of the `l`-th element of the prior mean 
            to the smoothed prediction of the `k`-th observation at time `t`. 
 
        Notes 
        ----- 
        Denote the smoothed state at time :math:`t` by :math:`\alpha_t`. Then 
        the smoothed signal is :math:`Z_t \alpha_t`, where :math:`Z_t` is the 
        design matrix operative at time :math:`t`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">decomposition_of </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">'smoothed_state'</span><span class="s2">, </span><span class="s5">'smoothed_signal'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid value for `decomposition_of`. Must be'</span>
                             <span class="s5">' one of &quot;smoothed_state&quot; or &quot;smoothed_signal&quot;.'</span><span class="s1">)</span>

        <span class="s1">weights</span><span class="s2">, </span><span class="s1">state_intercept_weights</span><span class="s2">, </span><span class="s1">prior_weights = (</span>
            <span class="s1">tools._compute_smoothed_state_weights(</span>
                <span class="s1">self.model</span><span class="s2">, </span><span class="s1">compute_prior_weights=</span><span class="s2">True, </span><span class="s1">scale=self.scale))</span>

        <span class="s4"># Get state space objects</span>
        <span class="s1">ZT = self.model.design.T           </span><span class="s4"># t, m, p</span>
        <span class="s1">dT = self.model.obs_intercept.T    </span><span class="s4"># t, p</span>
        <span class="s1">cT = self.model.state_intercept.T  </span><span class="s4"># t, m</span>

        <span class="s4"># Subset the states used for the impacts if applicable</span>
        <span class="s2">if </span><span class="s1">decomposition_of == </span><span class="s5">'smoothed_signal' </span><span class="s2">and </span><span class="s1">state_index </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">ZT = ZT[:</span><span class="s2">, </span><span class="s1">state_index</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">weights = weights[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">state_index]</span>
            <span class="s1">prior_weights = prior_weights[:</span><span class="s2">, </span><span class="s1">state_index</span><span class="s2">, </span><span class="s1">:]</span>

        <span class="s4"># Convert the weights in terms of smoothed signal</span>
        <span class="s4"># t, j, m, p, i</span>
        <span class="s2">if </span><span class="s1">decomposition_of == </span><span class="s5">'smoothed_signal'</span><span class="s1">:</span>
            <span class="s4"># Multiplication gives: t, j, m, p * t, j, m, p, k</span>
            <span class="s4"># Sum along axis=2 gives: t, j, p, k</span>
            <span class="s4"># Transpose to: t, j, k, p (i.e. like t, j, m, p but with k instead</span>
            <span class="s4"># of m)</span>
            <span class="s1">weights = np.nansum(weights[...</span><span class="s2">, None</span><span class="s1">] * ZT[:</span><span class="s2">, None, </span><span class="s1">:</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">,</span>
                                <span class="s1">axis=</span><span class="s3">2</span><span class="s1">).transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>

            <span class="s4"># Multiplication gives: t, j, m, l * t, j, m, l, k</span>
            <span class="s4"># Sum along axis=2 gives: t, j, l, k</span>
            <span class="s4"># Transpose to: t, j, k, l (i.e. like t, j, m, p but with k instead</span>
            <span class="s4"># of m and l instead of p)</span>
            <span class="s1">state_intercept_weights = np.nansum(</span>
                <span class="s1">state_intercept_weights[...</span><span class="s2">, None</span><span class="s1">] * ZT[:</span><span class="s2">, None, </span><span class="s1">:</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">,</span>
                <span class="s1">axis=</span><span class="s3">2</span><span class="s1">).transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>

            <span class="s4"># Multiplication gives: t, m, l * t, m, l, k = t, m, l, k</span>
            <span class="s4"># Sum along axis=1 gives: t, l, k</span>
            <span class="s4"># Transpose to: t, k, l (i.e. like t, m, l but with k instead of m)</span>
            <span class="s1">prior_weights = np.nansum(</span>
                <span class="s1">prior_weights[...</span><span class="s2">, None</span><span class="s1">] * ZT[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">,</span>
                <span class="s1">axis=</span><span class="s3">1</span><span class="s1">).transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s4"># Contributions of observations: multiply weights by observations</span>
        <span class="s4"># Multiplication gives t, j, {m,k}, p</span>
        <span class="s1">data_contributions = weights * self.model.endog.T[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, None, </span><span class="s1">:]</span>
        <span class="s4"># Transpose to: t, {m,k}, j, p</span>
        <span class="s1">data_contributions = data_contributions.transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>

        <span class="s4"># Contributions of obs intercept: multiply data weights by obs</span>
        <span class="s4"># intercept</span>
        <span class="s4"># Multiplication gives t, j, {m,k}, p</span>
        <span class="s1">obs_intercept_contributions = -weights * dT[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, None, </span><span class="s1">:]</span>
        <span class="s4"># Transpose to: t, {m,k}, j, p</span>
        <span class="s1">obs_intercept_contributions = (</span>
            <span class="s1">obs_intercept_contributions.transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span>

        <span class="s4"># Contributions of state intercept: multiply state intercept weights</span>
        <span class="s4"># by state intercept</span>
        <span class="s4"># Multiplication gives t, j, {m,k}, l</span>
        <span class="s1">state_intercept_contributions = (</span>
            <span class="s1">state_intercept_weights * cT[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, None, </span><span class="s1">:])</span>
        <span class="s4"># Transpose to: t, {m,k}, j, l</span>
        <span class="s1">state_intercept_contributions = (</span>
            <span class="s1">state_intercept_contributions.transpose(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span>

        <span class="s4"># Contributions of prior: multiply weights by prior</span>
        <span class="s4"># Multiplication gives t, {m, k}, l</span>
        <span class="s1">prior_contributions = prior_weights * self.initial_state[</span><span class="s2">None, None, </span><span class="s1">:]</span>

        <span class="s2">return </span><span class="s1">(data_contributions</span><span class="s2">, </span><span class="s1">obs_intercept_contributions</span><span class="s2">,</span>
                <span class="s1">state_intercept_contributions</span><span class="s2">, </span><span class="s1">prior_contributions)</span>
</pre>
</body>
</html>