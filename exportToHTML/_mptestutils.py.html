<html>
<head>
<title>_mptestutils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mptestutils.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">zip_longest</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">scipy.special._testutils </span><span class="s0">import </span><span class="s1">assert_func_equal</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">mpmath</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s0">pass</span>


<span class="s2"># ------------------------------------------------------------------------------</span>
<span class="s2"># Machinery for systematic tests with mpmath</span>
<span class="s2"># ------------------------------------------------------------------------------</span>

<span class="s0">class </span><span class="s1">Arg:</span>
    <span class="s3">&quot;&quot;&quot;Generate a set of numbers on the real axis, concentrating on 
    'interesting' regions and covering all orders of magnitude. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a=-np.inf</span><span class="s0">, </span><span class="s1">b=np.inf</span><span class="s0">, </span><span class="s1">inclusive_a=</span><span class="s0">True, </span><span class="s1">inclusive_b=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">a &gt; b:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;a should be less than or equal to b&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">a == -np.inf:</span>
            <span class="s1">a = -</span><span class="s5">0.5</span><span class="s1">*np.finfo(float).max</span>
        <span class="s0">if </span><span class="s1">b == np.inf:</span>
            <span class="s1">b = </span><span class="s5">0.5</span><span class="s1">*np.finfo(float).max</span>
        <span class="s1">self.a</span><span class="s0">, </span><span class="s1">self.b = a</span><span class="s0">, </span><span class="s1">b</span>

        <span class="s1">self.inclusive_a</span><span class="s0">, </span><span class="s1">self.inclusive_b = inclusive_a</span><span class="s0">, </span><span class="s1">inclusive_b</span>

    <span class="s0">def </span><span class="s1">_positive_values(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s0">if </span><span class="s1">a &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;a should be positive&quot;</span><span class="s1">)</span>

        <span class="s2"># Try to put half of the points into a linspace between a and</span>
        <span class="s2"># 10 the other half in a logspace.</span>
        <span class="s0">if </span><span class="s1">n % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">nlogpts = n//</span><span class="s5">2</span>
            <span class="s1">nlinpts = nlogpts</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">nlogpts = n//</span><span class="s5">2</span>
            <span class="s1">nlinpts = nlogpts + </span><span class="s5">1</span>

        <span class="s0">if </span><span class="s1">a &gt;= </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s2"># Outside of linspace range; just return a logspace.</span>
            <span class="s1">pts = np.logspace(np.log10(a)</span><span class="s0">, </span><span class="s1">np.log10(b)</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">elif </span><span class="s1">a &gt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">b &lt; </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s2"># Outside of logspace range; just return a linspace</span>
            <span class="s1">pts = np.linspace(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">elif </span><span class="s1">a &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># Linspace between a and 10 and a logspace between 10 and</span>
            <span class="s2"># b.</span>
            <span class="s1">linpts = np.linspace(a</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s1">nlinpts</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">logpts = np.logspace(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.log10(b)</span><span class="s0">, </span><span class="s1">nlogpts)</span>
            <span class="s1">pts = np.hstack((linpts</span><span class="s0">, </span><span class="s1">logpts))</span>
        <span class="s0">elif </span><span class="s1">a == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">b &lt;= </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s2"># Linspace between 0 and b and a logspace between 0 and</span>
            <span class="s2"># the smallest positive point of the linspace</span>
            <span class="s1">linpts = np.linspace(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">nlinpts)</span>
            <span class="s0">if </span><span class="s1">linpts.size &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">right = np.log10(linpts[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">right = -</span><span class="s5">30</span>
            <span class="s1">logpts = np.logspace(-</span><span class="s5">30</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">nlogpts</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">pts = np.hstack((logpts</span><span class="s0">, </span><span class="s1">linpts))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Linspace between 0 and 10, logspace between 0 and the</span>
            <span class="s2"># smallest positive point of the linspace, and a logspace</span>
            <span class="s2"># between 10 and b.</span>
            <span class="s0">if </span><span class="s1">nlogpts % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">nlogpts1 = nlogpts//</span><span class="s5">2</span>
                <span class="s1">nlogpts2 = nlogpts1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">nlogpts1 = nlogpts//</span><span class="s5">2</span>
                <span class="s1">nlogpts2 = nlogpts1 + </span><span class="s5">1</span>
            <span class="s1">linpts = np.linspace(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s1">nlinpts</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">linpts.size &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">right = np.log10(linpts[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">right = -</span><span class="s5">30</span>
            <span class="s1">logpts1 = np.logspace(-</span><span class="s5">30</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">nlogpts1</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">logpts2 = np.logspace(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.log10(b)</span><span class="s0">, </span><span class="s1">nlogpts2)</span>
            <span class="s1">pts = np.hstack((logpts1</span><span class="s0">, </span><span class="s1">linpts</span><span class="s0">, </span><span class="s1">logpts2))</span>

        <span class="s0">return </span><span class="s1">np.sort(pts)</span>

    <span class="s0">def </span><span class="s1">values(self</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s3">&quot;&quot;&quot;Return an array containing n numbers.&quot;&quot;&quot;</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b = self.a</span><span class="s0">, </span><span class="s1">self.b</span>
        <span class="s0">if </span><span class="s1">a == b:</span>
            <span class="s0">return </span><span class="s1">np.zeros(n)</span>

        <span class="s0">if not </span><span class="s1">self.inclusive_a:</span>
            <span class="s1">n += </span><span class="s5">1</span>
        <span class="s0">if not </span><span class="s1">self.inclusive_b:</span>
            <span class="s1">n += </span><span class="s5">1</span>

        <span class="s0">if </span><span class="s1">n % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">n1 = n//</span><span class="s5">2</span>
            <span class="s1">n2 = n1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">n1 = n//</span><span class="s5">2</span>
            <span class="s1">n2 = n1 + </span><span class="s5">1</span>

        <span class="s0">if </span><span class="s1">a &gt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">pospts = self._positive_values(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n)</span>
            <span class="s1">negpts = []</span>
        <span class="s0">elif </span><span class="s1">b &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">pospts = []</span>
            <span class="s1">negpts = -self._positive_values(-b</span><span class="s0">, </span><span class="s1">-a</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pospts = self._positive_values(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">n1)</span>
            <span class="s1">negpts = -self._positive_values(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-a</span><span class="s0">, </span><span class="s1">n2 + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2"># Don't want to get zero twice</span>
            <span class="s1">negpts = negpts[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">pts = np.hstack((negpts[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pospts))</span>

        <span class="s0">if not </span><span class="s1">self.inclusive_a:</span>
            <span class="s1">pts = pts[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s0">if not </span><span class="s1">self.inclusive_b:</span>
            <span class="s1">pts = pts[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">pts</span>


<span class="s0">class </span><span class="s1">FixedArg:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s1">self._values = np.asarray(values)</span>

    <span class="s0">def </span><span class="s1">values(self</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s0">return </span><span class="s1">self._values</span>


<span class="s0">class </span><span class="s1">ComplexArg:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a=complex(-np.inf</span><span class="s0">, </span><span class="s1">-np.inf)</span><span class="s0">, </span><span class="s1">b=complex(np.inf</span><span class="s0">, </span><span class="s1">np.inf)):</span>
        <span class="s1">self.real = Arg(a.real</span><span class="s0">, </span><span class="s1">b.real)</span>
        <span class="s1">self.imag = Arg(a.imag</span><span class="s0">, </span><span class="s1">b.imag)</span>

    <span class="s0">def </span><span class="s1">values(self</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s1">m = int(np.floor(np.sqrt(n)))</span>
        <span class="s1">x = self.real.values(m)</span>
        <span class="s1">y = self.imag.values(m + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">(x[:</span><span class="s0">,None</span><span class="s1">] + </span><span class="s5">1j</span><span class="s1">*y[</span><span class="s0">None,</span><span class="s1">:]).ravel()</span>


<span class="s0">class </span><span class="s1">IntArg:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a=-</span><span class="s5">1000</span><span class="s0">, </span><span class="s1">b=</span><span class="s5">1000</span><span class="s1">):</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.b = b</span>

    <span class="s0">def </span><span class="s1">values(self</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s1">v1 = Arg(self.a</span><span class="s0">, </span><span class="s1">self.b).values(max(</span><span class="s5">1 </span><span class="s1">+ n//</span><span class="s5">2</span><span class="s0">, </span><span class="s1">n-</span><span class="s5">5</span><span class="s1">)).astype(int)</span>
        <span class="s1">v2 = np.arange(-</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">v = np.unique(np.r_[v1</span><span class="s0">, </span><span class="s1">v2])</span>
        <span class="s1">v = v[(v &gt;= self.a) &amp; (v &lt; self.b)]</span>
        <span class="s0">return </span><span class="s1">v</span>


<span class="s0">def </span><span class="s1">get_args(argspec</span><span class="s0">, </span><span class="s1">n):</span>
    <span class="s0">if </span><span class="s1">isinstance(argspec</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">args = argspec.copy()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">nargs = len(argspec)</span>
        <span class="s1">ms = np.asarray([</span><span class="s5">1.5 </span><span class="s0">if </span><span class="s1">isinstance(spec</span><span class="s0">, </span><span class="s1">ComplexArg) </span><span class="s0">else </span><span class="s5">1.0 </span><span class="s0">for </span><span class="s1">spec </span><span class="s0">in </span><span class="s1">argspec])</span>
        <span class="s1">ms = (n**(ms/sum(ms))).astype(int) + </span><span class="s5">1</span>

        <span class="s1">args = [spec.values(m) </span><span class="s0">for </span><span class="s1">spec</span><span class="s0">, </span><span class="s1">m </span><span class="s0">in </span><span class="s1">zip(argspec</span><span class="s0">, </span><span class="s1">ms)]</span>
        <span class="s1">args = np.array(np.broadcast_arrays(*np.ix_(*args))).reshape(nargs</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">).T</span>

    <span class="s0">return </span><span class="s1">args</span>


<span class="s0">class </span><span class="s1">MpmathData:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">scipy_func</span><span class="s0">, </span><span class="s1">mpmath_func</span><span class="s0">, </span><span class="s1">arg_spec</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None,</span>
                 <span class="s1">dps=</span><span class="s0">None, </span><span class="s1">prec=</span><span class="s0">None, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">1e-300</span><span class="s0">,</span>
                 <span class="s1">ignore_inf_sign=</span><span class="s0">False, </span><span class="s1">distinguish_nan_and_inf=</span><span class="s0">True,</span>
                 <span class="s1">nan_ok=</span><span class="s0">True, </span><span class="s1">param_filter=</span><span class="s0">None</span><span class="s1">):</span>

        <span class="s2"># mpmath tests are really slow (see gh-6989).  Use a small number of</span>
        <span class="s2"># points by default, increase back to 5000 (old default) if XSLOW is</span>
        <span class="s2"># set</span>
        <span class="s0">if </span><span class="s1">n </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">is_xslow = int(os.environ.get(</span><span class="s4">'SCIPY_XSLOW'</span><span class="s0">, </span><span class="s4">'0'</span><span class="s1">))</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">is_xslow = </span><span class="s0">False</span>

            <span class="s1">n = </span><span class="s5">5000 </span><span class="s0">if </span><span class="s1">is_xslow </span><span class="s0">else </span><span class="s5">500</span>

        <span class="s1">self.scipy_func = scipy_func</span>
        <span class="s1">self.mpmath_func = mpmath_func</span>
        <span class="s1">self.arg_spec = arg_spec</span>
        <span class="s1">self.dps = dps</span>
        <span class="s1">self.prec = prec</span>
        <span class="s1">self.n = n</span>
        <span class="s1">self.rtol = rtol</span>
        <span class="s1">self.atol = atol</span>
        <span class="s1">self.ignore_inf_sign = ignore_inf_sign</span>
        <span class="s1">self.nan_ok = nan_ok</span>
        <span class="s0">if </span><span class="s1">isinstance(self.arg_spec</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">self.is_complex = np.issubdtype(self.arg_spec.dtype</span><span class="s0">, </span><span class="s1">np.complexfloating)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.is_complex = any([isinstance(arg</span><span class="s0">, </span><span class="s1">ComplexArg) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">self.arg_spec])</span>
        <span class="s1">self.ignore_inf_sign = ignore_inf_sign</span>
        <span class="s1">self.distinguish_nan_and_inf = distinguish_nan_and_inf</span>
        <span class="s0">if not </span><span class="s1">name </span><span class="s0">or </span><span class="s1">name == </span><span class="s4">'&lt;lambda&gt;'</span><span class="s1">:</span>
            <span class="s1">name = getattr(scipy_func</span><span class="s0">, </span><span class="s4">'__name__'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">name </span><span class="s0">or </span><span class="s1">name == </span><span class="s4">'&lt;lambda&gt;'</span><span class="s1">:</span>
            <span class="s1">name = getattr(mpmath_func</span><span class="s0">, </span><span class="s4">'__name__'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.param_filter = param_filter</span>

    <span class="s0">def </span><span class="s1">check(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>

        <span class="s2"># Generate values for the arguments</span>
        <span class="s1">argarr = get_args(self.arg_spec</span><span class="s0">, </span><span class="s1">self.n)</span>

        <span class="s2"># Check</span>
        <span class="s1">old_dps</span><span class="s0">, </span><span class="s1">old_prec = mpmath.mp.dps</span><span class="s0">, </span><span class="s1">mpmath.mp.prec</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.dps </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">dps_list = [self.dps]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">dps_list = [</span><span class="s5">20</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">self.prec </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">mpmath.mp.prec = self.prec</span>

            <span class="s2"># Proper casting of mpmath input and output types. Using</span>
            <span class="s2"># native mpmath types as inputs gives improved precision</span>
            <span class="s2"># in some cases.</span>
            <span class="s0">if </span><span class="s1">np.issubdtype(argarr.dtype</span><span class="s0">, </span><span class="s1">np.complexfloating):</span>
                <span class="s1">pytype = mpc2complex</span>

                <span class="s0">def </span><span class="s1">mptype(x):</span>
                    <span class="s0">return </span><span class="s1">mpmath.mpc(complex(x))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">def </span><span class="s1">mptype(x):</span>
                    <span class="s0">return </span><span class="s1">mpmath.mpf(float(x))</span>

                <span class="s0">def </span><span class="s1">pytype(x):</span>
                    <span class="s0">if </span><span class="s1">abs(x.imag) &gt; </span><span class="s5">1e-16</span><span class="s1">*(</span><span class="s5">1 </span><span class="s1">+ abs(x.real)):</span>
                        <span class="s0">return </span><span class="s1">np.nan</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">mpf2float(x.real)</span>

            <span class="s2"># Try out different dps until one (or none) works</span>
            <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">dps </span><span class="s0">in </span><span class="s1">enumerate(dps_list):</span>
                <span class="s1">mpmath.mp.dps = dps</span>

                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">assert_func_equal(self.scipy_func</span><span class="s0">,</span>
                                      <span class="s0">lambda </span><span class="s1">*a: pytype(self.mpmath_func(*map(mptype</span><span class="s0">, </span><span class="s1">a)))</span><span class="s0">,</span>
                                      <span class="s1">argarr</span><span class="s0">,</span>
                                      <span class="s1">vectorized=</span><span class="s0">False,</span>
                                      <span class="s1">rtol=self.rtol</span><span class="s0">, </span><span class="s1">atol=self.atol</span><span class="s0">,</span>
                                      <span class="s1">ignore_inf_sign=self.ignore_inf_sign</span><span class="s0">,</span>
                                      <span class="s1">distinguish_nan_and_inf=self.distinguish_nan_and_inf</span><span class="s0">,</span>
                                      <span class="s1">nan_ok=self.nan_ok</span><span class="s0">,</span>
                                      <span class="s1">param_filter=self.param_filter)</span>
                    <span class="s0">break</span>
                <span class="s0">except </span><span class="s1">AssertionError:</span>
                    <span class="s0">if </span><span class="s1">j &gt;= len(dps_list)-</span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s2"># reraise the Exception</span>
                        <span class="s1">tp</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">tb = sys.exc_info()</span>
                        <span class="s0">if </span><span class="s1">value.__traceback__ </span><span class="s0">is not </span><span class="s1">tb:</span>
                            <span class="s0">raise </span><span class="s1">value.with_traceback(tb)</span>
                        <span class="s0">raise </span><span class="s1">value</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">mpmath.mp.dps</span><span class="s0">, </span><span class="s1">mpmath.mp.prec = old_dps</span><span class="s0">, </span><span class="s1">old_prec</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">if </span><span class="s1">self.is_complex:</span>
            <span class="s0">return </span><span class="s4">f&quot;&lt;MpmathData: </span><span class="s0">{</span><span class="s1">self.name</span><span class="s0">} </span><span class="s4">(complex)&gt;&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s4">f&quot;&lt;MpmathData: </span><span class="s0">{</span><span class="s1">self.name</span><span class="s0">}</span><span class="s4">&gt;&quot;</span>


<span class="s0">def </span><span class="s1">assert_mpmath_equal(*a</span><span class="s0">, </span><span class="s1">**kw):</span>
    <span class="s1">d = MpmathData(*a</span><span class="s0">, </span><span class="s1">**kw)</span>
    <span class="s1">d.check()</span>


<span class="s0">def </span><span class="s1">nonfunctional_tooslow(func):</span>
    <span class="s0">return </span><span class="s1">pytest.mark.skip(reason=</span><span class="s4">&quot;    Test not yet functional (too slow), needs more work.&quot;</span><span class="s1">)(func)</span>


<span class="s2"># ------------------------------------------------------------------------------</span>
<span class="s2"># Tools for dealing with mpmath quirks</span>
<span class="s2"># ------------------------------------------------------------------------------</span>

<span class="s0">def </span><span class="s1">mpf2float(x):</span>
    <span class="s3">&quot;&quot;&quot; 
    Convert an mpf to the nearest floating point number. Just using 
    float directly doesn't work because of results like this: 
 
    with mp.workdps(50): 
        float(mpf(&quot;0.99999999999999999&quot;)) = 0.9999999999999999 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">float(mpmath.nstr(x</span><span class="s0">, </span><span class="s5">17</span><span class="s0">, </span><span class="s1">min_fixed=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_fixed=</span><span class="s5">0</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">mpc2complex(x):</span>
    <span class="s0">return </span><span class="s1">complex(mpf2float(x.real)</span><span class="s0">, </span><span class="s1">mpf2float(x.imag))</span>


<span class="s0">def </span><span class="s1">trace_args(func):</span>
    <span class="s0">def </span><span class="s1">tofloat(x):</span>
        <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">mpmath.mpc):</span>
            <span class="s0">return </span><span class="s1">complex(x)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">float(x)</span>

    <span class="s0">def </span><span class="s1">wrap(*a</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s1">sys.stderr.write(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">tuple(map(tofloat</span><span class="s0">, </span><span class="s1">a))</span><span class="s0">!r}</span><span class="s4">: &quot;</span><span class="s1">)</span>
        <span class="s1">sys.stderr.flush()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">r = func(*a</span><span class="s0">, </span><span class="s1">**kw)</span>
            <span class="s1">sys.stderr.write(</span><span class="s4">&quot;-&gt; %r&quot; </span><span class="s1">% r)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">sys.stderr.write(</span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">sys.stderr.flush()</span>
        <span class="s0">return </span><span class="s1">r</span>
    <span class="s0">return </span><span class="s1">wrap</span>


<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">signal</span>
    <span class="s1">POSIX = (</span><span class="s4">'setitimer' </span><span class="s0">in </span><span class="s1">dir(signal))</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s1">POSIX = </span><span class="s0">False</span>


<span class="s0">class </span><span class="s1">TimeoutError(Exception):</span>
    <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">time_limited(timeout=</span><span class="s5">0.5</span><span class="s0">, </span><span class="s1">return_val=np.nan</span><span class="s0">, </span><span class="s1">use_sigalrm=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Decorator for setting a timeout for pure-Python functions. 
 
    If the function does not return within `timeout` seconds, the 
    value `return_val` is returned instead. 
 
    On POSIX this uses SIGALRM by default. On non-POSIX, settrace is 
    used. Do not use this with threads: the SIGALRM implementation 
    does probably not work well. The settrace implementation only 
    traces the current thread. 
 
    The settrace implementation slows down execution speed. Slowdown 
    by a factor around 10 is probably typical. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">POSIX </span><span class="s0">and </span><span class="s1">use_sigalrm:</span>
        <span class="s0">def </span><span class="s1">sigalrm_handler(signum</span><span class="s0">, </span><span class="s1">frame):</span>
            <span class="s0">raise </span><span class="s1">TimeoutError()</span>

        <span class="s0">def </span><span class="s1">deco(func):</span>
            <span class="s0">def </span><span class="s1">wrap(*a</span><span class="s0">, </span><span class="s1">**kw):</span>
                <span class="s1">old_handler = signal.signal(signal.SIGALRM</span><span class="s0">, </span><span class="s1">sigalrm_handler)</span>
                <span class="s1">signal.setitimer(signal.ITIMER_REAL</span><span class="s0">, </span><span class="s1">timeout)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">func(*a</span><span class="s0">, </span><span class="s1">**kw)</span>
                <span class="s0">except </span><span class="s1">TimeoutError:</span>
                    <span class="s0">return </span><span class="s1">return_val</span>
                <span class="s0">finally</span><span class="s1">:</span>
                    <span class="s1">signal.setitimer(signal.ITIMER_REAL</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s1">signal.signal(signal.SIGALRM</span><span class="s0">, </span><span class="s1">old_handler)</span>
            <span class="s0">return </span><span class="s1">wrap</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">def </span><span class="s1">deco(func):</span>
            <span class="s0">def </span><span class="s1">wrap(*a</span><span class="s0">, </span><span class="s1">**kw):</span>
                <span class="s1">start_time = time.time()</span>

                <span class="s0">def </span><span class="s1">trace(frame</span><span class="s0">, </span><span class="s1">event</span><span class="s0">, </span><span class="s1">arg):</span>
                    <span class="s0">if </span><span class="s1">time.time() - start_time &gt; timeout:</span>
                        <span class="s0">raise </span><span class="s1">TimeoutError()</span>
                    <span class="s0">return </span><span class="s1">trace</span>
                <span class="s1">sys.settrace(trace)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">func(*a</span><span class="s0">, </span><span class="s1">**kw)</span>
                <span class="s0">except </span><span class="s1">TimeoutError:</span>
                    <span class="s1">sys.settrace(</span><span class="s0">None</span><span class="s1">)</span>
                    <span class="s0">return </span><span class="s1">return_val</span>
                <span class="s0">finally</span><span class="s1">:</span>
                    <span class="s1">sys.settrace(</span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">wrap</span>
    <span class="s0">return </span><span class="s1">deco</span>


<span class="s0">def </span><span class="s1">exception_to_nan(func):</span>
    <span class="s3">&quot;&quot;&quot;Decorate function to return nan if it raises an exception&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">wrap(*a</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">func(*a</span><span class="s0">, </span><span class="s1">**kw)</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">return </span><span class="s1">np.nan</span>
    <span class="s0">return </span><span class="s1">wrap</span>


<span class="s0">def </span><span class="s1">inf_to_nan(func):</span>
    <span class="s3">&quot;&quot;&quot;Decorate function to return nan if it returns inf&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">wrap(*a</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s1">v = func(*a</span><span class="s0">, </span><span class="s1">**kw)</span>
        <span class="s0">if not </span><span class="s1">np.isfinite(v):</span>
            <span class="s0">return </span><span class="s1">np.nan</span>
        <span class="s0">return </span><span class="s1">v</span>
    <span class="s0">return </span><span class="s1">wrap</span>


<span class="s0">def </span><span class="s1">mp_assert_allclose(res</span><span class="s0">, </span><span class="s1">std</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-17</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Compare lists of mpmath.mpf's or mpmath.mpc's directly so that it 
    can be done to higher precision than double. 
    &quot;&quot;&quot;</span>
    <span class="s1">failures = []</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">(resval</span><span class="s0">, </span><span class="s1">stdval) </span><span class="s0">in </span><span class="s1">enumerate(zip_longest(res</span><span class="s0">, </span><span class="s1">std)):</span>
        <span class="s0">if </span><span class="s1">resval </span><span class="s0">is None or </span><span class="s1">stdval </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'Lengths of inputs res and std are not equal.'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">mpmath.fabs(resval - stdval) &gt; atol + rtol*mpmath.fabs(stdval):</span>
            <span class="s1">failures.append((k</span><span class="s0">, </span><span class="s1">resval</span><span class="s0">, </span><span class="s1">stdval))</span>

    <span class="s1">nfail = len(failures)</span>
    <span class="s0">if </span><span class="s1">nfail &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">ndigits = int(abs(np.log10(rtol)))</span>
        <span class="s1">msg = [</span><span class="s4">&quot;&quot;</span><span class="s1">]</span>
        <span class="s1">msg.append(</span><span class="s4">&quot;Bad results ({} out of {}) for the following points:&quot;</span>
                   <span class="s1">.format(nfail</span><span class="s0">, </span><span class="s1">k + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">resval</span><span class="s0">, </span><span class="s1">stdval </span><span class="s0">in </span><span class="s1">failures:</span>
            <span class="s1">resrep = mpmath.nstr(resval</span><span class="s0">, </span><span class="s1">ndigits</span><span class="s0">, </span><span class="s1">min_fixed=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_fixed=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">stdrep = mpmath.nstr(stdval</span><span class="s0">, </span><span class="s1">ndigits</span><span class="s0">, </span><span class="s1">min_fixed=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_fixed=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">stdval == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">rdiff = </span><span class="s4">&quot;inf&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">rdiff = mpmath.fabs((resval - stdval)/stdval)</span>
                <span class="s1">rdiff = mpmath.nstr(rdiff</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
            <span class="s1">msg.append(</span><span class="s4">&quot;{}: {} != {} (rdiff {})&quot;</span><span class="s1">.format(k</span><span class="s0">, </span><span class="s1">resrep</span><span class="s0">, </span><span class="s1">stdrep</span><span class="s0">,</span>
                                                        <span class="s1">rdiff))</span>
        <span class="s1">assert_(</span><span class="s0">False, </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">.join(msg))</span>
</pre>
</body>
</html>