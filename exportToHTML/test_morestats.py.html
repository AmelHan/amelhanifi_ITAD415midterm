<html>
<head>
<title>test_morestats.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_morestats.py</font>
</center></td></tr></table>
<pre><span class="s0"># Author:  Travis Oliphant, 2002</span>
<span class="s0">#</span>
<span class="s0"># Further enhancements and tests added by numerous SciPy developers.</span>
<span class="s0">#</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">sys</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.random </span><span class="s2">import </span><span class="s1">RandomState</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_array_equal</span><span class="s2">, </span><span class="s1">assert_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_array_less</span><span class="s2">, </span><span class="s1">assert_array_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_equal</span><span class="s2">,</span>
                           <span class="s1">suppress_warnings)</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">optimize</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>
<span class="s2">from </span><span class="s1">scipy.stats._morestats </span><span class="s2">import </span><span class="s1">_abw_state</span><span class="s2">, </span><span class="s1">_get_As_weibull</span><span class="s2">, </span><span class="s1">_Avals_weibull</span>
<span class="s2">from </span><span class="s1">.common_tests </span><span class="s2">import </span><span class="s1">check_named_results</span>
<span class="s2">from </span><span class="s1">.._hypotests </span><span class="s2">import </span><span class="s1">_get_wilcoxon_distr</span><span class="s2">, </span><span class="s1">_get_wilcoxon_distr2</span>
<span class="s2">from </span><span class="s1">scipy.stats._binomtest </span><span class="s2">import </span><span class="s1">_binary_search_for_binom_tst</span>
<span class="s2">from </span><span class="s1">scipy.stats._distr_params </span><span class="s2">import </span><span class="s1">distcont</span>

<span class="s1">distcont = dict(distcont)  </span><span class="s0"># type: ignore</span>

<span class="s0"># Matplotlib is not a scipy dependency but is optionally used in probplot, so</span>
<span class="s0"># check if it's available</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">matplotlib</span>
    <span class="s1">matplotlib.rcParams[</span><span class="s3">'backend'</span><span class="s1">] = </span><span class="s3">'Agg'</span>
    <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
    <span class="s1">have_matplotlib = </span><span class="s2">True</span>
<span class="s2">except </span><span class="s1">Exception:</span>
    <span class="s1">have_matplotlib = </span><span class="s2">False</span>


<span class="s0"># test data gear.dat from NIST for Levene and Bartlett test</span>
<span class="s0"># https://www.itl.nist.gov/div898/handbook/eda/section3/eda3581.htm</span>
<span class="s1">g1 = [</span><span class="s4">1.006</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">1.000</span><span class="s2">, </span><span class="s4">0.992</span><span class="s2">, </span><span class="s4">0.993</span><span class="s2">, </span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">0.999</span><span class="s2">, </span><span class="s4">0.994</span><span class="s2">, </span><span class="s4">1.000</span><span class="s1">]</span>
<span class="s1">g2 = [</span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">1.006</span><span class="s2">, </span><span class="s4">1.000</span><span class="s2">, </span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">0.997</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">1.000</span><span class="s2">, </span><span class="s4">1.006</span><span class="s2">, </span><span class="s4">0.988</span><span class="s1">]</span>
<span class="s1">g3 = [</span><span class="s4">0.991</span><span class="s2">, </span><span class="s4">0.987</span><span class="s2">, </span><span class="s4">0.997</span><span class="s2">, </span><span class="s4">0.999</span><span class="s2">, </span><span class="s4">0.995</span><span class="s2">, </span><span class="s4">0.994</span><span class="s2">, </span><span class="s4">1.000</span><span class="s2">, </span><span class="s4">0.999</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">0.996</span><span class="s1">]</span>
<span class="s1">g4 = [</span><span class="s4">1.005</span><span class="s2">, </span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">0.994</span><span class="s2">, </span><span class="s4">1.000</span><span class="s2">, </span><span class="s4">0.995</span><span class="s2">, </span><span class="s4">0.994</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">0.996</span><span class="s1">]</span>
<span class="s1">g5 = [</span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">0.982</span><span class="s2">, </span><span class="s4">0.990</span><span class="s2">, </span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">0.984</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">0.993</span><span class="s2">, </span><span class="s4">0.980</span><span class="s2">, </span><span class="s4">0.996</span><span class="s1">]</span>
<span class="s1">g6 = [</span><span class="s4">1.009</span><span class="s2">, </span><span class="s4">1.013</span><span class="s2">, </span><span class="s4">1.009</span><span class="s2">, </span><span class="s4">0.997</span><span class="s2">, </span><span class="s4">0.988</span><span class="s2">, </span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">0.995</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">0.981</span><span class="s2">, </span><span class="s4">0.996</span><span class="s1">]</span>
<span class="s1">g7 = [</span><span class="s4">0.990</span><span class="s2">, </span><span class="s4">1.004</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">1.001</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">1.000</span><span class="s2">, </span><span class="s4">1.018</span><span class="s2">, </span><span class="s4">1.010</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">1.002</span><span class="s1">]</span>
<span class="s1">g8 = [</span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">1.000</span><span class="s2">, </span><span class="s4">1.006</span><span class="s2">, </span><span class="s4">1.000</span><span class="s2">, </span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">1.006</span><span class="s1">]</span>
<span class="s1">g9 = [</span><span class="s4">1.002</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">0.995</span><span class="s2">, </span><span class="s4">0.996</span><span class="s2">, </span><span class="s4">1.004</span><span class="s2">, </span><span class="s4">1.004</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">0.999</span><span class="s2">, </span><span class="s4">0.991</span><span class="s1">]</span>
<span class="s1">g10 = [</span><span class="s4">0.991</span><span class="s2">, </span><span class="s4">0.995</span><span class="s2">, </span><span class="s4">0.984</span><span class="s2">, </span><span class="s4">0.994</span><span class="s2">, </span><span class="s4">0.997</span><span class="s2">, </span><span class="s4">0.997</span><span class="s2">, </span><span class="s4">0.991</span><span class="s2">, </span><span class="s4">0.998</span><span class="s2">, </span><span class="s4">1.004</span><span class="s2">, </span><span class="s4">0.997</span><span class="s1">]</span>


<span class="s0"># The loggamma RVS stream is changing due to gh-13349; this version</span>
<span class="s0"># preserves the old stream so that tests don't change.</span>
<span class="s2">def </span><span class="s1">_old_loggamma_rvs(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">return </span><span class="s1">np.log(stats.gamma.rvs(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>


<span class="s2">class </span><span class="s1">TestBayes_mvs:</span>
    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s0"># Expected values in this test simply taken from the function.  For</span>
        <span class="s0"># some checks regarding correctness of implementation, see review in</span>
        <span class="s0"># gh-674</span>
        <span class="s1">data = [</span><span class="s4">6</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">13</span><span class="s1">]</span>
        <span class="s1">mean</span><span class="s2">, </span><span class="s1">var</span><span class="s2">, </span><span class="s1">std = stats.bayes_mvs(data)</span>
        <span class="s1">assert_almost_equal(mean.statistic</span><span class="s2">, </span><span class="s4">9.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(mean.minmax</span><span class="s2">, </span><span class="s1">(</span><span class="s4">7.1036502226125329</span><span class="s2">, </span><span class="s4">10.896349777387467</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(var.statistic</span><span class="s2">, </span><span class="s4">10.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(var.minmax</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3.1767242068607087</span><span class="s2">, </span><span class="s4">24.45910381334018</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-09</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(std.statistic</span><span class="s2">, </span><span class="s4">2.9724954732045084</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(std.minmax</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.7823367265645145</span><span class="s2">, </span><span class="s4">4.9456146050146312</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty_input(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.bayes_mvs</span><span class="s2">, </span><span class="s1">[])</span>

    <span class="s2">def </span><span class="s1">test_result_attributes(self):</span>
        <span class="s1">x = np.arange(</span><span class="s4">15</span><span class="s1">)</span>
        <span class="s1">attributes = (</span><span class="s3">'statistic'</span><span class="s2">, </span><span class="s3">'minmax'</span><span class="s1">)</span>
        <span class="s1">res = stats.bayes_mvs(x)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">res:</span>
            <span class="s1">check_named_results(i</span><span class="s2">, </span><span class="s1">attributes)</span>


<span class="s2">class </span><span class="s1">TestMvsdist:</span>
    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">data = [</span><span class="s4">6</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">13</span><span class="s1">]</span>
        <span class="s1">mean</span><span class="s2">, </span><span class="s1">var</span><span class="s2">, </span><span class="s1">std = stats.mvsdist(data)</span>
        <span class="s1">assert_almost_equal(mean.mean()</span><span class="s2">, </span><span class="s4">9.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(mean.interval(</span><span class="s4">0.9</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">7.1036502226125329</span><span class="s2">,</span>
                                             <span class="s4">10.896349777387467</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(var.mean()</span><span class="s2">, </span><span class="s4">10.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(var.interval(</span><span class="s4">0.9</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3.1767242068607087</span><span class="s2">,</span>
                                            <span class="s4">24.45910381334018</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-09</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(std.mean()</span><span class="s2">, </span><span class="s4">2.9724954732045084</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(std.interval(</span><span class="s4">0.9</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.7823367265645145</span><span class="s2">,</span>
                                            <span class="s4">4.9456146050146312</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty_input(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.mvsdist</span><span class="s2">, </span><span class="s1">[])</span>

    <span class="s2">def </span><span class="s1">test_bad_arg(self):</span>
        <span class="s0"># Raise ValueError if fewer than two data points are given.</span>
        <span class="s1">data = [</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.mvsdist</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s2">def </span><span class="s1">test_warns(self):</span>
        <span class="s0"># regression test for gh-5270</span>
        <span class="s0"># make sure there are no spurious divide-by-zero warnings</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">'error'</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">[x.mean() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">stats.mvsdist([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])]</span>
            <span class="s1">[x.mean() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">stats.mvsdist([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])]</span>


<span class="s2">class </span><span class="s1">TestShapiro:</span>
    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">x1 = [</span><span class="s4">0.11</span><span class="s2">, </span><span class="s4">7.87</span><span class="s2">, </span><span class="s4">4.61</span><span class="s2">, </span><span class="s4">10.14</span><span class="s2">, </span><span class="s4">7.95</span><span class="s2">, </span><span class="s4">3.14</span><span class="s2">, </span><span class="s4">0.46</span><span class="s2">,</span>
              <span class="s4">4.43</span><span class="s2">, </span><span class="s4">0.21</span><span class="s2">, </span><span class="s4">4.75</span><span class="s2">, </span><span class="s4">0.71</span><span class="s2">, </span><span class="s4">1.52</span><span class="s2">, </span><span class="s4">3.24</span><span class="s2">,</span>
              <span class="s4">0.93</span><span class="s2">, </span><span class="s4">0.42</span><span class="s2">, </span><span class="s4">4.97</span><span class="s2">, </span><span class="s4">9.53</span><span class="s2">, </span><span class="s4">4.55</span><span class="s2">, </span><span class="s4">0.47</span><span class="s2">, </span><span class="s4">6.66</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">pw = stats.shapiro(x1)</span>
        <span class="s1">shapiro_test = stats.shapiro(x1)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s2">, </span><span class="s4">0.90047299861907959</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.statistic</span><span class="s2">, </span><span class="s4">0.90047299861907959</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pw</span><span class="s2">, </span><span class="s4">0.042089745402336121</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.pvalue</span><span class="s2">, </span><span class="s4">0.042089745402336121</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s1">x2 = [</span><span class="s4">1.36</span><span class="s2">, </span><span class="s4">1.14</span><span class="s2">, </span><span class="s4">2.92</span><span class="s2">, </span><span class="s4">2.55</span><span class="s2">, </span><span class="s4">1.46</span><span class="s2">, </span><span class="s4">1.06</span><span class="s2">, </span><span class="s4">5.27</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.11</span><span class="s2">,</span>
              <span class="s4">3.48</span><span class="s2">, </span><span class="s4">1.10</span><span class="s2">, </span><span class="s4">0.88</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.51</span><span class="s2">, </span><span class="s4">1.46</span><span class="s2">, </span><span class="s4">0.52</span><span class="s2">, </span><span class="s4">6.20</span><span class="s2">, </span><span class="s4">1.69</span><span class="s2">,</span>
              <span class="s4">0.08</span><span class="s2">, </span><span class="s4">3.67</span><span class="s2">, </span><span class="s4">2.81</span><span class="s2">, </span><span class="s4">3.49</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">pw = stats.shapiro(x2)</span>
        <span class="s1">shapiro_test = stats.shapiro(x2)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s2">, </span><span class="s4">0.9590270</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.statistic</span><span class="s2">, </span><span class="s4">0.9590270</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pw</span><span class="s2">, </span><span class="s4">0.52460</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.pvalue</span><span class="s2">, </span><span class="s4">0.52460</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s0"># Verified against R</span>
        <span class="s1">x3 = stats.norm.rvs(loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">12345678</span><span class="s1">)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">pw = stats.shapiro(x3)</span>
        <span class="s1">shapiro_test = stats.shapiro(x3)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s2">, </span><span class="s4">0.9772805571556091</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.statistic</span><span class="s2">, </span><span class="s4">0.9772805571556091</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pw</span><span class="s2">, </span><span class="s4">0.08144091814756393</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.pvalue</span><span class="s2">, </span><span class="s4">0.08144091814756393</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s0"># Extracted from original paper</span>
        <span class="s1">x4 = [</span><span class="s4">0.139</span><span class="s2">, </span><span class="s4">0.157</span><span class="s2">, </span><span class="s4">0.175</span><span class="s2">, </span><span class="s4">0.256</span><span class="s2">, </span><span class="s4">0.344</span><span class="s2">, </span><span class="s4">0.413</span><span class="s2">, </span><span class="s4">0.503</span><span class="s2">, </span><span class="s4">0.577</span><span class="s2">, </span><span class="s4">0.614</span><span class="s2">,</span>
              <span class="s4">0.655</span><span class="s2">, </span><span class="s4">0.954</span><span class="s2">, </span><span class="s4">1.392</span><span class="s2">, </span><span class="s4">1.557</span><span class="s2">, </span><span class="s4">1.648</span><span class="s2">, </span><span class="s4">1.690</span><span class="s2">, </span><span class="s4">1.994</span><span class="s2">, </span><span class="s4">2.174</span><span class="s2">, </span><span class="s4">2.206</span><span class="s2">,</span>
              <span class="s4">3.245</span><span class="s2">, </span><span class="s4">3.510</span><span class="s2">, </span><span class="s4">3.571</span><span class="s2">, </span><span class="s4">4.354</span><span class="s2">, </span><span class="s4">4.980</span><span class="s2">, </span><span class="s4">6.084</span><span class="s2">, </span><span class="s4">8.351</span><span class="s1">]</span>
        <span class="s1">W_expected = </span><span class="s4">0.83467</span>
        <span class="s1">p_expected = </span><span class="s4">0.000914</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">pw = stats.shapiro(x4)</span>
        <span class="s1">shapiro_test = stats.shapiro(x4)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s2">, </span><span class="s1">W_expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.statistic</span><span class="s2">, </span><span class="s1">W_expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pw</span><span class="s2">, </span><span class="s1">p_expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.pvalue</span><span class="s2">, </span><span class="s1">p_expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_2d(self):</span>
        <span class="s1">x1 = [[</span><span class="s4">0.11</span><span class="s2">, </span><span class="s4">7.87</span><span class="s2">, </span><span class="s4">4.61</span><span class="s2">, </span><span class="s4">10.14</span><span class="s2">, </span><span class="s4">7.95</span><span class="s2">, </span><span class="s4">3.14</span><span class="s2">, </span><span class="s4">0.46</span><span class="s2">,</span>
              <span class="s4">4.43</span><span class="s2">, </span><span class="s4">0.21</span><span class="s2">, </span><span class="s4">4.75</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.71</span><span class="s2">, </span><span class="s4">1.52</span><span class="s2">, </span><span class="s4">3.24</span><span class="s2">,</span>
              <span class="s4">0.93</span><span class="s2">, </span><span class="s4">0.42</span><span class="s2">, </span><span class="s4">4.97</span><span class="s2">, </span><span class="s4">9.53</span><span class="s2">, </span><span class="s4">4.55</span><span class="s2">, </span><span class="s4">0.47</span><span class="s2">, </span><span class="s4">6.66</span><span class="s1">]]</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">pw = stats.shapiro(x1)</span>
        <span class="s1">shapiro_test = stats.shapiro(x1)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s2">, </span><span class="s4">0.90047299861907959</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.statistic</span><span class="s2">, </span><span class="s4">0.90047299861907959</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pw</span><span class="s2">, </span><span class="s4">0.042089745402336121</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.pvalue</span><span class="s2">, </span><span class="s4">0.042089745402336121</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s1">x2 = [[</span><span class="s4">1.36</span><span class="s2">, </span><span class="s4">1.14</span><span class="s2">, </span><span class="s4">2.92</span><span class="s2">, </span><span class="s4">2.55</span><span class="s2">, </span><span class="s4">1.46</span><span class="s2">, </span><span class="s4">1.06</span><span class="s2">, </span><span class="s4">5.27</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.11</span><span class="s2">,</span>
              <span class="s4">3.48</span><span class="s2">, </span><span class="s4">1.10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.88</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.51</span><span class="s2">, </span><span class="s4">1.46</span><span class="s2">, </span><span class="s4">0.52</span><span class="s2">, </span><span class="s4">6.20</span><span class="s2">, </span><span class="s4">1.69</span><span class="s2">,</span>
              <span class="s4">0.08</span><span class="s2">, </span><span class="s4">3.67</span><span class="s2">, </span><span class="s4">2.81</span><span class="s2">, </span><span class="s4">3.49</span><span class="s1">]]</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">pw = stats.shapiro(x2)</span>
        <span class="s1">shapiro_test = stats.shapiro(x2)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s2">, </span><span class="s4">0.9590270</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.statistic</span><span class="s2">, </span><span class="s4">0.9590270</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pw</span><span class="s2">, </span><span class="s4">0.52460</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.pvalue</span><span class="s2">, </span><span class="s4">0.52460</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty_input(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.shapiro</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.shapiro</span><span class="s2">, </span><span class="s1">[[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]])</span>

    <span class="s2">def </span><span class="s1">test_not_enough_values(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.shapiro</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.shapiro</span><span class="s2">, </span><span class="s1">np.array([[]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=object))</span>

    <span class="s2">def </span><span class="s1">test_bad_arg(self):</span>
        <span class="s0"># Length of x is less than 3.</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.shapiro</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">test_nan_input(self):</span>
        <span class="s1">x = np.arange(</span><span class="s4">10.</span><span class="s1">)</span>
        <span class="s1">x[</span><span class="s4">9</span><span class="s1">] = np.nan</span>

        <span class="s1">w</span><span class="s2">, </span><span class="s1">pw = stats.shapiro(x)</span>
        <span class="s1">shapiro_test = stats.shapiro(x)</span>
        <span class="s1">assert_equal(w</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_equal(shapiro_test.statistic</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_almost_equal(pw</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(shapiro_test.pvalue</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gh14462(self):</span>
        <span class="s0"># shapiro is theoretically location-invariant, but when the magnitude</span>
        <span class="s0"># of the values is much greater than the variance, there can be</span>
        <span class="s0"># numerical issues. Fixed by subtracting median from the data.</span>
        <span class="s0"># See gh-14462.</span>

        <span class="s1">trans_val</span><span class="s2">, </span><span class="s1">maxlog = stats.boxcox([</span><span class="s4">122500</span><span class="s2">, </span><span class="s4">474400</span><span class="s2">, </span><span class="s4">110400</span><span class="s1">])</span>
        <span class="s1">res = stats.shapiro(trans_val)</span>

        <span class="s0"># Reference from R:</span>
        <span class="s0"># options(digits=16)</span>
        <span class="s0"># x = c(0.00000000e+00, 3.39996924e-08, -6.35166875e-09)</span>
        <span class="s0"># shapiro.test(x)</span>
        <span class="s1">ref = (</span><span class="s4">0.86468431705371</span><span class="s2">, </span><span class="s4">0.2805581751566</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_length_3_gh18322(self):</span>
        <span class="s0"># gh-18322 reported that the p-value could be negative for input of</span>
        <span class="s0"># length 3. Check that this is resolved.</span>
        <span class="s1">res = stats.shapiro([</span><span class="s4">0.6931471805599453</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">res.pvalue &gt;= </span><span class="s4">0</span>

        <span class="s0"># R `shapiro.test` doesn't produce an accurate p-value in the case</span>
        <span class="s0"># above. Check that the formula used in `stats.shapiro` is not wrong.</span>
        <span class="s0"># options(digits=16)</span>
        <span class="s0"># x = c(-0.7746653110021126, -0.4344432067942129, 1.8157053280290931)</span>
        <span class="s0"># shapiro.test(x)</span>
        <span class="s1">x = [-</span><span class="s4">0.7746653110021126</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.4344432067942129</span><span class="s2">, </span><span class="s4">1.8157053280290931</span><span class="s1">]</span>
        <span class="s1">res = stats.shapiro(x)</span>
        <span class="s1">assert_allclose(res.statistic</span><span class="s2">, </span><span class="s4">0.84658770645509</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.2313666489882</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestAnderson:</span>
    <span class="s2">def </span><span class="s1">test_normal(self):</span>
        <span class="s1">rs = RandomState(</span><span class="s4">1234567890</span><span class="s1">)</span>
        <span class="s1">x1 = rs.standard_exponential(size=</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">x2 = rs.standard_normal(size=</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">A</span><span class="s2">, </span><span class="s1">crit</span><span class="s2">, </span><span class="s1">sig = stats.anderson(x1)</span>
        <span class="s1">assert_array_less(crit[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">A)</span>
        <span class="s1">A</span><span class="s2">, </span><span class="s1">crit</span><span class="s2">, </span><span class="s1">sig = stats.anderson(x2)</span>
        <span class="s1">assert_array_less(A</span><span class="s2">, </span><span class="s1">crit[-</span><span class="s4">2</span><span class="s1">:])</span>

        <span class="s1">v = np.ones(</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">v[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">A</span><span class="s2">, </span><span class="s1">crit</span><span class="s2">, </span><span class="s1">sig = stats.anderson(v)</span>
        <span class="s0"># The expected statistic 3.208057 was computed independently of scipy.</span>
        <span class="s0"># For example, in R:</span>
        <span class="s0">#   &gt; library(nortest)</span>
        <span class="s0">#   &gt; v &lt;- rep(1, 10)</span>
        <span class="s0">#   &gt; v[1] &lt;- 0</span>
        <span class="s0">#   &gt; result &lt;- ad.test(v)</span>
        <span class="s0">#   &gt; result$statistic</span>
        <span class="s0">#          A</span>
        <span class="s0">#   3.208057</span>
        <span class="s1">assert_allclose(A</span><span class="s2">, </span><span class="s4">3.208057</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_expon(self):</span>
        <span class="s1">rs = RandomState(</span><span class="s4">1234567890</span><span class="s1">)</span>
        <span class="s1">x1 = rs.standard_exponential(size=</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">x2 = rs.standard_normal(size=</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">A</span><span class="s2">, </span><span class="s1">crit</span><span class="s2">, </span><span class="s1">sig = stats.anderson(x1</span><span class="s2">, </span><span class="s3">'expon'</span><span class="s1">)</span>
        <span class="s1">assert_array_less(A</span><span class="s2">, </span><span class="s1">crit[-</span><span class="s4">2</span><span class="s1">:])</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">A</span><span class="s2">, </span><span class="s1">crit</span><span class="s2">, </span><span class="s1">sig = stats.anderson(x2</span><span class="s2">, </span><span class="s3">'expon'</span><span class="s1">)</span>
        <span class="s1">assert_(A &gt; crit[-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_gumbel(self):</span>
        <span class="s0"># Regression test for gh-6306.  Before that issue was fixed,</span>
        <span class="s0"># this case would return a2=inf.</span>
        <span class="s1">v = np.ones(</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">v[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0.0</span>
        <span class="s1">a2</span><span class="s2">, </span><span class="s1">crit</span><span class="s2">, </span><span class="s1">sig = stats.anderson(v</span><span class="s2">, </span><span class="s3">'gumbel'</span><span class="s1">)</span>
        <span class="s0"># A brief reimplementation of the calculation of the statistic.</span>
        <span class="s1">n = len(v)</span>
        <span class="s1">xbar</span><span class="s2">, </span><span class="s1">s = stats.gumbel_l.fit(v)</span>
        <span class="s1">logcdf = stats.gumbel_l.logcdf(v</span><span class="s2">, </span><span class="s1">xbar</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s1">logsf = stats.gumbel_l.logsf(v</span><span class="s2">, </span><span class="s1">xbar</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s1">i = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n+</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected_a2 = -n - np.mean((</span><span class="s4">2</span><span class="s1">*i - </span><span class="s4">1</span><span class="s1">) * (logcdf + logsf[::-</span><span class="s4">1</span><span class="s1">]))</span>

        <span class="s1">assert_allclose(a2</span><span class="s2">, </span><span class="s1">expected_a2)</span>

    <span class="s2">def </span><span class="s1">test_bad_arg(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.anderson</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dist=</span><span class="s3">'plate_of_shrimp'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_result_attributes(self):</span>
        <span class="s1">rs = RandomState(</span><span class="s4">1234567890</span><span class="s1">)</span>
        <span class="s1">x = rs.standard_exponential(size=</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">res = stats.anderson(x)</span>
        <span class="s1">attributes = (</span><span class="s3">'statistic'</span><span class="s2">, </span><span class="s3">'critical_values'</span><span class="s2">, </span><span class="s3">'significance_level'</span><span class="s1">)</span>
        <span class="s1">check_named_results(res</span><span class="s2">, </span><span class="s1">attributes)</span>

    <span class="s2">def </span><span class="s1">test_gumbel_l(self):</span>
        <span class="s0"># gh-2592, gh-6337</span>
        <span class="s0"># Adds support to 'gumbel_r' and 'gumbel_l' as valid inputs for dist.</span>
        <span class="s1">rs = RandomState(</span><span class="s4">1234567890</span><span class="s1">)</span>
        <span class="s1">x = rs.gumbel(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">A1</span><span class="s2">, </span><span class="s1">crit1</span><span class="s2">, </span><span class="s1">sig1 = stats.anderson(x</span><span class="s2">, </span><span class="s3">'gumbel'</span><span class="s1">)</span>
        <span class="s1">A2</span><span class="s2">, </span><span class="s1">crit2</span><span class="s2">, </span><span class="s1">sig2 = stats.anderson(x</span><span class="s2">, </span><span class="s3">'gumbel_l'</span><span class="s1">)</span>

        <span class="s1">assert_allclose(A2</span><span class="s2">, </span><span class="s1">A1)</span>

    <span class="s2">def </span><span class="s1">test_gumbel_r(self):</span>
        <span class="s0"># gh-2592, gh-6337</span>
        <span class="s0"># Adds support to 'gumbel_r' and 'gumbel_l' as valid inputs for dist.</span>
        <span class="s1">rs = RandomState(</span><span class="s4">1234567890</span><span class="s1">)</span>
        <span class="s1">x1 = rs.gumbel(size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">x2 = np.ones(</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s0"># A constant array is a degenerate case and breaks gumbel_r.fit, so</span>
        <span class="s0"># change one value in x2.</span>
        <span class="s1">x2[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0.996</span>
        <span class="s1">A1</span><span class="s2">, </span><span class="s1">crit1</span><span class="s2">, </span><span class="s1">sig1 = stats.anderson(x1</span><span class="s2">, </span><span class="s3">'gumbel_r'</span><span class="s1">)</span>
        <span class="s1">A2</span><span class="s2">, </span><span class="s1">crit2</span><span class="s2">, </span><span class="s1">sig2 = stats.anderson(x2</span><span class="s2">, </span><span class="s3">'gumbel_r'</span><span class="s1">)</span>

        <span class="s1">assert_array_less(A1</span><span class="s2">, </span><span class="s1">crit1[-</span><span class="s4">2</span><span class="s1">:])</span>
        <span class="s1">assert_(A2 &gt; crit2[-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_weibull_min_case_A(self):</span>
        <span class="s0"># data and reference values from `anderson` reference [7]</span>
        <span class="s1">x = np.array([</span><span class="s4">225</span><span class="s2">, </span><span class="s4">171</span><span class="s2">, </span><span class="s4">198</span><span class="s2">, </span><span class="s4">189</span><span class="s2">, </span><span class="s4">189</span><span class="s2">, </span><span class="s4">135</span><span class="s2">, </span><span class="s4">162</span><span class="s2">, </span><span class="s4">135</span><span class="s2">, </span><span class="s4">117</span><span class="s2">, </span><span class="s4">162</span><span class="s1">])</span>
        <span class="s1">res = stats.anderson(x</span><span class="s2">, </span><span class="s3">'weibull_min'</span><span class="s1">)</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = res.fit_result.params</span>
        <span class="s1">assert_allclose((m</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2.38</span><span class="s2">, </span><span class="s4">99.02</span><span class="s2">, </span><span class="s4">78.23</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.statistic</span><span class="s2">, </span><span class="s4">0.260</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res.statistic &lt; res.critical_values[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">c = </span><span class="s4">1 </span><span class="s1">/ m  </span><span class="s0"># ~0.42</span>
        <span class="s1">assert_allclose(c</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">2.38</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2e-3</span><span class="s1">)</span>
        <span class="s0"># interpolate between rows for c=0.4 and c=0.45, indices -3 and -2</span>
        <span class="s1">As40 = _Avals_weibull[-</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">As45 = _Avals_weibull[-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">As_ref = As40 + (c - </span><span class="s4">0.4</span><span class="s1">)/(</span><span class="s4">0.45 </span><span class="s1">- </span><span class="s4">0.4</span><span class="s1">) * (As45 - As40)</span>
        <span class="s0"># atol=1e-3 because results are rounded up to the next third decimal</span>
        <span class="s2">assert </span><span class="s1">np.all(res.critical_values &gt; As_ref)</span>
        <span class="s1">assert_allclose(res.critical_values</span><span class="s2">, </span><span class="s1">As_ref</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_weibull_min_case_B(self):</span>
        <span class="s0"># From `anderson` reference [7]</span>
        <span class="s1">x = np.array([</span><span class="s4">74</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">48</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">502</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s4">21</span><span class="s2">,</span>
                      <span class="s4">29</span><span class="s2">, </span><span class="s4">386</span><span class="s2">, </span><span class="s4">59</span><span class="s2">, </span><span class="s4">27</span><span class="s2">, </span><span class="s4">153</span><span class="s2">, </span><span class="s4">26</span><span class="s2">, </span><span class="s4">326</span><span class="s1">])</span>
        <span class="s1">message = </span><span class="s3">&quot;Maximum likelihood estimation has converged to &quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
            <span class="s1">stats.anderson(x</span><span class="s2">, </span><span class="s3">'weibull_min'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_weibull_warning_error(self):</span>
        <span class="s0"># Check for warning message when there are too few observations</span>
        <span class="s0"># This is also an example in which an error occurs during fitting</span>
        <span class="s1">x = -np.array([</span><span class="s4">225</span><span class="s2">, </span><span class="s4">75</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">168</span><span class="s2">, </span><span class="s4">107</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">61</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">29</span><span class="s1">])</span>
        <span class="s1">wmessage = </span><span class="s3">&quot;Critical values of the test statistic are given for the...&quot;</span>
        <span class="s1">emessage = </span><span class="s3">&quot;An error occurred while fitting the Weibull distribution...&quot;</span>
        <span class="s1">wcontext = pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=wmessage)</span>
        <span class="s1">econtext = pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=emessage)</span>
        <span class="s2">with </span><span class="s1">wcontext</span><span class="s2">, </span><span class="s1">econtext:</span>
            <span class="s1">stats.anderson(x</span><span class="s2">, </span><span class="s3">'weibull_min'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'distname'</span><span class="s2">,</span>
                             <span class="s1">[</span><span class="s3">'norm'</span><span class="s2">, </span><span class="s3">'expon'</span><span class="s2">, </span><span class="s3">'gumbel_l'</span><span class="s2">, </span><span class="s3">'extreme1'</span><span class="s2">,</span>
                              <span class="s3">'gumbel'</span><span class="s2">, </span><span class="s3">'gumbel_r'</span><span class="s2">, </span><span class="s3">'logistic'</span><span class="s2">, </span><span class="s3">'weibull_min'</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_anderson_fit_params(self</span><span class="s2">, </span><span class="s1">distname):</span>
        <span class="s0"># check that anderson now returns a FitResult</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">330691555377792039</span><span class="s1">)</span>
        <span class="s1">real_distname = (</span><span class="s3">'gumbel_l' </span><span class="s2">if </span><span class="s1">distname </span><span class="s2">in </span><span class="s1">{</span><span class="s3">'extreme1'</span><span class="s2">, </span><span class="s3">'gumbel'</span><span class="s1">}</span>
                         <span class="s2">else </span><span class="s1">distname)</span>
        <span class="s1">dist = getattr(stats</span><span class="s2">, </span><span class="s1">real_distname)</span>
        <span class="s1">params = distcont[real_distname]</span>
        <span class="s1">x = dist.rvs(*params</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">res = stats.anderson(x</span><span class="s2">, </span><span class="s1">distname)</span>
        <span class="s2">assert </span><span class="s1">res.fit_result.success</span>

    <span class="s2">def </span><span class="s1">test_anderson_weibull_As(self):</span>
        <span class="s1">m = </span><span class="s4">1  </span><span class="s0"># &quot;when mi &lt; 2, so that c &gt; 0.5, the last line...should be used&quot;</span>
        <span class="s1">assert_equal(_get_As_weibull(</span><span class="s4">1</span><span class="s1">/m)</span><span class="s2">, </span><span class="s1">_Avals_weibull[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">m = np.inf</span>
        <span class="s1">assert_equal(_get_As_weibull(</span><span class="s4">1</span><span class="s1">/m)</span><span class="s2">, </span><span class="s1">_Avals_weibull[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">TestAndersonKSamp:</span>
    <span class="s2">def </span><span class="s1">test_example1a(self):</span>
        <span class="s0"># Example data from Scholz &amp; Stephens (1987), originally</span>
        <span class="s0"># published in Lehmann (1995, Nonparametrics, Statistical</span>
        <span class="s0"># Methods Based on Ranks, p. 309)</span>
        <span class="s0"># Pass a mixture of lists and arrays</span>
        <span class="s1">t1 = [</span><span class="s4">38.7</span><span class="s2">, </span><span class="s4">41.5</span><span class="s2">, </span><span class="s4">43.8</span><span class="s2">, </span><span class="s4">44.5</span><span class="s2">, </span><span class="s4">45.5</span><span class="s2">, </span><span class="s4">46.0</span><span class="s2">, </span><span class="s4">47.7</span><span class="s2">, </span><span class="s4">58.0</span><span class="s1">]</span>
        <span class="s1">t2 = np.array([</span><span class="s4">39.2</span><span class="s2">, </span><span class="s4">39.3</span><span class="s2">, </span><span class="s4">39.7</span><span class="s2">, </span><span class="s4">41.4</span><span class="s2">, </span><span class="s4">41.8</span><span class="s2">, </span><span class="s4">42.9</span><span class="s2">, </span><span class="s4">43.3</span><span class="s2">, </span><span class="s4">45.8</span><span class="s1">])</span>
        <span class="s1">t3 = np.array([</span><span class="s4">34.0</span><span class="s2">, </span><span class="s4">35.0</span><span class="s2">, </span><span class="s4">39.0</span><span class="s2">, </span><span class="s4">40.0</span><span class="s2">, </span><span class="s4">43.0</span><span class="s2">, </span><span class="s4">43.0</span><span class="s2">, </span><span class="s4">44.0</span><span class="s2">, </span><span class="s4">45.0</span><span class="s1">])</span>
        <span class="s1">t4 = np.array([</span><span class="s4">34.0</span><span class="s2">, </span><span class="s4">34.8</span><span class="s2">, </span><span class="s4">34.8</span><span class="s2">, </span><span class="s4">35.4</span><span class="s2">, </span><span class="s4">37.2</span><span class="s2">, </span><span class="s4">37.8</span><span class="s2">, </span><span class="s4">41.2</span><span class="s2">, </span><span class="s4">42.8</span><span class="s1">])</span>

        <span class="s1">Tk</span><span class="s2">, </span><span class="s1">tm</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp((t1</span><span class="s2">, </span><span class="s1">t2</span><span class="s2">, </span><span class="s1">t3</span><span class="s2">, </span><span class="s1">t4)</span><span class="s2">, </span><span class="s1">midrank=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(Tk</span><span class="s2">, </span><span class="s4">4.449</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal([</span><span class="s4">0.4985</span><span class="s2">, </span><span class="s4">1.3237</span><span class="s2">, </span><span class="s4">1.9158</span><span class="s2">, </span><span class="s4">2.4930</span><span class="s2">, </span><span class="s4">3.2459</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">tm[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.0021</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.00025</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_example1b(self):</span>
        <span class="s0"># Example data from Scholz &amp; Stephens (1987), originally</span>
        <span class="s0"># published in Lehmann (1995, Nonparametrics, Statistical</span>
        <span class="s0"># Methods Based on Ranks, p. 309)</span>
        <span class="s0"># Pass arrays</span>
        <span class="s1">t1 = np.array([</span><span class="s4">38.7</span><span class="s2">, </span><span class="s4">41.5</span><span class="s2">, </span><span class="s4">43.8</span><span class="s2">, </span><span class="s4">44.5</span><span class="s2">, </span><span class="s4">45.5</span><span class="s2">, </span><span class="s4">46.0</span><span class="s2">, </span><span class="s4">47.7</span><span class="s2">, </span><span class="s4">58.0</span><span class="s1">])</span>
        <span class="s1">t2 = np.array([</span><span class="s4">39.2</span><span class="s2">, </span><span class="s4">39.3</span><span class="s2">, </span><span class="s4">39.7</span><span class="s2">, </span><span class="s4">41.4</span><span class="s2">, </span><span class="s4">41.8</span><span class="s2">, </span><span class="s4">42.9</span><span class="s2">, </span><span class="s4">43.3</span><span class="s2">, </span><span class="s4">45.8</span><span class="s1">])</span>
        <span class="s1">t3 = np.array([</span><span class="s4">34.0</span><span class="s2">, </span><span class="s4">35.0</span><span class="s2">, </span><span class="s4">39.0</span><span class="s2">, </span><span class="s4">40.0</span><span class="s2">, </span><span class="s4">43.0</span><span class="s2">, </span><span class="s4">43.0</span><span class="s2">, </span><span class="s4">44.0</span><span class="s2">, </span><span class="s4">45.0</span><span class="s1">])</span>
        <span class="s1">t4 = np.array([</span><span class="s4">34.0</span><span class="s2">, </span><span class="s4">34.8</span><span class="s2">, </span><span class="s4">34.8</span><span class="s2">, </span><span class="s4">35.4</span><span class="s2">, </span><span class="s4">37.2</span><span class="s2">, </span><span class="s4">37.8</span><span class="s2">, </span><span class="s4">41.2</span><span class="s2">, </span><span class="s4">42.8</span><span class="s1">])</span>
        <span class="s1">Tk</span><span class="s2">, </span><span class="s1">tm</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp((t1</span><span class="s2">, </span><span class="s1">t2</span><span class="s2">, </span><span class="s1">t3</span><span class="s2">, </span><span class="s1">t4)</span><span class="s2">, </span><span class="s1">midrank=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(Tk</span><span class="s2">, </span><span class="s4">4.480</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal([</span><span class="s4">0.4985</span><span class="s2">, </span><span class="s4">1.3237</span><span class="s2">, </span><span class="s4">1.9158</span><span class="s2">, </span><span class="s4">2.4930</span><span class="s2">, </span><span class="s4">3.2459</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">tm[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.0020</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.00025</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_example2a(self):</span>
        <span class="s0"># Example data taken from an earlier technical report of</span>
        <span class="s0"># Scholz and Stephens</span>
        <span class="s0"># Pass lists instead of arrays</span>
        <span class="s1">t1 = [</span><span class="s4">194</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">41</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">33</span><span class="s2">, </span><span class="s4">181</span><span class="s1">]</span>
        <span class="s1">t2 = [</span><span class="s4">413</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">58</span><span class="s2">, </span><span class="s4">37</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">65</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">169</span><span class="s2">, </span><span class="s4">447</span><span class="s2">, </span><span class="s4">184</span><span class="s2">, </span><span class="s4">36</span><span class="s2">, </span><span class="s4">201</span><span class="s2">, </span><span class="s4">118</span><span class="s1">]</span>
        <span class="s1">t3 = [</span><span class="s4">34</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">67</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">62</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">34</span><span class="s1">]</span>
        <span class="s1">t4 = [</span><span class="s4">90</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">60</span><span class="s2">, </span><span class="s4">186</span><span class="s2">, </span><span class="s4">61</span><span class="s2">, </span><span class="s4">49</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">56</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">79</span><span class="s2">, </span><span class="s4">84</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">59</span><span class="s2">, </span><span class="s4">29</span><span class="s2">,</span>
              <span class="s4">118</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">156</span><span class="s2">, </span><span class="s4">310</span><span class="s2">, </span><span class="s4">76</span><span class="s2">, </span><span class="s4">26</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">62</span><span class="s1">]</span>
        <span class="s1">t5 = [</span><span class="s4">130</span><span class="s2">, </span><span class="s4">208</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s4">101</span><span class="s2">, </span><span class="s4">208</span><span class="s1">]</span>
        <span class="s1">t6 = [</span><span class="s4">74</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">48</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">502</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">386</span><span class="s2">, </span><span class="s4">59</span><span class="s2">, </span><span class="s4">27</span><span class="s1">]</span>
        <span class="s1">t7 = [</span><span class="s4">55</span><span class="s2">, </span><span class="s4">320</span><span class="s2">, </span><span class="s4">56</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">220</span><span class="s2">, </span><span class="s4">239</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">246</span><span class="s2">, </span><span class="s4">176</span><span class="s2">, </span><span class="s4">182</span><span class="s2">, </span><span class="s4">33</span><span class="s1">]</span>
        <span class="s1">t8 = [</span><span class="s4">23</span><span class="s2">, </span><span class="s4">261</span><span class="s2">, </span><span class="s4">87</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">120</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">62</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">225</span><span class="s2">, </span><span class="s4">71</span><span class="s2">, </span><span class="s4">246</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">42</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">5</span><span class="s2">,</span>
              <span class="s4">12</span><span class="s2">, </span><span class="s4">120</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">71</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">90</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">52</span><span class="s2">, </span><span class="s4">95</span><span class="s1">]</span>
        <span class="s1">t9 = [</span><span class="s4">97</span><span class="s2">, </span><span class="s4">51</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">141</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">142</span><span class="s2">, </span><span class="s4">68</span><span class="s2">, </span><span class="s4">77</span><span class="s2">, </span><span class="s4">80</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">106</span><span class="s2">, </span><span class="s4">206</span><span class="s2">, </span><span class="s4">82</span><span class="s2">,</span>
              <span class="s4">54</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">216</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">111</span><span class="s2">, </span><span class="s4">39</span><span class="s2">, </span><span class="s4">63</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">191</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">163</span><span class="s2">, </span><span class="s4">24</span><span class="s1">]</span>
        <span class="s1">t10 = [</span><span class="s4">50</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">102</span><span class="s2">, </span><span class="s4">72</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">39</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">197</span><span class="s2">, </span><span class="s4">188</span><span class="s2">, </span><span class="s4">79</span><span class="s2">, </span><span class="s4">88</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">36</span><span class="s2">,</span>
               <span class="s4">22</span><span class="s2">, </span><span class="s4">139</span><span class="s2">, </span><span class="s4">210</span><span class="s2">, </span><span class="s4">97</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">14</span><span class="s1">]</span>
        <span class="s1">t11 = [</span><span class="s4">359</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">270</span><span class="s2">, </span><span class="s4">603</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">438</span><span class="s1">]</span>
        <span class="s1">t12 = [</span><span class="s4">50</span><span class="s2">, </span><span class="s4">254</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">283</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span>
        <span class="s1">t13 = [</span><span class="s4">487</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">98</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">85</span><span class="s2">, </span><span class="s4">91</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">230</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">130</span><span class="s1">]</span>
        <span class="s1">t14 = [</span><span class="s4">102</span><span class="s2">, </span><span class="s4">209</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">54</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s4">67</span><span class="s2">, </span><span class="s4">59</span><span class="s2">, </span><span class="s4">134</span><span class="s2">, </span><span class="s4">152</span><span class="s2">, </span><span class="s4">27</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">230</span><span class="s2">, </span><span class="s4">66</span><span class="s2">,</span>
               <span class="s4">61</span><span class="s2">, </span><span class="s4">34</span><span class="s1">]</span>

        <span class="s1">Tk</span><span class="s2">, </span><span class="s1">tm</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp((t1</span><span class="s2">, </span><span class="s1">t2</span><span class="s2">, </span><span class="s1">t3</span><span class="s2">, </span><span class="s1">t4</span><span class="s2">, </span><span class="s1">t5</span><span class="s2">, </span><span class="s1">t6</span><span class="s2">, </span><span class="s1">t7</span><span class="s2">, </span><span class="s1">t8</span><span class="s2">,</span>
                                          <span class="s1">t9</span><span class="s2">, </span><span class="s1">t10</span><span class="s2">, </span><span class="s1">t11</span><span class="s2">, </span><span class="s1">t12</span><span class="s2">, </span><span class="s1">t13</span><span class="s2">, </span><span class="s1">t14)</span><span class="s2">,</span>
                                         <span class="s1">midrank=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(Tk</span><span class="s2">, </span><span class="s4">3.288</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal([</span><span class="s4">0.5990</span><span class="s2">, </span><span class="s4">1.3269</span><span class="s2">, </span><span class="s4">1.8052</span><span class="s2">, </span><span class="s4">2.2486</span><span class="s2">, </span><span class="s4">2.8009</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">tm[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.0041</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.00025</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_example2b(self):</span>
        <span class="s0"># Example data taken from an earlier technical report of</span>
        <span class="s0"># Scholz and Stephens</span>
        <span class="s1">t1 = [</span><span class="s4">194</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">41</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">33</span><span class="s2">, </span><span class="s4">181</span><span class="s1">]</span>
        <span class="s1">t2 = [</span><span class="s4">413</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">58</span><span class="s2">, </span><span class="s4">37</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">65</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">169</span><span class="s2">, </span><span class="s4">447</span><span class="s2">, </span><span class="s4">184</span><span class="s2">, </span><span class="s4">36</span><span class="s2">, </span><span class="s4">201</span><span class="s2">, </span><span class="s4">118</span><span class="s1">]</span>
        <span class="s1">t3 = [</span><span class="s4">34</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">67</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">62</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">34</span><span class="s1">]</span>
        <span class="s1">t4 = [</span><span class="s4">90</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">60</span><span class="s2">, </span><span class="s4">186</span><span class="s2">, </span><span class="s4">61</span><span class="s2">, </span><span class="s4">49</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">56</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">79</span><span class="s2">, </span><span class="s4">84</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">59</span><span class="s2">, </span><span class="s4">29</span><span class="s2">,</span>
              <span class="s4">118</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">156</span><span class="s2">, </span><span class="s4">310</span><span class="s2">, </span><span class="s4">76</span><span class="s2">, </span><span class="s4">26</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">62</span><span class="s1">]</span>
        <span class="s1">t5 = [</span><span class="s4">130</span><span class="s2">, </span><span class="s4">208</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s4">101</span><span class="s2">, </span><span class="s4">208</span><span class="s1">]</span>
        <span class="s1">t6 = [</span><span class="s4">74</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">48</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">502</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">386</span><span class="s2">, </span><span class="s4">59</span><span class="s2">, </span><span class="s4">27</span><span class="s1">]</span>
        <span class="s1">t7 = [</span><span class="s4">55</span><span class="s2">, </span><span class="s4">320</span><span class="s2">, </span><span class="s4">56</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">220</span><span class="s2">, </span><span class="s4">239</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">246</span><span class="s2">, </span><span class="s4">176</span><span class="s2">, </span><span class="s4">182</span><span class="s2">, </span><span class="s4">33</span><span class="s1">]</span>
        <span class="s1">t8 = [</span><span class="s4">23</span><span class="s2">, </span><span class="s4">261</span><span class="s2">, </span><span class="s4">87</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">120</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">62</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">225</span><span class="s2">, </span><span class="s4">71</span><span class="s2">, </span><span class="s4">246</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">42</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">5</span><span class="s2">,</span>
              <span class="s4">12</span><span class="s2">, </span><span class="s4">120</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">71</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">90</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">52</span><span class="s2">, </span><span class="s4">95</span><span class="s1">]</span>
        <span class="s1">t9 = [</span><span class="s4">97</span><span class="s2">, </span><span class="s4">51</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">141</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">142</span><span class="s2">, </span><span class="s4">68</span><span class="s2">, </span><span class="s4">77</span><span class="s2">, </span><span class="s4">80</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">106</span><span class="s2">, </span><span class="s4">206</span><span class="s2">, </span><span class="s4">82</span><span class="s2">,</span>
              <span class="s4">54</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">216</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">111</span><span class="s2">, </span><span class="s4">39</span><span class="s2">, </span><span class="s4">63</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">191</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">163</span><span class="s2">, </span><span class="s4">24</span><span class="s1">]</span>
        <span class="s1">t10 = [</span><span class="s4">50</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">102</span><span class="s2">, </span><span class="s4">72</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">39</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">197</span><span class="s2">, </span><span class="s4">188</span><span class="s2">, </span><span class="s4">79</span><span class="s2">, </span><span class="s4">88</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">36</span><span class="s2">,</span>
               <span class="s4">22</span><span class="s2">, </span><span class="s4">139</span><span class="s2">, </span><span class="s4">210</span><span class="s2">, </span><span class="s4">97</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">14</span><span class="s1">]</span>
        <span class="s1">t11 = [</span><span class="s4">359</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">270</span><span class="s2">, </span><span class="s4">603</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">438</span><span class="s1">]</span>
        <span class="s1">t12 = [</span><span class="s4">50</span><span class="s2">, </span><span class="s4">254</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">283</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span>
        <span class="s1">t13 = [</span><span class="s4">487</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">98</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">85</span><span class="s2">, </span><span class="s4">91</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">230</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">130</span><span class="s1">]</span>
        <span class="s1">t14 = [</span><span class="s4">102</span><span class="s2">, </span><span class="s4">209</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">54</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s4">67</span><span class="s2">, </span><span class="s4">59</span><span class="s2">, </span><span class="s4">134</span><span class="s2">, </span><span class="s4">152</span><span class="s2">, </span><span class="s4">27</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">230</span><span class="s2">, </span><span class="s4">66</span><span class="s2">,</span>
               <span class="s4">61</span><span class="s2">, </span><span class="s4">34</span><span class="s1">]</span>

        <span class="s1">Tk</span><span class="s2">, </span><span class="s1">tm</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp((t1</span><span class="s2">, </span><span class="s1">t2</span><span class="s2">, </span><span class="s1">t3</span><span class="s2">, </span><span class="s1">t4</span><span class="s2">, </span><span class="s1">t5</span><span class="s2">, </span><span class="s1">t6</span><span class="s2">, </span><span class="s1">t7</span><span class="s2">, </span><span class="s1">t8</span><span class="s2">,</span>
                                          <span class="s1">t9</span><span class="s2">, </span><span class="s1">t10</span><span class="s2">, </span><span class="s1">t11</span><span class="s2">, </span><span class="s1">t12</span><span class="s2">, </span><span class="s1">t13</span><span class="s2">, </span><span class="s1">t14)</span><span class="s2">,</span>
                                         <span class="s1">midrank=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(Tk</span><span class="s2">, </span><span class="s4">3.294</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal([</span><span class="s4">0.5990</span><span class="s2">, </span><span class="s4">1.3269</span><span class="s2">, </span><span class="s4">1.8052</span><span class="s2">, </span><span class="s4">2.2486</span><span class="s2">, </span><span class="s4">2.8009</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">tm[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.0041</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.00025</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_R_kSamples(self):</span>
        <span class="s0"># test values generates with R package kSamples</span>
        <span class="s0"># package version 1.2-6 (2017-06-14)</span>
        <span class="s0"># r1 = 1:100</span>
        <span class="s0"># continuous case (no ties) --&gt; version  1</span>
        <span class="s0"># res &lt;- kSamples::ad.test(r1, r1 + 40.5)</span>
        <span class="s0"># res$ad[1, &quot;T.AD&quot;] #  41.105</span>
        <span class="s0"># res$ad[1, &quot; asympt. P-value&quot;] #  5.8399e-18</span>
        <span class="s0">#</span>
        <span class="s0"># discrete case (ties allowed) --&gt; version  2 (here: midrank=True)</span>
        <span class="s0"># res$ad[2, &quot;T.AD&quot;] #  41.235</span>
        <span class="s0">#</span>
        <span class="s0"># res &lt;- kSamples::ad.test(r1, r1 + .5)</span>
        <span class="s0"># res$ad[1, &quot;T.AD&quot;] #  -1.2824</span>
        <span class="s0"># res$ad[1, &quot; asympt. P-value&quot;] #  1</span>
        <span class="s0"># res$ad[2, &quot;T.AD&quot;] #  -1.2944</span>
        <span class="s0">#</span>
        <span class="s0"># res &lt;- kSamples::ad.test(r1, r1 + 7.5)</span>
        <span class="s0"># res$ad[1, &quot;T.AD&quot;] # 1.4923</span>
        <span class="s0"># res$ad[1, &quot; asympt. P-value&quot;] # 0.077501</span>
        <span class="s0">#</span>
        <span class="s0"># res &lt;- kSamples::ad.test(r1, r1 + 6)</span>
        <span class="s0"># res$ad[2, &quot;T.AD&quot;] # 0.63892</span>
        <span class="s0"># res$ad[2, &quot; asympt. P-value&quot;] # 0.17981</span>
        <span class="s0">#</span>
        <span class="s0"># res &lt;- kSamples::ad.test(r1, r1 + 11.5)</span>
        <span class="s0"># res$ad[1, &quot;T.AD&quot;] # 4.5042</span>
        <span class="s0"># res$ad[1, &quot; asympt. P-value&quot;] # 0.00545</span>
        <span class="s0">#</span>
        <span class="s0"># res &lt;- kSamples::ad.test(r1, r1 + 13.5)</span>
        <span class="s0"># res$ad[1, &quot;T.AD&quot;] # 6.2982</span>
        <span class="s0"># res$ad[1, &quot; asympt. P-value&quot;] # 0.00118</span>

        <span class="s1">x1 = np.linspace(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s0"># test case: different distributions;p-value floored at 0.001</span>
        <span class="s0"># test case for issue #5493 / #8536</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">'p-value floored'</span><span class="s1">)</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp([x1</span><span class="s2">, </span><span class="s1">x1 + </span><span class="s4">40.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">midrank=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(s</span><span class="s2">, </span><span class="s4">41.105</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">0.001</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">'p-value floored'</span><span class="s1">)</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp([x1</span><span class="s2">, </span><span class="s1">x1 + </span><span class="s4">40.5</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(s</span><span class="s2">, </span><span class="s4">41.235</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">0.001</span><span class="s1">)</span>

        <span class="s0"># test case: similar distributions --&gt; p-value capped at 0.25</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">'p-value capped'</span><span class="s1">)</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp([x1</span><span class="s2">, </span><span class="s1">x1 + </span><span class="s4">.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">midrank=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(s</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.2824</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">'p-value capped'</span><span class="s1">)</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp([x1</span><span class="s2">, </span><span class="s1">x1 + </span><span class="s4">.5</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(s</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.2944</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span>

        <span class="s0"># test case: check interpolated p-value in [0.01, 0.25] (no ties)</span>
        <span class="s1">s</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp([x1</span><span class="s2">, </span><span class="s1">x1 + </span><span class="s4">7.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">midrank=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(s</span><span class="s2">, </span><span class="s4">1.4923</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.0775</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.005</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># test case: check interpolated p-value in [0.01, 0.25] (w/ ties)</span>
        <span class="s1">s</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp([x1</span><span class="s2">, </span><span class="s1">x1 + </span><span class="s4">6</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(s</span><span class="s2">, </span><span class="s4">0.6389</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.1798</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.005</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># test extended critical values for p=0.001 and p=0.005</span>
        <span class="s1">s</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp([x1</span><span class="s2">, </span><span class="s1">x1 + </span><span class="s4">11.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">midrank=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(s</span><span class="s2">, </span><span class="s4">4.5042</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.00545</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.0005</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">s</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.anderson_ksamp([x1</span><span class="s2">, </span><span class="s1">x1 + </span><span class="s4">13.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">midrank=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(s</span><span class="s2">, </span><span class="s4">6.2982</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.00118</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.0001</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_not_enough_samples(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.anderson_ksamp</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">5</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_no_distinct_observations(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.anderson_ksamp</span><span class="s2">,</span>
                      <span class="s1">(np.ones(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">5</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">test_empty_sample(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.anderson_ksamp</span><span class="s2">, </span><span class="s1">(np.ones(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[]))</span>

    <span class="s2">def </span><span class="s1">test_result_attributes(self):</span>
        <span class="s0"># Pass a mixture of lists and arrays</span>
        <span class="s1">t1 = [</span><span class="s4">38.7</span><span class="s2">, </span><span class="s4">41.5</span><span class="s2">, </span><span class="s4">43.8</span><span class="s2">, </span><span class="s4">44.5</span><span class="s2">, </span><span class="s4">45.5</span><span class="s2">, </span><span class="s4">46.0</span><span class="s2">, </span><span class="s4">47.7</span><span class="s2">, </span><span class="s4">58.0</span><span class="s1">]</span>
        <span class="s1">t2 = np.array([</span><span class="s4">39.2</span><span class="s2">, </span><span class="s4">39.3</span><span class="s2">, </span><span class="s4">39.7</span><span class="s2">, </span><span class="s4">41.4</span><span class="s2">, </span><span class="s4">41.8</span><span class="s2">, </span><span class="s4">42.9</span><span class="s2">, </span><span class="s4">43.3</span><span class="s2">, </span><span class="s4">45.8</span><span class="s1">])</span>
        <span class="s1">res = stats.anderson_ksamp((t1</span><span class="s2">, </span><span class="s1">t2)</span><span class="s2">, </span><span class="s1">midrank=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">attributes = (</span><span class="s3">'statistic'</span><span class="s2">, </span><span class="s3">'critical_values'</span><span class="s2">, </span><span class="s3">'significance_level'</span><span class="s1">)</span>
        <span class="s1">check_named_results(res</span><span class="s2">, </span><span class="s1">attributes)</span>

        <span class="s1">assert_equal(res.significance_level</span><span class="s2">, </span><span class="s1">res.pvalue)</span>


<span class="s2">class </span><span class="s1">TestAnsari:</span>

    <span class="s2">def </span><span class="s1">test_small(self):</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s3">&quot;Ties preclude use of exact statistic.&quot;</span><span class="s1">)</span>
            <span class="s1">W</span><span class="s2">, </span><span class="s1">pval = stats.ansari(x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s1">assert_almost_equal(W</span><span class="s2">, </span><span class="s4">23.5</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pval</span><span class="s2">, </span><span class="s4">0.13499256881897437</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_approx(self):</span>
        <span class="s1">ramsay = np.array((</span><span class="s4">111</span><span class="s2">, </span><span class="s4">107</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">99</span><span class="s2">, </span><span class="s4">102</span><span class="s2">, </span><span class="s4">106</span><span class="s2">, </span><span class="s4">109</span><span class="s2">, </span><span class="s4">108</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">99</span><span class="s2">,</span>
                           <span class="s4">101</span><span class="s2">, </span><span class="s4">96</span><span class="s2">, </span><span class="s4">97</span><span class="s2">, </span><span class="s4">102</span><span class="s2">, </span><span class="s4">107</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">116</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">110</span><span class="s2">, </span><span class="s4">98</span><span class="s1">))</span>
        <span class="s1">parekh = np.array((</span><span class="s4">107</span><span class="s2">, </span><span class="s4">108</span><span class="s2">, </span><span class="s4">106</span><span class="s2">, </span><span class="s4">98</span><span class="s2">, </span><span class="s4">105</span><span class="s2">, </span><span class="s4">103</span><span class="s2">, </span><span class="s4">110</span><span class="s2">, </span><span class="s4">105</span><span class="s2">, </span><span class="s4">104</span><span class="s2">,</span>
                           <span class="s4">100</span><span class="s2">, </span><span class="s4">96</span><span class="s2">, </span><span class="s4">108</span><span class="s2">, </span><span class="s4">103</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">114</span><span class="s2">, </span><span class="s4">114</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">108</span><span class="s2">,</span>
                           <span class="s4">106</span><span class="s2">, </span><span class="s4">99</span><span class="s1">))</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s3">&quot;Ties preclude use of exact statistic.&quot;</span><span class="s1">)</span>
            <span class="s1">W</span><span class="s2">, </span><span class="s1">pval = stats.ansari(ramsay</span><span class="s2">, </span><span class="s1">parekh)</span>

        <span class="s1">assert_almost_equal(W</span><span class="s2">, </span><span class="s4">185.5</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pval</span><span class="s2">, </span><span class="s4">0.18145819972867083</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_exact(self):</span>
        <span class="s1">W</span><span class="s2">, </span><span class="s1">pval = stats.ansari([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">15</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">12</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(W</span><span class="s2">, </span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pval</span><span class="s2">, </span><span class="s4">0.533333333333333333</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_arg(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.ansari</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.ansari</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[])</span>

    <span class="s2">def </span><span class="s1">test_result_attributes(self):</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s3">&quot;Ties preclude use of exact statistic.&quot;</span><span class="s1">)</span>
            <span class="s1">res = stats.ansari(x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s1">attributes = (</span><span class="s3">'statistic'</span><span class="s2">, </span><span class="s3">'pvalue'</span><span class="s1">)</span>
        <span class="s1">check_named_results(res</span><span class="s2">, </span><span class="s1">attributes)</span>

    <span class="s2">def </span><span class="s1">test_bad_alternative(self):</span>
        <span class="s0"># invalid value for alternative must raise a ValueError</span>
        <span class="s1">x1 = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">x2 = [</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span>
        <span class="s1">match = </span><span class="s3">&quot;'alternative' must be 'two-sided'&quot;</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=match):</span>
            <span class="s1">stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'foo'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_alternative_exact(self):</span>
        <span class="s1">x1 = [-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">25</span><span class="s1">]  </span><span class="s0"># high scale, loc=10</span>
        <span class="s1">x2 = [</span><span class="s4">7.5</span><span class="s2">, </span><span class="s4">8.5</span><span class="s2">, </span><span class="s4">9.5</span><span class="s2">, </span><span class="s4">10.5</span><span class="s2">, </span><span class="s4">11.5</span><span class="s2">, </span><span class="s4">12.5</span><span class="s1">]  </span><span class="s0"># low scale, loc=10</span>
        <span class="s0"># ratio of scales is greater than 1. So, the</span>
        <span class="s0"># p-value must be high when `alternative='less'`</span>
        <span class="s0"># and low when `alternative='greater'`.</span>
        <span class="s1">statistic</span><span class="s2">, </span><span class="s1">pval = stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2)</span>
        <span class="s1">pval_l = stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'less'</span><span class="s1">).pvalue</span>
        <span class="s1">pval_g = stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'greater'</span><span class="s1">).pvalue</span>
        <span class="s2">assert </span><span class="s1">pval_l &gt; </span><span class="s4">0.95</span>
        <span class="s2">assert </span><span class="s1">pval_g &lt; </span><span class="s4">0.05  </span><span class="s0"># level of significance.</span>
        <span class="s0"># also check if the p-values sum up to 1 plus the probability</span>
        <span class="s0"># mass under the calculated statistic.</span>
        <span class="s1">prob = _abw_state.pmf(statistic</span><span class="s2">, </span><span class="s1">len(x1)</span><span class="s2">, </span><span class="s1">len(x2))</span>
        <span class="s1">assert_allclose(pval_g + pval_l</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ prob</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s0"># also check if one of the one-sided p-value equals half the</span>
        <span class="s0"># two-sided p-value and the other one-sided p-value is its</span>
        <span class="s0"># compliment.</span>
        <span class="s1">assert_allclose(pval_g</span><span class="s2">, </span><span class="s1">pval/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pval_l</span><span class="s2">, </span><span class="s4">1</span><span class="s1">+prob-pval/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s0"># sanity check. The result should flip if</span>
        <span class="s0"># we exchange x and y.</span>
        <span class="s1">pval_l_reverse = stats.ansari(x2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'less'</span><span class="s1">).pvalue</span>
        <span class="s1">pval_g_reverse = stats.ansari(x2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'greater'</span><span class="s1">).pvalue</span>
        <span class="s2">assert </span><span class="s1">pval_l_reverse &lt; </span><span class="s4">0.05</span>
        <span class="s2">assert </span><span class="s1">pval_g_reverse &gt; </span><span class="s4">0.95</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">'x, y, alternative, expected'</span><span class="s2">,</span>
        <span class="s0"># the tests are designed in such a way that the</span>
        <span class="s0"># if else statement in ansari test for exact</span>
        <span class="s0"># mode is covered.</span>
        <span class="s1">[([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, </span><span class="s4">0.6285714285714</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, </span><span class="s4">0.6285714285714</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, </span><span class="s4">0.8928571428571</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, </span><span class="s4">0.2857142857143</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, </span><span class="s4">0.2857142857143</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, </span><span class="s4">0.8928571428571</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_alternative_exact_with_R(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s0"># testing with R on arbitrary data</span>
        <span class="s0"># Sample R code used for the third test case above:</span>
        <span class="s0"># ```R</span>
        <span class="s0"># &gt; options(digits=16)</span>
        <span class="s0"># &gt; x &lt;- c(1,2,3)</span>
        <span class="s0"># &gt; y &lt;- c(4,5,6,7,8)</span>
        <span class="s0"># &gt; ansari.test(x, y, alternative='less', exact=TRUE)</span>
        <span class="s0">#</span>
        <span class="s0">#     Ansari-Bradley test</span>
        <span class="s0">#</span>
        <span class="s0"># data:  x and y</span>
        <span class="s0"># AB = 6, p-value = 0.8928571428571</span>
        <span class="s0"># alternative hypothesis: true ratio of scales is less than 1</span>
        <span class="s0">#</span>
        <span class="s0"># ```</span>
        <span class="s1">pval = stats.ansari(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=alternative).pvalue</span>
        <span class="s1">assert_allclose(pval</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_alternative_approx(self):</span>
        <span class="s0"># intuitive tests for approximation</span>
        <span class="s1">x1 = stats.norm.rvs(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">123</span><span class="s1">)</span>
        <span class="s1">x2 = stats.norm.rvs(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">123</span><span class="s1">)</span>
        <span class="s0"># for m &gt; 55 or n &gt; 55, the test should automatically</span>
        <span class="s0"># switch to approximation.</span>
        <span class="s1">pval_l = stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'less'</span><span class="s1">).pvalue</span>
        <span class="s1">pval_g = stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'greater'</span><span class="s1">).pvalue</span>
        <span class="s1">assert_allclose(pval_l</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pval_g</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s0"># also check if one of the one-sided p-value equals half the</span>
        <span class="s0"># two-sided p-value and the other one-sided p-value is its</span>
        <span class="s0"># compliment.</span>
        <span class="s1">x1 = stats.norm.rvs(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">123</span><span class="s1">)</span>
        <span class="s1">x2 = stats.norm.rvs(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">60</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">123</span><span class="s1">)</span>
        <span class="s1">pval = stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2).pvalue</span>
        <span class="s1">pval_l = stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'less'</span><span class="s1">).pvalue</span>
        <span class="s1">pval_g = stats.ansari(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'greater'</span><span class="s1">).pvalue</span>
        <span class="s1">assert_allclose(pval_g</span><span class="s2">, </span><span class="s1">pval/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pval_l</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-pval/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestBartlett:</span>

    <span class="s2">def </span><span class="s1">test_data(self):</span>
        <span class="s0"># https://www.itl.nist.gov/div898/handbook/eda/section3/eda357.htm</span>
        <span class="s1">args = [g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">g3</span><span class="s2">, </span><span class="s1">g4</span><span class="s2">, </span><span class="s1">g5</span><span class="s2">, </span><span class="s1">g6</span><span class="s2">, </span><span class="s1">g7</span><span class="s2">, </span><span class="s1">g8</span><span class="s2">, </span><span class="s1">g9</span><span class="s2">, </span><span class="s1">g10]</span>
        <span class="s1">T</span><span class="s2">, </span><span class="s1">pval = stats.bartlett(*args)</span>
        <span class="s1">assert_almost_equal(T</span><span class="s2">, </span><span class="s4">20.78587342806484</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pval</span><span class="s2">, </span><span class="s4">0.0136358632781</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_arg(self):</span>
        <span class="s0"># Too few args raises ValueError.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.bartlett</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_result_attributes(self):</span>
        <span class="s1">args = [g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">g3</span><span class="s2">, </span><span class="s1">g4</span><span class="s2">, </span><span class="s1">g5</span><span class="s2">, </span><span class="s1">g6</span><span class="s2">, </span><span class="s1">g7</span><span class="s2">, </span><span class="s1">g8</span><span class="s2">, </span><span class="s1">g9</span><span class="s2">, </span><span class="s1">g10]</span>
        <span class="s1">res = stats.bartlett(*args)</span>
        <span class="s1">attributes = (</span><span class="s3">'statistic'</span><span class="s2">, </span><span class="s3">'pvalue'</span><span class="s1">)</span>
        <span class="s1">check_named_results(res</span><span class="s2">, </span><span class="s1">attributes)</span>

    <span class="s2">def </span><span class="s1">test_empty_arg(self):</span>
        <span class="s1">args = (g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">g3</span><span class="s2">, </span><span class="s1">g4</span><span class="s2">, </span><span class="s1">g5</span><span class="s2">, </span><span class="s1">g6</span><span class="s2">, </span><span class="s1">g7</span><span class="s2">, </span><span class="s1">g8</span><span class="s2">, </span><span class="s1">g9</span><span class="s2">, </span><span class="s1">g10</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">assert_equal((np.nan</span><span class="s2">, </span><span class="s1">np.nan)</span><span class="s2">, </span><span class="s1">stats.bartlett(*args))</span>

    <span class="s0"># temporary fix for issue #9252: only accept 1d input</span>
    <span class="s2">def </span><span class="s1">test_1d_input(self):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.bartlett</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">class </span><span class="s1">TestLevene:</span>

    <span class="s2">def </span><span class="s1">test_data(self):</span>
        <span class="s0"># https://www.itl.nist.gov/div898/handbook/eda/section3/eda35a.htm</span>
        <span class="s1">args = [g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">g3</span><span class="s2">, </span><span class="s1">g4</span><span class="s2">, </span><span class="s1">g5</span><span class="s2">, </span><span class="s1">g6</span><span class="s2">, </span><span class="s1">g7</span><span class="s2">, </span><span class="s1">g8</span><span class="s2">, </span><span class="s1">g9</span><span class="s2">, </span><span class="s1">g10]</span>
        <span class="s1">W</span><span class="s2">, </span><span class="s1">pval = stats.levene(*args)</span>
        <span class="s1">assert_almost_equal(W</span><span class="s2">, </span><span class="s4">1.7059176930008939</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pval</span><span class="s2">, </span><span class="s4">0.0990829755522</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_trimmed1(self):</span>
        <span class="s0"># Test that center='trimmed' gives the same result as center='mean'</span>
        <span class="s0"># when proportiontocut=0.</span>
        <span class="s1">W1</span><span class="s2">, </span><span class="s1">pval1 = stats.levene(g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">g3</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'mean'</span><span class="s1">)</span>
        <span class="s1">W2</span><span class="s2">, </span><span class="s1">pval2 = stats.levene(g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">g3</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'trimmed'</span><span class="s2">,</span>
                                 <span class="s1">proportiontocut=</span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(W1</span><span class="s2">, </span><span class="s1">W2)</span>
        <span class="s1">assert_almost_equal(pval1</span><span class="s2">, </span><span class="s1">pval2)</span>

    <span class="s2">def </span><span class="s1">test_trimmed2(self):</span>
        <span class="s1">x = [</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">6.0</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">100.0</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">4.5</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.5</span><span class="s2">, </span><span class="s4">200.0</span><span class="s1">]</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x2 = np.random.permutation(x)</span>

        <span class="s0"># Use center='trimmed'</span>
        <span class="s1">W0</span><span class="s2">, </span><span class="s1">pval0 = stats.levene(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'trimmed'</span><span class="s2">,</span>
                                 <span class="s1">proportiontocut=</span><span class="s4">0.125</span><span class="s1">)</span>
        <span class="s1">W1</span><span class="s2">, </span><span class="s1">pval1 = stats.levene(x2</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'trimmed'</span><span class="s2">,</span>
                                 <span class="s1">proportiontocut=</span><span class="s4">0.125</span><span class="s1">)</span>
        <span class="s0"># Trim the data here, and use center='mean'</span>
        <span class="s1">W2</span><span class="s2">, </span><span class="s1">pval2 = stats.levene(x[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'mean'</span><span class="s1">)</span>
        <span class="s0"># Result should be the same.</span>
        <span class="s1">assert_almost_equal(W0</span><span class="s2">, </span><span class="s1">W2)</span>
        <span class="s1">assert_almost_equal(W1</span><span class="s2">, </span><span class="s1">W2)</span>
        <span class="s1">assert_almost_equal(pval1</span><span class="s2">, </span><span class="s1">pval2)</span>

    <span class="s2">def </span><span class="s1">test_equal_mean_median(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x2 = np.random.permutation(x)</span>
        <span class="s1">y = x**</span><span class="s4">3</span>
        <span class="s1">W1</span><span class="s2">, </span><span class="s1">pval1 = stats.levene(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'mean'</span><span class="s1">)</span>
        <span class="s1">W2</span><span class="s2">, </span><span class="s1">pval2 = stats.levene(x2</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'median'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(W1</span><span class="s2">, </span><span class="s1">W2)</span>
        <span class="s1">assert_almost_equal(pval1</span><span class="s2">, </span><span class="s1">pval2)</span>

    <span class="s2">def </span><span class="s1">test_bad_keyword(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.levene</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">portiontocut=</span><span class="s4">0.1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_center_value(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.levene</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'trim'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_too_few_args(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.levene</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_result_attributes(self):</span>
        <span class="s1">args = [g1</span><span class="s2">, </span><span class="s1">g2</span><span class="s2">, </span><span class="s1">g3</span><span class="s2">, </span><span class="s1">g4</span><span class="s2">, </span><span class="s1">g5</span><span class="s2">, </span><span class="s1">g6</span><span class="s2">, </span><span class="s1">g7</span><span class="s2">, </span><span class="s1">g8</span><span class="s2">, </span><span class="s1">g9</span><span class="s2">, </span><span class="s1">g10]</span>
        <span class="s1">res = stats.levene(*args)</span>
        <span class="s1">attributes = (</span><span class="s3">'statistic'</span><span class="s2">, </span><span class="s3">'pvalue'</span><span class="s1">)</span>
        <span class="s1">check_named_results(res</span><span class="s2">, </span><span class="s1">attributes)</span>

    <span class="s0"># temporary fix for issue #9252: only accept 1d input</span>
    <span class="s2">def </span><span class="s1">test_1d_input(self):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.levene</span><span class="s2">, </span><span class="s1">g1</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">class </span><span class="s1">TestBinomTestP:</span>
    <span class="s5">&quot;&quot;&quot; 
    Tests for stats.binomtest as a replacement for deprecated stats.binom_test. 
    &quot;&quot;&quot;</span>
    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">binom_test_func(x</span><span class="s2">, </span><span class="s1">n=</span><span class="s2">None, </span><span class="s1">p=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'two-sided'</span><span class="s1">):</span>
        <span class="s0"># This processing of x and n is copied from binom_test.</span>
        <span class="s1">x = np.atleast_1d(x).astype(np.int_)</span>
        <span class="s2">if </span><span class="s1">len(x) == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">n = x[</span><span class="s4">1</span><span class="s1">] + x[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">x = x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">len(x) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">x = x[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s2">is None or </span><span class="s1">n &lt; x:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;n must be &gt;= x&quot;</span><span class="s1">)</span>
            <span class="s1">n = np.int_(n)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Incorrect length for x.&quot;</span><span class="s1">)</span>

        <span class="s1">result = stats.binomtest(x</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p=p</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s2">return </span><span class="s1">result.pvalue</span>

    <span class="s2">def </span><span class="s1">test_data(self):</span>
        <span class="s1">pval = self.binom_test_func(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">250</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pval</span><span class="s2">, </span><span class="s4">0.0018833009350757682</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">pval = self.binom_test_func(</span><span class="s4">201</span><span class="s2">, </span><span class="s4">405</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pval</span><span class="s2">, </span><span class="s4">0.92085205962670713</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">pval = self.binom_test_func([</span><span class="s4">682</span><span class="s2">, </span><span class="s4">243</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">3</span><span class="s1">/</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pval</span><span class="s2">, </span><span class="s4">0.38249155957481695</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_len_x(self):</span>
        <span class="s0"># Length of x must be 1 or 2.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">self.binom_test_func</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_bad_n(self):</span>
        <span class="s0"># len(x) is 1, but n is invalid.</span>
        <span class="s0"># Missing n</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">self.binom_test_func</span><span class="s2">, </span><span class="s1">[</span><span class="s4">100</span><span class="s1">])</span>
        <span class="s0"># n less than x[0]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">self.binom_test_func</span><span class="s2">, </span><span class="s1">[</span><span class="s4">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">50</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_p(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                      <span class="s1">self.binom_test_func</span><span class="s2">, </span><span class="s1">[</span><span class="s4">50</span><span class="s2">, </span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">2.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_alternatives(self):</span>
        <span class="s1">res = self.binom_test_func(</span><span class="s4">51</span><span class="s2">, </span><span class="s4">235</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">1</span><span class="s1">/</span><span class="s4">6</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'less'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(res</span><span class="s2">, </span><span class="s4">0.982022657605858</span><span class="s1">)</span>

        <span class="s1">res = self.binom_test_func(</span><span class="s4">51</span><span class="s2">, </span><span class="s4">235</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">1</span><span class="s1">/</span><span class="s4">6</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'greater'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(res</span><span class="s2">, </span><span class="s4">0.02654424571169085</span><span class="s1">)</span>

        <span class="s1">res = self.binom_test_func(</span><span class="s4">51</span><span class="s2">, </span><span class="s4">235</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">1</span><span class="s1">/</span><span class="s4">6</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'two-sided'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(res</span><span class="s2">, </span><span class="s4">0.0437479701823997</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(sys.maxsize &lt;= </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;32-bit does not overflow&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_boost_overflow_raises(self):</span>
        <span class="s0"># Boost.Math error policy should raise exceptions in Python</span>
        <span class="s1">assert_raises(OverflowError</span><span class="s2">, </span><span class="s1">self.binom_test_func</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s1">p=sys.float_info.min)</span>


<span class="s2">class </span><span class="s1">TestBinomTest:</span>
    <span class="s5">&quot;&quot;&quot;Tests for stats.binomtest.&quot;&quot;&quot;</span>

    <span class="s0"># Expected results here are from R binom.test, e.g.</span>
    <span class="s0"># options(digits=16)</span>
    <span class="s0"># binom.test(484, 967, p=0.48)</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">test_two_sided_pvalues1(self):</span>
        <span class="s0"># `tol` could be stricter on most architectures, but the value</span>
        <span class="s0"># here is limited by accuracy of `binom.cdf` for large inputs on</span>
        <span class="s0"># Linux_Python_37_32bit_full and aarch64</span>
        <span class="s1">rtol = </span><span class="s4">1e-10  </span><span class="s0"># aarch64 observed rtol: 1.5e-11</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">10079999</span><span class="s2">, </span><span class="s4">21000000</span><span class="s2">, </span><span class="s4">0.48</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">10079990</span><span class="s2">, </span><span class="s4">21000000</span><span class="s2">, </span><span class="s4">0.48</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.9966892187965</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">10080009</span><span class="s2">, </span><span class="s4">21000000</span><span class="s2">, </span><span class="s4">0.48</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.9970377203856</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">10080017</span><span class="s2">, </span><span class="s4">21000000</span><span class="s2">, </span><span class="s4">0.48</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.9940754817328</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-9</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_two_sided_pvalues2(self):</span>
        <span class="s1">rtol = </span><span class="s4">1e-10  </span><span class="s0"># no aarch64 failure with 1e-15, preemptive bump</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">9</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">21</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.48</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.6689672431939</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">0.48</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.008139563452106</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">0.48</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.8278629664608</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">0.48</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.1966772901718</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.34375</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">.4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.16</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">.3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">0.5884</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s2">def </span><span class="s1">test_edge_cases(self):</span>
        <span class="s1">rtol = </span><span class="s4">1e-10  </span><span class="s0"># aarch64 observed rtol: 1.33e-15</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">484</span><span class="s2">, </span><span class="s4">967</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">3</span><span class="s1">/</span><span class="s4">47</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">13</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">13</span><span class="s1">/</span><span class="s4">46</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">15</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">15</span><span class="s1">/</span><span class="s4">44</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">6</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s2">def </span><span class="s1">test_binary_srch_for_binom_tst(self):</span>
        <span class="s0"># Test that old behavior of binomtest is maintained</span>
        <span class="s0"># by the new binary search method in cases where d</span>
        <span class="s0"># exactly equals the input on one side.</span>
        <span class="s1">n = </span><span class="s4">10</span>
        <span class="s1">p = </span><span class="s4">0.5</span>
        <span class="s1">k = </span><span class="s4">3</span>
        <span class="s0"># First test for the case where k &gt; mode of PMF</span>
        <span class="s1">i = np.arange(np.ceil(p * n)</span><span class="s2">, </span><span class="s1">n+</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">d = stats.binom.pmf(k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s0"># Old way of calculating y, probably consistent with R.</span>
        <span class="s1">y1 = np.sum(stats.binom.pmf(i</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p) &lt;= d</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0"># New way with binary search.</span>
        <span class="s1">ix = _binary_search_for_binom_tst(</span><span class="s2">lambda </span><span class="s1">x1:</span>
                                          <span class="s1">-stats.binom.pmf(x1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p)</span><span class="s2">,</span>
                                          <span class="s1">-d</span><span class="s2">, </span><span class="s1">np.ceil(p * n)</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">y2 = n - ix + int(d == stats.binom.pmf(ix</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p))</span>
        <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-9</span><span class="s1">)</span>
        <span class="s0"># Now test for the other side.</span>
        <span class="s1">k = </span><span class="s4">7</span>
        <span class="s1">i = np.arange(np.floor(p * n) + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">d = stats.binom.pmf(k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s0"># Old way of calculating y.</span>
        <span class="s1">y1 = np.sum(stats.binom.pmf(i</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p) &lt;= d</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0"># New way with binary search.</span>
        <span class="s1">ix = _binary_search_for_binom_tst(</span><span class="s2">lambda </span><span class="s1">x1:</span>
                                          <span class="s1">stats.binom.pmf(x1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p)</span><span class="s2">,</span>
                                          <span class="s1">d</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.floor(p * n))</span>
        <span class="s1">y2 = ix + </span><span class="s4">1</span>
        <span class="s1">assert_allclose(y1</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-9</span><span class="s1">)</span>

    <span class="s0"># Expected results here are from R 3.6.2 binom.test</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'alternative, pval, ci_low, ci_high'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s3">'less'</span><span class="s2">, </span><span class="s4">0.148831050443</span><span class="s2">,</span>
                               <span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.2772002496709138</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'greater'</span><span class="s2">, </span><span class="s4">0.9004695898947</span><span class="s2">,</span>
                               <span class="s4">0.1366613252458672</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'two-sided'</span><span class="s2">, </span><span class="s4">0.2983720970096</span><span class="s2">,</span>
                               <span class="s4">0.1266555521019559</span><span class="s2">, </span><span class="s4">0.2918426890886281</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_confidence_intervals1(self</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, </span><span class="s1">ci_low</span><span class="s2">, </span><span class="s1">ci_high):</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">20</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_equal(res.statistic</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">)</span>
        <span class="s1">ci = res.proportion_ci(confidence_level=</span><span class="s4">0.95</span><span class="s1">)</span>
        <span class="s1">assert_allclose((ci.low</span><span class="s2">, </span><span class="s1">ci.high)</span><span class="s2">, </span><span class="s1">(ci_low</span><span class="s2">, </span><span class="s1">ci_high)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s0"># Expected results here are from R 3.6.2 binom.test.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'alternative, pval, ci_low, ci_high'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s3">'less'</span><span class="s2">,</span>
                               <span class="s4">0.005656361</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.1872093</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'greater'</span><span class="s2">,</span>
                               <span class="s4">0.9987146</span><span class="s2">, </span><span class="s4">0.008860761</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'two-sided'</span><span class="s2">,</span>
                               <span class="s4">0.01191714</span><span class="s2">, </span><span class="s4">0.006872485</span><span class="s2">, </span><span class="s4">0.202706269</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_confidence_intervals2(self</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, </span><span class="s1">ci_low</span><span class="s2">, </span><span class="s1">ci_high):</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_equal(res.statistic</span><span class="s2">, </span><span class="s4">0.06</span><span class="s1">)</span>
        <span class="s1">ci = res.proportion_ci(confidence_level=</span><span class="s4">0.99</span><span class="s1">)</span>
        <span class="s1">assert_allclose((ci.low</span><span class="s2">, </span><span class="s1">ci.high)</span><span class="s2">, </span><span class="s1">(ci_low</span><span class="s2">, </span><span class="s1">ci_high)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s0"># Expected results here are from R 3.6.2 binom.test.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'alternative, pval, ci_high'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s3">'less'</span><span class="s2">, </span><span class="s4">0.05631351</span><span class="s2">, </span><span class="s4">0.2588656</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'greater'</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'two-sided'</span><span class="s2">, </span><span class="s4">0.07604122</span><span class="s2">, </span><span class="s4">0.3084971</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_confidence_interval_exact_k0(self</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, </span><span class="s1">ci_high):</span>
        <span class="s0"># Test with k=0, n = 10.</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">ci = res.proportion_ci(confidence_level=</span><span class="s4">0.95</span><span class="s1">)</span>
        <span class="s1">assert_equal(ci.low</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ci.high</span><span class="s2">, </span><span class="s1">ci_high</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s0"># Expected results here are from R 3.6.2 binom.test.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'alternative, pval, ci_low'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s3">'less'</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'greater'</span><span class="s2">, </span><span class="s4">9.536743e-07</span><span class="s2">, </span><span class="s4">0.7411344</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'two-sided'</span><span class="s2">, </span><span class="s4">9.536743e-07</span><span class="s2">, </span><span class="s4">0.6915029</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_confidence_interval_exact_k_is_n(self</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, </span><span class="s1">ci_low):</span>
        <span class="s0"># Test with k = n = 10.</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s1">assert_allclose(res.pvalue</span><span class="s2">, </span><span class="s1">pval</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">ci = res.proportion_ci(confidence_level=</span><span class="s4">0.95</span><span class="s1">)</span>
        <span class="s1">assert_equal(ci.high</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ci.low</span><span class="s2">, </span><span class="s1">ci_low</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s0"># Expected results are from the prop.test function in R 3.6.2.</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">'k, alternative, corr, conf, ci_low, ci_high'</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'two-sided'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.08094782</span><span class="s2">, </span><span class="s4">0.64632928</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'two-sided'</span><span class="s2">, True, </span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">0.0586329</span><span class="s2">, </span><span class="s4">0.7169416</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'two-sided'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.1077913</span><span class="s2">, </span><span class="s4">0.6032219</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'two-sided'</span><span class="s2">, False, </span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">0.07956632</span><span class="s2">, </span><span class="s4">0.6799753</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.6043476</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, True, </span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.6901811</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.5583002</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, False, </span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.6507187</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.09644904</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, True, </span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">0.06659141</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.1268766</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, False, </span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">0.08974147</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>

         <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">'two-sided'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.3445372</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">'two-sided'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.2775328</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.2847374</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.212942</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>

         <span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s3">'two-sided'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.6554628</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s3">'two-sided'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.7224672</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, True, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.7152626</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
         <span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">, False, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0.787058</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_ci_wilson_method(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">corr</span><span class="s2">, </span><span class="s1">conf</span><span class="s2">,</span>
                              <span class="s1">ci_low</span><span class="s2">, </span><span class="s1">ci_high):</span>
        <span class="s1">res = stats.binomtest(k</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s2">if </span><span class="s1">corr:</span>
            <span class="s1">method = </span><span class="s3">'wilsoncc'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">method = </span><span class="s3">'wilson'</span>
        <span class="s1">ci = res.proportion_ci(confidence_level=conf</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">assert_allclose((ci.low</span><span class="s2">, </span><span class="s1">ci.high)</span><span class="s2">, </span><span class="s1">(ci_low</span><span class="s2">, </span><span class="s1">ci_high)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_estimate_equals_hypothesized_prop(self):</span>
        <span class="s0"># Test the special case where the estimated proportion equals</span>
        <span class="s0"># the hypothesized proportion.  When alternative is 'two-sided',</span>
        <span class="s0"># the p-value is 1.</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">assert_equal(res.statistic</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">assert_equal(res.pvalue</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'k, n'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_invalid_k_n(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;must be an integer not less than&quot;</span><span class="s1">):</span>
            <span class="s1">stats.binomtest(k</span><span class="s2">, </span><span class="s1">n)</span>

    <span class="s2">def </span><span class="s1">test_invalid_k_too_big(self):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;k must not be greater than n&quot;</span><span class="s1">):</span>
            <span class="s1">stats.binomtest(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_invalid_confidence_level(self):</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;must be in the interval&quot;</span><span class="s1">):</span>
            <span class="s1">res.proportion_ci(confidence_level=-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_invalid_ci_method(self):</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;method must be&quot;</span><span class="s1">):</span>
            <span class="s1">res.proportion_ci(method=</span><span class="s3">&quot;plate of shrimp&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_alias(self):</span>
        <span class="s1">res = stats.binomtest(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_equal(res.proportion_estimate</span><span class="s2">, </span><span class="s1">res.statistic)</span>


<span class="s2">class </span><span class="s1">TestFligner:</span>

    <span class="s2">def </span><span class="s1">test_data(self):</span>
        <span class="s0"># numbers from R: fligner.test in package stats</span>
        <span class="s1">x1 = np.arange(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(stats.fligner(x1</span><span class="s2">, </span><span class="s1">x1**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">(</span><span class="s4">3.2282229927203536</span><span class="s2">, </span><span class="s4">0.072379187848207877</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s4">11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_trimmed1(self):</span>
        <span class="s0"># Perturb input to break ties in the transformed data</span>
        <span class="s0"># See https://github.com/scipy/scipy/pull/8042 for more details</span>
        <span class="s1">rs = np.random.RandomState(</span><span class="s4">123</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">_perturb(g):</span>
            <span class="s2">return </span><span class="s1">(np.asarray(g) + </span><span class="s4">1e-10 </span><span class="s1">* rs.randn(len(g))).tolist()</span>

        <span class="s1">g1_ = _perturb(g1)</span>
        <span class="s1">g2_ = _perturb(g2)</span>
        <span class="s1">g3_ = _perturb(g3)</span>
        <span class="s0"># Test that center='trimmed' gives the same result as center='mean'</span>
        <span class="s0"># when proportiontocut=0.</span>
        <span class="s1">Xsq1</span><span class="s2">, </span><span class="s1">pval1 = stats.fligner(g1_</span><span class="s2">, </span><span class="s1">g2_</span><span class="s2">, </span><span class="s1">g3_</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'mean'</span><span class="s1">)</span>
        <span class="s1">Xsq2</span><span class="s2">, </span><span class="s1">pval2 = stats.fligner(g1_</span><span class="s2">, </span><span class="s1">g2_</span><span class="s2">, </span><span class="s1">g3_</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'trimmed'</span><span class="s2">,</span>
                                    <span class="s1">proportiontocut=</span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(Xsq1</span><span class="s2">, </span><span class="s1">Xsq2)</span>
        <span class="s1">assert_almost_equal(pval1</span><span class="s2">, </span><span class="s1">pval2)</span>

    <span class="s2">def </span><span class="s1">test_trimmed2(self):</span>
        <span class="s1">x = [</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">6.0</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">100.0</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">4.5</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.5</span><span class="s2">, </span><span class="s4">200.0</span><span class="s1">]</span>
        <span class="s0"># Use center='trimmed'</span>
        <span class="s1">Xsq1</span><span class="s2">, </span><span class="s1">pval1 = stats.fligner(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'trimmed'</span><span class="s2">,</span>
                                    <span class="s1">proportiontocut=</span><span class="s4">0.125</span><span class="s1">)</span>
        <span class="s0"># Trim the data here, and use center='mean'</span>
        <span class="s1">Xsq2</span><span class="s2">, </span><span class="s1">pval2 = stats.fligner(x[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'mean'</span><span class="s1">)</span>
        <span class="s0"># Result should be the same.</span>
        <span class="s1">assert_almost_equal(Xsq1</span><span class="s2">, </span><span class="s1">Xsq2)</span>
        <span class="s1">assert_almost_equal(pval1</span><span class="s2">, </span><span class="s1">pval2)</span>

    <span class="s0"># The following test looks reasonable at first, but fligner() uses the</span>
    <span class="s0"># function stats.rankdata(), and in one of the cases in this test,</span>
    <span class="s0"># there are ties, while in the other (because of normal rounding</span>
    <span class="s0"># errors) there are not.  This difference leads to differences in the</span>
    <span class="s0"># third significant digit of W.</span>
    <span class="s0">#</span>
    <span class="s0">#def test_equal_mean_median(self):</span>
    <span class="s0">#    x = np.linspace(-1,1,21)</span>
    <span class="s0">#    y = x**3</span>
    <span class="s0">#    W1, pval1 = stats.fligner(x, y, center='mean')</span>
    <span class="s0">#    W2, pval2 = stats.fligner(x, y, center='median')</span>
    <span class="s0">#    assert_almost_equal(W1, W2)</span>
    <span class="s0">#    assert_almost_equal(pval1, pval2)</span>

    <span class="s2">def </span><span class="s1">test_bad_keyword(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.fligner</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">portiontocut=</span><span class="s4">0.1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_center_value(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.fligner</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">center=</span><span class="s3">'trim'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_num_args(self):</span>
        <span class="s0"># Too few args raises ValueError.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.fligner</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_empty_arg(self):</span>
        <span class="s1">x = np.arange(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_equal((np.nan</span><span class="s2">, </span><span class="s1">np.nan)</span><span class="s2">, </span><span class="s1">stats.fligner(x</span><span class="s2">, </span><span class="s1">x**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[]))</span>


<span class="s2">def </span><span class="s1">mood_cases_with_ties():</span>
    <span class="s0"># Generate random `x` and `y` arrays with ties both between and within the</span>
    <span class="s0"># samples. Expected results are (statistic, pvalue) from SAS.</span>
    <span class="s1">expected_results = [(-</span><span class="s4">1.76658511464992</span><span class="s2">, </span><span class="s4">.0386488678399305</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(-</span><span class="s4">.694031428192304</span><span class="s2">, </span><span class="s4">.2438312498647250</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(-</span><span class="s4">1.15093525352151</span><span class="s2">, </span><span class="s4">.1248794365836150</span><span class="s1">)]</span>
    <span class="s1">seeds = [</span><span class="s4">23453254</span><span class="s2">, </span><span class="s4">1298352315</span><span class="s2">, </span><span class="s4">987234597</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">si</span><span class="s2">, </span><span class="s1">seed </span><span class="s2">in </span><span class="s1">enumerate(seeds):</span>
        <span class="s1">rng = np.random.default_rng(seed)</span>
        <span class="s1">xy = rng.random(</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s0"># Generate random indices to make ties</span>
        <span class="s1">tie_ind = rng.integers(low=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">99</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s0"># Generate a random number of ties for each index.</span>
        <span class="s1">num_ties_per_ind = rng.integers(low=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s0"># At each `tie_ind`, mark the next `n` indices equal to that value.</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">n </span><span class="s2">in </span><span class="s1">zip(tie_ind</span><span class="s2">, </span><span class="s1">num_ties_per_ind):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(i + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">i + n):</span>
                <span class="s1">xy[j] = xy[i]</span>
        <span class="s0"># scramble order of xy before splitting into `x, y`</span>
        <span class="s1">rng.shuffle(xy)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = np.split(xy</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s2">yield </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, </span><span class="s1">*expected_results[si]</span>


<span class="s2">class </span><span class="s1">TestMood:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;x,y,alternative,stat_expect,p_expect&quot;</span><span class="s2">,</span>
                             <span class="s1">mood_cases_with_ties())</span>
    <span class="s2">def </span><span class="s1">test_against_SAS(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">stat_expect</span><span class="s2">, </span><span class="s1">p_expect):</span>
        <span class="s5">&quot;&quot;&quot; 
        Example code used to generate SAS output: 
        DATA myData; 
        INPUT X Y; 
        CARDS; 
        1 0 
        1 1 
        1 2 
        1 3 
        1 4 
        2 0 
        2 1 
        2 4 
        2 9 
        2 16 
        ods graphics on; 
        proc npar1way mood data=myData ; 
           class X; 
            ods output  MoodTest=mt; 
        proc contents data=mt; 
        proc print data=mt; 
          format     Prob1 17.16 Prob2 17.16 Statistic 17.16 Z 17.16 ; 
            title &quot;Mood Two-Sample Test&quot;; 
        proc print data=myData; 
            title &quot;Data for above results&quot;; 
          run; 
        &quot;&quot;&quot;</span>
        <span class="s1">statistic</span><span class="s2">, </span><span class="s1">pvalue = stats.mood(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s1">assert_allclose(stat_expect</span><span class="s2">, </span><span class="s1">statistic</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-16</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p_expect</span><span class="s2">, </span><span class="s1">pvalue</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-16</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;alternative, expected&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s3">'two-sided'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.019938533549930</span><span class="s2">,</span>
                                             <span class="s4">.3077576129778760</span><span class="s1">))</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'less'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.019938533549930</span><span class="s2">,</span>
                                        <span class="s4">1 </span><span class="s1">- </span><span class="s4">.1538788064889380</span><span class="s1">))</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s3">'greater'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.019938533549930</span><span class="s2">,</span>
                                           <span class="s4">.1538788064889380</span><span class="s1">))])</span>
    <span class="s2">def </span><span class="s1">test_against_SAS_2(self</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s0"># Code to run in SAS in above function</span>
        <span class="s1">x = [</span><span class="s4">111</span><span class="s2">, </span><span class="s4">107</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">99</span><span class="s2">, </span><span class="s4">102</span><span class="s2">, </span><span class="s4">106</span><span class="s2">, </span><span class="s4">109</span><span class="s2">, </span><span class="s4">108</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">99</span><span class="s2">,</span>
             <span class="s4">101</span><span class="s2">, </span><span class="s4">96</span><span class="s2">, </span><span class="s4">97</span><span class="s2">, </span><span class="s4">102</span><span class="s2">, </span><span class="s4">107</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">116</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">110</span><span class="s2">, </span><span class="s4">98</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">107</span><span class="s2">, </span><span class="s4">108</span><span class="s2">, </span><span class="s4">106</span><span class="s2">, </span><span class="s4">98</span><span class="s2">, </span><span class="s4">105</span><span class="s2">, </span><span class="s4">103</span><span class="s2">, </span><span class="s4">110</span><span class="s2">, </span><span class="s4">105</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">100</span><span class="s2">,</span>
             <span class="s4">96</span><span class="s2">, </span><span class="s4">108</span><span class="s2">, </span><span class="s4">103</span><span class="s2">, </span><span class="s4">104</span><span class="s2">, </span><span class="s4">114</span><span class="s2">, </span><span class="s4">114</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">108</span><span class="s2">, </span><span class="s4">106</span><span class="s2">, </span><span class="s4">99</span><span class="s1">]</span>
        <span class="s1">res = stats.mood(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_mood_order_of_args(self):</span>
        <span class="s0"># z should change sign when the order of arguments changes, pvalue</span>
        <span class="s0"># should not change</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x1 = np.random.randn(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">x2 = np.random.randn(</span><span class="s4">15</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">z1</span><span class="s2">, </span><span class="s1">p1 = stats.mood(x1</span><span class="s2">, </span><span class="s1">x2)</span>
        <span class="s1">z2</span><span class="s2">, </span><span class="s1">p2 = stats.mood(x2</span><span class="s2">, </span><span class="s1">x1)</span>
        <span class="s1">assert_array_almost_equal([z1</span><span class="s2">, </span><span class="s1">p1]</span><span class="s2">, </span><span class="s1">[-z2</span><span class="s2">, </span><span class="s1">p2])</span>

    <span class="s2">def </span><span class="s1">test_mood_with_axis_none(self):</span>
        <span class="s0"># Test with axis = None, compare with results from R</span>
        <span class="s1">x1 = [-</span><span class="s4">0.626453810742332</span><span class="s2">, </span><span class="s4">0.183643324222082</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.835628612410047</span><span class="s2">,</span>
              <span class="s4">1.59528080213779</span><span class="s2">, </span><span class="s4">0.329507771815361</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.820468384118015</span><span class="s2">,</span>
              <span class="s4">0.487429052428485</span><span class="s2">, </span><span class="s4">0.738324705129217</span><span class="s2">, </span><span class="s4">0.575781351653492</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">0.305388387156356</span><span class="s2">, </span><span class="s4">1.51178116845085</span><span class="s2">, </span><span class="s4">0.389843236411431</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">0.621240580541804</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.2146998871775</span><span class="s2">, </span><span class="s4">1.12493091814311</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">0.0449336090152309</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0161902630989461</span><span class="s2">, </span><span class="s4">0.943836210685299</span><span class="s2">,</span>
              <span class="s4">0.821221195098089</span><span class="s2">, </span><span class="s4">0.593901321217509</span><span class="s1">]</span>

        <span class="s1">x2 = [-</span><span class="s4">0.896914546624981</span><span class="s2">, </span><span class="s4">0.184849184646742</span><span class="s2">, </span><span class="s4">1.58784533120882</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">1.13037567424629</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0802517565509893</span><span class="s2">, </span><span class="s4">0.132420284381094</span><span class="s2">,</span>
              <span class="s4">0.707954729271733</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.23969802417184</span><span class="s2">, </span><span class="s4">1.98447393665293</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">0.138787012119665</span><span class="s2">, </span><span class="s4">0.417650750792556</span><span class="s2">, </span><span class="s4">0.981752777463662</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">0.392695355503813</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.03966897694891</span><span class="s2">, </span><span class="s4">1.78222896030858</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">2.31106908460517</span><span class="s2">, </span><span class="s4">0.878604580921265</span><span class="s2">, </span><span class="s4">0.035806718015226</span><span class="s2">,</span>
              <span class="s4">1.01282869212708</span><span class="s2">, </span><span class="s4">0.432265154539617</span><span class="s2">, </span><span class="s4">2.09081920524915</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">1.19992581964387</span><span class="s2">, </span><span class="s4">1.58963820029007</span><span class="s2">, </span><span class="s4">1.95465164222325</span><span class="s2">,</span>
              <span class="s4">0.00493777682814261</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.45170638784613</span><span class="s2">, </span><span class="s4">0.477237302613617</span><span class="s2">,</span>
              <span class="s1">-</span><span class="s4">0.596558168631403</span><span class="s2">, </span><span class="s4">0.792203270299649</span><span class="s2">, </span><span class="s4">0.289636710177348</span><span class="s1">]</span>

        <span class="s1">x1 = np.array(x1)</span>
        <span class="s1">x2 = np.array(x2)</span>
        <span class="s1">x1.shape = (</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">x2.shape = (</span><span class="s4">15</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(stats.mood(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">[-</span><span class="s4">1.31716607555</span><span class="s2">, </span><span class="s4">0.18778296257</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_mood_2d(self):</span>
        <span class="s0"># Test if the results of mood test in 2-D case are consistent with the</span>
        <span class="s0"># R result for the same inputs.  Numbers from R mood.test().</span>
        <span class="s1">ny = </span><span class="s4">5</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x1 = np.random.randn(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">ny)</span>
        <span class="s1">x2 = np.random.randn(</span><span class="s4">15</span><span class="s2">, </span><span class="s1">ny)</span>
        <span class="s1">z_vectest</span><span class="s2">, </span><span class="s1">pval_vectest = stats.mood(x1</span><span class="s2">, </span><span class="s1">x2)</span>

        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(ny):</span>
            <span class="s1">assert_array_almost_equal([z_vectest[j]</span><span class="s2">, </span><span class="s1">pval_vectest[j]]</span><span class="s2">,</span>
                                      <span class="s1">stats.mood(x1[:</span><span class="s2">, </span><span class="s1">j]</span><span class="s2">, </span><span class="s1">x2[:</span><span class="s2">, </span><span class="s1">j]))</span>

        <span class="s0"># inverse order of dimensions</span>
        <span class="s1">x1 = x1.transpose()</span>
        <span class="s1">x2 = x2.transpose()</span>
        <span class="s1">z_vectest</span><span class="s2">, </span><span class="s1">pval_vectest = stats.mood(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(ny):</span>
            <span class="s0"># check axis handling is self consistent</span>
            <span class="s1">assert_array_almost_equal([z_vectest[i]</span><span class="s2">, </span><span class="s1">pval_vectest[i]]</span><span class="s2">,</span>
                                      <span class="s1">stats.mood(x1[i</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">x2[i</span><span class="s2">, </span><span class="s1">:]))</span>

    <span class="s2">def </span><span class="s1">test_mood_3d(self):</span>
        <span class="s1">shape = (</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x1 = np.random.randn(*shape)</span>
        <span class="s1">x2 = np.random.randn(*shape)</span>

        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">z_vectest</span><span class="s2">, </span><span class="s1">pval_vectest = stats.mood(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">axis=axis)</span>
            <span class="s0"># Tests that result for 3-D arrays is equal to that for the</span>
            <span class="s0"># same calculation on a set of 1-D arrays taken from the</span>
            <span class="s0"># 3-D array</span>
            <span class="s1">axes_idx = ([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])  </span><span class="s0"># the two axes != axis</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(shape[axes_idx[axis][</span><span class="s4">0</span><span class="s1">]]):</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(shape[axes_idx[axis][</span><span class="s4">1</span><span class="s1">]]):</span>
                    <span class="s2">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s1">slice1 = x1[:</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j]</span>
                        <span class="s1">slice2 = x2[:</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j]</span>
                    <span class="s2">elif </span><span class="s1">axis == </span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s1">slice1 = x1[i</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">j]</span>
                        <span class="s1">slice2 = x2[i</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">j]</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">slice1 = x1[i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:]</span>
                        <span class="s1">slice2 = x2[i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:]</span>

                    <span class="s1">assert_array_almost_equal([z_vectest[i</span><span class="s2">, </span><span class="s1">j]</span><span class="s2">,</span>
                                               <span class="s1">pval_vectest[i</span><span class="s2">, </span><span class="s1">j]]</span><span class="s2">,</span>
                                              <span class="s1">stats.mood(slice1</span><span class="s2">, </span><span class="s1">slice2))</span>

    <span class="s2">def </span><span class="s1">test_mood_bad_arg(self):</span>
        <span class="s0"># Raise ValueError when the sum of the lengths of the args is</span>
        <span class="s0"># less than 3</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.mood</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[])</span>

    <span class="s2">def </span><span class="s1">test_mood_alternative(self):</span>

        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">x = stats.norm.rvs(scale=</span><span class="s4">0.75</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">y = stats.norm.rvs(scale=</span><span class="s4">1.25</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s1">stat1</span><span class="s2">, </span><span class="s1">p1 = stats.mood(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'two-sided'</span><span class="s1">)</span>
        <span class="s1">stat2</span><span class="s2">, </span><span class="s1">p2 = stats.mood(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'less'</span><span class="s1">)</span>
        <span class="s1">stat3</span><span class="s2">, </span><span class="s1">p3 = stats.mood(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'greater'</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">stat1 == stat2 == stat3</span>
        <span class="s1">assert_allclose(p1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p2</span><span class="s2">, </span><span class="s1">p1/</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p3</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- p1/</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;alternative must be...&quot;</span><span class="s1">):</span>
            <span class="s1">stats.mood(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'ekki-ekki'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;alternative&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'two-sided'</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_result(self</span><span class="s2">, </span><span class="s1">alternative):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">265827767938813079281100964083953437622</span><span class="s1">)</span>
        <span class="s1">x1 = rng.standard_normal((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">x2 = rng.standard_normal((</span><span class="s4">15</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s1">res = stats.mood(x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">alternative=alternative)</span>
        <span class="s1">assert_equal((res.statistic</span><span class="s2">, </span><span class="s1">res.pvalue)</span><span class="s2">, </span><span class="s1">res)</span>


<span class="s2">class </span><span class="s1">TestProbplot:</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">12345</span><span class="s1">)</span>
        <span class="s1">osm</span><span class="s2">, </span><span class="s1">osr = stats.probplot(x</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">osm_expected = [-</span><span class="s4">1.8241636</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.38768012</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.11829229</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.91222575</span><span class="s2">,</span>
                        <span class="s1">-</span><span class="s4">0.73908135</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5857176</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.44506467</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.31273668</span><span class="s2">,</span>
                        <span class="s1">-</span><span class="s4">0.18568928</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.06158146</span><span class="s2">, </span><span class="s4">0.06158146</span><span class="s2">, </span><span class="s4">0.18568928</span><span class="s2">,</span>
                        <span class="s4">0.31273668</span><span class="s2">, </span><span class="s4">0.44506467</span><span class="s2">, </span><span class="s4">0.5857176</span><span class="s2">, </span><span class="s4">0.73908135</span><span class="s2">,</span>
                        <span class="s4">0.91222575</span><span class="s2">, </span><span class="s4">1.11829229</span><span class="s2">, </span><span class="s4">1.38768012</span><span class="s2">, </span><span class="s4">1.8241636</span><span class="s1">]</span>
        <span class="s1">assert_allclose(osr</span><span class="s2">, </span><span class="s1">np.sort(x))</span>
        <span class="s1">assert_allclose(osm</span><span class="s2">, </span><span class="s1">osm_expected)</span>

        <span class="s1">res</span><span class="s2">, </span><span class="s1">res_fit = stats.probplot(x</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">res_fit_expected = [</span><span class="s4">1.05361841</span><span class="s2">, </span><span class="s4">0.31297795</span><span class="s2">, </span><span class="s4">0.98741609</span><span class="s1">]</span>
        <span class="s1">assert_allclose(res_fit</span><span class="s2">, </span><span class="s1">res_fit_expected)</span>

    <span class="s2">def </span><span class="s1">test_sparams_keyword(self):</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">123456</span><span class="s1">)</span>
        <span class="s0"># Check that None, () and 0 (loc=0, for normal distribution) all work</span>
        <span class="s0"># and give the same results</span>
        <span class="s1">osm1</span><span class="s2">, </span><span class="s1">osr1 = stats.probplot(x</span><span class="s2">, </span><span class="s1">sparams=</span><span class="s2">None, </span><span class="s1">fit=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">osm2</span><span class="s2">, </span><span class="s1">osr2 = stats.probplot(x</span><span class="s2">, </span><span class="s1">sparams=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">osm3</span><span class="s2">, </span><span class="s1">osr3 = stats.probplot(x</span><span class="s2">, </span><span class="s1">sparams=()</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(osm1</span><span class="s2">, </span><span class="s1">osm2)</span>
        <span class="s1">assert_allclose(osm1</span><span class="s2">, </span><span class="s1">osm3)</span>
        <span class="s1">assert_allclose(osr1</span><span class="s2">, </span><span class="s1">osr2)</span>
        <span class="s1">assert_allclose(osr1</span><span class="s2">, </span><span class="s1">osr3)</span>
        <span class="s0"># Check giving (loc, scale) params for normal distribution</span>
        <span class="s1">osm</span><span class="s2">, </span><span class="s1">osr = stats.probplot(x</span><span class="s2">, </span><span class="s1">sparams=()</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dist_keyword(self):</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">12345</span><span class="s1">)</span>
        <span class="s1">osm1</span><span class="s2">, </span><span class="s1">osr1 = stats.probplot(x</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False, </span><span class="s1">dist=</span><span class="s3">'t'</span><span class="s2">, </span><span class="s1">sparams=(</span><span class="s4">3</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">osm2</span><span class="s2">, </span><span class="s1">osr2 = stats.probplot(x</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False, </span><span class="s1">dist=stats.t</span><span class="s2">, </span><span class="s1">sparams=(</span><span class="s4">3</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_allclose(osm1</span><span class="s2">, </span><span class="s1">osm2)</span>
        <span class="s1">assert_allclose(osr1</span><span class="s2">, </span><span class="s1">osr2)</span>

        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.probplot</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dist=</span><span class="s3">'wrong-dist-name'</span><span class="s1">)</span>
        <span class="s1">assert_raises(AttributeError</span><span class="s2">, </span><span class="s1">stats.probplot</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dist=[])</span>

        <span class="s2">class </span><span class="s1">custom_dist:</span>
            <span class="s5">&quot;&quot;&quot;Some class that looks just enough like a distribution.&quot;&quot;&quot;</span>
            <span class="s2">def </span><span class="s1">ppf(self</span><span class="s2">, </span><span class="s1">q):</span>
                <span class="s2">return </span><span class="s1">stats.norm.ppf(q</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">osm1</span><span class="s2">, </span><span class="s1">osr1 = stats.probplot(x</span><span class="s2">, </span><span class="s1">sparams=(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">osm2</span><span class="s2">, </span><span class="s1">osr2 = stats.probplot(x</span><span class="s2">, </span><span class="s1">dist=custom_dist()</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(osm1</span><span class="s2">, </span><span class="s1">osm2)</span>
        <span class="s1">assert_allclose(osr1</span><span class="s2">, </span><span class="s1">osr2)</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s2">not </span><span class="s1">have_matplotlib</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;no matplotlib&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_plot_kwarg(self):</span>
        <span class="s1">fig = plt.figure()</span>
        <span class="s1">fig.add_subplot(</span><span class="s4">111</span><span class="s1">)</span>
        <span class="s1">x = stats.t.rvs(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">7654321</span><span class="s1">)</span>
        <span class="s1">res1</span><span class="s2">, </span><span class="s1">fitres1 = stats.probplot(x</span><span class="s2">, </span><span class="s1">plot=plt)</span>
        <span class="s1">plt.close()</span>
        <span class="s1">res2</span><span class="s2">, </span><span class="s1">fitres2 = stats.probplot(x</span><span class="s2">, </span><span class="s1">plot=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">res3 = stats.probplot(x</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False, </span><span class="s1">plot=plt)</span>
        <span class="s1">plt.close()</span>
        <span class="s1">res4 = stats.probplot(x</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False, </span><span class="s1">plot=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s0"># Check that results are consistent between combinations of `fit` and</span>
        <span class="s0"># `plot` keywords.</span>
        <span class="s1">assert_(len(res1) == len(res2) == len(res3) == len(res4) == </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1</span><span class="s2">, </span><span class="s1">res2)</span>
        <span class="s1">assert_allclose(res1</span><span class="s2">, </span><span class="s1">res3)</span>
        <span class="s1">assert_allclose(res1</span><span class="s2">, </span><span class="s1">res4)</span>
        <span class="s1">assert_allclose(fitres1</span><span class="s2">, </span><span class="s1">fitres2)</span>

        <span class="s0"># Check that a Matplotlib Axes object is accepted</span>
        <span class="s1">fig = plt.figure()</span>
        <span class="s1">ax = fig.add_subplot(</span><span class="s4">111</span><span class="s1">)</span>
        <span class="s1">stats.probplot(x</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False, </span><span class="s1">plot=ax)</span>
        <span class="s1">plt.close()</span>

    <span class="s2">def </span><span class="s1">test_probplot_bad_args(self):</span>
        <span class="s0"># Raise ValueError when given an invalid distribution.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.probplot</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dist=</span><span class="s3">&quot;plate_of_shrimp&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty(self):</span>
        <span class="s1">assert_equal(stats.probplot([]</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">(np.array([])</span><span class="s2">, </span><span class="s1">np.array([])))</span>
        <span class="s1">assert_equal(stats.probplot([]</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">((np.array([])</span><span class="s2">, </span><span class="s1">np.array([]))</span><span class="s2">,</span>
                      <span class="s1">(np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">test_array_of_size_one(self):</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_equal(stats.probplot([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fit=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">((np.array([</span><span class="s4">0.</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">1</span><span class="s1">]))</span><span class="s2">,</span>
                          <span class="s1">(np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)))</span>


<span class="s2">class </span><span class="s1">TestWilcoxon:</span>
    <span class="s2">def </span><span class="s1">test_wilcoxon_bad_arg(self):</span>
        <span class="s0"># Raise ValueError when two args of different lengths are given or</span>
        <span class="s0"># zero_method is unknown.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.wilcoxon</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.wilcoxon</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;dummy&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.wilcoxon</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">alternative=</span><span class="s3">&quot;dummy&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.wilcoxon</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]*</span><span class="s4">10</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;xyz&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_zero_diff(self):</span>
        <span class="s1">x = np.arange(</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s0"># pratt and wilcox do not work if x - y == 0</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.wilcoxon</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s3">&quot;wilcox&quot;</span><span class="s2">,</span>
                      <span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.wilcoxon</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s3">&quot;pratt&quot;</span><span class="s2">,</span>
                      <span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s0"># ranksum is n*(n+1)/2, split in half if zero_method == &quot;zsplit&quot;</span>
        <span class="s1">assert_equal(stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s3">&quot;zsplit&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">(</span><span class="s4">20</span><span class="s1">*</span><span class="s4">21</span><span class="s1">/</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_pratt(self):</span>
        <span class="s0"># regression test for gh-6805: p-value matches value from R package</span>
        <span class="s0"># coin (wilcoxsign_test) reported in the issue</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;Sample size too small&quot;</span><span class="s1">)</span>
            <span class="s1">res = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">zero_method=</span><span class="s3">&quot;pratt&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.31731050786291415</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_wilcoxon_arg_type(self):</span>
        <span class="s0"># Should be able to accept list as arguments.</span>
        <span class="s0"># Address issue 6070.</span>
        <span class="s1">arr = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">_ = stats.wilcoxon(arr</span><span class="s2">, </span><span class="s1">zero_method=</span><span class="s3">&quot;pratt&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">_ = stats.wilcoxon(arr</span><span class="s2">, </span><span class="s1">zero_method=</span><span class="s3">&quot;zsplit&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">_ = stats.wilcoxon(arr</span><span class="s2">, </span><span class="s1">zero_method=</span><span class="s3">&quot;wilcox&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_accuracy_wilcoxon(self):</span>
        <span class="s1">freq = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">nums = range(-</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">x = np.concatenate([[u] * v </span><span class="s2">for </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip(nums</span><span class="s2">, </span><span class="s1">freq)])</span>
        <span class="s1">y = np.zeros(x.size)</span>

        <span class="s1">T</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">&quot;pratt&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(T</span><span class="s2">, </span><span class="s4">423</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.0031724568006762576</span><span class="s1">)</span>

        <span class="s1">T</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">&quot;zsplit&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(T</span><span class="s2">, </span><span class="s4">441</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.0032145343172473055</span><span class="s1">)</span>

        <span class="s1">T</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">&quot;wilcox&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(T</span><span class="s2">, </span><span class="s4">327</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.00641346115861</span><span class="s1">)</span>

        <span class="s0"># Test the 'correction' option, using values computed in R with:</span>
        <span class="s0"># &gt; wilcox.test(x, y, paired=TRUE, exact=FALSE, correct={FALSE,TRUE})</span>
        <span class="s1">x = np.array([</span><span class="s4">120</span><span class="s2">, </span><span class="s4">114</span><span class="s2">, </span><span class="s4">181</span><span class="s2">, </span><span class="s4">188</span><span class="s2">, </span><span class="s4">180</span><span class="s2">, </span><span class="s4">146</span><span class="s2">, </span><span class="s4">121</span><span class="s2">, </span><span class="s4">191</span><span class="s2">, </span><span class="s4">132</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">127</span><span class="s2">, </span><span class="s4">112</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s4">133</span><span class="s2">, </span><span class="s4">143</span><span class="s2">, </span><span class="s4">119</span><span class="s2">, </span><span class="s4">189</span><span class="s2">, </span><span class="s4">112</span><span class="s2">, </span><span class="s4">199</span><span class="s2">, </span><span class="s4">198</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">115</span><span class="s2">, </span><span class="s4">121</span><span class="s2">, </span><span class="s4">142</span><span class="s2">, </span><span class="s4">187</span><span class="s1">])</span>
        <span class="s1">T</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">correction=</span><span class="s2">False, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(T</span><span class="s2">, </span><span class="s4">34</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.6948866</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">T</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">correction=</span><span class="s2">True, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(T</span><span class="s2">, </span><span class="s4">34</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.7240817</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_wilcoxon_result_attributes(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">120</span><span class="s2">, </span><span class="s4">114</span><span class="s2">, </span><span class="s4">181</span><span class="s2">, </span><span class="s4">188</span><span class="s2">, </span><span class="s4">180</span><span class="s2">, </span><span class="s4">146</span><span class="s2">, </span><span class="s4">121</span><span class="s2">, </span><span class="s4">191</span><span class="s2">, </span><span class="s4">132</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">127</span><span class="s2">, </span><span class="s4">112</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s4">133</span><span class="s2">, </span><span class="s4">143</span><span class="s2">, </span><span class="s4">119</span><span class="s2">, </span><span class="s4">189</span><span class="s2">, </span><span class="s4">112</span><span class="s2">, </span><span class="s4">199</span><span class="s2">, </span><span class="s4">198</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">115</span><span class="s2">, </span><span class="s4">121</span><span class="s2">, </span><span class="s4">142</span><span class="s2">, </span><span class="s4">187</span><span class="s1">])</span>
        <span class="s1">res = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">correction=</span><span class="s2">False, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">attributes = (</span><span class="s3">'statistic'</span><span class="s2">, </span><span class="s3">'pvalue'</span><span class="s1">)</span>
        <span class="s1">check_named_results(res</span><span class="s2">, </span><span class="s1">attributes)</span>

    <span class="s2">def </span><span class="s1">test_wilcoxon_has_zstatistic(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">89426135444</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = rng.random(</span><span class="s4">15</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rng.random(</span><span class="s4">15</span><span class="s1">)</span>

        <span class="s1">res = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">ref = stats.norm.ppf(res.pvalue/</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.zstatistic</span><span class="s2">, </span><span class="s1">ref)</span>

        <span class="s1">res = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;exact&quot;</span><span class="s1">)</span>
        <span class="s2">assert not </span><span class="s1">hasattr(res</span><span class="s2">, </span><span class="s3">'zstatistic'</span><span class="s1">)</span>

        <span class="s1">res = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">assert not </span><span class="s1">hasattr(res</span><span class="s2">, </span><span class="s3">'zstatistic'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_wilcoxon_tie(self):</span>
        <span class="s0"># Regression test for gh-2391.</span>
        <span class="s0"># Corresponding R code is:</span>
        <span class="s0">#   &gt; result = wilcox.test(rep(0.1, 10), exact=FALSE, correct=FALSE)</span>
        <span class="s0">#   &gt; result$p.value</span>
        <span class="s0">#   [1] 0.001565402</span>
        <span class="s0">#   &gt; result = wilcox.test(rep(0.1, 10), exact=FALSE, correct=TRUE)</span>
        <span class="s0">#   &gt; result$p.value</span>
        <span class="s0">#   [1] 0.001904195</span>
        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon([</span><span class="s4">0.1</span><span class="s1">] * </span><span class="s4">10</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">expected_p = </span><span class="s4">0.001565402</span>
        <span class="s1">assert_equal(stat</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected_p</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon([</span><span class="s4">0.1</span><span class="s1">] * </span><span class="s4">10</span><span class="s2">, </span><span class="s1">correction=</span><span class="s2">True, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">expected_p = </span><span class="s4">0.001904195</span>
        <span class="s1">assert_equal(stat</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected_p</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_onesided(self):</span>
        <span class="s0"># tested against &quot;R version 3.4.1 (2017-06-30)&quot;</span>
        <span class="s0"># x &lt;- c(125, 115, 130, 140, 140, 115, 140, 125, 140, 135)</span>
        <span class="s0"># y &lt;- c(110, 122, 125, 120, 140, 124, 123, 137, 135, 145)</span>
        <span class="s0"># cfg &lt;- list(x = x, y = y, paired = TRUE, exact = FALSE)</span>
        <span class="s0"># do.call(wilcox.test, c(cfg, list(alternative = &quot;less&quot;, correct = FALSE)))</span>
        <span class="s0"># do.call(wilcox.test, c(cfg, list(alternative = &quot;less&quot;, correct = TRUE)))</span>
        <span class="s0"># do.call(wilcox.test, c(cfg, list(alternative = &quot;greater&quot;, correct = FALSE)))</span>
        <span class="s0"># do.call(wilcox.test, c(cfg, list(alternative = &quot;greater&quot;, correct = TRUE)))</span>
        <span class="s1">x = [</span><span class="s4">125</span><span class="s2">, </span><span class="s4">115</span><span class="s2">, </span><span class="s4">130</span><span class="s2">, </span><span class="s4">140</span><span class="s2">, </span><span class="s4">140</span><span class="s2">, </span><span class="s4">115</span><span class="s2">, </span><span class="s4">140</span><span class="s2">, </span><span class="s4">125</span><span class="s2">, </span><span class="s4">140</span><span class="s2">, </span><span class="s4">135</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">110</span><span class="s2">, </span><span class="s4">122</span><span class="s2">, </span><span class="s4">125</span><span class="s2">, </span><span class="s4">120</span><span class="s2">, </span><span class="s4">140</span><span class="s2">, </span><span class="s4">124</span><span class="s2">, </span><span class="s4">123</span><span class="s2">, </span><span class="s4">137</span><span class="s2">, </span><span class="s4">135</span><span class="s2">, </span><span class="s4">145</span><span class="s1">]</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;Sample size too small&quot;</span><span class="s1">)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;less&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(w</span><span class="s2">, </span><span class="s4">27</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.7031847</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;Sample size too small&quot;</span><span class="s1">)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;less&quot;</span><span class="s2">, </span><span class="s1">correction=</span><span class="s2">True,</span>
                                  <span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(w</span><span class="s2">, </span><span class="s4">27</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.7233656</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;Sample size too small&quot;</span><span class="s1">)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;greater&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(w</span><span class="s2">, </span><span class="s4">27</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.2968153</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;Sample size too small&quot;</span><span class="s1">)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;greater&quot;</span><span class="s2">, </span><span class="s1">correction=</span><span class="s2">True,</span>
                                  <span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(w</span><span class="s2">, </span><span class="s4">27</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.3176447</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_exact_basic(self):</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">51</span><span class="s1">):</span>
            <span class="s1">pmf1 = _get_wilcoxon_distr(n)</span>
            <span class="s1">pmf2 = _get_wilcoxon_distr2(n)</span>
            <span class="s1">assert_equal(n*(n+</span><span class="s4">1</span><span class="s1">)/</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(pmf1))</span>
            <span class="s1">assert_equal(sum(pmf1)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_array_almost_equal(pmf1</span><span class="s2">, </span><span class="s1">pmf2)</span>

    <span class="s2">def </span><span class="s1">test_exact_pval(self):</span>
        <span class="s0"># expected values computed with &quot;R version 3.4.1 (2017-06-30)&quot;</span>
        <span class="s1">x = np.array([</span><span class="s4">1.81</span><span class="s2">, </span><span class="s4">0.82</span><span class="s2">, </span><span class="s4">1.56</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.48</span><span class="s2">, </span><span class="s4">0.81</span><span class="s2">, </span><span class="s4">1.28</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.04</span><span class="s2">, </span><span class="s4">0.23</span><span class="s2">,</span>
                      <span class="s1">-</span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.14</span><span class="s1">])</span>
        <span class="s1">y = np.array([</span><span class="s4">0.71</span><span class="s2">, </span><span class="s4">0.65</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.85</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.45</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.84</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.24</span><span class="s2">,</span>
                      <span class="s1">-</span><span class="s4">0.68</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.76</span><span class="s1">])</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;two-sided&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;exact&quot;</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.1054688</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;less&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;exact&quot;</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.9580078</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;greater&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;exact&quot;</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.05273438</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

        <span class="s1">x = np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">20</span><span class="s1">) + </span><span class="s4">0.5</span>
        <span class="s1">y = np.arange(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;two-sided&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;exact&quot;</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.8694878</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;less&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;exact&quot;</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.4347439</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;greater&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;exact&quot;</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">0.5795889</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

    <span class="s0"># These inputs were chosen to give a W statistic that is either the</span>
    <span class="s0"># center of the distribution (when the length of the support is odd), or</span>
    <span class="s0"># the value to the left of the center (when the length of the support is</span>
    <span class="s0"># even).  Also, the numbers are chosen so that the W statistic is the</span>
    <span class="s0"># sum of the positive values.</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'x'</span><span class="s2">, </span><span class="s1">[[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                                   <span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                                   <span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]])</span>
    <span class="s2">def </span><span class="s1">test_exact_p_1(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(x)</span>
        <span class="s1">x = np.array(x)</span>
        <span class="s1">wtrue = x[x &gt; </span><span class="s4">0</span><span class="s1">].sum()</span>
        <span class="s1">assert_equal(w</span><span class="s2">, </span><span class="s1">wtrue)</span>
        <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_auto(self):</span>
        <span class="s0"># auto default to exact if there are no ties and n&lt;= 25</span>
        <span class="s1">x = np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">25</span><span class="s1">) + </span><span class="s4">0.5</span>
        <span class="s1">y = np.arange(</span><span class="s4">25</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">,</span>
                     <span class="s1">stats.wilcoxon(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;exact&quot;</span><span class="s1">))</span>

        <span class="s0"># if there are ties (i.e. zeros in d = x-y), then switch to approx</span>
        <span class="s1">d = np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">13</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;Exact p-value calculation&quot;</span><span class="s1">)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">p = stats.wilcoxon(d)</span>
        <span class="s1">assert_equal(stats.wilcoxon(d</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(w</span><span class="s2">, </span><span class="s1">p))</span>

        <span class="s0"># use approximation for samples &gt; 25</span>
        <span class="s1">d = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">52</span><span class="s1">)</span>
        <span class="s1">assert_equal(stats.wilcoxon(d)</span><span class="s2">, </span><span class="s1">stats.wilcoxon(d</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;approx&quot;</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TestKstat:</span>
    <span class="s2">def </span><span class="s1">test_moments_normal_distribution(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">32149</span><span class="s1">)</span>
        <span class="s1">data = np.random.randn(</span><span class="s4">12345</span><span class="s1">)</span>
        <span class="s1">moments = [stats.kstat(data</span><span class="s2">, </span><span class="s1">n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span>

        <span class="s1">expected = [</span><span class="s4">0.011315</span><span class="s2">, </span><span class="s4">1.017931</span><span class="s2">, </span><span class="s4">0.05811052</span><span class="s2">, </span><span class="s4">0.0754134</span><span class="s1">]</span>
        <span class="s1">assert_allclose(moments</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

        <span class="s0"># test equivalence with `stats.moment`</span>
        <span class="s1">m1 = stats.moment(data</span><span class="s2">, </span><span class="s1">moment=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">m2 = stats.moment(data</span><span class="s2">, </span><span class="s1">moment=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">m3 = stats.moment(data</span><span class="s2">, </span><span class="s1">moment=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose((m1</span><span class="s2">, </span><span class="s1">m2</span><span class="s2">, </span><span class="s1">m3)</span><span class="s2">, </span><span class="s1">expected[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.02</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty_input(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.kstat</span><span class="s2">, </span><span class="s1">[])</span>

    <span class="s2">def </span><span class="s1">test_nan_input(self):</span>
        <span class="s1">data = np.arange(</span><span class="s4">10.</span><span class="s1">)</span>
        <span class="s1">data[</span><span class="s4">6</span><span class="s1">] = np.nan</span>

        <span class="s1">assert_equal(stats.kstat(data)</span><span class="s2">, </span><span class="s1">np.nan)</span>

    <span class="s2">def </span><span class="s1">test_kstat_bad_arg(self):</span>
        <span class="s0"># Raise ValueError if n &gt; 4 or n &lt; 1.</span>
        <span class="s1">data = np.arange(</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4.001</span><span class="s1">]:</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.kstat</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">n=n)</span>


<span class="s2">class </span><span class="s1">TestKstatVar:</span>
    <span class="s2">def </span><span class="s1">test_empty_input(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.kstatvar</span><span class="s2">, </span><span class="s1">[])</span>

    <span class="s2">def </span><span class="s1">test_nan_input(self):</span>
        <span class="s1">data = np.arange(</span><span class="s4">10.</span><span class="s1">)</span>
        <span class="s1">data[</span><span class="s4">6</span><span class="s1">] = np.nan</span>

        <span class="s1">assert_equal(stats.kstat(data)</span><span class="s2">, </span><span class="s1">np.nan)</span>

    <span class="s2">def </span><span class="s1">test_bad_arg(self):</span>
        <span class="s0"># Raise ValueError is n is not 1 or 2.</span>
        <span class="s1">data = [</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">n = </span><span class="s4">10</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.kstatvar</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">n=n)</span>


<span class="s2">class </span><span class="s1">TestPpccPlot:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">7654321</span><span class="s1">) + </span><span class="s4">5</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">N = </span><span class="s4">5</span>
        <span class="s1">svals</span><span class="s2">, </span><span class="s1">ppcc = stats.ppcc_plot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">N=N)</span>
        <span class="s1">ppcc_expected = [</span><span class="s4">0.21139644</span><span class="s2">, </span><span class="s4">0.21384059</span><span class="s2">, </span><span class="s4">0.98766719</span><span class="s2">, </span><span class="s4">0.97980182</span><span class="s2">,</span>
                         <span class="s4">0.93519298</span><span class="s1">]</span>
        <span class="s1">assert_allclose(svals</span><span class="s2">, </span><span class="s1">np.linspace(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">num=N))</span>
        <span class="s1">assert_allclose(ppcc</span><span class="s2">, </span><span class="s1">ppcc_expected)</span>

    <span class="s2">def </span><span class="s1">test_dist(self):</span>
        <span class="s0"># Test that we can specify distributions both by name and as objects.</span>
        <span class="s1">svals1</span><span class="s2">, </span><span class="s1">ppcc1 = stats.ppcc_plot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">dist=</span><span class="s3">'tukeylambda'</span><span class="s1">)</span>
        <span class="s1">svals2</span><span class="s2">, </span><span class="s1">ppcc2 = stats.ppcc_plot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">,</span>
                                        <span class="s1">dist=stats.tukeylambda)</span>
        <span class="s1">assert_allclose(svals1</span><span class="s2">, </span><span class="s1">svals2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-20</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ppcc1</span><span class="s2">, </span><span class="s1">ppcc2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-20</span><span class="s1">)</span>
        <span class="s0"># Test that 'tukeylambda' is the default dist</span>
        <span class="s1">svals3</span><span class="s2">, </span><span class="s1">ppcc3 = stats.ppcc_plot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(svals1</span><span class="s2">, </span><span class="s1">svals3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-20</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ppcc1</span><span class="s2">, </span><span class="s1">ppcc3</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-20</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s2">not </span><span class="s1">have_matplotlib</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;no matplotlib&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_plot_kwarg(self):</span>
        <span class="s0"># Check with the matplotlib.pyplot module</span>
        <span class="s1">fig = plt.figure()</span>
        <span class="s1">ax = fig.add_subplot(</span><span class="s4">111</span><span class="s1">)</span>
        <span class="s1">stats.ppcc_plot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s1">plot=plt)</span>
        <span class="s1">fig.delaxes(ax)</span>

        <span class="s0"># Check that a Matplotlib Axes object is accepted</span>
        <span class="s1">ax = fig.add_subplot(</span><span class="s4">111</span><span class="s1">)</span>
        <span class="s1">stats.ppcc_plot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s1">plot=ax)</span>
        <span class="s1">plt.close()</span>

    <span class="s2">def </span><span class="s1">test_invalid_inputs(self):</span>
        <span class="s0"># `b` has to be larger than `a`</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.ppcc_plot</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># Raise ValueError when given an invalid distribution.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.ppcc_plot</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">,</span>
                      <span class="s1">dist=</span><span class="s3">&quot;plate_of_shrimp&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty(self):</span>
        <span class="s0"># For consistency with probplot return for one empty array,</span>
        <span class="s0"># ppcc contains all zeros and svals is the same as for normal array</span>
        <span class="s0"># input.</span>
        <span class="s1">svals</span><span class="s2">, </span><span class="s1">ppcc = stats.ppcc_plot([]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(svals</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">num=</span><span class="s4">80</span><span class="s1">))</span>
        <span class="s1">assert_allclose(ppcc</span><span class="s2">, </span><span class="s1">np.zeros(</span><span class="s4">80</span><span class="s2">, </span><span class="s1">dtype=float))</span>


<span class="s2">class </span><span class="s1">TestPpccMax:</span>
    <span class="s2">def </span><span class="s1">test_ppcc_max_bad_arg(self):</span>
        <span class="s0"># Raise ValueError when given an invalid distribution.</span>
        <span class="s1">data = [</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.ppcc_max</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dist=</span><span class="s3">&quot;plate_of_shrimp&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ppcc_max_basic(self):</span>
        <span class="s1">x = stats.tukeylambda.rvs(-</span><span class="s4">0.7</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10000</span><span class="s2">,</span>
                                  <span class="s1">random_state=</span><span class="s4">1234567</span><span class="s1">) + </span><span class="s4">1e4</span>
        <span class="s1">assert_almost_equal(stats.ppcc_max(x)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.71215366521264145</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dist(self):</span>
        <span class="s1">x = stats.tukeylambda.rvs(-</span><span class="s4">0.7</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10000</span><span class="s2">,</span>
                                  <span class="s1">random_state=</span><span class="s4">1234567</span><span class="s1">) + </span><span class="s4">1e4</span>

        <span class="s0"># Test that we can specify distributions both by name and as objects.</span>
        <span class="s1">max1 = stats.ppcc_max(x</span><span class="s2">, </span><span class="s1">dist=</span><span class="s3">'tukeylambda'</span><span class="s1">)</span>
        <span class="s1">max2 = stats.ppcc_max(x</span><span class="s2">, </span><span class="s1">dist=stats.tukeylambda)</span>
        <span class="s1">assert_almost_equal(max1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.71215366521264145</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(max2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.71215366521264145</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>

        <span class="s0"># Test that 'tukeylambda' is the default dist</span>
        <span class="s1">max3 = stats.ppcc_max(x)</span>
        <span class="s1">assert_almost_equal(max3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.71215366521264145</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_brack(self):</span>
        <span class="s1">x = stats.tukeylambda.rvs(-</span><span class="s4">0.7</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10000</span><span class="s2">,</span>
                                  <span class="s1">random_state=</span><span class="s4">1234567</span><span class="s1">) + </span><span class="s4">1e4</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.ppcc_max</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">brack=(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">))</span>

        <span class="s1">assert_almost_equal(stats.ppcc_max(x</span><span class="s2">, </span><span class="s1">brack=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
                            <span class="s1">-</span><span class="s4">0.71215366521264145</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">7</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(stats.ppcc_max(x</span><span class="s2">, </span><span class="s1">brack=(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                            <span class="s1">-</span><span class="s4">0.71215366521264145</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">7</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestBoxcox_llf:</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">10000</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">54321</span><span class="s1">)</span>
        <span class="s1">lmbda = </span><span class="s4">1</span>
        <span class="s1">llf = stats.boxcox_llf(lmbda</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">llf_expected = -x.size / </span><span class="s4">2. </span><span class="s1">* np.log(np.sum(x.std()**</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_allclose(llf</span><span class="s2">, </span><span class="s1">llf_expected)</span>

    <span class="s2">def </span><span class="s1">test_array_like(self):</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">54321</span><span class="s1">)</span>
        <span class="s1">lmbda = </span><span class="s4">1</span>
        <span class="s1">llf = stats.boxcox_llf(lmbda</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">llf2 = stats.boxcox_llf(lmbda</span><span class="s2">, </span><span class="s1">list(x))</span>
        <span class="s1">assert_allclose(llf</span><span class="s2">, </span><span class="s1">llf2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_2d_input(self):</span>
        <span class="s0"># Note: boxcox_llf() was already working with 2-D input (sort of), so</span>
        <span class="s0"># keep it like that.  boxcox() doesn't work with 2-D input though, due</span>
        <span class="s0"># to brent() returning a scalar.</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">54321</span><span class="s1">)</span>
        <span class="s1">lmbda = </span><span class="s4">1</span>
        <span class="s1">llf = stats.boxcox_llf(lmbda</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">llf2 = stats.boxcox_llf(lmbda</span><span class="s2">, </span><span class="s1">np.vstack([x</span><span class="s2">, </span><span class="s1">x]).T)</span>
        <span class="s1">assert_allclose([llf</span><span class="s2">, </span><span class="s1">llf]</span><span class="s2">, </span><span class="s1">llf2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty(self):</span>
        <span class="s1">assert_(np.isnan(stats.boxcox_llf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[])))</span>

    <span class="s2">def </span><span class="s1">test_gh_6873(self):</span>
        <span class="s0"># Regression test for gh-6873.</span>
        <span class="s0"># This example was taken from gh-7534, a duplicate of gh-6873.</span>
        <span class="s1">data = [</span><span class="s4">198.0</span><span class="s2">, </span><span class="s4">233.0</span><span class="s2">, </span><span class="s4">233.0</span><span class="s2">, </span><span class="s4">392.0</span><span class="s1">]</span>
        <span class="s1">llf = stats.boxcox_llf(-</span><span class="s4">8</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s0"># The expected value was computed with mpmath.</span>
        <span class="s1">assert_allclose(llf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">17.93934208579061</span><span class="s1">)</span>


<span class="s0"># This is the data from github user Qukaiyi, given as an example</span>
<span class="s0"># of a data set that caused boxcox to fail.</span>
<span class="s1">_boxcox_data = [</span>
    <span class="s4">15957</span><span class="s2">, </span><span class="s4">112079</span><span class="s2">, </span><span class="s4">1039553</span><span class="s2">, </span><span class="s4">711775</span><span class="s2">, </span><span class="s4">173111</span><span class="s2">, </span><span class="s4">307382</span><span class="s2">, </span><span class="s4">183155</span><span class="s2">, </span><span class="s4">53366</span><span class="s2">, </span><span class="s4">760875</span><span class="s2">,</span>
    <span class="s4">207500</span><span class="s2">, </span><span class="s4">160045</span><span class="s2">, </span><span class="s4">473714</span><span class="s2">, </span><span class="s4">40194</span><span class="s2">, </span><span class="s4">440319</span><span class="s2">, </span><span class="s4">133261</span><span class="s2">, </span><span class="s4">265444</span><span class="s2">, </span><span class="s4">155590</span><span class="s2">, </span><span class="s4">36660</span><span class="s2">,</span>
    <span class="s4">904939</span><span class="s2">, </span><span class="s4">55108</span><span class="s2">, </span><span class="s4">138391</span><span class="s2">, </span><span class="s4">339146</span><span class="s2">, </span><span class="s4">458053</span><span class="s2">, </span><span class="s4">63324</span><span class="s2">, </span><span class="s4">1377727</span><span class="s2">, </span><span class="s4">1342632</span><span class="s2">, </span><span class="s4">41575</span><span class="s2">,</span>
    <span class="s4">68685</span><span class="s2">, </span><span class="s4">172755</span><span class="s2">, </span><span class="s4">63323</span><span class="s2">, </span><span class="s4">368161</span><span class="s2">, </span><span class="s4">199695</span><span class="s2">, </span><span class="s4">538214</span><span class="s2">, </span><span class="s4">167760</span><span class="s2">, </span><span class="s4">388610</span><span class="s2">, </span><span class="s4">398855</span><span class="s2">,</span>
    <span class="s4">1001873</span><span class="s2">, </span><span class="s4">364591</span><span class="s2">, </span><span class="s4">1320518</span><span class="s2">, </span><span class="s4">194060</span><span class="s2">, </span><span class="s4">194324</span><span class="s2">, </span><span class="s4">2318551</span><span class="s2">, </span><span class="s4">196114</span><span class="s2">, </span><span class="s4">64225</span><span class="s2">, </span><span class="s4">272000</span><span class="s2">,</span>
    <span class="s4">198668</span><span class="s2">, </span><span class="s4">123585</span><span class="s2">, </span><span class="s4">86420</span><span class="s2">, </span><span class="s4">1925556</span><span class="s2">, </span><span class="s4">695798</span><span class="s2">, </span><span class="s4">88664</span><span class="s2">, </span><span class="s4">46199</span><span class="s2">, </span><span class="s4">759135</span><span class="s2">, </span><span class="s4">28051</span><span class="s2">,</span>
    <span class="s4">345094</span><span class="s2">, </span><span class="s4">1977752</span><span class="s2">, </span><span class="s4">51778</span><span class="s2">, </span><span class="s4">82746</span><span class="s2">, </span><span class="s4">638126</span><span class="s2">, </span><span class="s4">2560910</span><span class="s2">, </span><span class="s4">45830</span><span class="s2">, </span><span class="s4">140576</span><span class="s2">, </span><span class="s4">1603787</span><span class="s2">,</span>
    <span class="s4">57371</span><span class="s2">, </span><span class="s4">548730</span><span class="s2">, </span><span class="s4">5343629</span><span class="s2">, </span><span class="s4">2298913</span><span class="s2">, </span><span class="s4">998813</span><span class="s2">, </span><span class="s4">2156812</span><span class="s2">, </span><span class="s4">423966</span><span class="s2">, </span><span class="s4">68350</span><span class="s2">, </span><span class="s4">145237</span><span class="s2">,</span>
    <span class="s4">131935</span><span class="s2">, </span><span class="s4">1600305</span><span class="s2">, </span><span class="s4">342359</span><span class="s2">, </span><span class="s4">111398</span><span class="s2">, </span><span class="s4">1409144</span><span class="s2">, </span><span class="s4">281007</span><span class="s2">, </span><span class="s4">60314</span><span class="s2">, </span><span class="s4">242004</span><span class="s2">, </span><span class="s4">113418</span><span class="s2">,</span>
    <span class="s4">246211</span><span class="s2">, </span><span class="s4">61940</span><span class="s2">, </span><span class="s4">95858</span><span class="s2">, </span><span class="s4">957805</span><span class="s2">, </span><span class="s4">40909</span><span class="s2">, </span><span class="s4">307955</span><span class="s2">, </span><span class="s4">174159</span><span class="s2">, </span><span class="s4">124278</span><span class="s2">, </span><span class="s4">241193</span><span class="s2">,</span>
    <span class="s4">872614</span><span class="s2">, </span><span class="s4">304180</span><span class="s2">, </span><span class="s4">146719</span><span class="s2">, </span><span class="s4">64361</span><span class="s2">, </span><span class="s4">87478</span><span class="s2">, </span><span class="s4">509360</span><span class="s2">, </span><span class="s4">167169</span><span class="s2">, </span><span class="s4">933479</span><span class="s2">, </span><span class="s4">620561</span><span class="s2">,</span>
    <span class="s4">483333</span><span class="s2">, </span><span class="s4">97416</span><span class="s2">, </span><span class="s4">143518</span><span class="s2">, </span><span class="s4">286905</span><span class="s2">, </span><span class="s4">597837</span><span class="s2">, </span><span class="s4">2556043</span><span class="s2">, </span><span class="s4">89065</span><span class="s2">, </span><span class="s4">69944</span><span class="s2">, </span><span class="s4">196858</span><span class="s2">,</span>
    <span class="s4">88883</span><span class="s2">, </span><span class="s4">49379</span><span class="s2">, </span><span class="s4">916265</span><span class="s2">, </span><span class="s4">1527392</span><span class="s2">, </span><span class="s4">626954</span><span class="s2">, </span><span class="s4">54415</span><span class="s2">, </span><span class="s4">89013</span><span class="s2">, </span><span class="s4">2883386</span><span class="s2">, </span><span class="s4">106096</span><span class="s2">,</span>
    <span class="s4">402697</span><span class="s2">, </span><span class="s4">45578</span><span class="s2">, </span><span class="s4">349852</span><span class="s2">, </span><span class="s4">140379</span><span class="s2">, </span><span class="s4">34648</span><span class="s2">, </span><span class="s4">757343</span><span class="s2">, </span><span class="s4">1305442</span><span class="s2">, </span><span class="s4">2054757</span><span class="s2">, </span><span class="s4">121232</span><span class="s2">,</span>
    <span class="s4">606048</span><span class="s2">, </span><span class="s4">101492</span><span class="s2">, </span><span class="s4">51426</span><span class="s2">, </span><span class="s4">1820833</span><span class="s2">, </span><span class="s4">83412</span><span class="s2">, </span><span class="s4">136349</span><span class="s2">, </span><span class="s4">1379924</span><span class="s2">, </span><span class="s4">505977</span><span class="s2">, </span><span class="s4">1303486</span><span class="s2">,</span>
    <span class="s4">95853</span><span class="s2">, </span><span class="s4">146451</span><span class="s2">, </span><span class="s4">285422</span><span class="s2">, </span><span class="s4">2205423</span><span class="s2">, </span><span class="s4">259020</span><span class="s2">, </span><span class="s4">45864</span><span class="s2">, </span><span class="s4">684547</span><span class="s2">, </span><span class="s4">182014</span><span class="s2">, </span><span class="s4">784334</span><span class="s2">,</span>
    <span class="s4">174793</span><span class="s2">, </span><span class="s4">563068</span><span class="s2">, </span><span class="s4">170745</span><span class="s2">, </span><span class="s4">1195531</span><span class="s2">, </span><span class="s4">63337</span><span class="s2">, </span><span class="s4">71833</span><span class="s2">, </span><span class="s4">199978</span><span class="s2">, </span><span class="s4">2330904</span><span class="s2">, </span><span class="s4">227335</span><span class="s2">,</span>
    <span class="s4">898280</span><span class="s2">, </span><span class="s4">75294</span><span class="s2">, </span><span class="s4">2011361</span><span class="s2">, </span><span class="s4">116771</span><span class="s2">, </span><span class="s4">157489</span><span class="s2">, </span><span class="s4">807147</span><span class="s2">, </span><span class="s4">1321443</span><span class="s2">, </span><span class="s4">1148635</span><span class="s2">, </span><span class="s4">2456524</span><span class="s2">,</span>
    <span class="s4">81839</span><span class="s2">, </span><span class="s4">1228251</span><span class="s2">, </span><span class="s4">97488</span><span class="s2">, </span><span class="s4">1051892</span><span class="s2">, </span><span class="s4">75397</span><span class="s2">, </span><span class="s4">3009923</span><span class="s2">, </span><span class="s4">2732230</span><span class="s2">, </span><span class="s4">90923</span><span class="s2">, </span><span class="s4">39735</span><span class="s2">,</span>
    <span class="s4">132433</span><span class="s2">, </span><span class="s4">225033</span><span class="s2">, </span><span class="s4">337555</span><span class="s2">, </span><span class="s4">1204092</span><span class="s2">, </span><span class="s4">686588</span><span class="s2">, </span><span class="s4">1062402</span><span class="s2">, </span><span class="s4">40362</span><span class="s2">, </span><span class="s4">1361829</span><span class="s2">, </span><span class="s4">1497217</span><span class="s2">,</span>
    <span class="s4">150074</span><span class="s2">, </span><span class="s4">551459</span><span class="s2">, </span><span class="s4">2019128</span><span class="s2">, </span><span class="s4">39581</span><span class="s2">, </span><span class="s4">45349</span><span class="s2">, </span><span class="s4">1117187</span><span class="s2">, </span><span class="s4">87845</span><span class="s2">, </span><span class="s4">1877288</span><span class="s2">, </span><span class="s4">164448</span><span class="s2">,</span>
    <span class="s4">10338362</span><span class="s2">, </span><span class="s4">24942</span><span class="s2">, </span><span class="s4">64737</span><span class="s2">, </span><span class="s4">769946</span><span class="s2">, </span><span class="s4">2469124</span><span class="s2">, </span><span class="s4">2366997</span><span class="s2">, </span><span class="s4">259124</span><span class="s2">, </span><span class="s4">2667585</span><span class="s2">, </span><span class="s4">29175</span><span class="s2">,</span>
    <span class="s4">56250</span><span class="s2">, </span><span class="s4">74450</span><span class="s2">, </span><span class="s4">96697</span><span class="s2">, </span><span class="s4">5920978</span><span class="s2">, </span><span class="s4">838375</span><span class="s2">, </span><span class="s4">225914</span><span class="s2">, </span><span class="s4">119494</span><span class="s2">, </span><span class="s4">206004</span><span class="s2">, </span><span class="s4">430907</span><span class="s2">,</span>
    <span class="s4">244083</span><span class="s2">, </span><span class="s4">219495</span><span class="s2">, </span><span class="s4">322239</span><span class="s2">, </span><span class="s4">407426</span><span class="s2">, </span><span class="s4">618748</span><span class="s2">, </span><span class="s4">2087536</span><span class="s2">, </span><span class="s4">2242124</span><span class="s2">, </span><span class="s4">4736149</span><span class="s2">, </span><span class="s4">124624</span><span class="s2">,</span>
    <span class="s4">406305</span><span class="s2">, </span><span class="s4">240921</span><span class="s2">, </span><span class="s4">2675273</span><span class="s2">, </span><span class="s4">4425340</span><span class="s2">, </span><span class="s4">821457</span><span class="s2">, </span><span class="s4">578467</span><span class="s2">, </span><span class="s4">28040</span><span class="s2">, </span><span class="s4">348943</span><span class="s2">, </span><span class="s4">48795</span><span class="s2">,</span>
    <span class="s4">145531</span><span class="s2">, </span><span class="s4">52110</span><span class="s2">, </span><span class="s4">1645730</span><span class="s2">, </span><span class="s4">1768364</span><span class="s2">, </span><span class="s4">348363</span><span class="s2">, </span><span class="s4">85042</span><span class="s2">, </span><span class="s4">2673847</span><span class="s2">, </span><span class="s4">81935</span><span class="s2">, </span><span class="s4">169075</span><span class="s2">,</span>
    <span class="s4">367733</span><span class="s2">, </span><span class="s4">135474</span><span class="s2">, </span><span class="s4">383327</span><span class="s2">, </span><span class="s4">1207018</span><span class="s2">, </span><span class="s4">93481</span><span class="s2">, </span><span class="s4">5934183</span><span class="s2">, </span><span class="s4">352190</span><span class="s2">, </span><span class="s4">636533</span><span class="s2">, </span><span class="s4">145870</span><span class="s2">,</span>
    <span class="s4">55659</span><span class="s2">, </span><span class="s4">146215</span><span class="s2">, </span><span class="s4">73191</span><span class="s2">, </span><span class="s4">248681</span><span class="s2">, </span><span class="s4">376907</span><span class="s2">, </span><span class="s4">1606620</span><span class="s2">, </span><span class="s4">169381</span><span class="s2">, </span><span class="s4">81164</span><span class="s2">, </span><span class="s4">246390</span><span class="s2">,</span>
    <span class="s4">236093</span><span class="s2">, </span><span class="s4">885778</span><span class="s2">, </span><span class="s4">335969</span><span class="s2">, </span><span class="s4">49266</span><span class="s2">, </span><span class="s4">381430</span><span class="s2">, </span><span class="s4">307437</span><span class="s2">, </span><span class="s4">350077</span><span class="s2">, </span><span class="s4">34346</span><span class="s2">, </span><span class="s4">49340</span><span class="s2">,</span>
    <span class="s4">84715</span><span class="s2">, </span><span class="s4">527120</span><span class="s2">, </span><span class="s4">40163</span><span class="s2">, </span><span class="s4">46898</span><span class="s2">, </span><span class="s4">4609439</span><span class="s2">, </span><span class="s4">617038</span><span class="s2">, </span><span class="s4">2239574</span><span class="s2">, </span><span class="s4">159905</span><span class="s2">, </span><span class="s4">118337</span><span class="s2">,</span>
    <span class="s4">120357</span><span class="s2">, </span><span class="s4">430778</span><span class="s2">, </span><span class="s4">3799158</span><span class="s2">, </span><span class="s4">3516745</span><span class="s2">, </span><span class="s4">54198</span><span class="s2">, </span><span class="s4">2970796</span><span class="s2">, </span><span class="s4">729239</span><span class="s2">, </span><span class="s4">97848</span><span class="s2">, </span><span class="s4">6317375</span><span class="s2">,</span>
    <span class="s4">887345</span><span class="s2">, </span><span class="s4">58198</span><span class="s2">, </span><span class="s4">88111</span><span class="s2">, </span><span class="s4">867595</span><span class="s2">, </span><span class="s4">210136</span><span class="s2">, </span><span class="s4">1572103</span><span class="s2">, </span><span class="s4">1420760</span><span class="s2">, </span><span class="s4">574046</span><span class="s2">, </span><span class="s4">845988</span><span class="s2">,</span>
    <span class="s4">509743</span><span class="s2">, </span><span class="s4">397927</span><span class="s2">, </span><span class="s4">1119016</span><span class="s2">, </span><span class="s4">189955</span><span class="s2">, </span><span class="s4">3883644</span><span class="s2">, </span><span class="s4">291051</span><span class="s2">, </span><span class="s4">126467</span><span class="s2">, </span><span class="s4">1239907</span><span class="s2">, </span><span class="s4">2556229</span><span class="s2">,</span>
    <span class="s4">411058</span><span class="s2">, </span><span class="s4">657444</span><span class="s2">, </span><span class="s4">2025234</span><span class="s2">, </span><span class="s4">1211368</span><span class="s2">, </span><span class="s4">93151</span><span class="s2">, </span><span class="s4">577594</span><span class="s2">, </span><span class="s4">4842264</span><span class="s2">, </span><span class="s4">1531713</span><span class="s2">, </span><span class="s4">305084</span><span class="s2">,</span>
    <span class="s4">479251</span><span class="s2">, </span><span class="s4">20591</span><span class="s2">, </span><span class="s4">1466166</span><span class="s2">, </span><span class="s4">137417</span><span class="s2">, </span><span class="s4">897756</span><span class="s2">, </span><span class="s4">594767</span><span class="s2">, </span><span class="s4">3606337</span><span class="s2">, </span><span class="s4">32844</span><span class="s2">, </span><span class="s4">82426</span><span class="s2">,</span>
    <span class="s4">1294831</span><span class="s2">, </span><span class="s4">57174</span><span class="s2">, </span><span class="s4">290167</span><span class="s2">, </span><span class="s4">322066</span><span class="s2">, </span><span class="s4">813146</span><span class="s2">, </span><span class="s4">5671804</span><span class="s2">, </span><span class="s4">4425684</span><span class="s2">, </span><span class="s4">895607</span><span class="s2">, </span><span class="s4">450598</span><span class="s2">,</span>
    <span class="s4">1048958</span><span class="s2">, </span><span class="s4">232844</span><span class="s2">, </span><span class="s4">56871</span><span class="s2">, </span><span class="s4">46113</span><span class="s2">, </span><span class="s4">70366</span><span class="s2">, </span><span class="s4">701618</span><span class="s2">, </span><span class="s4">97739</span><span class="s2">, </span><span class="s4">157113</span><span class="s2">, </span><span class="s4">865047</span><span class="s2">,</span>
    <span class="s4">194810</span><span class="s2">, </span><span class="s4">1501615</span><span class="s2">, </span><span class="s4">1765727</span><span class="s2">, </span><span class="s4">38125</span><span class="s2">, </span><span class="s4">2733376</span><span class="s2">, </span><span class="s4">40642</span><span class="s2">, </span><span class="s4">437590</span><span class="s2">, </span><span class="s4">127337</span><span class="s2">, </span><span class="s4">106310</span><span class="s2">,</span>
    <span class="s4">4167579</span><span class="s2">, </span><span class="s4">665303</span><span class="s2">, </span><span class="s4">809250</span><span class="s2">, </span><span class="s4">1210317</span><span class="s2">, </span><span class="s4">45750</span><span class="s2">, </span><span class="s4">1853687</span><span class="s2">, </span><span class="s4">348954</span><span class="s2">, </span><span class="s4">156786</span><span class="s2">, </span><span class="s4">90793</span><span class="s2">,</span>
    <span class="s4">1885504</span><span class="s2">, </span><span class="s4">281501</span><span class="s2">, </span><span class="s4">3902273</span><span class="s2">, </span><span class="s4">359546</span><span class="s2">, </span><span class="s4">797540</span><span class="s2">, </span><span class="s4">623508</span><span class="s2">, </span><span class="s4">3672775</span><span class="s2">, </span><span class="s4">55330</span><span class="s2">, </span><span class="s4">648221</span><span class="s2">,</span>
    <span class="s4">266831</span><span class="s2">, </span><span class="s4">90030</span><span class="s2">, </span><span class="s4">7118372</span><span class="s2">, </span><span class="s4">735521</span><span class="s2">, </span><span class="s4">1009925</span><span class="s2">, </span><span class="s4">283901</span><span class="s2">, </span><span class="s4">806005</span><span class="s2">, </span><span class="s4">2434897</span><span class="s2">, </span><span class="s4">94321</span><span class="s2">,</span>
    <span class="s4">309571</span><span class="s2">, </span><span class="s4">4213597</span><span class="s2">, </span><span class="s4">2213280</span><span class="s2">, </span><span class="s4">120339</span><span class="s2">, </span><span class="s4">64403</span><span class="s2">, </span><span class="s4">8155209</span><span class="s2">, </span><span class="s4">1686948</span><span class="s2">, </span><span class="s4">4327743</span><span class="s2">,</span>
    <span class="s4">1868312</span><span class="s2">, </span><span class="s4">135670</span><span class="s2">, </span><span class="s4">3189615</span><span class="s2">, </span><span class="s4">1569446</span><span class="s2">, </span><span class="s4">706058</span><span class="s2">, </span><span class="s4">58056</span><span class="s2">, </span><span class="s4">2438625</span><span class="s2">, </span><span class="s4">520619</span><span class="s2">, </span><span class="s4">105201</span><span class="s2">,</span>
    <span class="s4">141961</span><span class="s2">, </span><span class="s4">179990</span><span class="s2">, </span><span class="s4">1351440</span><span class="s2">, </span><span class="s4">3148662</span><span class="s2">, </span><span class="s4">2804457</span><span class="s2">, </span><span class="s4">2760144</span><span class="s2">, </span><span class="s4">70775</span><span class="s2">, </span><span class="s4">33807</span><span class="s2">, </span><span class="s4">1926518</span><span class="s2">,</span>
    <span class="s4">2362142</span><span class="s2">, </span><span class="s4">186761</span><span class="s2">, </span><span class="s4">240941</span><span class="s2">, </span><span class="s4">97860</span><span class="s2">, </span><span class="s4">1040429</span><span class="s2">, </span><span class="s4">1431035</span><span class="s2">, </span><span class="s4">78892</span><span class="s2">, </span><span class="s4">484039</span><span class="s2">, </span><span class="s4">57845</span><span class="s2">,</span>
    <span class="s4">724126</span><span class="s2">, </span><span class="s4">3166209</span><span class="s2">, </span><span class="s4">175913</span><span class="s2">, </span><span class="s4">159211</span><span class="s2">, </span><span class="s4">1182095</span><span class="s2">, </span><span class="s4">86734</span><span class="s2">, </span><span class="s4">1921472</span><span class="s2">, </span><span class="s4">513546</span><span class="s2">, </span><span class="s4">326016</span><span class="s2">,</span>
    <span class="s4">1891609</span>
<span class="s1">]</span>


<span class="s2">class </span><span class="s1">TestBoxcox:</span>

    <span class="s2">def </span><span class="s1">test_fixed_lmbda(self):</span>
        <span class="s1">x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">12345</span><span class="s1">) + </span><span class="s4">5</span>
        <span class="s1">xt = stats.boxcox(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s1">x - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">xt = stats.boxcox(x</span><span class="s2">, </span><span class="s1">lmbda=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">/x)</span>

        <span class="s1">xt = stats.boxcox(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s1">np.log(x))</span>

        <span class="s0"># Also test that array_like input works</span>
        <span class="s1">xt = stats.boxcox(list(x)</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s1">np.log(x))</span>

        <span class="s0"># test that constant input is accepted; see gh-12225</span>
        <span class="s1">xt = stats.boxcox(np.ones(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(xt</span><span class="s2">, </span><span class="s1">np.zeros(</span><span class="s4">10</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_lmbda_None(self):</span>
        <span class="s0"># Start from normal rv's, do inverse transform to check that</span>
        <span class="s0"># optimization function gets close to the right answer.</span>
        <span class="s1">lmbda = </span><span class="s4">2.5</span>
        <span class="s1">x = stats.norm.rvs(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">50000</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1245</span><span class="s1">)</span>
        <span class="s1">x_inv = (x * lmbda + </span><span class="s4">1</span><span class="s1">)**(-lmbda)</span>
        <span class="s1">xt</span><span class="s2">, </span><span class="s1">maxlog = stats.boxcox(x_inv)</span>

        <span class="s1">assert_almost_equal(maxlog</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1 </span><span class="s1">/ lmbda</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_alpha(self):</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">random_state=rng) + </span><span class="s4">5</span>

        <span class="s0"># Some regular values for alpha, on a small sample size</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">interval = stats.boxcox(x</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">assert_allclose(interval</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4.004485780226041</span><span class="s2">, </span><span class="s4">5.138756355035744</span><span class="s1">])</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">interval = stats.boxcox(x</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(interval</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.2138178554857557</span><span class="s2">, </span><span class="s4">8.209033272375663</span><span class="s1">])</span>

        <span class="s0"># Try some extreme values, see we don't hit the N=500 limit</span>
        <span class="s1">x = _old_loggamma_rvs(</span><span class="s4">7</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">random_state=rng) + </span><span class="s4">15</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">interval = stats.boxcox(x</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.001</span><span class="s1">)</span>
        <span class="s1">assert_allclose(interval</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.3988867</span><span class="s2">, </span><span class="s4">11.40553131</span><span class="s1">])</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">interval = stats.boxcox(x</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s4">0.999</span><span class="s1">)</span>
        <span class="s1">assert_allclose(interval</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.83316246</span><span class="s2">, </span><span class="s4">5.83735292</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_boxcox_bad_arg(self):</span>
        <span class="s0"># Raise ValueError if any data value is negative.</span>
        <span class="s1">x = np.array([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.boxcox</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s0"># Raise ValueError if data is constant.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.boxcox</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s0"># Raise ValueError if data is not 1-dimensional.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.boxcox</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]]))</span>

    <span class="s2">def </span><span class="s1">test_empty(self):</span>
        <span class="s1">assert_(stats.boxcox([]).shape == (</span><span class="s4">0</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_gh_6873(self):</span>
        <span class="s0"># Regression test for gh-6873.</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">lam = stats.boxcox(_boxcox_data)</span>
        <span class="s0"># The expected value of lam was computed with the function</span>
        <span class="s0"># powerTransform in the R library 'car'.  I trust that value</span>
        <span class="s0"># to only about five significant digits.</span>
        <span class="s1">assert_allclose(lam</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.051654</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bounds&quot;</span><span class="s2">, </span><span class="s1">[(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.1</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_bounded_optimizer_within_bounds(self</span><span class="s2">, </span><span class="s1">bounds):</span>
        <span class="s0"># Define custom optimizer with bounds.</span>
        <span class="s2">def </span><span class="s1">optimizer(fun):</span>
            <span class="s2">return </span><span class="s1">optimize.minimize_scalar(fun</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">,</span>
                                            <span class="s1">method=</span><span class="s3">&quot;bounded&quot;</span><span class="s1">)</span>

        <span class="s1">_</span><span class="s2">, </span><span class="s1">lmbda = stats.boxcox(_boxcox_data</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s2">None, </span><span class="s1">optimizer=optimizer)</span>
        <span class="s2">assert </span><span class="s1">bounds[</span><span class="s4">0</span><span class="s1">] &lt; lmbda &lt; bounds[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_bounded_optimizer_against_unbounded_optimizer(self):</span>
        <span class="s0"># Test whether setting bounds on optimizer excludes solution from</span>
        <span class="s0"># unbounded optimizer.</span>

        <span class="s0"># Get unbounded solution.</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">lmbda = stats.boxcox(_boxcox_data</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s0"># Set tolerance and bounds around solution.</span>
        <span class="s1">bounds = (lmbda + </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">lmbda + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">options = {</span><span class="s3">'xatol'</span><span class="s1">: </span><span class="s4">1e-12</span><span class="s1">}</span>

        <span class="s2">def </span><span class="s1">optimizer(fun):</span>
            <span class="s2">return </span><span class="s1">optimize.minimize_scalar(fun</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">,</span>
                                            <span class="s1">method=</span><span class="s3">&quot;bounded&quot;</span><span class="s2">, </span><span class="s1">options=options)</span>

        <span class="s0"># Check bounded solution. Lower bound should be active.</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">lmbda_bounded = stats.boxcox(_boxcox_data</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s2">None,</span>
                                        <span class="s1">optimizer=optimizer)</span>
        <span class="s2">assert </span><span class="s1">lmbda_bounded != lmbda</span>
        <span class="s1">assert_allclose(lmbda_bounded</span><span class="s2">, </span><span class="s1">bounds[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;optimizer&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;str&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_bad_optimizer_type_raises_error(self</span><span class="s2">, </span><span class="s1">optimizer):</span>
        <span class="s0"># Check if error is raised if string, tuple or float is passed</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;`optimizer` must be a callable&quot;</span><span class="s1">):</span>
            <span class="s1">stats.boxcox(_boxcox_data</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s2">None, </span><span class="s1">optimizer=optimizer)</span>

    <span class="s2">def </span><span class="s1">test_bad_optimizer_value_raises_error(self):</span>
        <span class="s0"># Check if error is raised if `optimizer` function does not return</span>
        <span class="s0"># `OptimizeResult` object</span>

        <span class="s0"># Define test function that always returns 1</span>
        <span class="s2">def </span><span class="s1">optimizer(fun):</span>
            <span class="s2">return </span><span class="s4">1</span>

        <span class="s1">message = </span><span class="s3">&quot;`optimizer` must return an object containing the optimal...&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
            <span class="s1">stats.boxcox(_boxcox_data</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s2">None, </span><span class="s1">optimizer=optimizer)</span>


<span class="s2">class </span><span class="s1">TestBoxcoxNormmax:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">12345</span><span class="s1">) + </span><span class="s4">5</span>

    <span class="s2">def </span><span class="s1">test_pearsonr(self):</span>
        <span class="s1">maxlog = stats.boxcox_normmax(self.x)</span>
        <span class="s1">assert_allclose(maxlog</span><span class="s2">, </span><span class="s4">1.804465</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s1">maxlog = stats.boxcox_normmax(self.x</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'mle'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(maxlog</span><span class="s2">, </span><span class="s4">1.758101</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

        <span class="s0"># Check that boxcox() uses 'mle'</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">maxlog_boxcox = stats.boxcox(self.x)</span>
        <span class="s1">assert_allclose(maxlog_boxcox</span><span class="s2">, </span><span class="s1">maxlog)</span>

    <span class="s2">def </span><span class="s1">test_all(self):</span>
        <span class="s1">maxlog_all = stats.boxcox_normmax(self.x</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'all'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(maxlog_all</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.804465</span><span class="s2">, </span><span class="s4">1.758101</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;mle&quot;</span><span class="s2">, </span><span class="s3">&quot;pearsonr&quot;</span><span class="s2">, </span><span class="s3">&quot;all&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bounds&quot;</span><span class="s2">, </span><span class="s1">[(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.1</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_bounded_optimizer_within_bounds(self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">bounds):</span>

        <span class="s2">def </span><span class="s1">optimizer(fun):</span>
            <span class="s2">return </span><span class="s1">optimize.minimize_scalar(fun</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">,</span>
                                            <span class="s1">method=</span><span class="s3">&quot;bounded&quot;</span><span class="s1">)</span>

        <span class="s1">maxlog = stats.boxcox_normmax(self.x</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">,</span>
                                      <span class="s1">optimizer=optimizer)</span>
        <span class="s2">assert </span><span class="s1">np.all(bounds[</span><span class="s4">0</span><span class="s1">] &lt; maxlog)</span>
        <span class="s2">assert </span><span class="s1">np.all(maxlog &lt; bounds[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_user_defined_optimizer(self):</span>
        <span class="s0"># tests an optimizer that is not based on scipy.optimize.minimize</span>
        <span class="s1">lmbda = stats.boxcox_normmax(self.x)</span>
        <span class="s1">lmbda_rounded = np.round(lmbda</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">lmbda_range = np.linspace(lmbda_rounded-</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">lmbda_rounded+</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1001</span><span class="s1">)</span>

        <span class="s2">class </span><span class="s1">MyResult:</span>
            <span class="s2">pass</span>

        <span class="s2">def </span><span class="s1">optimizer(fun):</span>
            <span class="s0"># brute force minimum over the range</span>
            <span class="s1">objs = []</span>
            <span class="s2">for </span><span class="s1">lmbda </span><span class="s2">in </span><span class="s1">lmbda_range:</span>
                <span class="s1">objs.append(fun(lmbda))</span>
            <span class="s1">res = MyResult()</span>
            <span class="s1">res.x = lmbda_range[np.argmin(objs)]</span>
            <span class="s2">return </span><span class="s1">res</span>

        <span class="s1">lmbda2 = stats.boxcox_normmax(self.x</span><span class="s2">, </span><span class="s1">optimizer=optimizer)</span>
        <span class="s2">assert </span><span class="s1">lmbda2 != lmbda                 </span><span class="s0"># not identical</span>
        <span class="s1">assert_allclose(lmbda2</span><span class="s2">, </span><span class="s1">lmbda</span><span class="s2">, </span><span class="s4">1e-5</span><span class="s1">)   </span><span class="s0"># but as close as it should be</span>

    <span class="s2">def </span><span class="s1">test_user_defined_optimizer_and_brack_raises_error(self):</span>
        <span class="s1">optimizer = optimize.minimize_scalar</span>

        <span class="s0"># Using default `brack=None` with user-defined `optimizer` works as</span>
        <span class="s0"># expected.</span>
        <span class="s1">stats.boxcox_normmax(self.x</span><span class="s2">, </span><span class="s1">brack=</span><span class="s2">None, </span><span class="s1">optimizer=optimizer)</span>

        <span class="s0"># Using user-defined `brack` with user-defined `optimizer` is expected</span>
        <span class="s0"># to throw an error. Instead, users should specify</span>
        <span class="s0"># optimizer-specific parameters in the optimizer function itself.</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;`brack` must be None if &quot;</span>
                                             <span class="s3">&quot;`optimizer` is given&quot;</span><span class="s1">):</span>

            <span class="s1">stats.boxcox_normmax(self.x</span><span class="s2">, </span><span class="s1">brack=(-</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">,</span>
                                 <span class="s1">optimizer=optimizer)</span>


<span class="s2">class </span><span class="s1">TestBoxcoxNormplot:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">7654321</span><span class="s1">) + </span><span class="s4">5</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">N = </span><span class="s4">5</span>
        <span class="s1">lmbdas</span><span class="s2">, </span><span class="s1">ppcc = stats.boxcox_normplot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">N=N)</span>
        <span class="s1">ppcc_expected = [</span><span class="s4">0.57783375</span><span class="s2">, </span><span class="s4">0.83610988</span><span class="s2">, </span><span class="s4">0.97524311</span><span class="s2">, </span><span class="s4">0.99756057</span><span class="s2">,</span>
                         <span class="s4">0.95843297</span><span class="s1">]</span>
        <span class="s1">assert_allclose(lmbdas</span><span class="s2">, </span><span class="s1">np.linspace(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">num=N))</span>
        <span class="s1">assert_allclose(ppcc</span><span class="s2">, </span><span class="s1">ppcc_expected)</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s2">not </span><span class="s1">have_matplotlib</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;no matplotlib&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_plot_kwarg(self):</span>
        <span class="s0"># Check with the matplotlib.pyplot module</span>
        <span class="s1">fig = plt.figure()</span>
        <span class="s1">ax = fig.add_subplot(</span><span class="s4">111</span><span class="s1">)</span>
        <span class="s1">stats.boxcox_normplot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s1">plot=plt)</span>
        <span class="s1">fig.delaxes(ax)</span>

        <span class="s0"># Check that a Matplotlib Axes object is accepted</span>
        <span class="s1">ax = fig.add_subplot(</span><span class="s4">111</span><span class="s1">)</span>
        <span class="s1">stats.boxcox_normplot(self.x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s1">plot=ax)</span>
        <span class="s1">plt.close()</span>

    <span class="s2">def </span><span class="s1">test_invalid_inputs(self):</span>
        <span class="s0"># `lb` has to be larger than `la`</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.boxcox_normplot</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0"># `x` can not contain negative values</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.boxcox_normplot</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty(self):</span>
        <span class="s1">assert_(stats.boxcox_normplot([]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">).size == </span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestYeojohnson_llf:</span>

    <span class="s2">def </span><span class="s1">test_array_like(self):</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">54321</span><span class="s1">)</span>
        <span class="s1">lmbda = </span><span class="s4">1</span>
        <span class="s1">llf = stats.yeojohnson_llf(lmbda</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">llf2 = stats.yeojohnson_llf(lmbda</span><span class="s2">, </span><span class="s1">list(x))</span>
        <span class="s1">assert_allclose(llf</span><span class="s2">, </span><span class="s1">llf2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_2d_input(self):</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">54321</span><span class="s1">)</span>
        <span class="s1">lmbda = </span><span class="s4">1</span>
        <span class="s1">llf = stats.yeojohnson_llf(lmbda</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">llf2 = stats.yeojohnson_llf(lmbda</span><span class="s2">, </span><span class="s1">np.vstack([x</span><span class="s2">, </span><span class="s1">x]).T)</span>
        <span class="s1">assert_allclose([llf</span><span class="s2">, </span><span class="s1">llf]</span><span class="s2">, </span><span class="s1">llf2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty(self):</span>
        <span class="s1">assert_(np.isnan(stats.yeojohnson_llf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[])))</span>


<span class="s2">class </span><span class="s1">TestYeojohnson:</span>

    <span class="s2">def </span><span class="s1">test_fixed_lmbda(self):</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s4">12345</span><span class="s1">)</span>

        <span class="s0"># Test positive input</span>
        <span class="s1">x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">random_state=rng) + </span><span class="s4">5</span>
        <span class="s2">assert </span><span class="s1">np.all(x &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1 </span><span class="s1">/ (x + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s1">np.log(x + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s1">x)</span>

        <span class="s0"># Test negative input</span>
        <span class="s1">x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">random_state=rng) - </span><span class="s4">5</span>
        <span class="s2">assert </span><span class="s1">np.all(x &lt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s1">-np.log(-x + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">/ (-x + </span><span class="s4">1</span><span class="s1">) - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0"># test both positive and negative input</span>
        <span class="s1">x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">random_state=rng) - </span><span class="s4">2</span>
        <span class="s2">assert not </span><span class="s1">np.all(x &lt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">assert not </span><span class="s1">np.all(x &gt;= </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">pos = x &gt;= </span><span class="s4">0</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt[pos]</span><span class="s2">, </span><span class="s1">x[pos])</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt[pos]</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1 </span><span class="s1">/ (x[pos] + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt[pos]</span><span class="s2">, </span><span class="s1">np.log(x[pos] + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt[pos]</span><span class="s2">, </span><span class="s1">x[pos])</span>

        <span class="s1">neg = ~pos</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt[neg]</span><span class="s2">, </span><span class="s1">-np.log(-x[neg] + </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt[neg]</span><span class="s2">, </span><span class="s1">x[neg])</span>
        <span class="s1">xt = stats.yeojohnson(x</span><span class="s2">, </span><span class="s1">lmbda=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt[neg]</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">/ (-x[neg] + </span><span class="s4">1</span><span class="s1">) - </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'lmbda'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_lmbda_None(self</span><span class="s2">, </span><span class="s1">lmbda):</span>
        <span class="s0"># Start from normal rv's, do inverse transform to check that</span>
        <span class="s0"># optimization function gets close to the right answer.</span>

        <span class="s2">def </span><span class="s1">_inverse_transform(x</span><span class="s2">, </span><span class="s1">lmbda):</span>
            <span class="s1">x_inv = np.zeros(x.shape</span><span class="s2">, </span><span class="s1">dtype=x.dtype)</span>
            <span class="s1">pos = x &gt;= </span><span class="s4">0</span>

            <span class="s0"># when x &gt;= 0</span>
            <span class="s2">if </span><span class="s1">abs(lmbda) &lt; np.spacing(</span><span class="s4">1.</span><span class="s1">):</span>
                <span class="s1">x_inv[pos] = np.exp(x[pos]) - </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s0"># lmbda != 0</span>
                <span class="s1">x_inv[pos] = np.power(x[pos] * lmbda + </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">/ lmbda) - </span><span class="s4">1</span>

            <span class="s0"># when x &lt; 0</span>
            <span class="s2">if </span><span class="s1">abs(lmbda - </span><span class="s4">2</span><span class="s1">) &gt; np.spacing(</span><span class="s4">1.</span><span class="s1">):</span>
                <span class="s1">x_inv[~pos] = </span><span class="s4">1 </span><span class="s1">- np.power(-(</span><span class="s4">2 </span><span class="s1">- lmbda) * x[~pos] + </span><span class="s4">1</span><span class="s2">,</span>
                                           <span class="s4">1 </span><span class="s1">/ (</span><span class="s4">2 </span><span class="s1">- lmbda))</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s0"># lmbda == 2</span>
                <span class="s1">x_inv[~pos] = </span><span class="s4">1 </span><span class="s1">- np.exp(-x[~pos])</span>

            <span class="s2">return </span><span class="s1">x_inv</span>

        <span class="s1">n_samples = </span><span class="s4">20000</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234567</span><span class="s1">)</span>
        <span class="s1">x = np.random.normal(loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=(n_samples))</span>

        <span class="s1">x_inv = _inverse_transform(x</span><span class="s2">, </span><span class="s1">lmbda)</span>
        <span class="s1">xt</span><span class="s2">, </span><span class="s1">maxlog = stats.yeojohnson(x_inv)</span>

        <span class="s1">assert_allclose(maxlog</span><span class="s2">, </span><span class="s1">lmbda</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-2</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.linalg.norm(x - xt) / n_samples</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">xt.mean()</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">xt.std()</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty(self):</span>
        <span class="s1">assert_(stats.yeojohnson([]).shape == (</span><span class="s4">0</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_array_like(self):</span>
        <span class="s1">x = stats.norm.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">54321</span><span class="s1">)</span>
        <span class="s1">xt1</span><span class="s2">, </span><span class="s1">_ = stats.yeojohnson(x)</span>
        <span class="s1">xt2</span><span class="s2">, </span><span class="s1">_ = stats.yeojohnson(list(x))</span>
        <span class="s1">assert_allclose(xt1</span><span class="s2">, </span><span class="s1">xt2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">[np.complex64</span><span class="s2">, </span><span class="s1">np.complex128])</span>
    <span class="s2">def </span><span class="s1">test_input_dtype_complex(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.arange(</span><span class="s4">6</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">err_msg = (</span><span class="s3">'Yeo-Johnson transformation is not defined for complex '</span>
                   <span class="s3">'numbers.'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=err_msg):</span>
            <span class="s1">stats.yeojohnson(x)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">[np.int8</span><span class="s2">, </span><span class="s1">np.uint8</span><span class="s2">, </span><span class="s1">np.int16</span><span class="s2">, </span><span class="s1">np.int32])</span>
    <span class="s2">def </span><span class="s1">test_input_dtype_integer(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x_int = np.arange(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">x_float = np.arange(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">xt_int</span><span class="s2">, </span><span class="s1">lmbda_int = stats.yeojohnson(x_int)</span>
        <span class="s1">xt_float</span><span class="s2">, </span><span class="s1">lmbda_float = stats.yeojohnson(x_float)</span>
        <span class="s1">assert_allclose(xt_int</span><span class="s2">, </span><span class="s1">xt_float</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(lmbda_int</span><span class="s2">, </span><span class="s1">lmbda_float</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_input_high_variance(self):</span>
        <span class="s0"># non-regression test for gh-10821</span>
        <span class="s1">x = np.array([</span><span class="s4">3251637.22</span><span class="s2">, </span><span class="s4">620695.44</span><span class="s2">, </span><span class="s4">11642969.00</span><span class="s2">, </span><span class="s4">2223468.22</span><span class="s2">,</span>
                      <span class="s4">85307500.00</span><span class="s2">, </span><span class="s4">16494389.89</span><span class="s2">, </span><span class="s4">917215.88</span><span class="s2">, </span><span class="s4">11642969.00</span><span class="s2">,</span>
                      <span class="s4">2145773.87</span><span class="s2">, </span><span class="s4">4962000.00</span><span class="s2">, </span><span class="s4">620695.44</span><span class="s2">, </span><span class="s4">651234.50</span><span class="s2">,</span>
                      <span class="s4">1907876.71</span><span class="s2">, </span><span class="s4">4053297.88</span><span class="s2">, </span><span class="s4">3251637.22</span><span class="s2">, </span><span class="s4">3259103.08</span><span class="s2">,</span>
                      <span class="s4">9547969.00</span><span class="s2">, </span><span class="s4">20631286.23</span><span class="s2">, </span><span class="s4">12807072.08</span><span class="s2">, </span><span class="s4">2383819.84</span><span class="s2">,</span>
                      <span class="s4">90114500.00</span><span class="s2">, </span><span class="s4">17209575.46</span><span class="s2">, </span><span class="s4">12852969.00</span><span class="s2">, </span><span class="s4">2414609.99</span><span class="s2">,</span>
                      <span class="s4">2170368.23</span><span class="s1">])</span>
        <span class="s1">xt_yeo</span><span class="s2">, </span><span class="s1">lam_yeo = stats.yeojohnson(x)</span>
        <span class="s1">xt_box</span><span class="s2">, </span><span class="s1">lam_box = stats.boxcox(x + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xt_yeo</span><span class="s2">, </span><span class="s1">xt_box</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(lam_yeo</span><span class="s2">, </span><span class="s1">lam_box</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestYeojohnsonNormmax:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.x = _old_loggamma_rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">12345</span><span class="s1">) + </span><span class="s4">5</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s1">maxlog = stats.yeojohnson_normmax(self.x)</span>
        <span class="s1">assert_allclose(maxlog</span><span class="s2">, </span><span class="s4">1.876393</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_darwin_example(self):</span>
        <span class="s0"># test from original paper &quot;A new family of power transformations to</span>
        <span class="s0"># improve normality or symmetry&quot; by Yeo and Johnson.</span>
        <span class="s1">x = [</span><span class="s4">6.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">8.4</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">2.9</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">5.1</span><span class="s2">, </span><span class="s4">1.8</span><span class="s2">, </span><span class="s4">3.6</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">9.3</span><span class="s2">,</span>
             <span class="s4">7.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6.0</span><span class="s1">]</span>
        <span class="s1">lmbda = stats.yeojohnson_normmax(x)</span>
        <span class="s2">assert </span><span class="s1">np.allclose(lmbda</span><span class="s2">, </span><span class="s4">1.305</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestCircFuncs:</span>
    <span class="s0"># In gh-5747, the R package `circular` was used to calculate reference</span>
    <span class="s0"># values for the circular variance, e.g.:</span>
    <span class="s0"># library(circular)</span>
    <span class="s0"># options(digits=16)</span>
    <span class="s0"># x = c(0, 2*pi/3, 5*pi/3)</span>
    <span class="s0"># var.circular(x)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func,expected&quot;</span><span class="s2">,</span>
                             <span class="s1">[(stats.circmean</span><span class="s2">, </span><span class="s4">0.167690146</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(stats.circvar</span><span class="s2">, </span><span class="s4">0.006455174270186603</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(stats.circstd</span><span class="s2">, </span><span class="s4">6.520702116</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_circfuncs(self</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = np.array([</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s1">])</span>
        <span class="s1">assert_allclose(test_func(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_circfuncs_small(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">20</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">20.5</span><span class="s2">, </span><span class="s4">19.2</span><span class="s1">])</span>
        <span class="s1">M1 = x.mean()</span>
        <span class="s1">M2 = stats.circmean(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">assert_allclose(M2</span><span class="s2">, </span><span class="s1">M1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

        <span class="s1">V1 = (x*np.pi/</span><span class="s4">180</span><span class="s1">).var()</span>
        <span class="s0"># for small variations, circvar is approximately half the</span>
        <span class="s0"># linear variance</span>
        <span class="s1">V1 = V1 / </span><span class="s4">2.</span>
        <span class="s1">V2 = stats.circvar(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">assert_allclose(V2</span><span class="s2">, </span><span class="s1">V1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

        <span class="s1">S1 = x.std()</span>
        <span class="s1">S2 = stats.circstd(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">assert_allclose(S2</span><span class="s2">, </span><span class="s1">S1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func, numpy_func&quot;</span><span class="s2">,</span>
                             <span class="s1">[(stats.circmean</span><span class="s2">, </span><span class="s1">np.mean)</span><span class="s2">,</span>
                              <span class="s1">(stats.circvar</span><span class="s2">, </span><span class="s1">np.var)</span><span class="s2">,</span>
                              <span class="s1">(stats.circstd</span><span class="s2">, </span><span class="s1">np.std)])</span>
    <span class="s2">def </span><span class="s1">test_circfuncs_close(self</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">numpy_func):</span>
        <span class="s0"># circfuncs should handle very similar inputs (gh-12740)</span>
        <span class="s1">x = np.array([</span><span class="s4">0.12675364631578953</span><span class="s1">] * </span><span class="s4">10 </span><span class="s1">+ [</span><span class="s4">0.12675365920187928</span><span class="s1">] * </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">circstat = test_func(x)</span>
        <span class="s1">normal = numpy_func(x)</span>
        <span class="s1">assert_allclose(circstat</span><span class="s2">, </span><span class="s1">normal</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_circmean_axis(self):</span>
        <span class="s1">x = np.array([[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">351</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">352</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">349</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">357</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">358</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">356</span><span class="s1">]])</span>
        <span class="s1">M1 = stats.circmean(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">M2 = stats.circmean(x.ravel()</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">assert_allclose(M1</span><span class="s2">, </span><span class="s1">M2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

        <span class="s1">M1 = stats.circmean(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">M2 = [stats.circmean(x[i]</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(x.shape[</span><span class="s4">0</span><span class="s1">])]</span>
        <span class="s1">assert_allclose(M1</span><span class="s2">, </span><span class="s1">M2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

        <span class="s1">M1 = stats.circmean(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">M2 = [stats.circmean(x[:</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(x.shape[</span><span class="s4">1</span><span class="s1">])]</span>
        <span class="s1">assert_allclose(M1</span><span class="s2">, </span><span class="s1">M2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_circvar_axis(self):</span>
        <span class="s1">x = np.array([[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">351</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">352</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">349</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">357</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">358</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">356</span><span class="s1">]])</span>

        <span class="s1">V1 = stats.circvar(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">V2 = stats.circvar(x.ravel()</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">assert_allclose(V1</span><span class="s2">, </span><span class="s1">V2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s1">)</span>

        <span class="s1">V1 = stats.circvar(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">V2 = [stats.circvar(x[i]</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(x.shape[</span><span class="s4">0</span><span class="s1">])]</span>
        <span class="s1">assert_allclose(V1</span><span class="s2">, </span><span class="s1">V2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s1">)</span>

        <span class="s1">V1 = stats.circvar(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">V2 = [stats.circvar(x[:</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(x.shape[</span><span class="s4">1</span><span class="s1">])]</span>
        <span class="s1">assert_allclose(V1</span><span class="s2">, </span><span class="s1">V2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_circstd_axis(self):</span>
        <span class="s1">x = np.array([[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">351</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">352</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">349</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">357</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">358</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">356</span><span class="s1">]])</span>

        <span class="s1">S1 = stats.circstd(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">S2 = stats.circstd(x.ravel()</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">assert_allclose(S1</span><span class="s2">, </span><span class="s1">S2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s1">)</span>

        <span class="s1">S1 = stats.circstd(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">S2 = [stats.circstd(x[i]</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(x.shape[</span><span class="s4">0</span><span class="s1">])]</span>
        <span class="s1">assert_allclose(S1</span><span class="s2">, </span><span class="s1">S2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s1">)</span>

        <span class="s1">S1 = stats.circstd(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">S2 = [stats.circstd(x[:</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(x.shape[</span><span class="s4">1</span><span class="s1">])]</span>
        <span class="s1">assert_allclose(S1</span><span class="s2">, </span><span class="s1">S2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func,expected&quot;</span><span class="s2">,</span>
                             <span class="s1">[(stats.circmean</span><span class="s2">, </span><span class="s4">0.167690146</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(stats.circvar</span><span class="s2">, </span><span class="s4">0.006455174270186603</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(stats.circstd</span><span class="s2">, </span><span class="s4">6.520702116</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_circfuncs_array_like(self</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = [</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s1">]</span>
        <span class="s1">assert_allclose(test_func(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func&quot;</span><span class="s2">, </span><span class="s1">[stats.circmean</span><span class="s2">, </span><span class="s1">stats.circvar</span><span class="s2">,</span>
                                           <span class="s1">stats.circstd])</span>
    <span class="s2">def </span><span class="s1">test_empty(self</span><span class="s2">, </span><span class="s1">test_func):</span>
        <span class="s1">assert_(np.isnan(test_func([])))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func&quot;</span><span class="s2">, </span><span class="s1">[stats.circmean</span><span class="s2">, </span><span class="s1">stats.circvar</span><span class="s2">,</span>
                                           <span class="s1">stats.circstd])</span>
    <span class="s2">def </span><span class="s1">test_nan_propagate(self</span><span class="s2">, </span><span class="s1">test_func):</span>
        <span class="s1">x = [</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s2">, </span><span class="s1">np.nan]</span>
        <span class="s1">assert_(np.isnan(test_func(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s1">)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func,expected&quot;</span><span class="s2">,</span>
                             <span class="s1">[(stats.circmean</span><span class="s2">,</span>
                               <span class="s1">{</span><span class="s2">None</span><span class="s1">: np.nan</span><span class="s2">, </span><span class="s4">0</span><span class="s1">: </span><span class="s4">355.66582264</span><span class="s2">, </span><span class="s4">1</span><span class="s1">: </span><span class="s4">0.28725053</span><span class="s1">})</span><span class="s2">,</span>
                              <span class="s1">(stats.circvar</span><span class="s2">,</span>
                               <span class="s1">{</span><span class="s2">None</span><span class="s1">: np.nan</span><span class="s2">,</span>
                                <span class="s4">0</span><span class="s1">: </span><span class="s4">0.002570671054089924</span><span class="s2">,</span>
                                <span class="s4">1</span><span class="s1">: </span><span class="s4">0.005545914017677123</span><span class="s1">})</span><span class="s2">,</span>
                              <span class="s1">(stats.circstd</span><span class="s2">,</span>
                               <span class="s1">{</span><span class="s2">None</span><span class="s1">: np.nan</span><span class="s2">, </span><span class="s4">0</span><span class="s1">: </span><span class="s4">4.11093193</span><span class="s2">, </span><span class="s4">1</span><span class="s1">: </span><span class="s4">6.04265394</span><span class="s1">})])</span>
    <span class="s2">def </span><span class="s1">test_nan_propagate_array(self</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = np.array([[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">351</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">352</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">349</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]])</span>
        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">expected.keys():</span>
            <span class="s1">out = test_func(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">axis=axis)</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">assert_(np.isnan(out))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_allclose(out[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[axis]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>
                <span class="s1">assert_(np.isnan(out[</span><span class="s4">1</span><span class="s1">:]).all())</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func,expected&quot;</span><span class="s2">,</span>
                             <span class="s1">[(stats.circmean</span><span class="s2">,</span>
                               <span class="s1">{</span><span class="s2">None</span><span class="s1">: </span><span class="s4">359.4178026893944</span><span class="s2">,</span>
                                <span class="s4">0</span><span class="s1">: np.array([</span><span class="s4">353.0</span><span class="s2">, </span><span class="s4">6.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">355.5</span><span class="s2">, </span><span class="s4">9.5</span><span class="s2">,</span>
                                             <span class="s4">349.5</span><span class="s1">])</span><span class="s2">,</span>
                                <span class="s4">1</span><span class="s1">: np.array([</span><span class="s4">0.16769015</span><span class="s2">, </span><span class="s4">358.66510252</span><span class="s1">])})</span><span class="s2">,</span>
                              <span class="s1">(stats.circvar</span><span class="s2">,</span>
                               <span class="s1">{</span><span class="s2">None</span><span class="s1">: </span><span class="s4">0.008396678483192477</span><span class="s2">,</span>
                                <span class="s4">0</span><span class="s1">: np.array([</span><span class="s4">1.9997969</span><span class="s2">, </span><span class="s4">0.4999873</span><span class="s2">, </span><span class="s4">0.4999873</span><span class="s2">,</span>
                                             <span class="s4">6.1230956</span><span class="s2">, </span><span class="s4">0.1249992</span><span class="s2">, </span><span class="s4">0.1249992</span><span class="s1">]</span>
                                            <span class="s1">)*(np.pi/</span><span class="s4">180</span><span class="s1">)**</span><span class="s4">2</span><span class="s2">,</span>
                                <span class="s4">1</span><span class="s1">: np.array([</span><span class="s4">0.006455174270186603</span><span class="s2">,</span>
                                             <span class="s4">0.01016767581393285</span><span class="s1">])})</span><span class="s2">,</span>
                              <span class="s1">(stats.circstd</span><span class="s2">,</span>
                               <span class="s1">{</span><span class="s2">None</span><span class="s1">: </span><span class="s4">7.440570778057074</span><span class="s2">,</span>
                                <span class="s4">0</span><span class="s1">: np.array([</span><span class="s4">2.00020313</span><span class="s2">, </span><span class="s4">1.00002539</span><span class="s2">, </span><span class="s4">1.00002539</span><span class="s2">,</span>
                                             <span class="s4">3.50108929</span><span class="s2">, </span><span class="s4">0.50000317</span><span class="s2">,</span>
                                             <span class="s4">0.50000317</span><span class="s1">])</span><span class="s2">,</span>
                                <span class="s4">1</span><span class="s1">: np.array([</span><span class="s4">6.52070212</span><span class="s2">, </span><span class="s4">8.19138093</span><span class="s1">])})])</span>
    <span class="s2">def </span><span class="s1">test_nan_omit_array(self</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = np.array([[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">351</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">352</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">349</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                      <span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]])</span>
        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">expected.keys():</span>
            <span class="s1">out = test_func(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'omit'</span><span class="s2">, </span><span class="s1">axis=axis)</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">assert_allclose(out</span><span class="s2">, </span><span class="s1">expected[axis]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_allclose(out[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[axis]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>
                <span class="s1">assert_(np.isnan(out[-</span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func,expected&quot;</span><span class="s2">,</span>
                             <span class="s1">[(stats.circmean</span><span class="s2">, </span><span class="s4">0.167690146</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(stats.circvar</span><span class="s2">, </span><span class="s4">0.006455174270186603</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(stats.circstd</span><span class="s2">, </span><span class="s4">6.520702116</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_nan_omit(self</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = [</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s2">, </span><span class="s1">np.nan]</span>
        <span class="s1">assert_allclose(test_func(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'omit'</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func&quot;</span><span class="s2">, </span><span class="s1">[stats.circmean</span><span class="s2">, </span><span class="s1">stats.circvar</span><span class="s2">,</span>
                                           <span class="s1">stats.circstd])</span>
    <span class="s2">def </span><span class="s1">test_nan_omit_all(self</span><span class="s2">, </span><span class="s1">test_func):</span>
        <span class="s1">x = [np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span>
        <span class="s1">assert_(np.isnan(test_func(x</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'omit'</span><span class="s1">)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func&quot;</span><span class="s2">, </span><span class="s1">[stats.circmean</span><span class="s2">, </span><span class="s1">stats.circvar</span><span class="s2">,</span>
                                           <span class="s1">stats.circstd])</span>
    <span class="s2">def </span><span class="s1">test_nan_omit_all_axis(self</span><span class="s2">, </span><span class="s1">test_func):</span>
        <span class="s1">x = np.array([[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                      <span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]])</span>
        <span class="s1">out = test_func(x</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'omit'</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_(np.isnan(out).all())</span>
        <span class="s1">assert_(len(out) == </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;x&quot;</span><span class="s2">,</span>
                             <span class="s1">[[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                              <span class="s1">np.array([[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s4">351</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">352</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">349</span><span class="s1">]])])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func&quot;</span><span class="s2">, </span><span class="s1">[stats.circmean</span><span class="s2">, </span><span class="s1">stats.circvar</span><span class="s2">,</span>
                                           <span class="s1">stats.circstd])</span>
    <span class="s2">def </span><span class="s1">test_nan_raise(self</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'raise'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;x&quot;</span><span class="s2">,</span>
                             <span class="s1">[[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                              <span class="s1">np.array([[</span><span class="s4">355</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">359</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">350</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                                        <span class="s1">[</span><span class="s4">351</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">352</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">349</span><span class="s1">]])])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;test_func&quot;</span><span class="s2">, </span><span class="s1">[stats.circmean</span><span class="s2">, </span><span class="s1">stats.circvar</span><span class="s2">,</span>
                                           <span class="s1">stats.circstd])</span>
    <span class="s2">def </span><span class="s1">test_bad_nan_policy(self</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">test_func</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">360</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'foobar'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_circmean_scalar(self):</span>
        <span class="s1">x = </span><span class="s4">1.</span>
        <span class="s1">M1 = x</span>
        <span class="s1">M2 = stats.circmean(x)</span>
        <span class="s1">assert_allclose(M2</span><span class="s2">, </span><span class="s1">M1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_circmean_range(self):</span>
        <span class="s0"># regression test for gh-6420: circmean(..., high, low) must be</span>
        <span class="s0"># between `high` and `low`</span>
        <span class="s1">m = stats.circmean(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.pi</span><span class="s2">, </span><span class="s1">-np.pi)</span>
        <span class="s1">assert_(m &lt; np.pi)</span>
        <span class="s1">assert_(m &gt; -np.pi)</span>

    <span class="s2">def </span><span class="s1">test_circfuncs_uint8(self):</span>
        <span class="s0"># regression test for gh-7255: overflow when working with</span>
        <span class="s0"># numpy uint8 data type</span>
        <span class="s1">x = np.array([</span><span class="s4">150</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'uint8'</span><span class="s1">)</span>
        <span class="s1">assert_equal(stats.circmean(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">180</span><span class="s1">)</span><span class="s2">, </span><span class="s4">170.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.circvar(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">180</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.2339555554617</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.circstd(x</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">180</span><span class="s1">)</span><span class="s2">, </span><span class="s4">20.91551378</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMedianTest:</span>

    <span class="s2">def </span><span class="s1">test_bad_n_samples(self):</span>
        <span class="s0"># median_test requires at least two samples.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_empty_sample(self):</span>
        <span class="s0"># Each sample must contain at least one value.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_empty_when_ties_ignored(self):</span>
        <span class="s0"># The grand median is 1, and all values in the first argument are</span>
        <span class="s0"># equal to the grand median.  With ties=&quot;ignore&quot;, those values are</span>
        <span class="s0"># ignored, which results in the first sample being (in effect) empty.</span>
        <span class="s0"># This should raise a ValueError.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ties=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_empty_contingency_row(self):</span>
        <span class="s0"># The grand median is 1, and with the default ties=&quot;below&quot;, all the</span>
        <span class="s0"># values in the samples are counted as being below the grand median.</span>
        <span class="s0"># This would result a row of zeros in the contingency table, which is</span>
        <span class="s0"># an error.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

        <span class="s0"># With ties=&quot;above&quot;, all the values are counted as above the</span>
        <span class="s0"># grand median.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">ties=</span><span class="s3">&quot;above&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_ties(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">ties=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_nan_policy(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'foobar'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_keyword(self):</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">foo=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">med</span><span class="s2">, </span><span class="s1">tbl = stats.median_test(x</span><span class="s2">, </span><span class="s1">y)</span>

        <span class="s0"># The median is floating point, but this equality test should be safe.</span>
        <span class="s1">assert_equal(med</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>

        <span class="s1">assert_array_equal(tbl</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]])</span>

        <span class="s0"># The expected values of the contingency table equal the contingency</span>
        <span class="s0"># table, so the statistic should be 0 and the p-value should be 1.</span>
        <span class="s1">assert_equal(stat</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ties_options(self):</span>
        <span class="s0"># Test the contingency table calculation.</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span>
        <span class="s1">z = [</span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span>
        <span class="s0"># grand median is 5.</span>

        <span class="s0"># Default 'ties' option is &quot;below&quot;.</span>
        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">tbl = stats.median_test(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)</span>
        <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(tbl</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>

        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">tbl = stats.median_test(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">ties=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(tbl</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>

        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">tbl = stats.median_test(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">ties=</span><span class="s3">&quot;above&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(tbl</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>

    <span class="s2">def </span><span class="s1">test_nan_policy_options(self):</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">np.nan]</span>
        <span class="s1">y = [</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span>
        <span class="s1">mt1 = stats.median_test(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'propagate'</span><span class="s1">)</span>
        <span class="s1">s</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">t = stats.median_test(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'omit'</span><span class="s1">)</span>

        <span class="s1">assert_equal(mt1</span><span class="s2">, </span><span class="s1">(np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, None</span><span class="s1">))</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s4">0.31250000000000006</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.57615012203057869</span><span class="s1">)</span>
        <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(t</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.median_test</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s3">'raise'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s0"># median_test calls chi2_contingency to compute the test statistic</span>
        <span class="s0"># and p-value.  Make sure it hasn't screwed up the call...</span>

        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span>

        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">tbl = stats.median_test(x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(tbl</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]])</span>

        <span class="s1">exp_stat</span><span class="s2">, </span><span class="s1">exp_p</span><span class="s2">, </span><span class="s1">dof</span><span class="s2">, </span><span class="s1">e = stats.chi2_contingency(tbl)</span>
        <span class="s1">assert_allclose(stat</span><span class="s2">, </span><span class="s1">exp_stat)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">exp_p)</span>

        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">tbl = stats.median_test(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">lambda_=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(tbl</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]])</span>

        <span class="s1">exp_stat</span><span class="s2">, </span><span class="s1">exp_p</span><span class="s2">, </span><span class="s1">dof</span><span class="s2">, </span><span class="s1">e = stats.chi2_contingency(tbl</span><span class="s2">, </span><span class="s1">lambda_=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stat</span><span class="s2">, </span><span class="s1">exp_stat)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">exp_p)</span>

        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">tbl = stats.median_test(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">correction=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(tbl</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]])</span>

        <span class="s1">exp_stat</span><span class="s2">, </span><span class="s1">exp_p</span><span class="s2">, </span><span class="s1">dof</span><span class="s2">, </span><span class="s1">e = stats.chi2_contingency(tbl</span><span class="s2">, </span><span class="s1">correction=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stat</span><span class="s2">, </span><span class="s1">exp_stat)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">exp_p)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;correction&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_result(self</span><span class="s2">, </span><span class="s1">correction):</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>

        <span class="s1">res = stats.median_test(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">correction=correction)</span>
        <span class="s1">assert_equal((res.statistic</span><span class="s2">, </span><span class="s1">res.pvalue</span><span class="s2">, </span><span class="s1">res.median</span><span class="s2">, </span><span class="s1">res.table)</span><span class="s2">, </span><span class="s1">res)</span>


<span class="s2">class </span><span class="s1">TestDirectionalStats:</span>
    <span class="s0"># Reference implementations are not available</span>
    <span class="s2">def </span><span class="s1">test_directional_stats_correctness(self):</span>
        <span class="s0"># Data from Fisher: Dispersion on a sphere, 1953 and</span>
        <span class="s0"># Mardia and Jupp, Directional Statistics.</span>

        <span class="s1">decl = -np.deg2rad(np.array([</span><span class="s4">343.2</span><span class="s2">, </span><span class="s4">62.</span><span class="s2">, </span><span class="s4">36.9</span><span class="s2">, </span><span class="s4">27.</span><span class="s2">, </span><span class="s4">359.</span><span class="s2">,</span>
                                     <span class="s4">5.7</span><span class="s2">, </span><span class="s4">50.4</span><span class="s2">, </span><span class="s4">357.6</span><span class="s2">, </span><span class="s4">44.</span><span class="s1">]))</span>
        <span class="s1">incl = -np.deg2rad(np.array([</span><span class="s4">66.1</span><span class="s2">, </span><span class="s4">68.7</span><span class="s2">, </span><span class="s4">70.1</span><span class="s2">, </span><span class="s4">82.1</span><span class="s2">, </span><span class="s4">79.5</span><span class="s2">,</span>
                                     <span class="s4">73.</span><span class="s2">, </span><span class="s4">69.3</span><span class="s2">, </span><span class="s4">58.8</span><span class="s2">, </span><span class="s4">51.4</span><span class="s1">]))</span>
        <span class="s1">data = np.stack((np.cos(incl) * np.cos(decl)</span><span class="s2">,</span>
                         <span class="s1">np.cos(incl) * np.sin(decl)</span><span class="s2">,</span>
                         <span class="s1">np.sin(incl))</span><span class="s2">,</span>
                        <span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">dirstats = stats.directional_stats(data)</span>
        <span class="s1">directional_mean = dirstats.mean_direction</span>
        <span class="s1">mean_rounded = np.round(directional_mean</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>

        <span class="s1">reference_mean = np.array([</span><span class="s4">0.2984</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1346</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.9449</span><span class="s1">])</span>
        <span class="s1">assert_allclose(mean_rounded</span><span class="s2">, </span><span class="s1">reference_mean)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'angles, ref'</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">([-np.pi/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">np.pi/</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">*np.pi]</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span>
    <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_directional_stats_2d_special_cases(self</span><span class="s2">, </span><span class="s1">angles</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s2">if </span><span class="s1">callable(ref):</span>
            <span class="s1">ref = ref(angles)</span>
        <span class="s1">data = np.stack([np.cos(angles)</span><span class="s2">, </span><span class="s1">np.sin(angles)]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">res = </span><span class="s4">1 </span><span class="s1">- stats.directional_stats(data).mean_resultant_length</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref)</span>

    <span class="s2">def </span><span class="s1">test_directional_stats_2d(self):</span>
        <span class="s0"># Test that for circular data directional_stats</span>
        <span class="s0"># yields the same result as circmean/circvar</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0xec9a6899d5a2830e0d1af479dbe1fd0c</span><span class="s1">)</span>
        <span class="s1">testdata = </span><span class="s4">2 </span><span class="s1">* np.pi * rng.random((</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">))</span>
        <span class="s1">testdata_vector = np.stack((np.cos(testdata)</span><span class="s2">,</span>
                                    <span class="s1">np.sin(testdata))</span><span class="s2">,</span>
                                   <span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">dirstats = stats.directional_stats(testdata_vector)</span>
        <span class="s1">directional_mean = dirstats.mean_direction</span>
        <span class="s1">directional_mean_angle = np.arctan2(directional_mean[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                                            <span class="s1">directional_mean[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">directional_mean_angle = directional_mean_angle % (</span><span class="s4">2</span><span class="s1">*np.pi)</span>
        <span class="s1">circmean = stats.circmean(testdata)</span>
        <span class="s1">assert_allclose(circmean</span><span class="s2">, </span><span class="s1">directional_mean_angle)</span>

        <span class="s1">directional_var = </span><span class="s4">1 </span><span class="s1">- dirstats.mean_resultant_length</span>
        <span class="s1">circular_var = stats.circvar(testdata)</span>
        <span class="s1">assert_allclose(directional_var</span><span class="s2">, </span><span class="s1">circular_var)</span>

    <span class="s2">def </span><span class="s1">test_directional_mean_higher_dim(self):</span>
        <span class="s0"># test that directional_stats works for higher dimensions</span>
        <span class="s0"># here a 4D array is reduced over axis = 2</span>
        <span class="s1">data = np.array([[</span><span class="s4">0.8660254</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">[</span><span class="s4">0.8660254</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]])</span>
        <span class="s1">full_array = np.tile(data</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">expected = np.array([[[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]]</span><span class="s2">,</span>
                             <span class="s1">[[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]]])</span>
        <span class="s1">dirstats = stats.directional_stats(full_array</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">dirstats.mean_direction)</span>

    <span class="s2">def </span><span class="s1">test_directional_stats_list_ndarray_input(self):</span>
        <span class="s0"># test that list and numpy array inputs yield same results</span>
        <span class="s1">data = [[</span><span class="s4">0.8660254</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.8660254</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s1">data_array = np.asarray(data)</span>
        <span class="s1">res = stats.directional_stats(data)</span>
        <span class="s1">ref = stats.directional_stats(data_array)</span>
        <span class="s1">assert_allclose(res.mean_direction</span><span class="s2">, </span><span class="s1">ref.mean_direction)</span>
        <span class="s1">assert_allclose(res.mean_resultant_length</span><span class="s2">,</span>
                        <span class="s1">res.mean_resultant_length)</span>

    <span class="s2">def </span><span class="s1">test_directional_stats_1d_error(self):</span>
        <span class="s0"># test that one-dimensional data raises ValueError</span>
        <span class="s1">data = np.ones((</span><span class="s4">5</span><span class="s2">, </span><span class="s1">))</span>
        <span class="s1">message = (</span><span class="s3">r&quot;samples must at least be two-dimensional. &quot;</span>
                   <span class="s3">r&quot;Instead samples has shape: (5,)&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=re.escape(message)):</span>
            <span class="s1">stats.directional_stats(data)</span>

    <span class="s2">def </span><span class="s1">test_directional_stats_normalize(self):</span>
        <span class="s0"># test that directional stats calculations yield same results</span>
        <span class="s0"># for unnormalized input with normalize=True and normalized</span>
        <span class="s0"># input with normalize=False</span>
        <span class="s1">data = np.array([[</span><span class="s4">0.8660254</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">[</span><span class="s4">1.7320508</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]])</span>
        <span class="s1">res = stats.directional_stats(data</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">normalized_data = data / np.linalg.norm(data</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s2">,</span>
                                                <span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">ref = stats.directional_stats(normalized_data</span><span class="s2">,</span>
                                      <span class="s1">normalize=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.mean_direction</span><span class="s2">, </span><span class="s1">ref.mean_direction)</span>
        <span class="s1">assert_allclose(res.mean_resultant_length</span><span class="s2">,</span>
                        <span class="s1">ref.mean_resultant_length)</span>


<span class="s2">class </span><span class="s1">TestFDRControl:</span>
    <span class="s2">def </span><span class="s1">test_input_validation(self):</span>
        <span class="s1">message = </span><span class="s3">&quot;`ps` must include only numbers between 0 and 1&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
            <span class="s1">stats.false_discovery_control([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.7</span><span class="s1">])</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
            <span class="s1">stats.false_discovery_control([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
            <span class="s1">stats.false_discovery_control([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s1">np.nan])</span>

        <span class="s1">message = </span><span class="s3">&quot;Unrecognized `method` 'YAK'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
            <span class="s1">stats.false_discovery_control([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'YAK'</span><span class="s1">)</span>

        <span class="s1">message = </span><span class="s3">&quot;`axis` must be an integer or `None`&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
            <span class="s1">stats.false_discovery_control([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1.5</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
            <span class="s1">stats.false_discovery_control([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_against_TileStats(self):</span>
        <span class="s0"># See reference [3] of false_discovery_control</span>
        <span class="s1">ps = [</span><span class="s4">0.005</span><span class="s2">, </span><span class="s4">0.009</span><span class="s2">, </span><span class="s4">0.019</span><span class="s2">, </span><span class="s4">0.022</span><span class="s2">, </span><span class="s4">0.051</span><span class="s2">, </span><span class="s4">0.101</span><span class="s2">, </span><span class="s4">0.361</span><span class="s2">, </span><span class="s4">0.387</span><span class="s1">]</span>
        <span class="s1">res = stats.false_discovery_control(ps)</span>
        <span class="s1">ref = [</span><span class="s4">0.036</span><span class="s2">, </span><span class="s4">0.036</span><span class="s2">, </span><span class="s4">0.044</span><span class="s2">, </span><span class="s4">0.044</span><span class="s2">, </span><span class="s4">0.082</span><span class="s2">, </span><span class="s4">0.135</span><span class="s2">, </span><span class="s4">0.387</span><span class="s2">, </span><span class="s4">0.387</span><span class="s1">]</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;case&quot;</span><span class="s2">,</span>
                             <span class="s1">[([</span><span class="s4">0.24617028</span><span class="s2">, </span><span class="s4">0.01140030</span><span class="s2">, </span><span class="s4">0.05652047</span><span class="s2">, </span><span class="s4">0.06841983</span><span class="s2">,</span>
                                <span class="s4">0.07989886</span><span class="s2">, </span><span class="s4">0.01841490</span><span class="s2">, </span><span class="s4">0.17540784</span><span class="s2">, </span><span class="s4">0.06841983</span><span class="s2">,</span>
                                <span class="s4">0.06841983</span><span class="s2">, </span><span class="s4">0.25464082</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'bh'</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">([</span><span class="s4">0.72102493</span><span class="s2">, </span><span class="s4">0.03339112</span><span class="s2">, </span><span class="s4">0.16554665</span><span class="s2">, </span><span class="s4">0.20039952</span><span class="s2">,</span>
                                <span class="s4">0.23402122</span><span class="s2">, </span><span class="s4">0.05393666</span><span class="s2">, </span><span class="s4">0.51376399</span><span class="s2">, </span><span class="s4">0.20039952</span><span class="s2">,</span>
                                <span class="s4">0.20039952</span><span class="s2">, </span><span class="s4">0.74583488</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'by'</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_against_R(self</span><span class="s2">, </span><span class="s1">case):</span>
        <span class="s0"># Test against p.adjust, e.g.</span>
        <span class="s0"># p = c(0.22155325, 0.00114003,..., 0.0364813 , 0.25464082)</span>
        <span class="s0"># p.adjust(p, &quot;BY&quot;)</span>
        <span class="s1">ref</span><span class="s2">, </span><span class="s1">method = case</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6134137338861652935</span><span class="s1">)</span>
        <span class="s1">ps = stats.loguniform.rvs(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">ps[</span><span class="s4">3</span><span class="s1">] = ps[</span><span class="s4">7</span><span class="s1">]  </span><span class="s0"># force a tie</span>
        <span class="s1">res = stats.false_discovery_control(ps</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_axis_None(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6134137338861652935</span><span class="s1">)</span>
        <span class="s1">ps = stats.loguniform.rvs(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">res = stats.false_discovery_control(ps</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">ref = stats.false_discovery_control(ps.ravel())</span>
        <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">ref)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;axis&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_axis(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6134137338861652935</span><span class="s1">)</span>
        <span class="s1">ps = stats.loguniform.rvs(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">res = stats.false_discovery_control(ps</span><span class="s2">, </span><span class="s1">axis=axis)</span>
        <span class="s1">ref = np.apply_along_axis(stats.false_discovery_control</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">ps)</span>
        <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">ref)</span>

    <span class="s2">def </span><span class="s1">test_edge_cases(self):</span>
        <span class="s1">assert_array_equal(stats.false_discovery_control([</span><span class="s4">0.25</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.25</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(stats.false_discovery_control(</span><span class="s4">0.25</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(stats.false_discovery_control([])</span><span class="s2">, </span><span class="s1">[])</span>
</pre>
</body>
</html>