<html>
<head>
<title>_matfuncs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_matfuncs.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Sparse matrix functions 
&quot;&quot;&quot;</span>

<span class="s2">#</span>
<span class="s2"># Authors: Travis Oliphant, March 2002</span>
<span class="s2">#          Anthony Scopatz, August 2012 (Sparse Updates)</span>
<span class="s2">#          Jake Vanderplas, August 2012 (Sparse Updates)</span>
<span class="s2">#</span>

<span class="s1">__all__ = [</span><span class="s3">'expm'</span><span class="s4">, </span><span class="s3">'inv'</span><span class="s1">]</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
<span class="s4">from </span><span class="s1">scipy.linalg._basic </span><span class="s4">import </span><span class="s1">solve</span><span class="s4">, </span><span class="s1">solve_triangular</span>

<span class="s4">from </span><span class="s1">scipy.sparse._base </span><span class="s4">import </span><span class="s1">issparse</span>
<span class="s4">from </span><span class="s1">scipy.sparse.linalg </span><span class="s4">import </span><span class="s1">spsolve</span>
<span class="s4">from </span><span class="s1">scipy.sparse._sputils </span><span class="s4">import </span><span class="s1">is_pydata_spmatrix</span>

<span class="s4">import </span><span class="s1">scipy.sparse</span>
<span class="s4">import </span><span class="s1">scipy.sparse.linalg</span>
<span class="s4">from </span><span class="s1">scipy.sparse.linalg._interface </span><span class="s4">import </span><span class="s1">LinearOperator</span>

<span class="s4">from </span><span class="s1">._expm_multiply </span><span class="s4">import </span><span class="s1">_ident_like</span><span class="s4">, </span><span class="s1">_exact_1_norm </span><span class="s4">as </span><span class="s1">_onenorm</span>


<span class="s1">UPPER_TRIANGULAR = </span><span class="s3">'upper_triangular'</span>


<span class="s4">def </span><span class="s1">inv(A):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the inverse of a sparse matrix 
 
    Parameters 
    ---------- 
    A : (M, M) sparse matrix 
        square matrix to be inverted 
 
    Returns 
    ------- 
    Ainv : (M, M) sparse matrix 
        inverse of `A` 
 
    Notes 
    ----- 
    This computes the sparse inverse of `A`. If the inverse of `A` is expected 
    to be non-sparse, it will likely be faster to convert `A` to dense and use 
    `scipy.linalg.inv`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import inv 
    &gt;&gt;&gt; A = csc_matrix([[1., 0.], [1., 2.]]) 
    &gt;&gt;&gt; Ainv = inv(A) 
    &gt;&gt;&gt; Ainv 
    &lt;2x2 sparse matrix of type '&lt;class 'numpy.float64'&gt;' 
        with 3 stored elements in Compressed Sparse Column format&gt; 
    &gt;&gt;&gt; A.dot(Ainv) 
    &lt;2x2 sparse matrix of type '&lt;class 'numpy.float64'&gt;' 
        with 2 stored elements in Compressed Sparse Column format&gt; 
    &gt;&gt;&gt; A.dot(Ainv).toarray() 
    array([[ 1.,  0.], 
           [ 0.,  1.]]) 
 
    .. versionadded:: 0.12.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Check input</span>
    <span class="s4">if not </span><span class="s1">(scipy.sparse.issparse(A) </span><span class="s4">or </span><span class="s1">is_pydata_spmatrix(A)):</span>
        <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'Input must be a sparse matrix'</span><span class="s1">)</span>

    <span class="s2"># Use sparse direct solver to solve &quot;AX = I&quot; accurately</span>
    <span class="s1">I = _ident_like(A)</span>
    <span class="s1">Ainv = spsolve(A</span><span class="s4">, </span><span class="s1">I)</span>
    <span class="s4">return </span><span class="s1">Ainv</span>


<span class="s4">def </span><span class="s1">_onenorm_matrix_power_nnm(A</span><span class="s4">, </span><span class="s1">p):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the 1-norm of a non-negative integer power of a non-negative matrix. 
 
    Parameters 
    ---------- 
    A : a square ndarray or matrix or sparse matrix 
        Input matrix with non-negative entries. 
    p : non-negative integer 
        The power to which the matrix is to be raised. 
 
    Returns 
    ------- 
    out : float 
        The 1-norm of the matrix power p of A. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Check input</span>
    <span class="s4">if </span><span class="s1">int(p) != p </span><span class="s4">or </span><span class="s1">p &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'expected non-negative integer p'</span><span class="s1">)</span>
    <span class="s1">p = int(p)</span>
    <span class="s4">if </span><span class="s1">len(A.shape) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'expected A to be like a square matrix'</span><span class="s1">)</span>

    <span class="s2"># Explicitly make a column vector so that this works when A is a</span>
    <span class="s2"># numpy matrix (in addition to ndarray and sparse matrix).</span>
    <span class="s1">v = np.ones((A.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">, </span><span class="s1">dtype=float)</span>
    <span class="s1">M = A.T</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(p):</span>
        <span class="s1">v = M.dot(v)</span>
    <span class="s4">return </span><span class="s1">np.max(v)</span>


<span class="s4">def </span><span class="s1">_is_upper_triangular(A):</span>
    <span class="s2"># This function could possibly be of wider interest.</span>
    <span class="s4">if </span><span class="s1">issparse(A):</span>
        <span class="s1">lower_part = scipy.sparse.tril(A</span><span class="s4">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2"># Check structural upper triangularity,</span>
        <span class="s2"># then coincidental upper triangularity if needed.</span>
        <span class="s4">return </span><span class="s1">lower_part.nnz == </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">lower_part.count_nonzero() == </span><span class="s5">0</span>
    <span class="s4">elif </span><span class="s1">is_pydata_spmatrix(A):</span>
        <span class="s4">import </span><span class="s1">sparse</span>
        <span class="s1">lower_part = sparse.tril(A</span><span class="s4">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">lower_part.nnz == </span><span class="s5">0</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">return not </span><span class="s1">np.tril(A</span><span class="s4">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">).any()</span>


<span class="s4">def </span><span class="s1">_smart_matrix_product(A</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">alpha=</span><span class="s4">None, </span><span class="s1">structure=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A matrix product that knows about sparse and structured matrices. 
 
    Parameters 
    ---------- 
    A : 2d ndarray 
        First matrix. 
    B : 2d ndarray 
        Second matrix. 
    alpha : float 
        The matrix product will be scaled by this constant. 
    structure : str, optional 
        A string describing the structure of both matrices `A` and `B`. 
        Only `upper_triangular` is currently supported. 
 
    Returns 
    ------- 
    M : 2d ndarray 
        Matrix product of A and B. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">len(A.shape) != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'expected A to be a rectangular matrix'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">len(B.shape) != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'expected B to be a rectangular matrix'</span><span class="s1">)</span>
    <span class="s1">f = </span><span class="s4">None</span>
    <span class="s4">if </span><span class="s1">structure == UPPER_TRIANGULAR:</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">not </span><span class="s1">issparse(A) </span><span class="s4">and not </span><span class="s1">issparse(B)</span>
                <span class="s4">and not </span><span class="s1">is_pydata_spmatrix(A) </span><span class="s4">and not </span><span class="s1">is_pydata_spmatrix(B)):</span>
            <span class="s1">f</span><span class="s4">, </span><span class="s1">= scipy.linalg.get_blas_funcs((</span><span class="s3">'trmm'</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">(A</span><span class="s4">, </span><span class="s1">B))</span>
    <span class="s4">if </span><span class="s1">f </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">alpha </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">alpha = </span><span class="s5">1.</span>
        <span class="s1">out = f(alpha</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">B)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">alpha </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">out = A.dot(B)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">out = alpha * A.dot(B)</span>
    <span class="s4">return </span><span class="s1">out</span>


<span class="s4">class </span><span class="s1">MatrixPowerOperator(LinearOperator):</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">structure=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s4">if </span><span class="s1">A.ndim != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'expected A to be like a square matrix'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">p &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'expected p to be a non-negative integer'</span><span class="s1">)</span>
        <span class="s1">self._A = A</span>
        <span class="s1">self._p = p</span>
        <span class="s1">self._structure = structure</span>
        <span class="s1">self.dtype = A.dtype</span>
        <span class="s1">self.ndim = A.ndim</span>
        <span class="s1">self.shape = A.shape</span>

    <span class="s4">def </span><span class="s1">_matvec(self</span><span class="s4">, </span><span class="s1">x):</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self._p):</span>
            <span class="s1">x = self._A.dot(x)</span>
        <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">_rmatvec(self</span><span class="s4">, </span><span class="s1">x):</span>
        <span class="s1">A_T = self._A.T</span>
        <span class="s1">x = x.ravel()</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self._p):</span>
            <span class="s1">x = A_T.dot(x)</span>
        <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">_matmat(self</span><span class="s4">, </span><span class="s1">X):</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self._p):</span>
            <span class="s1">X = _smart_matrix_product(self._A</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">structure=self._structure)</span>
        <span class="s4">return </span><span class="s1">X</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">T(self):</span>
        <span class="s4">return </span><span class="s1">MatrixPowerOperator(self._A.T</span><span class="s4">, </span><span class="s1">self._p)</span>


<span class="s4">class </span><span class="s1">ProductOperator(LinearOperator):</span>
    <span class="s0">&quot;&quot;&quot; 
    For now, this is limited to products of multiple square matrices. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._structure = kwargs.get(</span><span class="s3">'structure'</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">for </span><span class="s1">A </span><span class="s4">in </span><span class="s1">args:</span>
            <span class="s4">if </span><span class="s1">len(A.shape) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">'For now, the ProductOperator implementation is '</span>
                        <span class="s3">'limited to the product of multiple square matrices.'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">args:</span>
            <span class="s1">n = args[</span><span class="s5">0</span><span class="s1">].shape[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s4">for </span><span class="s1">A </span><span class="s4">in </span><span class="s1">args:</span>
                <span class="s4">for </span><span class="s1">d </span><span class="s4">in </span><span class="s1">A.shape:</span>
                    <span class="s4">if </span><span class="s1">d != n:</span>
                        <span class="s4">raise </span><span class="s1">ValueError(</span>
                                <span class="s3">'The square matrices of the ProductOperator '</span>
                                <span class="s3">'must all have the same shape.'</span><span class="s1">)</span>
            <span class="s1">self.shape = (n</span><span class="s4">, </span><span class="s1">n)</span>
            <span class="s1">self.ndim = len(self.shape)</span>
        <span class="s1">self.dtype = np.result_type(*[x.dtype </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">args])</span>
        <span class="s1">self._operator_sequence = args</span>

    <span class="s4">def </span><span class="s1">_matvec(self</span><span class="s4">, </span><span class="s1">x):</span>
        <span class="s4">for </span><span class="s1">A </span><span class="s4">in </span><span class="s1">reversed(self._operator_sequence):</span>
            <span class="s1">x = A.dot(x)</span>
        <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">_rmatvec(self</span><span class="s4">, </span><span class="s1">x):</span>
        <span class="s1">x = x.ravel()</span>
        <span class="s4">for </span><span class="s1">A </span><span class="s4">in </span><span class="s1">self._operator_sequence:</span>
            <span class="s1">x = A.T.dot(x)</span>
        <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">_matmat(self</span><span class="s4">, </span><span class="s1">X):</span>
        <span class="s4">for </span><span class="s1">A </span><span class="s4">in </span><span class="s1">reversed(self._operator_sequence):</span>
            <span class="s1">X = _smart_matrix_product(A</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">structure=self._structure)</span>
        <span class="s4">return </span><span class="s1">X</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">T(self):</span>
        <span class="s1">T_args = [A.T </span><span class="s4">for </span><span class="s1">A </span><span class="s4">in </span><span class="s1">reversed(self._operator_sequence)]</span>
        <span class="s4">return </span><span class="s1">ProductOperator(*T_args)</span>


<span class="s4">def </span><span class="s1">_onenormest_matrix_power(A</span><span class="s4">, </span><span class="s1">p</span><span class="s4">,</span>
        <span class="s1">t=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">itmax=</span><span class="s5">5</span><span class="s4">, </span><span class="s1">compute_v=</span><span class="s4">False, </span><span class="s1">compute_w=</span><span class="s4">False, </span><span class="s1">structure=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Efficiently estimate the 1-norm of A^p. 
 
    Parameters 
    ---------- 
    A : ndarray 
        Matrix whose 1-norm of a power is to be computed. 
    p : int 
        Non-negative integer power. 
    t : int, optional 
        A positive parameter controlling the tradeoff between 
        accuracy versus time and memory usage. 
        Larger values take longer and use more memory 
        but give more accurate output. 
    itmax : int, optional 
        Use at most this many iterations. 
    compute_v : bool, optional 
        Request a norm-maximizing linear operator input vector if True. 
    compute_w : bool, optional 
        Request a norm-maximizing linear operator output vector if True. 
 
    Returns 
    ------- 
    est : float 
        An underestimate of the 1-norm of the sparse matrix. 
    v : ndarray, optional 
        The vector such that ||Av||_1 == est*||v||_1. 
        It can be thought of as an input to the linear operator 
        that gives an output with particularly large norm. 
    w : ndarray, optional 
        The vector Av which has relatively large 1-norm. 
        It can be thought of as an output of the linear operator 
        that is relatively large in norm compared to the input. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">scipy.sparse.linalg.onenormest(</span>
            <span class="s1">MatrixPowerOperator(A</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">structure=structure))</span>


<span class="s4">def </span><span class="s1">_onenormest_product(operator_seq</span><span class="s4">,</span>
        <span class="s1">t=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">itmax=</span><span class="s5">5</span><span class="s4">, </span><span class="s1">compute_v=</span><span class="s4">False, </span><span class="s1">compute_w=</span><span class="s4">False, </span><span class="s1">structure=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Efficiently estimate the 1-norm of the matrix product of the args. 
 
    Parameters 
    ---------- 
    operator_seq : linear operator sequence 
        Matrices whose 1-norm of product is to be computed. 
    t : int, optional 
        A positive parameter controlling the tradeoff between 
        accuracy versus time and memory usage. 
        Larger values take longer and use more memory 
        but give more accurate output. 
    itmax : int, optional 
        Use at most this many iterations. 
    compute_v : bool, optional 
        Request a norm-maximizing linear operator input vector if True. 
    compute_w : bool, optional 
        Request a norm-maximizing linear operator output vector if True. 
    structure : str, optional 
        A string describing the structure of all operators. 
        Only `upper_triangular` is currently supported. 
 
    Returns 
    ------- 
    est : float 
        An underestimate of the 1-norm of the sparse matrix. 
    v : ndarray, optional 
        The vector such that ||Av||_1 == est*||v||_1. 
        It can be thought of as an input to the linear operator 
        that gives an output with particularly large norm. 
    w : ndarray, optional 
        The vector Av which has relatively large 1-norm. 
        It can be thought of as an output of the linear operator 
        that is relatively large in norm compared to the input. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">scipy.sparse.linalg.onenormest(</span>
            <span class="s1">ProductOperator(*operator_seq</span><span class="s4">, </span><span class="s1">structure=structure))</span>


<span class="s4">class </span><span class="s1">_ExpmPadeHelper:</span>
    <span class="s0">&quot;&quot;&quot; 
    Help lazily evaluate a matrix exponential. 
 
    The idea is to not do more work than we need for high expm precision, 
    so we lazily compute matrix powers and store or precompute 
    other properties of the matrix. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">structure=</span><span class="s4">None, </span><span class="s1">use_exact_onenorm=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the object. 
 
        Parameters 
        ---------- 
        A : a dense or sparse square numpy matrix or ndarray 
            The matrix to be exponentiated. 
        structure : str, optional 
            A string describing the structure of matrix `A`. 
            Only `upper_triangular` is currently supported. 
        use_exact_onenorm : bool, optional 
            If True then only the exact one-norm of matrix powers and products 
            will be used. Otherwise, the one-norm of powers and products 
            may initially be estimated. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.A = A</span>
        <span class="s1">self._A2 = </span><span class="s4">None</span>
        <span class="s1">self._A4 = </span><span class="s4">None</span>
        <span class="s1">self._A6 = </span><span class="s4">None</span>
        <span class="s1">self._A8 = </span><span class="s4">None</span>
        <span class="s1">self._A10 = </span><span class="s4">None</span>
        <span class="s1">self._d4_exact = </span><span class="s4">None</span>
        <span class="s1">self._d6_exact = </span><span class="s4">None</span>
        <span class="s1">self._d8_exact = </span><span class="s4">None</span>
        <span class="s1">self._d10_exact = </span><span class="s4">None</span>
        <span class="s1">self._d4_approx = </span><span class="s4">None</span>
        <span class="s1">self._d6_approx = </span><span class="s4">None</span>
        <span class="s1">self._d8_approx = </span><span class="s4">None</span>
        <span class="s1">self._d10_approx = </span><span class="s4">None</span>
        <span class="s1">self.ident = _ident_like(A)</span>
        <span class="s1">self.structure = structure</span>
        <span class="s1">self.use_exact_onenorm = use_exact_onenorm</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">A2(self):</span>
        <span class="s4">if </span><span class="s1">self._A2 </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._A2 = _smart_matrix_product(</span>
                    <span class="s1">self.A</span><span class="s4">, </span><span class="s1">self.A</span><span class="s4">, </span><span class="s1">structure=self.structure)</span>
        <span class="s4">return </span><span class="s1">self._A2</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">A4(self):</span>
        <span class="s4">if </span><span class="s1">self._A4 </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._A4 = _smart_matrix_product(</span>
                    <span class="s1">self.A2</span><span class="s4">, </span><span class="s1">self.A2</span><span class="s4">, </span><span class="s1">structure=self.structure)</span>
        <span class="s4">return </span><span class="s1">self._A4</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">A6(self):</span>
        <span class="s4">if </span><span class="s1">self._A6 </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._A6 = _smart_matrix_product(</span>
                    <span class="s1">self.A4</span><span class="s4">, </span><span class="s1">self.A2</span><span class="s4">, </span><span class="s1">structure=self.structure)</span>
        <span class="s4">return </span><span class="s1">self._A6</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">A8(self):</span>
        <span class="s4">if </span><span class="s1">self._A8 </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._A8 = _smart_matrix_product(</span>
                    <span class="s1">self.A6</span><span class="s4">, </span><span class="s1">self.A2</span><span class="s4">, </span><span class="s1">structure=self.structure)</span>
        <span class="s4">return </span><span class="s1">self._A8</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">A10(self):</span>
        <span class="s4">if </span><span class="s1">self._A10 </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._A10 = _smart_matrix_product(</span>
                    <span class="s1">self.A4</span><span class="s4">, </span><span class="s1">self.A6</span><span class="s4">, </span><span class="s1">structure=self.structure)</span>
        <span class="s4">return </span><span class="s1">self._A10</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">d4_tight(self):</span>
        <span class="s4">if </span><span class="s1">self._d4_exact </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._d4_exact = _onenorm(self.A4)**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self._d4_exact</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">d6_tight(self):</span>
        <span class="s4">if </span><span class="s1">self._d6_exact </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._d6_exact = _onenorm(self.A6)**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">6.</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self._d6_exact</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">d8_tight(self):</span>
        <span class="s4">if </span><span class="s1">self._d8_exact </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._d8_exact = _onenorm(self.A8)**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">8.</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self._d8_exact</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">d10_tight(self):</span>
        <span class="s4">if </span><span class="s1">self._d10_exact </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self._d10_exact = _onenorm(self.A10)**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">10.</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self._d10_exact</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">d4_loose(self):</span>
        <span class="s4">if </span><span class="s1">self.use_exact_onenorm:</span>
            <span class="s4">return </span><span class="s1">self.d4_tight</span>
        <span class="s4">if </span><span class="s1">self._d4_exact </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self._d4_exact</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self._d4_approx </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">self._d4_approx = _onenormest_matrix_power(self.A2</span><span class="s4">, </span><span class="s5">2</span><span class="s4">,</span>
                        <span class="s1">structure=self.structure)**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">4.</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">self._d4_approx</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">d6_loose(self):</span>
        <span class="s4">if </span><span class="s1">self.use_exact_onenorm:</span>
            <span class="s4">return </span><span class="s1">self.d6_tight</span>
        <span class="s4">if </span><span class="s1">self._d6_exact </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self._d6_exact</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self._d6_approx </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">self._d6_approx = _onenormest_matrix_power(self.A2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">,</span>
                        <span class="s1">structure=self.structure)**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">6.</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">self._d6_approx</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">d8_loose(self):</span>
        <span class="s4">if </span><span class="s1">self.use_exact_onenorm:</span>
            <span class="s4">return </span><span class="s1">self.d8_tight</span>
        <span class="s4">if </span><span class="s1">self._d8_exact </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self._d8_exact</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self._d8_approx </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">self._d8_approx = _onenormest_matrix_power(self.A4</span><span class="s4">, </span><span class="s5">2</span><span class="s4">,</span>
                        <span class="s1">structure=self.structure)**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">8.</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">self._d8_approx</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">d10_loose(self):</span>
        <span class="s4">if </span><span class="s1">self.use_exact_onenorm:</span>
            <span class="s4">return </span><span class="s1">self.d10_tight</span>
        <span class="s4">if </span><span class="s1">self._d10_exact </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self._d10_exact</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self._d10_approx </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">self._d10_approx = _onenormest_product((self.A4</span><span class="s4">, </span><span class="s1">self.A6)</span><span class="s4">,</span>
                        <span class="s1">structure=self.structure)**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">10.</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">self._d10_approx</span>

    <span class="s4">def </span><span class="s1">pade3(self):</span>
        <span class="s1">b = (</span><span class="s5">120.</span><span class="s4">, </span><span class="s5">60.</span><span class="s4">, </span><span class="s5">12.</span><span class="s4">, </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">U = _smart_matrix_product(self.A</span><span class="s4">,</span>
                <span class="s1">b[</span><span class="s5">3</span><span class="s1">]*self.A2 + b[</span><span class="s5">1</span><span class="s1">]*self.ident</span><span class="s4">,</span>
                <span class="s1">structure=self.structure)</span>
        <span class="s1">V = b[</span><span class="s5">2</span><span class="s1">]*self.A2 + b[</span><span class="s5">0</span><span class="s1">]*self.ident</span>
        <span class="s4">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span>

    <span class="s4">def </span><span class="s1">pade5(self):</span>
        <span class="s1">b = (</span><span class="s5">30240.</span><span class="s4">, </span><span class="s5">15120.</span><span class="s4">, </span><span class="s5">3360.</span><span class="s4">, </span><span class="s5">420.</span><span class="s4">, </span><span class="s5">30.</span><span class="s4">, </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">U = _smart_matrix_product(self.A</span><span class="s4">,</span>
                <span class="s1">b[</span><span class="s5">5</span><span class="s1">]*self.A4 + b[</span><span class="s5">3</span><span class="s1">]*self.A2 + b[</span><span class="s5">1</span><span class="s1">]*self.ident</span><span class="s4">,</span>
                <span class="s1">structure=self.structure)</span>
        <span class="s1">V = b[</span><span class="s5">4</span><span class="s1">]*self.A4 + b[</span><span class="s5">2</span><span class="s1">]*self.A2 + b[</span><span class="s5">0</span><span class="s1">]*self.ident</span>
        <span class="s4">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span>

    <span class="s4">def </span><span class="s1">pade7(self):</span>
        <span class="s1">b = (</span><span class="s5">17297280.</span><span class="s4">, </span><span class="s5">8648640.</span><span class="s4">, </span><span class="s5">1995840.</span><span class="s4">, </span><span class="s5">277200.</span><span class="s4">, </span><span class="s5">25200.</span><span class="s4">, </span><span class="s5">1512.</span><span class="s4">, </span><span class="s5">56.</span><span class="s4">, </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">U = _smart_matrix_product(self.A</span><span class="s4">,</span>
                <span class="s1">b[</span><span class="s5">7</span><span class="s1">]*self.A6 + b[</span><span class="s5">5</span><span class="s1">]*self.A4 + b[</span><span class="s5">3</span><span class="s1">]*self.A2 + b[</span><span class="s5">1</span><span class="s1">]*self.ident</span><span class="s4">,</span>
                <span class="s1">structure=self.structure)</span>
        <span class="s1">V = b[</span><span class="s5">6</span><span class="s1">]*self.A6 + b[</span><span class="s5">4</span><span class="s1">]*self.A4 + b[</span><span class="s5">2</span><span class="s1">]*self.A2 + b[</span><span class="s5">0</span><span class="s1">]*self.ident</span>
        <span class="s4">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span>

    <span class="s4">def </span><span class="s1">pade9(self):</span>
        <span class="s1">b = (</span><span class="s5">17643225600.</span><span class="s4">, </span><span class="s5">8821612800.</span><span class="s4">, </span><span class="s5">2075673600.</span><span class="s4">, </span><span class="s5">302702400.</span><span class="s4">, </span><span class="s5">30270240.</span><span class="s4">,</span>
                <span class="s5">2162160.</span><span class="s4">, </span><span class="s5">110880.</span><span class="s4">, </span><span class="s5">3960.</span><span class="s4">, </span><span class="s5">90.</span><span class="s4">, </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">U = _smart_matrix_product(self.A</span><span class="s4">,</span>
                <span class="s1">(b[</span><span class="s5">9</span><span class="s1">]*self.A8 + b[</span><span class="s5">7</span><span class="s1">]*self.A6 + b[</span><span class="s5">5</span><span class="s1">]*self.A4 +</span>
                    <span class="s1">b[</span><span class="s5">3</span><span class="s1">]*self.A2 + b[</span><span class="s5">1</span><span class="s1">]*self.ident)</span><span class="s4">,</span>
                <span class="s1">structure=self.structure)</span>
        <span class="s1">V = (b[</span><span class="s5">8</span><span class="s1">]*self.A8 + b[</span><span class="s5">6</span><span class="s1">]*self.A6 + b[</span><span class="s5">4</span><span class="s1">]*self.A4 +</span>
                <span class="s1">b[</span><span class="s5">2</span><span class="s1">]*self.A2 + b[</span><span class="s5">0</span><span class="s1">]*self.ident)</span>
        <span class="s4">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span>

    <span class="s4">def </span><span class="s1">pade13_scaled(self</span><span class="s4">, </span><span class="s1">s):</span>
        <span class="s1">b = (</span><span class="s5">64764752532480000.</span><span class="s4">, </span><span class="s5">32382376266240000.</span><span class="s4">, </span><span class="s5">7771770303897600.</span><span class="s4">,</span>
                <span class="s5">1187353796428800.</span><span class="s4">, </span><span class="s5">129060195264000.</span><span class="s4">, </span><span class="s5">10559470521600.</span><span class="s4">,</span>
                <span class="s5">670442572800.</span><span class="s4">, </span><span class="s5">33522128640.</span><span class="s4">, </span><span class="s5">1323241920.</span><span class="s4">, </span><span class="s5">40840800.</span><span class="s4">, </span><span class="s5">960960.</span><span class="s4">,</span>
                <span class="s5">16380.</span><span class="s4">, </span><span class="s5">182.</span><span class="s4">, </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">B = self.A * </span><span class="s5">2</span><span class="s1">**-s</span>
        <span class="s1">B2 = self.A2 * </span><span class="s5">2</span><span class="s1">**(-</span><span class="s5">2</span><span class="s1">*s)</span>
        <span class="s1">B4 = self.A4 * </span><span class="s5">2</span><span class="s1">**(-</span><span class="s5">4</span><span class="s1">*s)</span>
        <span class="s1">B6 = self.A6 * </span><span class="s5">2</span><span class="s1">**(-</span><span class="s5">6</span><span class="s1">*s)</span>
        <span class="s1">U2 = _smart_matrix_product(B6</span><span class="s4">,</span>
                <span class="s1">b[</span><span class="s5">13</span><span class="s1">]*B6 + b[</span><span class="s5">11</span><span class="s1">]*B4 + b[</span><span class="s5">9</span><span class="s1">]*B2</span><span class="s4">,</span>
                <span class="s1">structure=self.structure)</span>
        <span class="s1">U = _smart_matrix_product(B</span><span class="s4">,</span>
                <span class="s1">(U2 + b[</span><span class="s5">7</span><span class="s1">]*B6 + b[</span><span class="s5">5</span><span class="s1">]*B4 +</span>
                    <span class="s1">b[</span><span class="s5">3</span><span class="s1">]*B2 + b[</span><span class="s5">1</span><span class="s1">]*self.ident)</span><span class="s4">,</span>
                <span class="s1">structure=self.structure)</span>
        <span class="s1">V2 = _smart_matrix_product(B6</span><span class="s4">,</span>
                <span class="s1">b[</span><span class="s5">12</span><span class="s1">]*B6 + b[</span><span class="s5">10</span><span class="s1">]*B4 + b[</span><span class="s5">8</span><span class="s1">]*B2</span><span class="s4">,</span>
                <span class="s1">structure=self.structure)</span>
        <span class="s1">V = V2 + b[</span><span class="s5">6</span><span class="s1">]*B6 + b[</span><span class="s5">4</span><span class="s1">]*B4 + b[</span><span class="s5">2</span><span class="s1">]*B2 + b[</span><span class="s5">0</span><span class="s1">]*self.ident</span>
        <span class="s4">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span>


<span class="s4">def </span><span class="s1">expm(A):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the matrix exponential using Pade approximation. 
 
    Parameters 
    ---------- 
    A : (M,M) array_like or sparse matrix 
        2D Array or Matrix (sparse or dense) to be exponentiated 
 
    Returns 
    ------- 
    expA : (M,M) ndarray 
        Matrix exponential of `A` 
 
    Notes 
    ----- 
    This is algorithm (6.1) which is a simplification of algorithm (5.1). 
 
    .. versionadded:: 0.12.0 
 
    References 
    ---------- 
    .. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009) 
           &quot;A New Scaling and Squaring Algorithm for the Matrix Exponential.&quot; 
           SIAM Journal on Matrix Analysis and Applications. 
           31 (3). pp. 970-989. ISSN 1095-7162 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import expm 
    &gt;&gt;&gt; A = csc_matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]]) 
    &gt;&gt;&gt; A.toarray() 
    array([[1, 0, 0], 
           [0, 2, 0], 
           [0, 0, 3]], dtype=int64) 
    &gt;&gt;&gt; Aexp = expm(A) 
    &gt;&gt;&gt; Aexp 
    &lt;3x3 sparse matrix of type '&lt;class 'numpy.float64'&gt;' 
        with 3 stored elements in Compressed Sparse Column format&gt; 
    &gt;&gt;&gt; Aexp.toarray() 
    array([[  2.71828183,   0.        ,   0.        ], 
           [  0.        ,   7.3890561 ,   0.        ], 
           [  0.        ,   0.        ,  20.08553692]]) 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">_expm(A</span><span class="s4">, </span><span class="s1">use_exact_onenorm=</span><span class="s3">'auto'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_expm(A</span><span class="s4">, </span><span class="s1">use_exact_onenorm):</span>
    <span class="s2"># Core of expm, separated to allow testing exact and approximate</span>
    <span class="s2"># algorithms.</span>

    <span class="s2"># Avoid indiscriminate asarray() to allow sparse or other strange arrays.</span>
    <span class="s4">if </span><span class="s1">isinstance(A</span><span class="s4">, </span><span class="s1">(list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">np.matrix)):</span>
        <span class="s1">A = np.asarray(A)</span>
    <span class="s4">if </span><span class="s1">len(A.shape) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'expected a square matrix'</span><span class="s1">)</span>

    <span class="s2"># gracefully handle size-0 input,</span>
    <span class="s2"># carefully handling sparse scenario</span>
    <span class="s4">if </span><span class="s1">A.shape == (</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">out = np.zeros([</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">dtype=A.dtype)</span>
        <span class="s4">if </span><span class="s1">issparse(A) </span><span class="s4">or </span><span class="s1">is_pydata_spmatrix(A):</span>
            <span class="s4">return </span><span class="s1">A.__class__(out)</span>
        <span class="s4">return </span><span class="s1">out</span>

    <span class="s2"># Trivial case</span>
    <span class="s4">if </span><span class="s1">A.shape == (</span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">out = [[np.exp(A[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s1">])]]</span>

        <span class="s2"># Avoid indiscriminate casting to ndarray to</span>
        <span class="s2"># allow for sparse or other strange arrays</span>
        <span class="s4">if </span><span class="s1">issparse(A) </span><span class="s4">or </span><span class="s1">is_pydata_spmatrix(A):</span>
            <span class="s4">return </span><span class="s1">A.__class__(out)</span>

        <span class="s4">return </span><span class="s1">np.array(out)</span>

    <span class="s2"># Ensure input is of float type, to avoid integer overflows etc.</span>
    <span class="s4">if </span><span class="s1">((isinstance(A</span><span class="s4">, </span><span class="s1">np.ndarray) </span><span class="s4">or </span><span class="s1">issparse(A) </span><span class="s4">or </span><span class="s1">is_pydata_spmatrix(A))</span>
            <span class="s4">and not </span><span class="s1">np.issubdtype(A.dtype</span><span class="s4">, </span><span class="s1">np.inexact)):</span>
        <span class="s1">A = A.astype(float)</span>

    <span class="s2"># Detect upper triangularity.</span>
    <span class="s1">structure = UPPER_TRIANGULAR </span><span class="s4">if </span><span class="s1">_is_upper_triangular(A) </span><span class="s4">else None</span>

    <span class="s4">if </span><span class="s1">use_exact_onenorm == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s2"># Hardcode a matrix order threshold for exact vs. estimated one-norms.</span>
        <span class="s1">use_exact_onenorm = A.shape[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">200</span>

    <span class="s2"># Track functions of A to help compute the matrix exponential.</span>
    <span class="s1">h = _ExpmPadeHelper(</span>
            <span class="s1">A</span><span class="s4">, </span><span class="s1">structure=structure</span><span class="s4">, </span><span class="s1">use_exact_onenorm=use_exact_onenorm)</span>

    <span class="s2"># Try Pade order 3.</span>
    <span class="s1">eta_1 = max(h.d4_loose</span><span class="s4">, </span><span class="s1">h.d6_loose)</span>
    <span class="s4">if </span><span class="s1">eta_1 &lt; </span><span class="s5">1.495585217958292e-002 </span><span class="s4">and </span><span class="s1">_ell(h.A</span><span class="s4">, </span><span class="s5">3</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">U</span><span class="s4">, </span><span class="s1">V = h.pade3()</span>
        <span class="s4">return </span><span class="s1">_solve_P_Q(U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">structure=structure)</span>

    <span class="s2"># Try Pade order 5.</span>
    <span class="s1">eta_2 = max(h.d4_tight</span><span class="s4">, </span><span class="s1">h.d6_loose)</span>
    <span class="s4">if </span><span class="s1">eta_2 &lt; </span><span class="s5">2.539398330063230e-001 </span><span class="s4">and </span><span class="s1">_ell(h.A</span><span class="s4">, </span><span class="s5">5</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">U</span><span class="s4">, </span><span class="s1">V = h.pade5()</span>
        <span class="s4">return </span><span class="s1">_solve_P_Q(U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">structure=structure)</span>

    <span class="s2"># Try Pade orders 7 and 9.</span>
    <span class="s1">eta_3 = max(h.d6_tight</span><span class="s4">, </span><span class="s1">h.d8_loose)</span>
    <span class="s4">if </span><span class="s1">eta_3 &lt; </span><span class="s5">9.504178996162932e-001 </span><span class="s4">and </span><span class="s1">_ell(h.A</span><span class="s4">, </span><span class="s5">7</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">U</span><span class="s4">, </span><span class="s1">V = h.pade7()</span>
        <span class="s4">return </span><span class="s1">_solve_P_Q(U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">structure=structure)</span>
    <span class="s4">if </span><span class="s1">eta_3 &lt; </span><span class="s5">2.097847961257068e+000 </span><span class="s4">and </span><span class="s1">_ell(h.A</span><span class="s4">, </span><span class="s5">9</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">U</span><span class="s4">, </span><span class="s1">V = h.pade9()</span>
        <span class="s4">return </span><span class="s1">_solve_P_Q(U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">structure=structure)</span>

    <span class="s2"># Use Pade order 13.</span>
    <span class="s1">eta_4 = max(h.d8_loose</span><span class="s4">, </span><span class="s1">h.d10_loose)</span>
    <span class="s1">eta_5 = min(eta_3</span><span class="s4">, </span><span class="s1">eta_4)</span>
    <span class="s1">theta_13 = </span><span class="s5">4.25</span>

    <span class="s2"># Choose smallest s&gt;=0 such that 2**(-s) eta_5 &lt;= theta_13</span>
    <span class="s4">if </span><span class="s1">eta_5 == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2"># Nilpotent special case</span>
        <span class="s1">s = </span><span class="s5">0</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">s = max(int(np.ceil(np.log2(eta_5 / theta_13)))</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">s = s + _ell(</span><span class="s5">2</span><span class="s1">**-s * h.A</span><span class="s4">, </span><span class="s5">13</span><span class="s1">)</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V = h.pade13_scaled(s)</span>
    <span class="s1">X = _solve_P_Q(U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">structure=structure)</span>
    <span class="s4">if </span><span class="s1">structure == UPPER_TRIANGULAR:</span>
        <span class="s2"># Invoke Code Fragment 2.1.</span>
        <span class="s1">X = _fragment_2_1(X</span><span class="s4">, </span><span class="s1">h.A</span><span class="s4">, </span><span class="s1">s)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s2"># X = r_13(A)^(2^s) by repeated squaring.</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(s):</span>
            <span class="s1">X = X.dot(X)</span>
    <span class="s4">return </span><span class="s1">X</span>


<span class="s4">def </span><span class="s1">_solve_P_Q(U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">structure=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function for expm_2009. 
 
    Parameters 
    ---------- 
    U : ndarray 
        Pade numerator. 
    V : ndarray 
        Pade denominator. 
    structure : str, optional 
        A string describing the structure of both matrices `U` and `V`. 
        Only `upper_triangular` is currently supported. 
 
    Notes 
    ----- 
    The `structure` argument is inspired by similar args 
    for theano and cvxopt functions. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">P = U + V</span>
    <span class="s1">Q = -U + V</span>
    <span class="s4">if </span><span class="s1">issparse(U) </span><span class="s4">or </span><span class="s1">is_pydata_spmatrix(U):</span>
        <span class="s4">return </span><span class="s1">spsolve(Q</span><span class="s4">, </span><span class="s1">P)</span>
    <span class="s4">elif </span><span class="s1">structure </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">solve(Q</span><span class="s4">, </span><span class="s1">P)</span>
    <span class="s4">elif </span><span class="s1">structure == UPPER_TRIANGULAR:</span>
        <span class="s4">return </span><span class="s1">solve_triangular(Q</span><span class="s4">, </span><span class="s1">P)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'unsupported matrix structure: ' </span><span class="s1">+ str(structure))</span>


<span class="s4">def </span><span class="s1">_exp_sinch(a</span><span class="s4">, </span><span class="s1">x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stably evaluate exp(a)*sinh(x)/x 
 
    Notes 
    ----- 
    The strategy of falling back to a sixth order Taylor expansion 
    was suggested by the Spallation Neutron Source docs 
    which was found on the internet by google search. 
    http://www.ornl.gov/~t6p/resources/xal/javadoc/gov/sns/tools/math/ElementaryFunction.html 
    The details of the cutoff point and the Horner-like evaluation 
    was picked without reference to anything in particular. 
 
    Note that sinch is not currently implemented in scipy.special, 
    whereas the &quot;engineer's&quot; definition of sinc is implemented. 
    The implementation of sinc involves a scaling factor of pi 
    that distinguishes it from the &quot;mathematician's&quot; version of sinc. 
 
    &quot;&quot;&quot;</span>

    <span class="s2"># If x is small then use sixth order Taylor expansion.</span>
    <span class="s2"># How small is small? I am using the point where the relative error</span>
    <span class="s2"># of the approximation is less than 1e-14.</span>
    <span class="s2"># If x is large then directly evaluate sinh(x) / x.</span>
    <span class="s4">if </span><span class="s1">abs(x) &lt; </span><span class="s5">0.0135</span><span class="s1">:</span>
        <span class="s1">x2 = x*x</span>
        <span class="s4">return </span><span class="s1">np.exp(a) * (</span><span class="s5">1 </span><span class="s1">+ (x2/</span><span class="s5">6.</span><span class="s1">)*(</span><span class="s5">1 </span><span class="s1">+ (x2/</span><span class="s5">20.</span><span class="s1">)*(</span><span class="s5">1 </span><span class="s1">+ (x2/</span><span class="s5">42.</span><span class="s1">))))</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">(np.exp(a + x) - np.exp(a - x)) / (</span><span class="s5">2</span><span class="s1">*x)</span>


<span class="s4">def </span><span class="s1">_eq_10_42(lam_1</span><span class="s4">, </span><span class="s1">lam_2</span><span class="s4">, </span><span class="s1">t_12):</span>
    <span class="s0">&quot;&quot;&quot; 
    Equation (10.42) of Functions of Matrices: Theory and Computation. 
 
    Notes 
    ----- 
    This is a helper function for _fragment_2_1 of expm_2009. 
    Equation (10.42) is on page 251 in the section on Schur algorithms. 
    In particular, section 10.4.3 explains the Schur-Parlett algorithm. 
    expm([[lam_1, t_12], [0, lam_1]) 
    = 
    [[exp(lam_1), t_12*exp((lam_1 + lam_2)/2)*sinch((lam_1 - lam_2)/2)], 
    [0, exp(lam_2)] 
    &quot;&quot;&quot;</span>

    <span class="s2"># The plain formula t_12 * (exp(lam_2) - exp(lam_2)) / (lam_2 - lam_1)</span>
    <span class="s2"># apparently suffers from cancellation, according to Higham's textbook.</span>
    <span class="s2"># A nice implementation of sinch, defined as sinh(x)/x,</span>
    <span class="s2"># will apparently work around the cancellation.</span>
    <span class="s1">a = </span><span class="s5">0.5 </span><span class="s1">* (lam_1 + lam_2)</span>
    <span class="s1">b = </span><span class="s5">0.5 </span><span class="s1">* (lam_1 - lam_2)</span>
    <span class="s4">return </span><span class="s1">t_12 * _exp_sinch(a</span><span class="s4">, </span><span class="s1">b)</span>


<span class="s4">def </span><span class="s1">_fragment_2_1(X</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">s):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function for expm_2009. 
 
    Notes 
    ----- 
    The argument X is modified in-place, but this modification is not the same 
    as the returned value of the function. 
    This function also takes pains to do things in ways that are compatible 
    with sparse matrices, for example by avoiding fancy indexing 
    and by using methods of the matrices whenever possible instead of 
    using functions of the numpy or scipy libraries themselves. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Form X = r_m(2^-s T)</span>
    <span class="s2"># Replace diag(X) by exp(2^-s diag(T)).</span>
    <span class="s1">n = X.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">diag_T = np.ravel(T.diagonal().copy())</span>

    <span class="s2"># Replace diag(X) by exp(2^-s diag(T)).</span>
    <span class="s1">scale = </span><span class="s5">2 </span><span class="s1">** -s</span>
    <span class="s1">exp_diag = np.exp(scale * diag_T)</span>
    <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range(n):</span>
        <span class="s1">X[k</span><span class="s4">, </span><span class="s1">k] = exp_diag[k]</span>

    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(s-</span><span class="s5">1</span><span class="s4">, </span><span class="s1">-</span><span class="s5">1</span><span class="s4">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">X = X.dot(X)</span>

        <span class="s2"># Replace diag(X) by exp(2^-i diag(T)).</span>
        <span class="s1">scale = </span><span class="s5">2 </span><span class="s1">** -i</span>
        <span class="s1">exp_diag = np.exp(scale * diag_T)</span>
        <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range(n):</span>
            <span class="s1">X[k</span><span class="s4">, </span><span class="s1">k] = exp_diag[k]</span>

        <span class="s2"># Replace (first) superdiagonal of X by explicit formula</span>
        <span class="s2"># for superdiagonal of exp(2^-i T) from Eq (10.42) of</span>
        <span class="s2"># the author's 2008 textbook</span>
        <span class="s2"># Functions of Matrices: Theory and Computation.</span>
        <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range(n-</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">lam_1 = scale * diag_T[k]</span>
            <span class="s1">lam_2 = scale * diag_T[k+</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">t_12 = scale * T[k</span><span class="s4">, </span><span class="s1">k+</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">value = _eq_10_42(lam_1</span><span class="s4">, </span><span class="s1">lam_2</span><span class="s4">, </span><span class="s1">t_12)</span>
            <span class="s1">X[k</span><span class="s4">, </span><span class="s1">k+</span><span class="s5">1</span><span class="s1">] = value</span>

    <span class="s2"># Return the updated X matrix.</span>
    <span class="s4">return </span><span class="s1">X</span>


<span class="s4">def </span><span class="s1">_ell(A</span><span class="s4">, </span><span class="s1">m):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function for expm_2009. 
 
    Parameters 
    ---------- 
    A : linear operator 
        A linear operator whose norm of power we care about. 
    m : int 
        The power of the linear operator 
 
    Returns 
    ------- 
    value : int 
        A value related to a bound. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">len(A.shape) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">] != A.shape[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'expected A to be like a square matrix'</span><span class="s1">)</span>

    <span class="s2"># The c_i are explained in (2.2) and (2.6) of the 2005 expm paper.</span>
    <span class="s2"># They are coefficients of terms of a generating function series expansion.</span>
    <span class="s1">c_i = {</span><span class="s5">3</span><span class="s1">: </span><span class="s5">100800.</span><span class="s4">,</span>
           <span class="s5">5</span><span class="s1">: </span><span class="s5">10059033600.</span><span class="s4">,</span>
           <span class="s5">7</span><span class="s1">: </span><span class="s5">4487938430976000.</span><span class="s4">,</span>
           <span class="s5">9</span><span class="s1">: </span><span class="s5">5914384781877411840000.</span><span class="s4">,</span>
           <span class="s5">13</span><span class="s1">: </span><span class="s5">113250775606021113483283660800000000.</span>
           <span class="s1">}</span>
    <span class="s1">abs_c_recip = c_i[m]</span>

    <span class="s2"># This is explained after Eq. (1.2) of the 2009 expm paper.</span>
    <span class="s2"># It is the &quot;unit roundoff&quot; of IEEE double precision arithmetic.</span>
    <span class="s1">u = </span><span class="s5">2</span><span class="s1">**-</span><span class="s5">53</span>

    <span class="s2"># Compute the one-norm of matrix power p of abs(A).</span>
    <span class="s1">A_abs_onenorm = _onenorm_matrix_power_nnm(abs(A)</span><span class="s4">, </span><span class="s5">2</span><span class="s1">*m + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2"># Treat zero norm as a special case.</span>
    <span class="s4">if not </span><span class="s1">A_abs_onenorm:</span>
        <span class="s4">return </span><span class="s5">0</span>

    <span class="s1">alpha = A_abs_onenorm / (_onenorm(A) * abs_c_recip)</span>
    <span class="s1">log2_alpha_div_u = np.log2(alpha/u)</span>
    <span class="s1">value = int(np.ceil(log2_alpha_div_u / (</span><span class="s5">2 </span><span class="s1">* m)))</span>
    <span class="s4">return </span><span class="s1">max(value</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>
</pre>
</body>
</html>