<html>
<head>
<title>test_continuous_basic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_continuous_basic.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">numpy.testing </span><span class="s0">as </span><span class="s1">npt</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>
<span class="s0">from </span><span class="s1">scipy.integrate </span><span class="s0">import </span><span class="s1">IntegrationWarning</span>
<span class="s0">import </span><span class="s1">itertools</span>

<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">.common_tests </span><span class="s0">import </span><span class="s1">(check_normalization</span><span class="s0">, </span><span class="s1">check_moment</span><span class="s0">,</span>
                           <span class="s1">check_mean_expect</span><span class="s0">,</span>
                           <span class="s1">check_var_expect</span><span class="s0">, </span><span class="s1">check_skew_expect</span><span class="s0">,</span>
                           <span class="s1">check_kurt_expect</span><span class="s0">, </span><span class="s1">check_entropy</span><span class="s0">,</span>
                           <span class="s1">check_private_entropy</span><span class="s0">, </span><span class="s1">check_entropy_vect_scale</span><span class="s0">,</span>
                           <span class="s1">check_edge_support</span><span class="s0">, </span><span class="s1">check_named_args</span><span class="s0">,</span>
                           <span class="s1">check_random_state_property</span><span class="s0">,</span>
                           <span class="s1">check_meth_dtype</span><span class="s0">, </span><span class="s1">check_ppf_dtype</span><span class="s0">,</span>
                           <span class="s1">check_cmplx_deriv</span><span class="s0">,</span>
                           <span class="s1">check_pickling</span><span class="s0">, </span><span class="s1">check_rvs_broadcast</span><span class="s0">,</span>
                           <span class="s1">check_freezing</span><span class="s0">, </span><span class="s1">check_munp_expect</span><span class="s0">,</span><span class="s1">)</span>
<span class="s0">from </span><span class="s1">scipy.stats._distr_params </span><span class="s0">import </span><span class="s1">distcont</span>
<span class="s0">from </span><span class="s1">scipy.stats._distn_infrastructure </span><span class="s0">import </span><span class="s1">rv_continuous_frozen</span>

<span class="s2">&quot;&quot;&quot; 
Test all continuous distributions. 
 
Parameters were chosen for those distributions that pass the 
Kolmogorov-Smirnov test.  This provides safe parameters for each 
distributions so that we can perform further testing of class methods. 
 
These tests currently check only/mostly for serious errors and exceptions, 
not for numerically exact results. 
&quot;&quot;&quot;</span>

<span class="s3"># Note that you need to add new distributions you want tested</span>
<span class="s3"># to _distr_params</span>

<span class="s1">DECIMAL = </span><span class="s4">5  </span><span class="s3"># specify the precision of the tests  # increased from 0 to 5</span>
<span class="s1">_IS_32BIT = (sys.maxsize &lt; </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s1">)</span>

<span class="s3"># For skipping test_cont_basic</span>
<span class="s1">distslow = [</span><span class="s2">'recipinvgauss'</span><span class="s0">, </span><span class="s2">'vonmises'</span><span class="s0">, </span><span class="s2">'kappa4'</span><span class="s0">, </span><span class="s2">'vonmises_line'</span><span class="s0">,</span>
            <span class="s2">'gausshyper'</span><span class="s0">, </span><span class="s2">'norminvgauss'</span><span class="s0">, </span><span class="s2">'geninvgauss'</span><span class="s0">, </span><span class="s2">'genhyperbolic'</span><span class="s0">,</span>
            <span class="s2">'truncnorm'</span><span class="s0">, </span><span class="s2">'truncweibull_min'</span><span class="s1">]</span>

<span class="s3"># distxslow are sorted by speed (very slow to slow)</span>
<span class="s1">distxslow = [</span><span class="s2">'studentized_range'</span><span class="s0">, </span><span class="s2">'kstwo'</span><span class="s0">, </span><span class="s2">'ksone'</span><span class="s0">, </span><span class="s2">'wrapcauchy'</span><span class="s0">, </span><span class="s2">'genexpon'</span><span class="s1">]</span>

<span class="s3"># For skipping test_moments, which is already marked slow</span>
<span class="s1">distxslow_test_moments = [</span><span class="s2">'studentized_range'</span><span class="s0">, </span><span class="s2">'vonmises'</span><span class="s0">, </span><span class="s2">'vonmises_line'</span><span class="s0">,</span>
                          <span class="s2">'ksone'</span><span class="s0">, </span><span class="s2">'kstwo'</span><span class="s0">, </span><span class="s2">'recipinvgauss'</span><span class="s0">, </span><span class="s2">'genexpon'</span><span class="s1">]</span>

<span class="s3"># skip check_fit_args (test is slow)</span>
<span class="s1">skip_fit_test_mle = [</span><span class="s2">'exponpow'</span><span class="s0">, </span><span class="s2">'exponweib'</span><span class="s0">, </span><span class="s2">'gausshyper'</span><span class="s0">, </span><span class="s2">'genexpon'</span><span class="s0">,</span>
                     <span class="s2">'halfgennorm'</span><span class="s0">, </span><span class="s2">'gompertz'</span><span class="s0">, </span><span class="s2">'johnsonsb'</span><span class="s0">, </span><span class="s2">'johnsonsu'</span><span class="s0">,</span>
                     <span class="s2">'kappa4'</span><span class="s0">, </span><span class="s2">'ksone'</span><span class="s0">, </span><span class="s2">'kstwo'</span><span class="s0">, </span><span class="s2">'kstwobign'</span><span class="s0">, </span><span class="s2">'mielke'</span><span class="s0">, </span><span class="s2">'ncf'</span><span class="s0">,</span>
                     <span class="s2">'nct'</span><span class="s0">, </span><span class="s2">'powerlognorm'</span><span class="s0">, </span><span class="s2">'powernorm'</span><span class="s0">, </span><span class="s2">'recipinvgauss'</span><span class="s0">,</span>
                     <span class="s2">'trapezoid'</span><span class="s0">, </span><span class="s2">'vonmises'</span><span class="s0">, </span><span class="s2">'vonmises_line'</span><span class="s0">, </span><span class="s2">'levy_stable'</span><span class="s0">,</span>
                     <span class="s2">'rv_histogram_instance'</span><span class="s0">, </span><span class="s2">'studentized_range'</span><span class="s1">]</span>

<span class="s3"># these were really slow in `test_fit`.py.</span>
<span class="s3"># note that this list is used to skip both fit_test and fit_fix tests</span>
<span class="s1">slow_fit_test_mm = [</span><span class="s2">'argus'</span><span class="s0">, </span><span class="s2">'exponpow'</span><span class="s0">, </span><span class="s2">'exponweib'</span><span class="s0">, </span><span class="s2">'gausshyper'</span><span class="s0">, </span><span class="s2">'genexpon'</span><span class="s0">,</span>
                    <span class="s2">'genhalflogistic'</span><span class="s0">, </span><span class="s2">'halfgennorm'</span><span class="s0">, </span><span class="s2">'gompertz'</span><span class="s0">, </span><span class="s2">'johnsonsb'</span><span class="s0">,</span>
                    <span class="s2">'kappa4'</span><span class="s0">, </span><span class="s2">'kstwobign'</span><span class="s0">, </span><span class="s2">'recipinvgauss'</span><span class="s0">,</span>
                    <span class="s2">'trapezoid'</span><span class="s0">, </span><span class="s2">'truncexpon'</span><span class="s0">, </span><span class="s2">'vonmises'</span><span class="s0">, </span><span class="s2">'vonmises_line'</span><span class="s0">,</span>
                    <span class="s2">'studentized_range'</span><span class="s1">]</span>
<span class="s3"># pearson3 fails due to something weird</span>
<span class="s3"># the first list fails due to non-finite distribution moments encountered</span>
<span class="s3"># most of the rest fail due to integration warnings</span>
<span class="s3"># pearson3 is overriden as not implemented due to gh-11746</span>
<span class="s1">fail_fit_test_mm = ([</span><span class="s2">'alpha'</span><span class="s0">, </span><span class="s2">'betaprime'</span><span class="s0">, </span><span class="s2">'bradford'</span><span class="s0">, </span><span class="s2">'burr'</span><span class="s0">, </span><span class="s2">'burr12'</span><span class="s0">,</span>
                     <span class="s2">'cauchy'</span><span class="s0">, </span><span class="s2">'crystalball'</span><span class="s0">, </span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'fisk'</span><span class="s0">, </span><span class="s2">'foldcauchy'</span><span class="s0">,</span>
                     <span class="s2">'genextreme'</span><span class="s0">, </span><span class="s2">'genpareto'</span><span class="s0">, </span><span class="s2">'halfcauchy'</span><span class="s0">, </span><span class="s2">'invgamma'</span><span class="s0">,</span>
                     <span class="s2">'kappa3'</span><span class="s0">, </span><span class="s2">'levy'</span><span class="s0">, </span><span class="s2">'levy_l'</span><span class="s0">, </span><span class="s2">'loglaplace'</span><span class="s0">, </span><span class="s2">'lomax'</span><span class="s0">,</span>
                     <span class="s2">'mielke'</span><span class="s0">, </span><span class="s2">'nakagami'</span><span class="s0">, </span><span class="s2">'ncf'</span><span class="s0">, </span><span class="s2">'skewcauchy'</span><span class="s0">, </span><span class="s2">'t'</span><span class="s0">,</span>
                     <span class="s2">'tukeylambda'</span><span class="s0">, </span><span class="s2">'invweibull'</span><span class="s0">, </span><span class="s2">'rel_breitwigner'</span><span class="s1">]</span>
                     <span class="s1">+ [</span><span class="s2">'genhyperbolic'</span><span class="s0">, </span><span class="s2">'johnsonsu'</span><span class="s0">, </span><span class="s2">'ksone'</span><span class="s0">, </span><span class="s2">'kstwo'</span><span class="s0">,</span>
                        <span class="s2">'nct'</span><span class="s0">, </span><span class="s2">'pareto'</span><span class="s0">, </span><span class="s2">'powernorm'</span><span class="s0">, </span><span class="s2">'powerlognorm'</span><span class="s1">]</span>
                     <span class="s1">+ [</span><span class="s2">'pearson3'</span><span class="s1">])</span>

<span class="s1">skip_fit_test = {</span><span class="s2">&quot;MLE&quot;</span><span class="s1">: skip_fit_test_mle</span><span class="s0">,</span>
                 <span class="s2">&quot;MM&quot;</span><span class="s1">: slow_fit_test_mm + fail_fit_test_mm}</span>

<span class="s3"># skip check_fit_args_fix (test is slow)</span>
<span class="s1">skip_fit_fix_test_mle = [</span><span class="s2">'burr'</span><span class="s0">, </span><span class="s2">'exponpow'</span><span class="s0">, </span><span class="s2">'exponweib'</span><span class="s0">, </span><span class="s2">'gausshyper'</span><span class="s0">,</span>
                         <span class="s2">'genexpon'</span><span class="s0">, </span><span class="s2">'halfgennorm'</span><span class="s0">, </span><span class="s2">'gompertz'</span><span class="s0">, </span><span class="s2">'johnsonsb'</span><span class="s0">,</span>
                         <span class="s2">'johnsonsu'</span><span class="s0">, </span><span class="s2">'kappa4'</span><span class="s0">, </span><span class="s2">'ksone'</span><span class="s0">, </span><span class="s2">'kstwo'</span><span class="s0">, </span><span class="s2">'kstwobign'</span><span class="s0">,</span>
                         <span class="s2">'levy_stable'</span><span class="s0">, </span><span class="s2">'mielke'</span><span class="s0">, </span><span class="s2">'ncf'</span><span class="s0">, </span><span class="s2">'ncx2'</span><span class="s0">,</span>
                         <span class="s2">'powerlognorm'</span><span class="s0">, </span><span class="s2">'powernorm'</span><span class="s0">, </span><span class="s2">'rdist'</span><span class="s0">, </span><span class="s2">'recipinvgauss'</span><span class="s0">,</span>
                         <span class="s2">'trapezoid'</span><span class="s0">, </span><span class="s2">'truncpareto'</span><span class="s0">, </span><span class="s2">'vonmises'</span><span class="s0">, </span><span class="s2">'vonmises_line'</span><span class="s0">,</span>
                         <span class="s2">'studentized_range'</span><span class="s1">]</span>
<span class="s3"># the first list fails due to non-finite distribution moments encountered</span>
<span class="s3"># most of the rest fail due to integration warnings</span>
<span class="s3"># pearson3 is overriden as not implemented due to gh-11746</span>
<span class="s1">fail_fit_fix_test_mm = ([</span><span class="s2">'alpha'</span><span class="s0">, </span><span class="s2">'betaprime'</span><span class="s0">, </span><span class="s2">'burr'</span><span class="s0">, </span><span class="s2">'burr12'</span><span class="s0">, </span><span class="s2">'cauchy'</span><span class="s0">,</span>
                         <span class="s2">'crystalball'</span><span class="s0">, </span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'fisk'</span><span class="s0">, </span><span class="s2">'foldcauchy'</span><span class="s0">,</span>
                         <span class="s2">'genextreme'</span><span class="s0">, </span><span class="s2">'genpareto'</span><span class="s0">, </span><span class="s2">'halfcauchy'</span><span class="s0">, </span><span class="s2">'invgamma'</span><span class="s0">,</span>
                         <span class="s2">'kappa3'</span><span class="s0">, </span><span class="s2">'levy'</span><span class="s0">, </span><span class="s2">'levy_l'</span><span class="s0">, </span><span class="s2">'loglaplace'</span><span class="s0">, </span><span class="s2">'lomax'</span><span class="s0">,</span>
                         <span class="s2">'mielke'</span><span class="s0">, </span><span class="s2">'nakagami'</span><span class="s0">, </span><span class="s2">'ncf'</span><span class="s0">, </span><span class="s2">'nct'</span><span class="s0">, </span><span class="s2">'skewcauchy'</span><span class="s0">, </span><span class="s2">'t'</span><span class="s0">,</span>
                         <span class="s2">'truncpareto'</span><span class="s0">, </span><span class="s2">'invweibull'</span><span class="s1">]</span>
                        <span class="s1">+ [</span><span class="s2">'genhyperbolic'</span><span class="s0">, </span><span class="s2">'johnsonsu'</span><span class="s0">, </span><span class="s2">'ksone'</span><span class="s0">, </span><span class="s2">'kstwo'</span><span class="s0">,</span>
                           <span class="s2">'pareto'</span><span class="s0">, </span><span class="s2">'powernorm'</span><span class="s0">, </span><span class="s2">'powerlognorm'</span><span class="s1">]</span>
                        <span class="s1">+ [</span><span class="s2">'pearson3'</span><span class="s1">])</span>
<span class="s1">skip_fit_fix_test = {</span><span class="s2">&quot;MLE&quot;</span><span class="s1">: skip_fit_fix_test_mle</span><span class="s0">,</span>
                     <span class="s2">&quot;MM&quot;</span><span class="s1">: slow_fit_test_mm + fail_fit_fix_test_mm}</span>

<span class="s3"># These distributions fail the complex derivative test below.</span>
<span class="s3"># Here 'fail' mean produce wrong results and/or raise exceptions, depending</span>
<span class="s3"># on the implementation details of corresponding special functions.</span>
<span class="s3"># cf https://github.com/scipy/scipy/pull/4979 for a discussion.</span>
<span class="s1">fails_cmplx = {</span><span class="s2">'argus'</span><span class="s0">, </span><span class="s2">'beta'</span><span class="s0">, </span><span class="s2">'betaprime'</span><span class="s0">, </span><span class="s2">'chi'</span><span class="s0">, </span><span class="s2">'chi2'</span><span class="s0">, </span><span class="s2">'cosine'</span><span class="s0">,</span>
               <span class="s2">'dgamma'</span><span class="s0">, </span><span class="s2">'dweibull'</span><span class="s0">, </span><span class="s2">'erlang'</span><span class="s0">, </span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'foldcauchy'</span><span class="s0">, </span><span class="s2">'gamma'</span><span class="s0">,</span>
               <span class="s2">'gausshyper'</span><span class="s0">, </span><span class="s2">'gengamma'</span><span class="s0">, </span><span class="s2">'genhyperbolic'</span><span class="s0">,</span>
               <span class="s2">'geninvgauss'</span><span class="s0">, </span><span class="s2">'gennorm'</span><span class="s0">, </span><span class="s2">'genpareto'</span><span class="s0">,</span>
               <span class="s2">'halfcauchy'</span><span class="s0">, </span><span class="s2">'halfgennorm'</span><span class="s0">, </span><span class="s2">'invgamma'</span><span class="s0">,</span>
               <span class="s2">'ksone'</span><span class="s0">, </span><span class="s2">'kstwo'</span><span class="s0">, </span><span class="s2">'kstwobign'</span><span class="s0">, </span><span class="s2">'levy_l'</span><span class="s0">, </span><span class="s2">'loggamma'</span><span class="s0">,</span>
               <span class="s2">'logistic'</span><span class="s0">, </span><span class="s2">'loguniform'</span><span class="s0">, </span><span class="s2">'maxwell'</span><span class="s0">, </span><span class="s2">'nakagami'</span><span class="s0">,</span>
               <span class="s2">'ncf'</span><span class="s0">, </span><span class="s2">'nct'</span><span class="s0">, </span><span class="s2">'ncx2'</span><span class="s0">, </span><span class="s2">'norminvgauss'</span><span class="s0">, </span><span class="s2">'pearson3'</span><span class="s0">,</span>
               <span class="s2">'powerlaw'</span><span class="s0">, </span><span class="s2">'rdist'</span><span class="s0">, </span><span class="s2">'reciprocal'</span><span class="s0">, </span><span class="s2">'rice'</span><span class="s0">,</span>
               <span class="s2">'skewnorm'</span><span class="s0">, </span><span class="s2">'t'</span><span class="s0">, </span><span class="s2">'truncweibull_min'</span><span class="s0">,</span>
               <span class="s2">'tukeylambda'</span><span class="s0">, </span><span class="s2">'vonmises'</span><span class="s0">, </span><span class="s2">'vonmises_line'</span><span class="s0">,</span>
               <span class="s2">'rv_histogram_instance'</span><span class="s0">, </span><span class="s2">'truncnorm'</span><span class="s0">, </span><span class="s2">'studentized_range'</span><span class="s0">,</span>
               <span class="s2">'johnsonsb'</span><span class="s0">, </span><span class="s2">'halflogistic'</span><span class="s0">, </span><span class="s2">'rel_breitwigner'</span><span class="s1">}</span>


<span class="s3"># rv_histogram instances, with uniform and non-uniform bins;</span>
<span class="s3"># stored as (dist, arg) tuples for cases_test_cont_basic</span>
<span class="s3"># and cases_test_moments.</span>
<span class="s1">histogram_test_instances = []</span>
<span class="s1">case1 = {</span><span class="s2">'a'</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s0">,</span>
               <span class="s4">6</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">9</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'bins'</span><span class="s1">: </span><span class="s4">8</span><span class="s1">}  </span><span class="s3"># equal width bins</span>
<span class="s1">case2 = {</span><span class="s2">'a'</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'bins'</span><span class="s1">: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">10</span><span class="s1">]}  </span><span class="s3"># unequal width bins</span>
<span class="s0">for </span><span class="s1">case</span><span class="s0">, </span><span class="s1">density </span><span class="s0">in </span><span class="s1">itertools.product([case1</span><span class="s0">, </span><span class="s1">case2]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]):</span>
    <span class="s1">_hist = np.histogram(**case</span><span class="s0">, </span><span class="s1">density=density)</span>
    <span class="s1">_rv_hist = stats.rv_histogram(_hist</span><span class="s0">, </span><span class="s1">density=density)</span>
    <span class="s1">histogram_test_instances.append((_rv_hist</span><span class="s0">, </span><span class="s1">tuple()))</span>


<span class="s0">def </span><span class="s1">cases_test_cont_basic():</span>
    <span class="s0">for </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">distcont[:] + histogram_test_instances:</span>
        <span class="s0">if </span><span class="s1">distname == </span><span class="s2">'levy_stable'</span><span class="s1">:</span>
            <span class="s0">continue</span>
        <span class="s0">elif </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">distslow:</span>
            <span class="s0">yield </span><span class="s1">pytest.param(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">marks=pytest.mark.slow)</span>
        <span class="s0">elif </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">distxslow:</span>
            <span class="s0">yield </span><span class="s1">pytest.param(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">marks=pytest.mark.xslow)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">arg</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'distname,arg'</span><span class="s0">, </span><span class="s1">cases_test_cont_basic())</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'sn, n_fit_samples'</span><span class="s0">, </span><span class="s1">[(</span><span class="s4">500</span><span class="s0">, </span><span class="s4">200</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_cont_basic(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">sn</span><span class="s0">, </span><span class="s1">n_fit_samples):</span>
    <span class="s3"># this test skips slow distributions</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">distfn = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">distfn = distname</span>
        <span class="s1">distname = </span><span class="s2">'rv_histogram_instance'</span>

    <span class="s1">rng = np.random.RandomState(</span><span class="s4">765456</span><span class="s1">)</span>
    <span class="s1">rvs = distfn.rvs(size=sn</span><span class="s0">, </span><span class="s1">*arg</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
    <span class="s1">m</span><span class="s0">, </span><span class="s1">v = distfn.stats(*arg)</span>

    <span class="s0">if </span><span class="s1">distname </span><span class="s0">not in </span><span class="s1">{</span><span class="s2">'laplace_asymmetric'</span><span class="s1">}:</span>
        <span class="s1">check_sample_meanvar_(m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">rvs)</span>
    <span class="s1">check_cdf_ppf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_sf_isf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_pdf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_pdf_logpdf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_pdf_logpdf_at_endpoints(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_cdf_logcdf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_sf_logsf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_ppf_broadcast(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>

    <span class="s1">alpha = </span><span class="s4">0.01</span>
    <span class="s0">if </span><span class="s1">distname == </span><span class="s2">'rv_histogram_instance'</span><span class="s1">:</span>
        <span class="s1">check_distribution_rvs(distfn.cdf</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">rvs)</span>
    <span class="s0">elif </span><span class="s1">distname != </span><span class="s2">'geninvgauss'</span><span class="s1">:</span>
        <span class="s3"># skip kstest for geninvgauss since cdf is too slow; see test for</span>
        <span class="s3"># rv generation in TestGenInvGauss in test_distributions.py</span>
        <span class="s1">check_distribution_rvs(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">rvs)</span>

    <span class="s1">locscale_defaults = (</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">meths = [distfn.pdf</span><span class="s0">, </span><span class="s1">distfn.logpdf</span><span class="s0">, </span><span class="s1">distfn.cdf</span><span class="s0">, </span><span class="s1">distfn.logcdf</span><span class="s0">,</span>
             <span class="s1">distfn.logsf]</span>
    <span class="s3"># make sure arguments are within support</span>
    <span class="s1">spec_x = {</span><span class="s2">'weibull_max'</span><span class="s1">: -</span><span class="s4">0.5</span><span class="s0">, </span><span class="s2">'levy_l'</span><span class="s1">: -</span><span class="s4">0.5</span><span class="s0">,</span>
              <span class="s2">'pareto'</span><span class="s1">: </span><span class="s4">1.5</span><span class="s0">, </span><span class="s2">'truncpareto'</span><span class="s1">: </span><span class="s4">3.2</span><span class="s0">, </span><span class="s2">'tukeylambda'</span><span class="s1">: </span><span class="s4">0.3</span><span class="s0">,</span>
              <span class="s2">'rv_histogram_instance'</span><span class="s1">: </span><span class="s4">5.0</span><span class="s1">}</span>
    <span class="s1">x = spec_x.get(distname</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">distname == </span><span class="s2">'invweibull'</span><span class="s1">:</span>
        <span class="s1">arg = (</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">distname == </span><span class="s2">'ksone'</span><span class="s1">:</span>
        <span class="s1">arg = (</span><span class="s4">3</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">check_named_args(distfn</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">locscale_defaults</span><span class="s0">, </span><span class="s1">meths)</span>
    <span class="s1">check_random_state_property(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

    <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'rel_breitwigner'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">_IS_32BIT:</span>
        <span class="s3"># gh18414</span>
        <span class="s1">pytest.skip(</span><span class="s2">&quot;fails on Linux 32-bit&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">check_pickling(distfn</span><span class="s0">, </span><span class="s1">arg)</span>
    <span class="s1">check_freezing(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

    <span class="s3"># Entropy</span>
    <span class="s0">if </span><span class="s1">distname </span><span class="s0">not in </span><span class="s1">[</span><span class="s2">'kstwobign'</span><span class="s0">, </span><span class="s2">'kstwo'</span><span class="s0">, </span><span class="s2">'ncf'</span><span class="s1">]:</span>
        <span class="s1">check_entropy(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>

    <span class="s0">if </span><span class="s1">distfn.numargs == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">check_vecentropy(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

    <span class="s0">if </span><span class="s1">(distfn.__class__._entropy != stats.rv_continuous._entropy</span>
            <span class="s0">and </span><span class="s1">distname != </span><span class="s2">'vonmises'</span><span class="s1">):</span>
        <span class="s1">check_private_entropy(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">stats.rv_continuous)</span>

    <span class="s0">with </span><span class="s1">npt.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(IntegrationWarning</span><span class="s0">, </span><span class="s2">&quot;The occurrence of roundoff error&quot;</span><span class="s1">)</span>
        <span class="s1">sup.filter(IntegrationWarning</span><span class="s0">, </span><span class="s2">&quot;Extremely bad integrand&quot;</span><span class="s1">)</span>
        <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s2">&quot;invalid value&quot;</span><span class="s1">)</span>
        <span class="s1">check_entropy_vect_scale(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

    <span class="s1">check_retrieving_support(distfn</span><span class="s0">, </span><span class="s1">arg)</span>
    <span class="s1">check_edge_support(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

    <span class="s1">check_meth_dtype(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">meths)</span>
    <span class="s1">check_ppf_dtype(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

    <span class="s0">if </span><span class="s1">distname </span><span class="s0">not in </span><span class="s1">fails_cmplx:</span>
        <span class="s1">check_cmplx_deriv(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

    <span class="s0">if </span><span class="s1">distname != </span><span class="s2">'truncnorm'</span><span class="s1">:</span>
        <span class="s1">check_ppf_private(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>

    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;MLE&quot;</span><span class="s0">, </span><span class="s2">&quot;MM&quot;</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">distname </span><span class="s0">not in </span><span class="s1">skip_fit_test[method]:</span>
            <span class="s1">check_fit_args(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">rvs[:n_fit_samples]</span><span class="s0">, </span><span class="s1">method)</span>

        <span class="s0">if </span><span class="s1">distname </span><span class="s0">not in </span><span class="s1">skip_fit_fix_test[method]:</span>
            <span class="s1">check_fit_args_fix(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">rvs[:n_fit_samples]</span><span class="s0">, </span><span class="s1">method)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'distname,arg'</span><span class="s0">, </span><span class="s1">cases_test_cont_basic())</span>
<span class="s0">def </span><span class="s1">test_rvs_scalar(distname</span><span class="s0">, </span><span class="s1">arg):</span>
    <span class="s3"># rvs should return a scalar when given scalar arguments (gh-12428)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">distfn = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">distfn = distname</span>
        <span class="s1">distname = </span><span class="s2">'rv_histogram_instance'</span>

    <span class="s0">assert </span><span class="s1">np.isscalar(distfn.rvs(*arg))</span>
    <span class="s0">assert </span><span class="s1">np.isscalar(distfn.rvs(*arg</span><span class="s0">, </span><span class="s1">size=()))</span>
    <span class="s0">assert </span><span class="s1">np.isscalar(distfn.rvs(*arg</span><span class="s0">, </span><span class="s1">size=</span><span class="s0">None</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_levy_stable_random_state_property():</span>
    <span class="s3"># levy_stable only implements rvs(), so it is skipped in the</span>
    <span class="s3"># main loop in test_cont_basic(). Here we apply just the test</span>
    <span class="s3"># check_random_state_property to levy_stable.</span>
    <span class="s1">check_random_state_property(stats.levy_stable</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">cases_test_moments():</span>
    <span class="s1">fail_normalization = set()</span>
    <span class="s1">fail_higher = {</span><span class="s2">'ncf'</span><span class="s1">}</span>
    <span class="s1">fail_moment = {</span><span class="s2">'johnsonsu'</span><span class="s1">}  </span><span class="s3"># generic `munp` is inaccurate for johnsonsu</span>

    <span class="s0">for </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">distcont[:] + histogram_test_instances:</span>
        <span class="s0">if </span><span class="s1">distname == </span><span class="s2">'levy_stable'</span><span class="s1">:</span>
            <span class="s0">continue</span>

        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">distxslow_test_moments:</span>
            <span class="s0">yield </span><span class="s1">pytest.param(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, True, True, True, True,</span>
                               <span class="s1">marks=pytest.mark.xslow(reason=</span><span class="s2">&quot;too slow&quot;</span><span class="s1">))</span>
            <span class="s0">continue</span>

        <span class="s1">cond1 = distname </span><span class="s0">not in </span><span class="s1">fail_normalization</span>
        <span class="s1">cond2 = distname </span><span class="s0">not in </span><span class="s1">fail_higher</span>
        <span class="s1">cond3 = distname </span><span class="s0">not in </span><span class="s1">fail_moment</span>

        <span class="s1">marks = list()</span>
        <span class="s3"># Currently unused, `marks` can be used to add a timeout to a test of</span>
        <span class="s3"># a specific distribution.  For example, this shows how a timeout could</span>
        <span class="s3"># be added for the 'skewnorm' distribution:</span>
        <span class="s3">#</span>
        <span class="s3">#     marks = list()</span>
        <span class="s3">#     if distname == 'skewnorm':</span>
        <span class="s3">#         marks.append(pytest.mark.timeout(300))</span>

        <span class="s0">yield </span><span class="s1">pytest.param(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">cond1</span><span class="s0">, </span><span class="s1">cond2</span><span class="s0">, </span><span class="s1">cond3</span><span class="s0">,</span>
                           <span class="s0">False, </span><span class="s1">marks=marks)</span>

        <span class="s0">if not </span><span class="s1">cond1 </span><span class="s0">or not </span><span class="s1">cond2 </span><span class="s0">or not </span><span class="s1">cond3:</span>
            <span class="s3"># Run the distributions that have issues twice, once skipping the</span>
            <span class="s3"># not_ok parts, once with the not_ok parts but marked as knownfail</span>
            <span class="s0">yield </span><span class="s1">pytest.param(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, True, True, True, True,</span>
                               <span class="s1">marks=[pytest.mark.xfail] + marks)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'distname,arg,normalization_ok,higher_ok,moment_ok,'</span>
                         <span class="s2">'is_xfailing'</span><span class="s0">,</span>
                         <span class="s1">cases_test_moments())</span>
<span class="s0">def </span><span class="s1">test_moments(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">normalization_ok</span><span class="s0">, </span><span class="s1">higher_ok</span><span class="s0">, </span><span class="s1">moment_ok</span><span class="s0">,</span>
                 <span class="s1">is_xfailing):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">distfn = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">distfn = distname</span>
        <span class="s1">distname = </span><span class="s2">'rv_histogram_instance'</span>

    <span class="s0">with </span><span class="s1">npt.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(IntegrationWarning</span><span class="s0">,</span>
                   <span class="s2">&quot;The integral is probably divergent, or slowly convergent.&quot;</span><span class="s1">)</span>
        <span class="s1">sup.filter(IntegrationWarning</span><span class="s0">,</span>
                   <span class="s2">&quot;The maximum number of subdivisions.&quot;</span><span class="s1">)</span>
        <span class="s1">sup.filter(IntegrationWarning</span><span class="s0">,</span>
                   <span class="s2">&quot;The algorithm does not converge.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">is_xfailing:</span>
            <span class="s1">sup.filter(IntegrationWarning)</span>

        <span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">k = distfn.stats(*arg</span><span class="s0">, </span><span class="s1">moments=</span><span class="s2">'mvsk'</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">normalization_ok:</span>
                <span class="s1">check_normalization(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>

            <span class="s0">if </span><span class="s1">higher_ok:</span>
                <span class="s1">check_mean_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">distname)</span>
                <span class="s1">check_skew_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">distname)</span>
                <span class="s1">check_var_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">distname)</span>
                <span class="s1">check_kurt_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">distname)</span>
                <span class="s1">check_munp_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>

        <span class="s1">check_loc_scale(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">distname)</span>

        <span class="s0">if </span><span class="s1">moment_ok:</span>
            <span class="s1">check_moment(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">distname)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'dist,shape_args'</span><span class="s0">, </span><span class="s1">distcont)</span>
<span class="s0">def </span><span class="s1">test_rvs_broadcast(dist</span><span class="s0">, </span><span class="s1">shape_args):</span>
    <span class="s0">if </span><span class="s1">dist </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'gausshyper'</span><span class="s0">, </span><span class="s2">'studentized_range'</span><span class="s1">]:</span>
        <span class="s1">pytest.skip(</span><span class="s2">&quot;too slow&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">dist </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'rel_breitwigner'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">_IS_32BIT:</span>
        <span class="s3"># gh18414</span>
        <span class="s1">pytest.skip(</span><span class="s2">&quot;fails on Linux 32-bit&quot;</span><span class="s1">)</span>

    <span class="s3"># If shape_only is True, it means the _rvs method of the</span>
    <span class="s3"># distribution uses more than one random number to generate a random</span>
    <span class="s3"># variate.  That means the result of using rvs with broadcasting or</span>
    <span class="s3"># with a nontrivial size will not necessarily be the same as using the</span>
    <span class="s3"># numpy.vectorize'd version of rvs(), so we can only compare the shapes</span>
    <span class="s3"># of the results, not the values.</span>
    <span class="s3"># Whether or not a distribution is in the following list is an</span>
    <span class="s3"># implementation detail of the distribution, not a requirement.  If</span>
    <span class="s3"># the implementation the rvs() method of a distribution changes, this</span>
    <span class="s3"># test might also have to be changed.</span>
    <span class="s1">shape_only = dist </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'argus'</span><span class="s0">, </span><span class="s2">'betaprime'</span><span class="s0">, </span><span class="s2">'dgamma'</span><span class="s0">, </span><span class="s2">'dweibull'</span><span class="s0">,</span>
                          <span class="s2">'exponnorm'</span><span class="s0">, </span><span class="s2">'genhyperbolic'</span><span class="s0">, </span><span class="s2">'geninvgauss'</span><span class="s0">,</span>
                          <span class="s2">'levy_stable'</span><span class="s0">, </span><span class="s2">'nct'</span><span class="s0">, </span><span class="s2">'norminvgauss'</span><span class="s0">, </span><span class="s2">'rice'</span><span class="s0">,</span>
                          <span class="s2">'skewnorm'</span><span class="s0">, </span><span class="s2">'semicircular'</span><span class="s0">, </span><span class="s2">'gennorm'</span><span class="s0">, </span><span class="s2">'loggamma'</span><span class="s1">]</span>

    <span class="s1">distfunc = getattr(stats</span><span class="s0">, </span><span class="s1">dist)</span>
    <span class="s1">loc = np.zeros(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">scale = np.ones((</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">nargs = distfunc.numargs</span>
    <span class="s1">allargs = []</span>
    <span class="s1">bshape = [</span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>
    <span class="s3"># Generate shape parameter arguments...</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(nargs):</span>
        <span class="s1">shp = (k + </span><span class="s4">4</span><span class="s0">,</span><span class="s1">) + (</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)*(k + </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">allargs.append(shape_args[k]*np.ones(shp))</span>
        <span class="s1">bshape.insert(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">k + </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">allargs.extend([loc</span><span class="s0">, </span><span class="s1">scale])</span>
    <span class="s3"># bshape holds the expected shape when loc, scale, and the shape</span>
    <span class="s3"># parameters are all broadcast together.</span>

    <span class="s1">check_rvs_broadcast(distfunc</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">allargs</span><span class="s0">, </span><span class="s1">bshape</span><span class="s0">, </span><span class="s1">shape_only</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">)</span>


<span class="s3"># Expected values of the SF, CDF, PDF were computed using</span>
<span class="s3"># mpmath with mpmath.mp.dps = 50 and output at 20:</span>
<span class="s3">#</span>
<span class="s3"># def ks(x, n):</span>
<span class="s3">#     x = mpmath.mpf(x)</span>
<span class="s3">#     logp = -mpmath.power(6.0*n*x+1.0, 2)/18.0/n</span>
<span class="s3">#     sf, cdf = mpmath.exp(logp), -mpmath.expm1(logp)</span>
<span class="s3">#     pdf = (6.0*n*x+1.0) * 2 * sf/3</span>
<span class="s3">#     print(mpmath.nstr(sf, 20), mpmath.nstr(cdf, 20), mpmath.nstr(pdf, 20))</span>
<span class="s3">#</span>
<span class="s3"># Tests use 1/n &lt; x &lt; 1-1/n and n &gt; 1e6 to use the asymptotic computation.</span>
<span class="s3"># Larger x has a smaller sf.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'x,n,sf,cdf,pdf,rtol'</span><span class="s0">,</span>
                         <span class="s1">[(</span><span class="s4">2.0e-5</span><span class="s0">, </span><span class="s4">1000000000</span><span class="s0">,</span>
                           <span class="s4">0.44932297307934442379</span><span class="s0">, </span><span class="s4">0.55067702692065557621</span><span class="s0">,</span>
                           <span class="s4">35946.137394996276407</span><span class="s0">, </span><span class="s4">5e-15</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">(</span><span class="s4">2.0e-9</span><span class="s0">, </span><span class="s4">1000000000</span><span class="s0">,</span>
                           <span class="s4">0.99999999061111115519</span><span class="s0">, </span><span class="s4">9.3888888448132728224e-9</span><span class="s0">,</span>
                           <span class="s4">8.6666665852962971765</span><span class="s0">, </span><span class="s4">5e-14</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">(</span><span class="s4">5.0e-4</span><span class="s0">, </span><span class="s4">1000000000</span><span class="s0">,</span>
                           <span class="s4">7.1222019433090374624e-218</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">,</span>
                           <span class="s4">1.4244408634752704094e-211</span><span class="s0">, </span><span class="s4">5e-14</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_gh17775_regression(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">sf</span><span class="s0">, </span><span class="s1">cdf</span><span class="s0">, </span><span class="s1">pdf</span><span class="s0">, </span><span class="s1">rtol):</span>
    <span class="s3"># Regression test for gh-17775. In scipy 1.9.3 and earlier,</span>
    <span class="s3"># these test would fail.</span>
    <span class="s3">#</span>
    <span class="s3"># KS one asymptotic sf ~ e^(-(6nx+1)^2 / 18n)</span>
    <span class="s3"># Given a large 32-bit integer n, 6n will overflow in the c implementation.</span>
    <span class="s3"># Example of broken behaviour:</span>
    <span class="s3"># ksone.sf(2.0e-5, 1000000000) == 0.9374359693473666</span>
    <span class="s1">ks = stats.ksone</span>
    <span class="s1">vals = np.array([ks.sf(x</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">ks.cdf(x</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">ks.pdf(x</span><span class="s0">, </span><span class="s1">n)])</span>
    <span class="s1">expected = np.array([sf</span><span class="s0">, </span><span class="s1">cdf</span><span class="s0">, </span><span class="s1">pdf])</span>
    <span class="s1">npt.assert_allclose(vals</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>
    <span class="s3"># The sf+cdf must sum to 1.0.</span>
    <span class="s1">npt.assert_equal(vals[</span><span class="s4">0</span><span class="s1">] + vals[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s3"># Check inverting the (potentially very small) sf (uses a lower tolerance)</span>
    <span class="s1">npt.assert_allclose([ks.isf(sf</span><span class="s0">, </span><span class="s1">n)]</span><span class="s0">, </span><span class="s1">[x]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_rvs_gh2069_regression():</span>
    <span class="s3"># Regression tests for gh-2069.  In scipy 0.17 and earlier,</span>
    <span class="s3"># these tests would fail.</span>
    <span class="s3">#</span>
    <span class="s3"># A typical example of the broken behavior:</span>
    <span class="s3"># &gt;&gt;&gt; norm.rvs(loc=np.zeros(5), scale=np.ones(5))</span>
    <span class="s3"># array([-2.49613705, -2.49613705, -2.49613705, -2.49613705, -2.49613705])</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">123</span><span class="s1">)</span>
    <span class="s1">vals = stats.norm.rvs(loc=np.zeros(</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
    <span class="s1">d = np.diff(vals)</span>
    <span class="s1">npt.assert_(np.all(d != </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;All the values are equal, but they shouldn't be!&quot;</span><span class="s1">)</span>
    <span class="s1">vals = stats.norm.rvs(loc=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">scale=np.ones(</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
    <span class="s1">d = np.diff(vals)</span>
    <span class="s1">npt.assert_(np.all(d != </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;All the values are equal, but they shouldn't be!&quot;</span><span class="s1">)</span>
    <span class="s1">vals = stats.norm.rvs(loc=np.zeros(</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">scale=np.ones(</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
    <span class="s1">d = np.diff(vals)</span>
    <span class="s1">npt.assert_(np.all(d != </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;All the values are equal, but they shouldn't be!&quot;</span><span class="s1">)</span>
    <span class="s1">vals = stats.norm.rvs(loc=np.array([[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">scale=np.ones(</span><span class="s4">5</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">random_state=rng)</span>
    <span class="s1">d = np.diff(vals.ravel())</span>
    <span class="s1">npt.assert_(np.all(d != </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;All the values are equal, but they shouldn't be!&quot;</span><span class="s1">)</span>

    <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">stats.norm.rvs</span><span class="s0">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s0">,</span>
                  <span class="s1">[[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">stats.gamma.rvs</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">stats.gamma.rvs</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">[[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">4</span><span class="s0">,</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_nomodify_gh9900_regression():</span>
    <span class="s3"># Regression test for gh-9990</span>
    <span class="s3"># Prior to gh-9990, calls to stats.truncnorm._cdf() use what ever was</span>
    <span class="s3"># set inside the stats.truncnorm instance during stats.truncnorm.cdf().</span>
    <span class="s3"># This could cause issues wth multi-threaded code.</span>
    <span class="s3"># Since then, the calls to cdf() are not permitted to modify the global</span>
    <span class="s3"># stats.truncnorm instance.</span>
    <span class="s1">tn = stats.truncnorm</span>
    <span class="s3"># Use the right-half truncated normal</span>
    <span class="s3"># Check that the cdf and _cdf return the same result.</span>
    <span class="s1">npt.assert_almost_equal(tn.cdf(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s4">0.6826894921370859</span><span class="s1">)</span>
    <span class="s1">npt.assert_almost_equal(tn._cdf([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.inf])</span><span class="s0">, </span><span class="s4">0.6826894921370859</span><span class="s1">)</span>

    <span class="s3"># Now use the left-half truncated normal</span>
    <span class="s1">npt.assert_almost_equal(tn.cdf(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0.31731050786291415</span><span class="s1">)</span>
    <span class="s1">npt.assert_almost_equal(tn._cdf([-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-np.inf]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">, </span><span class="s4">0.31731050786291415</span><span class="s1">)</span>

    <span class="s3"># Check that the right-half truncated normal _cdf hasn't changed</span>
    <span class="s1">npt.assert_almost_equal(tn._cdf([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.inf])</span><span class="s0">, </span><span class="s4">0.6826894921370859</span><span class="s1">)  </span><span class="s3"># noqa, NOT 1.6826894921370859</span>
    <span class="s1">npt.assert_almost_equal(tn.cdf(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s4">0.6826894921370859</span><span class="s1">)</span>

    <span class="s3"># Check that the left-half truncated normal _cdf hasn't changed</span>
    <span class="s1">npt.assert_almost_equal(tn._cdf([-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-np.inf]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">, </span><span class="s4">0.31731050786291415</span><span class="s1">)  </span><span class="s3"># noqa, Not -0.6826894921370859</span>
    <span class="s1">npt.assert_almost_equal(tn.cdf(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)                     </span><span class="s3"># Not 1.6826894921370859</span>
    <span class="s1">npt.assert_almost_equal(tn.cdf(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0.31731050786291415</span><span class="s1">)  </span><span class="s3"># Not -0.6826894921370859</span>


<span class="s0">def </span><span class="s1">test_broadcast_gh9990_regression():</span>
    <span class="s3"># Regression test for gh-9990</span>
    <span class="s3"># The x-value 7 only lies within the support of 4 of the supplied</span>
    <span class="s3"># distributions.  Prior to 9990, one array passed to</span>
    <span class="s3"># stats.reciprocal._cdf would have 4 elements, but an array</span>
    <span class="s3"># previously stored by stats.reciprocal_argcheck() would have 6, leading</span>
    <span class="s3"># to a broadcast error.</span>
    <span class="s1">a = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">])</span>
    <span class="s1">b = np.array([</span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">48</span><span class="s1">])</span>
    <span class="s1">ans = [stats.reciprocal.cdf(</span><span class="s4">7</span><span class="s0">, </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">_b) </span><span class="s0">for </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">_b </span><span class="s0">in </span><span class="s1">zip(a</span><span class="s0">,</span><span class="s1">b)]</span>
    <span class="s1">npt.assert_array_almost_equal(stats.reciprocal.cdf(</span><span class="s4">7</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">ans)</span>

    <span class="s1">ans = [stats.reciprocal.cdf(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">_b) </span><span class="s0">for </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">_b </span><span class="s0">in </span><span class="s1">zip(a</span><span class="s0">,</span><span class="s1">b)]</span>
    <span class="s1">npt.assert_array_almost_equal(stats.reciprocal.cdf(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">ans)</span>

    <span class="s1">ans = [stats.reciprocal.cdf(_a</span><span class="s0">, </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">_b) </span><span class="s0">for </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">_b </span><span class="s0">in </span><span class="s1">zip(a</span><span class="s0">,</span><span class="s1">b)]</span>
    <span class="s1">npt.assert_array_almost_equal(stats.reciprocal.cdf(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">ans)</span>

    <span class="s1">ans = [stats.reciprocal.cdf(_b</span><span class="s0">, </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">_b) </span><span class="s0">for </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">_b </span><span class="s0">in </span><span class="s1">zip(a</span><span class="s0">,</span><span class="s1">b)]</span>
    <span class="s1">npt.assert_array_almost_equal(stats.reciprocal.cdf(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">ans)</span>


<span class="s0">def </span><span class="s1">test_broadcast_gh7933_regression():</span>
    <span class="s3"># Check broadcast works</span>
    <span class="s1">stats.truncnorm.logpdf(</span>
        <span class="s1">np.array([</span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">a=(</span><span class="s4">1.5 </span><span class="s1">- np.array([</span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s1">])) / </span><span class="s4">3.0</span><span class="s0">,</span>
        <span class="s1">b=np.inf</span><span class="s0">,</span>
        <span class="s1">loc=np.array([</span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">scale=</span><span class="s4">3.0</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_gh2002_regression():</span>
    <span class="s3"># Add a check that broadcast works in situations where only some</span>
    <span class="s3"># x-values are compatible with some of the shape arguments.</span>
    <span class="s1">x = np.r_[-</span><span class="s4">2</span><span class="s1">:</span><span class="s4">2</span><span class="s1">:</span><span class="s4">101j</span><span class="s1">]</span>
    <span class="s1">a = np.r_[-np.ones(</span><span class="s4">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s4">51</span><span class="s1">)]</span>
    <span class="s1">expected = [stats.truncnorm.pdf(_x</span><span class="s0">, </span><span class="s1">_a</span><span class="s0">, </span><span class="s1">np.inf) </span><span class="s0">for </span><span class="s1">_x</span><span class="s0">, </span><span class="s1">_a </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">a)]</span>
    <span class="s1">ans = stats.truncnorm.pdf(x</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">np.inf)</span>
    <span class="s1">npt.assert_array_almost_equal(ans</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_gh1320_regression():</span>
    <span class="s3"># Check that the first example from gh-1320 now works.</span>
    <span class="s1">c = </span><span class="s4">2.62</span>
    <span class="s1">stats.genextreme.ppf(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">np.array([[c]</span><span class="s0">, </span><span class="s1">[c + </span><span class="s4">0.5</span><span class="s1">]]))</span>
    <span class="s3"># The other examples in gh-1320 appear to have stopped working</span>
    <span class="s3"># some time ago.</span>
    <span class="s3"># ans = stats.genextreme.moment(2, np.array([c, c + 0.5]))</span>
    <span class="s3"># expected = np.array([25.50105963, 115.11191437])</span>
    <span class="s3"># stats.genextreme.moment(5, np.array([[c], [c + 0.5]]))</span>
    <span class="s3"># stats.genextreme.moment(5, np.array([c, c + 0.5]))</span>


<span class="s0">def </span><span class="s1">test_method_of_moments():</span>
    <span class="s3"># example from https://en.wikipedia.org/wiki/Method_of_moments_(statistics)</span>
    <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">x = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">a = </span><span class="s4">1</span><span class="s1">/</span><span class="s4">5 </span><span class="s1">- </span><span class="s4">2</span><span class="s1">*np.sqrt(</span><span class="s4">3</span><span class="s1">)/</span><span class="s4">5</span>
    <span class="s1">b = </span><span class="s4">1</span><span class="s1">/</span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">*np.sqrt(</span><span class="s4">3</span><span class="s1">)/</span><span class="s4">5</span>
    <span class="s3"># force use of method of moments (uniform.fit is overriden)</span>
    <span class="s1">loc</span><span class="s0">, </span><span class="s1">scale = super(type(stats.uniform)</span><span class="s0">, </span><span class="s1">stats.uniform).fit(x</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">&quot;MM&quot;</span><span class="s1">)</span>
    <span class="s1">npt.assert_almost_equal(loc</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">npt.assert_almost_equal(loc+scale</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_sample_meanvar_(popmean</span><span class="s0">, </span><span class="s1">popvar</span><span class="s0">, </span><span class="s1">sample):</span>
    <span class="s0">if </span><span class="s1">np.isfinite(popmean):</span>
        <span class="s1">check_sample_mean(sample</span><span class="s0">, </span><span class="s1">popmean)</span>
    <span class="s0">if </span><span class="s1">np.isfinite(popvar):</span>
        <span class="s1">check_sample_var(sample</span><span class="s0">, </span><span class="s1">popvar)</span>


<span class="s0">def </span><span class="s1">check_sample_mean(sample</span><span class="s0">, </span><span class="s1">popmean):</span>
    <span class="s3"># Checks for unlikely difference between sample mean and population mean</span>
    <span class="s1">prob = stats.ttest_1samp(sample</span><span class="s0">, </span><span class="s1">popmean).pvalue</span>
    <span class="s0">assert </span><span class="s1">prob &gt; </span><span class="s4">0.01</span>


<span class="s0">def </span><span class="s1">check_sample_var(sample</span><span class="s0">, </span><span class="s1">popvar):</span>
    <span class="s3"># check that population mean lies within the CI bootstrapped from the</span>
    <span class="s3"># sample. This used to be a chi-squared test for variance, but there were</span>
    <span class="s3"># too many false positives</span>
    <span class="s1">res = stats.bootstrap(</span>
        <span class="s1">(sample</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis: x.var(ddof=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">axis=axis)</span><span class="s0">,</span>
        <span class="s1">confidence_level=</span><span class="s4">0.995</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">conf = res.confidence_interval</span>
    <span class="s1">low</span><span class="s0">, </span><span class="s1">high = conf.low</span><span class="s0">, </span><span class="s1">conf.high</span>
    <span class="s0">assert </span><span class="s1">low &lt;= popvar &lt;= high</span>


<span class="s0">def </span><span class="s1">check_cdf_ppf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s1">values = [</span><span class="s4">0.001</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.999</span><span class="s1">]</span>
    <span class="s1">npt.assert_almost_equal(distfn.cdf(distfn.ppf(values</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                            <span class="s1">values</span><span class="s0">, </span><span class="s1">decimal=DECIMAL</span><span class="s0">, </span><span class="s1">err_msg=msg +</span>
                            <span class="s2">' - cdf-ppf roundtrip'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_sf_isf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s1">npt.assert_almost_equal(distfn.sf(distfn.isf([</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=DECIMAL</span><span class="s0">, </span><span class="s1">err_msg=msg +</span>
                            <span class="s2">' - sf-isf roundtrip'</span><span class="s1">)</span>
    <span class="s1">npt.assert_almost_equal(distfn.cdf([</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                            <span class="s4">1.0 </span><span class="s1">- distfn.sf([</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                            <span class="s1">decimal=DECIMAL</span><span class="s0">, </span><span class="s1">err_msg=msg +</span>
                            <span class="s2">' - cdf-sf relationship'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_pdf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># compares pdf at median with numerical derivative of cdf</span>
    <span class="s1">median = distfn.ppf(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s1">eps = </span><span class="s4">1e-6</span>
    <span class="s1">pdfv = distfn.pdf(median</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s0">if </span><span class="s1">(pdfv &lt; </span><span class="s4">1e-4</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(pdfv &gt; </span><span class="s4">1e4</span><span class="s1">):</span>
        <span class="s3"># avoid checking a case where pdf is close to zero or</span>
        <span class="s3"># huge (singularity)</span>
        <span class="s1">median = median + </span><span class="s4">0.1</span>
        <span class="s1">pdfv = distfn.pdf(median</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s1">cdfdiff = (distfn.cdf(median + eps</span><span class="s0">, </span><span class="s1">*arg) -</span>
               <span class="s1">distfn.cdf(median - eps</span><span class="s0">, </span><span class="s1">*arg))/eps/</span><span class="s4">2.0</span>
    <span class="s3"># replace with better diff and better test (more points),</span>
    <span class="s3"># actually, this works pretty well</span>
    <span class="s1">msg += </span><span class="s2">' - cdf-pdf relationship'</span>
    <span class="s1">npt.assert_almost_equal(pdfv</span><span class="s0">, </span><span class="s1">cdfdiff</span><span class="s0">, </span><span class="s1">decimal=DECIMAL</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>


<span class="s0">def </span><span class="s1">check_pdf_logpdf(distfn</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># compares pdf at several points with the log of the pdf</span>
    <span class="s1">points = np.array([</span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.3</span><span class="s0">, </span><span class="s4">0.4</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.6</span><span class="s0">, </span><span class="s4">0.7</span><span class="s0">, </span><span class="s4">0.8</span><span class="s1">])</span>
    <span class="s1">vals = distfn.ppf(points</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">vals = vals[np.isfinite(vals)]</span>
    <span class="s1">pdf = distfn.pdf(vals</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">logpdf = distfn.logpdf(vals</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">pdf = pdf[(pdf != </span><span class="s4">0</span><span class="s1">) &amp; np.isfinite(pdf)]</span>
    <span class="s1">logpdf = logpdf[np.isfinite(logpdf)]</span>
    <span class="s1">msg += </span><span class="s2">&quot; - logpdf-log(pdf) relationship&quot;</span>
    <span class="s1">npt.assert_almost_equal(np.log(pdf)</span><span class="s0">, </span><span class="s1">logpdf</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">7</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>


<span class="s0">def </span><span class="s1">check_pdf_logpdf_at_endpoints(distfn</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># compares pdf with the log of the pdf at the (finite) end points</span>
    <span class="s1">points = np.array([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">vals = distfn.ppf(points</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">vals = vals[np.isfinite(vals)]</span>
    <span class="s1">pdf = distfn.pdf(vals</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">logpdf = distfn.logpdf(vals</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">pdf = pdf[(pdf != </span><span class="s4">0</span><span class="s1">) &amp; np.isfinite(pdf)]</span>
    <span class="s1">logpdf = logpdf[np.isfinite(logpdf)]</span>
    <span class="s1">msg += </span><span class="s2">&quot; - logpdf-log(pdf) relationship&quot;</span>
    <span class="s1">npt.assert_almost_equal(np.log(pdf)</span><span class="s0">, </span><span class="s1">logpdf</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">7</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>


<span class="s0">def </span><span class="s1">check_sf_logsf(distfn</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># compares sf at several points with the log of the sf</span>
    <span class="s1">points = np.array([</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.3</span><span class="s0">, </span><span class="s4">0.4</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.6</span><span class="s0">, </span><span class="s4">0.7</span><span class="s0">, </span><span class="s4">0.8</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s1">vals = distfn.ppf(points</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">vals = vals[np.isfinite(vals)]</span>
    <span class="s1">sf = distfn.sf(vals</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">logsf = distfn.logsf(vals</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">sf = sf[sf != </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">logsf = logsf[np.isfinite(logsf)]</span>
    <span class="s1">msg += </span><span class="s2">&quot; - logsf-log(sf) relationship&quot;</span>
    <span class="s1">npt.assert_almost_equal(np.log(sf)</span><span class="s0">, </span><span class="s1">logsf</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">7</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>


<span class="s0">def </span><span class="s1">check_cdf_logcdf(distfn</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># compares cdf at several points with the log of the cdf</span>
    <span class="s1">points = np.array([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.3</span><span class="s0">, </span><span class="s4">0.4</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.6</span><span class="s0">, </span><span class="s4">0.7</span><span class="s0">, </span><span class="s4">0.8</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s1">vals = distfn.ppf(points</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">vals = vals[np.isfinite(vals)]</span>
    <span class="s1">cdf = distfn.cdf(vals</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">logcdf = distfn.logcdf(vals</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">cdf = cdf[cdf != </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">logcdf = logcdf[np.isfinite(logcdf)]</span>
    <span class="s1">msg += </span><span class="s2">&quot; - logcdf-log(cdf) relationship&quot;</span>
    <span class="s1">npt.assert_almost_equal(np.log(cdf)</span><span class="s0">, </span><span class="s1">logcdf</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">7</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>


<span class="s0">def </span><span class="s1">check_ppf_broadcast(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># compares ppf for multiple argsets.</span>
    <span class="s1">num_repeats = </span><span class="s4">5</span>
    <span class="s1">args = [] * num_repeats</span>
    <span class="s0">if </span><span class="s1">arg:</span>
        <span class="s1">args = [np.array([_] * num_repeats) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">arg]</span>

    <span class="s1">median = distfn.ppf(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s1">medians = distfn.ppf(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">msg += </span><span class="s2">&quot; - ppf multiple&quot;</span>
    <span class="s1">npt.assert_almost_equal(medians</span><span class="s0">, </span><span class="s1">[median] * num_repeats</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">7</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>


<span class="s0">def </span><span class="s1">check_distribution_rvs(dist</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">rvs):</span>
    <span class="s3"># dist is either a cdf function or name of a distribution in scipy.stats.</span>
    <span class="s3"># args are the args for scipy.stats.dist(*args)</span>
    <span class="s3"># alpha is a significance level, ~0.01</span>
    <span class="s3"># rvs is array_like of random variables</span>
    <span class="s3"># test from scipy.stats.tests</span>
    <span class="s3"># this version reuses existing random variables</span>
    <span class="s1">D</span><span class="s0">, </span><span class="s1">pval = stats.kstest(rvs</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">args=args</span><span class="s0">, </span><span class="s1">N=</span><span class="s4">1000</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">(pval &lt; alpha):</span>
        <span class="s3"># The rvs passed in failed the K-S test, which _could_ happen</span>
        <span class="s3"># but is unlikely if alpha is small enough.</span>
        <span class="s3"># Repeat the test with a new sample of rvs.</span>
        <span class="s3"># Generate 1000 rvs, perform a K-S test that the new sample of rvs</span>
        <span class="s3"># are distributed according to the distribution.</span>
        <span class="s1">D</span><span class="s0">, </span><span class="s1">pval = stats.kstest(dist</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">args=args</span><span class="s0">, </span><span class="s1">N=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s1">npt.assert_(pval &gt; alpha</span><span class="s0">, </span><span class="s2">&quot;D = &quot; </span><span class="s1">+ str(D) + </span><span class="s2">&quot;; pval = &quot; </span><span class="s1">+ str(pval) +</span>
                    <span class="s2">&quot;; alpha = &quot; </span><span class="s1">+ str(alpha) + </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">args = &quot; </span><span class="s1">+ str(args))</span>


<span class="s0">def </span><span class="s1">check_vecentropy(distfn</span><span class="s0">, </span><span class="s1">args):</span>
    <span class="s1">npt.assert_equal(distfn.vecentropy(*args)</span><span class="s0">, </span><span class="s1">distfn._entropy(*args))</span>


<span class="s0">def </span><span class="s1">check_loc_scale(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># Make `loc` and `scale` arrays to catch bugs like gh-13580 where</span>
    <span class="s3"># `loc` and `scale` arrays improperly broadcast with shapes.</span>
    <span class="s1">loc</span><span class="s0">, </span><span class="s1">scale = np.array([</span><span class="s4">10.0</span><span class="s0">, </span><span class="s4">20.0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">10.0</span><span class="s0">, </span><span class="s4">20.0</span><span class="s1">])</span>
    <span class="s1">mt</span><span class="s0">, </span><span class="s1">vt = distfn.stats(*arg</span><span class="s0">, </span><span class="s1">loc=loc</span><span class="s0">, </span><span class="s1">scale=scale)</span>
    <span class="s1">npt.assert_allclose(m*scale + loc</span><span class="s0">, </span><span class="s1">mt)</span>
    <span class="s1">npt.assert_allclose(v*scale*scale</span><span class="s0">, </span><span class="s1">vt)</span>


<span class="s0">def </span><span class="s1">check_ppf_private(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># fails by design for truncnorm self.nb not defined</span>
    <span class="s1">ppfs = distfn._ppf(np.array([</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.9</span><span class="s1">])</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s1">npt.assert_(</span><span class="s0">not </span><span class="s1">np.any(np.isnan(ppfs))</span><span class="s0">, </span><span class="s1">msg + </span><span class="s2">'ppf private is nan'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_retrieving_support(distfn</span><span class="s0">, </span><span class="s1">args):</span>
    <span class="s1">loc</span><span class="s0">, </span><span class="s1">scale = </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span>
    <span class="s1">supp = distfn.support(*args)</span>
    <span class="s1">supp_loc_scale = distfn.support(*args</span><span class="s0">, </span><span class="s1">loc=loc</span><span class="s0">, </span><span class="s1">scale=scale)</span>
    <span class="s1">npt.assert_almost_equal(np.array(supp)*scale + loc</span><span class="s0">,</span>
                            <span class="s1">np.array(supp_loc_scale))</span>


<span class="s0">def </span><span class="s1">check_fit_args(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">method):</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npt.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(category=RuntimeWarning</span><span class="s0">,</span>
                   <span class="s1">message=</span><span class="s2">&quot;The shape parameter of the erlang&quot;</span><span class="s1">)</span>
        <span class="s1">sup.filter(category=RuntimeWarning</span><span class="s0">,</span>
                   <span class="s1">message=</span><span class="s2">&quot;floating point number truncated&quot;</span><span class="s1">)</span>
        <span class="s1">vals = distfn.fit(rvs</span><span class="s0">, </span><span class="s1">method=method)</span>
        <span class="s1">vals2 = distfn.fit(rvs</span><span class="s0">, </span><span class="s1">optimizer=</span><span class="s2">'powell'</span><span class="s0">, </span><span class="s1">method=method)</span>
    <span class="s3"># Only check the length of the return; accuracy tested in test_fit.py</span>
    <span class="s1">npt.assert_(len(vals) == </span><span class="s4">2</span><span class="s1">+len(arg))</span>
    <span class="s1">npt.assert_(len(vals2) == </span><span class="s4">2</span><span class="s1">+len(arg))</span>


<span class="s0">def </span><span class="s1">check_fit_args_fix(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">method):</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npt.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(category=RuntimeWarning</span><span class="s0">,</span>
                   <span class="s1">message=</span><span class="s2">&quot;The shape parameter of the erlang&quot;</span><span class="s1">)</span>

        <span class="s1">vals = distfn.fit(rvs</span><span class="s0">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">method=method)</span>
        <span class="s1">vals2 = distfn.fit(rvs</span><span class="s0">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">method=method)</span>
        <span class="s1">npt.assert_(len(vals) == </span><span class="s4">2</span><span class="s1">+len(arg))</span>
        <span class="s1">npt.assert_(vals[-</span><span class="s4">2</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">npt.assert_(vals2[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">npt.assert_(len(vals2) == </span><span class="s4">2</span><span class="s1">+len(arg))</span>
        <span class="s0">if </span><span class="s1">len(arg) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">vals3 = distfn.fit(rvs</span><span class="s0">, </span><span class="s1">f0=arg[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=method)</span>
            <span class="s1">npt.assert_(len(vals3) == </span><span class="s4">2</span><span class="s1">+len(arg))</span>
            <span class="s1">npt.assert_(vals3[</span><span class="s4">0</span><span class="s1">] == arg[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">len(arg) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">vals4 = distfn.fit(rvs</span><span class="s0">, </span><span class="s1">f1=arg[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=method)</span>
            <span class="s1">npt.assert_(len(vals4) == </span><span class="s4">2</span><span class="s1">+len(arg))</span>
            <span class="s1">npt.assert_(vals4[</span><span class="s4">1</span><span class="s1">] == arg[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">len(arg) &gt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">vals5 = distfn.fit(rvs</span><span class="s0">, </span><span class="s1">f2=arg[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=method)</span>
            <span class="s1">npt.assert_(len(vals5) == </span><span class="s4">2</span><span class="s1">+len(arg))</span>
            <span class="s1">npt.assert_(vals5[</span><span class="s4">2</span><span class="s1">] == arg[</span><span class="s4">2</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'method'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'pdf'</span><span class="s0">, </span><span class="s2">'logpdf'</span><span class="s0">, </span><span class="s2">'cdf'</span><span class="s0">, </span><span class="s2">'logcdf'</span><span class="s0">,</span>
                                    <span class="s2">'sf'</span><span class="s0">, </span><span class="s2">'logsf'</span><span class="s0">, </span><span class="s2">'ppf'</span><span class="s0">, </span><span class="s2">'isf'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'distname, args'</span><span class="s0">, </span><span class="s1">distcont)</span>
<span class="s0">def </span><span class="s1">test_methods_with_lists(method</span><span class="s0">, </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">args):</span>
    <span class="s3"># Test that the continuous distributions can accept Python lists</span>
    <span class="s3"># as arguments.</span>
    <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">f = getattr(dist</span><span class="s0">, </span><span class="s1">method)</span>
    <span class="s0">if </span><span class="s1">distname == </span><span class="s2">'invweibull' </span><span class="s0">and </span><span class="s1">method.startswith(</span><span class="s2">'log'</span><span class="s1">):</span>
        <span class="s1">x = [</span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">x = [</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.2</span><span class="s1">]</span>

    <span class="s1">shape2 = [[a]*</span><span class="s4">2 </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args]</span>
    <span class="s1">loc = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0.1</span><span class="s1">]</span>
    <span class="s1">scale = [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1.01</span><span class="s1">]</span>
    <span class="s1">result = f(x</span><span class="s0">, </span><span class="s1">*shape2</span><span class="s0">, </span><span class="s1">loc=loc</span><span class="s0">, </span><span class="s1">scale=scale)</span>
    <span class="s1">npt.assert_allclose(result</span><span class="s0">,</span>
                        <span class="s1">[f(*v) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">*shape2</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">scale)]</span><span class="s0">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">5e-14</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_burr_fisk_moment_gh13234_regression():</span>
    <span class="s1">vals0 = stats.burr.moment(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(vals0</span><span class="s0">, </span><span class="s1">float)</span>

    <span class="s1">vals1 = stats.fisk.moment(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(vals1</span><span class="s0">, </span><span class="s1">float)</span>


<span class="s0">def </span><span class="s1">test_moments_with_array_gh12192_regression():</span>
    <span class="s3"># array loc and scalar scale</span>
    <span class="s1">vals0 = stats.norm.moment(order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">loc=np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected0 = np.array([</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s0">, </span><span class="s4">3.</span><span class="s1">])</span>
    <span class="s1">npt.assert_equal(vals0</span><span class="s0">, </span><span class="s1">expected0)</span>

    <span class="s3"># array loc and invalid scalar scale</span>
    <span class="s1">vals1 = stats.norm.moment(order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">loc=np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">scale=-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected1 = np.array([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">npt.assert_equal(vals1</span><span class="s0">, </span><span class="s1">expected1)</span>

    <span class="s3"># array loc and array scale with invalid entries</span>
    <span class="s1">vals2 = stats.norm.moment(order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">loc=np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span><span class="s0">,</span>
                              <span class="s1">scale=[-</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">expected2 = np.array([np.nan</span><span class="s0">, </span><span class="s4">2.</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">npt.assert_equal(vals2</span><span class="s0">, </span><span class="s1">expected2)</span>

    <span class="s3"># (loc == 0) &amp; (scale &lt; 0)</span>
    <span class="s1">vals3 = stats.norm.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">scale=-</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">expected3 = np.nan</span>
    <span class="s1">npt.assert_equal(vals3</span><span class="s0">, </span><span class="s1">expected3)</span>
    <span class="s0">assert </span><span class="s1">isinstance(vals3</span><span class="s0">, </span><span class="s1">expected3.__class__)</span>

    <span class="s3"># array loc with 0 entries and scale with invalid entries</span>
    <span class="s1">vals4 = stats.norm.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">loc=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">scale=[</span><span class="s4">3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">4</span><span class="s0">, </span><span class="s1">-</span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">expected4 = np.array([</span><span class="s4">10.</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">npt.assert_equal(vals4</span><span class="s0">, </span><span class="s1">expected4)</span>

    <span class="s3"># all(loc == 0) &amp; (array scale with invalid entries)</span>
    <span class="s1">vals5 = stats.norm.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">loc=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">scale=[</span><span class="s4">5.</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s4">100.</span><span class="s1">])</span>
    <span class="s1">expected5 = np.array([</span><span class="s4">25.</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">10000.</span><span class="s1">])</span>
    <span class="s1">npt.assert_equal(vals5</span><span class="s0">, </span><span class="s1">expected5)</span>

    <span class="s3"># all( (loc == 0) &amp; (scale &lt; 0) )</span>
    <span class="s1">vals6 = stats.norm.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">loc=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">scale=[-</span><span class="s4">5.</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">100.</span><span class="s1">])</span>
    <span class="s1">expected6 = np.array([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">npt.assert_equal(vals6</span><span class="s0">, </span><span class="s1">expected6)</span>

    <span class="s3"># scalar args, loc, and scale</span>
    <span class="s1">vals7 = stats.chi.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">df=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">scale=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">expected7 = np.nan</span>
    <span class="s1">npt.assert_equal(vals7</span><span class="s0">, </span><span class="s1">expected7)</span>
    <span class="s0">assert </span><span class="s1">isinstance(vals7</span><span class="s0">, </span><span class="s1">expected7.__class__)</span>

    <span class="s3"># array args, scalar loc, and scalar scale</span>
    <span class="s1">vals8 = stats.chi.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">df=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">scale=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">expected8 = np.array([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">npt.assert_equal(vals8</span><span class="s0">, </span><span class="s1">expected8)</span>

    <span class="s3"># array args, array loc, and array scale</span>
    <span class="s1">vals9 = stats.chi.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">df=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">loc=[</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">scale=[</span><span class="s4">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3.</span><span class="s0">, </span><span class="s4">0.</span><span class="s1">])</span>
    <span class="s1">expected9 = np.array([</span><span class="s4">3.59576912</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">npt.assert_allclose(vals9</span><span class="s0">, </span><span class="s1">expected9</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>

    <span class="s3"># (n &gt; 4), all(loc != 0), and all(scale != 0)</span>
    <span class="s1">vals10 = stats.norm.moment(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s1">])</span>
    <span class="s1">expected10 = np.array([</span><span class="s4">26.</span><span class="s0">, </span><span class="s4">832.</span><span class="s1">])</span>
    <span class="s1">npt.assert_allclose(vals10</span><span class="s0">, </span><span class="s1">expected10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s3"># test broadcasting and more</span>
    <span class="s1">a = [-</span><span class="s4">1.1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2.2</span><span class="s0">, </span><span class="s1">np.pi]</span>
    <span class="s1">b = [-</span><span class="s4">1.1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2.2</span><span class="s0">, </span><span class="s1">np.pi]</span>
    <span class="s1">loc = [-</span><span class="s4">1.1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.sqrt(</span><span class="s4">2</span><span class="s1">)]</span>
    <span class="s1">scale = [-</span><span class="s4">2.1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2.2</span><span class="s0">, </span><span class="s1">np.pi]</span>

    <span class="s1">a = np.array(a).reshape((-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">b = np.array(b).reshape((-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">loc = np.array(loc).reshape((-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">scale = np.array(scale)</span>

    <span class="s1">vals11 = stats.beta.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">a=a</span><span class="s0">, </span><span class="s1">b=b</span><span class="s0">, </span><span class="s1">loc=loc</span><span class="s0">, </span><span class="s1">scale=scale)</span>

    <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">scale = np.broadcast_arrays(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">scale)</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">np.ndenumerate(a):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'ignore'</span><span class="s0">, </span><span class="s1">divide=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">i = i[</span><span class="s4">0</span><span class="s1">]  </span><span class="s3"># just get the index</span>
            <span class="s3"># check against same function with scalar input</span>
            <span class="s1">expected = stats.beta.moment(order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">a=a[i]</span><span class="s0">, </span><span class="s1">b=b[i]</span><span class="s0">,</span>
                                         <span class="s1">loc=loc[i]</span><span class="s0">, </span><span class="s1">scale=scale[i])</span>
            <span class="s1">np.testing.assert_equal(vals11[i]</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_broadcasting_in_moments_gh12192_regression():</span>
    <span class="s1">vals0 = stats.norm.moment(order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">loc=np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">scale=[[</span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">expected0 = np.array([[</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s0">, </span><span class="s4">3.</span><span class="s1">]])</span>
    <span class="s1">npt.assert_equal(vals0</span><span class="s0">, </span><span class="s1">expected0)</span>
    <span class="s0">assert </span><span class="s1">vals0.shape == expected0.shape</span>

    <span class="s1">vals1 = stats.norm.moment(order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">loc=np.array([[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s1">]])</span><span class="s0">,</span>
                              <span class="s1">scale=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">expected1 = np.array([[</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">1.</span><span class="s0">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s0">, </span><span class="s4">2.</span><span class="s0">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s0">, </span><span class="s4">3.</span><span class="s0">, </span><span class="s4">3.</span><span class="s1">]])</span>
    <span class="s1">npt.assert_equal(vals1</span><span class="s0">, </span><span class="s1">expected1)</span>
    <span class="s0">assert </span><span class="s1">vals1.shape == expected1.shape</span>

    <span class="s1">vals2 = stats.chi.moment(order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">df=[</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s0">, </span><span class="s4">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">loc=</span><span class="s4">0.</span><span class="s0">, </span><span class="s1">scale=</span><span class="s4">1.</span><span class="s1">)</span>
    <span class="s1">expected2 = np.array([</span><span class="s4">0.79788456</span><span class="s0">, </span><span class="s4">1.25331414</span><span class="s0">, </span><span class="s4">1.59576912</span><span class="s1">])</span>
    <span class="s1">npt.assert_allclose(vals2</span><span class="s0">, </span><span class="s1">expected2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">vals2.shape == expected2.shape</span>

    <span class="s1">vals3 = stats.chi.moment(order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">df=[[</span><span class="s4">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">loc=[</span><span class="s4">0.</span><span class="s0">, </span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">scale=[-</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">3.</span><span class="s1">])</span>
    <span class="s1">expected3 = np.array([[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">4.39365368</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">5.75994241</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">6.78730736</span><span class="s1">]])</span>
    <span class="s1">npt.assert_allclose(vals3</span><span class="s0">, </span><span class="s1">expected3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">vals3.shape == expected3.shape</span>


<span class="s0">def </span><span class="s1">test_kappa3_array_gh13582():</span>
    <span class="s3"># https://github.com/scipy/scipy/pull/15140#issuecomment-994958241</span>
    <span class="s1">shapes = [</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">3.5</span><span class="s0">, </span><span class="s4">4.5</span><span class="s1">]</span>
    <span class="s1">moments = </span><span class="s2">'mvsk'</span>
    <span class="s1">res = np.array([[stats.kappa3.stats(shape</span><span class="s0">, </span><span class="s1">moments=moment)</span>
                   <span class="s0">for </span><span class="s1">shape </span><span class="s0">in </span><span class="s1">shapes] </span><span class="s0">for </span><span class="s1">moment </span><span class="s0">in </span><span class="s1">moments])</span>
    <span class="s1">res2 = np.array(stats.kappa3.stats(shapes</span><span class="s0">, </span><span class="s1">moments=moments))</span>
    <span class="s1">npt.assert_allclose(res</span><span class="s0">, </span><span class="s1">res2)</span>


<span class="s1">@pytest.mark.xslow</span>
<span class="s0">def </span><span class="s1">test_kappa4_array_gh13582():</span>
    <span class="s1">h = np.array([-</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">3.5</span><span class="s0">, </span><span class="s4">4.5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">k = np.array([-</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">3.5</span><span class="s1">])</span>
    <span class="s1">moments = </span><span class="s2">'mvsk'</span>
    <span class="s1">res = np.array([[stats.kappa4.stats(h[i]</span><span class="s0">, </span><span class="s1">k[i]</span><span class="s0">, </span><span class="s1">moments=moment)</span>
                   <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">)] </span><span class="s0">for </span><span class="s1">moment </span><span class="s0">in </span><span class="s1">moments])</span>
    <span class="s1">res2 = np.array(stats.kappa4.stats(h</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">moments=moments))</span>
    <span class="s1">npt.assert_allclose(res</span><span class="s0">, </span><span class="s1">res2)</span>

    <span class="s3"># https://github.com/scipy/scipy/pull/15250#discussion_r775112913</span>
    <span class="s1">h = np.array([-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">/</span><span class="s4">4</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">/</span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">k = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">res = np.array([[stats.kappa4.stats(h[i]</span><span class="s0">, </span><span class="s1">k[i]</span><span class="s0">, </span><span class="s1">moments=moment)</span>
                   <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">6</span><span class="s1">)] </span><span class="s0">for </span><span class="s1">moment </span><span class="s0">in </span><span class="s1">moments])</span>
    <span class="s1">res2 = np.array(stats.kappa4.stats(h</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">moments=moments))</span>
    <span class="s1">npt.assert_allclose(res</span><span class="s0">, </span><span class="s1">res2)</span>

    <span class="s3"># https://github.com/scipy/scipy/pull/15250#discussion_r775115021</span>
    <span class="s1">h = np.array([-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">k = np.array([-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])[:</span><span class="s0">, None</span><span class="s1">]</span>
    <span class="s1">res2 = np.array(stats.kappa4.stats(h</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">moments=moments))</span>
    <span class="s0">assert </span><span class="s1">res2.shape == (</span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_frozen_attributes():</span>
    <span class="s3"># gh-14827 reported that all frozen distributions had both pmf and pdf</span>
    <span class="s3"># attributes; continuous should have pdf and discrete should have pmf.</span>
    <span class="s1">message = </span><span class="s2">&quot;'rv_continuous_frozen' object has no attribute&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=message):</span>
        <span class="s1">stats.norm().pmf</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=message):</span>
        <span class="s1">stats.norm().logpmf</span>
    <span class="s1">stats.norm.pmf = </span><span class="s2">&quot;herring&quot;</span>
    <span class="s1">frozen_norm = stats.norm()</span>
    <span class="s0">assert </span><span class="s1">isinstance(frozen_norm</span><span class="s0">, </span><span class="s1">rv_continuous_frozen)</span>
    <span class="s1">delattr(stats.norm</span><span class="s0">, </span><span class="s2">'pmf'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_skewnorm_pdf_gh16038():</span>
    <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">a = -np.inf</span><span class="s0">, </span><span class="s4">0</span>
    <span class="s1">npt.assert_equal(stats.skewnorm.pdf(x</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">stats.norm.pdf(x))</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">a = rng.random(size=(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">rng.random(size=(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">mask = rng.random(size=(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)) &lt; </span><span class="s4">0.5</span>
    <span class="s1">a[mask] = </span><span class="s4">0</span>
    <span class="s1">x_norm = x[mask]</span>
    <span class="s1">res = stats.skewnorm.pdf(x</span><span class="s0">, </span><span class="s1">a)</span>
    <span class="s1">npt.assert_equal(res[mask]</span><span class="s0">, </span><span class="s1">stats.norm.pdf(x_norm))</span>
    <span class="s1">npt.assert_equal(res[~mask]</span><span class="s0">, </span><span class="s1">stats.skewnorm.pdf(x[~mask]</span><span class="s0">, </span><span class="s1">a[~mask]))</span>


<span class="s3"># for scalar input, these functions should return scalar output</span>
<span class="s1">scalar_out = [[</span><span class="s2">'rvs'</span><span class="s0">, </span><span class="s1">[]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'pdf'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'logpdf'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'cdf'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">'logcdf'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'sf'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'logsf'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'ppf'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">'isf'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'moment'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'entropy'</span><span class="s0">, </span><span class="s1">[]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'expect'</span><span class="s0">, </span><span class="s1">[]]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">'median'</span><span class="s0">, </span><span class="s1">[]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'mean'</span><span class="s0">, </span><span class="s1">[]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'std'</span><span class="s0">, </span><span class="s1">[]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'var'</span><span class="s0">, </span><span class="s1">[]]]</span>
<span class="s1">scalars_out = [[</span><span class="s2">'interval'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.95</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'support'</span><span class="s0">, </span><span class="s1">[]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'stats'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'mv'</span><span class="s1">]]]</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'case'</span><span class="s0">, </span><span class="s1">scalar_out + scalars_out)</span>
<span class="s0">def </span><span class="s1">test_scalar_for_scalar(case):</span>
    <span class="s3"># Some rv_continuous functions returned 0d array instead of NumPy scalar</span>
    <span class="s3"># Guard against regression</span>
    <span class="s1">method_name</span><span class="s0">, </span><span class="s1">args = case</span>
    <span class="s1">method = getattr(stats.norm()</span><span class="s0">, </span><span class="s1">method_name)</span>
    <span class="s1">res = method(*args)</span>
    <span class="s0">if </span><span class="s1">case </span><span class="s0">in </span><span class="s1">scalar_out:</span>
        <span class="s0">assert </span><span class="s1">isinstance(res</span><span class="s0">, </span><span class="s1">np.number)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">isinstance(res[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.number)</span>
        <span class="s0">assert </span><span class="s1">isinstance(res[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.number)</span>


<span class="s0">def </span><span class="s1">test_scalar_for_scalar2():</span>
    <span class="s3"># test methods that are not attributes of frozen distributions</span>
    <span class="s1">res = stats.norm.fit([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">isinstance(res[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.number)</span>
    <span class="s0">assert </span><span class="s1">isinstance(res[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.number)</span>
    <span class="s1">res = stats.norm.fit_loc_scale([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">isinstance(res[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.number)</span>
    <span class="s0">assert </span><span class="s1">isinstance(res[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.number)</span>
    <span class="s1">res = stats.norm.nnlf((</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">isinstance(res</span><span class="s0">, </span><span class="s1">np.number)</span>
</pre>
</body>
</html>