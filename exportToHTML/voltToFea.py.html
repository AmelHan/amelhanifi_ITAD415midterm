<html>
<head>
<title>voltToFea.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
voltToFea.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;\ 
MS VOLT ``.vtp`` to AFDKO ``.fea`` OpenType Layout converter. 
 
Usage 
----- 
 
To convert a VTP project file: 
 
 
    $ fonttools voltLib.voltToFea input.vtp output.fea 
 
It is also possible convert font files with `TSIV` table (as saved from Volt), 
in this case the glyph names used in the Volt project will be mapped to the 
actual glyph names in the font files when written to the feature file: 
 
    $ fonttools voltLib.voltToFea input.ttf output.fea 
 
The ``--quiet`` option can be used to suppress warnings. 
 
The ``--traceback`` can be used to get Python traceback in case of exceptions, 
instead of suppressing the traceback. 
 
 
Limitations 
----------- 
 
* Not all VOLT features are supported, the script will error if it it 
  encounters something it does not understand. Please report an issue if this 
  happens. 
* AFDKO feature file syntax for mark positioning is awkward and does not allow 
  setting the mark coverage. It also defines mark anchors globally, as a result 
  some mark positioning lookups might cover many marks than what was in the VOLT 
  file. This should not be an issue in practice, but if it is then the only way 
  is to modify the VOLT file or the generated feature file manually to use unique 
  mark anchors for each lookup. 
* VOLT allows subtable breaks in any lookup type, but AFDKO feature file 
  implementations vary in their support; currently AFDKO’s makeOTF supports 
  subtable breaks in pair positioning lookups only, while FontTools’ feaLib 
  support it for most substitution lookups and only some positioning lookups. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">StringIO</span>

<span class="s2">from </span><span class="s1">fontTools.feaLib </span><span class="s2">import </span><span class="s1">ast</span>
<span class="s2">from </span><span class="s1">fontTools.ttLib </span><span class="s2">import </span><span class="s1">TTFont</span><span class="s2">, </span><span class="s1">TTLibError</span>
<span class="s2">from </span><span class="s1">fontTools.voltLib </span><span class="s2">import </span><span class="s1">ast </span><span class="s2">as </span><span class="s1">VAst</span>
<span class="s2">from </span><span class="s1">fontTools.voltLib.parser </span><span class="s2">import </span><span class="s1">Parser </span><span class="s2">as </span><span class="s1">VoltParser</span>

<span class="s1">log = logging.getLogger(</span><span class="s3">&quot;fontTools.voltLib.voltToFea&quot;</span><span class="s1">)</span>

<span class="s1">TABLES = [</span><span class="s3">&quot;GDEF&quot;</span><span class="s2">, </span><span class="s3">&quot;GSUB&quot;</span><span class="s2">, </span><span class="s3">&quot;GPOS&quot;</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">MarkClassDefinition(ast.MarkClassDefinition):</span>
    <span class="s2">def </span><span class="s1">asFea(self</span><span class="s2">, </span><span class="s1">indent=</span><span class="s3">&quot;&quot;</span><span class="s1">):</span>
        <span class="s1">res = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;used&quot;</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s1">res += </span><span class="s3">&quot;#&quot;</span>
        <span class="s1">res += ast.MarkClassDefinition.asFea(self</span><span class="s2">, </span><span class="s1">indent)</span>
        <span class="s2">return </span><span class="s1">res</span>


<span class="s4"># For sorting voltLib.ast.GlyphDefinition, see its use below.</span>
<span class="s2">class </span><span class="s1">Group:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">group):</span>
        <span class="s1">self.name = group.name.lower()</span>
        <span class="s1">self.groups = [</span>
            <span class="s1">x.group.lower() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">group.enum.enum </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">VAst.GroupName)</span>
        <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">in </span><span class="s1">other.groups:</span>
            <span class="s2">return True</span>
        <span class="s2">if </span><span class="s1">other.name </span><span class="s2">in </span><span class="s1">self.groups:</span>
            <span class="s2">return False</span>
        <span class="s2">if </span><span class="s1">self.groups </span><span class="s2">and not </span><span class="s1">other.groups:</span>
            <span class="s2">return False</span>
        <span class="s2">if not </span><span class="s1">self.groups </span><span class="s2">and </span><span class="s1">other.groups:</span>
            <span class="s2">return True</span>


<span class="s2">class </span><span class="s1">VoltToFea:</span>
    <span class="s1">_NOT_LOOKUP_NAME_RE = re.compile(</span><span class="s3">r&quot;[^A-Za-z_0-9.]&quot;</span><span class="s1">)</span>
    <span class="s1">_NOT_CLASS_NAME_RE = re.compile(</span><span class="s3">r&quot;[^A-Za-z_0-9.\-]&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file_or_path</span><span class="s2">, </span><span class="s1">font=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._file_or_path = file_or_path</span>
        <span class="s1">self._font = font</span>

        <span class="s1">self._glyph_map = {}</span>
        <span class="s1">self._glyph_order = </span><span class="s2">None</span>

        <span class="s1">self._gdef = {}</span>
        <span class="s1">self._glyphclasses = {}</span>
        <span class="s1">self._features = {}</span>
        <span class="s1">self._lookups = {}</span>

        <span class="s1">self._marks = set()</span>
        <span class="s1">self._ligatures = {}</span>

        <span class="s1">self._markclasses = {}</span>
        <span class="s1">self._anchors = {}</span>

        <span class="s1">self._settings = {}</span>

        <span class="s1">self._lookup_names = {}</span>
        <span class="s1">self._class_names = {}</span>

    <span class="s2">def </span><span class="s1">_lookupName(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self._lookup_names:</span>
            <span class="s1">res = self._NOT_LOOKUP_NAME_RE.sub(</span><span class="s3">&quot;_&quot;</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s2">while </span><span class="s1">res </span><span class="s2">in </span><span class="s1">self._lookup_names.values():</span>
                <span class="s1">res += </span><span class="s3">&quot;_&quot;</span>
            <span class="s1">self._lookup_names[name] = res</span>
        <span class="s2">return </span><span class="s1">self._lookup_names[name]</span>

    <span class="s2">def </span><span class="s1">_className(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self._class_names:</span>
            <span class="s1">res = self._NOT_CLASS_NAME_RE.sub(</span><span class="s3">&quot;_&quot;</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s2">while </span><span class="s1">res </span><span class="s2">in </span><span class="s1">self._class_names.values():</span>
                <span class="s1">res += </span><span class="s3">&quot;_&quot;</span>
            <span class="s1">self._class_names[name] = res</span>
        <span class="s2">return </span><span class="s1">self._class_names[name]</span>

    <span class="s2">def </span><span class="s1">_collectStatements(self</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">, </span><span class="s1">tables):</span>
        <span class="s4"># Collect and sort group definitions first, to make sure a group</span>
        <span class="s4"># definition that references other groups comes after them since VOLT</span>
        <span class="s4"># does not enforce such ordering, and feature file require it.</span>
        <span class="s1">groups = [s </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">doc.statements </span><span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">VAst.GroupDefinition)]</span>
        <span class="s2">for </span><span class="s1">statement </span><span class="s2">in </span><span class="s1">sorted(groups</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: Group(x)):</span>
            <span class="s1">self._groupDefinition(statement)</span>

        <span class="s2">for </span><span class="s1">statement </span><span class="s2">in </span><span class="s1">doc.statements:</span>
            <span class="s2">if </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">VAst.GlyphDefinition):</span>
                <span class="s1">self._glyphDefinition(statement)</span>
            <span class="s2">elif </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">VAst.AnchorDefinition):</span>
                <span class="s2">if </span><span class="s3">&quot;GPOS&quot; </span><span class="s2">in </span><span class="s1">tables:</span>
                    <span class="s1">self._anchorDefinition(statement)</span>
            <span class="s2">elif </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">VAst.SettingDefinition):</span>
                <span class="s1">self._settingDefinition(statement)</span>
            <span class="s2">elif </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">VAst.GroupDefinition):</span>
                <span class="s2">pass  </span><span class="s4"># Handled above</span>
            <span class="s2">elif </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">VAst.ScriptDefinition):</span>
                <span class="s1">self._scriptDefinition(statement)</span>
            <span class="s2">elif not </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">VAst.LookupDefinition):</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(statement)</span>

        <span class="s4"># Lookup definitions need to be handled last as they reference glyph</span>
        <span class="s4"># and mark classes that might be defined after them.</span>
        <span class="s2">for </span><span class="s1">statement </span><span class="s2">in </span><span class="s1">doc.statements:</span>
            <span class="s2">if </span><span class="s1">isinstance(statement</span><span class="s2">, </span><span class="s1">VAst.LookupDefinition):</span>
                <span class="s2">if </span><span class="s1">statement.pos </span><span class="s2">and </span><span class="s3">&quot;GPOS&quot; </span><span class="s2">not in </span><span class="s1">tables:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">statement.sub </span><span class="s2">and </span><span class="s3">&quot;GSUB&quot; </span><span class="s2">not in </span><span class="s1">tables:</span>
                    <span class="s2">continue</span>
                <span class="s1">self._lookupDefinition(statement)</span>

    <span class="s2">def </span><span class="s1">_buildFeatureFile(self</span><span class="s2">, </span><span class="s1">tables):</span>
        <span class="s1">doc = ast.FeatureFile()</span>
        <span class="s1">statements = doc.statements</span>

        <span class="s2">if </span><span class="s1">self._glyphclasses:</span>
            <span class="s1">statements.append(ast.Comment(</span><span class="s3">&quot;# Glyph classes&quot;</span><span class="s1">))</span>
            <span class="s1">statements.extend(self._glyphclasses.values())</span>

        <span class="s2">if </span><span class="s1">self._markclasses:</span>
            <span class="s1">statements.append(ast.Comment(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3"># Mark classes&quot;</span><span class="s1">))</span>
            <span class="s1">statements.extend(c[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">sorted(self._markclasses.items()))</span>

        <span class="s2">if </span><span class="s1">self._lookups:</span>
            <span class="s1">statements.append(ast.Comment(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3"># Lookups&quot;</span><span class="s1">))</span>
            <span class="s2">for </span><span class="s1">lookup </span><span class="s2">in </span><span class="s1">self._lookups.values():</span>
                <span class="s1">statements.extend(getattr(lookup</span><span class="s2">, </span><span class="s3">&quot;targets&quot;</span><span class="s2">, </span><span class="s1">[]))</span>
                <span class="s1">statements.append(lookup)</span>

        <span class="s4"># Prune features</span>
        <span class="s1">features = self._features.copy()</span>
        <span class="s2">for </span><span class="s1">ftag </span><span class="s2">in </span><span class="s1">features:</span>
            <span class="s1">scripts = features[ftag]</span>
            <span class="s2">for </span><span class="s1">stag </span><span class="s2">in </span><span class="s1">scripts:</span>
                <span class="s1">langs = scripts[stag]</span>
                <span class="s2">for </span><span class="s1">ltag </span><span class="s2">in </span><span class="s1">langs:</span>
                    <span class="s1">langs[ltag] = [l </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">langs[ltag] </span><span class="s2">if </span><span class="s1">l.lower() </span><span class="s2">in </span><span class="s1">self._lookups]</span>
                <span class="s1">scripts[stag] = {t: l </span><span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">l </span><span class="s2">in </span><span class="s1">langs.items() </span><span class="s2">if </span><span class="s1">l}</span>
            <span class="s1">features[ftag] = {t: s </span><span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">scripts.items() </span><span class="s2">if </span><span class="s1">s}</span>
        <span class="s1">features = {t: f </span><span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">features.items() </span><span class="s2">if </span><span class="s1">f}</span>

        <span class="s2">if </span><span class="s1">features:</span>
            <span class="s1">statements.append(ast.Comment(</span><span class="s3">&quot;# Features&quot;</span><span class="s1">))</span>
            <span class="s2">for </span><span class="s1">ftag</span><span class="s2">, </span><span class="s1">scripts </span><span class="s2">in </span><span class="s1">features.items():</span>
                <span class="s1">feature = ast.FeatureBlock(ftag)</span>
                <span class="s1">stags = sorted(scripts</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">k: </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">k == </span><span class="s3">&quot;DFLT&quot; </span><span class="s2">else </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">stag </span><span class="s2">in </span><span class="s1">stags:</span>
                    <span class="s1">feature.statements.append(ast.ScriptStatement(stag))</span>
                    <span class="s1">ltags = sorted(scripts[stag]</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">k: </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">k == </span><span class="s3">&quot;dflt&quot; </span><span class="s2">else </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">ltag </span><span class="s2">in </span><span class="s1">ltags:</span>
                        <span class="s1">include_default = </span><span class="s2">True if </span><span class="s1">ltag == </span><span class="s3">&quot;dflt&quot; </span><span class="s2">else False</span>
                        <span class="s1">feature.statements.append(</span>
                            <span class="s1">ast.LanguageStatement(ltag</span><span class="s2">, </span><span class="s1">include_default=include_default)</span>
                        <span class="s1">)</span>
                        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">scripts[stag][ltag]:</span>
                            <span class="s1">lookup = self._lookups[name.lower()]</span>
                            <span class="s1">lookupref = ast.LookupReferenceStatement(lookup)</span>
                            <span class="s1">feature.statements.append(lookupref)</span>
                <span class="s1">statements.append(feature)</span>

        <span class="s2">if </span><span class="s1">self._gdef </span><span class="s2">and </span><span class="s3">&quot;GDEF&quot; </span><span class="s2">in </span><span class="s1">tables:</span>
            <span class="s1">classes = []</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;BASE&quot;</span><span class="s2">, </span><span class="s3">&quot;MARK&quot;</span><span class="s2">, </span><span class="s3">&quot;LIGATURE&quot;</span><span class="s2">, </span><span class="s3">&quot;COMPONENT&quot;</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._gdef:</span>
                    <span class="s1">classname = </span><span class="s3">&quot;GDEF_&quot; </span><span class="s1">+ name.lower()</span>
                    <span class="s1">glyphclass = ast.GlyphClassDefinition(classname</span><span class="s2">, </span><span class="s1">self._gdef[name])</span>
                    <span class="s1">statements.append(glyphclass)</span>
                    <span class="s1">classes.append(ast.GlyphClassName(glyphclass))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">classes.append(</span><span class="s2">None</span><span class="s1">)</span>

            <span class="s1">gdef = ast.TableBlock(</span><span class="s3">&quot;GDEF&quot;</span><span class="s1">)</span>
            <span class="s1">gdef.statements.append(ast.GlyphClassDefStatement(*classes))</span>
            <span class="s1">statements.append(gdef)</span>

        <span class="s2">return </span><span class="s1">doc</span>

    <span class="s2">def </span><span class="s1">convert(self</span><span class="s2">, </span><span class="s1">tables=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">doc = VoltParser(self._file_or_path).parse()</span>

        <span class="s2">if </span><span class="s1">tables </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">tables = TABLES</span>
        <span class="s2">if </span><span class="s1">self._font </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._glyph_order = self._font.getGlyphOrder()</span>

        <span class="s1">self._collectStatements(doc</span><span class="s2">, </span><span class="s1">tables)</span>
        <span class="s1">fea = self._buildFeatureFile(tables)</span>
        <span class="s2">return </span><span class="s1">fea.asFea()</span>

    <span class="s2">def </span><span class="s1">_glyphName(self</span><span class="s2">, </span><span class="s1">glyph):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">name = glyph.glyph</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s1">name = glyph</span>
        <span class="s2">return </span><span class="s1">ast.GlyphName(self._glyph_map.get(name</span><span class="s2">, </span><span class="s1">name))</span>

    <span class="s2">def </span><span class="s1">_groupName(self</span><span class="s2">, </span><span class="s1">group):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">name = group.group</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s1">name = group</span>
        <span class="s2">return </span><span class="s1">ast.GlyphClassName(self._glyphclasses[name.lower()])</span>

    <span class="s2">def </span><span class="s1">_coverage(self</span><span class="s2">, </span><span class="s1">coverage):</span>
        <span class="s1">items = []</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">coverage:</span>
            <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">VAst.GlyphName):</span>
                <span class="s1">items.append(self._glyphName(item))</span>
            <span class="s2">elif </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">VAst.GroupName):</span>
                <span class="s1">items.append(self._groupName(item))</span>
            <span class="s2">elif </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">VAst.Enum):</span>
                <span class="s1">items.append(self._enum(item))</span>
            <span class="s2">elif </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">VAst.Range):</span>
                <span class="s1">items.append((item.start</span><span class="s2">, </span><span class="s1">item.end))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(item)</span>
        <span class="s2">return </span><span class="s1">items</span>

    <span class="s2">def </span><span class="s1">_enum(self</span><span class="s2">, </span><span class="s1">enum):</span>
        <span class="s2">return </span><span class="s1">ast.GlyphClass(self._coverage(enum.enum))</span>

    <span class="s2">def </span><span class="s1">_context(self</span><span class="s2">, </span><span class="s1">context):</span>
        <span class="s1">out = []</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">context:</span>
            <span class="s1">coverage = self._coverage(item)</span>
            <span class="s2">if not </span><span class="s1">isinstance(coverage</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
                <span class="s1">coverage = [coverage]</span>
            <span class="s1">out.extend(coverage)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_groupDefinition(self</span><span class="s2">, </span><span class="s1">group):</span>
        <span class="s1">name = self._className(group.name)</span>
        <span class="s1">glyphs = self._enum(group.enum)</span>
        <span class="s1">glyphclass = ast.GlyphClassDefinition(name</span><span class="s2">, </span><span class="s1">glyphs)</span>

        <span class="s1">self._glyphclasses[group.name.lower()] = glyphclass</span>

    <span class="s2">def </span><span class="s1">_glyphDefinition(self</span><span class="s2">, </span><span class="s1">glyph):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._glyph_map[glyph.name] = self._glyph_order[glyph.id]</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">pass</span>

        <span class="s2">if </span><span class="s1">glyph.type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;BASE&quot;</span><span class="s2">, </span><span class="s3">&quot;MARK&quot;</span><span class="s2">, </span><span class="s3">&quot;LIGATURE&quot;</span><span class="s2">, </span><span class="s3">&quot;COMPONENT&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">glyph.type </span><span class="s2">not in </span><span class="s1">self._gdef:</span>
                <span class="s1">self._gdef[glyph.type] = ast.GlyphClass()</span>
            <span class="s1">self._gdef[glyph.type].glyphs.append(self._glyphName(glyph.name))</span>

        <span class="s2">if </span><span class="s1">glyph.type == </span><span class="s3">&quot;MARK&quot;</span><span class="s1">:</span>
            <span class="s1">self._marks.add(glyph.name)</span>
        <span class="s2">elif </span><span class="s1">glyph.type == </span><span class="s3">&quot;LIGATURE&quot;</span><span class="s1">:</span>
            <span class="s1">self._ligatures[glyph.name] = glyph.components</span>

    <span class="s2">def </span><span class="s1">_scriptDefinition(self</span><span class="s2">, </span><span class="s1">script):</span>
        <span class="s1">stag = script.tag</span>
        <span class="s2">for </span><span class="s1">lang </span><span class="s2">in </span><span class="s1">script.langs:</span>
            <span class="s1">ltag = lang.tag</span>
            <span class="s2">for </span><span class="s1">feature </span><span class="s2">in </span><span class="s1">lang.features:</span>
                <span class="s1">lookups = {l.split(</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]: </span><span class="s2">True for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">feature.lookups}</span>
                <span class="s1">ftag = feature.tag</span>
                <span class="s2">if </span><span class="s1">ftag </span><span class="s2">not in </span><span class="s1">self._features:</span>
                    <span class="s1">self._features[ftag] = {}</span>
                <span class="s2">if </span><span class="s1">stag </span><span class="s2">not in </span><span class="s1">self._features[ftag]:</span>
                    <span class="s1">self._features[ftag][stag] = {}</span>
                <span class="s2">assert </span><span class="s1">ltag </span><span class="s2">not in </span><span class="s1">self._features[ftag][stag]</span>
                <span class="s1">self._features[ftag][stag][ltag] = lookups.keys()</span>

    <span class="s2">def </span><span class="s1">_settingDefinition(self</span><span class="s2">, </span><span class="s1">setting):</span>
        <span class="s2">if </span><span class="s1">setting.name.startswith(</span><span class="s3">&quot;COMPILER_&quot;</span><span class="s1">):</span>
            <span class="s1">self._settings[setting.name] = setting.value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">log.warning(</span><span class="s3">f&quot;Unsupported setting ignored: </span><span class="s2">{</span><span class="s1">setting.name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_adjustment(self</span><span class="s2">, </span><span class="s1">adjustment):</span>
        <span class="s1">adv</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">adv_adjust_by</span><span class="s2">, </span><span class="s1">dx_adjust_by</span><span class="s2">, </span><span class="s1">dy_adjust_by = adjustment</span>

        <span class="s1">adv_device = adv_adjust_by </span><span class="s2">and </span><span class="s1">adv_adjust_by.items() </span><span class="s2">or None</span>
        <span class="s1">dx_device = dx_adjust_by </span><span class="s2">and </span><span class="s1">dx_adjust_by.items() </span><span class="s2">or None</span>
        <span class="s1">dy_device = dy_adjust_by </span><span class="s2">and </span><span class="s1">dy_adjust_by.items() </span><span class="s2">or None</span>

        <span class="s2">return </span><span class="s1">ast.ValueRecord(</span>
            <span class="s1">xPlacement=dx</span><span class="s2">,</span>
            <span class="s1">yPlacement=dy</span><span class="s2">,</span>
            <span class="s1">xAdvance=adv</span><span class="s2">,</span>
            <span class="s1">xPlaDevice=dx_device</span><span class="s2">,</span>
            <span class="s1">yPlaDevice=dy_device</span><span class="s2">,</span>
            <span class="s1">xAdvDevice=adv_device</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_anchor(self</span><span class="s2">, </span><span class="s1">adjustment):</span>
        <span class="s1">adv</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">adv_adjust_by</span><span class="s2">, </span><span class="s1">dx_adjust_by</span><span class="s2">, </span><span class="s1">dy_adjust_by = adjustment</span>

        <span class="s2">assert not </span><span class="s1">adv_adjust_by</span>
        <span class="s1">dx_device = dx_adjust_by </span><span class="s2">and </span><span class="s1">dx_adjust_by.items() </span><span class="s2">or None</span>
        <span class="s1">dy_device = dy_adjust_by </span><span class="s2">and </span><span class="s1">dy_adjust_by.items() </span><span class="s2">or None</span>

        <span class="s2">return </span><span class="s1">ast.Anchor(</span>
            <span class="s1">dx </span><span class="s2">or </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s1">dy </span><span class="s2">or </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s1">xDeviceTable=dx_device </span><span class="s2">or None,</span>
            <span class="s1">yDeviceTable=dy_device </span><span class="s2">or None,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_anchorDefinition(self</span><span class="s2">, </span><span class="s1">anchordef):</span>
        <span class="s1">anchorname = anchordef.name</span>
        <span class="s1">glyphname = anchordef.glyph_name</span>
        <span class="s1">anchor = self._anchor(anchordef.pos)</span>

        <span class="s2">if </span><span class="s1">anchorname.startswith(</span><span class="s3">&quot;MARK_&quot;</span><span class="s1">):</span>
            <span class="s1">name = </span><span class="s3">&quot;_&quot;</span><span class="s1">.join(anchorname.split(</span><span class="s3">&quot;_&quot;</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s1">markclass = ast.MarkClass(self._className(name))</span>
            <span class="s1">glyph = self._glyphName(glyphname)</span>
            <span class="s1">markdef = MarkClassDefinition(markclass</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">glyph)</span>
            <span class="s1">self._markclasses[(glyphname</span><span class="s2">, </span><span class="s1">anchorname)] = markdef</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">glyphname </span><span class="s2">not in </span><span class="s1">self._anchors:</span>
                <span class="s1">self._anchors[glyphname] = {}</span>
            <span class="s2">if </span><span class="s1">anchorname </span><span class="s2">not in </span><span class="s1">self._anchors[glyphname]:</span>
                <span class="s1">self._anchors[glyphname][anchorname] = {}</span>
            <span class="s1">self._anchors[glyphname][anchorname][anchordef.component] = anchor</span>

    <span class="s2">def </span><span class="s1">_gposLookup(self</span><span class="s2">, </span><span class="s1">lookup</span><span class="s2">, </span><span class="s1">fealookup):</span>
        <span class="s1">statements = fealookup.statements</span>

        <span class="s1">pos = lookup.pos</span>
        <span class="s2">if </span><span class="s1">isinstance(pos</span><span class="s2">, </span><span class="s1">VAst.PositionAdjustPairDefinition):</span>
            <span class="s2">for </span><span class="s1">(idx1</span><span class="s2">, </span><span class="s1">idx2)</span><span class="s2">, </span><span class="s1">(pos1</span><span class="s2">, </span><span class="s1">pos2) </span><span class="s2">in </span><span class="s1">pos.adjust_pair.items():</span>
                <span class="s1">coverage_1 = pos.coverages_1[idx1 - </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">coverage_2 = pos.coverages_2[idx2 - </span><span class="s5">1</span><span class="s1">]</span>

                <span class="s4"># If not both are groups, use “enum pos” otherwise makeotf will</span>
                <span class="s4"># fail.</span>
                <span class="s1">enumerated = </span><span class="s2">False</span>
                <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">coverage_1 + coverage_2:</span>
                    <span class="s2">if not </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">VAst.GroupName):</span>
                        <span class="s1">enumerated = </span><span class="s2">True</span>

                <span class="s1">glyphs1 = self._coverage(coverage_1)</span>
                <span class="s1">glyphs2 = self._coverage(coverage_2)</span>
                <span class="s1">record1 = self._adjustment(pos1)</span>
                <span class="s1">record2 = self._adjustment(pos2)</span>
                <span class="s2">assert </span><span class="s1">len(glyphs1) == </span><span class="s5">1</span>
                <span class="s2">assert </span><span class="s1">len(glyphs2) == </span><span class="s5">1</span>
                <span class="s1">statements.append(</span>
                    <span class="s1">ast.PairPosStatement(</span>
                        <span class="s1">glyphs1[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">record1</span><span class="s2">, </span><span class="s1">glyphs2[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">record2</span><span class="s2">, </span><span class="s1">enumerated=enumerated</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(pos</span><span class="s2">, </span><span class="s1">VAst.PositionAdjustSingleDefinition):</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">pos.adjust_single:</span>
                <span class="s1">glyphs = self._coverage(a)</span>
                <span class="s1">record = self._adjustment(b)</span>
                <span class="s2">assert </span><span class="s1">len(glyphs) == </span><span class="s5">1</span>
                <span class="s1">statements.append(</span>
                    <span class="s1">ast.SinglePosStatement([(glyphs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">record)]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(pos</span><span class="s2">, </span><span class="s1">VAst.PositionAttachDefinition):</span>
            <span class="s1">anchors = {}</span>
            <span class="s2">for </span><span class="s1">marks</span><span class="s2">, </span><span class="s1">classname </span><span class="s2">in </span><span class="s1">pos.coverage_to:</span>
                <span class="s2">for </span><span class="s1">mark </span><span class="s2">in </span><span class="s1">marks:</span>
                    <span class="s4"># Set actually used mark classes. Basically a hack to get</span>
                    <span class="s4"># around the feature file syntax limitation of making mark</span>
                    <span class="s4"># classes global and not allowing mark positioning to</span>
                    <span class="s4"># specify mark coverage.</span>
                    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">mark.glyphSet():</span>
                        <span class="s1">key = (name</span><span class="s2">, </span><span class="s3">&quot;MARK_&quot; </span><span class="s1">+ classname)</span>
                        <span class="s1">self._markclasses[key].used = </span><span class="s2">True</span>
                <span class="s1">markclass = ast.MarkClass(self._className(classname))</span>
                <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">pos.coverage:</span>
                    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">base.glyphSet():</span>
                        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">anchors:</span>
                            <span class="s1">anchors[name] = []</span>
                        <span class="s2">if </span><span class="s1">classname </span><span class="s2">not in </span><span class="s1">anchors[name]:</span>
                            <span class="s1">anchors[name].append(classname)</span>

            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">anchors:</span>
                <span class="s1">components = </span><span class="s5">1</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._ligatures:</span>
                    <span class="s1">components = self._ligatures[name]</span>

                <span class="s1">marks = []</span>
                <span class="s2">for </span><span class="s1">mark </span><span class="s2">in </span><span class="s1">anchors[name]:</span>
                    <span class="s1">markclass = ast.MarkClass(self._className(mark))</span>
                    <span class="s2">for </span><span class="s1">component </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">components + </span><span class="s5">1</span><span class="s1">):</span>
                        <span class="s2">if </span><span class="s1">len(marks) &lt; component:</span>
                            <span class="s1">marks.append([])</span>
                        <span class="s1">anchor = </span><span class="s2">None</span>
                        <span class="s2">if </span><span class="s1">component </span><span class="s2">in </span><span class="s1">self._anchors[name][mark]:</span>
                            <span class="s1">anchor = self._anchors[name][mark][component]</span>
                        <span class="s1">marks[component - </span><span class="s5">1</span><span class="s1">].append((anchor</span><span class="s2">, </span><span class="s1">markclass))</span>

                <span class="s1">base = self._glyphName(name)</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._marks:</span>
                    <span class="s1">mark = ast.MarkMarkPosStatement(base</span><span class="s2">, </span><span class="s1">marks[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._ligatures:</span>
                    <span class="s1">mark = ast.MarkLigPosStatement(base</span><span class="s2">, </span><span class="s1">marks)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">mark = ast.MarkBasePosStatement(base</span><span class="s2">, </span><span class="s1">marks[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s1">statements.append(mark)</span>
        <span class="s2">elif </span><span class="s1">isinstance(pos</span><span class="s2">, </span><span class="s1">VAst.PositionAttachCursiveDefinition):</span>
            <span class="s4"># Collect enter and exit glyphs</span>
            <span class="s1">enter_coverage = []</span>
            <span class="s2">for </span><span class="s1">coverage </span><span class="s2">in </span><span class="s1">pos.coverages_enter:</span>
                <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">coverage:</span>
                    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">base.glyphSet():</span>
                        <span class="s1">enter_coverage.append(name)</span>
            <span class="s1">exit_coverage = []</span>
            <span class="s2">for </span><span class="s1">coverage </span><span class="s2">in </span><span class="s1">pos.coverages_exit:</span>
                <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">coverage:</span>
                    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">base.glyphSet():</span>
                        <span class="s1">exit_coverage.append(name)</span>

            <span class="s4"># Write enter anchors, also check if the glyph has exit anchor and</span>
            <span class="s4"># write it, too.</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enter_coverage:</span>
                <span class="s1">glyph = self._glyphName(name)</span>
                <span class="s1">entry = self._anchors[name][</span><span class="s3">&quot;entry&quot;</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">exit = </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">exit_coverage:</span>
                    <span class="s1">exit = self._anchors[name][</span><span class="s3">&quot;exit&quot;</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">exit_coverage.pop(exit_coverage.index(name))</span>
                <span class="s1">statements.append(ast.CursivePosStatement(glyph</span><span class="s2">, </span><span class="s1">entry</span><span class="s2">, </span><span class="s1">exit))</span>

            <span class="s4"># Write any remaining exit anchors.</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">exit_coverage:</span>
                <span class="s1">glyph = self._glyphName(name)</span>
                <span class="s1">exit = self._anchors[name][</span><span class="s3">&quot;exit&quot;</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">statements.append(ast.CursivePosStatement(glyph</span><span class="s2">, None, </span><span class="s1">exit))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(pos)</span>

    <span class="s2">def </span><span class="s1">_gposContextLookup(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">lookup</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">ignore</span><span class="s2">, </span><span class="s1">fealookup</span><span class="s2">, </span><span class="s1">targetlookup</span>
    <span class="s1">):</span>
        <span class="s1">statements = fealookup.statements</span>

        <span class="s2">assert not </span><span class="s1">lookup.reversal</span>

        <span class="s1">pos = lookup.pos</span>
        <span class="s2">if </span><span class="s1">isinstance(pos</span><span class="s2">, </span><span class="s1">VAst.PositionAdjustPairDefinition):</span>
            <span class="s2">for </span><span class="s1">(idx1</span><span class="s2">, </span><span class="s1">idx2)</span><span class="s2">, </span><span class="s1">(pos1</span><span class="s2">, </span><span class="s1">pos2) </span><span class="s2">in </span><span class="s1">pos.adjust_pair.items():</span>
                <span class="s1">glyphs1 = self._coverage(pos.coverages_1[idx1 - </span><span class="s5">1</span><span class="s1">])</span>
                <span class="s1">glyphs2 = self._coverage(pos.coverages_2[idx2 - </span><span class="s5">1</span><span class="s1">])</span>
                <span class="s2">assert </span><span class="s1">len(glyphs1) == </span><span class="s5">1</span>
                <span class="s2">assert </span><span class="s1">len(glyphs2) == </span><span class="s5">1</span>
                <span class="s1">glyphs = (glyphs1[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">glyphs2[</span><span class="s5">0</span><span class="s1">])</span>

                <span class="s2">if </span><span class="s1">ignore:</span>
                    <span class="s1">statement = ast.IgnorePosStatement([(prefix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">suffix)])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">lookups = (targetlookup</span><span class="s2">, </span><span class="s1">targetlookup)</span>
                    <span class="s1">statement = ast.ChainContextPosStatement(</span>
                        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">lookups</span>
                    <span class="s1">)</span>
                <span class="s1">statements.append(statement)</span>
        <span class="s2">elif </span><span class="s1">isinstance(pos</span><span class="s2">, </span><span class="s1">VAst.PositionAdjustSingleDefinition):</span>
            <span class="s1">glyphs = [ast.GlyphClass()]</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">pos.adjust_single:</span>
                <span class="s1">glyph = self._coverage(a)</span>
                <span class="s1">glyphs[</span><span class="s5">0</span><span class="s1">].extend(glyph)</span>

            <span class="s2">if </span><span class="s1">ignore:</span>
                <span class="s1">statement = ast.IgnorePosStatement([(prefix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">suffix)])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">statement = ast.ChainContextPosStatement(</span>
                    <span class="s1">prefix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">[targetlookup]</span>
                <span class="s1">)</span>
            <span class="s1">statements.append(statement)</span>
        <span class="s2">elif </span><span class="s1">isinstance(pos</span><span class="s2">, </span><span class="s1">VAst.PositionAttachDefinition):</span>
            <span class="s1">glyphs = [ast.GlyphClass()]</span>
            <span class="s2">for </span><span class="s1">coverage</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">pos.coverage_to:</span>
                <span class="s1">glyphs[</span><span class="s5">0</span><span class="s1">].extend(self._coverage(coverage))</span>

            <span class="s2">if </span><span class="s1">ignore:</span>
                <span class="s1">statement = ast.IgnorePosStatement([(prefix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">suffix)])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">statement = ast.ChainContextPosStatement(</span>
                    <span class="s1">prefix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">[targetlookup]</span>
                <span class="s1">)</span>
            <span class="s1">statements.append(statement)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(pos)</span>

    <span class="s2">def </span><span class="s1">_gsubLookup(self</span><span class="s2">, </span><span class="s1">lookup</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">ignore</span><span class="s2">, </span><span class="s1">chain</span><span class="s2">, </span><span class="s1">fealookup):</span>
        <span class="s1">statements = fealookup.statements</span>

        <span class="s1">sub = lookup.sub</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">sub.mapping.items():</span>
            <span class="s2">if not </span><span class="s1">key </span><span class="s2">or not </span><span class="s1">val:</span>
                <span class="s1">path</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">column = sub.location</span>
                <span class="s1">log.warning(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s3">:</span><span class="s2">{</span><span class="s1">line</span><span class="s2">}</span><span class="s3">:</span><span class="s2">{</span><span class="s1">column</span><span class="s2">}</span><span class="s3">: Ignoring empty substitution&quot;</span><span class="s1">)</span>
                <span class="s2">continue</span>
            <span class="s1">statement = </span><span class="s2">None</span>
            <span class="s1">glyphs = self._coverage(key)</span>
            <span class="s1">replacements = self._coverage(val)</span>
            <span class="s2">if </span><span class="s1">ignore:</span>
                <span class="s1">chain_context = (prefix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">suffix)</span>
                <span class="s1">statement = ast.IgnoreSubstStatement([chain_context])</span>
            <span class="s2">elif </span><span class="s1">isinstance(sub</span><span class="s2">, </span><span class="s1">VAst.SubstitutionSingleDefinition):</span>
                <span class="s2">assert </span><span class="s1">len(glyphs) == </span><span class="s5">1</span>
                <span class="s2">assert </span><span class="s1">len(replacements) == </span><span class="s5">1</span>
                <span class="s1">statement = ast.SingleSubstStatement(</span>
                    <span class="s1">glyphs</span><span class="s2">, </span><span class="s1">replacements</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">chain</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(sub</span><span class="s2">, </span><span class="s1">VAst.SubstitutionReverseChainingSingleDefinition):</span>
                <span class="s2">assert </span><span class="s1">len(glyphs) == </span><span class="s5">1</span>
                <span class="s2">assert </span><span class="s1">len(replacements) == </span><span class="s5">1</span>
                <span class="s1">statement = ast.ReverseChainSingleSubstStatement(</span>
                    <span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">replacements</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(sub</span><span class="s2">, </span><span class="s1">VAst.SubstitutionMultipleDefinition):</span>
                <span class="s2">assert </span><span class="s1">len(glyphs) == </span><span class="s5">1</span>
                <span class="s1">statement = ast.MultipleSubstStatement(</span>
                    <span class="s1">prefix</span><span class="s2">, </span><span class="s1">glyphs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">replacements</span><span class="s2">, </span><span class="s1">chain</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(sub</span><span class="s2">, </span><span class="s1">VAst.SubstitutionLigatureDefinition):</span>
                <span class="s2">assert </span><span class="s1">len(replacements) == </span><span class="s5">1</span>
                <span class="s1">statement = ast.LigatureSubstStatement(</span>
                    <span class="s1">prefix</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">replacements[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">chain</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(sub)</span>
            <span class="s1">statements.append(statement)</span>

    <span class="s2">def </span><span class="s1">_lookupDefinition(self</span><span class="s2">, </span><span class="s1">lookup):</span>
        <span class="s1">mark_attachement = </span><span class="s2">None</span>
        <span class="s1">mark_filtering = </span><span class="s2">None</span>

        <span class="s1">flags = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">lookup.direction == </span><span class="s3">&quot;RTL&quot;</span><span class="s1">:</span>
            <span class="s1">flags |= </span><span class="s5">1</span>
        <span class="s2">if not </span><span class="s1">lookup.process_base:</span>
            <span class="s1">flags |= </span><span class="s5">2</span>
        <span class="s4"># FIXME: Does VOLT support this?</span>
        <span class="s4"># if not lookup.process_ligatures:</span>
        <span class="s4">#     flags |= 4</span>
        <span class="s2">if not </span><span class="s1">lookup.process_marks:</span>
            <span class="s1">flags |= </span><span class="s5">8</span>
        <span class="s2">elif </span><span class="s1">isinstance(lookup.process_marks</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">mark_attachement = self._groupName(lookup.process_marks)</span>
        <span class="s2">elif </span><span class="s1">lookup.mark_glyph_set </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">mark_filtering = self._groupName(lookup.mark_glyph_set)</span>

        <span class="s1">lookupflags = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">flags </span><span class="s2">or </span><span class="s1">mark_attachement </span><span class="s2">is not None or </span><span class="s1">mark_filtering </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">lookupflags = ast.LookupFlagStatement(</span>
                <span class="s1">flags</span><span class="s2">, </span><span class="s1">mark_attachement</span><span class="s2">, </span><span class="s1">mark_filtering</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot; </span><span class="s2">in </span><span class="s1">lookup.name:</span>
            <span class="s4"># Merge sub lookups as subtables (lookups named “base\sub”),</span>
            <span class="s4"># makeotf/feaLib will issue a warning and ignore the subtable</span>
            <span class="s4"># statement if it is not a pairpos lookup, though.</span>
            <span class="s1">name = lookup.name.split(</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">name.lower() </span><span class="s2">not in </span><span class="s1">self._lookups:</span>
                <span class="s1">fealookup = ast.LookupBlock(self._lookupName(name))</span>
                <span class="s2">if </span><span class="s1">lookupflags </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">fealookup.statements.append(lookupflags)</span>
                <span class="s1">fealookup.statements.append(ast.Comment(</span><span class="s3">&quot;# &quot; </span><span class="s1">+ lookup.name))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fealookup = self._lookups[name.lower()]</span>
                <span class="s1">fealookup.statements.append(ast.SubtableStatement())</span>
                <span class="s1">fealookup.statements.append(ast.Comment(</span><span class="s3">&quot;# &quot; </span><span class="s1">+ lookup.name))</span>
            <span class="s1">self._lookups[name.lower()] = fealookup</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fealookup = ast.LookupBlock(self._lookupName(lookup.name))</span>
            <span class="s2">if </span><span class="s1">lookupflags </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">fealookup.statements.append(lookupflags)</span>
            <span class="s1">self._lookups[lookup.name.lower()] = fealookup</span>

        <span class="s2">if </span><span class="s1">lookup.comments </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">fealookup.statements.append(ast.Comment(</span><span class="s3">&quot;# &quot; </span><span class="s1">+ lookup.comments))</span>

        <span class="s1">contexts = []</span>
        <span class="s2">if </span><span class="s1">lookup.context:</span>
            <span class="s2">for </span><span class="s1">context </span><span class="s2">in </span><span class="s1">lookup.context:</span>
                <span class="s1">prefix = self._context(context.left)</span>
                <span class="s1">suffix = self._context(context.right)</span>
                <span class="s1">ignore = context.ex_or_in == </span><span class="s3">&quot;EXCEPT_CONTEXT&quot;</span>
                <span class="s1">contexts.append([prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">ignore</span><span class="s2">, False</span><span class="s1">])</span>
                <span class="s4"># It seems that VOLT will create contextual substitution using</span>
                <span class="s4"># only the input if there is no other contexts in this lookup.</span>
                <span class="s2">if </span><span class="s1">ignore </span><span class="s2">and </span><span class="s1">len(lookup.context) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">contexts.append([[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, False, True</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">contexts.append([[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, False, False</span><span class="s1">])</span>

        <span class="s1">targetlookup = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">ignore</span><span class="s2">, </span><span class="s1">chain </span><span class="s2">in </span><span class="s1">contexts:</span>
            <span class="s2">if </span><span class="s1">lookup.sub </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._gsubLookup(lookup</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">ignore</span><span class="s2">, </span><span class="s1">chain</span><span class="s2">, </span><span class="s1">fealookup)</span>

            <span class="s2">if </span><span class="s1">lookup.pos </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self._settings.get(</span><span class="s3">&quot;COMPILER_USEEXTENSIONLOOKUPS&quot;</span><span class="s1">):</span>
                    <span class="s1">fealookup.use_extension = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">prefix </span><span class="s2">or </span><span class="s1">suffix </span><span class="s2">or </span><span class="s1">chain </span><span class="s2">or </span><span class="s1">ignore:</span>
                    <span class="s2">if not </span><span class="s1">ignore </span><span class="s2">and </span><span class="s1">targetlookup </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">targetname = self._lookupName(lookup.name + </span><span class="s3">&quot; target&quot;</span><span class="s1">)</span>
                        <span class="s1">targetlookup = ast.LookupBlock(targetname)</span>
                        <span class="s1">fealookup.targets = getattr(fealookup</span><span class="s2">, </span><span class="s3">&quot;targets&quot;</span><span class="s2">, </span><span class="s1">[])</span>
                        <span class="s1">fealookup.targets.append(targetlookup)</span>
                        <span class="s1">self._gposLookup(lookup</span><span class="s2">, </span><span class="s1">targetlookup)</span>
                    <span class="s1">self._gposContextLookup(</span>
                        <span class="s1">lookup</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">ignore</span><span class="s2">, </span><span class="s1">fealookup</span><span class="s2">, </span><span class="s1">targetlookup</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._gposLookup(lookup</span><span class="s2">, </span><span class="s1">fealookup)</span>


<span class="s2">def </span><span class="s1">main(args=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Convert MS VOLT to AFDKO feature files.&quot;&quot;&quot;</span>

    <span class="s2">import </span><span class="s1">argparse</span>
    <span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>

    <span class="s2">from </span><span class="s1">fontTools </span><span class="s2">import </span><span class="s1">configLogger</span>

    <span class="s1">parser = argparse.ArgumentParser(</span>
        <span class="s3">&quot;fonttools voltLib.voltToFea&quot;</span><span class="s2">, </span><span class="s1">description=main.__doc__</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;input&quot;</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">&quot;INPUT&quot;</span><span class="s2">, </span><span class="s1">type=Path</span><span class="s2">, </span><span class="s1">help=</span><span class="s3">&quot;input font/VTP file to process&quot;</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;featurefile&quot;</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">&quot;OUTPUT&quot;</span><span class="s2">, </span><span class="s1">type=Path</span><span class="s2">, </span><span class="s1">help=</span><span class="s3">&quot;output feature file&quot;</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;-t&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;--table&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s3">&quot;append&quot;</span><span class="s2">,</span>
        <span class="s1">choices=TABLES</span><span class="s2">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;tables&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">&quot;List of tables to write, by default all tables are written&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;-q&quot;</span><span class="s2">, </span><span class="s3">&quot;--quiet&quot;</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s2">, </span><span class="s1">help=</span><span class="s3">&quot;Suppress non-error messages&quot;</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s3">&quot;--traceback&quot;</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s2">, </span><span class="s1">help=</span><span class="s3">&quot;Don’t catch exceptions&quot;</span>
    <span class="s1">)</span>

    <span class="s1">options = parser.parse_args(args)</span>

    <span class="s1">configLogger(level=(</span><span class="s3">&quot;ERROR&quot; </span><span class="s2">if </span><span class="s1">options.quiet </span><span class="s2">else </span><span class="s3">&quot;INFO&quot;</span><span class="s1">))</span>

    <span class="s1">file_or_path = options.input</span>
    <span class="s1">font = </span><span class="s2">None</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">font = TTFont(file_or_path)</span>
        <span class="s2">if </span><span class="s3">&quot;TSIV&quot; </span><span class="s2">in </span><span class="s1">font:</span>
            <span class="s1">file_or_path = StringIO(font[</span><span class="s3">&quot;TSIV&quot;</span><span class="s1">].data.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">log.error(</span><span class="s3">'&quot;TSIV&quot; table is missing, font was not saved from VOLT?'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s5">1</span>
    <span class="s2">except </span><span class="s1">TTLibError:</span>
        <span class="s2">pass</span>

    <span class="s1">converter = VoltToFea(file_or_path</span><span class="s2">, </span><span class="s1">font)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">fea = converter.convert(options.tables)</span>
    <span class="s2">except </span><span class="s1">NotImplementedError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s2">if </span><span class="s1">options.traceback:</span>
            <span class="s2">raise</span>
        <span class="s1">location = getattr(e.args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;location&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">message = </span><span class="s3">f'&quot;</span><span class="s2">{</span><span class="s1">e</span><span class="s2">}</span><span class="s3">&quot; is not supported'</span>
        <span class="s2">if </span><span class="s1">location:</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">column = location</span>
            <span class="s1">log.error(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}</span><span class="s3">:</span><span class="s2">{</span><span class="s1">line</span><span class="s2">}</span><span class="s3">:</span><span class="s2">{</span><span class="s1">column</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">message</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">log.error(message)</span>
        <span class="s2">return </span><span class="s5">1</span>
    <span class="s2">with </span><span class="s1">open(options.featurefile</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">feafile:</span>
        <span class="s1">feafile.write(fea)</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">sys</span>

    <span class="s1">sys.exit(main())</span>
</pre>
</body>
</html>