<html>
<head>
<title>test__differential_evolution.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__differential_evolution.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Unit tests for the differential global minimization algorithm. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">multiprocessing</span>
<span class="s2">import </span><span class="s1">platform</span>

<span class="s2">from </span><span class="s1">scipy.optimize._differentialevolution </span><span class="s2">import </span><span class="s1">(DifferentialEvolutionSolver</span><span class="s2">,</span>
                                                   <span class="s1">_ConstraintWrapper)</span>
<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">differential_evolution</span>
<span class="s2">from </span><span class="s1">scipy.optimize._constraints </span><span class="s2">import </span><span class="s1">(Bounds</span><span class="s2">, </span><span class="s1">NonlinearConstraint</span><span class="s2">,</span>
                                         <span class="s1">LinearConstraint)</span>
<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">rosen</span><span class="s2">, </span><span class="s1">minimize</span>
<span class="s2">from </span><span class="s1">scipy.sparse </span><span class="s2">import </span><span class="s1">csr_matrix</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_string_equal</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">suppress_warnings)</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span><span class="s2">, </span><span class="s1">warns</span>
<span class="s2">import </span><span class="s1">pytest</span>


<span class="s2">class </span><span class="s1">TestDifferentialEvolutionSolver:</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.old_seterr = np.seterr(invalid=</span><span class="s3">'raise'</span><span class="s1">)</span>
        <span class="s1">self.limits = np.array([[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                                <span class="s1">[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]])</span>
        <span class="s1">self.bounds = [(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)]</span>

        <span class="s1">self.dummy_solver = DifferentialEvolutionSolver(self.quadratic</span><span class="s2">,</span>
                                                        <span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)])</span>

        <span class="s5"># dummy_solver2 will be used to test mutation strategies</span>
        <span class="s1">self.dummy_solver2 = DifferentialEvolutionSolver(self.quadratic</span><span class="s2">,</span>
                                                         <span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s2">,</span>
                                                         <span class="s1">popsize=</span><span class="s4">7</span><span class="s2">,</span>
                                                         <span class="s1">mutation=</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s5"># create a population that's only 7 members long</span>
        <span class="s5"># [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]</span>
        <span class="s1">population = np.atleast_2d(np.arange(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)).T</span>
        <span class="s1">self.dummy_solver2.population = population</span>

    <span class="s2">def </span><span class="s1">teardown_method(self):</span>
        <span class="s1">np.seterr(**self.old_seterr)</span>

    <span class="s2">def </span><span class="s1">quadratic(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">]**</span><span class="s4">2</span>

    <span class="s2">def </span><span class="s1">test__strategy_resolves(self):</span>
        <span class="s5"># test that the correct mutation function is resolved by</span>
        <span class="s5"># different requested strategy arguments</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'best1exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'best1exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_best1'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'best1bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'best1bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_best1'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'rand1bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'rand1bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_rand1'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'rand1exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'rand1exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_rand1'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'rand2exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'rand2exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_rand2'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'best2bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'best2bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_best2'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'rand2bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'rand2bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_rand2'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'rand2exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'rand2exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_rand2'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'randtobest1bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'randtobest1bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_randtobest1'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'randtobest1exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'randtobest1exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_randtobest1'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'currenttobest1bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'currenttobest1bin'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_currenttobest1'</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'currenttobest1exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.strategy</span><span class="s2">, </span><span class="s3">'currenttobest1exp'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver.mutation_func.__name__</span><span class="s2">, </span><span class="s3">'_currenttobest1'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test__mutate1(self):</span>
        <span class="s5"># strategies */1/*, i.e. rand/1/bin, best/1/exp, etc.</span>
        <span class="s1">result = np.array([</span><span class="s4">0.05</span><span class="s1">])</span>
        <span class="s1">trial = self.dummy_solver2._best1((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">assert_allclose(trial</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result = np.array([</span><span class="s4">0.25</span><span class="s1">])</span>
        <span class="s1">trial = self.dummy_solver2._rand1((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">assert_allclose(trial</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test__mutate2(self):</span>
        <span class="s5"># strategies */2/*, i.e. rand/2/bin, best/2/exp, etc.</span>
        <span class="s5"># [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]</span>

        <span class="s1">result = np.array([-</span><span class="s4">0.1</span><span class="s1">])</span>
        <span class="s1">trial = self.dummy_solver2._best2((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">assert_allclose(trial</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result = np.array([</span><span class="s4">0.1</span><span class="s1">])</span>
        <span class="s1">trial = self.dummy_solver2._rand2((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">assert_allclose(trial</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test__randtobest1(self):</span>
        <span class="s5"># strategies randtobest/1/*</span>
        <span class="s1">result = np.array([</span><span class="s4">0.15</span><span class="s1">])</span>
        <span class="s1">trial = self.dummy_solver2._randtobest1((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">assert_allclose(trial</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test__currenttobest1(self):</span>
        <span class="s5"># strategies currenttobest/1/*</span>
        <span class="s1">result = np.array([</span><span class="s4">0.1</span><span class="s1">])</span>
        <span class="s1">trial = self.dummy_solver2._currenttobest1(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">assert_allclose(trial</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test_can_init_with_dithering(self):</span>
        <span class="s1">mutation = (</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">solver = DifferentialEvolutionSolver(self.quadratic</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">mutation=mutation)</span>

        <span class="s1">assert_equal(solver.dither</span><span class="s2">, </span><span class="s1">list(mutation))</span>

    <span class="s2">def </span><span class="s1">test_invalid_mutation_values_arent_accepted(self):</span>
        <span class="s1">func = rosen</span>
        <span class="s1">mutation = (</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                          <span class="s1">DifferentialEvolutionSolver</span><span class="s2">,</span>
                          <span class="s1">func</span><span class="s2">,</span>
                          <span class="s1">self.bounds</span><span class="s2">,</span>
                          <span class="s1">mutation=mutation)</span>

        <span class="s1">mutation = (-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                          <span class="s1">DifferentialEvolutionSolver</span><span class="s2">,</span>
                          <span class="s1">func</span><span class="s2">,</span>
                          <span class="s1">self.bounds</span><span class="s2">,</span>
                          <span class="s1">mutation=mutation)</span>

        <span class="s1">mutation = (</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                          <span class="s1">DifferentialEvolutionSolver</span><span class="s2">,</span>
                          <span class="s1">func</span><span class="s2">,</span>
                          <span class="s1">self.bounds</span><span class="s2">,</span>
                          <span class="s1">mutation=mutation)</span>

        <span class="s1">mutation = </span><span class="s4">0.5</span>
        <span class="s1">solver = DifferentialEvolutionSolver(func</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">mutation=mutation)</span>
        <span class="s1">assert_equal(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">solver.scale)</span>
        <span class="s1">assert_equal(</span><span class="s2">None, </span><span class="s1">solver.dither)</span>

    <span class="s2">def </span><span class="s1">test_invalid_functional(self):</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">np.array([np.sum(x ** </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sum(x)])</span>

        <span class="s2">with </span><span class="s1">assert_raises(</span>
                <span class="s1">RuntimeError</span><span class="s2">,</span>
                <span class="s1">match=</span><span class="s3">r&quot;func\(x, \*args\) must return a scalar value&quot;</span><span class="s1">):</span>
            <span class="s1">differential_evolution(func</span><span class="s2">, </span><span class="s1">[(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">test__scale_parameters(self):</span>
        <span class="s1">trial = np.array([</span><span class="s4">0.3</span><span class="s1">])</span>
        <span class="s1">assert_equal(</span><span class="s4">30</span><span class="s2">, </span><span class="s1">self.dummy_solver._scale_parameters(trial))</span>

        <span class="s5"># it should also work with the limits reversed</span>
        <span class="s1">self.dummy_solver.limits = np.array([[</span><span class="s4">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s1">]])</span>
        <span class="s1">assert_equal(</span><span class="s4">30</span><span class="s2">, </span><span class="s1">self.dummy_solver._scale_parameters(trial))</span>

    <span class="s2">def </span><span class="s1">test__unscale_parameters(self):</span>
        <span class="s1">trial = np.array([</span><span class="s4">30</span><span class="s1">])</span>
        <span class="s1">assert_equal(</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">self.dummy_solver._unscale_parameters(trial))</span>

        <span class="s5"># it should also work with the limits reversed</span>
        <span class="s1">self.dummy_solver.limits = np.array([[</span><span class="s4">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s1">]])</span>
        <span class="s1">assert_equal(</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">self.dummy_solver._unscale_parameters(trial))</span>

    <span class="s2">def </span><span class="s1">test_equal_bounds(self):</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'raise'</span><span class="s1">):</span>
            <span class="s1">solver = DifferentialEvolutionSolver(</span>
                <span class="s1">self.quadratic</span><span class="s2">,</span>
                <span class="s1">bounds=[(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">)]</span>
            <span class="s1">)</span>
            <span class="s1">v = solver._unscale_parameters([</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">])</span>
            <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>

        <span class="s1">res = differential_evolution(self.quadratic</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">)])</span>
        <span class="s1">assert_equal(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test__ensure_constraint(self):</span>
        <span class="s1">trial = np.array([</span><span class="s4">1.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">100</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">300.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.00001</span><span class="s1">])</span>
        <span class="s1">self.dummy_solver._ensure_constraint(trial)</span>

        <span class="s1">assert_equal(trial[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">)</span>
        <span class="s1">assert_(np.logical_and(trial &gt;= </span><span class="s4">0</span><span class="s2">, </span><span class="s1">trial &lt;= </span><span class="s4">1</span><span class="s1">).all())</span>

    <span class="s2">def </span><span class="s1">test_differential_evolution(self):</span>
        <span class="s5"># test that the Jmin of DifferentialEvolutionSolver</span>
        <span class="s5"># is the same as the function evaluation</span>
        <span class="s1">solver = DifferentialEvolutionSolver(</span>
            <span class="s1">self.quadratic</span><span class="s2">, </span><span class="s1">[(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">False</span>
        <span class="s1">)</span>
        <span class="s1">result = solver.solve()</span>
        <span class="s1">assert_equal(result.fun</span><span class="s2">, </span><span class="s1">self.quadratic(result.x))</span>

        <span class="s1">solver = DifferentialEvolutionSolver(</span>
            <span class="s1">self.quadratic</span><span class="s2">, </span><span class="s1">[(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">True</span>
        <span class="s1">)</span>
        <span class="s1">result = solver.solve()</span>
        <span class="s1">assert_equal(result.fun</span><span class="s2">, </span><span class="s1">self.quadratic(result.x))</span>

    <span class="s2">def </span><span class="s1">test_best_solution_retrieval(self):</span>
        <span class="s5"># test that the getter property method for the best solution works.</span>
        <span class="s1">solver = DifferentialEvolutionSolver(self.quadratic</span><span class="s2">, </span><span class="s1">[(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)])</span>
        <span class="s1">result = solver.solve()</span>
        <span class="s1">assert_equal(result.x</span><span class="s2">, </span><span class="s1">solver.x)</span>

    <span class="s2">def </span><span class="s1">test_callback_terminates(self):</span>
        <span class="s5"># test that if the callback returns true, then the minimization halts</span>
        <span class="s1">bounds = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span>
        <span class="s1">expected_msg = </span><span class="s3">'callback function requested stop early by returning True'</span>

        <span class="s2">def </span><span class="s1">callback_python_true(param</span><span class="s2">, </span><span class="s1">convergence=</span><span class="s4">0.</span><span class="s1">):</span>
            <span class="s2">return True</span>

        <span class="s1">result = differential_evolution(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">callback=callback_python_true)</span>
        <span class="s1">assert_string_equal(result.message</span><span class="s2">, </span><span class="s1">expected_msg)</span>

        <span class="s2">def </span><span class="s1">callback_evaluates_true(param</span><span class="s2">, </span><span class="s1">convergence=</span><span class="s4">0.</span><span class="s1">):</span>
            <span class="s5"># DE should stop if bool(self.callback) is True</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s4">10</span><span class="s1">]</span>

        <span class="s1">result = differential_evolution(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">callback=callback_evaluates_true)</span>
        <span class="s1">assert_string_equal(result.message</span><span class="s2">, </span><span class="s1">expected_msg)</span>

        <span class="s2">def </span><span class="s1">callback_evaluates_false(param</span><span class="s2">, </span><span class="s1">convergence=</span><span class="s4">0.</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s1">result = differential_evolution(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">callback=callback_evaluates_false)</span>
        <span class="s2">assert </span><span class="s1">result.success</span>

    <span class="s2">def </span><span class="s1">test_args_tuple_is_passed(self):</span>
        <span class="s5"># test that the args tuple is passed to the cost function properly.</span>
        <span class="s1">bounds = [(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)]</span>
        <span class="s1">args = (</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">quadratic(x</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s2">if </span><span class="s1">type(args) != tuple:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'args should be a tuple'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">args[</span><span class="s4">0</span><span class="s1">] + args[</span><span class="s4">1</span><span class="s1">] * x + args[</span><span class="s4">2</span><span class="s1">] * x**</span><span class="s4">2.</span>

        <span class="s1">result = differential_evolution(quadratic</span><span class="s2">,</span>
                                        <span class="s1">bounds</span><span class="s2">,</span>
                                        <span class="s1">args=args</span><span class="s2">,</span>
                                        <span class="s1">polish=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(result.fun</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">/ </span><span class="s4">3.</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_init_with_invalid_strategy(self):</span>
        <span class="s5"># test that passing an invalid strategy raises ValueError</span>
        <span class="s1">func = rosen</span>
        <span class="s1">bounds = [(-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                          <span class="s1">differential_evolution</span><span class="s2">,</span>
                          <span class="s1">func</span><span class="s2">,</span>
                          <span class="s1">bounds</span><span class="s2">,</span>
                          <span class="s1">strategy=</span><span class="s3">'abc'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bounds_checking(self):</span>
        <span class="s5"># test that the bounds checking works</span>
        <span class="s1">func = rosen</span>
        <span class="s1">bounds = [(-</span><span class="s4">3</span><span class="s1">)]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                          <span class="s1">differential_evolution</span><span class="s2">,</span>
                          <span class="s1">func</span><span class="s2">,</span>
                          <span class="s1">bounds)</span>
        <span class="s1">bounds = [(-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                          <span class="s1">differential_evolution</span><span class="s2">,</span>
                          <span class="s1">func</span><span class="s2">,</span>
                          <span class="s1">bounds)</span>

        <span class="s5"># test that we can use a new-type Bounds object</span>
        <span class="s1">result = differential_evolution(rosen</span><span class="s2">, </span><span class="s1">Bounds([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(result.x</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_select_samples(self):</span>
        <span class="s5"># select_samples should return 5 separate random numbers.</span>
        <span class="s1">limits = np.arange(</span><span class="s4">12.</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'float64'</span><span class="s1">).reshape(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">bounds = list(zip(limits[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">limits[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:]))</span>
        <span class="s1">solver = DifferentialEvolutionSolver(</span><span class="s2">None, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">candidate = </span><span class="s4">0</span>
        <span class="s1">r1</span><span class="s2">, </span><span class="s1">r2</span><span class="s2">, </span><span class="s1">r3</span><span class="s2">, </span><span class="s1">r4</span><span class="s2">, </span><span class="s1">r5 = solver._select_samples(candidate</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">len(np.unique(np.array([candidate</span><span class="s2">, </span><span class="s1">r1</span><span class="s2">, </span><span class="s1">r2</span><span class="s2">, </span><span class="s1">r3</span><span class="s2">, </span><span class="s1">r4</span><span class="s2">, </span><span class="s1">r5])))</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_maxiter_stops_solve(self):</span>
        <span class="s5"># test that if the maximum number of iterations is exceeded</span>
        <span class="s5"># the solver stops.</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">result = solver.solve()</span>
        <span class="s1">assert_equal(result.success</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(result.message</span><span class="s2">,</span>
                        <span class="s3">'Maximum number of iterations has been exceeded.'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_maxfun_stops_solve(self):</span>
        <span class="s5"># test that if the maximum number of function evaluations is exceeded</span>
        <span class="s5"># during initialisation the solver stops</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">maxfun=</span><span class="s4">1</span><span class="s2">,</span>
                                             <span class="s1">polish=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">result = solver.solve()</span>

        <span class="s1">assert_equal(result.nfev</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(result.success</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(result.message</span><span class="s2">,</span>
                     <span class="s3">'Maximum number of function evaluations has '</span>
                     <span class="s3">'been exceeded.'</span><span class="s1">)</span>

        <span class="s5"># test that if the maximum number of function evaluations is exceeded</span>
        <span class="s5"># during the actual minimisation, then the solver stops.</span>
        <span class="s5"># Have to turn polishing off, as this will still occur even if maxfun</span>
        <span class="s5"># is reached. For popsize=5 and len(bounds)=2, then there are only 10</span>
        <span class="s5"># function evaluations during initialisation.</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">popsize=</span><span class="s4">5</span><span class="s2">,</span>
                                             <span class="s1">polish=</span><span class="s2">False,</span>
                                             <span class="s1">maxfun=</span><span class="s4">40</span><span class="s1">)</span>
        <span class="s1">result = solver.solve()</span>

        <span class="s1">assert_equal(result.nfev</span><span class="s2">, </span><span class="s4">41</span><span class="s1">)</span>
        <span class="s1">assert_equal(result.success</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(result.message</span><span class="s2">,</span>
                     <span class="s3">'Maximum number of function evaluations has '</span>
                     <span class="s3">'been exceeded.'</span><span class="s1">)</span>

        <span class="s5"># now repeat for updating='deferred version</span>
        <span class="s5"># 47 function evaluations is not a multiple of the population size,</span>
        <span class="s5"># so maxfun is reached partway through a population evaluation.</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">popsize=</span><span class="s4">5</span><span class="s2">,</span>
                                             <span class="s1">polish=</span><span class="s2">False,</span>
                                             <span class="s1">maxfun=</span><span class="s4">47</span><span class="s2">,</span>
                                             <span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s1">)</span>
        <span class="s1">result = solver.solve()</span>

        <span class="s1">assert_equal(result.nfev</span><span class="s2">, </span><span class="s4">47</span><span class="s1">)</span>
        <span class="s1">assert_equal(result.success</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(result.message</span><span class="s2">,</span>
                     <span class="s3">'Maximum number of function evaluations has '</span>
                     <span class="s3">'been reached.'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_quadratic(self):</span>
        <span class="s5"># test the quadratic function from object</span>
        <span class="s1">solver = DifferentialEvolutionSolver(self.quadratic</span><span class="s2">,</span>
                                             <span class="s1">[(-</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">tol=</span><span class="s4">0.02</span><span class="s1">)</span>
        <span class="s1">solver.solve()</span>
        <span class="s1">assert_equal(np.argmin(solver.population_energies)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_quadratic_from_diff_ev(self):</span>
        <span class="s5"># test the quadratic function from differential_evolution function</span>
        <span class="s1">differential_evolution(self.quadratic</span><span class="s2">,</span>
                               <span class="s1">[(-</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span><span class="s2">,</span>
                               <span class="s1">tol=</span><span class="s4">0.02</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_seed_gives_repeatability(self):</span>
        <span class="s1">result = differential_evolution(self.quadratic</span><span class="s2">,</span>
                                        <span class="s1">[(-</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span><span class="s2">,</span>
                                        <span class="s1">polish=</span><span class="s2">False,</span>
                                        <span class="s1">seed=</span><span class="s4">1</span><span class="s2">,</span>
                                        <span class="s1">tol=</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">result2 = differential_evolution(self.quadratic</span><span class="s2">,</span>
                                        <span class="s1">[(-</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span><span class="s2">,</span>
                                        <span class="s1">polish=</span><span class="s2">False,</span>
                                        <span class="s1">seed=</span><span class="s4">1</span><span class="s2">,</span>
                                        <span class="s1">tol=</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_equal(result.x</span><span class="s2">, </span><span class="s1">result2.x)</span>
        <span class="s1">assert_equal(result.nfev</span><span class="s2">, </span><span class="s1">result2.nfev)</span>

    <span class="s2">def </span><span class="s1">test_random_generator(self):</span>
        <span class="s5"># check that np.random.Generator can be used (numpy &gt;= 1.17)</span>
        <span class="s5"># obtain a np.random.Generator object</span>
        <span class="s1">rng = np.random.default_rng()</span>

        <span class="s1">inits = [</span><span class="s3">'random'</span><span class="s2">, </span><span class="s3">'latinhypercube'</span><span class="s2">, </span><span class="s3">'sobol'</span><span class="s2">, </span><span class="s3">'halton'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">init </span><span class="s2">in </span><span class="s1">inits:</span>
            <span class="s1">differential_evolution(self.quadratic</span><span class="s2">,</span>
                                   <span class="s1">[(-</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span><span class="s2">,</span>
                                   <span class="s1">polish=</span><span class="s2">False,</span>
                                   <span class="s1">seed=rng</span><span class="s2">,</span>
                                   <span class="s1">tol=</span><span class="s4">0.5</span><span class="s2">,</span>
                                   <span class="s1">init=init)</span>

    <span class="s2">def </span><span class="s1">test_exp_runs(self):</span>
        <span class="s5"># test whether exponential mutation loop runs</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">,</span>
                                             <span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'best1exp'</span><span class="s2">,</span>
                                             <span class="s1">maxiter=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">solver.solve()</span>

    <span class="s2">def </span><span class="s1">test_gh_4511_regression(self):</span>
        <span class="s5"># This modification of the differential evolution docstring example</span>
        <span class="s5"># uses a custom popsize that had triggered an off-by-one error.</span>
        <span class="s5"># Because we do not care about solving the optimization problem in</span>
        <span class="s5"># this test, we use maxiter=1 to reduce the testing time.</span>
        <span class="s1">bounds = [(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)]</span>
        <span class="s5"># result = differential_evolution(rosen, bounds, popsize=1815,</span>
        <span class="s5">#                                 maxiter=1)</span>

        <span class="s5"># the original issue arose because of rounding error in arange, with</span>
        <span class="s5"># linspace being a much better solution. 1815 is quite a large popsize</span>
        <span class="s5"># to use and results in a long test time (~13s). I used the original</span>
        <span class="s5"># issue to figure out the lowest number of samples that would cause</span>
        <span class="s5"># this rounding error to occur, 49.</span>
        <span class="s1">differential_evolution(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">49</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_calculate_population_energies(self):</span>
        <span class="s5"># if popsize is 3, then the overall generation has size (6,)</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">solver._calculate_population_energies(solver.population)</span>
        <span class="s1">solver._promote_lowest_energy()</span>
        <span class="s1">assert_equal(np.argmin(solver.population_energies)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s5"># initial calculation of the energies should require 6 nfev.</span>
        <span class="s1">assert_equal(solver._nfev</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_iteration(self):</span>
        <span class="s5"># test that DifferentialEvolutionSolver is iterable</span>
        <span class="s5"># if popsize is 3, then the overall generation has size (6,)</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">3</span><span class="s2">,</span>
                                             <span class="s1">maxfun=</span><span class="s4">12</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">fun = next(solver)</span>
        <span class="s1">assert_equal(np.size(x</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s5"># 6 nfev are required for initial calculation of energies, 6 nfev are</span>
        <span class="s5"># required for the evolution of the 6 population members.</span>
        <span class="s1">assert_equal(solver._nfev</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span>

        <span class="s5"># the next generation should halt because it exceeds maxfun</span>
        <span class="s1">assert_raises(StopIteration</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">solver)</span>

        <span class="s5"># check a proper minimisation can be done by an iterable solver</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">fun_prev = next(solver)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">soln </span><span class="s2">in </span><span class="s1">enumerate(solver):</span>
            <span class="s1">x_current</span><span class="s2">, </span><span class="s1">fun_current = soln</span>
            <span class="s2">assert </span><span class="s1">fun_prev &gt;= fun_current</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">fun_prev = x_current</span><span class="s2">, </span><span class="s1">fun_current</span>
            <span class="s5"># need to have this otherwise the solver would never stop.</span>
            <span class="s2">if </span><span class="s1">i == </span><span class="s4">50</span><span class="s1">:</span>
                <span class="s2">break</span>

    <span class="s2">def </span><span class="s1">test_convergence(self):</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">tol=</span><span class="s4">0.2</span><span class="s2">,</span>
                                             <span class="s1">polish=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">solver.solve()</span>
        <span class="s1">assert_(solver.convergence &lt; </span><span class="s4">0.2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_maxiter_none_GH5731(self):</span>
        <span class="s5"># Pre 0.17 the previous default for maxiter and maxfun was None.</span>
        <span class="s5"># the numerical defaults are now 1000 and np.inf. However, some scripts</span>
        <span class="s5"># will still supply None for both of those, this will raise a TypeError</span>
        <span class="s5"># in the solve method.</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s2">None,</span>
                                             <span class="s1">maxfun=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">solver.solve()</span>

    <span class="s2">def </span><span class="s1">test_population_initiation(self):</span>
        <span class="s5"># test the different modes of population initiation</span>

        <span class="s5"># init must be either 'latinhypercube' or 'random'</span>
        <span class="s5"># raising ValueError is something else is passed in</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                      <span class="s1">DifferentialEvolutionSolver</span><span class="s2">,</span>
                      <span class="s1">*(rosen</span><span class="s2">, </span><span class="s1">self.bounds)</span><span class="s2">,</span>
                      <span class="s1">**{</span><span class="s3">'init'</span><span class="s1">: </span><span class="s3">'rubbish'</span><span class="s1">})</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds)</span>

        <span class="s5"># check that population initiation:</span>
        <span class="s5"># 1) resets _nfev to 0</span>
        <span class="s5"># 2) all population energies are np.inf</span>
        <span class="s1">solver.init_population_random()</span>
        <span class="s1">assert_equal(solver._nfev</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(np.isinf(solver.population_energies)))</span>

        <span class="s1">solver.init_population_lhs()</span>
        <span class="s1">assert_equal(solver._nfev</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(np.isinf(solver.population_energies)))</span>

        <span class="s1">solver.init_population_qmc(qmc_engine=</span><span class="s3">'halton'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver._nfev</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(np.isinf(solver.population_energies)))</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">init=</span><span class="s3">'sobol'</span><span class="s1">)</span>
        <span class="s1">solver.init_population_qmc(qmc_engine=</span><span class="s3">'sobol'</span><span class="s1">)</span>
        <span class="s1">assert_equal(solver._nfev</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(np.isinf(solver.population_energies)))</span>

        <span class="s5"># we should be able to initialize with our own array</span>
        <span class="s1">population = np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s1">).reshape(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">,</span>
                                             <span class="s1">init=population</span><span class="s2">,</span>
                                             <span class="s1">strategy=</span><span class="s3">'best2bin'</span><span class="s2">,</span>
                                             <span class="s1">atol=</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">5</span><span class="s1">)</span>

        <span class="s1">assert_equal(solver._nfev</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(np.isinf(solver.population_energies)))</span>
        <span class="s1">assert_(solver.num_population_members == </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_(solver.population_shape == (</span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s5"># check that the population was initialized correctly</span>
        <span class="s1">unscaled_population = np.clip(solver._unscale_parameters(population)</span><span class="s2">,</span>
                                      <span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(solver.population[:</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unscaled_population)</span>

        <span class="s5"># population values need to be clipped to bounds</span>
        <span class="s1">assert_almost_equal(np.min(solver.population[:</span><span class="s4">5</span><span class="s1">])</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(np.max(solver.population[:</span><span class="s4">5</span><span class="s1">])</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># shouldn't be able to initialize with an array if it's the wrong shape</span>
        <span class="s5"># this would have too many parameters</span>
        <span class="s1">population = np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">15</span><span class="s1">).reshape(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">,</span>
                      <span class="s1">DifferentialEvolutionSolver</span><span class="s2">,</span>
                      <span class="s1">*(rosen</span><span class="s2">, </span><span class="s1">self.bounds)</span><span class="s2">,</span>
                      <span class="s1">**{</span><span class="s3">'init'</span><span class="s1">: population})</span>

        <span class="s5"># provide an initial solution</span>
        <span class="s5"># bounds are [(0, 2), (0, 2)]</span>
        <span class="s1">x0 = np.random.uniform(low=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">high=</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">solver = DifferentialEvolutionSolver(</span>
            <span class="s1">rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">x0=x0</span>
        <span class="s1">)</span>
        <span class="s5"># parameters are scaled to unit interval</span>
        <span class="s1">assert_allclose(solver.population[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x0 / </span><span class="s4">2.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_x0(self):</span>
        <span class="s5"># smoke test that checks that x0 is usable.</span>
        <span class="s1">res = differential_evolution(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">res.success</span>

        <span class="s5"># check what happens if some of the x0 lay outside the bounds</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">differential_evolution(rosen</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">2.1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_infinite_objective_function(self):</span>
        <span class="s5"># Test that there are no problems if the objective function</span>
        <span class="s5"># returns inf on some runs</span>
        <span class="s2">def </span><span class="s1">sometimes_inf(x):</span>
            <span class="s2">if </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">.5</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.inf</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">bounds = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s1">differential_evolution(sometimes_inf</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_deferred_updating(self):</span>
        <span class="s5"># check setting of deferred updating, with default workers</span>
        <span class="s1">bounds = [(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)]</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s1">)</span>
        <span class="s1">assert_(solver._updating == </span><span class="s3">'deferred'</span><span class="s1">)</span>
        <span class="s1">assert_(solver._mapwrapper._mapfunc </span><span class="s2">is </span><span class="s1">map)</span>
        <span class="s1">solver.solve()</span>

    <span class="s2">def </span><span class="s1">test_immediate_updating(self):</span>
        <span class="s5"># check setting of immediate updating, with default workers</span>
        <span class="s1">bounds = [(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)]</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">bounds)</span>
        <span class="s1">assert_(solver._updating == </span><span class="s3">'immediate'</span><span class="s1">)</span>

        <span class="s5"># should raise a UserWarning because the updating='immediate'</span>
        <span class="s5"># is being overridden by the workers keyword</span>
        <span class="s2">with </span><span class="s1">warns(UserWarning):</span>
            <span class="s2">with </span><span class="s1">DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">workers=</span><span class="s4">2</span><span class="s1">) </span><span class="s2">as </span><span class="s1">solver:</span>
                <span class="s2">pass</span>
        <span class="s1">assert_(solver._updating == </span><span class="s3">'deferred'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_parallel(self):</span>
        <span class="s5"># smoke test for parallelization with deferred updating</span>
        <span class="s1">bounds = [(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)]</span>
        <span class="s2">with </span><span class="s1">multiprocessing.Pool(</span><span class="s4">2</span><span class="s1">) </span><span class="s2">as </span><span class="s1">p</span><span class="s2">, </span><span class="s1">DifferentialEvolutionSolver(</span>
                <span class="s1">rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s2">, </span><span class="s1">workers=p.map) </span><span class="s2">as </span><span class="s1">solver:</span>
            <span class="s1">assert_(solver._mapwrapper.pool </span><span class="s2">is not None</span><span class="s1">)</span>
            <span class="s1">assert_(solver._updating == </span><span class="s3">'deferred'</span><span class="s1">)</span>
            <span class="s1">solver.solve()</span>

        <span class="s2">with </span><span class="s1">DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s2">,</span>
                                         <span class="s1">workers=</span><span class="s4">2</span><span class="s1">) </span><span class="s2">as </span><span class="s1">solver:</span>
            <span class="s1">assert_(solver._mapwrapper.pool </span><span class="s2">is not None</span><span class="s1">)</span>
            <span class="s1">assert_(solver._updating == </span><span class="s3">'deferred'</span><span class="s1">)</span>
            <span class="s1">solver.solve()</span>

    <span class="s2">def </span><span class="s1">test_converged(self):</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)])</span>
        <span class="s1">solver.solve()</span>
        <span class="s1">assert_(solver.converged())</span>

    <span class="s2">def </span><span class="s1">test_constraint_violation_fn(self):</span>
        <span class="s2">def </span><span class="s1">constr_f(x):</span>
            <span class="s2">return </span><span class="s1">[x[</span><span class="s4">0</span><span class="s1">] + x[</span><span class="s4">1</span><span class="s1">]]</span>

        <span class="s2">def </span><span class="s1">constr_f2(x):</span>
            <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s4">0</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">] - x[</span><span class="s4">1</span><span class="s1">]])</span>

        <span class="s1">nlc = NonlinearConstraint(constr_f</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1.9</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">constraints=(nlc))</span>

        <span class="s1">cv = solver._constraint_violation_fn(np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(cv</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span>

        <span class="s1">nlc2 = NonlinearConstraint(constr_f2</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1.8</span><span class="s1">)</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">constraints=(nlc</span><span class="s2">, </span><span class="s1">nlc2))</span>

        <span class="s5"># for multiple constraints the constraint violations should</span>
        <span class="s5"># be concatenated.</span>
        <span class="s1">xs = [(</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)]</span>
        <span class="s1">vs = [(</span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.64</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2.1</span><span class="s2">, </span><span class="s4">4.2</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)]</span>

        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">vs):</span>
            <span class="s1">cv = solver._constraint_violation_fn(np.array(x))</span>
            <span class="s1">assert_allclose(cv</span><span class="s2">, </span><span class="s1">np.atleast_2d(v))</span>

        <span class="s5"># vectorized calculation of a series of solutions</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">solver._constraint_violation_fn(np.array(xs))</span><span class="s2">, </span><span class="s1">np.array(vs)</span>
        <span class="s1">)</span>

        <span class="s5"># the following line is used in _calculate_population_feasibilities.</span>
        <span class="s5"># _constraint_violation_fn returns an (1, M) array when</span>
        <span class="s5"># x.shape == (N,), i.e. a single solution. Therefore this list</span>
        <span class="s5"># comprehension should generate (S, 1, M) array.</span>
        <span class="s1">constraint_violation = np.array([solver._constraint_violation_fn(x)</span>
                                         <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">np.array(xs)])</span>
        <span class="s2">assert </span><span class="s1">constraint_violation.shape == (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>

        <span class="s5"># we need reasonable error messages if the constraint function doesn't</span>
        <span class="s5"># return the right thing</span>
        <span class="s2">def </span><span class="s1">constr_f3(x):</span>
            <span class="s5"># returns (S, M), rather than (M, S)</span>
            <span class="s2">return </span><span class="s1">constr_f2(x).T</span>

        <span class="s1">nlc2 = NonlinearConstraint(constr_f3</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1.8</span><span class="s1">)</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">constraints=(nlc</span><span class="s2">, </span><span class="s1">nlc2)</span><span class="s2">,</span>
                                             <span class="s1">vectorized=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">solver.vectorized = </span><span class="s2">True</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
                <span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;An array returned from a Constraint&quot;</span>
        <span class="s1">):</span>
            <span class="s1">solver._constraint_violation_fn(np.array(xs))</span>

    <span class="s2">def </span><span class="s1">test_constraint_population_feasibilities(self):</span>
        <span class="s2">def </span><span class="s1">constr_f(x):</span>
            <span class="s2">return </span><span class="s1">[x[</span><span class="s4">0</span><span class="s1">] + x[</span><span class="s4">1</span><span class="s1">]]</span>

        <span class="s2">def </span><span class="s1">constr_f2(x):</span>
            <span class="s2">return </span><span class="s1">[x[</span><span class="s4">0</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">] - x[</span><span class="s4">1</span><span class="s1">]]</span>

        <span class="s1">nlc = NonlinearConstraint(constr_f</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1.9</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">constraints=(nlc))</span>

        <span class="s5"># are population feasibilities correct</span>
        <span class="s5"># [0.5, 0.5] corresponds to scaled values of [1., 1.]</span>
        <span class="s1">feas</span><span class="s2">, </span><span class="s1">cv = solver._calculate_population_feasibilities(</span>
            <span class="s1">np.array([[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]]))</span>
        <span class="s1">assert_equal(feas</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, False</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(cv</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s4">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.1</span><span class="s1">]]))</span>
        <span class="s2">assert </span><span class="s1">cv.shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">nlc2 = NonlinearConstraint(constr_f2</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1.8</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">vectorize </span><span class="s2">in </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">]:</span>
            <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                                 <span class="s1">constraints=(nlc</span><span class="s2">, </span><span class="s1">nlc2)</span><span class="s2">,</span>
                                                 <span class="s1">vectorized=vectorize</span><span class="s2">,</span>
                                                 <span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s1">)</span>

            <span class="s1">feas</span><span class="s2">, </span><span class="s1">cv = solver._calculate_population_feasibilities(</span>
                <span class="s1">np.array([[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.6</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]]))</span>
            <span class="s1">assert_equal(feas</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, False</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(cv</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.64</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]))</span>

            <span class="s1">feas</span><span class="s2">, </span><span class="s1">cv = solver._calculate_population_feasibilities(</span>
                <span class="s1">np.array([[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]]))</span>
            <span class="s1">assert_equal(feas</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, False</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(cv</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.1</span><span class="s2">, </span><span class="s4">4.2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]))</span>
            <span class="s2">assert </span><span class="s1">cv.shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>

            <span class="s1">feas</span><span class="s2">, </span><span class="s1">cv = solver._calculate_population_feasibilities(</span>
                <span class="s1">np.array([[</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]]))</span>
            <span class="s1">assert_equal(feas</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(cv</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.1</span><span class="s2">, </span><span class="s4">4.2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]))</span>
            <span class="s2">assert </span><span class="s1">cv.shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_constraint_solve(self):</span>
        <span class="s2">def </span><span class="s1">constr_f(x):</span>
            <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s4">0</span><span class="s1">] + x[</span><span class="s4">1</span><span class="s1">]])</span>

        <span class="s1">nlc = NonlinearConstraint(constr_f</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1.9</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">constraints=(nlc))</span>

        <span class="s5"># trust-constr warns if the constraint function is linear</span>
        <span class="s2">with </span><span class="s1">warns(UserWarning):</span>
            <span class="s1">res = solver.solve()</span>

        <span class="s2">assert </span><span class="s1">constr_f(res.x) &lt;= </span><span class="s4">1.9</span>
        <span class="s2">assert </span><span class="s1">res.success</span>

    <span class="s2">def </span><span class="s1">test_impossible_constraint(self):</span>
        <span class="s2">def </span><span class="s1">constr_f(x):</span>
            <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s4">0</span><span class="s1">] + x[</span><span class="s4">1</span><span class="s1">]])</span>

        <span class="s1">nlc = NonlinearConstraint(constr_f</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">constraints=(nlc)</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">3</span><span class="s2">,</span>
                                             <span class="s1">seed=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># a UserWarning is issued because the 'trust-constr' polishing is</span>
        <span class="s5"># attempted on the least infeasible solution found.</span>
        <span class="s2">with </span><span class="s1">warns(UserWarning):</span>
            <span class="s1">res = solver.solve()</span>

        <span class="s2">assert </span><span class="s1">res.maxcv &gt; </span><span class="s4">0</span>
        <span class="s2">assert not </span><span class="s1">res.success</span>

        <span class="s5"># test _promote_lowest_energy works when none of the population is</span>
        <span class="s5"># feasible. In this case, the solution with the lowest constraint</span>
        <span class="s5"># violation should be promoted.</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">constraints=(nlc)</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">next(solver)</span>
        <span class="s2">assert not </span><span class="s1">solver.feasible.all()</span>
        <span class="s2">assert not </span><span class="s1">np.isfinite(solver.population_energies).all()</span>

        <span class="s5"># now swap two of the entries in the population</span>
        <span class="s1">l = </span><span class="s4">20</span>
        <span class="s1">cv = solver.constraint_violation[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">solver.population_energies[[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">l]] = solver.population_energies[[l</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s1">solver.population[[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">l]</span><span class="s2">, </span><span class="s1">:] = solver.population[[l</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">solver.constraint_violation[[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">l]</span><span class="s2">, </span><span class="s1">:] = (</span>
            <span class="s1">solver.constraint_violation[[l</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">:])</span>

        <span class="s1">solver._promote_lowest_energy()</span>
        <span class="s1">assert_equal(solver.constraint_violation[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cv)</span>

    <span class="s2">def </span><span class="s1">test_accept_trial(self):</span>
        <span class="s5"># _accept_trial(self, energy_trial, feasible_trial, cv_trial,</span>
        <span class="s5">#               energy_orig, feasible_orig, cv_orig)</span>
        <span class="s2">def </span><span class="s1">constr_f(x):</span>
            <span class="s2">return </span><span class="s1">[x[</span><span class="s4">0</span><span class="s1">] + x[</span><span class="s4">1</span><span class="s1">]]</span>
        <span class="s1">nlc = NonlinearConstraint(constr_f</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1.9</span><span class="s1">)</span>
        <span class="s1">solver = DifferentialEvolutionSolver(rosen</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">,</span>
                                             <span class="s1">constraints=(nlc))</span>
        <span class="s1">fn = solver._accept_trial</span>
        <span class="s5"># both solutions are feasible, select lower energy</span>
        <span class="s2">assert </span><span class="s1">fn(</span><span class="s4">0.1</span><span class="s2">, True, </span><span class="s1">np.array([</span><span class="s4">0.</span><span class="s1">])</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, True, </span><span class="s1">np.array([</span><span class="s4">0.</span><span class="s1">]))</span>
        <span class="s2">assert </span><span class="s1">(fn(</span><span class="s4">1.0</span><span class="s2">, True, </span><span class="s1">np.array([</span><span class="s4">0.0</span><span class="s1">])</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, True, </span><span class="s1">np.array([</span><span class="s4">0.0</span><span class="s1">])) </span><span class="s2">is False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">fn(</span><span class="s4">0.1</span><span class="s2">, True, </span><span class="s1">np.array([</span><span class="s4">0.</span><span class="s1">])</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, True, </span><span class="s1">np.array([</span><span class="s4">0.</span><span class="s1">]))</span>

        <span class="s5"># trial is feasible, original is not</span>
        <span class="s2">assert </span><span class="s1">fn(</span><span class="s4">9.9</span><span class="s2">, True, </span><span class="s1">np.array([</span><span class="s4">0.</span><span class="s1">])</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, False, </span><span class="s1">np.array([</span><span class="s4">1.</span><span class="s1">]))</span>

        <span class="s5"># trial and original are infeasible</span>
        <span class="s5"># cv_trial have to be &lt;= cv_original to be better</span>
        <span class="s2">assert </span><span class="s1">(fn(</span><span class="s4">0.1</span><span class="s2">, False, </span><span class="s1">np.array([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s4">1.0</span><span class="s2">, False, </span><span class="s1">np.array([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])))</span>
        <span class="s2">assert </span><span class="s1">(fn(</span><span class="s4">0.1</span><span class="s2">, False, </span><span class="s1">np.array([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s4">1.0</span><span class="s2">, False, </span><span class="s1">np.array([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.50</span><span class="s1">])))</span>
        <span class="s2">assert </span><span class="s1">(fn(</span><span class="s4">1.0</span><span class="s2">, False, </span><span class="s1">np.array([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, False, </span><span class="s1">np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.4</span><span class="s1">])) </span><span class="s2">is False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_constraint_wrapper(self):</span>
        <span class="s1">lb = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s1">])</span>
        <span class="s1">ub = np.array([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s4">70</span><span class="s1">])</span>
        <span class="s1">x0 = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">pc = _ConstraintWrapper(Bounds(lb</span><span class="s2">, </span><span class="s1">ub)</span><span class="s2">, </span><span class="s1">x0)</span>
        <span class="s2">assert </span><span class="s1">(pc.violation(x0) &gt; </span><span class="s4">0</span><span class="s1">).any()</span>
        <span class="s2">assert </span><span class="s1">(pc.violation([</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">31</span><span class="s1">]) == </span><span class="s4">0</span><span class="s1">).all()</span>

        <span class="s5"># check vectorized Bounds constraint</span>
        <span class="s1">xs = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">16</span><span class="s1">).reshape(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">violations = []</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs:</span>
            <span class="s1">violations.append(pc.violation(x))</span>
        <span class="s1">np.testing.assert_allclose(pc.violation(xs.T)</span><span class="s2">, </span><span class="s1">np.array(violations).T)</span>

        <span class="s1">x0 = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">A = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s1">pc = _ConstraintWrapper(LinearConstraint(A</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">x0)</span>
        <span class="s2">assert </span><span class="s1">(pc.violation(x0) &gt; </span><span class="s4">0</span><span class="s1">).any()</span>
        <span class="s2">assert </span><span class="s1">(pc.violation([-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]) == </span><span class="s4">0</span><span class="s1">).all()</span>

        <span class="s5"># check vectorized LinearConstraint, for 7 lots of parameter vectors</span>
        <span class="s5"># with each parameter vector being 4 long, with 3 constraints</span>
        <span class="s5"># xs is the same shape as stored in the differential evolution</span>
        <span class="s5"># population, but it's sent to the violation function as (len(x), M)</span>
        <span class="s1">xs = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">29</span><span class="s1">).reshape(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">violations = []</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs:</span>
            <span class="s1">violations.append(pc.violation(x))</span>
        <span class="s1">np.testing.assert_allclose(pc.violation(xs.T)</span><span class="s2">, </span><span class="s1">np.array(violations).T)</span>

        <span class="s1">pc = _ConstraintWrapper(LinearConstraint(csr_matrix(A)</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">x0)</span>
        <span class="s2">assert </span><span class="s1">(pc.violation(x0) &gt; </span><span class="s4">0</span><span class="s1">).any()</span>
        <span class="s2">assert </span><span class="s1">(pc.violation([-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]) == </span><span class="s4">0</span><span class="s1">).all()</span>

        <span class="s2">def </span><span class="s1">fun(x):</span>
            <span class="s2">return </span><span class="s1">A.dot(x)</span>

        <span class="s1">nonlinear = NonlinearConstraint(fun</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">pc = _ConstraintWrapper(nonlinear</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">(pc.violation(x0) &gt; </span><span class="s4">0</span><span class="s1">).any()</span>
        <span class="s2">assert </span><span class="s1">(pc.violation([-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]) == </span><span class="s4">0</span><span class="s1">).all()</span>

    <span class="s2">def </span><span class="s1">test_constraint_wrapper_violation(self):</span>
        <span class="s2">def </span><span class="s1">cons_f(x):</span>
            <span class="s5"># written in vectorised form to accept an array of (N, S)</span>
            <span class="s5"># returning (M, S)</span>
            <span class="s5"># where N is the number of parameters,</span>
            <span class="s5"># S is the number of solution vectors to be examined,</span>
            <span class="s5"># and M is the number of constraint components</span>
            <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s4">0</span><span class="s1">] ** </span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">x[</span><span class="s4">0</span><span class="s1">] ** </span><span class="s4">2 </span><span class="s1">- x[</span><span class="s4">1</span><span class="s1">]])</span>

        <span class="s1">nlc = NonlinearConstraint(cons_f</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.8500</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">pc = _ConstraintWrapper(nlc</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">np.size(pc.bounds[</span><span class="s4">0</span><span class="s1">]) == </span><span class="s4">2</span>

        <span class="s1">xs = [(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)]</span>
        <span class="s1">vs = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.64</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.19</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1.14</span><span class="s1">)]</span>

        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">vs):</span>
            <span class="s1">assert_allclose(pc.violation(x)</span><span class="s2">, </span><span class="s1">v)</span>

        <span class="s5"># now check that we can vectorize the constraint wrapper</span>
        <span class="s1">assert_allclose(pc.violation(np.array(xs).T)</span><span class="s2">,</span>
                        <span class="s1">np.array(vs).T)</span>
        <span class="s2">assert </span><span class="s1">pc.fun(np.array(xs).T).shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s1">len(xs))</span>
        <span class="s2">assert </span><span class="s1">pc.violation(np.array(xs).T).shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s1">len(xs))</span>
        <span class="s2">assert </span><span class="s1">pc.num_constr == </span><span class="s4">2</span>
        <span class="s2">assert </span><span class="s1">pc.parameter_count == </span><span class="s4">2</span>

    <span class="s2">def </span><span class="s1">test_L1(self):</span>
        <span class="s5"># Lampinen ([5]) test problem 1</span>

        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s1">fun = np.sum(</span><span class="s4">5</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">5</span><span class="s1">]) - </span><span class="s4">5</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">5</span><span class="s1">]@x[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">5</span><span class="s1">] - np.sum(x[</span><span class="s4">5</span><span class="s1">:])</span>
            <span class="s2">return </span><span class="s1">fun</span>

        <span class="s1">A = np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">14</span><span class="s1">))  </span><span class="s5"># 1-indexed to match reference</span>
        <span class="s1">A[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span><span class="s1">]] = </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]] = -</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">3</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]] = -</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">4</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span><span class="s1">]] = </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">5</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">11</span><span class="s1">]] = -</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">6</span><span class="s2">, </span><span class="s1">[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">11</span><span class="s1">]] = -</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">7</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]] = </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">8</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]] = -</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">9</span><span class="s2">, </span><span class="s1">[</span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]] = -</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">A = A[</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]</span>

        <span class="s1">b = np.array([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">L = LinearConstraint(A</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">b)</span>

        <span class="s1">bounds = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]*</span><span class="s4">9 </span><span class="s1">+ [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]*</span><span class="s4">3 </span><span class="s1">+ [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span>

        <span class="s5"># using a lower popsize to speed the test up</span>
        <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'best1bin'</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1234</span><span class="s2">,</span>
                                     <span class="s1">constraints=(L)</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">x_opt = (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">f_opt = -</span><span class="s4">15</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt)</span>
        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-3</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(A@res.x &lt;= b))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

        <span class="s5"># now repeat the same solve, using the same overall constraints,</span>
        <span class="s5"># but using a sparse matrix for the LinearConstraint instead of an</span>
        <span class="s5"># array</span>

        <span class="s1">L = LinearConstraint(csr_matrix(A)</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">b)</span>

        <span class="s5"># using a lower popsize to speed the test up</span>
        <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'best1bin'</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1234</span><span class="s2">,</span>
                                     <span class="s1">constraints=(L)</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt)</span>
        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-3</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(A@res.x &lt;= b))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

        <span class="s5"># now repeat the same solve, using the same overall constraints,</span>
        <span class="s5"># but specify half the constraints in terms of LinearConstraint,</span>
        <span class="s5"># and the other half by NonlinearConstraint</span>
        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">] + </span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">] + x[</span><span class="s4">11</span><span class="s1">] + x[</span><span class="s4">12</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">8</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">] + x[</span><span class="s4">12</span><span class="s1">]]</span>

        <span class="s2">def </span><span class="s1">c2(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">8</span><span class="s1">] - x[</span><span class="s4">9</span><span class="s1">] + x[</span><span class="s4">12</span><span class="s1">]</span>

        <span class="s1">L = LinearConstraint(A[:</span><span class="s4">5</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">b[:</span><span class="s4">5</span><span class="s1">])</span>
        <span class="s1">L2 = LinearConstraint(A[</span><span class="s4">5</span><span class="s1">:</span><span class="s4">6</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">b[</span><span class="s4">5</span><span class="s1">:</span><span class="s4">6</span><span class="s1">])</span>
        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">b[</span><span class="s4">6</span><span class="s1">:</span><span class="s4">8</span><span class="s1">])</span>
        <span class="s1">N2 = NonlinearConstraint(c2</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">b[</span><span class="s4">8</span><span class="s1">:</span><span class="s4">9</span><span class="s1">])</span>
        <span class="s1">constraints = (L</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">L2</span><span class="s2">, </span><span class="s1">N2)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning)</span>
            <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'rand1bin'</span><span class="s2">,</span>
                                         <span class="s1">seed=</span><span class="s4">1234</span><span class="s2">, </span><span class="s1">constraints=constraints</span><span class="s2">,</span>
                                         <span class="s1">popsize=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-3</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(A@res.x &lt;= b))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_L2(self):</span>
        <span class="s5"># Lampinen ([5]) test problem 2</span>

        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s1">fun = ((x[</span><span class="s4">1</span><span class="s1">]-</span><span class="s4">10</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">5</span><span class="s1">*(x[</span><span class="s4">2</span><span class="s1">]-</span><span class="s4">12</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">3</span><span class="s1">]**</span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">*(x[</span><span class="s4">4</span><span class="s1">]-</span><span class="s4">11</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+</span>
                   <span class="s4">10</span><span class="s1">*x[</span><span class="s4">5</span><span class="s1">]**</span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">7</span><span class="s1">*x[</span><span class="s4">6</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">7</span><span class="s1">]**</span><span class="s4">4 </span><span class="s1">- </span><span class="s4">4</span><span class="s1">*x[</span><span class="s4">6</span><span class="s1">]*x[</span><span class="s4">7</span><span class="s1">] - </span><span class="s4">10</span><span class="s1">*x[</span><span class="s4">6</span><span class="s1">] -</span>
                   <span class="s4">8</span><span class="s1">*x[</span><span class="s4">7</span><span class="s1">])</span>
            <span class="s2">return </span><span class="s1">fun</span>

        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s4">127 </span><span class="s1">- </span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">]**</span><span class="s4">4 </span><span class="s1">- x[</span><span class="s4">3</span><span class="s1">] - </span><span class="s4">4</span><span class="s1">*x[</span><span class="s4">4</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">5</span><span class="s1">*x[</span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s4">196 </span><span class="s1">- </span><span class="s4">23</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">] - x[</span><span class="s4">2</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">6</span><span class="s1">*x[</span><span class="s4">6</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">8</span><span class="s1">*x[</span><span class="s4">7</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s4">282 </span><span class="s1">- </span><span class="s4">7</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">3</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">10</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">- x[</span><span class="s4">4</span><span class="s1">] + x[</span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">4</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">- x[</span><span class="s4">2</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">-</span>
                    <span class="s4">5</span><span class="s1">*x[</span><span class="s4">6</span><span class="s1">] + </span><span class="s4">11</span><span class="s1">*x[</span><span class="s4">7</span><span class="s1">]]</span>

        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">bounds = [(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)]*</span><span class="s4">7</span>
        <span class="s1">constraints = (N)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning)</span>
            <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'rand1bin'</span><span class="s2">,</span>
                                         <span class="s1">seed=</span><span class="s4">1234</span><span class="s2">, </span><span class="s1">constraints=constraints)</span>

        <span class="s1">f_opt = </span><span class="s4">680.6300599487869</span>
        <span class="s1">x_opt = (</span><span class="s4">2.330499</span><span class="s2">, </span><span class="s4">1.951372</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.4775414</span><span class="s2">, </span><span class="s4">4.365726</span><span class="s2">,</span>
                 <span class="s1">-</span><span class="s4">0.6244870</span><span class="s2">, </span><span class="s4">1.038131</span><span class="s2">, </span><span class="s4">1.594227</span><span class="s1">)</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &gt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_L3(self):</span>
        <span class="s5"># Lampinen ([5]) test problem 3</span>

        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s1">fun = (x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">2</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">14</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">16</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">] +</span>
                   <span class="s1">(x[</span><span class="s4">3</span><span class="s1">]-</span><span class="s4">10</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">4</span><span class="s1">*(x[</span><span class="s4">4</span><span class="s1">]-</span><span class="s4">5</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ (x[</span><span class="s4">5</span><span class="s1">]-</span><span class="s4">3</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">*(x[</span><span class="s4">6</span><span class="s1">]-</span><span class="s4">1</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+</span>
                   <span class="s4">5</span><span class="s1">*x[</span><span class="s4">7</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">7</span><span class="s1">*(x[</span><span class="s4">8</span><span class="s1">]-</span><span class="s4">11</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">*(x[</span><span class="s4">9</span><span class="s1">]-</span><span class="s4">10</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+</span>
                   <span class="s1">(x[</span><span class="s4">10</span><span class="s1">] - </span><span class="s4">7</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">45</span>
                   <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">fun  </span><span class="s5"># maximize</span>

        <span class="s1">A = np.zeros((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span>
        <span class="s1">A[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]] = -</span><span class="s4">4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9</span>
        <span class="s1">A[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]] = -</span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span>
        <span class="s1">A[</span><span class="s4">3</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]] = </span><span class="s4">8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span>
        <span class="s1">A = A[</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">b = np.array([-</span><span class="s4">105</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">12</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s4">3</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">6</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">12</span><span class="s1">*(x[</span><span class="s4">9</span><span class="s1">]-</span><span class="s4">8</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">7</span><span class="s1">*x[</span><span class="s4">10</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">3</span><span class="s1">*(x[</span><span class="s4">1</span><span class="s1">]-</span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">4</span><span class="s1">*(x[</span><span class="s4">2</span><span class="s1">]-</span><span class="s4">3</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">7</span><span class="s1">*x[</span><span class="s4">4</span><span class="s1">] + </span><span class="s4">120</span><span class="s2">,</span>
                    <span class="s1">-x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">2</span><span class="s1">*(x[</span><span class="s4">2</span><span class="s1">]-</span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">14</span><span class="s1">*x[</span><span class="s4">5</span><span class="s1">] + </span><span class="s4">6</span><span class="s1">*x[</span><span class="s4">6</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">5</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">8</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">] - (x[</span><span class="s4">3</span><span class="s1">]-</span><span class="s4">6</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">4</span><span class="s1">] + </span><span class="s4">40</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">0.5</span><span class="s1">*(x[</span><span class="s4">1</span><span class="s1">]-</span><span class="s4">8</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">2</span><span class="s1">*(x[</span><span class="s4">2</span><span class="s1">]-</span><span class="s4">4</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3</span><span class="s1">*x[</span><span class="s4">5</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">6</span><span class="s1">] + </span><span class="s4">30</span><span class="s1">]</span>

        <span class="s1">L = LinearConstraint(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">bounds = [(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)]*</span><span class="s4">10</span>
        <span class="s1">constraints = (L</span><span class="s2">, </span><span class="s1">N)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning)</span>
            <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1234</span><span class="s2">,</span>
                                         <span class="s1">constraints=constraints</span><span class="s2">, </span><span class="s1">popsize=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s1">x_opt = (</span><span class="s4">2.171996</span><span class="s2">, </span><span class="s4">2.363683</span><span class="s2">, </span><span class="s4">8.773926</span><span class="s2">, </span><span class="s4">5.095984</span><span class="s2">, </span><span class="s4">0.9906548</span><span class="s2">,</span>
                 <span class="s4">1.430574</span><span class="s2">, </span><span class="s4">1.321644</span><span class="s2">, </span><span class="s4">9.828726</span><span class="s2">, </span><span class="s4">8.280092</span><span class="s2">, </span><span class="s4">8.375927</span><span class="s1">)</span>
        <span class="s1">f_opt = </span><span class="s4">24.3062091</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_(np.all(A @ res.x &gt;= b))</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &gt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_L4(self):</span>
        <span class="s5"># Lampinen ([5]) test problem 4</span>
        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s2">return </span><span class="s1">np.sum(x[:</span><span class="s4">3</span><span class="s1">])</span>

        <span class="s1">A = np.zeros((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">9</span><span class="s1">))</span>
        <span class="s1">A[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]] = </span><span class="s4">0.0025</span><span class="s2">, </span><span class="s4">0.0025</span>
        <span class="s1">A[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]] = </span><span class="s4">0.0025</span><span class="s2">, </span><span class="s4">0.0025</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0025</span>
        <span class="s1">A[</span><span class="s4">3</span><span class="s2">, </span><span class="s1">[</span><span class="s4">8</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]] = </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.01</span>
        <span class="s1">A = A[</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">b = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">[x[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">6</span><span class="s1">] - </span><span class="s4">833.33252</span><span class="s1">*x[</span><span class="s4">4</span><span class="s1">] - </span><span class="s4">100</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">83333.333</span><span class="s2">,</span>
                    <span class="s1">x[</span><span class="s4">2</span><span class="s1">]*x[</span><span class="s4">7</span><span class="s1">] - </span><span class="s4">1250</span><span class="s1">*x[</span><span class="s4">5</span><span class="s1">] - x[</span><span class="s4">2</span><span class="s1">]*x[</span><span class="s4">4</span><span class="s1">] + </span><span class="s4">1250</span><span class="s1">*x[</span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">x[</span><span class="s4">3</span><span class="s1">]*x[</span><span class="s4">8</span><span class="s1">] - </span><span class="s4">1250000 </span><span class="s1">- x[</span><span class="s4">3</span><span class="s1">]*x[</span><span class="s4">5</span><span class="s1">] + </span><span class="s4">2500</span><span class="s1">*x[</span><span class="s4">5</span><span class="s1">]]</span>

        <span class="s1">L = LinearConstraint(A</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf)</span>

        <span class="s1">bounds = [(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">10000</span><span class="s1">)] + [(</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">10000</span><span class="s1">)]*</span><span class="s4">2 </span><span class="s1">+ [(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">)]*</span><span class="s4">5</span>
        <span class="s1">constraints = (L</span><span class="s2">, </span><span class="s1">N)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning)</span>
            <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'rand1bin'</span><span class="s2">,</span>
                                     <span class="s1">seed=</span><span class="s4">1234</span><span class="s2">, </span><span class="s1">constraints=constraints</span><span class="s2">,</span>
                                     <span class="s1">popsize=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s1">f_opt = </span><span class="s4">7049.248</span>

        <span class="s1">x_opt = [</span><span class="s4">579.306692</span><span class="s2">, </span><span class="s4">1359.97063</span><span class="s2">, </span><span class="s4">5109.9707</span><span class="s2">, </span><span class="s4">182.0177</span><span class="s2">, </span><span class="s4">295.601172</span><span class="s2">,</span>
                <span class="s4">217.9823</span><span class="s2">, </span><span class="s4">286.416528</span><span class="s2">, </span><span class="s4">395.601172</span><span class="s1">]</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.001</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.001</span><span class="s1">)</span>

        <span class="s5"># use higher tol here for 32-bit Windows, see gh-11693</span>
        <span class="s2">if </span><span class="s1">(platform.system() == </span><span class="s3">'Windows' </span><span class="s2">and </span><span class="s1">np.dtype(np.intp).itemsize &lt; </span><span class="s4">8</span><span class="s1">):</span>
            <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2.4e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.0035</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># tolerance determined from macOS + MKL failure, see gh-12701</span>
            <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.0024</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_(np.all(A @ res.x &lt;= b))</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &gt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_L5(self):</span>
        <span class="s5"># Lampinen ([5]) test problem 5</span>

        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s1">fun = (np.sin(</span><span class="s4">2</span><span class="s1">*np.pi*x[</span><span class="s4">1</span><span class="s1">])**</span><span class="s4">3</span><span class="s1">*np.sin(</span><span class="s4">2</span><span class="s1">*np.pi*x[</span><span class="s4">2</span><span class="s1">]) /</span>
                   <span class="s1">(x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">3</span><span class="s1">*(x[</span><span class="s4">1</span><span class="s1">]+x[</span><span class="s4">2</span><span class="s1">])))</span>
            <span class="s2">return </span><span class="s1">-fun  </span><span class="s5"># maximize</span>

        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">[x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">- x[</span><span class="s4">2</span><span class="s1">] + </span><span class="s4">1</span><span class="s2">,</span>
                    <span class="s4">1 </span><span class="s1">- x[</span><span class="s4">1</span><span class="s1">] + (x[</span><span class="s4">2</span><span class="s1">]-</span><span class="s4">4</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">bounds = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)]*</span><span class="s4">2</span>
        <span class="s1">constraints = (N)</span>

        <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'rand1bin'</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1234</span><span class="s2">,</span>
                                     <span class="s1">constraints=constraints)</span>

        <span class="s1">x_opt = (</span><span class="s4">1.22797135</span><span class="s2">, </span><span class="s4">4.24537337</span><span class="s1">)</span>
        <span class="s1">f_opt = -</span><span class="s4">0.095825</span>
        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &lt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_L6(self):</span>
        <span class="s5"># Lampinen ([5]) test problem 6</span>
        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s1">fun = (x[</span><span class="s4">1</span><span class="s1">]-</span><span class="s4">10</span><span class="s1">)**</span><span class="s4">3 </span><span class="s1">+ (x[</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">20</span><span class="s1">)**</span><span class="s4">3</span>
            <span class="s2">return </span><span class="s1">fun</span>

        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">[(x[</span><span class="s4">1</span><span class="s1">]-</span><span class="s4">5</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ (x[</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">5</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">100</span><span class="s2">,</span>
                    <span class="s1">-(x[</span><span class="s4">1</span><span class="s1">]-</span><span class="s4">6</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">- (x[</span><span class="s4">2</span><span class="s1">] - </span><span class="s4">5</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">82.81</span><span class="s1">]</span>

        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">bounds = [(</span><span class="s4">13</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span>
        <span class="s1">constraints = (N)</span>
        <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'rand1bin'</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1234</span><span class="s2">,</span>
                                     <span class="s1">constraints=constraints</span><span class="s2">, </span><span class="s1">tol=</span><span class="s4">1e-7</span><span class="s1">)</span>
        <span class="s1">x_opt = (</span><span class="s4">14.095</span><span class="s2">, </span><span class="s4">0.84296</span><span class="s1">)</span>
        <span class="s1">f_opt = -</span><span class="s4">6961.814744</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.001</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &gt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_L7(self):</span>
        <span class="s5"># Lampinen ([5]) test problem 7</span>
        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s1">fun = (</span><span class="s4">5.3578547</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">0.8356891</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">5</span><span class="s1">] +</span>
                   <span class="s4">37.293239</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">40792.141</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">fun</span>

        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">[</span>
                    <span class="s4">85.334407 </span><span class="s1">+ </span><span class="s4">0.0056858</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">]*x[</span><span class="s4">5</span><span class="s1">] + </span><span class="s4">0.0006262</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">4</span><span class="s1">] -</span>
                    <span class="s4">0.0022053</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">]*x[</span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>

                    <span class="s4">80.51249 </span><span class="s1">+ </span><span class="s4">0.0071317</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">]*x[</span><span class="s4">5</span><span class="s1">] + </span><span class="s4">0.0029955</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">2</span><span class="s1">] +</span>
                    <span class="s4">0.0021813</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">]**</span><span class="s4">2</span><span class="s2">,</span>

                    <span class="s4">9.300961 </span><span class="s1">+ </span><span class="s4">0.0047026</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">]*x[</span><span class="s4">5</span><span class="s1">] + </span><span class="s4">0.0012547</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">3</span><span class="s1">] +</span>
                    <span class="s4">0.0019085</span><span class="s1">*x[</span><span class="s4">3</span><span class="s1">]*x[</span><span class="s4">4</span><span class="s1">]</span>
                    <span class="s1">]</span>

        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">90</span><span class="s2">, </span><span class="s4">20</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">92</span><span class="s2">, </span><span class="s4">110</span><span class="s2">, </span><span class="s4">25</span><span class="s1">])</span>

        <span class="s1">bounds = [(</span><span class="s4">78</span><span class="s2">, </span><span class="s4">102</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">33</span><span class="s2">, </span><span class="s4">45</span><span class="s1">)] + [(</span><span class="s4">27</span><span class="s2">, </span><span class="s4">45</span><span class="s1">)]*</span><span class="s4">3</span>
        <span class="s1">constraints = (N)</span>

        <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'rand1bin'</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1234</span><span class="s2">,</span>
                                     <span class="s1">constraints=constraints)</span>

        <span class="s5"># using our best solution, rather than Lampinen/Koziel. Koziel solution</span>
        <span class="s5"># doesn't satisfy constraints, Lampinen f_opt just plain wrong.</span>
        <span class="s1">x_opt = [</span><span class="s4">78.00000686</span><span class="s2">, </span><span class="s4">33.00000362</span><span class="s2">, </span><span class="s4">29.99526064</span><span class="s2">, </span><span class="s4">44.99999971</span><span class="s2">,</span>
                 <span class="s4">36.77579979</span><span class="s1">]</span>

        <span class="s1">f_opt = -</span><span class="s4">30665.537578</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt)</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &gt;= np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">90</span><span class="s2">, </span><span class="s4">20</span><span class="s1">])))</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &lt;= np.array([</span><span class="s4">92</span><span class="s2">, </span><span class="s4">110</span><span class="s2">, </span><span class="s4">25</span><span class="s1">])))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.xfail(platform.machine() == </span><span class="s3">'ppc64le'</span><span class="s2">,</span>
                       <span class="s1">reason=</span><span class="s3">&quot;fails on ppc64le&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_L8(self):</span>
        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s1">fun = </span><span class="s4">3</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">0.000001</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">] + </span><span class="s4">0.000002</span><span class="s1">/</span><span class="s4">3</span><span class="s1">*x[</span><span class="s4">2</span><span class="s1">]**</span><span class="s4">3</span>
            <span class="s2">return </span><span class="s1">fun</span>

        <span class="s1">A = np.zeros((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">A[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]] = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span>
        <span class="s1">A[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]] = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span>
        <span class="s1">A = A[</span><span class="s4">1</span><span class="s1">:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">b = np.array([-</span><span class="s4">.55</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.55</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">[</span>
                    <span class="s4">1000</span><span class="s1">*np.sin(-x[</span><span class="s4">3</span><span class="s1">]-</span><span class="s4">0.25</span><span class="s1">) + </span><span class="s4">1000</span><span class="s1">*np.sin(-x[</span><span class="s4">4</span><span class="s1">]-</span><span class="s4">0.25</span><span class="s1">) +</span>
                    <span class="s4">894.8 </span><span class="s1">- x[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s4">1000</span><span class="s1">*np.sin(x[</span><span class="s4">3</span><span class="s1">]-</span><span class="s4">0.25</span><span class="s1">) + </span><span class="s4">1000</span><span class="s1">*np.sin(x[</span><span class="s4">3</span><span class="s1">]-x[</span><span class="s4">4</span><span class="s1">]-</span><span class="s4">0.25</span><span class="s1">) +</span>
                    <span class="s4">894.8 </span><span class="s1">- x[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s4">1000</span><span class="s1">*np.sin(x[</span><span class="s4">4</span><span class="s1">]-</span><span class="s4">0.25</span><span class="s1">) + </span><span class="s4">1000</span><span class="s1">*np.sin(x[</span><span class="s4">4</span><span class="s1">]-x[</span><span class="s4">3</span><span class="s1">]-</span><span class="s4">0.25</span><span class="s1">) +</span>
                    <span class="s4">1294.8</span>
                    <span class="s1">]</span>
        <span class="s1">L = LinearConstraint(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s1">np.full(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.001</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.full(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.001</span><span class="s1">))</span>

        <span class="s1">bounds = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1200</span><span class="s1">)]*</span><span class="s4">2</span><span class="s1">+[(-</span><span class="s4">.55</span><span class="s2">, </span><span class="s4">.55</span><span class="s1">)]*</span><span class="s4">2</span>
        <span class="s1">constraints = (L</span><span class="s2">, </span><span class="s1">N)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning)</span>
            <span class="s5"># original Lampinen test was with rand1bin, but that takes a</span>
            <span class="s5"># huge amount of CPU time. Changing strategy to best1bin speeds</span>
            <span class="s5"># things up a lot</span>
            <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'best1bin'</span><span class="s2">,</span>
                                         <span class="s1">seed=</span><span class="s4">1234</span><span class="s2">, </span><span class="s1">constraints=constraints</span><span class="s2">,</span>
                                         <span class="s1">maxiter=</span><span class="s4">5000</span><span class="s1">)</span>

        <span class="s1">x_opt = (</span><span class="s4">679.9453</span><span class="s2">, </span><span class="s4">1026.067</span><span class="s2">, </span><span class="s4">0.1188764</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3962336</span><span class="s1">)</span>
        <span class="s1">f_opt = </span><span class="s4">5126.4981</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.x[:</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x_opt[:</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.x[</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">x_opt[</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-2</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_(np.all(A@res.x &gt;= b))</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &gt;= -</span><span class="s4">0.001</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &lt;= </span><span class="s4">0.001</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_L9(self):</span>
        <span class="s5"># Lampinen ([5]) test problem 9</span>

        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ (x[</span><span class="s4">2</span><span class="s1">]-</span><span class="s4">1</span><span class="s1">)**</span><span class="s4">2</span>

        <span class="s2">def </span><span class="s1">c1(x):</span>
            <span class="s1">x = np.hstack(([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x))  </span><span class="s5"># 1-indexed to match reference</span>
            <span class="s2">return </span><span class="s1">[x[</span><span class="s4">2</span><span class="s1">] - x[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">N = NonlinearConstraint(c1</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">.001</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.001</span><span class="s1">])</span>

        <span class="s1">bounds = [(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]*</span><span class="s4">2</span>
        <span class="s1">constraints = (N)</span>
        <span class="s1">res = differential_evolution(f</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">strategy=</span><span class="s3">'rand1bin'</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1234</span><span class="s2">,</span>
                                     <span class="s1">constraints=constraints)</span>

        <span class="s1">x_opt = [np.sqrt(</span><span class="s4">2</span><span class="s1">)/</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span>
        <span class="s1">f_opt = </span><span class="s4">0.75</span>

        <span class="s1">assert_allclose(f(x_opt)</span><span class="s2">, </span><span class="s1">f_opt)</span>
        <span class="s1">assert_allclose(np.abs(res.x)</span><span class="s2">, </span><span class="s1">x_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res.fun</span><span class="s2">, </span><span class="s1">f_opt</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res.success</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &gt;= -</span><span class="s4">0.001</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(np.array(c1(res.x)) &lt;= </span><span class="s4">0.001</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(res.x &gt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">assert_(np.all(res.x &lt;= np.array(bounds)[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_integrality(self):</span>
        <span class="s5"># test fitting discrete distribution to data</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6519843218105</span><span class="s1">)</span>
        <span class="s1">dist = stats.nbinom</span>
        <span class="s1">shapes = (</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">x = dist.rvs(*shapes</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10000</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s2">def </span><span class="s1">func(p</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s1">dist</span><span class="s2">, </span><span class="s1">x = args</span>
            <span class="s5"># negative log-likelihood function</span>
            <span class="s1">ll = -np.log(dist.pmf(x</span><span class="s2">, </span><span class="s1">*p)).sum(axis=-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">np.isnan(ll):  </span><span class="s5"># occurs when x is outside of support</span>
                <span class="s1">ll = np.inf  </span><span class="s5"># we don't want that</span>
            <span class="s2">return </span><span class="s1">ll</span>

        <span class="s1">integrality = [</span><span class="s2">True, False</span><span class="s1">]</span>
        <span class="s1">bounds = [(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">18</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.95</span><span class="s1">)]</span>

        <span class="s1">res = differential_evolution(func</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">args=(dist</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                                     <span class="s1">integrality=integrality</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">False,</span>
                                     <span class="s1">seed=rng)</span>
        <span class="s5"># tolerance has to be fairly relaxed for the second parameter</span>
        <span class="s5"># because we're fitting a distribution to random variates.</span>
        <span class="s2">assert </span><span class="s1">res.x[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">5</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">shapes</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.02</span><span class="s1">)</span>

        <span class="s5"># check that we can still use integrality constraints with polishing</span>
        <span class="s1">res2 = differential_evolution(func</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">args=(dist</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                                      <span class="s1">integrality=integrality</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">True,</span>
                                      <span class="s1">seed=rng)</span>

        <span class="s2">def </span><span class="s1">func2(p</span><span class="s2">, </span><span class="s1">*args):</span>
            <span class="s1">n</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">x = args</span>
            <span class="s2">return </span><span class="s1">func(np.array([n</span><span class="s2">, </span><span class="s1">p[</span><span class="s4">0</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">x)</span>

        <span class="s5"># compare the DE derived solution to an LBFGSB solution (that doesn't</span>
        <span class="s5"># have to find the integral values). Note we're setting x0 to be the</span>
        <span class="s5"># output from the first DE result, thereby making the polishing step</span>
        <span class="s5"># and this minimisation pretty much equivalent.</span>
        <span class="s1">LBFGSB = minimize(func2</span><span class="s2">, </span><span class="s1">res2.x[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
                          <span class="s1">bounds=[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.95</span><span class="s1">)])</span>
        <span class="s1">assert_allclose(res2.x[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">LBFGSB.x)</span>
        <span class="s2">assert </span><span class="s1">res2.fun &lt;= res.fun</span>

    <span class="s2">def </span><span class="s1">test_integrality_limits(self):</span>
        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s2">return </span><span class="s1">x</span>

        <span class="s1">integrality = [</span><span class="s2">True, False, True</span><span class="s1">]</span>
        <span class="s1">bounds = [(</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">2.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3.3</span><span class="s2">, </span><span class="s4">4.9</span><span class="s1">)]</span>

        <span class="s5"># no integrality constraints</span>
        <span class="s1">solver = DifferentialEvolutionSolver(f</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">False,</span>
                                             <span class="s1">integrality=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(solver.limits[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">3.3</span><span class="s1">])</span>
        <span class="s1">assert_allclose(solver.limits[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">2.2</span><span class="s2">, </span><span class="s4">4.9</span><span class="s1">])</span>

        <span class="s5"># with integrality constraints</span>
        <span class="s1">solver = DifferentialEvolutionSolver(f</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">False,</span>
                                             <span class="s1">integrality=integrality)</span>
        <span class="s1">assert_allclose(solver.limits[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">3.5</span><span class="s1">])</span>
        <span class="s1">assert_allclose(solver.limits[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.2</span><span class="s2">, </span><span class="s4">4.5</span><span class="s1">])</span>
        <span class="s1">assert_equal(solver.integrality</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False, True</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">solver.polish </span><span class="s2">is False</span>

        <span class="s1">bounds = [(-</span><span class="s4">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.9</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">2.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">10.3</span><span class="s2">, </span><span class="s4">4.1</span><span class="s1">)]</span>
        <span class="s1">solver = DifferentialEvolutionSolver(f</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">False,</span>
                                             <span class="s1">integrality=integrality)</span>
        <span class="s1">assert_allclose(solver.limits[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10.5</span><span class="s1">])</span>
        <span class="s1">assert_allclose(solver.limits[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2.2</span><span class="s2">, </span><span class="s4">4.5</span><span class="s1">])</span>

        <span class="s5"># A lower bound of -1.2 is converted to</span>
        <span class="s5"># np.nextafter(np.ceil(-1.2) - 0.5, np.inf)</span>
        <span class="s5"># with a similar process to the upper bound. Check that the</span>
        <span class="s5"># conversions work</span>
        <span class="s1">assert_allclose(np.round(solver.limits[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10.0</span><span class="s1">])</span>
        <span class="s1">assert_allclose(np.round(solver.limits[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">])</span>

        <span class="s1">bounds = [(-</span><span class="s4">10.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">8.1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">2.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">10.9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9.9999</span><span class="s1">)]</span>
        <span class="s1">solver = DifferentialEvolutionSolver(f</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">False,</span>
                                             <span class="s1">integrality=integrality)</span>
        <span class="s1">assert_allclose(solver.limits[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">10.5</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10.5</span><span class="s1">])</span>
        <span class="s1">assert_allclose(solver.limits[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">8.5</span><span class="s2">, </span><span class="s4">2.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9.5</span><span class="s1">])</span>

        <span class="s1">bounds = [(-</span><span class="s4">10.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10.1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">2.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">10.9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9.9999</span><span class="s1">)]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">'One of the integrality'</span><span class="s1">):</span>
            <span class="s1">DifferentialEvolutionSolver(f</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">polish=</span><span class="s2">False,</span>
                                        <span class="s1">integrality=integrality)</span>

    <span class="s2">def </span><span class="s1">test_vectorized(self):</span>
        <span class="s2">def </span><span class="s1">quadratic(x):</span>
            <span class="s2">return </span><span class="s1">np.sum(x**</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">quadratic_vec(x):</span>
            <span class="s2">return </span><span class="s1">np.sum(x**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s5"># A vectorized function needs to accept (len(x), S) and return (S,)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">'The vectorized function'</span><span class="s1">):</span>
            <span class="s1">differential_evolution(quadratic</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">,</span>
                                   <span class="s1">vectorized=</span><span class="s2">True, </span><span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s1">)</span>

        <span class="s5"># vectorized overrides the updating keyword, check for warning</span>
        <span class="s2">with </span><span class="s1">warns(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;differential_evolution: the 'vector&quot;</span><span class="s1">):</span>
            <span class="s1">differential_evolution(quadratic_vec</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">,</span>
                                   <span class="s1">vectorized=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s5"># vectorized defers to the workers keyword, check for warning</span>
        <span class="s2">with </span><span class="s1">warns(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;differential_evolution: the 'workers&quot;</span><span class="s1">):</span>
            <span class="s1">differential_evolution(quadratic_vec</span><span class="s2">, </span><span class="s1">self.bounds</span><span class="s2">,</span>
                                   <span class="s1">vectorized=</span><span class="s2">True, </span><span class="s1">workers=map</span><span class="s2">,</span>
                                   <span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s1">)</span>

        <span class="s1">ncalls = [</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">rosen_vec(x):</span>
            <span class="s1">ncalls[</span><span class="s4">0</span><span class="s1">] += </span><span class="s4">1</span>
            <span class="s2">return </span><span class="s1">rosen(x)</span>

        <span class="s1">bounds = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)]</span>
        <span class="s1">res1 = differential_evolution(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s2">,</span>
                                      <span class="s1">seed=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">res2 = differential_evolution(rosen_vec</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">vectorized=</span><span class="s2">True,</span>
                                      <span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># the two minimisation runs should be functionally equivalent</span>
        <span class="s1">assert_allclose(res1.x</span><span class="s2">, </span><span class="s1">res2.x)</span>
        <span class="s2">assert </span><span class="s1">ncalls[</span><span class="s4">0</span><span class="s1">] == res2.nfev</span>
        <span class="s2">assert </span><span class="s1">res1.nit == res2.nit</span>

    <span class="s2">def </span><span class="s1">test_vectorized_constraints(self):</span>
        <span class="s2">def </span><span class="s1">constr_f(x):</span>
            <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s4">0</span><span class="s1">] + x[</span><span class="s4">1</span><span class="s1">]])</span>

        <span class="s2">def </span><span class="s1">constr_f2(x):</span>
            <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s4">0</span><span class="s1">]**</span><span class="s4">2 </span><span class="s1">+ x[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">] - x[</span><span class="s4">1</span><span class="s1">]])</span>

        <span class="s1">nlc1 = NonlinearConstraint(constr_f</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">1.9</span><span class="s1">)</span>
        <span class="s1">nlc2 = NonlinearConstraint(constr_f2</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">))</span>

        <span class="s2">def </span><span class="s1">rosen_vec(x):</span>
            <span class="s5"># accept an (len(x0), S) array, returning a (S,) array</span>
            <span class="s1">v = </span><span class="s4">100 </span><span class="s1">* (x[</span><span class="s4">1</span><span class="s1">:] - x[:-</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2.0</span><span class="s1">)**</span><span class="s4">2.0</span>
            <span class="s1">v += (</span><span class="s4">1 </span><span class="s1">- x[:-</span><span class="s4">1</span><span class="s1">])**</span><span class="s4">2.0</span>
            <span class="s2">return </span><span class="s1">np.squeeze(v)</span>

        <span class="s1">bounds = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)]</span>

        <span class="s1">res1 = differential_evolution(rosen</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s2">,</span>
                                      <span class="s1">seed=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">constraints=[nlc1</span><span class="s2">, </span><span class="s1">nlc2]</span><span class="s2">,</span>
                                      <span class="s1">polish=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">res2 = differential_evolution(rosen_vec</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">vectorized=</span><span class="s2">True,</span>
                                      <span class="s1">updating=</span><span class="s3">'deferred'</span><span class="s2">, </span><span class="s1">seed=</span><span class="s4">1</span><span class="s2">,</span>
                                      <span class="s1">constraints=[nlc1</span><span class="s2">, </span><span class="s1">nlc2]</span><span class="s2">,</span>
                                      <span class="s1">polish=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s5"># the two minimisation runs should be functionally equivalent</span>
        <span class="s1">assert_allclose(res1.x</span><span class="s2">, </span><span class="s1">res2.x)</span>

    <span class="s2">def </span><span class="s1">test_constraint_violation_error_message(self):</span>

        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">np.cos(x[</span><span class="s4">0</span><span class="s1">]) + np.sin(x[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s5"># Intentionally infeasible constraints.</span>
        <span class="s1">c0 = NonlinearConstraint(</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s4">1</span><span class="s1">] - (x[</span><span class="s4">0</span><span class="s1">]-</span><span class="s4">1</span><span class="s1">)**</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">c1 = NonlinearConstraint(</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s4">1</span><span class="s1">] + x[</span><span class="s4">0</span><span class="s1">]**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">result = differential_evolution(func</span><span class="s2">,</span>
                                        <span class="s1">bounds=[(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s2">,</span>
                                        <span class="s1">constraints=[c0</span><span class="s2">, </span><span class="s1">c1]</span><span class="s2">,</span>
                                        <span class="s1">maxiter=</span><span class="s4">10</span><span class="s2">,</span>
                                        <span class="s1">polish=</span><span class="s2">False,</span>
                                        <span class="s1">seed=</span><span class="s4">864197532</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.success </span><span class="s2">is False</span>
        <span class="s5"># The numerical value in the error message might be sensitive to</span>
        <span class="s5"># changes in the implementation.  It can be updated if the code is</span>
        <span class="s5"># changed.  The essential part of the test is that there is a number</span>
        <span class="s5"># after the '=', so if necessary, the text could be reduced to, say,</span>
        <span class="s5"># &quot;MAXCV = 0.&quot;.</span>
        <span class="s2">assert </span><span class="s3">&quot;MAXCV = 0.404&quot; </span><span class="s2">in </span><span class="s1">result.message</span>
</pre>
</body>
</html>