<html>
<head>
<title>table.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
table.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Provides a simple table class.  A SimpleTable is essentially 
a list of lists plus some formatting functionality. 
 
Dependencies: the Python 2.5+ standard library. 
 
Installation: just copy this module into your working directory (or 
   anywhere in your pythonpath). 
 
Basic use:: 
 
   mydata = [[11,12],[21,22]]  # data MUST be 2-dimensional 
   myheaders = [ &quot;Column 1&quot;, &quot;Column 2&quot; ] 
   mystubs = [ &quot;Row 1&quot;, &quot;Row 2&quot; ] 
   tbl = SimpleTable(mydata, myheaders, mystubs, title=&quot;Title&quot;) 
   print( tbl ) 
   print( tbl.as_csv() ) 
 
A SimpleTable is inherently (but not rigidly) rectangular. 
You should create it from a *rectangular* (2d!) iterable of data. 
Each item in your rectangular iterable will become the data 
of a single Cell.  In principle, items can be any object, 
not just numbers and strings.  However, default conversion 
during table production is by simple string interpolation. 
(So you cannot have a tuple as a data item *and* rely on 
the default conversion.) 
 
A SimpleTable allows only one column (the first) of stubs at 
initilization, concatenation of tables allows you to produce tables 
with interior stubs.  (You can also assign the datatype 'stub' to the 
cells in any column, or use ``insert_stubs``.) A SimpleTable can be 
concatenated with another SimpleTable or extended by another 
SimpleTable. :: 
 
    table1.extend_right(table2) 
    table1.extend(table2) 
 
 
A SimpleTable can be initialized with `datatypes`: a list of ints that 
provide indexes into `data_fmts` and `data_aligns`.  Each data cell is 
assigned a datatype, which will control formatting.  If you do not 
specify the `datatypes` list, it will be set to ``range(ncols)`` where 
`ncols` is the number of columns in the data.  (I.e., cells in a 
column have their own datatype.) This means that you can just specify 
`data_fmts` without bothering to provide a `datatypes` list.  If 
``len(datatypes)&lt;ncols`` then datatype assignment will cycle across a 
row.  E.g., if you provide 10 columns of data with ``datatypes=[0,1]`` 
then you will have 5 columns of datatype 0 and 5 columns of datatype 
1, alternating.  Corresponding to this specification, you should provide 
a list of two ``data_fmts`` and a list of two ``data_aligns``. 
 
Cells can be assigned labels as their `datatype` attribute. 
You can then provide a format for that lable. 
Us the SimpleTable's `label_cells` method to do this.  :: 
 
    def mylabeller(cell): 
        if cell.data is np.nan: 
            return 'missing' 
 
    mytable.label_cells(mylabeller) 
    print(mytable.as_text(missing='-')) 
 
 
Potential problems for Python 3 
------------------------------- 
 
- Calls ``next`` instead of ``__next__``. 
  The 2to3 tool should handle that no problem. 
  (We will switch to the `next` function if 2.5 support is ever dropped.) 
- Let me know if you find other problems. 
 
:contact: alan dot isaac at gmail dot com 
:requires: Python 2.5.1+ 
:note: current version 
:note: HTML data format currently specifies tags 
:todo: support a bit more of http://www.oasis-open.org/specs/tr9503.html 
:todo: add labels2formatters method, that associates a cell formatter with a 
       datatype 
:todo: add colspan support to Cell 
:since: 2008-12-21 
:change: 2010-05-02 eliminate newlines that came before and after table 
:change: 2010-05-06 add `label_cells` to `SimpleTable` 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">statsmodels.compat.python </span><span class="s2">import </span><span class="s1">lmap</span><span class="s2">, </span><span class="s1">lrange</span>

<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">cycle</span><span class="s2">, </span><span class="s1">zip_longest</span>
<span class="s2">import </span><span class="s1">csv</span>


<span class="s2">def </span><span class="s1">csv2st(csvfile</span><span class="s2">, </span><span class="s1">headers=</span><span class="s2">False, </span><span class="s1">stubs=</span><span class="s2">False, </span><span class="s1">title=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return SimpleTable instance, 
    created from the data in `csvfile`, 
    which is in comma separated values format. 
    The first row may contain headers: set headers=True. 
    The first column may contain stubs: set stubs=True. 
    Can also supply headers and stubs as tuples of strings. 
    &quot;&quot;&quot;</span>
    <span class="s1">rows = list()</span>
    <span class="s2">with </span><span class="s1">open(csvfile</span><span class="s2">, </span><span class="s3">'r'</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fh:</span>
        <span class="s1">reader = csv.reader(fh)</span>
        <span class="s2">if </span><span class="s1">headers </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">headers = next(reader)</span>
        <span class="s2">elif </span><span class="s1">headers </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s1">headers = ()</span>
        <span class="s2">if </span><span class="s1">stubs </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">stubs = list()</span>
            <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">reader:</span>
                <span class="s2">if </span><span class="s1">row:</span>
                    <span class="s1">stubs.append(row[</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">rows.append(row[</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s5"># no stubs, or stubs provided</span>
            <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">reader:</span>
                <span class="s2">if </span><span class="s1">row:</span>
                    <span class="s1">rows.append(row)</span>
        <span class="s2">if </span><span class="s1">stubs </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s1">stubs = ()</span>
    <span class="s1">ncols = len(rows[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">any(len(row) != ncols </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">rows):</span>
        <span class="s2">raise </span><span class="s1">IOError(</span><span class="s3">'All rows of CSV file must have same length.'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">SimpleTable(data=rows</span><span class="s2">, </span><span class="s1">headers=headers</span><span class="s2">, </span><span class="s1">stubs=stubs)</span>


<span class="s2">class </span><span class="s1">SimpleTable(list):</span>
    <span class="s0">&quot;&quot;&quot;Produce a simple ASCII, CSV, HTML, or LaTeX table from a 
    *rectangular* (2d!) array of data, not necessarily numerical. 
    Directly supports at most one header row, 
    which should be the length of data[0]. 
    Directly supports at most one stubs column, 
    which must be the length of data. 
    (But see `insert_stubs` method.) 
    See globals `default_txt_fmt`, `default_csv_fmt`, `default_html_fmt`, 
    and `default_latex_fmt` for formatting options. 
 
    Sample uses:: 
 
        mydata = [[11,12],[21,22]]  # data MUST be 2-dimensional 
        myheaders = [ &quot;Column 1&quot;, &quot;Column 2&quot; ] 
        mystubs = [ &quot;Row 1&quot;, &quot;Row 2&quot; ] 
        tbl = text.SimpleTable(mydata, myheaders, mystubs, title=&quot;Title&quot;) 
        print( tbl ) 
        print( tbl.as_html() ) 
        # set column specific data formatting 
        tbl = text.SimpleTable(mydata, myheaders, mystubs, 
            data_fmts=[&quot;%3.2f&quot;,&quot;%d&quot;]) 
        print( tbl.as_csv() ) 
        with open('c:/temp/temp.tex','w') as fh: 
            fh.write( tbl.as_latex_tabular() ) 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">headers=</span><span class="s2">None, </span><span class="s1">stubs=</span><span class="s2">None, </span><span class="s1">title=</span><span class="s3">''</span><span class="s2">,</span>
                 <span class="s1">datatypes=</span><span class="s2">None, </span><span class="s1">csv_fmt=</span><span class="s2">None, </span><span class="s1">txt_fmt=</span><span class="s2">None, </span><span class="s1">ltx_fmt=</span><span class="s2">None,</span>
                 <span class="s1">html_fmt=</span><span class="s2">None, </span><span class="s1">celltype=</span><span class="s2">None, </span><span class="s1">rowtype=</span><span class="s2">None, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        data : list of lists or 2d array (not matrix!) 
            R rows by K columns of table elements 
        headers : list (or tuple) of str 
            sequence of K strings, one per header 
        stubs : list (or tuple) of str 
            sequence of R strings, one per stub 
        title : str 
            title of the table 
        datatypes : list of int 
            indexes to `data_fmts` 
        txt_fmt : dict 
            text formatting options 
        ltx_fmt : dict 
            latex formatting options 
        csv_fmt : dict 
            csv formatting options 
        hmtl_fmt : dict 
            hmtl formatting options 
        celltype : class 
            the cell class for the table (default: Cell) 
        rowtype : class 
            the row class for the table (default: Row) 
        fmt_dict : dict 
            general formatting options 
        &quot;&quot;&quot;</span>
        <span class="s1">self.title = title</span>
        <span class="s1">self._datatypes = datatypes</span>
        <span class="s2">if </span><span class="s1">self._datatypes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._datatypes = [] </span><span class="s2">if </span><span class="s1">len(data) == </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">lrange(len(data[</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s5"># start with default formatting</span>
        <span class="s1">self._txt_fmt = default_txt_fmt.copy()</span>
        <span class="s1">self._latex_fmt = default_latex_fmt.copy()</span>
        <span class="s1">self._csv_fmt = default_csv_fmt.copy()</span>
        <span class="s1">self._html_fmt = default_html_fmt.copy()</span>
        <span class="s5"># substitute any general user specified formatting</span>
        <span class="s5"># :note: these will be overridden by output specific arguments</span>
        <span class="s1">self._csv_fmt.update(fmt_dict)</span>
        <span class="s1">self._txt_fmt.update(fmt_dict)</span>
        <span class="s1">self._latex_fmt.update(fmt_dict)</span>
        <span class="s1">self._html_fmt.update(fmt_dict)</span>
        <span class="s5"># substitute any output-type specific formatting</span>
        <span class="s1">self._csv_fmt.update(csv_fmt </span><span class="s2">or </span><span class="s1">dict())</span>
        <span class="s1">self._txt_fmt.update(txt_fmt </span><span class="s2">or </span><span class="s1">dict())</span>
        <span class="s1">self._latex_fmt.update(ltx_fmt </span><span class="s2">or </span><span class="s1">dict())</span>
        <span class="s1">self._html_fmt.update(html_fmt </span><span class="s2">or </span><span class="s1">dict())</span>
        <span class="s1">self.output_formats = dict(</span>
            <span class="s1">txt=self._txt_fmt</span><span class="s2">,</span>
            <span class="s1">csv=self._csv_fmt</span><span class="s2">,</span>
            <span class="s1">html=self._html_fmt</span><span class="s2">,</span>
            <span class="s1">latex=self._latex_fmt</span>
        <span class="s1">)</span>
        <span class="s1">self._Cell = celltype </span><span class="s2">or </span><span class="s1">Cell</span>
        <span class="s1">self._Row = rowtype </span><span class="s2">or </span><span class="s1">Row</span>
        <span class="s1">rows = self._data2rows(data)  </span><span class="s5"># a list of Row instances</span>
        <span class="s1">list.__init__(self</span><span class="s2">, </span><span class="s1">rows)</span>
        <span class="s1">self._add_headers_stubs(headers</span><span class="s2">, </span><span class="s1">stubs)</span>
        <span class="s1">self._colwidths = dict()</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">self.as_text()</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">str(type(self))</span>

    <span class="s2">def </span><span class="s1">_repr_html_(self</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s2">return </span><span class="s1">self.as_html(**fmt_dict)</span>

    <span class="s2">def </span><span class="s1">_repr_latex_(self</span><span class="s2">, </span><span class="s1">center=</span><span class="s2">True, </span><span class="s1">**fmt_dict):</span>
        <span class="s2">return </span><span class="s1">self.as_latex_tabular(center</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>

    <span class="s2">def </span><span class="s1">_add_headers_stubs(self</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">stubs):</span>
        <span class="s0">&quot;&quot;&quot;Return None.  Adds headers and stubs to table, 
        if these were provided at initialization. 
        Parameters 
        ---------- 
        headers : list[str] 
            K strings, where K is number of columns 
        stubs : list[str] 
            R strings, where R is number of non-header rows 
 
        :note: a header row does not receive a stub! 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">headers:</span>
            <span class="s1">self.insert_header_row(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">dec_below=</span><span class="s3">'header_dec_below'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">stubs:</span>
            <span class="s1">self.insert_stubs(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">stubs)</span>

    <span class="s2">def </span><span class="s1">insert(self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">datatype=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return None.  Insert a row into a table. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">datatype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">datatype = row.datatype</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">pass</span>
        <span class="s1">row = self._Row(row</span><span class="s2">, </span><span class="s1">datatype=datatype</span><span class="s2">, </span><span class="s1">table=self)</span>
        <span class="s1">list.insert(self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">row)</span>

    <span class="s2">def </span><span class="s1">insert_header_row(self</span><span class="s2">, </span><span class="s1">rownum</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">dec_below=</span><span class="s3">'header_dec_below'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return None.  Insert a row of headers, 
        where ``headers`` is a sequence of strings. 
        (The strings may contain newlines, to indicated multiline headers.) 
        &quot;&quot;&quot;</span>
        <span class="s1">header_rows = [header.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">header </span><span class="s2">in </span><span class="s1">headers]</span>
        <span class="s5"># rows in reverse order</span>
        <span class="s1">rows = list(zip_longest(*header_rows</span><span class="s2">, </span><span class="s1">**dict(fillvalue=</span><span class="s3">''</span><span class="s1">)))</span>
        <span class="s1">rows.reverse()</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">row </span><span class="s2">in </span><span class="s1">enumerate(rows):</span>
            <span class="s1">self.insert(rownum</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">datatype=</span><span class="s3">'header'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self[rownum].dec_below = dec_below</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self[rownum].dec_below = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">insert_stubs(self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">stubs):</span>
        <span class="s0">&quot;&quot;&quot;Return None.  Insert column of stubs at column `loc`. 
        If there is a header row, it gets an empty cell. 
        So ``len(stubs)`` should equal the number of non-header rows. 
        &quot;&quot;&quot;</span>
        <span class="s1">_Cell = self._Cell</span>
        <span class="s1">stubs = iter(stubs)</span>
        <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">row.datatype == </span><span class="s3">'header'</span><span class="s1">:</span>
                <span class="s1">empty_cell = _Cell(</span><span class="s3">''</span><span class="s2">, </span><span class="s1">datatype=</span><span class="s3">'empty'</span><span class="s1">)</span>
                <span class="s1">row.insert(loc</span><span class="s2">, </span><span class="s1">empty_cell)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">row.insert_stub(loc</span><span class="s2">, </span><span class="s1">next(stubs))</span>
                <span class="s2">except </span><span class="s1">StopIteration:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'length of stubs must match table length'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_data2rows(self</span><span class="s2">, </span><span class="s1">raw_data):</span>
        <span class="s0">&quot;&quot;&quot;Return list of Row, 
        the raw data as rows of cells. 
        &quot;&quot;&quot;</span>

        <span class="s1">_Cell = self._Cell</span>
        <span class="s1">_Row = self._Row</span>
        <span class="s1">rows = []</span>
        <span class="s2">for </span><span class="s1">datarow </span><span class="s2">in </span><span class="s1">raw_data:</span>
            <span class="s1">dtypes = cycle(self._datatypes)</span>
            <span class="s1">newrow = _Row(datarow</span><span class="s2">, </span><span class="s1">datatype=</span><span class="s3">'data'</span><span class="s2">, </span><span class="s1">table=self</span><span class="s2">, </span><span class="s1">celltype=_Cell)</span>
            <span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">newrow:</span>
                <span class="s1">cell.datatype = next(dtypes)</span>
                <span class="s1">cell.row = newrow  </span><span class="s5"># a cell knows its row</span>
            <span class="s1">rows.append(newrow)</span>

        <span class="s2">return </span><span class="s1">rows</span>

    <span class="s2">def </span><span class="s1">pad(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">align):</span>
        <span class="s0">&quot;&quot;&quot;DEPRECATED: just use the pad function&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">pad(s</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">align)</span>

    <span class="s2">def </span><span class="s1">_get_colwidths(self</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return list, the calculated widths of each column.&quot;&quot;&quot;</span>
        <span class="s1">output_format = get_output_format(output_format)</span>
        <span class="s1">fmt = self.output_formats[output_format].copy()</span>
        <span class="s1">fmt.update(fmt_dict)</span>
        <span class="s1">ncols = max(len(row) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">self)</span>
        <span class="s1">request = fmt.get(</span><span class="s3">'colwidths'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">request == </span><span class="s4">0</span><span class="s1">:  </span><span class="s5"># assume no extra space desired (e.g, CSV)</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s4">0</span><span class="s1">] * ncols</span>
        <span class="s2">elif </span><span class="s1">request </span><span class="s2">is None</span><span class="s1">:  </span><span class="s5"># assume no extra space desired (e.g, CSV)</span>
            <span class="s1">request = [</span><span class="s4">0</span><span class="s1">] * ncols</span>
        <span class="s2">elif </span><span class="s1">isinstance(request</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">request = [request] * ncols</span>
        <span class="s2">elif </span><span class="s1">len(request) &lt; ncols:</span>
            <span class="s1">request = [request[i % len(request)] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(ncols)]</span>
        <span class="s1">min_widths = []</span>
        <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">zip(*self):</span>
            <span class="s1">maxwidth = max(len(c.format(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt)) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">col)</span>
            <span class="s1">min_widths.append(maxwidth)</span>
        <span class="s1">result = lmap(max</span><span class="s2">, </span><span class="s1">min_widths</span><span class="s2">, </span><span class="s1">request)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">get_colwidths(self</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return list, the widths of each column.&quot;&quot;&quot;</span>
        <span class="s1">call_args = [output_format]</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">sorted(fmt_dict.items()):</span>
            <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s1">call_args.append((k</span><span class="s2">, </span><span class="s1">tuple(v)))</span>
            <span class="s2">elif </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s1">call_args.append((k</span><span class="s2">, </span><span class="s1">tuple(sorted(v.items()))))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">call_args.append((k</span><span class="s2">, </span><span class="s1">v))</span>
        <span class="s1">key = tuple(call_args)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._colwidths[key]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s1">self._colwidths[key] = self._get_colwidths(output_format</span><span class="s2">,</span>
                                                       <span class="s1">**fmt_dict)</span>
            <span class="s2">return </span><span class="s1">self._colwidths[key]</span>

    <span class="s2">def </span><span class="s1">_get_fmt(self</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return dict, the formatting options. 
        &quot;&quot;&quot;</span>
        <span class="s1">output_format = get_output_format(output_format)</span>
        <span class="s5"># first get the default formatting</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fmt = self.output_formats[output_format].copy()</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown format: %s' </span><span class="s1">% output_format)</span>
        <span class="s5"># then, add formatting specific to this call</span>
        <span class="s1">fmt.update(fmt_dict)</span>
        <span class="s2">return </span><span class="s1">fmt</span>

    <span class="s2">def </span><span class="s1">as_csv(self</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return string, the table in CSV format. 
        Currently only supports comma separator.&quot;&quot;&quot;</span>
        <span class="s5"># fetch the format, which may just be default_csv_format</span>
        <span class="s1">fmt = self._get_fmt(</span><span class="s3">'csv'</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>
        <span class="s2">return </span><span class="s1">self.as_text(**fmt)</span>

    <span class="s2">def </span><span class="s1">as_text(self</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return string, the table as text.&quot;&quot;&quot;</span>
        <span class="s5"># fetch the text format, override with fmt_dict</span>
        <span class="s1">fmt = self._get_fmt(</span><span class="s3">'txt'</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>
        <span class="s5"># get rows formatted as strings</span>
        <span class="s1">formatted_rows = [row.as_string(</span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">**fmt) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">self]</span>
        <span class="s1">rowlen = len(formatted_rows[-</span><span class="s4">1</span><span class="s1">])  </span><span class="s5"># do not use header row</span>

        <span class="s5"># place decoration above the table body, if desired</span>
        <span class="s1">table_dec_above = fmt.get(</span><span class="s3">'table_dec_above'</span><span class="s2">, </span><span class="s3">'='</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">table_dec_above:</span>
            <span class="s1">formatted_rows.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">table_dec_above * rowlen)</span>
        <span class="s5"># next place a title at the very top, if desired</span>
        <span class="s5"># :note: user can include a newlines at end of title if desired</span>
        <span class="s1">title = self.title</span>
        <span class="s2">if </span><span class="s1">title:</span>
            <span class="s1">title = pad(self.title</span><span class="s2">, </span><span class="s1">rowlen</span><span class="s2">, </span><span class="s1">fmt.get(</span><span class="s3">'title_align'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s1">))</span>
            <span class="s1">formatted_rows.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">title)</span>
        <span class="s5"># add decoration below the table, if desired</span>
        <span class="s1">table_dec_below = fmt.get(</span><span class="s3">'table_dec_below'</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">table_dec_below:</span>
            <span class="s1">formatted_rows.append(table_dec_below * rowlen)</span>
        <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(formatted_rows)</span>

    <span class="s2">def </span><span class="s1">as_html(self</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return string. 
        This is the default formatter for HTML tables. 
        An HTML table formatter must accept as arguments 
        a table and a format dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s5"># fetch the text format, override with fmt_dict</span>
        <span class="s1">fmt = self._get_fmt(</span><span class="s3">'html'</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>
        <span class="s1">formatted_rows = [</span><span class="s3">'&lt;table class=&quot;simpletable&quot;&gt;'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.title:</span>
            <span class="s1">title = </span><span class="s3">'&lt;caption&gt;%s&lt;/caption&gt;' </span><span class="s1">% self.title</span>
            <span class="s1">formatted_rows.append(title)</span>
        <span class="s1">formatted_rows.extend(row.as_string(</span><span class="s3">'html'</span><span class="s2">, </span><span class="s1">**fmt) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">self)</span>
        <span class="s1">formatted_rows.append(</span><span class="s3">'&lt;/table&gt;'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(formatted_rows)</span>

    <span class="s2">def </span><span class="s1">as_latex_tabular(self</span><span class="s2">, </span><span class="s1">center=</span><span class="s2">True, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">'''Return string, the table as a LaTeX tabular environment. 
        Note: will require the booktabs package.'''</span>
        <span class="s5"># fetch the text format, override with fmt_dict</span>
        <span class="s1">fmt = self._get_fmt(</span><span class="s3">'latex'</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>

        <span class="s1">formatted_rows = []</span>
        <span class="s2">if </span><span class="s1">center:</span>
            <span class="s1">formatted_rows.append(</span><span class="s3">r'\begin{center}'</span><span class="s1">)</span>

        <span class="s1">table_dec_above = fmt[</span><span class="s3">'table_dec_above'</span><span class="s1">] </span><span class="s2">or </span><span class="s3">''</span>
        <span class="s1">table_dec_below = fmt[</span><span class="s3">'table_dec_below'</span><span class="s1">] </span><span class="s2">or </span><span class="s3">''</span>

        <span class="s1">prev_aligns = </span><span class="s2">None</span>
        <span class="s1">last = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">self + [last]:</span>
            <span class="s2">if </span><span class="s1">row == last:</span>
                <span class="s1">aligns = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">aligns = row.get_aligns(</span><span class="s3">'latex'</span><span class="s2">, </span><span class="s1">**fmt)</span>

            <span class="s2">if </span><span class="s1">aligns != prev_aligns:</span>
                <span class="s5"># When the number/type of columns changes...</span>
                <span class="s2">if </span><span class="s1">prev_aligns:</span>
                    <span class="s5"># ... if there is a tabular to close, close it...</span>
                    <span class="s1">formatted_rows.append(table_dec_below)</span>
                    <span class="s1">formatted_rows.append(</span><span class="s3">r'\end{tabular}'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">aligns:</span>
                    <span class="s5"># ... and if there are more lines, open a new one:</span>
                    <span class="s1">formatted_rows.append(</span><span class="s3">r'\begin{tabular}{%s}' </span><span class="s1">% aligns)</span>
                    <span class="s2">if not </span><span class="s1">prev_aligns:</span>
                        <span class="s5"># (with a nice line if it's the top of the whole table)</span>
                        <span class="s1">formatted_rows.append(table_dec_above)</span>
            <span class="s2">if </span><span class="s1">row != last:</span>
                <span class="s1">formatted_rows.append(</span>
                    <span class="s1">row.as_string(output_format=</span><span class="s3">'latex'</span><span class="s2">, </span><span class="s1">**fmt))</span>
            <span class="s1">prev_aligns = aligns</span>
        <span class="s5"># tabular does not support caption, but make it available for</span>
        <span class="s5"># figure environment</span>
        <span class="s2">if </span><span class="s1">self.title:</span>
            <span class="s1">title = </span><span class="s3">r'%%\caption{%s}' </span><span class="s1">% self.title</span>
            <span class="s1">formatted_rows.append(title)</span>
        <span class="s2">if </span><span class="s1">center:</span>
            <span class="s1">formatted_rows.append(</span><span class="s3">r'\end{center}'</span><span class="s1">)</span>

        <span class="s5"># Replace $$ due to bug in GH 5444</span>
        <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(formatted_rows).replace(</span><span class="s3">'$$'</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">extend_right(self</span><span class="s2">, </span><span class="s1">table):</span>
        <span class="s0">&quot;&quot;&quot;Return None. 
        Extend each row of `self` with corresponding row of `table`. 
        Does **not** import formatting from ``table``. 
        This generally makes sense only if the two tables have 
        the same number of rows, but that is not enforced. 
        :note: To extend append a table below, just use `extend`, 
        which is the ordinary list method.  This generally makes sense 
        only if the two tables have the same number of columns, 
        but that is not enforced. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">row1</span><span class="s2">, </span><span class="s1">row2 </span><span class="s2">in </span><span class="s1">zip(self</span><span class="s2">, </span><span class="s1">table):</span>
            <span class="s1">row1.extend(row2)</span>

    <span class="s2">def </span><span class="s1">label_cells(self</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s0">&quot;&quot;&quot;Return None.  Labels cells based on `func`. 
        If ``func(cell) is None`` then its datatype is 
        not changed; otherwise it is set to ``func(cell)``. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">row:</span>
                <span class="s1">label = func(cell)</span>
                <span class="s2">if </span><span class="s1">label </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">cell.datatype = label</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">data(self):</span>
        <span class="s2">return </span><span class="s1">[row.data </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">self]</span>


<span class="s2">def </span><span class="s1">pad(s</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">align):</span>
    <span class="s0">&quot;&quot;&quot;Return string padded with spaces, 
    based on alignment parameter.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">align == </span><span class="s3">'l'</span><span class="s1">:</span>
        <span class="s1">s = s.ljust(width)</span>
    <span class="s2">elif </span><span class="s1">align == </span><span class="s3">'r'</span><span class="s1">:</span>
        <span class="s1">s = s.rjust(width)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">s = s.center(width)</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">class </span><span class="s1">Row(list):</span>
    <span class="s0">&quot;&quot;&quot;Provides a table row as a list of cells. 
    A row can belong to a SimpleTable, but does not have to. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">seq</span><span class="s2">, </span><span class="s1">datatype=</span><span class="s3">'data'</span><span class="s2">, </span><span class="s1">table=</span><span class="s2">None, </span><span class="s1">celltype=</span><span class="s2">None,</span>
                 <span class="s1">dec_below=</span><span class="s3">'row_dec_below'</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        seq : sequence of data or cells 
        table : SimpleTable 
        datatype : str ('data' or 'header') 
        dec_below : str 
          (e.g., 'header_dec_below' or 'row_dec_below') 
          decoration tag, identifies the decoration to go below the row. 
          (Decoration is repeated as needed for text formats.) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.datatype = datatype</span>
        <span class="s1">self.table = table</span>
        <span class="s2">if </span><span class="s1">celltype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">table </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">celltype = Cell</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">celltype = table._Cell</span>
        <span class="s1">self._Cell = celltype</span>
        <span class="s1">self._fmt = fmt_dict</span>
        <span class="s1">self.special_fmts = dict()  </span><span class="s5"># special formatting for any output format</span>
        <span class="s1">self.dec_below = dec_below</span>
        <span class="s1">list.__init__(self</span><span class="s2">, </span><span class="s1">(celltype(cell</span><span class="s2">, </span><span class="s1">row=self) </span><span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">seq))</span>

    <span class="s2">def </span><span class="s1">add_format(self</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return None. Adds row-instance specific formatting 
        for the specified output format. 
        Example: myrow.add_format('txt', row_dec_below='+-') 
        &quot;&quot;&quot;</span>
        <span class="s1">output_format = get_output_format(output_format)</span>
        <span class="s2">if </span><span class="s1">output_format </span><span class="s2">not in </span><span class="s1">self.special_fmts:</span>
            <span class="s1">self.special_fmts[output_format] = dict()</span>
        <span class="s1">self.special_fmts[output_format].update(fmt_dict)</span>

    <span class="s2">def </span><span class="s1">insert_stub(self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">stub):</span>
        <span class="s0">&quot;&quot;&quot;Return None.  Inserts a stub cell 
        in the row at `loc`. 
        &quot;&quot;&quot;</span>
        <span class="s1">_Cell = self._Cell</span>
        <span class="s2">if not </span><span class="s1">isinstance(stub</span><span class="s2">, </span><span class="s1">_Cell):</span>
            <span class="s1">stub = stub</span>
            <span class="s1">stub = _Cell(stub</span><span class="s2">, </span><span class="s1">datatype=</span><span class="s3">'stub'</span><span class="s2">, </span><span class="s1">row=self)</span>
        <span class="s1">self.insert(loc</span><span class="s2">, </span><span class="s1">stub)</span>

    <span class="s2">def </span><span class="s1">_get_fmt(self</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return dict, the formatting options. 
        &quot;&quot;&quot;</span>
        <span class="s1">output_format = get_output_format(output_format)</span>
        <span class="s5"># first get the default formatting</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fmt = default_fmts[output_format].copy()</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown format: %s' </span><span class="s1">% output_format)</span>
        <span class="s5"># second get table specific formatting (if possible)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fmt.update(self.table.output_formats[output_format])</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s5"># finally, add formatting for this row and this call</span>
        <span class="s1">fmt.update(self._fmt)</span>
        <span class="s1">fmt.update(fmt_dict)</span>
        <span class="s1">special_fmt = self.special_fmts.get(output_format</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">special_fmt </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">fmt.update(special_fmt)</span>
        <span class="s2">return </span><span class="s1">fmt</span>

    <span class="s2">def </span><span class="s1">get_aligns(self</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return string, sequence of column alignments. 
        Ensure comformable data_aligns in `fmt_dict`.&quot;&quot;&quot;</span>
        <span class="s1">fmt = self._get_fmt(output_format</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>
        <span class="s2">return </span><span class="s3">''</span><span class="s1">.join(cell.alignment(output_format</span><span class="s2">, </span><span class="s1">**fmt) </span><span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">as_string(self</span><span class="s2">, </span><span class="s1">output_format=</span><span class="s3">'txt'</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return string: the formatted row. 
        This is the default formatter for rows. 
        Override this to get different formatting. 
        A row formatter must accept as arguments 
        a row (self) and an output format, 
        one of ('html', 'txt', 'csv', 'latex'). 
        &quot;&quot;&quot;</span>
        <span class="s1">fmt = self._get_fmt(output_format</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>

        <span class="s5"># get column widths</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">colwidths = self.table.get_colwidths(output_format</span><span class="s2">, </span><span class="s1">**fmt)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s1">colwidths = fmt.get(</span><span class="s3">'colwidths'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">colwidths </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">colwidths = (</span><span class="s4">0</span><span class="s2">,</span><span class="s1">) * len(self)</span>

        <span class="s1">colsep = fmt[</span><span class="s3">'colsep'</span><span class="s1">]</span>
        <span class="s1">row_pre = fmt.get(</span><span class="s3">'row_pre'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">row_post = fmt.get(</span><span class="s3">'row_post'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">formatted_cells = []</span>
        <span class="s2">for </span><span class="s1">cell</span><span class="s2">, </span><span class="s1">width </span><span class="s2">in </span><span class="s1">zip(self</span><span class="s2">, </span><span class="s1">colwidths):</span>
            <span class="s1">content = cell.format(width</span><span class="s2">, </span><span class="s1">output_format=output_format</span><span class="s2">, </span><span class="s1">**fmt)</span>
            <span class="s1">formatted_cells.append(content)</span>
        <span class="s1">formatted_row = row_pre + colsep.join(formatted_cells) + row_post</span>
        <span class="s1">formatted_row = self._decorate_below(formatted_row</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">,</span>
                                             <span class="s1">**fmt)</span>
        <span class="s2">return </span><span class="s1">formatted_row</span>

    <span class="s2">def </span><span class="s1">_decorate_below(self</span><span class="s2">, </span><span class="s1">row_as_string</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;This really only makes sense for the text and latex output formats. 
        &quot;&quot;&quot;</span>
        <span class="s1">dec_below = fmt_dict.get(self.dec_below</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">dec_below </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">result = row_as_string</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">output_format = get_output_format(output_format)</span>
            <span class="s2">if </span><span class="s1">output_format == </span><span class="s3">'txt'</span><span class="s1">:</span>
                <span class="s1">row0len = len(row_as_string)</span>
                <span class="s1">dec_len = len(dec_below)</span>
                <span class="s1">repeat</span><span class="s2">, </span><span class="s1">addon = divmod(row0len</span><span class="s2">, </span><span class="s1">dec_len)</span>
                <span class="s1">result = row_as_string + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">+ (dec_below * repeat +</span>
                                                 <span class="s1">dec_below[:addon])</span>
            <span class="s2">elif </span><span class="s1">output_format == </span><span class="s3">'latex'</span><span class="s1">:</span>
                <span class="s1">result = row_as_string + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">+ dec_below</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;I cannot decorate a %s header.&quot; </span><span class="s1">%</span>
                                 <span class="s1">output_format)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">data(self):</span>
        <span class="s2">return </span><span class="s1">[cell.data </span><span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">self]</span>


<span class="s2">class </span><span class="s1">Cell:</span>
    <span class="s0">&quot;&quot;&quot;Provides a table cell. 
    A cell can belong to a Row, but does not have to. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">data=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">datatype=</span><span class="s2">None, </span><span class="s1">row=</span><span class="s2">None, </span><span class="s1">**fmt_dict):</span>
        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">Cell):</span>
            <span class="s5"># might have passed a Cell instance</span>
            <span class="s1">self.data = data.data</span>
            <span class="s1">self._datatype = data.datatype</span>
            <span class="s1">self._fmt = data._fmt</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.data = data</span>
            <span class="s1">self._datatype = datatype</span>
            <span class="s1">self._fmt = dict()</span>
        <span class="s1">self._fmt.update(fmt_dict)</span>
        <span class="s1">self.row = row</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">'%s' </span><span class="s1">% self.data</span>

    <span class="s2">def </span><span class="s1">_get_fmt(self</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return dict, the formatting options. 
        &quot;&quot;&quot;</span>
        <span class="s1">output_format = get_output_format(output_format)</span>
        <span class="s5"># first get the default formatting</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fmt = default_fmts[output_format].copy()</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown format: %s' </span><span class="s1">% output_format)</span>
        <span class="s5"># then get any table specific formtting</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fmt.update(self.row.table.output_formats[output_format])</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s5"># then get any row specific formtting</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">fmt.update(self.row._fmt)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s5"># finally add formatting for this instance and call</span>
        <span class="s1">fmt.update(self._fmt)</span>
        <span class="s1">fmt.update(fmt_dict)</span>
        <span class="s2">return </span><span class="s1">fmt</span>

    <span class="s2">def </span><span class="s1">alignment(self</span><span class="s2">, </span><span class="s1">output_format</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s1">fmt = self._get_fmt(output_format</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>
        <span class="s1">datatype = self.datatype</span>
        <span class="s1">data_aligns = fmt.get(</span><span class="s3">'data_aligns'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(datatype</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">align = data_aligns[datatype % len(data_aligns)]</span>
        <span class="s2">elif </span><span class="s1">datatype == </span><span class="s3">'stub'</span><span class="s1">:</span>
            <span class="s5"># still support deprecated `stubs_align`</span>
            <span class="s1">align = fmt.get(</span><span class="s3">'stubs_align'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">fmt.get(</span><span class="s3">'stub_align'</span><span class="s2">, </span><span class="s3">'l'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">datatype </span><span class="s2">in </span><span class="s1">fmt:</span>
            <span class="s1">label_align = </span><span class="s3">'%s_align' </span><span class="s1">% datatype</span>
            <span class="s1">align = fmt.get(label_align</span><span class="s2">, </span><span class="s3">'c'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown cell datatype: %s' </span><span class="s1">% datatype)</span>
        <span class="s2">return </span><span class="s1">align</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_latex_escape(data</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">output_format):</span>
        <span class="s2">if </span><span class="s1">output_format != </span><span class="s3">'latex'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">data</span>
        <span class="s2">if </span><span class="s3">&quot;replacements&quot; </span><span class="s2">in </span><span class="s1">fmt:</span>
            <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">for </span><span class="s1">repl </span><span class="s2">in </span><span class="s1">sorted(fmt[</span><span class="s3">&quot;replacements&quot;</span><span class="s1">]):</span>
                    <span class="s1">data = data.replace(repl</span><span class="s2">, </span><span class="s1">fmt[</span><span class="s3">&quot;replacements&quot;</span><span class="s1">][repl])</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">format(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">output_format=</span><span class="s3">'txt'</span><span class="s2">, </span><span class="s1">**fmt_dict):</span>
        <span class="s0">&quot;&quot;&quot;Return string. 
        This is the default formatter for cells. 
        Override this to get different formating. 
        A cell formatter must accept as arguments 
        a cell (self) and an output format, 
        one of ('html', 'txt', 'csv', 'latex'). 
        It will generally respond to the datatype, 
        one of (int, 'header', 'stub'). 
        &quot;&quot;&quot;</span>
        <span class="s1">fmt = self._get_fmt(output_format</span><span class="s2">, </span><span class="s1">**fmt_dict)</span>

        <span class="s1">data = self.data</span>
        <span class="s1">datatype = self.datatype</span>
        <span class="s1">data_fmts = fmt.get(</span><span class="s3">'data_fmts'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">data_fmts </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s5"># chk allow for deprecated use of data_fmt</span>
            <span class="s1">data_fmt = fmt.get(</span><span class="s3">'data_fmt'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">data_fmt </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">data_fmt = </span><span class="s3">'%s'</span>
            <span class="s1">data_fmts = [data_fmt]</span>
        <span class="s2">if </span><span class="s1">isinstance(datatype</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">datatype = datatype % len(data_fmts)  </span><span class="s5"># constrain to indexes</span>
            <span class="s1">data_fmt = data_fmts[datatype]</span>
            <span class="s2">if </span><span class="s1">isinstance(data_fmt</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">content = data_fmt % (data</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">callable(data_fmt):</span>
                <span class="s1">content = data_fmt(data)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Must be a string or a callable&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">datatype == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">content = self._latex_escape(content</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">output_format)</span>
        <span class="s2">elif </span><span class="s1">datatype </span><span class="s2">in </span><span class="s1">fmt:</span>
            <span class="s1">data = self._latex_escape(data</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">output_format)</span>

            <span class="s1">dfmt = fmt.get(datatype)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">content = dfmt % (data</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">TypeError:  </span><span class="s5"># dfmt is not a substitution string</span>
                <span class="s1">content = dfmt</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown cell datatype: %s' </span><span class="s1">% datatype)</span>
        <span class="s1">align = self.alignment(output_format</span><span class="s2">, </span><span class="s1">**fmt)</span>
        <span class="s2">return </span><span class="s1">pad(content</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">align)</span>

    <span class="s2">def </span><span class="s1">get_datatype(self):</span>
        <span class="s2">if </span><span class="s1">self._datatype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dtype = self.row.datatype</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = self._datatype</span>
        <span class="s2">return </span><span class="s1">dtype</span>

    <span class="s2">def </span><span class="s1">set_datatype(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s5"># TODO: add checking</span>
        <span class="s1">self._datatype = val</span>
    <span class="s1">datatype = property(get_datatype</span><span class="s2">, </span><span class="s1">set_datatype)</span>


<span class="s5"># begin: default formats for SimpleTable</span>
<span class="s3">&quot;&quot;&quot; Some formatting suggestions: 
 
- if you want rows to have no extra spacing, 
  set colwidths=0 and colsep=''. 
  (Naturally the columns will not align.) 
- if you want rows to have minimal extra spacing, 
  set colwidths=1.  The columns will align. 
- to get consistent formatting, you should leave 
  all field width handling to SimpleTable: 
  use 0 as the field width in data_fmts.  E.g., :: 
 
        data_fmts = [&quot;%#0.6g&quot;,&quot;%#0.6g&quot;,&quot;%#0.4g&quot;,&quot;%#0.4g&quot;], 
        colwidths = 14, 
        data_aligns = &quot;r&quot;, 
&quot;&quot;&quot;</span>
<span class="s1">default_txt_fmt = dict(</span>
    <span class="s1">fmt=</span><span class="s3">'txt'</span><span class="s2">,</span>
    <span class="s5"># basic table formatting</span>
    <span class="s1">table_dec_above=</span><span class="s3">'='</span><span class="s2">,</span>
    <span class="s1">table_dec_below=</span><span class="s3">'-'</span><span class="s2">,</span>
    <span class="s1">title_align=</span><span class="s3">'c'</span><span class="s2">,</span>
    <span class="s5"># basic row formatting</span>
    <span class="s1">row_pre=</span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">row_post=</span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">header_dec_below=</span><span class="s3">'-'</span><span class="s2">,</span>
    <span class="s1">row_dec_below=</span><span class="s2">None,</span>
    <span class="s1">colwidths=</span><span class="s2">None,</span>
    <span class="s1">colsep=</span><span class="s3">' '</span><span class="s2">,</span>
    <span class="s1">data_aligns=</span><span class="s3">&quot;r&quot;</span><span class="s2">,  </span><span class="s5"># GH 1477</span>
    <span class="s5"># data formats</span>
    <span class="s5"># data_fmt=&quot;%s&quot;,  #deprecated; use data_fmts</span>
    <span class="s1">data_fmts=[</span><span class="s3">&quot;%s&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s5"># labeled alignments</span>
    <span class="s5"># stubs_align='l',   #deprecated; use data_fmts</span>
    <span class="s1">stub_align=</span><span class="s3">'l'</span><span class="s2">,</span>
    <span class="s1">header_align=</span><span class="s3">'c'</span><span class="s2">,</span>
    <span class="s5"># labeled formats</span>
    <span class="s1">header_fmt=</span><span class="s3">'%s'</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'header'</span>
    <span class="s1">stub_fmt=</span><span class="s3">'%s'</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'stub'</span>
    <span class="s1">header=</span><span class="s3">'%s'</span><span class="s2">,</span>
    <span class="s1">stub=</span><span class="s3">'%s'</span><span class="s2">,</span>
    <span class="s1">empty_cell=</span><span class="s3">''</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'empty'</span>
    <span class="s1">empty=</span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">missing=</span><span class="s3">'--'</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">default_csv_fmt = dict(</span>
    <span class="s1">fmt=</span><span class="s3">'csv'</span><span class="s2">,</span>
    <span class="s1">table_dec_above=</span><span class="s2">None,  </span><span class="s5"># '',</span>
    <span class="s1">table_dec_below=</span><span class="s2">None,  </span><span class="s5"># '',</span>
    <span class="s5"># basic row formatting</span>
    <span class="s1">row_pre=</span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">row_post=</span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">header_dec_below=</span><span class="s2">None,  </span><span class="s5"># '',</span>
    <span class="s1">row_dec_below=</span><span class="s2">None,</span>
    <span class="s1">title_align=</span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">data_aligns=</span><span class="s3">&quot;l&quot;</span><span class="s2">,</span>
    <span class="s1">colwidths=</span><span class="s2">None,</span>
    <span class="s1">colsep=</span><span class="s3">','</span><span class="s2">,</span>
    <span class="s5"># data formats</span>
    <span class="s1">data_fmt=</span><span class="s3">'%s'</span><span class="s2">,  </span><span class="s5"># deprecated; use data_fmts</span>
    <span class="s1">data_fmts=[</span><span class="s3">'%s'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s5"># labeled alignments</span>
    <span class="s5"># stubs_align='l',   # deprecated; use data_fmts</span>
    <span class="s1">stub_align=</span><span class="s3">&quot;l&quot;</span><span class="s2">,</span>
    <span class="s1">header_align=</span><span class="s3">'c'</span><span class="s2">,</span>
    <span class="s5"># labeled formats</span>
    <span class="s1">header_fmt=</span><span class="s3">'&quot;%s&quot;'</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'header'</span>
    <span class="s1">stub_fmt=</span><span class="s3">'&quot;%s&quot;'</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'stub'</span>
    <span class="s1">empty_cell=</span><span class="s3">''</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'empty'</span>
    <span class="s1">header=</span><span class="s3">'%s'</span><span class="s2">,</span>
    <span class="s1">stub=</span><span class="s3">'%s'</span><span class="s2">,</span>
    <span class="s1">empty=</span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">missing=</span><span class="s3">'--'</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">default_html_fmt = dict(</span>
    <span class="s5"># basic table formatting</span>
    <span class="s1">table_dec_above=</span><span class="s2">None,</span>
    <span class="s1">table_dec_below=</span><span class="s2">None,</span>
    <span class="s1">header_dec_below=</span><span class="s2">None,</span>
    <span class="s1">row_dec_below=</span><span class="s2">None,</span>
    <span class="s1">title_align=</span><span class="s3">'c'</span><span class="s2">,</span>
    <span class="s5"># basic row formatting</span>
    <span class="s1">colwidths=</span><span class="s2">None,</span>
    <span class="s1">colsep=</span><span class="s3">' '</span><span class="s2">,</span>
    <span class="s1">row_pre=</span><span class="s3">'&lt;tr&gt;</span><span class="s2">\n  </span><span class="s3">'</span><span class="s2">,</span>
    <span class="s1">row_post=</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">&lt;/tr&gt;'</span><span class="s2">,</span>
    <span class="s1">data_aligns=</span><span class="s3">&quot;c&quot;</span><span class="s2">,</span>
    <span class="s5"># data formats</span>
    <span class="s1">data_fmts=[</span><span class="s3">'&lt;td&gt;%s&lt;/td&gt;'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">data_fmt=</span><span class="s3">&quot;&lt;td&gt;%s&lt;/td&gt;&quot;</span><span class="s2">,  </span><span class="s5"># deprecated; use data_fmts</span>
    <span class="s5"># labeled alignments</span>
    <span class="s5"># stubs_align='l',   #deprecated; use data_fmts</span>
    <span class="s1">stub_align=</span><span class="s3">'l'</span><span class="s2">,</span>
    <span class="s1">header_align=</span><span class="s3">'c'</span><span class="s2">,</span>
    <span class="s5"># labeled formats</span>
    <span class="s1">header_fmt=</span><span class="s3">'&lt;th&gt;%s&lt;/th&gt;'</span><span class="s2">,  </span><span class="s5"># deprecated; just use `header`</span>
    <span class="s1">stub_fmt=</span><span class="s3">'&lt;th&gt;%s&lt;/th&gt;'</span><span class="s2">,  </span><span class="s5"># deprecated; just use `stub`</span>
    <span class="s1">empty_cell=</span><span class="s3">'&lt;td&gt;&lt;/td&gt;'</span><span class="s2">,  </span><span class="s5"># deprecated; just use `empty`</span>
    <span class="s1">header=</span><span class="s3">'&lt;th&gt;%s&lt;/th&gt;'</span><span class="s2">,</span>
    <span class="s1">stub=</span><span class="s3">'&lt;th&gt;%s&lt;/th&gt;'</span><span class="s2">,</span>
    <span class="s1">empty=</span><span class="s3">'&lt;td&gt;&lt;/td&gt;'</span><span class="s2">,</span>
    <span class="s1">missing=</span><span class="s3">'&lt;td&gt;--&lt;/td&gt;'</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">default_latex_fmt = dict(</span>
    <span class="s1">fmt=</span><span class="s3">'ltx'</span><span class="s2">,</span>
    <span class="s5"># basic table formatting</span>
    <span class="s1">table_dec_above=</span><span class="s3">r'\toprule'</span><span class="s2">,</span>
    <span class="s1">table_dec_below=</span><span class="s3">r'\bottomrule'</span><span class="s2">,</span>
    <span class="s1">header_dec_below=</span><span class="s3">r'\midrule'</span><span class="s2">,</span>
    <span class="s1">row_dec_below=</span><span class="s2">None,</span>
    <span class="s1">strip_backslash=</span><span class="s2">True,  </span><span class="s5"># NotImplemented</span>
    <span class="s5"># row formatting</span>
    <span class="s1">row_post=</span><span class="s3">r'  \\'</span><span class="s2">,</span>
    <span class="s1">data_aligns=</span><span class="s3">'c'</span><span class="s2">,</span>
    <span class="s1">colwidths=</span><span class="s2">None,</span>
    <span class="s1">colsep=</span><span class="s3">' &amp; '</span><span class="s2">,</span>
    <span class="s5"># data formats</span>
    <span class="s1">data_fmts=[</span><span class="s3">'%s'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">data_fmt=</span><span class="s3">'%s'</span><span class="s2">,  </span><span class="s5"># deprecated; use data_fmts</span>
    <span class="s5"># labeled alignments</span>
    <span class="s5"># stubs_align='l',   # deprecated; use data_fmts</span>
    <span class="s1">stub_align=</span><span class="s3">'l'</span><span class="s2">,</span>
    <span class="s1">header_align=</span><span class="s3">'c'</span><span class="s2">,</span>
    <span class="s1">empty_align=</span><span class="s3">'l'</span><span class="s2">,</span>
    <span class="s5"># labeled formats</span>
    <span class="s1">header_fmt=</span><span class="s3">r'\textbf{%s}'</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'header'</span>
    <span class="s1">stub_fmt=</span><span class="s3">r'\textbf{%s}'</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'stub'</span>
    <span class="s1">empty_cell=</span><span class="s3">''</span><span class="s2">,  </span><span class="s5"># deprecated; just use 'empty'</span>
    <span class="s1">header=</span><span class="s3">r'\textbf{%s}'</span><span class="s2">,</span>
    <span class="s1">stub=</span><span class="s3">r'\textbf{%s}'</span><span class="s2">,</span>
    <span class="s1">empty=</span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">missing=</span><span class="s3">'--'</span><span class="s2">,</span>
    <span class="s5"># replacements will be processed in lexicographical order</span>
    <span class="s1">replacements={</span><span class="s3">&quot;#&quot;</span><span class="s1">: </span><span class="s3">r&quot;\#&quot;</span><span class="s2">,</span>
                  <span class="s3">&quot;$&quot;</span><span class="s1">: </span><span class="s3">r&quot;\$&quot;</span><span class="s2">,</span>
                  <span class="s3">&quot;%&quot;</span><span class="s1">: </span><span class="s3">r&quot;\%&quot;</span><span class="s2">,</span>
                  <span class="s3">&quot;&amp;&quot;</span><span class="s1">: </span><span class="s3">r&quot;\&amp;&quot;</span><span class="s2">,</span>
                  <span class="s3">&quot;&gt;&quot;</span><span class="s1">: </span><span class="s3">r&quot;$&gt;$&quot;</span><span class="s2">,</span>
                  <span class="s3">&quot;_&quot;</span><span class="s1">: </span><span class="s3">r&quot;\_&quot;</span><span class="s2">,</span>
                  <span class="s3">&quot;|&quot;</span><span class="s1">: </span><span class="s3">r&quot;$|$&quot;</span><span class="s1">}</span>
<span class="s1">)</span>

<span class="s1">default_fmts = dict(</span>
    <span class="s1">html=default_html_fmt</span><span class="s2">,</span>
    <span class="s1">txt=default_txt_fmt</span><span class="s2">,</span>
    <span class="s1">latex=default_latex_fmt</span><span class="s2">,</span>
    <span class="s1">csv=default_csv_fmt</span>
<span class="s1">)</span>
<span class="s1">output_format_translations = dict(</span>
    <span class="s1">htm=</span><span class="s3">'html'</span><span class="s2">,</span>
    <span class="s1">text=</span><span class="s3">'txt'</span><span class="s2">,</span>
    <span class="s1">ltx=</span><span class="s3">'latex'</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_output_format(output_format):</span>
    <span class="s2">if </span><span class="s1">output_format </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">'html'</span><span class="s2">, </span><span class="s3">'txt'</span><span class="s2">, </span><span class="s3">'latex'</span><span class="s2">, </span><span class="s3">'csv'</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">output_format = output_format_translations[output_format]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'unknown output format %s' </span><span class="s1">% output_format)</span>
    <span class="s2">return </span><span class="s1">output_format</span>
</pre>
</body>
</html>