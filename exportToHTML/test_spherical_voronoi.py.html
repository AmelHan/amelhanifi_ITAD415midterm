<html>
<head>
<title>test_spherical_voronoi.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_spherical_voronoi.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_equal</span><span class="s0">,</span>
                           <span class="s1">assert_almost_equal</span><span class="s0">,</span>
                           <span class="s1">assert_array_equal</span><span class="s0">,</span>
                           <span class="s1">assert_array_almost_equal)</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>
<span class="s0">from </span><span class="s1">scipy.spatial </span><span class="s0">import </span><span class="s1">SphericalVoronoi</span><span class="s0">, </span><span class="s1">distance</span>
<span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">linear_sum_assignment</span>
<span class="s0">from </span><span class="s1">scipy.constants </span><span class="s0">import </span><span class="s1">golden </span><span class="s0">as </span><span class="s1">phi</span>
<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">gamma</span>


<span class="s1">TOL = </span><span class="s2">1E-10</span>


<span class="s0">def </span><span class="s1">_generate_tetrahedron():</span>
    <span class="s0">return </span><span class="s1">np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>


<span class="s0">def </span><span class="s1">_generate_cube():</span>
    <span class="s0">return </span><span class="s1">np.array(list(itertools.product([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repeat=</span><span class="s2">3</span><span class="s1">)))</span>


<span class="s0">def </span><span class="s1">_generate_octahedron():</span>
    <span class="s0">return </span><span class="s1">np.array([[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[+</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                     <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">+</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">+</span><span class="s2">1</span><span class="s1">]])</span>


<span class="s0">def </span><span class="s1">_generate_dodecahedron():</span>

    <span class="s1">x1 = _generate_cube()</span>
    <span class="s1">x2 = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-phi</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">/ phi]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-phi</span><span class="s0">, </span><span class="s1">+</span><span class="s2">1 </span><span class="s1">/ phi]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">+phi</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">/ phi]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">+phi</span><span class="s0">, </span><span class="s1">+</span><span class="s2">1 </span><span class="s1">/ phi]])</span>
    <span class="s1">x3 = np.array([[-</span><span class="s2">1 </span><span class="s1">/ phi</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-phi]</span><span class="s0">,</span>
                   <span class="s1">[+</span><span class="s2">1 </span><span class="s1">/ phi</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-phi]</span><span class="s0">,</span>
                   <span class="s1">[-</span><span class="s2">1 </span><span class="s1">/ phi</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">+phi]</span><span class="s0">,</span>
                   <span class="s1">[+</span><span class="s2">1 </span><span class="s1">/ phi</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">+phi]])</span>
    <span class="s1">x4 = np.array([[-phi</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">/ phi</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[-phi</span><span class="s0">, </span><span class="s1">+</span><span class="s2">1 </span><span class="s1">/ phi</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[+phi</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">/ phi</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[+phi</span><span class="s0">, </span><span class="s1">+</span><span class="s2">1 </span><span class="s1">/ phi</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
    <span class="s0">return </span><span class="s1">np.concatenate((x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">x3</span><span class="s0">, </span><span class="s1">x4))</span>


<span class="s0">def </span><span class="s1">_generate_icosahedron():</span>
    <span class="s1">x = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-phi]</span><span class="s0">,</span>
                  <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">+phi]</span><span class="s0">,</span>
                  <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-phi]</span><span class="s0">,</span>
                  <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">+phi]])</span>
    <span class="s0">return </span><span class="s1">np.concatenate([np.roll(x</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">)])</span>


<span class="s0">def </span><span class="s1">_generate_polytope(name):</span>
    <span class="s1">polygons = [</span><span class="s3">&quot;triangle&quot;</span><span class="s0">, </span><span class="s3">&quot;square&quot;</span><span class="s0">, </span><span class="s3">&quot;pentagon&quot;</span><span class="s0">, </span><span class="s3">&quot;hexagon&quot;</span><span class="s0">, </span><span class="s3">&quot;heptagon&quot;</span><span class="s0">,</span>
                <span class="s3">&quot;octagon&quot;</span><span class="s0">, </span><span class="s3">&quot;nonagon&quot;</span><span class="s0">, </span><span class="s3">&quot;decagon&quot;</span><span class="s0">, </span><span class="s3">&quot;undecagon&quot;</span><span class="s0">, </span><span class="s3">&quot;dodecagon&quot;</span><span class="s1">]</span>
    <span class="s1">polyhedra = [</span><span class="s3">&quot;tetrahedron&quot;</span><span class="s0">, </span><span class="s3">&quot;cube&quot;</span><span class="s0">, </span><span class="s3">&quot;octahedron&quot;</span><span class="s0">, </span><span class="s3">&quot;dodecahedron&quot;</span><span class="s0">,</span>
                 <span class="s3">&quot;icosahedron&quot;</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">polygons </span><span class="s0">and </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">polyhedra:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;unrecognized polytope&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">polygons:</span>
        <span class="s1">n = polygons.index(name) + </span><span class="s2">3</span>
        <span class="s1">thetas = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">p = np.vstack([np.cos(thetas)</span><span class="s0">, </span><span class="s1">np.sin(thetas)]).T</span>
    <span class="s0">elif </span><span class="s1">name == </span><span class="s3">&quot;tetrahedron&quot;</span><span class="s1">:</span>
        <span class="s1">p = _generate_tetrahedron()</span>
    <span class="s0">elif </span><span class="s1">name == </span><span class="s3">&quot;cube&quot;</span><span class="s1">:</span>
        <span class="s1">p = _generate_cube()</span>
    <span class="s0">elif </span><span class="s1">name == </span><span class="s3">&quot;octahedron&quot;</span><span class="s1">:</span>
        <span class="s1">p = _generate_octahedron()</span>
    <span class="s0">elif </span><span class="s1">name == </span><span class="s3">&quot;dodecahedron&quot;</span><span class="s1">:</span>
        <span class="s1">p = _generate_dodecahedron()</span>
    <span class="s0">elif </span><span class="s1">name == </span><span class="s3">&quot;icosahedron&quot;</span><span class="s1">:</span>
        <span class="s1">p = _generate_icosahedron()</span>

    <span class="s0">return </span><span class="s1">p / np.linalg.norm(p</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_hypersphere_area(dim</span><span class="s0">, </span><span class="s1">radius):</span>
    <span class="s4"># https://en.wikipedia.org/wiki/N-sphere#Closed_forms</span>
    <span class="s0">return </span><span class="s2">2 </span><span class="s1">* np.pi**(dim / </span><span class="s2">2</span><span class="s1">) / gamma(dim / </span><span class="s2">2</span><span class="s1">) * radius**(dim - </span><span class="s2">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_sample_sphere(n</span><span class="s0">, </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">seed=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4"># Sample points uniformly at random from the hypersphere</span>
    <span class="s1">rng = np.random.RandomState(seed=seed)</span>
    <span class="s1">points = rng.randn(n</span><span class="s0">, </span><span class="s1">dim)</span>
    <span class="s1">points /= np.linalg.norm(points</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">points</span>


<span class="s0">class </span><span class="s1">TestSphericalVoronoi:</span>

    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.points = np.array([</span>
            <span class="s1">[-</span><span class="s2">0.78928481</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.16341094</span><span class="s0">, </span><span class="s2">0.59188373</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s2">0.66839141</span><span class="s0">, </span><span class="s2">0.73309634</span><span class="s0">, </span><span class="s2">0.12578818</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0.32535778</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.92476944</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.19734181</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s2">0.90177102</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.03785291</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.43055335</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0.71781344</span><span class="s0">, </span><span class="s2">0.68428936</span><span class="s0">, </span><span class="s2">0.12842096</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s2">0.96064876</span><span class="s0">, </span><span class="s2">0.23492353</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.14820556</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0.73181537</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.22025898</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.6449281</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0.79979205</span><span class="s0">, </span><span class="s2">0.54555747</span><span class="s0">, </span><span class="s2">0.25039913</span><span class="s1">]]</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_constructor(self):</span>
        <span class="s1">center = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">radius = </span><span class="s2">2</span>
        <span class="s1">s1 = SphericalVoronoi(self.points)</span>
        <span class="s4"># user input checks in SphericalVoronoi now require</span>
        <span class="s4"># the radius / center to match the generators so adjust</span>
        <span class="s4"># accordingly here</span>
        <span class="s1">s2 = SphericalVoronoi(self.points * radius</span><span class="s0">, </span><span class="s1">radius)</span>
        <span class="s1">s3 = SphericalVoronoi(self.points + center</span><span class="s0">, </span><span class="s1">center=center)</span>
        <span class="s1">s4 = SphericalVoronoi(self.points * radius + center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">center)</span>
        <span class="s1">assert_array_equal(s1.center</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]))</span>
        <span class="s1">assert_equal(s1.radius</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(s2.center</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]))</span>
        <span class="s1">assert_equal(s2.radius</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(s3.center</span><span class="s0">, </span><span class="s1">center)</span>
        <span class="s1">assert_equal(s3.radius</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(s4.center</span><span class="s0">, </span><span class="s1">center)</span>
        <span class="s1">assert_equal(s4.radius</span><span class="s0">, </span><span class="s1">radius)</span>

        <span class="s4"># Test a non-sequence/-ndarray based array-like</span>
        <span class="s1">s5 = SphericalVoronoi(memoryview(self.points))  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">assert_array_equal(s5.center</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]))</span>
        <span class="s1">assert_equal(s5.radius</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vertices_regions_translation_invariance(self):</span>
        <span class="s1">sv_origin = SphericalVoronoi(self.points)</span>
        <span class="s1">center = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">sv_translated = SphericalVoronoi(self.points + center</span><span class="s0">, </span><span class="s1">center=center)</span>
        <span class="s1">assert_equal(sv_origin.regions</span><span class="s0">, </span><span class="s1">sv_translated.regions)</span>
        <span class="s1">assert_array_almost_equal(sv_origin.vertices + center</span><span class="s0">,</span>
                                  <span class="s1">sv_translated.vertices)</span>

    <span class="s0">def </span><span class="s1">test_vertices_regions_scaling_invariance(self):</span>
        <span class="s1">sv_unit = SphericalVoronoi(self.points)</span>
        <span class="s1">sv_scaled = SphericalVoronoi(self.points * </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(sv_unit.regions</span><span class="s0">, </span><span class="s1">sv_scaled.regions)</span>
        <span class="s1">assert_array_almost_equal(sv_unit.vertices * </span><span class="s2">2</span><span class="s0">,</span>
                                  <span class="s1">sv_scaled.vertices)</span>

    <span class="s0">def </span><span class="s1">test_old_radius_api_error(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'`radius` is `None`. *'</span><span class="s1">):</span>
            <span class="s1">SphericalVoronoi(self.points</span><span class="s0">, </span><span class="s1">radius=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sort_vertices_of_regions(self):</span>
        <span class="s1">sv = SphericalVoronoi(self.points)</span>
        <span class="s1">unsorted_regions = sv.regions</span>
        <span class="s1">sv.sort_vertices_of_regions()</span>
        <span class="s1">assert_equal(sorted(sv.regions)</span><span class="s0">, </span><span class="s1">sorted(unsorted_regions))</span>

    <span class="s0">def </span><span class="s1">test_sort_vertices_of_regions_flattened(self):</span>
        <span class="s1">expected = sorted([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">9</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">expected = list(itertools.chain(*sorted(expected)))  </span><span class="s4"># type: ignore</span>
        <span class="s1">sv = SphericalVoronoi(self.points)</span>
        <span class="s1">sv.sort_vertices_of_regions()</span>
        <span class="s1">actual = list(itertools.chain(*sorted(sv.regions)))</span>
        <span class="s1">assert_array_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_sort_vertices_of_regions_dimensionality(self):</span>
        <span class="s1">points = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;three-dimensional&quot;</span><span class="s1">):</span>
            <span class="s1">sv = SphericalVoronoi(points)</span>
            <span class="s1">sv.sort_vertices_of_regions()</span>

    <span class="s0">def </span><span class="s1">test_num_vertices(self):</span>
        <span class="s4"># for any n &gt;= 3, a spherical Voronoi diagram has 2n - 4</span>
        <span class="s4"># vertices; this is a direct consequence of Euler's formula</span>
        <span class="s4"># as explained by Dinis and Mamede (2010) Proceedings of the</span>
        <span class="s4"># 2010 International Symposium on Voronoi Diagrams in Science</span>
        <span class="s4"># and Engineering</span>
        <span class="s1">sv = SphericalVoronoi(self.points)</span>
        <span class="s1">expected = self.points.shape[</span><span class="s2">0</span><span class="s1">] * </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">4</span>
        <span class="s1">actual = sv.vertices.shape[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">assert_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_voronoi_circles(self):</span>
        <span class="s1">sv = SphericalVoronoi(self.points)</span>
        <span class="s0">for </span><span class="s1">vertex </span><span class="s0">in </span><span class="s1">sv.vertices:</span>
            <span class="s1">distances = distance.cdist(sv.points</span><span class="s0">, </span><span class="s1">np.array([vertex]))</span>
            <span class="s1">closest = np.array(sorted(distances)[</span><span class="s2">0</span><span class="s1">:</span><span class="s2">3</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(closest[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">closest[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s1">str(vertex))</span>
            <span class="s1">assert_almost_equal(closest[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">closest[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s1">str(vertex))</span>

    <span class="s0">def </span><span class="s1">test_duplicate_point_handling(self):</span>
        <span class="s4"># an exception should be raised for degenerate generators</span>
        <span class="s4"># related to Issue# 7046</span>
        <span class="s1">self.degenerate = np.concatenate((self.points</span><span class="s0">, </span><span class="s1">self.points))</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">SphericalVoronoi(self.degenerate)</span>

    <span class="s0">def </span><span class="s1">test_incorrect_radius_handling(self):</span>
        <span class="s4"># an exception should be raised if the radius provided</span>
        <span class="s4"># cannot possibly match the input generators</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">SphericalVoronoi(self.points</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">0.98</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_incorrect_center_handling(self):</span>
        <span class="s4"># an exception should be raised if the center provided</span>
        <span class="s4"># cannot possibly match the input generators</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">SphericalVoronoi(self.points</span><span class="s0">, </span><span class="s1">center=[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dim&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;shift&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_single_hemisphere_handling(self</span><span class="s0">, </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">shift):</span>
        <span class="s1">n = </span><span class="s2">10</span>
        <span class="s1">points = _sample_sphere(n</span><span class="s0">, </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">seed=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">points[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">] = np.abs(points[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">center = (np.arange(dim) + </span><span class="s2">1</span><span class="s1">) * shift</span>
        <span class="s1">sv = SphericalVoronoi(points + center</span><span class="s0">, </span><span class="s1">center=center)</span>
        <span class="s1">dots = np.einsum(</span><span class="s3">'ij,ij-&gt;i'</span><span class="s0">, </span><span class="s1">sv.vertices - center</span><span class="s0">,</span>
                                     <span class="s1">sv.points[sv._simplices[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]] - center)</span>
        <span class="s1">circumradii = np.arccos(np.clip(dots</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">np.max(circumradii) &gt; np.pi / </span><span class="s2">2</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;n&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">10</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dim&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;shift&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_rank_deficient(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">shift):</span>
        <span class="s1">center = (np.arange(dim) + </span><span class="s2">1</span><span class="s1">) * shift</span>
        <span class="s1">points = _sample_sphere(n</span><span class="s0">, </span><span class="s1">dim - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">seed=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">points = np.hstack([points</span><span class="s0">, </span><span class="s1">np.zeros((n</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Rank of input points&quot;</span><span class="s1">):</span>
            <span class="s1">SphericalVoronoi(points + center</span><span class="s0">, </span><span class="s1">center=center)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dim&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_higher_dimensions(self</span><span class="s0">, </span><span class="s1">dim):</span>
        <span class="s1">n = </span><span class="s2">100</span>
        <span class="s1">points = _sample_sphere(n</span><span class="s0">, </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">seed=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">sv = SphericalVoronoi(points)</span>
        <span class="s0">assert </span><span class="s1">sv.vertices.shape[</span><span class="s2">1</span><span class="s1">] == dim</span>
        <span class="s0">assert </span><span class="s1">len(sv.regions) == n</span>

        <span class="s4"># verify Euler characteristic</span>
        <span class="s1">cell_counts = []</span>
        <span class="s1">simplices = np.sort(sv._simplices)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dim + </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">cells = []</span>
            <span class="s0">for </span><span class="s1">indices </span><span class="s0">in </span><span class="s1">itertools.combinations(range(dim)</span><span class="s0">, </span><span class="s1">i):</span>
                <span class="s1">cells.append(simplices[:</span><span class="s0">, </span><span class="s1">list(indices)])</span>
            <span class="s1">cells = np.unique(np.concatenate(cells)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
            <span class="s1">cell_counts.append(len(cells))</span>
        <span class="s1">expected_euler = </span><span class="s2">1 </span><span class="s1">+ (-</span><span class="s2">1</span><span class="s1">)**(dim-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">actual_euler = sum([(-</span><span class="s2">1</span><span class="s1">)**i * e </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">e </span><span class="s0">in </span><span class="s1">enumerate(cell_counts)])</span>
        <span class="s0">assert </span><span class="s1">expected_euler == actual_euler</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dim&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_cross_polytope_regions(self</span><span class="s0">, </span><span class="s1">dim):</span>
        <span class="s4"># The hypercube is the dual of the cross-polytope, so the voronoi</span>
        <span class="s4"># vertices of the cross-polytope lie on the points of the hypercube.</span>

        <span class="s4"># generate points of the cross-polytope</span>
        <span class="s1">points = np.concatenate((-np.eye(dim)</span><span class="s0">, </span><span class="s1">np.eye(dim)))</span>
        <span class="s1">sv = SphericalVoronoi(points)</span>
        <span class="s0">assert </span><span class="s1">all([len(e) == </span><span class="s2">2</span><span class="s1">**(dim - </span><span class="s2">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">sv.regions])</span>

        <span class="s4"># generate points of the hypercube</span>
        <span class="s1">expected = np.vstack(list(itertools.product([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repeat=dim)))</span>
        <span class="s1">expected = expected.astype(np.float64) / np.sqrt(dim)</span>

        <span class="s4"># test that Voronoi vertices are correctly placed</span>
        <span class="s1">dist = distance.cdist(sv.vertices</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">res = linear_sum_assignment(dist)</span>
        <span class="s0">assert </span><span class="s1">dist[res].sum() &lt; TOL</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dim&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_hypercube_regions(self</span><span class="s0">, </span><span class="s1">dim):</span>
        <span class="s4"># The cross-polytope is the dual of the hypercube, so the voronoi</span>
        <span class="s4"># vertices of the hypercube lie on the points of the cross-polytope.</span>

        <span class="s4"># generate points of the hypercube</span>
        <span class="s1">points = np.vstack(list(itertools.product([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repeat=dim)))</span>
        <span class="s1">points = points.astype(np.float64) / np.sqrt(dim)</span>
        <span class="s1">sv = SphericalVoronoi(points)</span>

        <span class="s4"># generate points of the cross-polytope</span>
        <span class="s1">expected = np.concatenate((-np.eye(dim)</span><span class="s0">, </span><span class="s1">np.eye(dim)))</span>

        <span class="s4"># test that Voronoi vertices are correctly placed</span>
        <span class="s1">dist = distance.cdist(sv.vertices</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">res = linear_sum_assignment(dist)</span>
        <span class="s0">assert </span><span class="s1">dist[res].sum() &lt; TOL</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;n&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">500</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dim&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;radius&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;shift&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;single_hemisphere&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_area_reconstitution(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">shift</span><span class="s0">,</span>
                                 <span class="s1">single_hemisphere):</span>
        <span class="s1">points = _sample_sphere(n</span><span class="s0">, </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">seed=</span><span class="s2">0</span><span class="s1">)</span>

        <span class="s4"># move all points to one side of the sphere for single-hemisphere test</span>
        <span class="s0">if </span><span class="s1">single_hemisphere:</span>
            <span class="s1">points[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">] = np.abs(points[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

        <span class="s1">center = (np.arange(dim) + </span><span class="s2">1</span><span class="s1">) * shift</span>
        <span class="s1">points = radius * points + center</span>

        <span class="s1">sv = SphericalVoronoi(points</span><span class="s0">, </span><span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">center=center)</span>
        <span class="s1">areas = sv.calculate_areas()</span>
        <span class="s1">assert_almost_equal(areas.sum()</span><span class="s0">, </span><span class="s1">_hypersphere_area(dim</span><span class="s0">, </span><span class="s1">radius))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;poly&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;triangle&quot;</span><span class="s0">, </span><span class="s3">&quot;dodecagon&quot;</span><span class="s0">,</span>
                                      <span class="s3">&quot;tetrahedron&quot;</span><span class="s0">, </span><span class="s3">&quot;cube&quot;</span><span class="s0">, </span><span class="s3">&quot;octahedron&quot;</span><span class="s0">,</span>
                                      <span class="s3">&quot;dodecahedron&quot;</span><span class="s0">, </span><span class="s3">&quot;icosahedron&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_equal_area_reconstitution(self</span><span class="s0">, </span><span class="s1">poly):</span>
        <span class="s1">points = _generate_polytope(poly)</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">dim = points.shape</span>
        <span class="s1">sv = SphericalVoronoi(points)</span>
        <span class="s1">areas = sv.calculate_areas()</span>
        <span class="s1">assert_almost_equal(areas</span><span class="s0">, </span><span class="s1">_hypersphere_area(dim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">) / n)</span>

    <span class="s0">def </span><span class="s1">test_area_unsupported_dimension(self):</span>
        <span class="s1">dim = </span><span class="s2">4</span>
        <span class="s1">points = np.concatenate((-np.eye(dim)</span><span class="s0">, </span><span class="s1">np.eye(dim)))</span>
        <span class="s1">sv = SphericalVoronoi(points)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Only supported&quot;</span><span class="s1">):</span>
            <span class="s1">sv.calculate_areas()</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;radius&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;center&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">2.</span><span class="s0">, </span><span class="s2">3.</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_attribute_types(self</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">center):</span>
        <span class="s1">points = radius * self.points</span>
        <span class="s0">if </span><span class="s1">center </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">points += center</span>

        <span class="s1">sv = SphericalVoronoi(points</span><span class="s0">, </span><span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">center=center)</span>
        <span class="s0">assert </span><span class="s1">sv.points.dtype </span><span class="s0">is </span><span class="s1">np.dtype(np.float64)</span>
        <span class="s0">assert </span><span class="s1">sv.center.dtype </span><span class="s0">is </span><span class="s1">np.dtype(np.float64)</span>
        <span class="s0">assert </span><span class="s1">isinstance(sv.radius</span><span class="s0">, </span><span class="s1">float)</span>

    <span class="s0">def </span><span class="s1">test_region_types(self):</span>
        <span class="s4"># Tests that region integer type does not change</span>
        <span class="s4"># See Issue #13412</span>
        <span class="s1">sv = SphericalVoronoi(self.points)</span>
        <span class="s1">dtype = type(sv.regions[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">sv.sort_vertices_of_regions()</span>
        <span class="s0">assert </span><span class="s1">type(sv.regions[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">]) == dtype</span>
        <span class="s1">sv.sort_vertices_of_regions()</span>
        <span class="s0">assert </span><span class="s1">type(sv.regions[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">]) == dtype</span>
</pre>
</body>
</html>