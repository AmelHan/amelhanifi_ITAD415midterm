<html>
<head>
<title>_mannwhitneyu.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mannwhitneyu.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">special</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">._axis_nan_policy </span><span class="s0">import </span><span class="s1">_axis_nan_policy_factory</span>


<span class="s0">def </span><span class="s1">_broadcast_concatenate(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s2">'''Broadcast then concatenate arrays, leaving concatenation axis last'''</span>
    <span class="s1">x = np.moveaxis(x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">y = np.moveaxis(y</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">z = np.broadcast(x[...</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y[...</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">x = np.broadcast_to(x</span><span class="s0">, </span><span class="s1">z.shape + (x.shape[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">y = np.broadcast_to(y</span><span class="s0">, </span><span class="s1">z.shape + (y.shape[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">z = np.concatenate((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z</span>


<span class="s0">class </span><span class="s1">_MWU:</span>
    <span class="s2">'''Distribution of MWU statistic under the null hypothesis'''</span>
    <span class="s4"># Possible improvement: if m and n are small enough, use integer arithmetic</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s2">'''Minimal initializer'''</span>
        <span class="s1">self._fmnks = -np.ones((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">self._recursive = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">pmf(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s0">if </span><span class="s1">(self._recursive </span><span class="s0">is None and </span><span class="s1">m &lt;= </span><span class="s3">500 </span><span class="s0">and </span><span class="s1">n &lt;= </span><span class="s3">500</span>
                <span class="s0">or </span><span class="s1">self._recursive):</span>
            <span class="s0">return </span><span class="s1">self.pmf_recursive(k</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.pmf_iterative(k</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n)</span>

    <span class="s0">def </span><span class="s1">pmf_recursive(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s2">'''Probability mass function, recursive version'''</span>
        <span class="s1">self._resize_fmnks(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">np.max(k))</span>
        <span class="s4"># could loop over just the unique elements, but probably not worth</span>
        <span class="s4"># the time to find them</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">np.ravel(k):</span>
            <span class="s1">self._f(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">i)</span>
        <span class="s0">return </span><span class="s1">self._fmnks[m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k] / special.binom(m + n</span><span class="s0">, </span><span class="s1">m)</span>

    <span class="s0">def </span><span class="s1">pmf_iterative(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s2">'''Probability mass function, iterative version'''</span>
        <span class="s1">fmnks = {}</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">np.ravel(k):</span>
            <span class="s1">fmnks = _mwu_f_iterative(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">fmnks)</span>
        <span class="s0">return </span><span class="s1">(np.array([fmnks[(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">ki)] </span><span class="s0">for </span><span class="s1">ki </span><span class="s0">in </span><span class="s1">k])</span>
                <span class="s1">/ special.binom(m + n</span><span class="s0">, </span><span class="s1">m))</span>

    <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s2">'''Cumulative distribution function'''</span>
        <span class="s4"># We could use the fact that the distribution is symmetric to avoid</span>
        <span class="s4"># summing more than m*n/2 terms, but it might not be worth the</span>
        <span class="s4"># overhead. Let's leave that to an improvement.</span>
        <span class="s1">pmfs = self.pmf(np.arange(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.max(k) + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">cdfs = np.cumsum(pmfs)</span>
        <span class="s0">return </span><span class="s1">cdfs[k]</span>

    <span class="s0">def </span><span class="s1">sf(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s2">'''Survival function'''</span>
        <span class="s4"># Use the fact that the distribution is symmetric; i.e.</span>
        <span class="s4"># _f(m, n, m*n-k) = _f(m, n, k), and sum from the left</span>
        <span class="s1">k = m*n - k</span>
        <span class="s4"># Note that both CDF and SF include the PMF at k. The p-value is</span>
        <span class="s4"># calculated from the SF and should include the mass at k, so this</span>
        <span class="s4"># is desirable</span>
        <span class="s0">return </span><span class="s1">self.cdf(k</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n)</span>

    <span class="s0">def </span><span class="s1">_resize_fmnks(self</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s2">'''If necessary, expand the array that remembers PMF values'''</span>
        <span class="s4"># could probably use `np.pad` but I'm not sure it would save code</span>
        <span class="s1">shape_old = np.array(self._fmnks.shape)</span>
        <span class="s1">shape_new = np.array((m+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k+</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">np.any(shape_new &gt; shape_old):</span>
            <span class="s1">shape = np.maximum(shape_old</span><span class="s0">, </span><span class="s1">shape_new)</span>
            <span class="s1">fmnks = -np.ones(shape)             </span><span class="s4"># create the new array</span>
            <span class="s1">m0</span><span class="s0">, </span><span class="s1">n0</span><span class="s0">, </span><span class="s1">k0 = shape_old</span>
            <span class="s1">fmnks[:m0</span><span class="s0">, </span><span class="s1">:n0</span><span class="s0">, </span><span class="s1">:k0] = self._fmnks  </span><span class="s4"># copy remembered values</span>
            <span class="s1">self._fmnks = fmnks</span>

    <span class="s0">def </span><span class="s1">_f(self</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s2">'''Recursive implementation of function of [3] Theorem 2.5'''</span>

        <span class="s4"># [3] Theorem 2.5 Line 1</span>
        <span class="s0">if </span><span class="s1">k &lt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">m &lt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">n &lt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">k &gt; m*n:</span>
            <span class="s0">return </span><span class="s3">0</span>

        <span class="s4"># if already calculated, return the value</span>
        <span class="s0">if </span><span class="s1">self._fmnks[m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k] &gt;= </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._fmnks[m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k]</span>

        <span class="s0">if </span><span class="s1">k == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">m &gt;= </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">n &gt;= </span><span class="s3">0</span><span class="s1">:  </span><span class="s4"># [3] Theorem 2.5 Line 2</span>
            <span class="s1">fmnk = </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:   </span><span class="s4"># [3] Theorem 2.5 Line 3 / Equation 3</span>
            <span class="s1">fmnk = self._f(m-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k-n) + self._f(m</span><span class="s0">, </span><span class="s1">n-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">self._fmnks[m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k] = fmnk  </span><span class="s4"># remember result</span>

        <span class="s0">return </span><span class="s1">fmnk</span>


<span class="s4"># Maintain state for faster repeat calls to mannwhitneyu w/ method='exact'</span>
<span class="s1">_mwu_state = _MWU()</span>


<span class="s0">def </span><span class="s1">_mwu_f_iterative(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">fmnks):</span>
    <span class="s2">'''Iterative implementation of function of [3] Theorem 2.5'''</span>

    <span class="s0">def </span><span class="s1">_base_case(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s2">'''Base cases from recursive version'''</span>

        <span class="s4"># if already calculated, return the value</span>
        <span class="s0">if </span><span class="s1">fmnks.get((m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">) &gt;= </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">fmnks[(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k)]</span>

        <span class="s4"># [3] Theorem 2.5 Line 1</span>
        <span class="s0">elif </span><span class="s1">k &lt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">m &lt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">n &lt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">k &gt; m*n:</span>
            <span class="s0">return </span><span class="s3">0</span>

        <span class="s4"># [3] Theorem 2.5 Line 2</span>
        <span class="s0">elif </span><span class="s1">k == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">m &gt;= </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">n &gt;= </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">1</span>

        <span class="s0">return None</span>

    <span class="s1">stack = [(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k)]</span>
    <span class="s1">fmnk = </span><span class="s0">None</span>

    <span class="s0">while </span><span class="s1">stack:</span>
        <span class="s4"># Popping only if necessary would save a tiny bit of time, but NWI.</span>
        <span class="s1">m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k = stack.pop()</span>

        <span class="s4"># If we're at a base case, continue (stack unwinds)</span>
        <span class="s1">fmnk = _base_case(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s0">if </span><span class="s1">fmnk </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">fmnks[(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k)] = fmnk</span>
            <span class="s0">continue</span>

        <span class="s4"># If both terms are base cases, continue (stack unwinds)</span>
        <span class="s1">f1 = _base_case(m-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k-n)</span>
        <span class="s1">f2 = _base_case(m</span><span class="s0">, </span><span class="s1">n-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s0">if </span><span class="s1">f1 </span><span class="s0">is not None and </span><span class="s1">f2 </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s4"># [3] Theorem 2.5 Line 3 / Equation 3</span>
            <span class="s1">fmnk = f1 + f2</span>
            <span class="s1">fmnks[(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k)] = fmnk</span>
            <span class="s0">continue</span>

        <span class="s4"># recurse deeper</span>
        <span class="s1">stack.append((m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k))</span>
        <span class="s0">if </span><span class="s1">f1 </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">stack.append((m-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">k-n))</span>
        <span class="s0">if </span><span class="s1">f2 </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">stack.append((m</span><span class="s0">, </span><span class="s1">n-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">k))</span>

    <span class="s0">return </span><span class="s1">fmnks</span>


<span class="s0">def </span><span class="s1">_tie_term(ranks):</span>
    <span class="s2">&quot;&quot;&quot;Tie correction term&quot;&quot;&quot;</span>
    <span class="s4"># element i of t is the number of elements sharing rank i</span>
    <span class="s1">_</span><span class="s0">, </span><span class="s1">t = np.unique(ranks</span><span class="s0">, </span><span class="s1">return_counts=</span><span class="s0">True, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">(t**</span><span class="s3">3 </span><span class="s1">- t).sum(axis=-</span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_get_mwu_z(U</span><span class="s0">, </span><span class="s1">n1</span><span class="s0">, </span><span class="s1">n2</span><span class="s0">, </span><span class="s1">ranks</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">continuity=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s2">'''Standardized MWU statistic'''</span>
    <span class="s4"># Follows mannwhitneyu [2]</span>
    <span class="s1">mu = n1 * n2 / </span><span class="s3">2</span>
    <span class="s1">n = n1 + n2</span>

    <span class="s4"># Tie correction according to [2]</span>
    <span class="s1">tie_term = np.apply_along_axis(_tie_term</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">ranks)</span>
    <span class="s1">s = np.sqrt(n1*n2/</span><span class="s3">12 </span><span class="s1">* ((n + </span><span class="s3">1</span><span class="s1">) - tie_term/(n*(n-</span><span class="s3">1</span><span class="s1">))))</span>

    <span class="s4"># equivalent to using scipy.stats.tiecorrect</span>
    <span class="s4"># T = np.apply_along_axis(stats.tiecorrect, -1, ranks)</span>
    <span class="s4"># s = np.sqrt(T * n1 * n2 * (n1+n2+1) / 12.0)</span>

    <span class="s1">numerator = U - mu</span>

    <span class="s4"># Continuity correction.</span>
    <span class="s4"># Because SF is always used to calculate the p-value, we can always</span>
    <span class="s4"># _subtract_ 0.5 for the continuity correction. This always increases the</span>
    <span class="s4"># p-value to account for the rest of the probability mass _at_ q = U.</span>
    <span class="s0">if </span><span class="s1">continuity:</span>
        <span class="s1">numerator -= </span><span class="s3">0.5</span>

    <span class="s4"># no problem evaluating the norm SF at an infinity</span>
    <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s5">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s5">'ignore'</span><span class="s1">):</span>
        <span class="s1">z = numerator / s</span>
    <span class="s0">return </span><span class="s1">z</span>


<span class="s0">def </span><span class="s1">_mwu_input_validation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">use_continuity</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">method):</span>
    <span class="s2">''' Input validation and standardization for mannwhitneyu '''</span>
    <span class="s4"># Would use np.asarray_chkfinite, but infs are OK</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.atleast_1d(x)</span><span class="s0">, </span><span class="s1">np.atleast_1d(y)</span>
    <span class="s0">if </span><span class="s1">np.isnan(x).any() </span><span class="s0">or </span><span class="s1">np.isnan(y).any():</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">'`x` and `y` must not contain NaNs.'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">np.size(x) == </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">np.size(y) == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">'`x` and `y` must be of nonzero size.'</span><span class="s1">)</span>

    <span class="s1">bools = {</span><span class="s0">True, False</span><span class="s1">}</span>
    <span class="s0">if </span><span class="s1">use_continuity </span><span class="s0">not in </span><span class="s1">bools:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f'`use_continuity` must be one of </span><span class="s0">{</span><span class="s1">bools</span><span class="s0">}</span><span class="s5">.'</span><span class="s1">)</span>

    <span class="s1">alternatives = {</span><span class="s5">&quot;two-sided&quot;</span><span class="s0">, </span><span class="s5">&quot;less&quot;</span><span class="s0">, </span><span class="s5">&quot;greater&quot;</span><span class="s1">}</span>
    <span class="s1">alternative = alternative.lower()</span>
    <span class="s0">if </span><span class="s1">alternative </span><span class="s0">not in </span><span class="s1">alternatives:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f'`alternative` must be one of </span><span class="s0">{</span><span class="s1">alternatives</span><span class="s0">}</span><span class="s5">.'</span><span class="s1">)</span>

    <span class="s1">axis_int = int(axis)</span>
    <span class="s0">if </span><span class="s1">axis != axis_int:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">'`axis` must be an integer.'</span><span class="s1">)</span>

    <span class="s1">methods = {</span><span class="s5">&quot;asymptotic&quot;</span><span class="s0">, </span><span class="s5">&quot;exact&quot;</span><span class="s0">, </span><span class="s5">&quot;auto&quot;</span><span class="s1">}</span>
    <span class="s1">method = method.lower()</span>
    <span class="s0">if </span><span class="s1">method </span><span class="s0">not in </span><span class="s1">methods:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f'`method` must be one of </span><span class="s0">{</span><span class="s1">methods</span><span class="s0">}</span><span class="s5">.'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">use_continuity</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis_int</span><span class="s0">, </span><span class="s1">method</span>


<span class="s0">def </span><span class="s1">_tie_check(xy):</span>
    <span class="s2">&quot;&quot;&quot;Find any ties in data&quot;&quot;&quot;</span>
    <span class="s1">_</span><span class="s0">, </span><span class="s1">t = np.unique(xy</span><span class="s0">, </span><span class="s1">return_counts=</span><span class="s0">True, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">np.any(t != </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_mwu_choose_method(n1</span><span class="s0">, </span><span class="s1">n2</span><span class="s0">, </span><span class="s1">xy</span><span class="s0">, </span><span class="s1">method):</span>
    <span class="s2">&quot;&quot;&quot;Choose method 'asymptotic' or 'exact' depending on input size, ties&quot;&quot;&quot;</span>

    <span class="s4"># if both inputs are large, asymptotic is OK</span>
    <span class="s0">if </span><span class="s1">n1 &gt; </span><span class="s3">8 </span><span class="s0">and </span><span class="s1">n2 &gt; </span><span class="s3">8</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s5">&quot;asymptotic&quot;</span>

    <span class="s4"># if there are any ties, asymptotic is preferred</span>
    <span class="s0">if </span><span class="s1">np.apply_along_axis(_tie_check</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">xy).any():</span>
        <span class="s0">return </span><span class="s5">&quot;asymptotic&quot;</span>

    <span class="s0">return </span><span class="s5">&quot;exact&quot;</span>


<span class="s1">MannwhitneyuResult = namedtuple(</span><span class="s5">'MannwhitneyuResult'</span><span class="s0">, </span><span class="s1">(</span><span class="s5">'statistic'</span><span class="s0">, </span><span class="s5">'pvalue'</span><span class="s1">))</span>


<span class="s1">@_axis_nan_policy_factory(MannwhitneyuResult</span><span class="s0">, </span><span class="s1">n_samples=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">mannwhitneyu(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">use_continuity=</span><span class="s0">True, </span><span class="s1">alternative=</span><span class="s5">&quot;two-sided&quot;</span><span class="s0">,</span>
                 <span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">&quot;auto&quot;</span><span class="s1">):</span>
    <span class="s2">r'''Perform the Mann-Whitney U rank test on two independent samples. 
 
    The Mann-Whitney U test is a nonparametric test of the null hypothesis 
    that the distribution underlying sample `x` is the same as the 
    distribution underlying sample `y`. It is often used as a test of 
    difference in location between distributions. 
 
    Parameters 
    ---------- 
    x, y : array-like 
        N-d arrays of samples. The arrays must be broadcastable except along 
        the dimension given by `axis`. 
    use_continuity : bool, optional 
            Whether a continuity correction (1/2) should be applied. 
            Default is True when `method` is ``'asymptotic'``; has no effect 
            otherwise. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        Let *F(u)* and *G(u)* be the cumulative distribution functions of the 
        distributions underlying `x` and `y`, respectively. Then the following 
        alternative hypotheses are available: 
 
        * 'two-sided': the distributions are not equal, i.e. *F(u) ≠ G(u)* for 
          at least one *u*. 
        * 'less': the distribution underlying `x` is stochastically less 
          than the distribution underlying `y`, i.e. *F(u) &gt; G(u)* for all *u*. 
        * 'greater': the distribution underlying `x` is stochastically greater 
          than the distribution underlying `y`, i.e. *F(u) &lt; G(u)* for all *u*. 
 
        Under a more restrictive set of assumptions, the alternative hypotheses 
        can be expressed in terms of the locations of the distributions; 
        see [5] section 5.1. 
    axis : int, optional 
        Axis along which to perform the test. Default is 0. 
    method : {'auto', 'asymptotic', 'exact'}, optional 
        Selects the method used to calculate the *p*-value. 
        Default is 'auto'. The following options are available. 
 
        * ``'asymptotic'``: compares the standardized test statistic 
          against the normal distribution, correcting for ties. 
        * ``'exact'``: computes the exact *p*-value by comparing the observed 
          :math:`U` statistic against the exact distribution of the :math:`U` 
          statistic under the null hypothesis. No correction is made for ties. 
        * ``'auto'``: chooses ``'exact'`` when the size of one of the samples 
          is less than or equal to 8 and there are no ties; 
          chooses ``'asymptotic'`` otherwise. 
 
    Returns 
    ------- 
    res : MannwhitneyuResult 
        An object containing attributes: 
 
        statistic : float 
            The Mann-Whitney U statistic corresponding with sample `x`. See 
            Notes for the test statistic corresponding with sample `y`. 
        pvalue : float 
            The associated *p*-value for the chosen `alternative`. 
 
    Notes 
    ----- 
    If ``U1`` is the statistic corresponding with sample `x`, then the 
    statistic corresponding with sample `y` is 
    `U2 = `x.shape[axis] * y.shape[axis] - U1``. 
 
    `mannwhitneyu` is for independent samples. For related / paired samples, 
    consider `scipy.stats.wilcoxon`. 
 
    `method` ``'exact'`` is recommended when there are no ties and when either 
    sample size is less than 8 [1]_. The implementation follows the recurrence 
    relation originally proposed in [1]_ as it is described in [3]_. 
    Note that the exact method is *not* corrected for ties, but 
    `mannwhitneyu` will not raise errors or warnings if there are ties in the 
    data. 
 
    The Mann-Whitney U test is a non-parametric version of the t-test for 
    independent samples. When the means of samples from the populations 
    are normally distributed, consider `scipy.stats.ttest_ind`. 
 
    See Also 
    -------- 
    scipy.stats.wilcoxon, scipy.stats.ranksums, scipy.stats.ttest_ind 
 
    References 
    ---------- 
    .. [1] H.B. Mann and D.R. Whitney, &quot;On a test of whether one of two random 
           variables is stochastically larger than the other&quot;, The Annals of 
           Mathematical Statistics, Vol. 18, pp. 50-60, 1947. 
    .. [2] Mann-Whitney U Test, Wikipedia, 
           http://en.wikipedia.org/wiki/Mann-Whitney_U_test 
    .. [3] A. Di Bucchianico, &quot;Combinatorics, computer algebra, and the 
           Wilcoxon-Mann-Whitney test&quot;, Journal of Statistical Planning and 
           Inference, Vol. 79, pp. 349-364, 1999. 
    .. [4] Rosie Shier, &quot;Statistics: 2.3 The Mann-Whitney U Test&quot;, Mathematics 
           Learning Support Centre, 2004. 
    .. [5] Michael P. Fay and Michael A. Proschan. &quot;Wilcoxon-Mann-Whitney 
           or t-test? On assumptions for hypothesis tests and multiple \ 
           interpretations of decision rules.&quot; Statistics surveys, Vol. 4, pp. 
           1-39, 2010. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2857732/ 
 
    Examples 
    -------- 
    We follow the example from [4]_: nine randomly sampled young adults were 
    diagnosed with type II diabetes at the ages below. 
 
    &gt;&gt;&gt; males = [19, 22, 16, 29, 24] 
    &gt;&gt;&gt; females = [20, 11, 17, 12] 
 
    We use the Mann-Whitney U test to assess whether there is a statistically 
    significant difference in the diagnosis age of males and females. 
    The null hypothesis is that the distribution of male diagnosis ages is 
    the same as the distribution of female diagnosis ages. We decide 
    that a confidence level of 95% is required to reject the null hypothesis 
    in favor of the alternative that the distributions are different. 
    Since the number of samples is very small and there are no ties in the 
    data, we can compare the observed test statistic against the *exact* 
    distribution of the test statistic under the null hypothesis. 
 
    &gt;&gt;&gt; from scipy.stats import mannwhitneyu 
    &gt;&gt;&gt; U1, p = mannwhitneyu(males, females, method=&quot;exact&quot;) 
    &gt;&gt;&gt; print(U1) 
    17.0 
 
    `mannwhitneyu` always reports the statistic associated with the first 
    sample, which, in this case, is males. This agrees with :math:`U_M = 17` 
    reported in [4]_. The statistic associated with the second statistic 
    can be calculated: 
 
    &gt;&gt;&gt; nx, ny = len(males), len(females) 
    &gt;&gt;&gt; U2 = nx*ny - U1 
    &gt;&gt;&gt; print(U2) 
    3.0 
 
    This agrees with :math:`U_F = 3` reported in [4]_. The two-sided 
    *p*-value can be calculated from either statistic, and the value produced 
    by `mannwhitneyu` agrees with :math:`p = 0.11` reported in [4]_. 
 
    &gt;&gt;&gt; print(p) 
    0.1111111111111111 
 
    The exact distribution of the test statistic is asymptotically normal, so 
    the example continues by comparing the exact *p*-value against the 
    *p*-value produced using the normal approximation. 
 
    &gt;&gt;&gt; _, pnorm = mannwhitneyu(males, females, method=&quot;asymptotic&quot;) 
    &gt;&gt;&gt; print(pnorm) 
    0.11134688653314041 
 
    Here `mannwhitneyu`'s reported *p*-value appears to conflict with the 
    value :math:`p = 0.09` given in [4]_. The reason is that [4]_ 
    does not apply the continuity correction performed by `mannwhitneyu`; 
    `mannwhitneyu` reduces the distance between the test statistic and the 
    mean :math:`\mu = n_x n_y / 2` by 0.5 to correct for the fact that the 
    discrete statistic is being compared against a continuous distribution. 
    Here, the :math:`U` statistic used is less than the mean, so we reduce 
    the distance by adding 0.5 in the numerator. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import norm 
    &gt;&gt;&gt; U = min(U1, U2) 
    &gt;&gt;&gt; N = nx + ny 
    &gt;&gt;&gt; z = (U - nx*ny/2 + 0.5) / np.sqrt(nx*ny * (N + 1)/ 12) 
    &gt;&gt;&gt; p = 2 * norm.cdf(z)  # use CDF to get p-value from smaller statistic 
    &gt;&gt;&gt; print(p) 
    0.11134688653314041 
 
    If desired, we can disable the continuity correction to get a result 
    that agrees with that reported in [4]_. 
 
    &gt;&gt;&gt; _, pnorm = mannwhitneyu(males, females, use_continuity=False, 
    ...                         method=&quot;asymptotic&quot;) 
    &gt;&gt;&gt; print(pnorm) 
    0.0864107329737 
 
    Regardless of whether we perform an exact or asymptotic test, the 
    probability of the test statistic being as extreme or more extreme by 
    chance exceeds 5%, so we do not consider the results statistically 
    significant. 
 
    Suppose that, before seeing the data, we had hypothesized that females 
    would tend to be diagnosed at a younger age than males. 
    In that case, it would be natural to provide the female ages as the 
    first input, and we would have performed a one-sided test using 
    ``alternative = 'less'``: females are diagnosed at an age that is 
    stochastically less than that of males. 
 
    &gt;&gt;&gt; res = mannwhitneyu(females, males, alternative=&quot;less&quot;, method=&quot;exact&quot;) 
    &gt;&gt;&gt; print(res) 
    MannwhitneyuResult(statistic=3.0, pvalue=0.05555555555555555) 
 
    Again, the probability of getting a sufficiently low value of the 
    test statistic by chance under the null hypothesis is greater than 5%, 
    so we do not reject the null hypothesis in favor of our alternative. 
 
    If it is reasonable to assume that the means of samples from the 
    populations are normally distributed, we could have used a t-test to 
    perform the analysis. 
 
    &gt;&gt;&gt; from scipy.stats import ttest_ind 
    &gt;&gt;&gt; res = ttest_ind(females, males, alternative=&quot;less&quot;) 
    &gt;&gt;&gt; print(res) 
    Ttest_indResult(statistic=-2.239334696520584, pvalue=0.030068441095757924) 
 
    Under this assumption, the *p*-value would be low enough to reject the 
    null hypothesis in favor of the alternative. 
 
    '''</span>

    <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">use_continuity</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis_int</span><span class="s0">, </span><span class="s1">method = (</span>
        <span class="s1">_mwu_input_validation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">use_continuity</span><span class="s0">, </span><span class="s1">alternative</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">method))</span>

    <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">xy = _broadcast_concatenate(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s1">n1</span><span class="s0">, </span><span class="s1">n2 = x.shape[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y.shape[-</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">method == </span><span class="s5">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s1">method = _mwu_choose_method(n1</span><span class="s0">, </span><span class="s1">n2</span><span class="s0">, </span><span class="s1">xy</span><span class="s0">, </span><span class="s1">method)</span>

    <span class="s4"># Follows [2]</span>
    <span class="s1">ranks = stats.rankdata(xy</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)  </span><span class="s4"># method 2, step 1</span>
    <span class="s1">R1 = ranks[...</span><span class="s0">, </span><span class="s1">:n1].sum(axis=-</span><span class="s3">1</span><span class="s1">)    </span><span class="s4"># method 2, step 2</span>
    <span class="s1">U1 = R1 - n1*(n1+</span><span class="s3">1</span><span class="s1">)/</span><span class="s3">2                </span><span class="s4"># method 2, step 3</span>
    <span class="s1">U2 = n1 * n2 - U1                    </span><span class="s4"># as U1 + U2 = n1 * n2</span>

    <span class="s0">if </span><span class="s1">alternative == </span><span class="s5">&quot;greater&quot;</span><span class="s1">:</span>
        <span class="s1">U</span><span class="s0">, </span><span class="s1">f = U1</span><span class="s0">, </span><span class="s3">1  </span><span class="s4"># U is the statistic to use for p-value, f is a factor</span>
    <span class="s0">elif </span><span class="s1">alternative == </span><span class="s5">&quot;less&quot;</span><span class="s1">:</span>
        <span class="s1">U</span><span class="s0">, </span><span class="s1">f = U2</span><span class="s0">, </span><span class="s3">1  </span><span class="s4"># Due to symmetry, use SF of U2 rather than CDF of U1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">U</span><span class="s0">, </span><span class="s1">f = np.maximum(U1</span><span class="s0">, </span><span class="s1">U2)</span><span class="s0">, </span><span class="s3">2  </span><span class="s4"># multiply SF by two for two-sided test</span>

    <span class="s0">if </span><span class="s1">method == </span><span class="s5">&quot;exact&quot;</span><span class="s1">:</span>
        <span class="s1">p = _mwu_state.sf(U.astype(int)</span><span class="s0">, </span><span class="s1">n1</span><span class="s0">, </span><span class="s1">n2)</span>
    <span class="s0">elif </span><span class="s1">method == </span><span class="s5">&quot;asymptotic&quot;</span><span class="s1">:</span>
        <span class="s1">z = _get_mwu_z(U</span><span class="s0">, </span><span class="s1">n1</span><span class="s0">, </span><span class="s1">n2</span><span class="s0">, </span><span class="s1">ranks</span><span class="s0">, </span><span class="s1">continuity=use_continuity)</span>
        <span class="s1">p = stats.norm.sf(z)</span>
    <span class="s1">p *= f</span>

    <span class="s4"># Ensure that test statistic is not greater than 1</span>
    <span class="s4"># This could happen for exact test when U = m*n/2</span>
    <span class="s1">p = np.clip(p</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">MannwhitneyuResult(U1</span><span class="s0">, </span><span class="s1">p)</span>
</pre>
</body>
</html>