<html>
<head>
<title>_coo.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_coo.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; A sparse matrix in COOrdinate or 'triplet' format&quot;&quot;&quot;</span>

<span class="s1">__docformat__ = </span><span class="s2">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ = [</span><span class="s2">'coo_array'</span><span class="s3">, </span><span class="s2">'coo_matrix'</span><span class="s3">, </span><span class="s2">'isspmatrix_coo'</span><span class="s1">]</span>

<span class="s3">from </span><span class="s1">warnings </span><span class="s3">import </span><span class="s1">warn</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">._matrix </span><span class="s3">import </span><span class="s1">spmatrix</span><span class="s3">, </span><span class="s1">_array_doc_to_matrix</span>
<span class="s3">from </span><span class="s1">._sparsetools </span><span class="s3">import </span><span class="s1">coo_tocsr</span><span class="s3">, </span><span class="s1">coo_todense</span><span class="s3">, </span><span class="s1">coo_matvec</span>
<span class="s3">from </span><span class="s1">._base </span><span class="s3">import </span><span class="s1">issparse</span><span class="s3">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s3">, </span><span class="s1">_spbase</span><span class="s3">, </span><span class="s1">sparray</span>
<span class="s3">from </span><span class="s1">._data </span><span class="s3">import </span><span class="s1">_data_matrix</span><span class="s3">, </span><span class="s1">_minmax_mixin</span>
<span class="s3">from </span><span class="s1">._sputils </span><span class="s3">import </span><span class="s1">(upcast</span><span class="s3">, </span><span class="s1">upcast_char</span><span class="s3">, </span><span class="s1">to_native</span><span class="s3">, </span><span class="s1">isshape</span><span class="s3">, </span><span class="s1">getdtype</span><span class="s3">,</span>
                       <span class="s1">getdata</span><span class="s3">, </span><span class="s1">downcast_intp_index</span><span class="s3">,</span>
                       <span class="s1">check_shape</span><span class="s3">, </span><span class="s1">check_reshape_kwargs)</span>

<span class="s3">import </span><span class="s1">operator</span>


<span class="s3">class </span><span class="s1">_coo_base(_data_matrix</span><span class="s3">, </span><span class="s1">_minmax_mixin):</span>
    <span class="s0">&quot;&quot;&quot; 
    A sparse matrix in COOrdinate format. 
 
    Also known as the 'ijv' or 'triplet' format. 
 
    This can be instantiated in several ways: 
        coo_array(D) 
            with a dense matrix D 
 
        coo_array(S) 
            with another sparse matrix S (equivalent to S.tocoo()) 
 
        coo_array((M, N), [dtype]) 
            to construct an empty matrix with shape (M, N) 
            dtype is optional, defaulting to dtype='d'. 
 
        coo_array((data, (i, j)), [shape=(M, N)]) 
            to construct from three arrays: 
                1. data[:]   the entries of the matrix, in any order 
                2. i[:]      the row indices of the matrix entries 
                3. j[:]      the column indices of the matrix entries 
 
            Where ``A[i[k], j[k]] = data[k]``.  When shape is not 
            specified, it is inferred from the index arrays 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the matrix 
    shape : 2-tuple 
        Shape of the matrix 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
        Number of stored values, including explicit zeros 
    data 
        COO format data array of the matrix 
    row 
        COO format row index array of the matrix 
    col 
        COO format column index array of the matrix 
 
    Notes 
    ----- 
 
    Sparse matrices can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Advantages of the COO format 
        - facilitates fast conversion among sparse formats 
        - permits duplicate entries (see example) 
        - very fast conversion to and from CSR/CSC formats 
 
    Disadvantages of the COO format 
        - does not directly support: 
            + arithmetic operations 
            + slicing 
 
    Intended Usage 
        - COO is a fast format for constructing sparse matrices 
        - Once a matrix has been constructed, convert to CSR or 
          CSC format for fast arithmetic and matrix vector operations 
        - By default when converting to CSR or CSC format, duplicate (i,j) 
          entries will be summed together.  This facilitates efficient 
          construction of finite element matrices and the like. (see example) 
 
    Canonical format 
        - Entries and indices sorted by row, then column. 
        - There are no duplicate entries (i.e. duplicate (i,j) locations) 
        - Arrays MAY have explicit zeros. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; # Constructing an empty matrix 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import coo_array 
    &gt;&gt;&gt; coo_array((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; # Constructing a matrix using ijv format 
    &gt;&gt;&gt; row  = np.array([0, 3, 1, 0]) 
    &gt;&gt;&gt; col  = np.array([0, 3, 1, 2]) 
    &gt;&gt;&gt; data = np.array([4, 5, 7, 9]) 
    &gt;&gt;&gt; coo_array((data, (row, col)), shape=(4, 4)).toarray() 
    array([[4, 0, 9, 0], 
           [0, 7, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 5]]) 
 
    &gt;&gt;&gt; # Constructing a matrix with duplicate indices 
    &gt;&gt;&gt; row  = np.array([0, 0, 1, 3, 1, 0, 0]) 
    &gt;&gt;&gt; col  = np.array([0, 2, 1, 3, 1, 0, 0]) 
    &gt;&gt;&gt; data = np.array([1, 1, 1, 1, 1, 1, 1]) 
    &gt;&gt;&gt; coo = coo_array((data, (row, col)), shape=(4, 4)) 
    &gt;&gt;&gt; # Duplicate indices are maintained until implicitly or explicitly summed 
    &gt;&gt;&gt; np.max(coo.data) 
    1 
    &gt;&gt;&gt; coo.toarray() 
    array([[3, 0, 1, 0], 
           [0, 2, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 1]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_format = </span><span class="s2">'coo'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">arg1</span><span class="s3">, </span><span class="s1">shape=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">_data_matrix.__init__(self)</span>

        <span class="s3">if </span><span class="s1">isinstance(arg1</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s3">if </span><span class="s1">isshape(arg1):</span>
                <span class="s1">M</span><span class="s3">, </span><span class="s1">N = arg1</span>
                <span class="s1">self._shape = check_shape((M</span><span class="s3">, </span><span class="s1">N))</span>
                <span class="s1">idx_dtype = self._get_index_dtype(maxval=max(M</span><span class="s3">, </span><span class="s1">N))</span>
                <span class="s1">data_dtype = getdtype(dtype</span><span class="s3">, </span><span class="s1">default=float)</span>
                <span class="s1">self.row = np.array([]</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
                <span class="s1">self.col = np.array([]</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
                <span class="s1">self.data = np.array([]</span><span class="s3">, </span><span class="s1">dtype=data_dtype)</span>
                <span class="s1">self.has_canonical_format = </span><span class="s3">True</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">obj</span><span class="s3">, </span><span class="s1">(row</span><span class="s3">, </span><span class="s1">col) = arg1</span>
                <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">ValueError) </span><span class="s3">as </span><span class="s1">e:</span>
                    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'invalid input format'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>

                <span class="s3">if </span><span class="s1">shape </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">len(row) == </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">len(col) == </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'cannot infer dimensions from zero '</span>
                                         <span class="s2">'sized index arrays'</span><span class="s1">)</span>
                    <span class="s1">M = operator.index(np.max(row)) + </span><span class="s4">1</span>
                    <span class="s1">N = operator.index(np.max(col)) + </span><span class="s4">1</span>
                    <span class="s1">self._shape = check_shape((M</span><span class="s3">, </span><span class="s1">N))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s5"># Use 2 steps to ensure shape has length 2.</span>
                    <span class="s1">M</span><span class="s3">, </span><span class="s1">N = shape</span>
                    <span class="s1">self._shape = check_shape((M</span><span class="s3">, </span><span class="s1">N))</span>

                <span class="s1">idx_dtype = self._get_index_dtype((row</span><span class="s3">, </span><span class="s1">col)</span><span class="s3">, </span><span class="s1">maxval=max(self.shape)</span><span class="s3">, </span><span class="s1">check_contents=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s1">self.row = np.array(row</span><span class="s3">, </span><span class="s1">copy=copy</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
                <span class="s1">self.col = np.array(col</span><span class="s3">, </span><span class="s1">copy=copy</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
                <span class="s1">self.data = getdata(obj</span><span class="s3">, </span><span class="s1">copy=copy</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
                <span class="s1">self.has_canonical_format = </span><span class="s3">False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">issparse(arg1):</span>
                <span class="s3">if </span><span class="s1">arg1.format == self.format </span><span class="s3">and </span><span class="s1">copy:</span>
                    <span class="s1">self.row = arg1.row.copy()</span>
                    <span class="s1">self.col = arg1.col.copy()</span>
                    <span class="s1">self.data = arg1.data.copy()</span>
                    <span class="s1">self._shape = check_shape(arg1.shape)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">coo = arg1.tocoo()</span>
                    <span class="s1">self.row = coo.row</span>
                    <span class="s1">self.col = coo.col</span>
                    <span class="s1">self.data = coo.data</span>
                    <span class="s1">self._shape = check_shape(coo.shape)</span>
                <span class="s1">self.has_canonical_format = </span><span class="s3">False</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s5">#dense argument</span>
                <span class="s1">M = np.atleast_2d(np.asarray(arg1))</span>

                <span class="s3">if </span><span class="s1">M.ndim != </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'expected dimension &lt;= 2 array or matrix'</span><span class="s1">)</span>

                <span class="s1">self._shape = check_shape(M.shape)</span>
                <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">check_shape(shape) != self._shape:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'inconsistent shapes: %s != %s' </span><span class="s1">%</span>
                                         <span class="s1">(shape</span><span class="s3">, </span><span class="s1">self._shape))</span>
                <span class="s1">index_dtype = self._get_index_dtype(maxval=max(self._shape))</span>
                <span class="s1">row</span><span class="s3">, </span><span class="s1">col = M.nonzero()</span>
                <span class="s1">self.row = row.astype(index_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s1">self.col = col.astype(index_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s1">self.data = M[self.row</span><span class="s3">, </span><span class="s1">self.col]</span>
                <span class="s1">self.has_canonical_format = </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.data = self.data.astype(dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">self._check()</span>

    <span class="s3">def </span><span class="s1">reshape(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">shape = check_shape(args</span><span class="s3">, </span><span class="s1">self.shape)</span>
        <span class="s1">order</span><span class="s3">, </span><span class="s1">copy = check_reshape_kwargs(kwargs)</span>

        <span class="s5"># Return early if reshape is not required</span>
        <span class="s3">if </span><span class="s1">shape == self.shape:</span>
            <span class="s3">if </span><span class="s1">copy:</span>
                <span class="s3">return </span><span class="s1">self.copy()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self</span>

        <span class="s1">nrows</span><span class="s3">, </span><span class="s1">ncols = self.shape</span>

        <span class="s3">if </span><span class="s1">order == </span><span class="s2">'C'</span><span class="s1">:</span>
            <span class="s5"># Upcast to avoid overflows: the coo_array constructor</span>
            <span class="s5"># below will downcast the results to a smaller dtype, if</span>
            <span class="s5"># possible.</span>
            <span class="s1">dtype = self._get_index_dtype(maxval=(ncols * max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">nrows - </span><span class="s4">1</span><span class="s1">) + max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">ncols - </span><span class="s4">1</span><span class="s1">)))</span>

            <span class="s1">flat_indices = np.multiply(ncols</span><span class="s3">, </span><span class="s1">self.row</span><span class="s3">, </span><span class="s1">dtype=dtype) + self.col</span>
            <span class="s1">new_row</span><span class="s3">, </span><span class="s1">new_col = divmod(flat_indices</span><span class="s3">, </span><span class="s1">shape[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">elif </span><span class="s1">order == </span><span class="s2">'F'</span><span class="s1">:</span>
            <span class="s1">dtype = self._get_index_dtype(maxval=(nrows * max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">ncols - </span><span class="s4">1</span><span class="s1">) + max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">nrows - </span><span class="s4">1</span><span class="s1">)))</span>

            <span class="s1">flat_indices = np.multiply(nrows</span><span class="s3">, </span><span class="s1">self.col</span><span class="s3">, </span><span class="s1">dtype=dtype) + self.row</span>
            <span class="s1">new_col</span><span class="s3">, </span><span class="s1">new_row = divmod(flat_indices</span><span class="s3">, </span><span class="s1">shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;'order' must be 'C' or 'F'&quot;</span><span class="s1">)</span>

        <span class="s5"># Handle copy here rather than passing on to the constructor so that no</span>
        <span class="s5"># copy will be made of new_row and new_col regardless</span>
        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s1">new_data = self.data.copy()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">new_data = self.data</span>

        <span class="s3">return </span><span class="s1">self.__class__((new_data</span><span class="s3">, </span><span class="s1">(new_row</span><span class="s3">, </span><span class="s1">new_col))</span><span class="s3">,</span>
                              <span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s1">reshape.__doc__ = _spbase.reshape.__doc__</span>

    <span class="s3">def </span><span class="s1">_getnnz(self</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">nnz = len(self.data)</span>
            <span class="s3">if </span><span class="s1">nnz != len(self.row) </span><span class="s3">or </span><span class="s1">nnz != len(self.col):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'row, column, and data array must all be the '</span>
                                 <span class="s2">'same length'</span><span class="s1">)</span>

            <span class="s3">if </span><span class="s1">self.data.ndim != </span><span class="s4">1 </span><span class="s3">or </span><span class="s1">self.row.ndim != </span><span class="s4">1 </span><span class="s3">or </span><span class="s1">\</span>
                    <span class="s1">self.col.ndim != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'row, column, and data arrays must be 1-D'</span><span class="s1">)</span>

            <span class="s3">return </span><span class="s1">int(nnz)</span>

        <span class="s3">if </span><span class="s1">axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">axis += </span><span class="s4">2</span>
        <span class="s3">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.bincount(downcast_intp_index(self.col)</span><span class="s3">,</span>
                               <span class="s1">minlength=self.shape[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">elif </span><span class="s1">axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.bincount(downcast_intp_index(self.row)</span><span class="s3">,</span>
                               <span class="s1">minlength=self.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'axis out of bounds'</span><span class="s1">)</span>

    <span class="s1">_getnnz.__doc__ = _spbase._getnnz.__doc__</span>

    <span class="s3">def </span><span class="s1">_check(self):</span>
        <span class="s0">&quot;&quot;&quot; Checks data structure for consistency &quot;&quot;&quot;</span>

        <span class="s5"># index arrays should have integer data types</span>
        <span class="s3">if </span><span class="s1">self.row.dtype.kind != </span><span class="s2">'i'</span><span class="s1">:</span>
            <span class="s1">warn(</span><span class="s2">&quot;row index array has non-integer dtype (%s)  &quot;</span>
                    <span class="s1">% self.row.dtype.name)</span>
        <span class="s3">if </span><span class="s1">self.col.dtype.kind != </span><span class="s2">'i'</span><span class="s1">:</span>
            <span class="s1">warn(</span><span class="s2">&quot;col index array has non-integer dtype (%s) &quot;</span>
                    <span class="s1">% self.col.dtype.name)</span>

        <span class="s1">idx_dtype = self._get_index_dtype((self.row</span><span class="s3">, </span><span class="s1">self.col)</span><span class="s3">, </span><span class="s1">maxval=max(self.shape))</span>
        <span class="s1">self.row = np.asarray(self.row</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">self.col = np.asarray(self.col</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">self.data = to_native(self.data)</span>

        <span class="s3">if </span><span class="s1">self.nnz &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.row.max() &gt;= self.shape[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'row index exceeds matrix dimensions'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">self.col.max() &gt;= self.shape[</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'column index exceeds matrix dimensions'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">self.row.min() &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'negative row index found'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">self.col.min() &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'negative column index found'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">transpose(self</span><span class="s3">, </span><span class="s1">axes=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">axes </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Sparse matrices do not support &quot;</span>
                              <span class="s2">&quot;an 'axes' parameter because swapping &quot;</span>
                              <span class="s2">&quot;dimensions is the only logical permutation.&quot;</span><span class="s1">)</span>

        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>
        <span class="s3">return </span><span class="s1">self.__class__((self.data</span><span class="s3">, </span><span class="s1">(self.col</span><span class="s3">, </span><span class="s1">self.row))</span><span class="s3">,</span>
                              <span class="s1">shape=(N</span><span class="s3">, </span><span class="s1">M)</span><span class="s3">, </span><span class="s1">copy=copy)</span>

    <span class="s1">transpose.__doc__ = _spbase.transpose.__doc__</span>

    <span class="s3">def </span><span class="s1">resize(self</span><span class="s3">, </span><span class="s1">*shape):</span>
        <span class="s1">shape = check_shape(shape)</span>
        <span class="s1">new_M</span><span class="s3">, </span><span class="s1">new_N = shape</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>

        <span class="s3">if </span><span class="s1">new_M &lt; M </span><span class="s3">or </span><span class="s1">new_N &lt; N:</span>
            <span class="s1">mask = np.logical_and(self.row &lt; new_M</span><span class="s3">, </span><span class="s1">self.col &lt; new_N)</span>
            <span class="s3">if not </span><span class="s1">mask.all():</span>
                <span class="s1">self.row = self.row[mask]</span>
                <span class="s1">self.col = self.col[mask]</span>
                <span class="s1">self.data = self.data[mask]</span>

        <span class="s1">self._shape = shape</span>

    <span class="s1">resize.__doc__ = _spbase.resize.__doc__</span>

    <span class="s3">def </span><span class="s1">toarray(self</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;See the docstring for `_spbase.toarray`.&quot;&quot;&quot;</span>
        <span class="s1">B = self._process_toarray_args(order</span><span class="s3">, </span><span class="s1">out)</span>
        <span class="s1">fortran = int(B.flags.f_contiguous)</span>
        <span class="s3">if not </span><span class="s1">fortran </span><span class="s3">and not </span><span class="s1">B.flags.c_contiguous:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Output array must be C or F contiguous&quot;</span><span class="s1">)</span>
        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
        <span class="s1">coo_todense(M</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">self.nnz</span><span class="s3">, </span><span class="s1">self.row</span><span class="s3">, </span><span class="s1">self.col</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">,</span>
                    <span class="s1">B.ravel(</span><span class="s2">'A'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">fortran)</span>
        <span class="s3">return </span><span class="s1">B</span>

    <span class="s3">def </span><span class="s1">tocsc(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Convert this matrix to Compressed Sparse Column format 
 
        Duplicate entries will be summed together. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from numpy import array 
        &gt;&gt;&gt; from scipy.sparse import coo_array 
        &gt;&gt;&gt; row  = array([0, 0, 1, 3, 1, 0, 0]) 
        &gt;&gt;&gt; col  = array([0, 2, 1, 3, 1, 0, 0]) 
        &gt;&gt;&gt; data = array([1, 1, 1, 1, 1, 1, 1]) 
        &gt;&gt;&gt; A = coo_array((data, (row, col)), shape=(4, 4)).tocsc() 
        &gt;&gt;&gt; A.toarray() 
        array([[3, 0, 1, 0], 
               [0, 2, 0, 0], 
               [0, 0, 0, 0], 
               [0, 0, 0, 1]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.nnz == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._csc_container(self.shape</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
            <span class="s1">idx_dtype = self._get_index_dtype(</span>
                <span class="s1">(self.col</span><span class="s3">, </span><span class="s1">self.row)</span><span class="s3">, </span><span class="s1">maxval=max(self.nnz</span><span class="s3">, </span><span class="s1">M)</span>
            <span class="s1">)</span>
            <span class="s1">row = self.row.astype(idx_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">col = self.col.astype(idx_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

            <span class="s1">indptr = np.empty(N + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">indices = np.empty_like(row</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">data = np.empty_like(self.data</span><span class="s3">, </span><span class="s1">dtype=upcast(self.dtype))</span>

            <span class="s1">coo_tocsr(N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">self.nnz</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">,</span>
                      <span class="s1">indptr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">data)</span>

            <span class="s1">x = self._csc_container((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">, </span><span class="s1">shape=self.shape)</span>
            <span class="s3">if not </span><span class="s1">self.has_canonical_format:</span>
                <span class="s1">x.sum_duplicates()</span>
            <span class="s3">return </span><span class="s1">x</span>

    <span class="s3">def </span><span class="s1">tocsr(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Convert this matrix to Compressed Sparse Row format 
 
        Duplicate entries will be summed together. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from numpy import array 
        &gt;&gt;&gt; from scipy.sparse import coo_array 
        &gt;&gt;&gt; row  = array([0, 0, 1, 3, 1, 0, 0]) 
        &gt;&gt;&gt; col  = array([0, 2, 1, 3, 1, 0, 0]) 
        &gt;&gt;&gt; data = array([1, 1, 1, 1, 1, 1, 1]) 
        &gt;&gt;&gt; A = coo_array((data, (row, col)), shape=(4, 4)).tocsr() 
        &gt;&gt;&gt; A.toarray() 
        array([[3, 0, 1, 0], 
               [0, 2, 0, 0], 
               [0, 0, 0, 0], 
               [0, 0, 0, 1]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.nnz == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._csr_container(self.shape</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
            <span class="s1">idx_dtype = self._get_index_dtype(</span>
                <span class="s1">(self.row</span><span class="s3">, </span><span class="s1">self.col)</span><span class="s3">, </span><span class="s1">maxval=max(self.nnz</span><span class="s3">, </span><span class="s1">N)</span>
            <span class="s1">)</span>
            <span class="s1">row = self.row.astype(idx_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">col = self.col.astype(idx_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

            <span class="s1">indptr = np.empty(M + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">indices = np.empty_like(col</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">data = np.empty_like(self.data</span><span class="s3">, </span><span class="s1">dtype=upcast(self.dtype))</span>

            <span class="s1">coo_tocsr(M</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">self.nnz</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">,</span>
                      <span class="s1">indptr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">data)</span>

            <span class="s1">x = self._csr_container((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">, </span><span class="s1">shape=self.shape)</span>
            <span class="s3">if not </span><span class="s1">self.has_canonical_format:</span>
                <span class="s1">x.sum_duplicates()</span>
            <span class="s3">return </span><span class="s1">x</span>

    <span class="s3">def </span><span class="s1">tocoo(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s3">return </span><span class="s1">self.copy()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">tocoo.__doc__ = _spbase.tocoo.__doc__</span>

    <span class="s3">def </span><span class="s1">todia(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self.sum_duplicates()</span>
        <span class="s1">ks = self.col - self.row  </span><span class="s5"># the diagonal for each nonzero</span>
        <span class="s1">diags</span><span class="s3">, </span><span class="s1">diag_idx = np.unique(ks</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">len(diags) &gt; </span><span class="s4">100</span><span class="s1">:</span>
            <span class="s5"># probably undesired, should todia() have a maxdiags parameter?</span>
            <span class="s1">warn(</span><span class="s2">&quot;Constructing a DIA matrix with %d diagonals &quot;</span>
                 <span class="s2">&quot;is inefficient&quot; </span><span class="s1">% len(diags)</span><span class="s3">, </span><span class="s1">SparseEfficiencyWarning)</span>

        <span class="s5">#initialize and fill in data array</span>
        <span class="s3">if </span><span class="s1">self.data.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">data = np.zeros((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">data = np.zeros((len(diags)</span><span class="s3">, </span><span class="s1">self.col.max()+</span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
            <span class="s1">data[diag_idx</span><span class="s3">, </span><span class="s1">self.col] = self.data</span>

        <span class="s3">return </span><span class="s1">self._dia_container((data</span><span class="s3">, </span><span class="s1">diags)</span><span class="s3">, </span><span class="s1">shape=self.shape)</span>

    <span class="s1">todia.__doc__ = _spbase.todia.__doc__</span>

    <span class="s3">def </span><span class="s1">todok(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self.sum_duplicates()</span>
        <span class="s1">dok = self._dok_container((self.shape)</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">dok._update(zip(zip(self.row</span><span class="s3">,</span><span class="s1">self.col)</span><span class="s3">,</span><span class="s1">self.data))</span>

        <span class="s3">return </span><span class="s1">dok</span>

    <span class="s1">todok.__doc__ = _spbase.todok.__doc__</span>

    <span class="s3">def </span><span class="s1">diagonal(self</span><span class="s3">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">rows</span><span class="s3">, </span><span class="s1">cols = self.shape</span>
        <span class="s3">if </span><span class="s1">k &lt;= -rows </span><span class="s3">or </span><span class="s1">k &gt;= cols:</span>
            <span class="s3">return </span><span class="s1">np.empty(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">dtype=self.data.dtype)</span>
        <span class="s1">diag = np.zeros(min(rows + min(k</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">cols - max(k</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span><span class="s3">,</span>
                        <span class="s1">dtype=self.dtype)</span>
        <span class="s1">diag_mask = (self.row + k) == self.col</span>

        <span class="s3">if </span><span class="s1">self.has_canonical_format:</span>
            <span class="s1">row = self.row[diag_mask]</span>
            <span class="s1">data = self.data[diag_mask]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">row</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">data = self._sum_duplicates(self.row[diag_mask]</span><span class="s3">,</span>
                                                <span class="s1">self.col[diag_mask]</span><span class="s3">,</span>
                                                <span class="s1">self.data[diag_mask])</span>
        <span class="s1">diag[row + min(k</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)] = data</span>

        <span class="s3">return </span><span class="s1">diag</span>

    <span class="s1">diagonal.__doc__ = _data_matrix.diagonal.__doc__</span>

    <span class="s3">def </span><span class="s1">_setdiag(self</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">k):</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>
        <span class="s3">if </span><span class="s1">values.ndim </span><span class="s3">and not </span><span class="s1">len(values):</span>
            <span class="s3">return</span>
        <span class="s1">idx_dtype = self.row.dtype</span>

        <span class="s5"># Determine which triples to keep and where to put the new ones.</span>
        <span class="s1">full_keep = self.col - self.row != k</span>
        <span class="s3">if </span><span class="s1">k &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">max_index = min(M+k</span><span class="s3">, </span><span class="s1">N)</span>
            <span class="s3">if </span><span class="s1">values.ndim:</span>
                <span class="s1">max_index = min(max_index</span><span class="s3">, </span><span class="s1">len(values))</span>
            <span class="s1">keep = np.logical_or(full_keep</span><span class="s3">, </span><span class="s1">self.col &gt;= max_index)</span>
            <span class="s1">new_row = np.arange(-k</span><span class="s3">, </span><span class="s1">-k + max_index</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">new_col = np.arange(max_index</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">max_index = min(M</span><span class="s3">, </span><span class="s1">N-k)</span>
            <span class="s3">if </span><span class="s1">values.ndim:</span>
                <span class="s1">max_index = min(max_index</span><span class="s3">, </span><span class="s1">len(values))</span>
            <span class="s1">keep = np.logical_or(full_keep</span><span class="s3">, </span><span class="s1">self.row &gt;= max_index)</span>
            <span class="s1">new_row = np.arange(max_index</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">new_col = np.arange(k</span><span class="s3">, </span><span class="s1">k + max_index</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>

        <span class="s5"># Define the array of data consisting of the entries to be added.</span>
        <span class="s3">if </span><span class="s1">values.ndim:</span>
            <span class="s1">new_data = values[:max_index]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">new_data = np.empty(max_index</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
            <span class="s1">new_data[:] = values</span>

        <span class="s5"># Update the internal structure.</span>
        <span class="s1">self.row = np.concatenate((self.row[keep]</span><span class="s3">, </span><span class="s1">new_row))</span>
        <span class="s1">self.col = np.concatenate((self.col[keep]</span><span class="s3">, </span><span class="s1">new_col))</span>
        <span class="s1">self.data = np.concatenate((self.data[keep]</span><span class="s3">, </span><span class="s1">new_data))</span>
        <span class="s1">self.has_canonical_format = </span><span class="s3">False</span>

    <span class="s5"># needed by _data_matrix</span>
    <span class="s3">def </span><span class="s1">_with_data(self</span><span class="s3">,</span><span class="s1">data</span><span class="s3">,</span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a matrix with the same sparsity structure as self, 
        but with different data.  By default the index arrays 
        (i.e. .row and .col) are copied. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s3">return </span><span class="s1">self.__class__((data</span><span class="s3">, </span><span class="s1">(self.row.copy()</span><span class="s3">, </span><span class="s1">self.col.copy()))</span><span class="s3">,</span>
                                   <span class="s1">shape=self.shape</span><span class="s3">, </span><span class="s1">dtype=data.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.__class__((data</span><span class="s3">, </span><span class="s1">(self.row</span><span class="s3">, </span><span class="s1">self.col))</span><span class="s3">,</span>
                                   <span class="s1">shape=self.shape</span><span class="s3">, </span><span class="s1">dtype=data.dtype)</span>

    <span class="s3">def </span><span class="s1">sum_duplicates(self):</span>
        <span class="s0">&quot;&quot;&quot;Eliminate duplicate matrix entries by adding them together 
 
        This is an *in place* operation 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.has_canonical_format:</span>
            <span class="s3">return</span>
        <span class="s1">summed = self._sum_duplicates(self.row</span><span class="s3">, </span><span class="s1">self.col</span><span class="s3">, </span><span class="s1">self.data)</span>
        <span class="s1">self.row</span><span class="s3">, </span><span class="s1">self.col</span><span class="s3">, </span><span class="s1">self.data = summed</span>
        <span class="s1">self.has_canonical_format = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">_sum_duplicates(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s5"># Assumes (data, row, col) not in canonical format.</span>
        <span class="s3">if </span><span class="s1">len(data) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">data</span>
        <span class="s5"># Sort indices w.r.t. rows, then cols. This corresponds to C-order,</span>
        <span class="s5"># which we rely on for argmin/argmax to return the first index in the</span>
        <span class="s5"># same way that numpy does (in the case of ties).</span>
        <span class="s1">order = np.lexsort((col</span><span class="s3">, </span><span class="s1">row))</span>
        <span class="s1">row = row[order]</span>
        <span class="s1">col = col[order]</span>
        <span class="s1">data = data[order]</span>
        <span class="s1">unique_mask = ((row[</span><span class="s4">1</span><span class="s1">:] != row[:-</span><span class="s4">1</span><span class="s1">]) |</span>
                       <span class="s1">(col[</span><span class="s4">1</span><span class="s1">:] != col[:-</span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s1">unique_mask = np.append(</span><span class="s3">True, </span><span class="s1">unique_mask)</span>
        <span class="s1">row = row[unique_mask]</span>
        <span class="s1">col = col[unique_mask]</span>
        <span class="s1">unique_inds</span><span class="s3">, </span><span class="s1">= np.nonzero(unique_mask)</span>
        <span class="s1">data = np.add.reduceat(data</span><span class="s3">, </span><span class="s1">unique_inds</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s3">return </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">data</span>

    <span class="s3">def </span><span class="s1">eliminate_zeros(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove zero entries from the matrix 
 
        This is an *in place* operation 
        &quot;&quot;&quot;</span>
        <span class="s1">mask = self.data != </span><span class="s4">0</span>
        <span class="s1">self.data = self.data[mask]</span>
        <span class="s1">self.row = self.row[mask]</span>
        <span class="s1">self.col = self.col[mask]</span>

    <span class="s5">#######################</span>
    <span class="s5"># Arithmetic handlers #</span>
    <span class="s5">#######################</span>

    <span class="s3">def </span><span class="s1">_add_dense(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">other.shape != self.shape:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'Incompatible shapes ({} and {})'</span>
                             <span class="s1">.format(self.shape</span><span class="s3">, </span><span class="s1">other.shape))</span>
        <span class="s1">dtype = upcast_char(self.dtype.char</span><span class="s3">, </span><span class="s1">other.dtype.char)</span>
        <span class="s1">result = np.array(other</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">fortran = int(result.flags.f_contiguous)</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>
        <span class="s1">coo_todense(M</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">self.nnz</span><span class="s3">, </span><span class="s1">self.row</span><span class="s3">, </span><span class="s1">self.col</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">,</span>
                    <span class="s1">result.ravel(</span><span class="s2">'A'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">fortran)</span>
        <span class="s3">return </span><span class="s1">self._container(result</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_mul_vector(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">#output array</span>
        <span class="s1">result = np.zeros(self.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=upcast_char(self.dtype.char</span><span class="s3">,</span>
                                                            <span class="s1">other.dtype.char))</span>
        <span class="s1">coo_matvec(self.nnz</span><span class="s3">, </span><span class="s1">self.row</span><span class="s3">, </span><span class="s1">self.col</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">result)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_mul_multivector(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">result = np.zeros((other.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.shape[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">,</span>
                          <span class="s1">dtype=upcast_char(self.dtype.char</span><span class="s3">, </span><span class="s1">other.dtype.char))</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">col </span><span class="s3">in </span><span class="s1">enumerate(other.T):</span>
            <span class="s1">coo_matvec(self.nnz</span><span class="s3">, </span><span class="s1">self.row</span><span class="s3">, </span><span class="s1">self.col</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">result[i])</span>
        <span class="s3">return </span><span class="s1">result.T.view(type=type(other))</span>


<span class="s3">def </span><span class="s1">isspmatrix_coo(x):</span>
    <span class="s0">&quot;&quot;&quot;Is `x` of coo_matrix type? 
 
    Parameters 
    ---------- 
    x 
        object to check for being a coo matrix 
 
    Returns 
    ------- 
    bool 
        True if `x` is a coo matrix, False otherwise 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_array, coo_matrix, csr_matrix, isspmatrix_coo 
    &gt;&gt;&gt; isspmatrix_coo(coo_matrix([[5]])) 
    True 
    &gt;&gt;&gt; isspmatrix_coo(coo_array([[5]])) 
    False 
    &gt;&gt;&gt; isspmatrix_coo(csr_matrix([[5]])) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">coo_matrix)</span>


<span class="s5"># This namespace class separates array from matrix with isinstance</span>
<span class="s3">class </span><span class="s1">coo_array(_coo_base</span><span class="s3">, </span><span class="s1">sparray):</span>
    <span class="s3">pass</span>

<span class="s1">coo_array.__doc__ = _coo_base.__doc__</span>

<span class="s3">class </span><span class="s1">coo_matrix(spmatrix</span><span class="s3">, </span><span class="s1">_coo_base):</span>
    <span class="s3">pass</span>

<span class="s1">coo_matrix.__doc__ = _array_doc_to_matrix(_coo_base.__doc__)</span>
</pre>
</body>
</html>