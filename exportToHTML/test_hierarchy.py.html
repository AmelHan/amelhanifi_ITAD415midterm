<html>
<head>
<title>test_hierarchy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_hierarchy.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Author: Damian Eads</span>
<span class="s0"># Date: April 17, 2008</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2008 Damian Eads</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions</span>
<span class="s0"># are met:</span>
<span class="s0">#</span>
<span class="s0"># 1. Redistributions of source code must retain the above copyright</span>
<span class="s0">#    notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#</span>
<span class="s0"># 2. Redistributions in binary form must reproduce the above</span>
<span class="s0">#    copyright notice, this list of conditions and the following</span>
<span class="s0">#    disclaimer in the documentation and/or other materials provided</span>
<span class="s0">#    with the distribution.</span>
<span class="s0">#</span>
<span class="s0"># 3. The name of the author may not be used to endorse or promote</span>
<span class="s0">#    products derived from this software without specific prior</span>
<span class="s0">#    written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS</span>
<span class="s0"># OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0"># ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</span>
<span class="s0"># DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="s0"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE</span>
<span class="s0"># GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<span class="s0"># WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="s0"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="s0"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_warns</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>

<span class="s2">import </span><span class="s1">scipy.cluster.hierarchy</span>
<span class="s2">from </span><span class="s1">scipy.cluster.hierarchy </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ClusterWarning</span><span class="s2">, </span><span class="s1">linkage</span><span class="s2">, </span><span class="s1">from_mlab_linkage</span><span class="s2">, </span><span class="s1">to_mlab_linkage</span><span class="s2">,</span>
    <span class="s1">num_obs_linkage</span><span class="s2">, </span><span class="s1">inconsistent</span><span class="s2">, </span><span class="s1">cophenet</span><span class="s2">, </span><span class="s1">fclusterdata</span><span class="s2">, </span><span class="s1">fcluster</span><span class="s2">,</span>
    <span class="s1">is_isomorphic</span><span class="s2">, </span><span class="s1">single</span><span class="s2">, </span><span class="s1">leaders</span><span class="s2">,</span>
    <span class="s1">correspond</span><span class="s2">, </span><span class="s1">is_monotonic</span><span class="s2">, </span><span class="s1">maxdists</span><span class="s2">, </span><span class="s1">maxinconsts</span><span class="s2">, </span><span class="s1">maxRstat</span><span class="s2">,</span>
    <span class="s1">is_valid_linkage</span><span class="s2">, </span><span class="s1">is_valid_im</span><span class="s2">, </span><span class="s1">to_tree</span><span class="s2">, </span><span class="s1">leaves_list</span><span class="s2">, </span><span class="s1">dendrogram</span><span class="s2">,</span>
    <span class="s1">set_link_color_palette</span><span class="s2">, </span><span class="s1">cut_tree</span><span class="s2">, </span><span class="s1">optimal_leaf_ordering</span><span class="s2">,</span>
    <span class="s1">_order_cluster_tree</span><span class="s2">, </span><span class="s1">_hierarchy</span><span class="s2">, </span><span class="s1">_LINKAGE_METHODS)</span>
<span class="s2">from </span><span class="s1">scipy.spatial.distance </span><span class="s2">import </span><span class="s1">pdist</span>
<span class="s2">from </span><span class="s1">scipy.cluster._hierarchy </span><span class="s2">import </span><span class="s1">Heap</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">hierarchy_test_data</span>


<span class="s0"># Matplotlib is not a scipy dependency but is optionally used in dendrogram, so</span>
<span class="s0"># check if it's available</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">matplotlib</span>
    <span class="s0"># and set the backend to be Agg (no gui)</span>
    <span class="s1">matplotlib.use(</span><span class="s3">'Agg'</span><span class="s1">)</span>
    <span class="s0"># before importing pyplot</span>
    <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
    <span class="s1">have_matplotlib = </span><span class="s2">True</span>
<span class="s2">except </span><span class="s1">Exception:</span>
    <span class="s1">have_matplotlib = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">TestLinkage:</span>
    <span class="s2">def </span><span class="s1">test_linkage_non_finite_elements_in_distance_matrix(self):</span>
        <span class="s0"># Tests linkage(Y) where Y contains a non-finite element (e.g. NaN or Inf).</span>
        <span class="s0"># Exception expected.</span>
        <span class="s1">y = np.zeros((</span><span class="s4">6</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">y[</span><span class="s4">0</span><span class="s1">] = np.nan</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linkage</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s2">def </span><span class="s1">test_linkage_empty_distance_matrix(self):</span>
        <span class="s0"># Tests linkage(Y) where Y is a 0x4 linkage matrix. Exception expected.</span>
        <span class="s1">y = np.zeros((</span><span class="s4">0</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linkage</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s2">def </span><span class="s1">test_linkage_tdist(self):</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'single'</span><span class="s2">, </span><span class="s3">'complete'</span><span class="s2">, </span><span class="s3">'average'</span><span class="s2">, </span><span class="s3">'weighted'</span><span class="s1">]:</span>
            <span class="s1">self.check_linkage_tdist(method)</span>

    <span class="s2">def </span><span class="s1">check_linkage_tdist(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s0"># Tests linkage(Y, method) on the tdist data set.</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">expectedZ = getattr(hierarchy_test_data</span><span class="s2">, </span><span class="s3">'linkage_ytdist_' </span><span class="s1">+ method)</span>
        <span class="s1">assert_allclose(Z</span><span class="s2">, </span><span class="s1">expectedZ</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_linkage_X(self):</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'centroid'</span><span class="s2">, </span><span class="s3">'median'</span><span class="s2">, </span><span class="s3">'ward'</span><span class="s1">]:</span>
            <span class="s1">self.check_linkage_q(method)</span>

    <span class="s2">def </span><span class="s1">check_linkage_q(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s0"># Tests linkage(Y, method) on the Q data set.</span>
        <span class="s1">Z = linkage(hierarchy_test_data.X</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">expectedZ = getattr(hierarchy_test_data</span><span class="s2">, </span><span class="s3">'linkage_X_' </span><span class="s1">+ method)</span>
        <span class="s1">assert_allclose(Z</span><span class="s2">, </span><span class="s1">expectedZ</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-06</span><span class="s1">)</span>

        <span class="s1">y = scipy.spatial.distance.pdist(hierarchy_test_data.X</span><span class="s2">,</span>
                                         <span class="s1">metric=</span><span class="s3">&quot;euclidean&quot;</span><span class="s1">)</span>
        <span class="s1">Z = linkage(y</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">assert_allclose(Z</span><span class="s2">, </span><span class="s1">expectedZ</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-06</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_compare_with_trivial(self):</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">20</span>
        <span class="s1">X = rng.rand(n</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">d = pdist(X)</span>

        <span class="s2">for </span><span class="s1">method</span><span class="s2">, </span><span class="s1">code </span><span class="s2">in </span><span class="s1">_LINKAGE_METHODS.items():</span>
            <span class="s1">Z_trivial = _hierarchy.linkage(d</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">code)</span>
            <span class="s1">Z = linkage(d</span><span class="s2">, </span><span class="s1">method)</span>
            <span class="s1">assert_allclose(Z_trivial</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_optimal_leaf_ordering(self):</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s1">optimal_ordering=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expectedZ = getattr(hierarchy_test_data</span><span class="s2">, </span><span class="s3">'linkage_ytdist_single_olo'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(Z</span><span class="s2">, </span><span class="s1">expectedZ</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLinkageTies:</span>
    <span class="s1">_expectations = {</span>
        <span class="s3">'single'</span><span class="s1">: np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.41421356</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.41421356</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s3">'complete'</span><span class="s1">: np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.41421356</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.82842712</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s3">'average'</span><span class="s1">: np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.41421356</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.12132034</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s3">'weighted'</span><span class="s1">: np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.41421356</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.12132034</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s3">'centroid'</span><span class="s1">: np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.41421356</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.12132034</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s3">'median'</span><span class="s1">: np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.41421356</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.12132034</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s3">'ward'</span><span class="s1">: np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.41421356</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.44948974</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">test_linkage_ties(self):</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'single'</span><span class="s2">, </span><span class="s3">'complete'</span><span class="s2">, </span><span class="s3">'average'</span><span class="s2">, </span><span class="s3">'weighted'</span><span class="s2">, </span><span class="s3">'centroid'</span><span class="s2">, </span><span class="s3">'median'</span><span class="s2">, </span><span class="s3">'ward'</span><span class="s1">]:</span>
            <span class="s1">self.check_linkage_ties(method)</span>

    <span class="s2">def </span><span class="s1">check_linkage_ties(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s1">X = np.array([[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
        <span class="s1">Z = linkage(X</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">expectedZ = self._expectations[method]</span>
        <span class="s1">assert_allclose(Z</span><span class="s2">, </span><span class="s1">expectedZ</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-06</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestInconsistent:</span>
    <span class="s2">def </span><span class="s1">test_inconsistent_tdist(self):</span>
        <span class="s2">for </span><span class="s1">depth </span><span class="s2">in </span><span class="s1">hierarchy_test_data.inconsistent_ytdist:</span>
            <span class="s1">self.check_inconsistent_tdist(depth)</span>

    <span class="s2">def </span><span class="s1">check_inconsistent_tdist(self</span><span class="s2">, </span><span class="s1">depth):</span>
        <span class="s1">Z = hierarchy_test_data.linkage_ytdist_single</span>
        <span class="s1">assert_allclose(inconsistent(Z</span><span class="s2">, </span><span class="s1">depth)</span><span class="s2">,</span>
                        <span class="s1">hierarchy_test_data.inconsistent_ytdist[depth])</span>


<span class="s2">class </span><span class="s1">TestCopheneticDistance:</span>
    <span class="s2">def </span><span class="s1">test_linkage_cophenet_tdist_Z(self):</span>
        <span class="s0"># Tests cophenet(Z) on tdist data set.</span>
        <span class="s1">expectedM = np.array([</span><span class="s4">268</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">255</span><span class="s2">, </span><span class="s4">255</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">268</span><span class="s2">, </span><span class="s4">268</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">295</span><span class="s2">,</span>
                              <span class="s4">295</span><span class="s2">, </span><span class="s4">138</span><span class="s2">, </span><span class="s4">219</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">295</span><span class="s1">])</span>
        <span class="s1">Z = hierarchy_test_data.linkage_ytdist_single</span>
        <span class="s1">M = cophenet(Z)</span>
        <span class="s1">assert_allclose(M</span><span class="s2">, </span><span class="s1">expectedM</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_linkage_cophenet_tdist_Z_Y(self):</span>
        <span class="s0"># Tests cophenet(Z, Y) on tdist data set.</span>
        <span class="s1">Z = hierarchy_test_data.linkage_ytdist_single</span>
        <span class="s1">(c</span><span class="s2">, </span><span class="s1">M) = cophenet(Z</span><span class="s2">, </span><span class="s1">hierarchy_test_data.ytdist)</span>
        <span class="s1">expectedM = np.array([</span><span class="s4">268</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">255</span><span class="s2">, </span><span class="s4">255</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">268</span><span class="s2">, </span><span class="s4">268</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">295</span><span class="s2">,</span>
                              <span class="s4">295</span><span class="s2">, </span><span class="s4">138</span><span class="s2">, </span><span class="s4">219</span><span class="s2">, </span><span class="s4">295</span><span class="s2">, </span><span class="s4">295</span><span class="s1">])</span>
        <span class="s1">expectedc = </span><span class="s4">0.639931296433393415057366837573</span>
        <span class="s1">assert_allclose(c</span><span class="s2">, </span><span class="s1">expectedc</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(M</span><span class="s2">, </span><span class="s1">expectedM</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMLabLinkageConversion:</span>
    <span class="s2">def </span><span class="s1">test_mlab_linkage_conversion_empty(self):</span>
        <span class="s0"># Tests from/to_mlab_linkage on empty linkage array.</span>
        <span class="s1">X = np.asarray([])</span>
        <span class="s1">assert_equal(from_mlab_linkage([])</span><span class="s2">, </span><span class="s1">X)</span>
        <span class="s1">assert_equal(to_mlab_linkage([])</span><span class="s2">, </span><span class="s1">X)</span>

    <span class="s2">def </span><span class="s1">test_mlab_linkage_conversion_single_row(self):</span>
        <span class="s0"># Tests from/to_mlab_linkage on linkage array with single row.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">3.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]])</span>
        <span class="s1">Zm = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span>
        <span class="s1">assert_equal(from_mlab_linkage(Zm)</span><span class="s2">, </span><span class="s1">Z)</span>
        <span class="s1">assert_equal(to_mlab_linkage(Z)</span><span class="s2">, </span><span class="s1">Zm)</span>

    <span class="s2">def </span><span class="s1">test_mlab_linkage_conversion_multiple_rows(self):</span>
        <span class="s0"># Tests from/to_mlab_linkage on linkage array with multiple rows.</span>
        <span class="s1">Zm = np.asarray([[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">138</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">219</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">255</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">268</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">295</span><span class="s1">]])</span>
        <span class="s1">Z = np.array([[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">5.</span><span class="s2">, </span><span class="s4">138.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s2">, </span><span class="s4">219.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">7.</span><span class="s2">, </span><span class="s4">255.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">8.</span><span class="s2">, </span><span class="s4">268.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">6.</span><span class="s2">, </span><span class="s4">9.</span><span class="s2">, </span><span class="s4">295.</span><span class="s2">, </span><span class="s4">6.</span><span class="s1">]]</span><span class="s2">,</span>
                      <span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(from_mlab_linkage(Zm)</span><span class="s2">, </span><span class="s1">Z)</span>
        <span class="s1">assert_equal(to_mlab_linkage(Z)</span><span class="s2">, </span><span class="s1">Zm)</span>


<span class="s2">class </span><span class="s1">TestFcluster:</span>
    <span class="s2">def </span><span class="s1">test_fclusterdata(self):</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hierarchy_test_data.fcluster_inconsistent:</span>
            <span class="s1">self.check_fclusterdata(t</span><span class="s2">, </span><span class="s3">'inconsistent'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hierarchy_test_data.fcluster_distance:</span>
            <span class="s1">self.check_fclusterdata(t</span><span class="s2">, </span><span class="s3">'distance'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hierarchy_test_data.fcluster_maxclust:</span>
            <span class="s1">self.check_fclusterdata(t</span><span class="s2">, </span><span class="s3">'maxclust'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">check_fclusterdata(self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">criterion):</span>
        <span class="s0"># Tests fclusterdata(X, criterion=criterion, t=t) on a random 3-cluster data set.</span>
        <span class="s1">expectedT = getattr(hierarchy_test_data</span><span class="s2">, </span><span class="s3">'fcluster_' </span><span class="s1">+ criterion)[t]</span>
        <span class="s1">X = hierarchy_test_data.Q_X</span>
        <span class="s1">T = fclusterdata(X</span><span class="s2">, </span><span class="s1">criterion=criterion</span><span class="s2">, </span><span class="s1">t=t)</span>
        <span class="s1">assert_(is_isomorphic(T</span><span class="s2">, </span><span class="s1">expectedT))</span>

    <span class="s2">def </span><span class="s1">test_fcluster(self):</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hierarchy_test_data.fcluster_inconsistent:</span>
            <span class="s1">self.check_fcluster(t</span><span class="s2">, </span><span class="s3">'inconsistent'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hierarchy_test_data.fcluster_distance:</span>
            <span class="s1">self.check_fcluster(t</span><span class="s2">, </span><span class="s3">'distance'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hierarchy_test_data.fcluster_maxclust:</span>
            <span class="s1">self.check_fcluster(t</span><span class="s2">, </span><span class="s3">'maxclust'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">check_fcluster(self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">criterion):</span>
        <span class="s0"># Tests fcluster(Z, criterion=criterion, t=t) on a random 3-cluster data set.</span>
        <span class="s1">expectedT = getattr(hierarchy_test_data</span><span class="s2">, </span><span class="s3">'fcluster_' </span><span class="s1">+ criterion)[t]</span>
        <span class="s1">Z = single(hierarchy_test_data.Q_X)</span>
        <span class="s1">T = fcluster(Z</span><span class="s2">, </span><span class="s1">criterion=criterion</span><span class="s2">, </span><span class="s1">t=t)</span>
        <span class="s1">assert_(is_isomorphic(T</span><span class="s2">, </span><span class="s1">expectedT))</span>

    <span class="s2">def </span><span class="s1">test_fcluster_monocrit(self):</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hierarchy_test_data.fcluster_distance:</span>
            <span class="s1">self.check_fcluster_monocrit(t)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">hierarchy_test_data.fcluster_maxclust:</span>
            <span class="s1">self.check_fcluster_maxclust_monocrit(t)</span>

    <span class="s2">def </span><span class="s1">check_fcluster_monocrit(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">expectedT = hierarchy_test_data.fcluster_distance[t]</span>
        <span class="s1">Z = single(hierarchy_test_data.Q_X)</span>
        <span class="s1">T = fcluster(Z</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">criterion=</span><span class="s3">'monocrit'</span><span class="s2">, </span><span class="s1">monocrit=maxdists(Z))</span>
        <span class="s1">assert_(is_isomorphic(T</span><span class="s2">, </span><span class="s1">expectedT))</span>

    <span class="s2">def </span><span class="s1">check_fcluster_maxclust_monocrit(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">expectedT = hierarchy_test_data.fcluster_maxclust[t]</span>
        <span class="s1">Z = single(hierarchy_test_data.Q_X)</span>
        <span class="s1">T = fcluster(Z</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">criterion=</span><span class="s3">'maxclust_monocrit'</span><span class="s2">, </span><span class="s1">monocrit=maxdists(Z))</span>
        <span class="s1">assert_(is_isomorphic(T</span><span class="s2">, </span><span class="s1">expectedT))</span>


<span class="s2">class </span><span class="s1">TestLeaders:</span>
    <span class="s2">def </span><span class="s1">test_leaders_single(self):</span>
        <span class="s0"># Tests leaders using a flat clustering generated by single linkage.</span>
        <span class="s1">X = hierarchy_test_data.Q_X</span>
        <span class="s1">Y = pdist(X)</span>
        <span class="s1">Z = linkage(Y)</span>
        <span class="s1">T = fcluster(Z</span><span class="s2">, </span><span class="s1">criterion=</span><span class="s3">'maxclust'</span><span class="s2">, </span><span class="s1">t=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">Lright = (np.array([</span><span class="s4">53</span><span class="s2">, </span><span class="s4">55</span><span class="s2">, </span><span class="s4">56</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s1">L = leaders(Z</span><span class="s2">, </span><span class="s1">T)</span>
        <span class="s1">assert_equal(L</span><span class="s2">, </span><span class="s1">Lright)</span>


<span class="s2">class </span><span class="s1">TestIsIsomorphic:</span>
    <span class="s2">def </span><span class="s1">test_is_isomorphic_1(self):</span>
        <span class="s0"># Tests is_isomorphic on test case #1 (one flat cluster, different labellings)</span>
        <span class="s1">a = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">assert_(is_isomorphic(a</span><span class="s2">, </span><span class="s1">b))</span>
        <span class="s1">assert_(is_isomorphic(b</span><span class="s2">, </span><span class="s1">a))</span>

    <span class="s2">def </span><span class="s1">test_is_isomorphic_2(self):</span>
        <span class="s0"># Tests is_isomorphic on test case #2 (two flat clusters, different labelings)</span>
        <span class="s1">a = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">assert_(is_isomorphic(a</span><span class="s2">, </span><span class="s1">b))</span>
        <span class="s1">assert_(is_isomorphic(b</span><span class="s2">, </span><span class="s1">a))</span>

    <span class="s2">def </span><span class="s1">test_is_isomorphic_3(self):</span>
        <span class="s0"># Tests is_isomorphic on test case #3 (no flat clusters)</span>
        <span class="s1">a = []</span>
        <span class="s1">b = []</span>
        <span class="s1">assert_(is_isomorphic(a</span><span class="s2">, </span><span class="s1">b))</span>

    <span class="s2">def </span><span class="s1">test_is_isomorphic_4A(self):</span>
        <span class="s0"># Tests is_isomorphic on test case #4A (3 flat clusters, different labelings, isomorphic)</span>
        <span class="s1">a = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">assert_(is_isomorphic(a</span><span class="s2">, </span><span class="s1">b))</span>
        <span class="s1">assert_(is_isomorphic(b</span><span class="s2">, </span><span class="s1">a))</span>

    <span class="s2">def </span><span class="s1">test_is_isomorphic_4B(self):</span>
        <span class="s0"># Tests is_isomorphic on test case #4B (3 flat clusters, different labelings, nonisomorphic)</span>
        <span class="s1">a = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">assert_(is_isomorphic(a</span><span class="s2">, </span><span class="s1">b) </span><span class="s2">is False</span><span class="s1">)</span>
        <span class="s1">assert_(is_isomorphic(b</span><span class="s2">, </span><span class="s1">a) </span><span class="s2">is False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_isomorphic_4C(self):</span>
        <span class="s0"># Tests is_isomorphic on test case #4C (3 flat clusters, different labelings, isomorphic)</span>
        <span class="s1">a = [</span><span class="s4">7</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s4">6</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">assert_(is_isomorphic(a</span><span class="s2">, </span><span class="s1">b))</span>
        <span class="s1">assert_(is_isomorphic(b</span><span class="s2">, </span><span class="s1">a))</span>

    <span class="s2">def </span><span class="s1">test_is_isomorphic_5(self):</span>
        <span class="s0"># Tests is_isomorphic on test case #5 (1000 observations, 2/3/5 random</span>
        <span class="s0"># clusters, random permutation of the labeling).</span>
        <span class="s2">for </span><span class="s1">nc </span><span class="s2">in </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]:</span>
            <span class="s1">self.help_is_isomorphic_randperm(</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">nc)</span>

    <span class="s2">def </span><span class="s1">test_is_isomorphic_6(self):</span>
        <span class="s0"># Tests is_isomorphic on test case #5A (1000 observations, 2/3/5 random</span>
        <span class="s0"># clusters, random permutation of the labeling, slightly</span>
        <span class="s0"># nonisomorphic.)</span>
        <span class="s2">for </span><span class="s1">nc </span><span class="s2">in </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]:</span>
            <span class="s1">self.help_is_isomorphic_randperm(</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">nc</span><span class="s2">, True, </span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_isomorphic_7(self):</span>
        <span class="s0"># Regression test for gh-6271</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">is_isomorphic([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">help_is_isomorphic_randperm(self</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">nclusters</span><span class="s2">, </span><span class="s1">noniso=</span><span class="s2">False, </span><span class="s1">nerrors=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">a = np.int_(np.random.rand(nobs) * nclusters)</span>
            <span class="s1">b = np.zeros(a.size</span><span class="s2">, </span><span class="s1">dtype=np.int_)</span>
            <span class="s1">P = np.random.permutation(nclusters)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">a.shape[</span><span class="s4">0</span><span class="s1">]):</span>
                <span class="s1">b[i] = P[a[i]]</span>
            <span class="s2">if </span><span class="s1">noniso:</span>
                <span class="s1">Q = np.random.permutation(nobs)</span>
                <span class="s1">b[Q[</span><span class="s4">0</span><span class="s1">:nerrors]] += </span><span class="s4">1</span>
                <span class="s1">b[Q[</span><span class="s4">0</span><span class="s1">:nerrors]] %= nclusters</span>
            <span class="s1">assert_(is_isomorphic(a</span><span class="s2">, </span><span class="s1">b) == (</span><span class="s2">not </span><span class="s1">noniso))</span>
            <span class="s1">assert_(is_isomorphic(b</span><span class="s2">, </span><span class="s1">a) == (</span><span class="s2">not </span><span class="s1">noniso))</span>


<span class="s2">class </span><span class="s1">TestIsValidLinkage:</span>
    <span class="s2">def </span><span class="s1">test_is_valid_linkage_various_size(self):</span>
        <span class="s2">for </span><span class="s1">nrow</span><span class="s2">, </span><span class="s1">ncol</span><span class="s2">, </span><span class="s1">valid </span><span class="s2">in </span><span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, True</span><span class="s1">)]:</span>
            <span class="s1">self.check_is_valid_linkage_various_size(nrow</span><span class="s2">, </span><span class="s1">ncol</span><span class="s2">, </span><span class="s1">valid)</span>

    <span class="s2">def </span><span class="s1">check_is_valid_linkage_various_size(self</span><span class="s2">, </span><span class="s1">nrow</span><span class="s2">, </span><span class="s1">ncol</span><span class="s2">, </span><span class="s1">valid):</span>
        <span class="s0"># Tests is_valid_linkage(Z) with linkage matrics of various sizes</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">Z = Z[:nrow</span><span class="s2">, </span><span class="s1">:ncol]</span>
        <span class="s1">assert_(is_valid_linkage(Z) == valid)</span>
        <span class="s2">if not </span><span class="s1">valid:</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_linkage</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_linkage_int_type(self):</span>
        <span class="s0"># Tests is_valid_linkage(Z) with integer type.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">assert_(is_valid_linkage(Z) </span><span class="s2">is False</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">is_valid_linkage</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_linkage_empty(self):</span>
        <span class="s0"># Tests is_valid_linkage(Z) with empty linkage.</span>
        <span class="s1">Z = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_(is_valid_linkage(Z) </span><span class="s2">is False</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_linkage</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_linkage_4_and_up(self):</span>
        <span class="s0"># Tests is_valid_linkage(Z) on linkage on observation sets between</span>
        <span class="s0"># sizes 4 and 15 (step size 3).</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">assert_(is_valid_linkage(Z) </span><span class="s2">is True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_linkage_4_and_up_neg_index_left(self):</span>
        <span class="s0"># Tests is_valid_linkage(Z) on linkage on observation sets between</span>
        <span class="s0"># sizes 4 and 15 (step size 3) with negative indices (left).</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">Z[i//</span><span class="s4">2</span><span class="s2">,</span><span class="s4">0</span><span class="s1">] = -</span><span class="s4">2</span>
            <span class="s1">assert_(is_valid_linkage(Z) </span><span class="s2">is False</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_linkage</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_linkage_4_and_up_neg_index_right(self):</span>
        <span class="s0"># Tests is_valid_linkage(Z) on linkage on observation sets between</span>
        <span class="s0"># sizes 4 and 15 (step size 3) with negative indices (right).</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">Z[i//</span><span class="s4">2</span><span class="s2">,</span><span class="s4">1</span><span class="s1">] = -</span><span class="s4">2</span>
            <span class="s1">assert_(is_valid_linkage(Z) </span><span class="s2">is False</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_linkage</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_linkage_4_and_up_neg_dist(self):</span>
        <span class="s0"># Tests is_valid_linkage(Z) on linkage on observation sets between</span>
        <span class="s0"># sizes 4 and 15 (step size 3) with negative distances.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">Z[i//</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">] = -</span><span class="s4">0.5</span>
            <span class="s1">assert_(is_valid_linkage(Z) </span><span class="s2">is False</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_linkage</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_linkage_4_and_up_neg_counts(self):</span>
        <span class="s0"># Tests is_valid_linkage(Z) on linkage on observation sets between</span>
        <span class="s0"># sizes 4 and 15 (step size 3) with negative counts.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">Z[i//</span><span class="s4">2</span><span class="s2">,</span><span class="s4">3</span><span class="s1">] = -</span><span class="s4">2</span>
            <span class="s1">assert_(is_valid_linkage(Z) </span><span class="s2">is False</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_linkage</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestIsValidInconsistent:</span>
    <span class="s2">def </span><span class="s1">test_is_valid_im_int_type(self):</span>
        <span class="s0"># Tests is_valid_im(R) with integer type.</span>
        <span class="s1">R = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">assert_(is_valid_im(R) </span><span class="s2">is False</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">is_valid_im</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_im_various_size(self):</span>
        <span class="s2">for </span><span class="s1">nrow</span><span class="s2">, </span><span class="s1">ncol</span><span class="s2">, </span><span class="s1">valid </span><span class="s2">in </span><span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, True</span><span class="s1">)]:</span>
            <span class="s1">self.check_is_valid_im_various_size(nrow</span><span class="s2">, </span><span class="s1">ncol</span><span class="s2">, </span><span class="s1">valid)</span>

    <span class="s2">def </span><span class="s1">check_is_valid_im_various_size(self</span><span class="s2">, </span><span class="s1">nrow</span><span class="s2">, </span><span class="s1">ncol</span><span class="s2">, </span><span class="s1">valid):</span>
        <span class="s0"># Tests is_valid_im(R) with linkage matrics of various sizes</span>
        <span class="s1">R = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">R = R[:nrow</span><span class="s2">, </span><span class="s1">:ncol]</span>
        <span class="s1">assert_(is_valid_im(R) == valid)</span>
        <span class="s2">if not </span><span class="s1">valid:</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_im</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_im_empty(self):</span>
        <span class="s0"># Tests is_valid_im(R) with empty inconsistency matrix.</span>
        <span class="s1">R = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_(is_valid_im(R) </span><span class="s2">is False</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_im</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_im_4_and_up(self):</span>
        <span class="s0"># Tests is_valid_im(R) on im on observation sets between sizes 4 and 15</span>
        <span class="s0"># (step size 3).</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">R = inconsistent(Z)</span>
            <span class="s1">assert_(is_valid_im(R) </span><span class="s2">is True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_im_4_and_up_neg_index_left(self):</span>
        <span class="s0"># Tests is_valid_im(R) on im on observation sets between sizes 4 and 15</span>
        <span class="s0"># (step size 3) with negative link height means.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">R = inconsistent(Z)</span>
            <span class="s1">R[i//</span><span class="s4">2</span><span class="s2">,</span><span class="s4">0</span><span class="s1">] = -</span><span class="s4">2.0</span>
            <span class="s1">assert_(is_valid_im(R) </span><span class="s2">is False</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_im</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_im_4_and_up_neg_index_right(self):</span>
        <span class="s0"># Tests is_valid_im(R) on im on observation sets between sizes 4 and 15</span>
        <span class="s0"># (step size 3) with negative link height standard deviations.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">R = inconsistent(Z)</span>
            <span class="s1">R[i//</span><span class="s4">2</span><span class="s2">,</span><span class="s4">1</span><span class="s1">] = -</span><span class="s4">2.0</span>
            <span class="s1">assert_(is_valid_im(R) </span><span class="s2">is False</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_im</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_valid_im_4_and_up_neg_dist(self):</span>
        <span class="s0"># Tests is_valid_im(R) on im on observation sets between sizes 4 and 15</span>
        <span class="s0"># (step size 3) with negative link counts.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">R = inconsistent(Z)</span>
            <span class="s1">R[i//</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">] = -</span><span class="s4">0.5</span>
            <span class="s1">assert_(is_valid_im(R) </span><span class="s2">is False</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_valid_im</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">throw=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNumObsLinkage:</span>
    <span class="s2">def </span><span class="s1">test_num_obs_linkage_empty(self):</span>
        <span class="s0"># Tests num_obs_linkage(Z) with empty linkage.</span>
        <span class="s1">Z = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">num_obs_linkage</span><span class="s2">, </span><span class="s1">Z)</span>

    <span class="s2">def </span><span class="s1">test_num_obs_linkage_1x4(self):</span>
        <span class="s0"># Tests num_obs_linkage(Z) on linkage over 2 observations.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(num_obs_linkage(Z)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_num_obs_linkage_2x4(self):</span>
        <span class="s0"># Tests num_obs_linkage(Z) on linkage over 3 observations.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(num_obs_linkage(Z)</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_num_obs_linkage_4_and_up(self):</span>
        <span class="s0"># Tests num_obs_linkage(Z) on linkage on observation sets between sizes</span>
        <span class="s0"># 4 and 15 (step size 3).</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">assert_equal(num_obs_linkage(Z)</span><span class="s2">, </span><span class="s1">i)</span>


<span class="s2">class </span><span class="s1">TestLeavesList:</span>
    <span class="s2">def </span><span class="s1">test_leaves_list_1x4(self):</span>
        <span class="s0"># Tests leaves_list(Z) on a 1x4 linkage.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">to_tree(Z)</span>
        <span class="s1">assert_equal(leaves_list(Z)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_leaves_list_2x4(self):</span>
        <span class="s0"># Tests leaves_list(Z) on a 2x4 linkage.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">to_tree(Z)</span>
        <span class="s1">assert_equal(leaves_list(Z)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_leaves_list_Q(self):</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'single'</span><span class="s2">, </span><span class="s3">'complete'</span><span class="s2">, </span><span class="s3">'average'</span><span class="s2">, </span><span class="s3">'weighted'</span><span class="s2">, </span><span class="s3">'centroid'</span><span class="s2">,</span>
                       <span class="s3">'median'</span><span class="s2">, </span><span class="s3">'ward'</span><span class="s1">]:</span>
            <span class="s1">self.check_leaves_list_Q(method)</span>

    <span class="s2">def </span><span class="s1">check_leaves_list_Q(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s0"># Tests leaves_list(Z) on the Q data set</span>
        <span class="s1">X = hierarchy_test_data.Q_X</span>
        <span class="s1">Z = linkage(X</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">node = to_tree(Z)</span>
        <span class="s1">assert_equal(node.pre_order()</span><span class="s2">, </span><span class="s1">leaves_list(Z))</span>

    <span class="s2">def </span><span class="s1">test_Q_subtree_pre_order(self):</span>
        <span class="s0"># Tests that pre_order() works when called on sub-trees.</span>
        <span class="s1">X = hierarchy_test_data.Q_X</span>
        <span class="s1">Z = linkage(X</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>
        <span class="s1">node = to_tree(Z)</span>
        <span class="s1">assert_equal(node.pre_order()</span><span class="s2">, </span><span class="s1">(node.get_left().pre_order()</span>
                                        <span class="s1">+ node.get_right().pre_order()))</span>


<span class="s2">class </span><span class="s1">TestCorrespond:</span>
    <span class="s2">def </span><span class="s1">test_correspond_empty(self):</span>
        <span class="s0"># Tests correspond(Z, y) with empty linkage and condensed distance matrix.</span>
        <span class="s1">y = np.zeros((</span><span class="s4">0</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">Z = np.zeros((</span><span class="s4">0</span><span class="s2">,</span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">correspond</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s2">def </span><span class="s1">test_correspond_2_and_up(self):</span>
        <span class="s0"># Tests correspond(Z, y) on linkage and CDMs over observation sets of</span>
        <span class="s0"># different sizes.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">assert_(correspond(Z</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">assert_(correspond(Z</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s2">def </span><span class="s1">test_correspond_4_and_up(self):</span>
        <span class="s0"># Tests correspond(Z, y) on linkage and CDMs over observation sets of</span>
        <span class="s0"># different sizes. Correspondence should be false.</span>
        <span class="s2">for </span><span class="s1">(i</span><span class="s2">, </span><span class="s1">j) </span><span class="s2">in </span><span class="s1">(list(zip(list(range(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">list(range(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)))) +</span>
                       <span class="s1">list(zip(list(range(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span><span class="s2">, </span><span class="s1">list(range(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))))):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">y2 = np.random.rand(j*(j-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">Z2 = linkage(y2)</span>
            <span class="s1">assert_equal(correspond(Z</span><span class="s2">, </span><span class="s1">y2)</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s1">assert_equal(correspond(Z2</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_correspond_4_and_up_2(self):</span>
        <span class="s0"># Tests correspond(Z, y) on linkage and CDMs over observation sets of</span>
        <span class="s0"># different sizes. Correspondence should be false.</span>
        <span class="s2">for </span><span class="s1">(i</span><span class="s2">, </span><span class="s1">j) </span><span class="s2">in </span><span class="s1">(list(zip(list(range(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">7</span><span class="s1">))</span><span class="s2">, </span><span class="s1">list(range(</span><span class="s4">16</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)))) +</span>
                       <span class="s1">list(zip(list(range(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">7</span><span class="s1">))</span><span class="s2">, </span><span class="s1">list(range(</span><span class="s4">16</span><span class="s2">, </span><span class="s4">21</span><span class="s1">))))):</span>
            <span class="s1">y = np.random.rand(i*(i-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">y2 = np.random.rand(j*(j-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">Z = linkage(y)</span>
            <span class="s1">Z2 = linkage(y2)</span>
            <span class="s1">assert_equal(correspond(Z</span><span class="s2">, </span><span class="s1">y2)</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s1">assert_equal(correspond(Z2</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_num_obs_linkage_multi_matrix(self):</span>
        <span class="s0"># Tests num_obs_linkage with observation matrices of multiple sizes.</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s1">):</span>
            <span class="s1">X = np.random.rand(n</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
            <span class="s1">Y = pdist(X)</span>
            <span class="s1">Z = linkage(Y)</span>
            <span class="s1">assert_equal(num_obs_linkage(Z)</span><span class="s2">, </span><span class="s1">n)</span>


<span class="s2">class </span><span class="s1">TestIsMonotonic:</span>
    <span class="s2">def </span><span class="s1">test_is_monotonic_empty(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on an empty linkage.</span>
        <span class="s1">Z = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">is_monotonic</span><span class="s2">, </span><span class="s1">Z)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_1x4(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on 1x4 linkage. Expecting True.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_2x4_T(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on 2x4 linkage. Expecting True.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_2x4_F(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on 2x4 linkage. Expecting False.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_3x4_T(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on 3x4 linkage. Expecting True.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_3x4_F1(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on 3x4 linkage (case 1). Expecting False.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_3x4_F2(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on 3x4 linkage (case 2). Expecting False.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_3x4_F3(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on 3x4 linkage (case 3). Expecting False</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_tdist_linkage1(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on clustering generated by single linkage on</span>
        <span class="s0"># tdist data set. Expecting True.</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_tdist_linkage2(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on clustering generated by single linkage on</span>
        <span class="s0"># tdist data set. Perturbing. Expecting False.</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>
        <span class="s1">Z[</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">] = </span><span class="s4">0.0</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_monotonic_Q_linkage(self):</span>
        <span class="s0"># Tests is_monotonic(Z) on clustering generated by single linkage on</span>
        <span class="s0"># Q data set. Expecting True.</span>
        <span class="s1">X = hierarchy_test_data.Q_X</span>
        <span class="s1">Z = linkage(X</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>
        <span class="s1">assert_equal(is_monotonic(Z)</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMaxDists:</span>
    <span class="s2">def </span><span class="s1">test_maxdists_empty_linkage(self):</span>
        <span class="s0"># Tests maxdists(Z) on empty linkage. Expecting exception.</span>
        <span class="s1">Z = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">maxdists</span><span class="s2">, </span><span class="s1">Z)</span>

    <span class="s2">def </span><span class="s1">test_maxdists_one_cluster_linkage(self):</span>
        <span class="s0"># Tests maxdists(Z) on linkage with one cluster.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">MD = maxdists(Z)</span>
        <span class="s1">expectedMD = calculate_maximum_distances(Z)</span>
        <span class="s1">assert_allclose(MD</span><span class="s2">, </span><span class="s1">expectedMD</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_maxdists_Q_linkage(self):</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'single'</span><span class="s2">, </span><span class="s3">'complete'</span><span class="s2">, </span><span class="s3">'ward'</span><span class="s2">, </span><span class="s3">'centroid'</span><span class="s2">, </span><span class="s3">'median'</span><span class="s1">]:</span>
            <span class="s1">self.check_maxdists_Q_linkage(method)</span>

    <span class="s2">def </span><span class="s1">check_maxdists_Q_linkage(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s0"># Tests maxdists(Z) on the Q data set</span>
        <span class="s1">X = hierarchy_test_data.Q_X</span>
        <span class="s1">Z = linkage(X</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">MD = maxdists(Z)</span>
        <span class="s1">expectedMD = calculate_maximum_distances(Z)</span>
        <span class="s1">assert_allclose(MD</span><span class="s2">, </span><span class="s1">expectedMD</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMaxInconsts:</span>
    <span class="s2">def </span><span class="s1">test_maxinconsts_empty_linkage(self):</span>
        <span class="s0"># Tests maxinconsts(Z, R) on empty linkage. Expecting exception.</span>
        <span class="s1">Z = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">R = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">maxinconsts</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">R)</span>

    <span class="s2">def </span><span class="s1">test_maxinconsts_difrow_linkage(self):</span>
        <span class="s0"># Tests maxinconsts(Z, R) on linkage and inconsistency matrices with</span>
        <span class="s0"># different numbers of clusters. Expecting exception.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">R = np.random.rand(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">maxinconsts</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">R)</span>

    <span class="s2">def </span><span class="s1">test_maxinconsts_one_cluster_linkage(self):</span>
        <span class="s0"># Tests maxinconsts(Z, R) on linkage with one cluster.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">R = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">MD = maxinconsts(Z</span><span class="s2">, </span><span class="s1">R)</span>
        <span class="s1">expectedMD = calculate_maximum_inconsistencies(Z</span><span class="s2">, </span><span class="s1">R)</span>
        <span class="s1">assert_allclose(MD</span><span class="s2">, </span><span class="s1">expectedMD</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_maxinconsts_Q_linkage(self):</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'single'</span><span class="s2">, </span><span class="s3">'complete'</span><span class="s2">, </span><span class="s3">'ward'</span><span class="s2">, </span><span class="s3">'centroid'</span><span class="s2">, </span><span class="s3">'median'</span><span class="s1">]:</span>
            <span class="s1">self.check_maxinconsts_Q_linkage(method)</span>

    <span class="s2">def </span><span class="s1">check_maxinconsts_Q_linkage(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s0"># Tests maxinconsts(Z, R) on the Q data set</span>
        <span class="s1">X = hierarchy_test_data.Q_X</span>
        <span class="s1">Z = linkage(X</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">R = inconsistent(Z)</span>
        <span class="s1">MD = maxinconsts(Z</span><span class="s2">, </span><span class="s1">R)</span>
        <span class="s1">expectedMD = calculate_maximum_inconsistencies(Z</span><span class="s2">, </span><span class="s1">R)</span>
        <span class="s1">assert_allclose(MD</span><span class="s2">, </span><span class="s1">expectedMD</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMaxRStat:</span>
    <span class="s2">def </span><span class="s1">test_maxRstat_invalid_index(self):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">[</span><span class="s4">3.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]:</span>
            <span class="s1">self.check_maxRstat_invalid_index(i)</span>

    <span class="s2">def </span><span class="s1">check_maxRstat_invalid_index(self</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s0"># Tests maxRstat(Z, R, i). Expecting exception.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">R = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s2">if </span><span class="s1">isinstance(i</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">maxRstat</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">i)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">maxRstat</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">i)</span>

    <span class="s2">def </span><span class="s1">test_maxRstat_empty_linkage(self):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
            <span class="s1">self.check_maxRstat_empty_linkage(i)</span>

    <span class="s2">def </span><span class="s1">check_maxRstat_empty_linkage(self</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s0"># Tests maxRstat(Z, R, i) on empty linkage. Expecting exception.</span>
        <span class="s1">Z = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">R = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">maxRstat</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">i)</span>

    <span class="s2">def </span><span class="s1">test_maxRstat_difrow_linkage(self):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
            <span class="s1">self.check_maxRstat_difrow_linkage(i)</span>

    <span class="s2">def </span><span class="s1">check_maxRstat_difrow_linkage(self</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s0"># Tests maxRstat(Z, R, i) on linkage and inconsistency matrices with</span>
        <span class="s0"># different numbers of clusters. Expecting exception.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">R = np.random.rand(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">maxRstat</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">i)</span>

    <span class="s2">def </span><span class="s1">test_maxRstat_one_cluster_linkage(self):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
            <span class="s1">self.check_maxRstat_one_cluster_linkage(i)</span>

    <span class="s2">def </span><span class="s1">check_maxRstat_one_cluster_linkage(self</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s0"># Tests maxRstat(Z, R, i) on linkage with one cluster.</span>
        <span class="s1">Z = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">R = np.asarray([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">MD = maxRstat(Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expectedMD = calculate_maximum_inconsistencies(Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(MD</span><span class="s2">, </span><span class="s1">expectedMD</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_maxRstat_Q_linkage(self):</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'single'</span><span class="s2">, </span><span class="s3">'complete'</span><span class="s2">, </span><span class="s3">'ward'</span><span class="s2">, </span><span class="s3">'centroid'</span><span class="s2">, </span><span class="s3">'median'</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
                <span class="s1">self.check_maxRstat_Q_linkage(method</span><span class="s2">, </span><span class="s1">i)</span>

    <span class="s2">def </span><span class="s1">check_maxRstat_Q_linkage(self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">i):</span>
        <span class="s0"># Tests maxRstat(Z, R, i) on the Q data set</span>
        <span class="s1">X = hierarchy_test_data.Q_X</span>
        <span class="s1">Z = linkage(X</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">R = inconsistent(Z)</span>
        <span class="s1">MD = maxRstat(Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expectedMD = calculate_maximum_inconsistencies(Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(MD</span><span class="s2">, </span><span class="s1">expectedMD</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDendrogram:</span>
    <span class="s2">def </span><span class="s1">test_dendrogram_single_linkage_tdist(self):</span>
        <span class="s0"># Tests dendrogram calculation on single linkage of the tdist data set.</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>
        <span class="s1">R = dendrogram(Z</span><span class="s2">, </span><span class="s1">no_plot=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">leaves = R[</span><span class="s3">&quot;leaves&quot;</span><span class="s1">]</span>
        <span class="s1">assert_equal(leaves</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_valid_orientation(self):</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">dendrogram</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">orientation=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_labels_as_array_or_list(self):</span>
        <span class="s0"># test for gh-12418</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>
        <span class="s1">labels = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
        <span class="s1">result1 = dendrogram(Z</span><span class="s2">, </span><span class="s1">labels=labels</span><span class="s2">, </span><span class="s1">no_plot=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">result2 = dendrogram(Z</span><span class="s2">, </span><span class="s1">labels=labels.tolist()</span><span class="s2">, </span><span class="s1">no_plot=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result1 == result2</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s2">not </span><span class="s1">have_matplotlib</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;no matplotlib&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_valid_label_size(self):</span>
        <span class="s1">link = np.array([</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">])</span>
        <span class="s1">plt.figure()</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s2">as </span><span class="s1">exc_info:</span>
            <span class="s1">dendrogram(link</span><span class="s2">, </span><span class="s1">labels=list(range(</span><span class="s4">100</span><span class="s1">)))</span>
        <span class="s2">assert </span><span class="s3">&quot;Dimensions of Z and labels must be consistent.&quot;</span><span class="s1">\</span>
               <span class="s2">in </span><span class="s1">str(exc_info.value)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(</span>
                <span class="s1">ValueError</span><span class="s2">,</span>
                <span class="s1">match=</span><span class="s3">&quot;Dimensions of Z and labels must be consistent.&quot;</span><span class="s1">):</span>
            <span class="s1">dendrogram(link</span><span class="s2">, </span><span class="s1">labels=[])</span>

        <span class="s1">plt.close()</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s2">not </span><span class="s1">have_matplotlib</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;no matplotlib&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dendrogram_plot(self):</span>
        <span class="s2">for </span><span class="s1">orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'top'</span><span class="s2">, </span><span class="s3">'bottom'</span><span class="s2">, </span><span class="s3">'left'</span><span class="s2">, </span><span class="s3">'right'</span><span class="s1">]:</span>
            <span class="s1">self.check_dendrogram_plot(orientation)</span>

    <span class="s2">def </span><span class="s1">check_dendrogram_plot(self</span><span class="s2">, </span><span class="s1">orientation):</span>
        <span class="s0"># Tests dendrogram plotting.</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>
        <span class="s1">expected = {</span><span class="s3">'color_list'</span><span class="s1">: [</span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">'dcoord'</span><span class="s1">: [[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">138.0</span><span class="s2">, </span><span class="s4">138.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">219.0</span><span class="s2">, </span><span class="s4">219.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">255.0</span><span class="s2">, </span><span class="s4">255.0</span><span class="s2">, </span><span class="s4">219.0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">268.0</span><span class="s2">, </span><span class="s4">268.0</span><span class="s2">, </span><span class="s4">255.0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">138.0</span><span class="s2">, </span><span class="s4">295.0</span><span class="s2">, </span><span class="s4">295.0</span><span class="s2">, </span><span class="s4">268.0</span><span class="s1">]]</span><span class="s2">,</span>
                    <span class="s3">'icoord'</span><span class="s1">: [[</span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">15.0</span><span class="s2">, </span><span class="s4">15.0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">45.0</span><span class="s2">, </span><span class="s4">45.0</span><span class="s2">, </span><span class="s4">55.0</span><span class="s2">, </span><span class="s4">55.0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">35.0</span><span class="s2">, </span><span class="s4">35.0</span><span class="s2">, </span><span class="s4">50.0</span><span class="s2">, </span><span class="s4">50.0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">42.5</span><span class="s2">, </span><span class="s4">42.5</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">33.75</span><span class="s2">, </span><span class="s4">33.75</span><span class="s1">]]</span><span class="s2">,</span>
                    <span class="s3">'ivl'</span><span class="s1">: [</span><span class="s3">'2'</span><span class="s2">, </span><span class="s3">'5'</span><span class="s2">, </span><span class="s3">'1'</span><span class="s2">, </span><span class="s3">'0'</span><span class="s2">, </span><span class="s3">'3'</span><span class="s2">, </span><span class="s3">'4'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">'leaves'</span><span class="s1">: [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">'leaves_color_list'</span><span class="s1">: [</span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">}</span>

        <span class="s1">fig = plt.figure()</span>
        <span class="s1">ax = fig.add_subplot(</span><span class="s4">221</span><span class="s1">)</span>

        <span class="s0"># test that dendrogram accepts ax keyword</span>
        <span class="s1">R1 = dendrogram(Z</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">orientation=orientation)</span>
        <span class="s1">assert_equal(R1</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># test that dendrogram accepts and handle the leaf_font_size and</span>
        <span class="s0"># leaf_rotation keywords</span>
        <span class="s1">dendrogram(Z</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">orientation=orientation</span><span class="s2">,</span>
                   <span class="s1">leaf_font_size=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">leaf_rotation=</span><span class="s4">90</span><span class="s1">)</span>
        <span class="s1">testlabel = (</span>
            <span class="s1">ax.get_xticklabels()[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'top'</span><span class="s2">, </span><span class="s3">'bottom'</span><span class="s1">]</span>
            <span class="s2">else </span><span class="s1">ax.get_yticklabels()[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_equal(testlabel.get_rotation()</span><span class="s2">, </span><span class="s4">90</span><span class="s1">)</span>
        <span class="s1">assert_equal(testlabel.get_size()</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">dendrogram(Z</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">orientation=orientation</span><span class="s2">,</span>
                   <span class="s1">leaf_rotation=</span><span class="s4">90</span><span class="s1">)</span>
        <span class="s1">testlabel = (</span>
            <span class="s1">ax.get_xticklabels()[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'top'</span><span class="s2">, </span><span class="s3">'bottom'</span><span class="s1">]</span>
            <span class="s2">else </span><span class="s1">ax.get_yticklabels()[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_equal(testlabel.get_rotation()</span><span class="s2">, </span><span class="s4">90</span><span class="s1">)</span>
        <span class="s1">dendrogram(Z</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">orientation=orientation</span><span class="s2">,</span>
                   <span class="s1">leaf_font_size=</span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">testlabel = (</span>
            <span class="s1">ax.get_xticklabels()[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'top'</span><span class="s2">, </span><span class="s3">'bottom'</span><span class="s1">]</span>
            <span class="s2">else </span><span class="s1">ax.get_yticklabels()[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_equal(testlabel.get_size()</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">plt.close()</span>

        <span class="s0"># test plotting to gca (will import pylab)</span>
        <span class="s1">R2 = dendrogram(Z</span><span class="s2">, </span><span class="s1">orientation=orientation)</span>
        <span class="s1">plt.close()</span>
        <span class="s1">assert_equal(R2</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s2">not </span><span class="s1">have_matplotlib</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;no matplotlib&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dendrogram_truncate_mode(self):</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>

        <span class="s1">R = dendrogram(Z</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s3">'lastp'</span><span class="s2">, </span><span class="s1">show_contracted=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">plt.close()</span>
        <span class="s1">assert_equal(R</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'color_list'</span><span class="s1">: [</span><span class="s3">'C0'</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s3">'dcoord'</span><span class="s1">: [[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">295.0</span><span class="s2">, </span><span class="s4">295.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]]</span><span class="s2">,</span>
                         <span class="s3">'icoord'</span><span class="s1">: [[</span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">15.0</span><span class="s2">, </span><span class="s4">15.0</span><span class="s1">]]</span><span class="s2">,</span>
                         <span class="s3">'ivl'</span><span class="s1">: [</span><span class="s3">'(2)'</span><span class="s2">, </span><span class="s3">'(4)'</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s3">'leaves'</span><span class="s1">: [</span><span class="s4">6</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s3">'leaves_color_list'</span><span class="s1">: [</span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">})</span>

        <span class="s1">R = dendrogram(Z</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s3">'mtica'</span><span class="s2">, </span><span class="s1">show_contracted=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">plt.close()</span>
        <span class="s1">assert_equal(R</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'color_list'</span><span class="s1">: [</span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s3">'dcoord'</span><span class="s1">: [[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">138.0</span><span class="s2">, </span><span class="s4">138.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">255.0</span><span class="s2">, </span><span class="s4">255.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">268.0</span><span class="s2">, </span><span class="s4">268.0</span><span class="s2">, </span><span class="s4">255.0</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">138.0</span><span class="s2">, </span><span class="s4">295.0</span><span class="s2">, </span><span class="s4">295.0</span><span class="s2">, </span><span class="s4">268.0</span><span class="s1">]]</span><span class="s2">,</span>
                         <span class="s3">'icoord'</span><span class="s1">: [[</span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">15.0</span><span class="s2">, </span><span class="s4">15.0</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">35.0</span><span class="s2">, </span><span class="s4">35.0</span><span class="s2">, </span><span class="s4">45.0</span><span class="s2">, </span><span class="s4">45.0</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">40.0</span><span class="s2">, </span><span class="s4">40.0</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">[</span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">32.5</span><span class="s2">, </span><span class="s4">32.5</span><span class="s1">]]</span><span class="s2">,</span>
                         <span class="s3">'ivl'</span><span class="s1">: [</span><span class="s3">'2'</span><span class="s2">, </span><span class="s3">'5'</span><span class="s2">, </span><span class="s3">'1'</span><span class="s2">, </span><span class="s3">'0'</span><span class="s2">, </span><span class="s3">'(2)'</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s3">'leaves'</span><span class="s1">: [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s3">'leaves_color_list'</span><span class="s1">: [</span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">})</span>

    <span class="s2">def </span><span class="s1">test_dendrogram_colors(self):</span>
        <span class="s0"># Tests dendrogram plots with alternate colors</span>
        <span class="s1">Z = linkage(hierarchy_test_data.ytdist</span><span class="s2">, </span><span class="s3">'single'</span><span class="s1">)</span>

        <span class="s1">set_link_color_palette([</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'m'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'k'</span><span class="s1">])</span>
        <span class="s1">R = dendrogram(Z</span><span class="s2">, </span><span class="s1">no_plot=</span><span class="s2">True,</span>
                       <span class="s1">above_threshold_color=</span><span class="s3">'g'</span><span class="s2">, </span><span class="s1">color_threshold=</span><span class="s4">250</span><span class="s1">)</span>
        <span class="s1">set_link_color_palette([</span><span class="s3">'g'</span><span class="s2">, </span><span class="s3">'r'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'m'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'k'</span><span class="s1">])</span>

        <span class="s1">color_list = R[</span><span class="s3">'color_list'</span><span class="s1">]</span>
        <span class="s1">assert_equal(color_list</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'m'</span><span class="s2">, </span><span class="s3">'g'</span><span class="s2">, </span><span class="s3">'g'</span><span class="s2">, </span><span class="s3">'g'</span><span class="s1">])</span>

        <span class="s0"># reset color palette (global list)</span>
        <span class="s1">set_link_color_palette(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dendrogram_leaf_colors_zero_dist(self):</span>
        <span class="s0"># tests that the colors of leafs are correct for tree</span>
        <span class="s0"># with two identical points</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s1">z = linkage(x</span><span class="s2">, </span><span class="s3">&quot;single&quot;</span><span class="s1">)</span>
        <span class="s1">d = dendrogram(z</span><span class="s2">, </span><span class="s1">no_plot=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">exp_colors = [</span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C2'</span><span class="s2">, </span><span class="s3">'C2'</span><span class="s1">]</span>
        <span class="s1">colors = d[</span><span class="s3">&quot;leaves_color_list&quot;</span><span class="s1">]</span>
        <span class="s1">assert_equal(colors</span><span class="s2">, </span><span class="s1">exp_colors)</span>

    <span class="s2">def </span><span class="s1">test_dendrogram_leaf_colors(self):</span>
        <span class="s0"># tests that the colors are correct for a tree</span>
        <span class="s0"># with two near points ((0, 0, 1.1) and (0, 0, 1))</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s1">z = linkage(x</span><span class="s2">, </span><span class="s3">&quot;single&quot;</span><span class="s1">)</span>
        <span class="s1">d = dendrogram(z</span><span class="s2">, </span><span class="s1">no_plot=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">exp_colors = [</span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C1'</span><span class="s2">, </span><span class="s3">'C0'</span><span class="s2">, </span><span class="s3">'C2'</span><span class="s2">, </span><span class="s3">'C2'</span><span class="s1">]</span>
        <span class="s1">colors = d[</span><span class="s3">&quot;leaves_color_list&quot;</span><span class="s1">]</span>
        <span class="s1">assert_equal(colors</span><span class="s2">, </span><span class="s1">exp_colors)</span>


<span class="s2">def </span><span class="s1">calculate_maximum_distances(Z):</span>
    <span class="s0"># Used for testing correctness of maxdists.</span>
    <span class="s1">n = Z.shape[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">1</span>
    <span class="s1">B = np.zeros((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">q = np.zeros((</span><span class="s4">3</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">q[:] = </span><span class="s4">0.0</span>
        <span class="s1">left = Z[i</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">right = Z[i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">left &gt;= n:</span>
            <span class="s1">q[</span><span class="s4">0</span><span class="s1">] = B[int(left) - n]</span>
        <span class="s2">if </span><span class="s1">right &gt;= n:</span>
            <span class="s1">q[</span><span class="s4">1</span><span class="s1">] = B[int(right) - n]</span>
        <span class="s1">q[</span><span class="s4">2</span><span class="s1">] = Z[i</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">B[i] = q.max()</span>
    <span class="s2">return </span><span class="s1">B</span>


<span class="s2">def </span><span class="s1">calculate_maximum_inconsistencies(Z</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">3</span><span class="s1">):</span>
    <span class="s0"># Used for testing correctness of maxinconsts.</span>
    <span class="s1">n = Z.shape[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">1</span>
    <span class="s1">B = np.zeros((n-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">q = np.zeros((</span><span class="s4">3</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">q[:] = </span><span class="s4">0.0</span>
        <span class="s1">left = Z[i</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">right = Z[i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">left &gt;= n:</span>
            <span class="s1">q[</span><span class="s4">0</span><span class="s1">] = B[int(left) - n]</span>
        <span class="s2">if </span><span class="s1">right &gt;= n:</span>
            <span class="s1">q[</span><span class="s4">1</span><span class="s1">] = B[int(right) - n]</span>
        <span class="s1">q[</span><span class="s4">2</span><span class="s1">] = R[i</span><span class="s2">, </span><span class="s1">k]</span>
        <span class="s1">B[i] = q.max()</span>
    <span class="s2">return </span><span class="s1">B</span>


<span class="s2">def </span><span class="s1">test_unsupported_uncondensed_distance_matrix_linkage_warning():</span>
    <span class="s1">assert_warns(ClusterWarning</span><span class="s2">, </span><span class="s1">linkage</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>


<span class="s2">def </span><span class="s1">test_euclidean_linkage_value_error():</span>
    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">scipy.cluster.hierarchy._EUCLIDEAN_METHODS:</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linkage</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">,</span>
                      <span class="s1">method=method</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'cityblock'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_2x2_linkage():</span>
    <span class="s1">Z1 = linkage([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'single'</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'euclidean'</span><span class="s1">)</span>
    <span class="s1">Z2 = linkage([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'single'</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'euclidean'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(Z1</span><span class="s2">, </span><span class="s1">Z2)</span>


<span class="s2">def </span><span class="s1">test_node_compare():</span>
    <span class="s1">np.random.seed(</span><span class="s4">23</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s4">50</span>
    <span class="s1">X = np.random.randn(nobs</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">Z = scipy.cluster.hierarchy.ward(X)</span>
    <span class="s1">tree = to_tree(Z)</span>
    <span class="s1">assert_(tree &gt; tree.get_left())</span>
    <span class="s1">assert_(tree.get_right() &gt; tree.get_left())</span>
    <span class="s1">assert_(tree.get_right() == tree.get_right())</span>
    <span class="s1">assert_(tree.get_right() != tree.get_left())</span>


<span class="s2">def </span><span class="s1">test_cut_tree():</span>
    <span class="s1">np.random.seed(</span><span class="s4">23</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s4">50</span>
    <span class="s1">X = np.random.randn(nobs</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">Z = scipy.cluster.hierarchy.ward(X)</span>
    <span class="s1">cutree = cut_tree(Z)</span>

    <span class="s1">assert_equal(cutree[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.arange(nobs))</span>
    <span class="s1">assert_equal(cutree[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.zeros(nobs))</span>
    <span class="s1">assert_equal(cutree.max(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.arange(nobs - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">assert_equal(cutree[:</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">cut_tree(Z</span><span class="s2">, </span><span class="s1">n_clusters=</span><span class="s4">5</span><span class="s1">))</span>
    <span class="s1">assert_equal(cutree[:</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">cut_tree(Z</span><span class="s2">, </span><span class="s1">n_clusters=[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]))</span>
    <span class="s1">assert_equal(cutree[:</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">cut_tree(Z</span><span class="s2">, </span><span class="s1">n_clusters=[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]))</span>

    <span class="s1">nodes = _order_cluster_tree(Z)</span>
    <span class="s1">heights = np.array([node.dist </span><span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">nodes])</span>

    <span class="s1">assert_equal(cutree[:</span><span class="s2">, </span><span class="s1">np.searchsorted(heights</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s1">])]</span><span class="s2">,</span>
                 <span class="s1">cut_tree(Z</span><span class="s2">, </span><span class="s1">height=</span><span class="s4">5</span><span class="s1">))</span>
    <span class="s1">assert_equal(cutree[:</span><span class="s2">, </span><span class="s1">np.searchsorted(heights</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])]</span><span class="s2">,</span>
                 <span class="s1">cut_tree(Z</span><span class="s2">, </span><span class="s1">height=[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">]))</span>
    <span class="s1">assert_equal(cutree[:</span><span class="s2">, </span><span class="s1">np.searchsorted(heights</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])]</span><span class="s2">,</span>
                 <span class="s1">cut_tree(Z</span><span class="s2">, </span><span class="s1">height=[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]))</span>


<span class="s2">def </span><span class="s1">test_optimal_leaf_ordering():</span>
    <span class="s0"># test with the distance vector y</span>
    <span class="s1">Z = optimal_leaf_ordering(linkage(hierarchy_test_data.ytdist)</span><span class="s2">,</span>
                              <span class="s1">hierarchy_test_data.ytdist)</span>
    <span class="s1">expectedZ = hierarchy_test_data.linkage_ytdist_single_olo</span>
    <span class="s1">assert_allclose(Z</span><span class="s2">, </span><span class="s1">expectedZ</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s0"># test with the observation matrix X</span>
    <span class="s1">Z = optimal_leaf_ordering(linkage(hierarchy_test_data.X</span><span class="s2">, </span><span class="s3">'ward'</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">hierarchy_test_data.X)</span>
    <span class="s1">expectedZ = hierarchy_test_data.linkage_X_ward_olo</span>
    <span class="s1">assert_allclose(Z</span><span class="s2">, </span><span class="s1">expectedZ</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-06</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_Heap():</span>
    <span class="s1">values = np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">heap = Heap(values)</span>

    <span class="s1">pair = heap.get_min()</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'key'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'value'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.5</span><span class="s1">)</span>

    <span class="s1">heap.remove_min()</span>
    <span class="s1">pair = heap.get_min()</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'key'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'value'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">heap.change_value(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">)</span>
    <span class="s1">pair = heap.get_min()</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'key'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'value'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">heap.remove_min()</span>
    <span class="s1">heap.remove_min()</span>

    <span class="s1">heap.change_value(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">pair = heap.get_min()</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'key'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'value'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>

    <span class="s1">heap.remove_min()</span>
    <span class="s1">pair = heap.get_min()</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'key'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(pair[</span><span class="s3">'value'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
</pre>
</body>
</html>