<html>
<head>
<title>merge.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
merge.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
SQL-style merge routines 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
    <span class="s1">final</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">uuid</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">hashtable </span><span class="s2">as </span><span class="s1">libhashtable</span><span class="s2">,</span>
    <span class="s1">join </span><span class="s2">as </span><span class="s1">libjoin</span><span class="s2">,</span>
    <span class="s1">lib</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.lib </span><span class="s2">import </span><span class="s1">is_range_indexer</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">AnyArrayLike</span><span class="s2">,</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">IndexLabel</span><span class="s2">,</span>
    <span class="s1">JoinHow</span><span class="s2">,</span>
    <span class="s1">MergeHow</span><span class="s2">,</span>
    <span class="s1">Shape</span><span class="s2">,</span>
    <span class="s1">Suffixes</span><span class="s2">,</span>
    <span class="s1">npt</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">MergeError</span>
<span class="s2">from </span><span class="s1">pandas.util._decorators </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Appender</span><span class="s2">,</span>
    <span class="s1">Substitution</span><span class="s2">,</span>
    <span class="s1">cache_readonly</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.base </span><span class="s2">import </span><span class="s1">ExtensionDtype</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">find_common_type</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_int64</span><span class="s2">,</span>
    <span class="s1">ensure_object</span><span class="s2">,</span>
    <span class="s1">is_bool</span><span class="s2">,</span>
    <span class="s1">is_bool_dtype</span><span class="s2">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s2">,</span>
    <span class="s1">is_float_dtype</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_number</span><span class="s2">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s2">,</span>
    <span class="s1">is_object_dtype</span><span class="s2">,</span>
    <span class="s1">is_string_dtype</span><span class="s2">,</span>
    <span class="s1">needs_i8_conversion</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CategoricalDtype</span><span class="s2">,</span>
    <span class="s1">DatetimeTZDtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">na_value_for_dtype</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrowDtype</span><span class="s2">,</span>
    <span class="s1">Categorical</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">MultiIndex</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas.core.algorithms </span><span class="s2">as </span><span class="s1">algos</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrowExtensionArray</span><span class="s2">,</span>
    <span class="s1">BaseMaskedArray</span><span class="s2">,</span>
    <span class="s1">ExtensionArray</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays._mixins </span><span class="s2">import </span><span class="s1">NDArrayBackedExtensionArray</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s2">import </span><span class="s1">StringDtype</span>
<span class="s2">import </span><span class="s1">pandas.core.common </span><span class="s2">as </span><span class="s1">com</span>
<span class="s2">from </span><span class="s1">pandas.core.construction </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">,</span>
    <span class="s1">extract_array</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.frame </span><span class="s2">import </span><span class="s1">_merge_doc</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.api </span><span class="s2">import </span><span class="s1">default_index</span>
<span class="s2">from </span><span class="s1">pandas.core.sorting </span><span class="s2">import </span><span class="s1">is_int64_overflow_possible</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">DataFrame</span>
    <span class="s2">from </span><span class="s1">pandas.core </span><span class="s2">import </span><span class="s1">groupby</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">DatetimeArray</span>

<span class="s1">_factorizers = {</span>
    <span class="s1">np.int64: libhashtable.Int64Factorizer</span><span class="s2">,</span>
    <span class="s1">np.longlong: libhashtable.Int64Factorizer</span><span class="s2">,</span>
    <span class="s1">np.int32: libhashtable.Int32Factorizer</span><span class="s2">,</span>
    <span class="s1">np.int16: libhashtable.Int16Factorizer</span><span class="s2">,</span>
    <span class="s1">np.int8: libhashtable.Int8Factorizer</span><span class="s2">,</span>
    <span class="s1">np.uint64: libhashtable.UInt64Factorizer</span><span class="s2">,</span>
    <span class="s1">np.uint32: libhashtable.UInt32Factorizer</span><span class="s2">,</span>
    <span class="s1">np.uint16: libhashtable.UInt16Factorizer</span><span class="s2">,</span>
    <span class="s1">np.uint8: libhashtable.UInt8Factorizer</span><span class="s2">,</span>
    <span class="s1">np.bool_: libhashtable.UInt8Factorizer</span><span class="s2">,</span>
    <span class="s1">np.float64: libhashtable.Float64Factorizer</span><span class="s2">,</span>
    <span class="s1">np.float32: libhashtable.Float32Factorizer</span><span class="s2">,</span>
    <span class="s1">np.complex64: libhashtable.Complex64Factorizer</span><span class="s2">,</span>
    <span class="s1">np.complex128: libhashtable.Complex128Factorizer</span><span class="s2">,</span>
    <span class="s1">np.object_: libhashtable.ObjectFactorizer</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s3"># See https://github.com/pandas-dev/pandas/issues/52451</span>
<span class="s2">if </span><span class="s1">np.intc </span><span class="s2">is not </span><span class="s1">np.int32:</span>
    <span class="s1">_factorizers[np.intc] = libhashtable.Int64Factorizer</span>

<span class="s1">_known = (np.ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">ABCSeries)</span>


<span class="s1">@Substitution(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">left : DataFrame or named Series&quot;</span><span class="s1">)</span>
<span class="s1">@Appender(_merge_doc</span><span class="s2">, </span><span class="s1">indents=</span><span class="s5">0</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">merge(</span>
    <span class="s1">left: DataFrame | Series</span><span class="s2">,</span>
    <span class="s1">right: DataFrame | Series</span><span class="s2">,</span>
    <span class="s1">how: MergeHow = </span><span class="s4">&quot;inner&quot;</span><span class="s2">,</span>
    <span class="s1">on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">left_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">right_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">left_index: bool = </span><span class="s2">False,</span>
    <span class="s1">right_index: bool = </span><span class="s2">False,</span>
    <span class="s1">sort: bool = </span><span class="s2">False,</span>
    <span class="s1">suffixes: Suffixes = (</span><span class="s4">&quot;_x&quot;</span><span class="s2">, </span><span class="s4">&quot;_y&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">copy: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">indicator: str | bool = </span><span class="s2">False,</span>
    <span class="s1">validate: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s1">left_df = _validate_operand(left)</span>
    <span class="s1">right_df = _validate_operand(right)</span>
    <span class="s2">if </span><span class="s1">how == </span><span class="s4">&quot;cross&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_cross_merge(</span>
            <span class="s1">left_df</span><span class="s2">,</span>
            <span class="s1">right_df</span><span class="s2">,</span>
            <span class="s1">on=on</span><span class="s2">,</span>
            <span class="s1">left_on=left_on</span><span class="s2">,</span>
            <span class="s1">right_on=right_on</span><span class="s2">,</span>
            <span class="s1">left_index=left_index</span><span class="s2">,</span>
            <span class="s1">right_index=right_index</span><span class="s2">,</span>
            <span class="s1">sort=sort</span><span class="s2">,</span>
            <span class="s1">suffixes=suffixes</span><span class="s2">,</span>
            <span class="s1">indicator=indicator</span><span class="s2">,</span>
            <span class="s1">validate=validate</span><span class="s2">,</span>
            <span class="s1">copy=copy</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">op = _MergeOperation(</span>
            <span class="s1">left_df</span><span class="s2">,</span>
            <span class="s1">right_df</span><span class="s2">,</span>
            <span class="s1">how=how</span><span class="s2">,</span>
            <span class="s1">on=on</span><span class="s2">,</span>
            <span class="s1">left_on=left_on</span><span class="s2">,</span>
            <span class="s1">right_on=right_on</span><span class="s2">,</span>
            <span class="s1">left_index=left_index</span><span class="s2">,</span>
            <span class="s1">right_index=right_index</span><span class="s2">,</span>
            <span class="s1">sort=sort</span><span class="s2">,</span>
            <span class="s1">suffixes=suffixes</span><span class="s2">,</span>
            <span class="s1">indicator=indicator</span><span class="s2">,</span>
            <span class="s1">validate=validate</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">op.get_result(copy=copy)</span>


<span class="s2">def </span><span class="s1">_cross_merge(</span>
    <span class="s1">left: DataFrame</span><span class="s2">,</span>
    <span class="s1">right: DataFrame</span><span class="s2">,</span>
    <span class="s1">on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">left_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">right_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">left_index: bool = </span><span class="s2">False,</span>
    <span class="s1">right_index: bool = </span><span class="s2">False,</span>
    <span class="s1">sort: bool = </span><span class="s2">False,</span>
    <span class="s1">suffixes: Suffixes = (</span><span class="s4">&quot;_x&quot;</span><span class="s2">, </span><span class="s4">&quot;_y&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">copy: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">indicator: str | bool = </span><span class="s2">False,</span>
    <span class="s1">validate: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s0">&quot;&quot;&quot; 
    See merge.__doc__ with how='cross' 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">left_index</span>
        <span class="s2">or </span><span class="s1">right_index</span>
        <span class="s2">or </span><span class="s1">right_on </span><span class="s2">is not None</span>
        <span class="s2">or </span><span class="s1">left_on </span><span class="s2">is not None</span>
        <span class="s2">or </span><span class="s1">on </span><span class="s2">is not None</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">MergeError(</span>
            <span class="s4">&quot;Can not pass on, right_on, left_on or set right_index=True or &quot;</span>
            <span class="s4">&quot;left_index=True&quot;</span>
        <span class="s1">)</span>

    <span class="s1">cross_col = </span><span class="s4">f&quot;_cross_</span><span class="s2">{</span><span class="s1">uuid.uuid4()</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s1">left = left.assign(**{cross_col: </span><span class="s5">1</span><span class="s1">})</span>
    <span class="s1">right = right.assign(**{cross_col: </span><span class="s5">1</span><span class="s1">})</span>

    <span class="s1">left_on = right_on = [cross_col]</span>

    <span class="s1">res = merge(</span>
        <span class="s1">left</span><span class="s2">,</span>
        <span class="s1">right</span><span class="s2">,</span>
        <span class="s1">how=</span><span class="s4">&quot;inner&quot;</span><span class="s2">,</span>
        <span class="s1">on=on</span><span class="s2">,</span>
        <span class="s1">left_on=left_on</span><span class="s2">,</span>
        <span class="s1">right_on=right_on</span><span class="s2">,</span>
        <span class="s1">left_index=left_index</span><span class="s2">,</span>
        <span class="s1">right_index=right_index</span><span class="s2">,</span>
        <span class="s1">sort=sort</span><span class="s2">,</span>
        <span class="s1">suffixes=suffixes</span><span class="s2">,</span>
        <span class="s1">indicator=indicator</span><span class="s2">,</span>
        <span class="s1">validate=validate</span><span class="s2">,</span>
        <span class="s1">copy=copy</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">del </span><span class="s1">res[cross_col]</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">_groupby_and_merge(by</span><span class="s2">, </span><span class="s1">left: DataFrame</span><span class="s2">, </span><span class="s1">right: DataFrame</span><span class="s2">, </span><span class="s1">merge_pieces):</span>
    <span class="s0">&quot;&quot;&quot; 
    groupby &amp; merge; we are always performing a left-by type operation 
 
    Parameters 
    ---------- 
    by: field to group 
    left: DataFrame 
    right: DataFrame 
    merge_pieces: function for merging 
    &quot;&quot;&quot;</span>
    <span class="s1">pieces = []</span>
    <span class="s2">if not </span><span class="s1">isinstance(by</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">by = [by]</span>

    <span class="s1">lby = left.groupby(by</span><span class="s2">, </span><span class="s1">sort=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">rby: groupby.DataFrameGroupBy | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>

    <span class="s3"># if we can groupby the rhs</span>
    <span class="s3"># then we can get vastly better perf</span>
    <span class="s2">if </span><span class="s1">all(item </span><span class="s2">in </span><span class="s1">right.columns </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">by):</span>
        <span class="s1">rby = right.groupby(by</span><span class="s2">, </span><span class="s1">sort=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">lhs </span><span class="s2">in </span><span class="s1">lby.grouper.get_iterator(lby._selected_obj</span><span class="s2">, </span><span class="s1">axis=lby.axis):</span>
        <span class="s2">if </span><span class="s1">rby </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rhs = right</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">rhs = right.take(rby.indices[key])</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s3"># key doesn't exist in left</span>
                <span class="s1">lcols = lhs.columns.tolist()</span>
                <span class="s1">cols = lcols + [r </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">right.columns </span><span class="s2">if </span><span class="s1">r </span><span class="s2">not in </span><span class="s1">set(lcols)]</span>
                <span class="s1">merged = lhs.reindex(columns=cols)</span>
                <span class="s1">merged.index = range(len(merged))</span>
                <span class="s1">pieces.append(merged)</span>
                <span class="s2">continue</span>

        <span class="s1">merged = merge_pieces(lhs</span><span class="s2">, </span><span class="s1">rhs)</span>

        <span class="s3"># make sure join keys are in the merged</span>
        <span class="s3"># TODO, should merge_pieces do this?</span>
        <span class="s1">merged[by] = key</span>

        <span class="s1">pieces.append(merged)</span>

    <span class="s3"># preserve the original order</span>
    <span class="s3"># if we have a missing piece this can be reset</span>
    <span class="s2">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s2">import </span><span class="s1">concat</span>

    <span class="s1">result = concat(pieces</span><span class="s2">, </span><span class="s1">ignore_index=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">result = result.reindex(columns=pieces[</span><span class="s5">0</span><span class="s1">].columns</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">lby</span>


<span class="s2">def </span><span class="s1">merge_ordered(</span>
    <span class="s1">left: DataFrame</span><span class="s2">,</span>
    <span class="s1">right: DataFrame</span><span class="s2">,</span>
    <span class="s1">on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">left_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">right_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">left_by=</span><span class="s2">None,</span>
    <span class="s1">right_by=</span><span class="s2">None,</span>
    <span class="s1">fill_method: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">suffixes: Suffixes = (</span><span class="s4">&quot;_x&quot;</span><span class="s2">, </span><span class="s4">&quot;_y&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">how: JoinHow = </span><span class="s4">&quot;outer&quot;</span><span class="s2">,</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform a merge for ordered data with optional filling/interpolation. 
 
    Designed for ordered data like time series data. Optionally 
    perform group-wise merge (see examples). 
 
    Parameters 
    ---------- 
    left : DataFrame or named Series 
    right : DataFrame or named Series 
    on : label or list 
        Field names to join on. Must be found in both DataFrames. 
    left_on : label or list, or array-like 
        Field names to join on in left DataFrame. Can be a vector or list of 
        vectors of the length of the DataFrame to use a particular vector as 
        the join key instead of columns. 
    right_on : label or list, or array-like 
        Field names to join on in right DataFrame or vector/list of vectors per 
        left_on docs. 
    left_by : column name or list of column names 
        Group left DataFrame by group columns and merge piece by piece with 
        right DataFrame. Must be None if either left or right are a Series. 
    right_by : column name or list of column names 
        Group right DataFrame by group columns and merge piece by piece with 
        left DataFrame. Must be None if either left or right are a Series. 
    fill_method : {'ffill', None}, default None 
        Interpolation method for data. 
    suffixes : list-like, default is (&quot;_x&quot;, &quot;_y&quot;) 
        A length-2 sequence where each element is optionally a string 
        indicating the suffix to add to overlapping column names in 
        `left` and `right` respectively. Pass a value of `None` instead 
        of a string to indicate that the column name from `left` or 
        `right` should be left as-is, with no suffix. At least one of the 
        values must not be None. 
 
    how : {'left', 'right', 'outer', 'inner'}, default 'outer' 
        * left: use only keys from left frame (SQL: left outer join) 
        * right: use only keys from right frame (SQL: right outer join) 
        * outer: use union of keys from both frames (SQL: full outer join) 
        * inner: use intersection of keys from both frames (SQL: inner join). 
 
    Returns 
    ------- 
    DataFrame 
        The merged DataFrame output type will be the same as 
        'left', if it is a subclass of DataFrame. 
 
    See Also 
    -------- 
    merge : Merge with a database-style join. 
    merge_asof : Merge on nearest keys. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from pandas import merge_ordered 
    &gt;&gt;&gt; df1 = pd.DataFrame( 
    ...     { 
    ...         &quot;key&quot;: [&quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;a&quot;, &quot;c&quot;, &quot;e&quot;], 
    ...         &quot;lvalue&quot;: [1, 2, 3, 1, 2, 3], 
    ...         &quot;group&quot;: [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;] 
    ...     } 
    ... ) 
    &gt;&gt;&gt; df1 
      key  lvalue group 
    0   a       1     a 
    1   c       2     a 
    2   e       3     a 
    3   a       1     b 
    4   c       2     b 
    5   e       3     b 
 
    &gt;&gt;&gt; df2 = pd.DataFrame({&quot;key&quot;: [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;], &quot;rvalue&quot;: [1, 2, 3]}) 
    &gt;&gt;&gt; df2 
      key  rvalue 
    0   b       1 
    1   c       2 
    2   d       3 
 
    &gt;&gt;&gt; merge_ordered(df1, df2, fill_method=&quot;ffill&quot;, left_by=&quot;group&quot;) 
      key  lvalue group  rvalue 
    0   a       1     a     NaN 
    1   b       1     a     1.0 
    2   c       2     a     2.0 
    3   d       2     a     3.0 
    4   e       3     a     3.0 
    5   a       1     b     NaN 
    6   b       1     b     1.0 
    7   c       2     b     2.0 
    8   d       2     b     3.0 
    9   e       3     b     3.0 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_merger(x</span><span class="s2">, </span><span class="s1">y) -&gt; DataFrame:</span>
        <span class="s3"># perform the ordered merge operation</span>
        <span class="s1">op = _OrderedMerge(</span>
            <span class="s1">x</span><span class="s2">,</span>
            <span class="s1">y</span><span class="s2">,</span>
            <span class="s1">on=on</span><span class="s2">,</span>
            <span class="s1">left_on=left_on</span><span class="s2">,</span>
            <span class="s1">right_on=right_on</span><span class="s2">,</span>
            <span class="s1">suffixes=suffixes</span><span class="s2">,</span>
            <span class="s1">fill_method=fill_method</span><span class="s2">,</span>
            <span class="s1">how=how</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">op.get_result()</span>

    <span class="s2">if </span><span class="s1">left_by </span><span class="s2">is not None and </span><span class="s1">right_by </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Can only group either left or right frames&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">left_by </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(left_by</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">left_by = [left_by]</span>
        <span class="s1">check = set(left_by).difference(left.columns)</span>
        <span class="s2">if </span><span class="s1">len(check) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">KeyError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">check</span><span class="s2">} </span><span class="s4">not found in left columns&quot;</span><span class="s1">)</span>
        <span class="s1">result</span><span class="s2">, </span><span class="s1">_ = _groupby_and_merge(left_by</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: _merger(x</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s2">elif </span><span class="s1">right_by </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(right_by</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">right_by = [right_by]</span>
        <span class="s1">check = set(right_by).difference(right.columns)</span>
        <span class="s2">if </span><span class="s1">len(check) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">KeyError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">check</span><span class="s2">} </span><span class="s4">not found in right columns&quot;</span><span class="s1">)</span>
        <span class="s1">result</span><span class="s2">, </span><span class="s1">_ = _groupby_and_merge(</span>
            <span class="s1">right_by</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: _merger(y</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result = _merger(left</span><span class="s2">, </span><span class="s1">right)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">merge_asof(</span>
    <span class="s1">left: DataFrame | Series</span><span class="s2">,</span>
    <span class="s1">right: DataFrame | Series</span><span class="s2">,</span>
    <span class="s1">on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">left_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">right_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">left_index: bool = </span><span class="s2">False,</span>
    <span class="s1">right_index: bool = </span><span class="s2">False,</span>
    <span class="s1">by=</span><span class="s2">None,</span>
    <span class="s1">left_by=</span><span class="s2">None,</span>
    <span class="s1">right_by=</span><span class="s2">None,</span>
    <span class="s1">suffixes: Suffixes = (</span><span class="s4">&quot;_x&quot;</span><span class="s2">, </span><span class="s4">&quot;_y&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">tolerance: int | Timedelta | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">allow_exact_matches: bool = </span><span class="s2">True,</span>
    <span class="s1">direction: str = </span><span class="s4">&quot;backward&quot;</span><span class="s2">,</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform a merge by key distance. 
 
    This is similar to a left-join except that we match on nearest 
    key rather than equal keys. Both DataFrames must be sorted by the key. 
 
    For each row in the left DataFrame: 
 
      - A &quot;backward&quot; search selects the last row in the right DataFrame whose 
        'on' key is less than or equal to the left's key. 
 
      - A &quot;forward&quot; search selects the first row in the right DataFrame whose 
        'on' key is greater than or equal to the left's key. 
 
      - A &quot;nearest&quot; search selects the row in the right DataFrame whose 'on' 
        key is closest in absolute distance to the left's key. 
 
    Optionally match on equivalent keys with 'by' before searching with 'on'. 
 
    Parameters 
    ---------- 
    left : DataFrame or named Series 
    right : DataFrame or named Series 
    on : label 
        Field name to join on. Must be found in both DataFrames. 
        The data MUST be ordered. Furthermore this must be a numeric column, 
        such as datetimelike, integer, or float. On or left_on/right_on 
        must be given. 
    left_on : label 
        Field name to join on in left DataFrame. 
    right_on : label 
        Field name to join on in right DataFrame. 
    left_index : bool 
        Use the index of the left DataFrame as the join key. 
    right_index : bool 
        Use the index of the right DataFrame as the join key. 
    by : column name or list of column names 
        Match on these columns before performing merge operation. 
    left_by : column name 
        Field names to match on in the left DataFrame. 
    right_by : column name 
        Field names to match on in the right DataFrame. 
    suffixes : 2-length sequence (tuple, list, ...) 
        Suffix to apply to overlapping column names in the left and right 
        side, respectively. 
    tolerance : int or Timedelta, optional, default None 
        Select asof tolerance within this range; must be compatible 
        with the merge index. 
    allow_exact_matches : bool, default True 
 
        - If True, allow matching with the same 'on' value 
          (i.e. less-than-or-equal-to / greater-than-or-equal-to) 
        - If False, don't match the same 'on' value 
          (i.e., strictly less-than / strictly greater-than). 
 
    direction : 'backward' (default), 'forward', or 'nearest' 
        Whether to search for prior, subsequent, or closest matches. 
 
    Returns 
    ------- 
    DataFrame 
 
    See Also 
    -------- 
    merge : Merge with a database-style join. 
    merge_ordered : Merge with optional filling/interpolation. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; left = pd.DataFrame({&quot;a&quot;: [1, 5, 10], &quot;left_val&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}) 
    &gt;&gt;&gt; left 
        a left_val 
    0   1        a 
    1   5        b 
    2  10        c 
 
    &gt;&gt;&gt; right = pd.DataFrame({&quot;a&quot;: [1, 2, 3, 6, 7], &quot;right_val&quot;: [1, 2, 3, 6, 7]}) 
    &gt;&gt;&gt; right 
       a  right_val 
    0  1          1 
    1  2          2 
    2  3          3 
    3  6          6 
    4  7          7 
 
    &gt;&gt;&gt; pd.merge_asof(left, right, on=&quot;a&quot;) 
        a left_val  right_val 
    0   1        a          1 
    1   5        b          3 
    2  10        c          7 
 
    &gt;&gt;&gt; pd.merge_asof(left, right, on=&quot;a&quot;, allow_exact_matches=False) 
        a left_val  right_val 
    0   1        a        NaN 
    1   5        b        3.0 
    2  10        c        7.0 
 
    &gt;&gt;&gt; pd.merge_asof(left, right, on=&quot;a&quot;, direction=&quot;forward&quot;) 
        a left_val  right_val 
    0   1        a        1.0 
    1   5        b        6.0 
    2  10        c        NaN 
 
    &gt;&gt;&gt; pd.merge_asof(left, right, on=&quot;a&quot;, direction=&quot;nearest&quot;) 
        a left_val  right_val 
    0   1        a          1 
    1   5        b          6 
    2  10        c          7 
 
    We can use indexed DataFrames as well. 
 
    &gt;&gt;&gt; left = pd.DataFrame({&quot;left_val&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}, index=[1, 5, 10]) 
    &gt;&gt;&gt; left 
       left_val 
    1         a 
    5         b 
    10        c 
 
    &gt;&gt;&gt; right = pd.DataFrame({&quot;right_val&quot;: [1, 2, 3, 6, 7]}, index=[1, 2, 3, 6, 7]) 
    &gt;&gt;&gt; right 
       right_val 
    1          1 
    2          2 
    3          3 
    6          6 
    7          7 
 
    &gt;&gt;&gt; pd.merge_asof(left, right, left_index=True, right_index=True) 
       left_val  right_val 
    1         a          1 
    5         b          3 
    10        c          7 
 
    Here is a real-world times-series example 
 
    &gt;&gt;&gt; quotes = pd.DataFrame( 
    ...     { 
    ...         &quot;time&quot;: [ 
    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.023&quot;), 
    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.023&quot;), 
    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.030&quot;), 
    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.041&quot;), 
    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.048&quot;), 
    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.049&quot;), 
    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.072&quot;), 
    ...             pd.Timestamp(&quot;2016-05-25 13:30:00.075&quot;) 
    ...         ], 
    ...         &quot;ticker&quot;: [ 
    ...                &quot;GOOG&quot;, 
    ...                &quot;MSFT&quot;, 
    ...                &quot;MSFT&quot;, 
    ...                &quot;MSFT&quot;, 
    ...                &quot;GOOG&quot;, 
    ...                &quot;AAPL&quot;, 
    ...                &quot;GOOG&quot;, 
    ...                &quot;MSFT&quot; 
    ...            ], 
    ...            &quot;bid&quot;: [720.50, 51.95, 51.97, 51.99, 720.50, 97.99, 720.50, 52.01], 
    ...            &quot;ask&quot;: [720.93, 51.96, 51.98, 52.00, 720.93, 98.01, 720.88, 52.03] 
    ...     } 
    ... ) 
    &gt;&gt;&gt; quotes 
                         time ticker     bid     ask 
    0 2016-05-25 13:30:00.023   GOOG  720.50  720.93 
    1 2016-05-25 13:30:00.023   MSFT   51.95   51.96 
    2 2016-05-25 13:30:00.030   MSFT   51.97   51.98 
    3 2016-05-25 13:30:00.041   MSFT   51.99   52.00 
    4 2016-05-25 13:30:00.048   GOOG  720.50  720.93 
    5 2016-05-25 13:30:00.049   AAPL   97.99   98.01 
    6 2016-05-25 13:30:00.072   GOOG  720.50  720.88 
    7 2016-05-25 13:30:00.075   MSFT   52.01   52.03 
 
    &gt;&gt;&gt; trades = pd.DataFrame( 
    ...        { 
    ...            &quot;time&quot;: [ 
    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.023&quot;), 
    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.038&quot;), 
    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.048&quot;), 
    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.048&quot;), 
    ...                pd.Timestamp(&quot;2016-05-25 13:30:00.048&quot;) 
    ...            ], 
    ...            &quot;ticker&quot;: [&quot;MSFT&quot;, &quot;MSFT&quot;, &quot;GOOG&quot;, &quot;GOOG&quot;, &quot;AAPL&quot;], 
    ...            &quot;price&quot;: [51.95, 51.95, 720.77, 720.92, 98.0], 
    ...            &quot;quantity&quot;: [75, 155, 100, 100, 100] 
    ...        } 
    ...    ) 
    &gt;&gt;&gt; trades 
                         time ticker   price  quantity 
    0 2016-05-25 13:30:00.023   MSFT   51.95        75 
    1 2016-05-25 13:30:00.038   MSFT   51.95       155 
    2 2016-05-25 13:30:00.048   GOOG  720.77       100 
    3 2016-05-25 13:30:00.048   GOOG  720.92       100 
    4 2016-05-25 13:30:00.048   AAPL   98.00       100 
 
    By default we are taking the asof of the quotes 
 
    &gt;&gt;&gt; pd.merge_asof(trades, quotes, on=&quot;time&quot;, by=&quot;ticker&quot;) 
                         time ticker   price  quantity     bid     ask 
    0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96 
    1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98 
    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93 
    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93 
    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN 
 
    We only asof within 2ms between the quote time and the trade time 
 
    &gt;&gt;&gt; pd.merge_asof( 
    ...     trades, quotes, on=&quot;time&quot;, by=&quot;ticker&quot;, tolerance=pd.Timedelta(&quot;2ms&quot;) 
    ... ) 
                         time ticker   price  quantity     bid     ask 
    0 2016-05-25 13:30:00.023   MSFT   51.95        75   51.95   51.96 
    1 2016-05-25 13:30:00.038   MSFT   51.95       155     NaN     NaN 
    2 2016-05-25 13:30:00.048   GOOG  720.77       100  720.50  720.93 
    3 2016-05-25 13:30:00.048   GOOG  720.92       100  720.50  720.93 
    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN 
 
    We only asof within 10ms between the quote time and the trade time 
    and we exclude exact matches on time. However *prior* data will 
    propagate forward 
 
    &gt;&gt;&gt; pd.merge_asof( 
    ...     trades, 
    ...     quotes, 
    ...     on=&quot;time&quot;, 
    ...     by=&quot;ticker&quot;, 
    ...     tolerance=pd.Timedelta(&quot;10ms&quot;), 
    ...     allow_exact_matches=False 
    ... ) 
                         time ticker   price  quantity     bid     ask 
    0 2016-05-25 13:30:00.023   MSFT   51.95        75     NaN     NaN 
    1 2016-05-25 13:30:00.038   MSFT   51.95       155   51.97   51.98 
    2 2016-05-25 13:30:00.048   GOOG  720.77       100     NaN     NaN 
    3 2016-05-25 13:30:00.048   GOOG  720.92       100     NaN     NaN 
    4 2016-05-25 13:30:00.048   AAPL   98.00       100     NaN     NaN 
    &quot;&quot;&quot;</span>
    <span class="s1">op = _AsOfMerge(</span>
        <span class="s1">left</span><span class="s2">,</span>
        <span class="s1">right</span><span class="s2">,</span>
        <span class="s1">on=on</span><span class="s2">,</span>
        <span class="s1">left_on=left_on</span><span class="s2">,</span>
        <span class="s1">right_on=right_on</span><span class="s2">,</span>
        <span class="s1">left_index=left_index</span><span class="s2">,</span>
        <span class="s1">right_index=right_index</span><span class="s2">,</span>
        <span class="s1">by=by</span><span class="s2">,</span>
        <span class="s1">left_by=left_by</span><span class="s2">,</span>
        <span class="s1">right_by=right_by</span><span class="s2">,</span>
        <span class="s1">suffixes=suffixes</span><span class="s2">,</span>
        <span class="s1">how=</span><span class="s4">&quot;asof&quot;</span><span class="s2">,</span>
        <span class="s1">tolerance=tolerance</span><span class="s2">,</span>
        <span class="s1">allow_exact_matches=allow_exact_matches</span><span class="s2">,</span>
        <span class="s1">direction=direction</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">op.get_result()</span>


<span class="s3"># TODO: transformations??</span>
<span class="s3"># TODO: only copy DataFrames when modification necessary</span>
<span class="s2">class </span><span class="s1">_MergeOperation:</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform a database (SQL) merge operation between two DataFrame or Series 
    objects using either columns as keys or their row indexes 
    &quot;&quot;&quot;</span>

    <span class="s1">_merge_type = </span><span class="s4">&quot;merge&quot;</span>
    <span class="s1">how: MergeHow | Literal[</span><span class="s4">&quot;asof&quot;</span><span class="s1">]</span>
    <span class="s1">on: IndexLabel | </span><span class="s2">None</span>
    <span class="s3"># left_on/right_on may be None when passed, but in validate_specification</span>
    <span class="s3">#  get replaced with non-None.</span>
    <span class="s1">left_on: Sequence[Hashable | AnyArrayLike]</span>
    <span class="s1">right_on: Sequence[Hashable | AnyArrayLike]</span>
    <span class="s1">left_index: bool</span>
    <span class="s1">right_index: bool</span>
    <span class="s1">sort: bool</span>
    <span class="s1">suffixes: Suffixes</span>
    <span class="s1">copy: bool</span>
    <span class="s1">indicator: str | bool</span>
    <span class="s1">validate: str | </span><span class="s2">None</span>
    <span class="s1">join_names: list[Hashable]</span>
    <span class="s1">right_join_keys: list[ArrayLike]</span>
    <span class="s1">left_join_keys: list[ArrayLike]</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">left: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">right: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">how: MergeHow | Literal[</span><span class="s4">&quot;asof&quot;</span><span class="s1">] = </span><span class="s4">&quot;inner&quot;</span><span class="s2">,</span>
        <span class="s1">on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">left_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">right_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">left_index: bool = </span><span class="s2">False,</span>
        <span class="s1">right_index: bool = </span><span class="s2">False,</span>
        <span class="s1">sort: bool = </span><span class="s2">True,</span>
        <span class="s1">suffixes: Suffixes = (</span><span class="s4">&quot;_x&quot;</span><span class="s2">, </span><span class="s4">&quot;_y&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">indicator: str | bool = </span><span class="s2">False,</span>
        <span class="s1">validate: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">_left = _validate_operand(left)</span>
        <span class="s1">_right = _validate_operand(right)</span>
        <span class="s1">self.left = self.orig_left = _left</span>
        <span class="s1">self.right = self.orig_right = _right</span>
        <span class="s1">self.how = how</span>

        <span class="s1">self.on = com.maybe_make_list(on)</span>

        <span class="s1">self.suffixes = suffixes</span>
        <span class="s1">self.sort = sort</span>

        <span class="s1">self.left_index = left_index</span>
        <span class="s1">self.right_index = right_index</span>

        <span class="s1">self.indicator = indicator</span>

        <span class="s2">if not </span><span class="s1">is_bool(left_index):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;left_index parameter must be of type bool, not </span><span class="s2">{</span><span class="s1">type(left_index)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">is_bool(right_index):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;right_index parameter must be of type bool, not </span><span class="s2">{</span><span class="s1">type(right_index)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

        <span class="s3"># GH 40993: raise when merging between different levels; enforced in 2.0</span>
        <span class="s2">if </span><span class="s1">_left.columns.nlevels != _right.columns.nlevels:</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;Not allowed to merge between different levels. &quot;</span>
                <span class="s4">f&quot;(</span><span class="s2">{</span><span class="s1">_left.columns.nlevels</span><span class="s2">} </span><span class="s4">levels on the left, &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">_right.columns.nlevels</span><span class="s2">} </span><span class="s4">on the right)&quot;</span>
            <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">MergeError(msg)</span>

        <span class="s1">self.left_on</span><span class="s2">, </span><span class="s1">self.right_on = self._validate_left_right_on(left_on</span><span class="s2">, </span><span class="s1">right_on)</span>

        <span class="s1">(</span>
            <span class="s1">self.left_join_keys</span><span class="s2">,</span>
            <span class="s1">self.right_join_keys</span><span class="s2">,</span>
            <span class="s1">self.join_names</span><span class="s2">,</span>
            <span class="s1">left_drop</span><span class="s2">,</span>
            <span class="s1">right_drop</span><span class="s2">,</span>
        <span class="s1">) = self._get_merge_keys()</span>

        <span class="s2">if </span><span class="s1">left_drop:</span>
            <span class="s1">self.left = self.left._drop_labels_or_levels(left_drop)</span>

        <span class="s2">if </span><span class="s1">right_drop:</span>
            <span class="s1">self.right = self.right._drop_labels_or_levels(right_drop)</span>

        <span class="s1">self._maybe_require_matching_dtypes(self.left_join_keys</span><span class="s2">, </span><span class="s1">self.right_join_keys)</span>
        <span class="s1">self._validate_tolerance(self.left_join_keys)</span>

        <span class="s3"># validate the merge keys dtypes. We may need to coerce</span>
        <span class="s3"># to avoid incompatible dtypes</span>
        <span class="s1">self._maybe_coerce_merge_keys()</span>

        <span class="s3"># If argument passed to validate,</span>
        <span class="s3"># check if columns specified as unique</span>
        <span class="s3"># are in fact unique.</span>
        <span class="s2">if </span><span class="s1">validate </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._validate_validate_kwd(validate)</span>

    <span class="s2">def </span><span class="s1">_maybe_require_matching_dtypes(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">left_join_keys: list[ArrayLike]</span><span class="s2">, </span><span class="s1">right_join_keys: list[ArrayLike]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># Overridden by AsOfMerge</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_validate_tolerance(self</span><span class="s2">, </span><span class="s1">left_join_keys: list[ArrayLike]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># Overridden by AsOfMerge</span>
        <span class="s2">pass</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_reindex_and_concat(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">join_index: Index</span><span class="s2">,</span>
        <span class="s1">left_indexer: npt.NDArray[np.intp] | </span><span class="s2">None,</span>
        <span class="s1">right_indexer: npt.NDArray[np.intp] | </span><span class="s2">None,</span>
        <span class="s1">copy: bool | </span><span class="s2">None,</span>
    <span class="s1">) -&gt; DataFrame:</span>
        <span class="s0">&quot;&quot;&quot; 
        reindex along index and concat along columns. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Take views so we do not alter the originals</span>
        <span class="s1">left = self.left[:]</span>
        <span class="s1">right = self.right[:]</span>

        <span class="s1">llabels</span><span class="s2">, </span><span class="s1">rlabels = _items_overlap_with_suffix(</span>
            <span class="s1">self.left._info_axis</span><span class="s2">, </span><span class="s1">self.right._info_axis</span><span class="s2">, </span><span class="s1">self.suffixes</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">left_indexer </span><span class="s2">is not None and not </span><span class="s1">is_range_indexer(left_indexer</span><span class="s2">, </span><span class="s1">len(left)):</span>
            <span class="s3"># Pinning the index here (and in the right code just below) is not</span>
            <span class="s3">#  necessary, but makes the `.take` more performant if we have e.g.</span>
            <span class="s3">#  a MultiIndex for left.index.</span>
            <span class="s1">lmgr = left._mgr.reindex_indexer(</span>
                <span class="s1">join_index</span><span class="s2">,</span>
                <span class="s1">left_indexer</span><span class="s2">,</span>
                <span class="s1">axis=</span><span class="s5">1</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">False,</span>
                <span class="s1">only_slice=</span><span class="s2">True,</span>
                <span class="s1">allow_dups=</span><span class="s2">True,</span>
                <span class="s1">use_na_proxy=</span><span class="s2">True,</span>
            <span class="s1">)</span>
            <span class="s1">left = left._constructor_from_mgr(lmgr</span><span class="s2">, </span><span class="s1">axes=lmgr.axes)</span>
        <span class="s1">left.index = join_index</span>

        <span class="s2">if </span><span class="s1">right_indexer </span><span class="s2">is not None and not </span><span class="s1">is_range_indexer(</span>
            <span class="s1">right_indexer</span><span class="s2">, </span><span class="s1">len(right)</span>
        <span class="s1">):</span>
            <span class="s1">rmgr = right._mgr.reindex_indexer(</span>
                <span class="s1">join_index</span><span class="s2">,</span>
                <span class="s1">right_indexer</span><span class="s2">,</span>
                <span class="s1">axis=</span><span class="s5">1</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">False,</span>
                <span class="s1">only_slice=</span><span class="s2">True,</span>
                <span class="s1">allow_dups=</span><span class="s2">True,</span>
                <span class="s1">use_na_proxy=</span><span class="s2">True,</span>
            <span class="s1">)</span>
            <span class="s1">right = right._constructor_from_mgr(rmgr</span><span class="s2">, </span><span class="s1">axes=rmgr.axes)</span>
        <span class="s1">right.index = join_index</span>

        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">concat</span>

        <span class="s1">left.columns = llabels</span>
        <span class="s1">right.columns = rlabels</span>
        <span class="s1">result = concat([left</span><span class="s2">, </span><span class="s1">right]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">copy=copy)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">get_result(self</span><span class="s2">, </span><span class="s1">copy: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">True</span><span class="s1">) -&gt; DataFrame:</span>
        <span class="s2">if </span><span class="s1">self.indicator:</span>
            <span class="s1">self.left</span><span class="s2">, </span><span class="s1">self.right = self._indicator_pre_merge(self.left</span><span class="s2">, </span><span class="s1">self.right)</span>

        <span class="s1">join_index</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer = self._get_join_info()</span>

        <span class="s1">result = self._reindex_and_concat(</span>
            <span class="s1">join_index</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer</span><span class="s2">, </span><span class="s1">copy=copy</span>
        <span class="s1">)</span>
        <span class="s1">result = result.__finalize__(self</span><span class="s2">, </span><span class="s1">method=self._merge_type)</span>

        <span class="s2">if </span><span class="s1">self.indicator:</span>
            <span class="s1">result = self._indicator_post_merge(result)</span>

        <span class="s1">self._maybe_add_join_keys(result</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer)</span>

        <span class="s1">self._maybe_restore_index_levels(result)</span>

        <span class="s2">return </span><span class="s1">result.__finalize__(self</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">&quot;merge&quot;</span><span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_indicator_name(self) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(self.indicator</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">self.indicator</span>
        <span class="s2">elif </span><span class="s1">isinstance(self.indicator</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s2">return </span><span class="s4">&quot;_merge&quot; </span><span class="s2">if </span><span class="s1">self.indicator </span><span class="s2">else None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;indicator option can only accept boolean or string arguments&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_indicator_pre_merge(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">left: DataFrame</span><span class="s2">, </span><span class="s1">right: DataFrame</span>
    <span class="s1">) -&gt; tuple[DataFrame</span><span class="s2">, </span><span class="s1">DataFrame]:</span>
        <span class="s1">columns = left.columns.union(right.columns)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;_left_indicator&quot;</span><span class="s2">, </span><span class="s4">&quot;_right_indicator&quot;</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">columns:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Cannot use `indicator=True` option when &quot;</span>
                    <span class="s4">f&quot;data contains a column named </span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._indicator_name </span><span class="s2">in </span><span class="s1">columns:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Cannot use name of an existing column for indicator column&quot;</span>
            <span class="s1">)</span>

        <span class="s1">left = left.copy()</span>
        <span class="s1">right = right.copy()</span>

        <span class="s1">left[</span><span class="s4">&quot;_left_indicator&quot;</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">left[</span><span class="s4">&quot;_left_indicator&quot;</span><span class="s1">] = left[</span><span class="s4">&quot;_left_indicator&quot;</span><span class="s1">].astype(</span><span class="s4">&quot;int8&quot;</span><span class="s1">)</span>

        <span class="s1">right[</span><span class="s4">&quot;_right_indicator&quot;</span><span class="s1">] = </span><span class="s5">2</span>
        <span class="s1">right[</span><span class="s4">&quot;_right_indicator&quot;</span><span class="s1">] = right[</span><span class="s4">&quot;_right_indicator&quot;</span><span class="s1">].astype(</span><span class="s4">&quot;int8&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_indicator_post_merge(self</span><span class="s2">, </span><span class="s1">result: DataFrame) -&gt; DataFrame:</span>
        <span class="s1">result[</span><span class="s4">&quot;_left_indicator&quot;</span><span class="s1">] = result[</span><span class="s4">&quot;_left_indicator&quot;</span><span class="s1">].fillna(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">result[</span><span class="s4">&quot;_right_indicator&quot;</span><span class="s1">] = result[</span><span class="s4">&quot;_right_indicator&quot;</span><span class="s1">].fillna(</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">result[self._indicator_name] = Categorical(</span>
            <span class="s1">(result[</span><span class="s4">&quot;_left_indicator&quot;</span><span class="s1">] + result[</span><span class="s4">&quot;_right_indicator&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">categories=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">result[self._indicator_name] = result[</span>
            <span class="s1">self._indicator_name</span>
        <span class="s1">].cat.rename_categories([</span><span class="s4">&quot;left_only&quot;</span><span class="s2">, </span><span class="s4">&quot;right_only&quot;</span><span class="s2">, </span><span class="s4">&quot;both&quot;</span><span class="s1">])</span>

        <span class="s1">result = result.drop(labels=[</span><span class="s4">&quot;_left_indicator&quot;</span><span class="s2">, </span><span class="s4">&quot;_right_indicator&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_maybe_restore_index_levels(self</span><span class="s2">, </span><span class="s1">result: DataFrame) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Restore index levels specified as `on` parameters 
 
        Here we check for cases where `self.left_on` and `self.right_on` pairs 
        each reference an index level in their respective DataFrames. The 
        joined columns corresponding to these pairs are then restored to the 
        index of `result`. 
 
        **Note:** This method has side effects. It modifies `result` in-place 
 
        Parameters 
        ---------- 
        result: DataFrame 
            merge result 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s1">names_to_restore = []</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">left_key</span><span class="s2">, </span><span class="s1">right_key </span><span class="s2">in </span><span class="s1">zip(</span>
            <span class="s1">self.join_names</span><span class="s2">, </span><span class="s1">self.left_on</span><span class="s2">, </span><span class="s1">self.right_on</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s3"># Argument 1 to &quot;_is_level_reference&quot; of &quot;NDFrame&quot; has incompatible</span>
                <span class="s3"># type &quot;Union[Hashable, ExtensionArray, Index, Series]&quot;; expected</span>
                <span class="s3"># &quot;Hashable&quot;</span>
                <span class="s1">self.orig_left._is_level_reference(left_key)  </span><span class="s3"># type: ignore[arg-type]</span>
                <span class="s3"># Argument 1 to &quot;_is_level_reference&quot; of &quot;NDFrame&quot; has incompatible</span>
                <span class="s3"># type &quot;Union[Hashable, ExtensionArray, Index, Series]&quot;; expected</span>
                <span class="s3"># &quot;Hashable&quot;</span>
                <span class="s2">and </span><span class="s1">self.orig_right._is_level_reference(</span>
                    <span class="s1">right_key  </span><span class="s3"># type: ignore[arg-type]</span>
                <span class="s1">)</span>
                <span class="s2">and </span><span class="s1">left_key == right_key</span>
                <span class="s2">and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">result.index.names</span>
            <span class="s1">):</span>
                <span class="s1">names_to_restore.append(name)</span>

        <span class="s2">if </span><span class="s1">names_to_restore:</span>
            <span class="s1">result.set_index(names_to_restore</span><span class="s2">, </span><span class="s1">inplace=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_maybe_add_join_keys(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">result: DataFrame</span><span class="s2">,</span>
        <span class="s1">left_indexer: npt.NDArray[np.intp] | </span><span class="s2">None,</span>
        <span class="s1">right_indexer: npt.NDArray[np.intp] | </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">left_has_missing = </span><span class="s2">None</span>
        <span class="s1">right_has_missing = </span><span class="s2">None</span>

        <span class="s2">assert </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">_known) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.left_join_keys)</span>

        <span class="s1">keys = zip(self.join_names</span><span class="s2">, </span><span class="s1">self.left_on</span><span class="s2">, </span><span class="s1">self.right_on)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(name</span><span class="s2">, </span><span class="s1">lname</span><span class="s2">, </span><span class="s1">rname) </span><span class="s2">in </span><span class="s1">enumerate(keys):</span>
            <span class="s2">if not </span><span class="s1">_should_fill(lname</span><span class="s2">, </span><span class="s1">rname):</span>
                <span class="s2">continue</span>

            <span class="s1">take_left</span><span class="s2">, </span><span class="s1">take_right = </span><span class="s2">None, None</span>

            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">result:</span>
                <span class="s2">if </span><span class="s1">left_indexer </span><span class="s2">is not None and </span><span class="s1">right_indexer </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.left:</span>
                        <span class="s2">if </span><span class="s1">left_has_missing </span><span class="s2">is None</span><span class="s1">:</span>
                            <span class="s1">left_has_missing = (left_indexer == -</span><span class="s5">1</span><span class="s1">).any()</span>

                        <span class="s2">if </span><span class="s1">left_has_missing:</span>
                            <span class="s1">take_right = self.right_join_keys[i]</span>

                            <span class="s2">if </span><span class="s1">result[name].dtype != self.left[name].dtype:</span>
                                <span class="s1">take_left = self.left[name]._values</span>

                    <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.right:</span>
                        <span class="s2">if </span><span class="s1">right_has_missing </span><span class="s2">is None</span><span class="s1">:</span>
                            <span class="s1">right_has_missing = (right_indexer == -</span><span class="s5">1</span><span class="s1">).any()</span>

                        <span class="s2">if </span><span class="s1">right_has_missing:</span>
                            <span class="s1">take_left = self.left_join_keys[i]</span>

                            <span class="s2">if </span><span class="s1">result[name].dtype != self.right[name].dtype:</span>
                                <span class="s1">take_right = self.right[name]._values</span>

            <span class="s2">elif </span><span class="s1">left_indexer </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">take_left = self.left_join_keys[i]</span>
                <span class="s1">take_right = self.right_join_keys[i]</span>

            <span class="s2">if </span><span class="s1">take_left </span><span class="s2">is not None or </span><span class="s1">take_right </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">take_left </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">lvals = result[name]._values</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># TODO: can we pin down take_left's type earlier?</span>
                    <span class="s1">take_left = extract_array(take_left</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s1">lfill = na_value_for_dtype(take_left.dtype)</span>
                    <span class="s1">lvals = algos.take_nd(take_left</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">fill_value=lfill)</span>

                <span class="s2">if </span><span class="s1">take_right </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">rvals = result[name]._values</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># TODO: can we pin down take_right's type earlier?</span>
                    <span class="s1">taker = extract_array(take_right</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s1">rfill = na_value_for_dtype(taker.dtype)</span>
                    <span class="s1">rvals = algos.take_nd(taker</span><span class="s2">, </span><span class="s1">right_indexer</span><span class="s2">, </span><span class="s1">fill_value=rfill)</span>

                <span class="s3"># if we have an all missing left_indexer</span>
                <span class="s3"># make sure to just use the right values or vice-versa</span>
                <span class="s1">mask_left = left_indexer == -</span><span class="s5">1</span>
                <span class="s3"># error: Item &quot;bool&quot; of &quot;Union[Any, bool]&quot; has no attribute &quot;all&quot;</span>
                <span class="s2">if </span><span class="s1">mask_left.all():  </span><span class="s3"># type: ignore[union-attr]</span>
                    <span class="s1">key_col = Index(rvals)</span>
                    <span class="s1">result_dtype = rvals.dtype</span>
                <span class="s2">elif </span><span class="s1">right_indexer </span><span class="s2">is not None and </span><span class="s1">(right_indexer == -</span><span class="s5">1</span><span class="s1">).all():</span>
                    <span class="s1">key_col = Index(lvals)</span>
                    <span class="s1">result_dtype = lvals.dtype</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">key_col = Index(lvals).where(~mask_left</span><span class="s2">, </span><span class="s1">rvals)</span>
                    <span class="s1">result_dtype = find_common_type([lvals.dtype</span><span class="s2">, </span><span class="s1">rvals.dtype])</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">lvals.dtype.kind == </span><span class="s4">&quot;M&quot;</span>
                        <span class="s2">and </span><span class="s1">rvals.dtype.kind == </span><span class="s4">&quot;M&quot;</span>
                        <span class="s2">and </span><span class="s1">result_dtype.kind == </span><span class="s4">&quot;O&quot;</span>
                    <span class="s1">):</span>
                        <span class="s3"># TODO(non-nano) Workaround for common_type not dealing</span>
                        <span class="s3"># with different resolutions</span>
                        <span class="s1">result_dtype = key_col.dtype</span>

                <span class="s2">if </span><span class="s1">result._is_label_reference(name):</span>
                    <span class="s1">result[name] = result._constructor_sliced(</span>
                        <span class="s1">key_col</span><span class="s2">, </span><span class="s1">dtype=result_dtype</span><span class="s2">, </span><span class="s1">index=result.index</span>
                    <span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">result._is_level_reference(name):</span>
                    <span class="s2">if </span><span class="s1">isinstance(result.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
                        <span class="s1">key_col.name = name</span>
                        <span class="s1">idx_list = [</span>
                            <span class="s1">result.index.get_level_values(level_name)</span>
                            <span class="s2">if </span><span class="s1">level_name != name</span>
                            <span class="s2">else </span><span class="s1">key_col</span>
                            <span class="s2">for </span><span class="s1">level_name </span><span class="s2">in </span><span class="s1">result.index.names</span>
                        <span class="s1">]</span>

                        <span class="s1">result.set_index(idx_list</span><span class="s2">, </span><span class="s1">inplace=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">result.index = Index(key_col</span><span class="s2">, </span><span class="s1">name=name)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">result.insert(i</span><span class="s2">, </span><span class="s1">name </span><span class="s2">or </span><span class="s4">f&quot;key_</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s1">key_col)</span>

    <span class="s2">def </span><span class="s1">_get_join_indexers(self) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
        <span class="s0">&quot;&quot;&quot;return the join indexers&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">get_join_indexers(</span>
            <span class="s1">self.left_join_keys</span><span class="s2">, </span><span class="s1">self.right_join_keys</span><span class="s2">, </span><span class="s1">sort=self.sort</span><span class="s2">, </span><span class="s1">how=self.how</span>
        <span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_get_join_info(</span>
        <span class="s1">self</span><span class="s2">,</span>
    <span class="s1">) -&gt; tuple[Index</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp] | </span><span class="s2">None, </span><span class="s1">npt.NDArray[np.intp] | </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s3"># make mypy happy</span>
        <span class="s2">assert </span><span class="s1">self.how != </span><span class="s4">&quot;cross&quot;</span>
        <span class="s1">left_ax = self.left.index</span>
        <span class="s1">right_ax = self.right.index</span>

        <span class="s2">if </span><span class="s1">self.left_index </span><span class="s2">and </span><span class="s1">self.right_index </span><span class="s2">and </span><span class="s1">self.how != </span><span class="s4">&quot;asof&quot;</span><span class="s1">:</span>
            <span class="s1">join_index</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer = left_ax.join(</span>
                <span class="s1">right_ax</span><span class="s2">, </span><span class="s1">how=self.how</span><span class="s2">, </span><span class="s1">return_indexers=</span><span class="s2">True, </span><span class="s1">sort=self.sort</span>
            <span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">self.right_index </span><span class="s2">and </span><span class="s1">self.how == </span><span class="s4">&quot;left&quot;</span><span class="s1">:</span>
            <span class="s1">join_index</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer = _left_join_on_index(</span>
                <span class="s1">left_ax</span><span class="s2">, </span><span class="s1">right_ax</span><span class="s2">, </span><span class="s1">self.left_join_keys</span><span class="s2">, </span><span class="s1">sort=self.sort</span>
            <span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">self.left_index </span><span class="s2">and </span><span class="s1">self.how == </span><span class="s4">&quot;right&quot;</span><span class="s1">:</span>
            <span class="s1">join_index</span><span class="s2">, </span><span class="s1">right_indexer</span><span class="s2">, </span><span class="s1">left_indexer = _left_join_on_index(</span>
                <span class="s1">right_ax</span><span class="s2">, </span><span class="s1">left_ax</span><span class="s2">, </span><span class="s1">self.right_join_keys</span><span class="s2">, </span><span class="s1">sort=self.sort</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">(left_indexer</span><span class="s2">, </span><span class="s1">right_indexer) = self._get_join_indexers()</span>

            <span class="s2">if </span><span class="s1">self.right_index:</span>
                <span class="s2">if </span><span class="s1">len(self.left) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">join_index = self._create_join_index(</span>
                        <span class="s1">left_ax</span><span class="s2">,</span>
                        <span class="s1">right_ax</span><span class="s2">,</span>
                        <span class="s1">left_indexer</span><span class="s2">,</span>
                        <span class="s1">how=</span><span class="s4">&quot;right&quot;</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">join_index = right_ax.take(right_indexer)</span>
            <span class="s2">elif </span><span class="s1">self.left_index:</span>
                <span class="s2">if </span><span class="s1">self.how == </span><span class="s4">&quot;asof&quot;</span><span class="s1">:</span>
                    <span class="s3"># GH#33463 asof should always behave like a left merge</span>
                    <span class="s1">join_index = self._create_join_index(</span>
                        <span class="s1">left_ax</span><span class="s2">,</span>
                        <span class="s1">right_ax</span><span class="s2">,</span>
                        <span class="s1">left_indexer</span><span class="s2">,</span>
                        <span class="s1">how=</span><span class="s4">&quot;left&quot;</span><span class="s2">,</span>
                    <span class="s1">)</span>

                <span class="s2">elif </span><span class="s1">len(self.right) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">join_index = self._create_join_index(</span>
                        <span class="s1">right_ax</span><span class="s2">,</span>
                        <span class="s1">left_ax</span><span class="s2">,</span>
                        <span class="s1">right_indexer</span><span class="s2">,</span>
                        <span class="s1">how=</span><span class="s4">&quot;left&quot;</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">join_index = left_ax.take(left_indexer)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">join_index = default_index(len(left_indexer))</span>

        <span class="s2">return </span><span class="s1">join_index</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_create_join_index(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">index: Index</span><span class="s2">,</span>
        <span class="s1">other_index: Index</span><span class="s2">,</span>
        <span class="s1">indexer: npt.NDArray[np.intp]</span><span class="s2">,</span>
        <span class="s1">how: JoinHow = </span><span class="s4">&quot;left&quot;</span><span class="s2">,</span>
    <span class="s1">) -&gt; Index:</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a join index by rearranging one index to match another 
 
        Parameters 
        ---------- 
        index : Index being rearranged 
        other_index : Index used to supply values not found in index 
        indexer : np.ndarray[np.intp] how to rearrange index 
        how : str 
            Replacement is only necessary if indexer based on other_index. 
 
        Returns 
        ------- 
        Index 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.how </span><span class="s2">in </span><span class="s1">(how</span><span class="s2">, </span><span class="s4">&quot;outer&quot;</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">isinstance(other_index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s3"># if final index requires values in other_index but not target</span>
            <span class="s3"># index, indexer may hold missing (-1) values, causing Index.take</span>
            <span class="s3"># to take the final value in target index. So, we set the last</span>
            <span class="s3"># element to be the desired fill value. We do not use allow_fill</span>
            <span class="s3"># and fill_value because it throws a ValueError on integer indices</span>
            <span class="s1">mask = indexer == -</span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">np.any(mask):</span>
                <span class="s1">fill_value = na_value_for_dtype(index.dtype</span><span class="s2">, </span><span class="s1">compat=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">index = index.append(Index([fill_value]))</span>
        <span class="s2">return </span><span class="s1">index.take(indexer)</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_get_merge_keys(</span>
        <span class="s1">self</span><span class="s2">,</span>
    <span class="s1">) -&gt; tuple[</span>
        <span class="s1">list[ArrayLike]</span><span class="s2">,</span>
        <span class="s1">list[ArrayLike]</span><span class="s2">,</span>
        <span class="s1">list[Hashable]</span><span class="s2">,</span>
        <span class="s1">list[Hashable]</span><span class="s2">,</span>
        <span class="s1">list[Hashable]</span><span class="s2">,</span>
    <span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns 
        ------- 
        left_keys, right_keys, join_names, left_drop, right_drop 
        &quot;&quot;&quot;</span>
        <span class="s1">left_keys: list[ArrayLike] = []</span>
        <span class="s1">right_keys: list[ArrayLike] = []</span>
        <span class="s1">join_names: list[Hashable] = []</span>
        <span class="s1">right_drop: list[Hashable] = []</span>
        <span class="s1">left_drop: list[Hashable] = []</span>

        <span class="s1">left</span><span class="s2">, </span><span class="s1">right = self.left</span><span class="s2">, </span><span class="s1">self.right</span>

        <span class="s1">is_lkey = </span><span class="s2">lambda </span><span class="s1">x: isinstance(x</span><span class="s2">, </span><span class="s1">_known) </span><span class="s2">and </span><span class="s1">len(x) == len(left)</span>
        <span class="s1">is_rkey = </span><span class="s2">lambda </span><span class="s1">x: isinstance(x</span><span class="s2">, </span><span class="s1">_known) </span><span class="s2">and </span><span class="s1">len(x) == len(right)</span>

        <span class="s3"># Note that pd.merge_asof() has separate 'on' and 'by' parameters. A</span>
        <span class="s3"># user could, for example, request 'left_index' and 'left_by'. In a</span>
        <span class="s3"># regular pd.merge(), users cannot specify both 'left_index' and</span>
        <span class="s3"># 'left_on'. (Instead, users have a MultiIndex). That means the</span>
        <span class="s3"># self.left_on in this function is always empty in a pd.merge(), but</span>
        <span class="s3"># a pd.merge_asof(left_index=True, left_by=...) will result in a</span>
        <span class="s3"># self.left_on array with a None in the middle of it. This requires</span>
        <span class="s3"># a work-around as designated in the code below.</span>
        <span class="s3"># See _validate_left_right_on() for where this happens.</span>

        <span class="s3"># ugh, spaghetti re #733</span>
        <span class="s2">if </span><span class="s1">_any(self.left_on) </span><span class="s2">and </span><span class="s1">_any(self.right_on):</span>
            <span class="s2">for </span><span class="s1">lk</span><span class="s2">, </span><span class="s1">rk </span><span class="s2">in </span><span class="s1">zip(self.left_on</span><span class="s2">, </span><span class="s1">self.right_on):</span>
                <span class="s1">lk = extract_array(lk</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">rk = extract_array(rk</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">is_lkey(lk):</span>
                    <span class="s1">lk = cast(ArrayLike</span><span class="s2">, </span><span class="s1">lk)</span>
                    <span class="s1">left_keys.append(lk)</span>
                    <span class="s2">if </span><span class="s1">is_rkey(rk):</span>
                        <span class="s1">rk = cast(ArrayLike</span><span class="s2">, </span><span class="s1">rk)</span>
                        <span class="s1">right_keys.append(rk)</span>
                        <span class="s1">join_names.append(</span><span class="s2">None</span><span class="s1">)  </span><span class="s3"># what to do?</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s3"># Then we're either Hashable or a wrong-length arraylike,</span>
                        <span class="s3">#  the latter of which will raise</span>
                        <span class="s1">rk = cast(Hashable</span><span class="s2">, </span><span class="s1">rk)</span>
                        <span class="s2">if </span><span class="s1">rk </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s1">right_keys.append(right._get_label_or_level_values(rk))</span>
                            <span class="s1">join_names.append(rk)</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s3"># work-around for merge_asof(right_index=True)</span>
                            <span class="s1">right_keys.append(right.index._values)</span>
                            <span class="s1">join_names.append(right.index.name)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if not </span><span class="s1">is_rkey(rk):</span>
                        <span class="s3"># Then we're either Hashable or a wrong-length arraylike,</span>
                        <span class="s3">#  the latter of which will raise</span>
                        <span class="s1">rk = cast(Hashable</span><span class="s2">, </span><span class="s1">rk)</span>
                        <span class="s2">if </span><span class="s1">rk </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s1">right_keys.append(right._get_label_or_level_values(rk))</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s3"># work-around for merge_asof(right_index=True)</span>
                            <span class="s1">right_keys.append(right.index._values)</span>
                        <span class="s2">if </span><span class="s1">lk </span><span class="s2">is not None and </span><span class="s1">lk == rk:  </span><span class="s3"># FIXME: what about other NAs?</span>
                            <span class="s3"># avoid key upcast in corner case (length-0)</span>
                            <span class="s1">lk = cast(Hashable</span><span class="s2">, </span><span class="s1">lk)</span>
                            <span class="s2">if </span><span class="s1">len(left) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                                <span class="s1">right_drop.append(rk)</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">left_drop.append(lk)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">rk = cast(ArrayLike</span><span class="s2">, </span><span class="s1">rk)</span>
                        <span class="s1">right_keys.append(rk)</span>
                    <span class="s2">if </span><span class="s1">lk </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s3"># Then we're either Hashable or a wrong-length arraylike,</span>
                        <span class="s3">#  the latter of which will raise</span>
                        <span class="s1">lk = cast(Hashable</span><span class="s2">, </span><span class="s1">lk)</span>
                        <span class="s1">left_keys.append(left._get_label_or_level_values(lk))</span>
                        <span class="s1">join_names.append(lk)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s3"># work-around for merge_asof(left_index=True)</span>
                        <span class="s1">left_keys.append(left.index._values)</span>
                        <span class="s1">join_names.append(left.index.name)</span>
        <span class="s2">elif </span><span class="s1">_any(self.left_on):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.left_on:</span>
                <span class="s2">if </span><span class="s1">is_lkey(k):</span>
                    <span class="s1">k = extract_array(k</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s1">k = cast(ArrayLike</span><span class="s2">, </span><span class="s1">k)</span>
                    <span class="s1">left_keys.append(k)</span>
                    <span class="s1">join_names.append(</span><span class="s2">None</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># Then we're either Hashable or a wrong-length arraylike,</span>
                    <span class="s3">#  the latter of which will raise</span>
                    <span class="s1">k = cast(Hashable</span><span class="s2">, </span><span class="s1">k)</span>
                    <span class="s1">left_keys.append(left._get_label_or_level_values(k))</span>
                    <span class="s1">join_names.append(k)</span>
            <span class="s2">if </span><span class="s1">isinstance(self.right.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
                <span class="s1">right_keys = [</span>
                    <span class="s1">lev._values.take(lev_codes)</span>
                    <span class="s2">for </span><span class="s1">lev</span><span class="s2">, </span><span class="s1">lev_codes </span><span class="s2">in </span><span class="s1">zip(</span>
                        <span class="s1">self.right.index.levels</span><span class="s2">, </span><span class="s1">self.right.index.codes</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">right_keys = [self.right.index._values]</span>
        <span class="s2">elif </span><span class="s1">_any(self.right_on):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.right_on:</span>
                <span class="s1">k = extract_array(k</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">is_rkey(k):</span>
                    <span class="s1">k = cast(ArrayLike</span><span class="s2">, </span><span class="s1">k)</span>
                    <span class="s1">right_keys.append(k)</span>
                    <span class="s1">join_names.append(</span><span class="s2">None</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># Then we're either Hashable or a wrong-length arraylike,</span>
                    <span class="s3">#  the latter of which will raise</span>
                    <span class="s1">k = cast(Hashable</span><span class="s2">, </span><span class="s1">k)</span>
                    <span class="s1">right_keys.append(right._get_label_or_level_values(k))</span>
                    <span class="s1">join_names.append(k)</span>
            <span class="s2">if </span><span class="s1">isinstance(self.left.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
                <span class="s1">left_keys = [</span>
                    <span class="s1">lev._values.take(lev_codes)</span>
                    <span class="s2">for </span><span class="s1">lev</span><span class="s2">, </span><span class="s1">lev_codes </span><span class="s2">in </span><span class="s1">zip(</span>
                        <span class="s1">self.left.index.levels</span><span class="s2">, </span><span class="s1">self.left.index.codes</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">left_keys = [self.left.index._values]</span>

        <span class="s2">return </span><span class="s1">left_keys</span><span class="s2">, </span><span class="s1">right_keys</span><span class="s2">, </span><span class="s1">join_names</span><span class="s2">, </span><span class="s1">left_drop</span><span class="s2">, </span><span class="s1">right_drop</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_maybe_coerce_merge_keys(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># we have valid merges but we may have to further</span>
        <span class="s3"># coerce these if they are originally incompatible types</span>
        <span class="s3">#</span>
        <span class="s3"># for example if these are categorical, but are not dtype_equal</span>
        <span class="s3"># or if we have object and integer dtypes</span>

        <span class="s2">for </span><span class="s1">lk</span><span class="s2">, </span><span class="s1">rk</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">zip(</span>
            <span class="s1">self.left_join_keys</span><span class="s2">, </span><span class="s1">self.right_join_keys</span><span class="s2">, </span><span class="s1">self.join_names</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">(len(lk) </span><span class="s2">and not </span><span class="s1">len(rk)) </span><span class="s2">or </span><span class="s1">(</span><span class="s2">not </span><span class="s1">len(lk) </span><span class="s2">and </span><span class="s1">len(rk)):</span>
                <span class="s2">continue</span>

            <span class="s1">lk = extract_array(lk</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">rk = extract_array(rk</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>

            <span class="s1">lk_is_cat = isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype)</span>
            <span class="s1">rk_is_cat = isinstance(rk.dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype)</span>
            <span class="s1">lk_is_object = is_object_dtype(lk.dtype)</span>
            <span class="s1">rk_is_object = is_object_dtype(rk.dtype)</span>

            <span class="s3"># if either left or right is a categorical</span>
            <span class="s3"># then the must match exactly in categories &amp; ordered</span>
            <span class="s2">if </span><span class="s1">lk_is_cat </span><span class="s2">and </span><span class="s1">rk_is_cat:</span>
                <span class="s1">lk = cast(Categorical</span><span class="s2">, </span><span class="s1">lk)</span>
                <span class="s1">rk = cast(Categorical</span><span class="s2">, </span><span class="s1">rk)</span>
                <span class="s2">if </span><span class="s1">lk._categories_match_up_to_permutation(rk):</span>
                    <span class="s2">continue</span>

            <span class="s2">elif </span><span class="s1">lk_is_cat </span><span class="s2">or </span><span class="s1">rk_is_cat:</span>
                <span class="s2">pass</span>

            <span class="s2">elif </span><span class="s1">lk.dtype == rk.dtype:</span>
                <span class="s2">continue</span>

            <span class="s1">msg = (</span>
                <span class="s4">f&quot;You are trying to merge on </span><span class="s2">{</span><span class="s1">lk.dtype</span><span class="s2">} </span><span class="s4">and </span><span class="s2">{</span><span class="s1">rk.dtype</span><span class="s2">} </span><span class="s4">columns &quot;</span>
                <span class="s4">f&quot;for key '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">'. If you wish to proceed you should use pd.concat&quot;</span>
            <span class="s1">)</span>

            <span class="s3"># if we are numeric, then allow differing</span>
            <span class="s3"># kinds to proceed, eg. int64 and int8, int and float</span>
            <span class="s3"># further if we are object, but we infer to</span>
            <span class="s3"># the same, then proceed</span>
            <span class="s2">if </span><span class="s1">is_numeric_dtype(lk.dtype) </span><span class="s2">and </span><span class="s1">is_numeric_dtype(rk.dtype):</span>
                <span class="s2">if </span><span class="s1">lk.dtype.kind == rk.dtype.kind:</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">is_extension_array_dtype(lk.dtype) </span><span class="s2">and not </span><span class="s1">is_extension_array_dtype(</span>
                    <span class="s1">rk.dtype</span>
                <span class="s1">):</span>
                    <span class="s1">ct = find_common_type([lk.dtype</span><span class="s2">, </span><span class="s1">rk.dtype])</span>
                    <span class="s2">if </span><span class="s1">is_extension_array_dtype(ct):</span>
                        <span class="s1">rk = ct.construct_array_type()._from_sequence(rk)  </span><span class="s3"># type: ignore[union-attr]  # noqa: E501</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">rk = rk.astype(ct)  </span><span class="s3"># type: ignore[arg-type]</span>
                <span class="s2">elif </span><span class="s1">is_extension_array_dtype(rk.dtype):</span>
                    <span class="s1">ct = find_common_type([lk.dtype</span><span class="s2">, </span><span class="s1">rk.dtype])</span>
                    <span class="s2">if </span><span class="s1">is_extension_array_dtype(ct):</span>
                        <span class="s1">lk = ct.construct_array_type()._from_sequence(lk)  </span><span class="s3"># type: ignore[union-attr]  # noqa: E501</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">lk = lk.astype(ct)  </span><span class="s3"># type: ignore[arg-type]</span>

                <span class="s3"># check whether ints and floats</span>
                <span class="s2">if </span><span class="s1">is_integer_dtype(rk.dtype) </span><span class="s2">and </span><span class="s1">is_float_dtype(lk.dtype):</span>
                    <span class="s3"># GH 47391 numpy &gt; 1.24 will raise a RuntimeError for nan -&gt; int</span>
                    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
                        <span class="s3"># error: Argument 1 to &quot;astype&quot; of &quot;ndarray&quot; has incompatible</span>
                        <span class="s3"># type &quot;Union[ExtensionDtype, Any, dtype[Any]]&quot;; expected</span>
                        <span class="s3"># &quot;Union[dtype[Any], Type[Any], _SupportsDType[dtype[Any]]]&quot;</span>
                        <span class="s1">casted = lk.astype(rk.dtype)  </span><span class="s3"># type: ignore[arg-type]</span>

                    <span class="s1">mask = ~np.isnan(lk)</span>
                    <span class="s1">match = lk == casted</span>
                    <span class="s2">if not </span><span class="s1">match[mask].all():</span>
                        <span class="s1">warnings.warn(</span>
                            <span class="s4">&quot;You are merging on int and float &quot;</span>
                            <span class="s4">&quot;columns where the float values &quot;</span>
                            <span class="s4">&quot;are not equal to their int representation.&quot;</span><span class="s2">,</span>
                            <span class="s1">UserWarning</span><span class="s2">,</span>
                            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">is_float_dtype(rk.dtype) </span><span class="s2">and </span><span class="s1">is_integer_dtype(lk.dtype):</span>
                    <span class="s3"># GH 47391 numpy &gt; 1.24 will raise a RuntimeError for nan -&gt; int</span>
                    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
                        <span class="s3"># error: Argument 1 to &quot;astype&quot; of &quot;ndarray&quot; has incompatible</span>
                        <span class="s3"># type &quot;Union[ExtensionDtype, Any, dtype[Any]]&quot;; expected</span>
                        <span class="s3"># &quot;Union[dtype[Any], Type[Any], _SupportsDType[dtype[Any]]]&quot;</span>
                        <span class="s1">casted = rk.astype(lk.dtype)  </span><span class="s3"># type: ignore[arg-type]</span>

                    <span class="s1">mask = ~np.isnan(rk)</span>
                    <span class="s1">match = rk == casted</span>
                    <span class="s2">if not </span><span class="s1">match[mask].all():</span>
                        <span class="s1">warnings.warn(</span>
                            <span class="s4">&quot;You are merging on int and float &quot;</span>
                            <span class="s4">&quot;columns where the float values &quot;</span>
                            <span class="s4">&quot;are not equal to their int representation.&quot;</span><span class="s2">,</span>
                            <span class="s1">UserWarning</span><span class="s2">,</span>
                            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s2">continue</span>

                <span class="s3"># let's infer and see if we are ok</span>
                <span class="s2">if </span><span class="s1">lib.infer_dtype(lk</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">) == lib.infer_dtype(</span>
                    <span class="s1">rk</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span>
                <span class="s1">):</span>
                    <span class="s2">continue</span>

            <span class="s3"># Check if we are trying to merge on obviously</span>
            <span class="s3"># incompatible dtypes GH 9780, GH 15800</span>

            <span class="s3"># bool values are coerced to object</span>
            <span class="s2">elif </span><span class="s1">(lk_is_object </span><span class="s2">and </span><span class="s1">is_bool_dtype(rk.dtype)) </span><span class="s2">or </span><span class="s1">(</span>
                <span class="s1">is_bool_dtype(lk.dtype) </span><span class="s2">and </span><span class="s1">rk_is_object</span>
            <span class="s1">):</span>
                <span class="s2">pass</span>

            <span class="s3"># object values are allowed to be merged</span>
            <span class="s2">elif </span><span class="s1">(lk_is_object </span><span class="s2">and </span><span class="s1">is_numeric_dtype(rk.dtype)) </span><span class="s2">or </span><span class="s1">(</span>
                <span class="s1">is_numeric_dtype(lk.dtype) </span><span class="s2">and </span><span class="s1">rk_is_object</span>
            <span class="s1">):</span>
                <span class="s1">inferred_left = lib.infer_dtype(lk</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">inferred_right = lib.infer_dtype(rk</span><span class="s2">, </span><span class="s1">skipna=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">bool_types = [</span><span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s4">&quot;mixed-integer&quot;</span><span class="s2">, </span><span class="s4">&quot;boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;empty&quot;</span><span class="s1">]</span>
                <span class="s1">string_types = [</span><span class="s4">&quot;string&quot;</span><span class="s2">, </span><span class="s4">&quot;unicode&quot;</span><span class="s2">, </span><span class="s4">&quot;mixed&quot;</span><span class="s2">, </span><span class="s4">&quot;bytes&quot;</span><span class="s2">, </span><span class="s4">&quot;empty&quot;</span><span class="s1">]</span>

                <span class="s3"># inferred bool</span>
                <span class="s2">if </span><span class="s1">inferred_left </span><span class="s2">in </span><span class="s1">bool_types </span><span class="s2">and </span><span class="s1">inferred_right </span><span class="s2">in </span><span class="s1">bool_types:</span>
                    <span class="s2">pass</span>

                <span class="s3"># unless we are merging non-string-like with string-like</span>
                <span class="s2">elif </span><span class="s1">(</span>
                    <span class="s1">inferred_left </span><span class="s2">in </span><span class="s1">string_types </span><span class="s2">and </span><span class="s1">inferred_right </span><span class="s2">not in </span><span class="s1">string_types</span>
                <span class="s1">) </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">inferred_right </span><span class="s2">in </span><span class="s1">string_types </span><span class="s2">and </span><span class="s1">inferred_left </span><span class="s2">not in </span><span class="s1">string_types</span>
                <span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

            <span class="s3"># datetimelikes must match exactly</span>
            <span class="s2">elif </span><span class="s1">needs_i8_conversion(lk.dtype) </span><span class="s2">and not </span><span class="s1">needs_i8_conversion(rk.dtype):</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">elif not </span><span class="s1">needs_i8_conversion(lk.dtype) </span><span class="s2">and </span><span class="s1">needs_i8_conversion(rk.dtype):</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">elif </span><span class="s1">isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype) </span><span class="s2">and not </span><span class="s1">isinstance(</span>
                <span class="s1">rk.dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">elif not </span><span class="s1">isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype) </span><span class="s2">and </span><span class="s1">isinstance(</span>
                <span class="s1">rk.dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">elif </span><span class="s1">(</span>
                <span class="s1">isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype)</span>
                <span class="s2">and </span><span class="s1">isinstance(rk.dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype)</span>
            <span class="s1">) </span><span class="s2">or </span><span class="s1">(lk.dtype.kind == </span><span class="s4">&quot;M&quot; </span><span class="s2">and </span><span class="s1">rk.dtype.kind == </span><span class="s4">&quot;M&quot;</span><span class="s1">):</span>
                <span class="s3"># allows datetime with different resolutions</span>
                <span class="s2">continue</span>

            <span class="s2">elif </span><span class="s1">lk_is_object </span><span class="s2">and </span><span class="s1">rk_is_object:</span>
                <span class="s2">continue</span>

            <span class="s3"># Houston, we have a problem!</span>
            <span class="s3"># let's coerce to object if the dtypes aren't</span>
            <span class="s3"># categorical, otherwise coerce to the category</span>
            <span class="s3"># dtype. If we coerced categories to object,</span>
            <span class="s3"># then we would lose type information on some</span>
            <span class="s3"># columns, and end up trying to merge</span>
            <span class="s3"># incompatible dtypes. See GH 16900.</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.left.columns:</span>
                <span class="s1">typ = cast(Categorical</span><span class="s2">, </span><span class="s1">lk).categories.dtype </span><span class="s2">if </span><span class="s1">lk_is_cat </span><span class="s2">else </span><span class="s1">object</span>
                <span class="s1">self.left = self.left.copy()</span>
                <span class="s1">self.left[name] = self.left[name].astype(typ)</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.right.columns:</span>
                <span class="s1">typ = cast(Categorical</span><span class="s2">, </span><span class="s1">rk).categories.dtype </span><span class="s2">if </span><span class="s1">rk_is_cat </span><span class="s2">else </span><span class="s1">object</span>
                <span class="s1">self.right = self.right.copy()</span>
                <span class="s1">self.right[name] = self.right[name].astype(typ)</span>

    <span class="s2">def </span><span class="s1">_validate_left_right_on(self</span><span class="s2">, </span><span class="s1">left_on</span><span class="s2">, </span><span class="s1">right_on):</span>
        <span class="s1">left_on = com.maybe_make_list(left_on)</span>
        <span class="s1">right_on = com.maybe_make_list(right_on)</span>

        <span class="s3"># Hm, any way to make this logic less complicated??</span>
        <span class="s2">if </span><span class="s1">self.on </span><span class="s2">is None and </span><span class="s1">left_on </span><span class="s2">is None and </span><span class="s1">right_on </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.left_index </span><span class="s2">and </span><span class="s1">self.right_index:</span>
                <span class="s1">left_on</span><span class="s2">, </span><span class="s1">right_on = ()</span><span class="s2">, </span><span class="s1">()</span>
            <span class="s2">elif </span><span class="s1">self.left_index:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;Must pass right_on or right_index=True&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">self.right_index:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;Must pass left_on or left_index=True&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># use the common columns</span>
                <span class="s1">left_cols = self.left.columns</span>
                <span class="s1">right_cols = self.right.columns</span>
                <span class="s1">common_cols = left_cols.intersection(right_cols)</span>
                <span class="s2">if </span><span class="s1">len(common_cols) == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">MergeError(</span>
                        <span class="s4">&quot;No common columns to perform merge on. &quot;</span>
                        <span class="s4">f&quot;Merge options: left_on=</span><span class="s2">{</span><span class="s1">left_on</span><span class="s2">}</span><span class="s4">, &quot;</span>
                        <span class="s4">f&quot;right_on=</span><span class="s2">{</span><span class="s1">right_on</span><span class="s2">}</span><span class="s4">, &quot;</span>
                        <span class="s4">f&quot;left_index=</span><span class="s2">{</span><span class="s1">self.left_index</span><span class="s2">}</span><span class="s4">, &quot;</span>
                        <span class="s4">f&quot;right_index=</span><span class="s2">{</span><span class="s1">self.right_index</span><span class="s2">}</span><span class="s4">&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s2">not </span><span class="s1">left_cols.join(common_cols</span><span class="s2">, </span><span class="s1">how=</span><span class="s4">&quot;inner&quot;</span><span class="s1">).is_unique</span>
                    <span class="s2">or not </span><span class="s1">right_cols.join(common_cols</span><span class="s2">, </span><span class="s1">how=</span><span class="s4">&quot;inner&quot;</span><span class="s1">).is_unique</span>
                <span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">f&quot;Data columns not unique: </span><span class="s2">{</span><span class="s1">repr(common_cols)</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s1">left_on = right_on = common_cols</span>
        <span class="s2">elif </span><span class="s1">self.on </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">left_on </span><span class="s2">is not None or </span><span class="s1">right_on </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">'Can only pass argument &quot;on&quot; OR &quot;left_on&quot; '</span>
                    <span class="s4">'and &quot;right_on&quot;, not a combination of both.'</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.left_index </span><span class="s2">or </span><span class="s1">self.right_index:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">'Can only pass argument &quot;on&quot; OR &quot;left_index&quot; '</span>
                    <span class="s4">'and &quot;right_index&quot;, not a combination of both.'</span>
                <span class="s1">)</span>
            <span class="s1">left_on = right_on = self.on</span>
        <span class="s2">elif </span><span class="s1">left_on </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.left_index:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">'Can only pass argument &quot;left_on&quot; OR &quot;left_index&quot; not both.'</span>
                <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">self.right_index </span><span class="s2">and </span><span class="s1">right_on </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">'Must pass &quot;right_on&quot; OR &quot;right_index&quot;.'</span><span class="s1">)</span>
            <span class="s1">n = len(left_on)</span>
            <span class="s2">if </span><span class="s1">self.right_index:</span>
                <span class="s2">if </span><span class="s1">len(left_on) != self.right.index.nlevels:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;len(left_on) must equal the number &quot;</span>
                        <span class="s4">'of levels in the index of &quot;right&quot;'</span>
                    <span class="s1">)</span>
                <span class="s1">right_on = [</span><span class="s2">None</span><span class="s1">] * n</span>
        <span class="s2">elif </span><span class="s1">right_on </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.right_index:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">'Can only pass argument &quot;right_on&quot; OR &quot;right_index&quot; not both.'</span>
                <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">self.left_index </span><span class="s2">and </span><span class="s1">left_on </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">'Must pass &quot;left_on&quot; OR &quot;left_index&quot;.'</span><span class="s1">)</span>
            <span class="s1">n = len(right_on)</span>
            <span class="s2">if </span><span class="s1">self.left_index:</span>
                <span class="s2">if </span><span class="s1">len(right_on) != self.left.index.nlevels:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;len(right_on) must equal the number &quot;</span>
                        <span class="s4">'of levels in the index of &quot;left&quot;'</span>
                    <span class="s1">)</span>
                <span class="s1">left_on = [</span><span class="s2">None</span><span class="s1">] * n</span>
        <span class="s2">if </span><span class="s1">len(right_on) != len(left_on):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;len(right_on) must equal len(left_on)&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">left_on</span><span class="s2">, </span><span class="s1">right_on</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_validate_validate_kwd(self</span><span class="s2">, </span><span class="s1">validate: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># Check uniqueness of each</span>
        <span class="s2">if </span><span class="s1">self.left_index:</span>
            <span class="s1">left_unique = self.orig_left.index.is_unique</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">left_unique = MultiIndex.from_arrays(self.left_join_keys).is_unique</span>

        <span class="s2">if </span><span class="s1">self.right_index:</span>
            <span class="s1">right_unique = self.orig_right.index.is_unique</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">right_unique = MultiIndex.from_arrays(self.right_join_keys).is_unique</span>

        <span class="s3"># Check data integrity</span>
        <span class="s2">if </span><span class="s1">validate </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;one_to_one&quot;</span><span class="s2">, </span><span class="s4">&quot;1:1&quot;</span><span class="s1">]:</span>
            <span class="s2">if not </span><span class="s1">left_unique </span><span class="s2">and not </span><span class="s1">right_unique:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">&quot;Merge keys are not unique in either left &quot;</span>
                    <span class="s4">&quot;or right dataset; not a one-to-one merge&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">left_unique:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">&quot;Merge keys are not unique in left dataset; not a one-to-one merge&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">right_unique:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">&quot;Merge keys are not unique in right dataset; not a one-to-one merge&quot;</span>
                <span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">validate </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;one_to_many&quot;</span><span class="s2">, </span><span class="s4">&quot;1:m&quot;</span><span class="s1">]:</span>
            <span class="s2">if not </span><span class="s1">left_unique:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">&quot;Merge keys are not unique in left dataset; not a one-to-many merge&quot;</span>
                <span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">validate </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;many_to_one&quot;</span><span class="s2">, </span><span class="s4">&quot;m:1&quot;</span><span class="s1">]:</span>
            <span class="s2">if not </span><span class="s1">right_unique:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span>
                    <span class="s4">&quot;Merge keys are not unique in right dataset; &quot;</span>
                    <span class="s4">&quot;not a many-to-one merge&quot;</span>
                <span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">validate </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;many_to_many&quot;</span><span class="s2">, </span><span class="s4">&quot;m:m&quot;</span><span class="s1">]:</span>
            <span class="s2">pass</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f'&quot;</span><span class="s2">{</span><span class="s1">validate</span><span class="s2">}</span><span class="s4">&quot; is not a valid argument. '</span>
                <span class="s4">&quot;Valid arguments are:</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">'- &quot;1:1&quot;</span><span class="s2">\n</span><span class="s4">'</span>
                <span class="s4">'- &quot;1:m&quot;</span><span class="s2">\n</span><span class="s4">'</span>
                <span class="s4">'- &quot;m:1&quot;</span><span class="s2">\n</span><span class="s4">'</span>
                <span class="s4">'- &quot;m:m&quot;</span><span class="s2">\n</span><span class="s4">'</span>
                <span class="s4">'- &quot;one_to_one&quot;</span><span class="s2">\n</span><span class="s4">'</span>
                <span class="s4">'- &quot;one_to_many&quot;</span><span class="s2">\n</span><span class="s4">'</span>
                <span class="s4">'- &quot;many_to_one&quot;</span><span class="s2">\n</span><span class="s4">'</span>
                <span class="s4">'- &quot;many_to_many&quot;'</span>
            <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_join_indexers(</span>
    <span class="s1">left_keys: list[ArrayLike]</span><span class="s2">,</span>
    <span class="s1">right_keys: list[ArrayLike]</span><span class="s2">,</span>
    <span class="s1">sort: bool = </span><span class="s2">False,</span>
    <span class="s1">how: MergeHow | Literal[</span><span class="s4">&quot;asof&quot;</span><span class="s1">] = </span><span class="s4">&quot;inner&quot;</span><span class="s2">,</span>
<span class="s1">) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
    <span class="s0">&quot;&quot;&quot; 
 
    Parameters 
    ---------- 
    left_keys : list[ndarray, ExtensionArray, Index, Series] 
    right_keys : list[ndarray, ExtensionArray, Index, Series] 
    sort : bool, default False 
    how : {'inner', 'outer', 'left', 'right'}, default 'inner' 
 
    Returns 
    ------- 
    np.ndarray[np.intp] 
        Indexer into the left_keys. 
    np.ndarray[np.intp] 
        Indexer into the right_keys. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">len(left_keys) == len(</span>
        <span class="s1">right_keys</span>
    <span class="s1">)</span><span class="s2">, </span><span class="s4">&quot;left_keys and right_keys must be the same length&quot;</span>

    <span class="s3"># fast-path for empty left/right</span>
    <span class="s1">left_n = len(left_keys[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">right_n = len(right_keys[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">left_n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">how </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;left&quot;</span><span class="s2">, </span><span class="s4">&quot;inner&quot;</span><span class="s2">, </span><span class="s4">&quot;cross&quot;</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">_get_empty_indexer()</span>
        <span class="s2">elif not </span><span class="s1">sort </span><span class="s2">and </span><span class="s1">how </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;right&quot;</span><span class="s2">, </span><span class="s4">&quot;outer&quot;</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">_get_no_sort_one_missing_indexer(right_n</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">right_n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">how </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;right&quot;</span><span class="s2">, </span><span class="s4">&quot;inner&quot;</span><span class="s2">, </span><span class="s4">&quot;cross&quot;</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">_get_empty_indexer()</span>
        <span class="s2">elif not </span><span class="s1">sort </span><span class="s2">and </span><span class="s1">how </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;left&quot;</span><span class="s2">, </span><span class="s4">&quot;outer&quot;</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">_get_no_sort_one_missing_indexer(left_n</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s3"># get left &amp; right join labels and num. of levels at each location</span>
    <span class="s1">mapped = (</span>
        <span class="s1">_factorize_keys(left_keys[n]</span><span class="s2">, </span><span class="s1">right_keys[n]</span><span class="s2">, </span><span class="s1">sort=sort</span><span class="s2">, </span><span class="s1">how=how)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(left_keys))</span>
    <span class="s1">)</span>
    <span class="s1">zipped = zip(*mapped)</span>
    <span class="s1">llab</span><span class="s2">, </span><span class="s1">rlab</span><span class="s2">, </span><span class="s1">shape = (list(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">zipped)</span>

    <span class="s3"># get flat i8 keys from label lists</span>
    <span class="s1">lkey</span><span class="s2">, </span><span class="s1">rkey = _get_join_keys(llab</span><span class="s2">, </span><span class="s1">rlab</span><span class="s2">, </span><span class="s1">tuple(shape)</span><span class="s2">, </span><span class="s1">sort)</span>

    <span class="s3"># factorize keys to a dense i8 space</span>
    <span class="s3"># `count` is the num. of unique keys</span>
    <span class="s3"># set(lkey) | set(rkey) == range(count)</span>

    <span class="s1">lkey</span><span class="s2">, </span><span class="s1">rkey</span><span class="s2">, </span><span class="s1">count = _factorize_keys(lkey</span><span class="s2">, </span><span class="s1">rkey</span><span class="s2">, </span><span class="s1">sort=sort</span><span class="s2">, </span><span class="s1">how=how)</span>
    <span class="s3"># preserve left frame order if how == 'left' and sort == False</span>
    <span class="s1">kwargs = {}</span>
    <span class="s2">if </span><span class="s1">how </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;left&quot;</span><span class="s2">, </span><span class="s4">&quot;right&quot;</span><span class="s1">):</span>
        <span class="s1">kwargs[</span><span class="s4">&quot;sort&quot;</span><span class="s1">] = sort</span>
    <span class="s1">join_func = {</span>
        <span class="s4">&quot;inner&quot;</span><span class="s1">: libjoin.inner_join</span><span class="s2">,</span>
        <span class="s4">&quot;left&quot;</span><span class="s1">: libjoin.left_outer_join</span><span class="s2">,</span>
        <span class="s4">&quot;right&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">**kwargs: libjoin.left_outer_join(</span>
            <span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s4">&quot;outer&quot;</span><span class="s1">: libjoin.full_outer_join</span><span class="s2">,</span>
    <span class="s1">}[how]</span>

    <span class="s3"># error: Cannot call function of unknown type</span>
    <span class="s2">return </span><span class="s1">join_func(lkey</span><span class="s2">, </span><span class="s1">rkey</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">**kwargs)  </span><span class="s3"># type: ignore[operator]</span>


<span class="s2">def </span><span class="s1">restore_dropped_levels_multijoin(</span>
    <span class="s1">left: MultiIndex</span><span class="s2">,</span>
    <span class="s1">right: MultiIndex</span><span class="s2">,</span>
    <span class="s1">dropped_level_names</span><span class="s2">,</span>
    <span class="s1">join_index: Index</span><span class="s2">,</span>
    <span class="s1">lindexer: npt.NDArray[np.intp]</span><span class="s2">,</span>
    <span class="s1">rindexer: npt.NDArray[np.intp]</span><span class="s2">,</span>
<span class="s1">) -&gt; tuple[list[Index]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">list[Hashable]]:</span>
    <span class="s0">&quot;&quot;&quot; 
    *this is an internal non-public method* 
 
    Returns the levels, labels and names of a multi-index to multi-index join. 
    Depending on the type of join, this method restores the appropriate 
    dropped levels of the joined multi-index. 
    The method relies on lindexer, rindexer which hold the index positions of 
    left and right, where a join was feasible 
 
    Parameters 
    ---------- 
    left : MultiIndex 
        left index 
    right : MultiIndex 
        right index 
    dropped_level_names : str array 
        list of non-common level names 
    join_index : Index 
        the index of the join between the 
        common levels of left and right 
    lindexer : np.ndarray[np.intp] 
        left indexer 
    rindexer : np.ndarray[np.intp] 
        right indexer 
 
    Returns 
    ------- 
    levels : list of Index 
        levels of combined multiindexes 
    labels : np.ndarray[np.intp] 
        labels of combined multiindexes 
    names : List[Hashable] 
        names of combined multiindex levels 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_convert_to_multiindex(index: Index) -&gt; MultiIndex:</span>
        <span class="s2">if </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s2">return </span><span class="s1">index</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">MultiIndex.from_arrays([index._values]</span><span class="s2">, </span><span class="s1">names=[index.name])</span>

    <span class="s3"># For multi-multi joins with one overlapping level,</span>
    <span class="s3"># the returned index if of type Index</span>
    <span class="s3"># Assure that join_index is of type MultiIndex</span>
    <span class="s3"># so that dropped levels can be appended</span>
    <span class="s1">join_index = _convert_to_multiindex(join_index)</span>

    <span class="s1">join_levels = join_index.levels</span>
    <span class="s1">join_codes = join_index.codes</span>
    <span class="s1">join_names = join_index.names</span>

    <span class="s3"># Iterate through the levels that must be restored</span>
    <span class="s2">for </span><span class="s1">dropped_level_name </span><span class="s2">in </span><span class="s1">dropped_level_names:</span>
        <span class="s2">if </span><span class="s1">dropped_level_name </span><span class="s2">in </span><span class="s1">left.names:</span>
            <span class="s1">idx = left</span>
            <span class="s1">indexer = lindexer</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">idx = right</span>
            <span class="s1">indexer = rindexer</span>

        <span class="s3"># The index of the level name to be restored</span>
        <span class="s1">name_idx = idx.names.index(dropped_level_name)</span>

        <span class="s1">restore_levels = idx.levels[name_idx]</span>
        <span class="s3"># Inject -1 in the codes list where a join was not possible</span>
        <span class="s3"># IOW indexer[i]=-1</span>
        <span class="s1">codes = idx.codes[name_idx]</span>
        <span class="s2">if </span><span class="s1">indexer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">restore_codes = codes</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">restore_codes = algos.take_nd(codes</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">fill_value=-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s3"># error: Cannot determine type of &quot;__add__&quot;</span>
        <span class="s1">join_levels = join_levels + [restore_levels]  </span><span class="s3"># type: ignore[has-type]</span>
        <span class="s1">join_codes = join_codes + [restore_codes]</span>
        <span class="s1">join_names = join_names + [dropped_level_name]</span>

    <span class="s2">return </span><span class="s1">join_levels</span><span class="s2">, </span><span class="s1">join_codes</span><span class="s2">, </span><span class="s1">join_names</span>


<span class="s2">class </span><span class="s1">_OrderedMerge(_MergeOperation):</span>
    <span class="s1">_merge_type = </span><span class="s4">&quot;ordered_merge&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">left: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">right: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">left_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">right_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">left_index: bool = </span><span class="s2">False,</span>
        <span class="s1">right_index: bool = </span><span class="s2">False,</span>
        <span class="s1">suffixes: Suffixes = (</span><span class="s4">&quot;_x&quot;</span><span class="s2">, </span><span class="s4">&quot;_y&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">fill_method: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">how: JoinHow | Literal[</span><span class="s4">&quot;asof&quot;</span><span class="s1">] = </span><span class="s4">&quot;outer&quot;</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.fill_method = fill_method</span>
        <span class="s1">_MergeOperation.__init__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">left</span><span class="s2">,</span>
            <span class="s1">right</span><span class="s2">,</span>
            <span class="s1">on=on</span><span class="s2">,</span>
            <span class="s1">left_on=left_on</span><span class="s2">,</span>
            <span class="s1">left_index=left_index</span><span class="s2">,</span>
            <span class="s1">right_index=right_index</span><span class="s2">,</span>
            <span class="s1">right_on=right_on</span><span class="s2">,</span>
            <span class="s1">how=how</span><span class="s2">,</span>
            <span class="s1">suffixes=suffixes</span><span class="s2">,</span>
            <span class="s1">sort=</span><span class="s2">True,  </span><span class="s3"># factorize sorts</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_result(self</span><span class="s2">, </span><span class="s1">copy: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">True</span><span class="s1">) -&gt; DataFrame:</span>
        <span class="s1">join_index</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer = self._get_join_info()</span>

        <span class="s1">left_join_indexer: npt.NDArray[np.intp] | </span><span class="s2">None</span>
        <span class="s1">right_join_indexer: npt.NDArray[np.intp] | </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.fill_method == </span><span class="s4">&quot;ffill&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">left_indexer </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;left_indexer cannot be None&quot;</span><span class="s1">)</span>
            <span class="s1">left_indexer = cast(</span><span class="s4">&quot;npt.NDArray[np.intp]&quot;</span><span class="s2">, </span><span class="s1">left_indexer)</span>
            <span class="s1">right_indexer = cast(</span><span class="s4">&quot;npt.NDArray[np.intp]&quot;</span><span class="s2">, </span><span class="s1">right_indexer)</span>
            <span class="s1">left_join_indexer = libjoin.ffill_indexer(left_indexer)</span>
            <span class="s1">right_join_indexer = libjoin.ffill_indexer(right_indexer)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">left_join_indexer = left_indexer</span>
            <span class="s1">right_join_indexer = right_indexer</span>

        <span class="s1">result = self._reindex_and_concat(</span>
            <span class="s1">join_index</span><span class="s2">, </span><span class="s1">left_join_indexer</span><span class="s2">, </span><span class="s1">right_join_indexer</span><span class="s2">, </span><span class="s1">copy=copy</span>
        <span class="s1">)</span>
        <span class="s1">self._maybe_add_join_keys(result</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer)</span>

        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_asof_by_function(direction: str):</span>
    <span class="s1">name = </span><span class="s4">f&quot;asof_join_</span><span class="s2">{</span><span class="s1">direction</span><span class="s2">}</span><span class="s4">_on_X_by_Y&quot;</span>
    <span class="s2">return </span><span class="s1">getattr(libjoin</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, None</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">_AsOfMerge(_OrderedMerge):</span>
    <span class="s1">_merge_type = </span><span class="s4">&quot;asof_merge&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">left: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">right: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">left_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">right_on: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">left_index: bool = </span><span class="s2">False,</span>
        <span class="s1">right_index: bool = </span><span class="s2">False,</span>
        <span class="s1">by=</span><span class="s2">None,</span>
        <span class="s1">left_by=</span><span class="s2">None,</span>
        <span class="s1">right_by=</span><span class="s2">None,</span>
        <span class="s1">suffixes: Suffixes = (</span><span class="s4">&quot;_x&quot;</span><span class="s2">, </span><span class="s4">&quot;_y&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">how: Literal[</span><span class="s4">&quot;asof&quot;</span><span class="s1">] = </span><span class="s4">&quot;asof&quot;</span><span class="s2">,</span>
        <span class="s1">tolerance=</span><span class="s2">None,</span>
        <span class="s1">allow_exact_matches: bool = </span><span class="s2">True,</span>
        <span class="s1">direction: str = </span><span class="s4">&quot;backward&quot;</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.by = by</span>
        <span class="s1">self.left_by = left_by</span>
        <span class="s1">self.right_by = right_by</span>
        <span class="s1">self.tolerance = tolerance</span>
        <span class="s1">self.allow_exact_matches = allow_exact_matches</span>
        <span class="s1">self.direction = direction</span>

        <span class="s3"># check 'direction' is valid</span>
        <span class="s2">if </span><span class="s1">self.direction </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">&quot;backward&quot;</span><span class="s2">, </span><span class="s4">&quot;forward&quot;</span><span class="s2">, </span><span class="s4">&quot;nearest&quot;</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">f&quot;direction invalid: </span><span class="s2">{</span><span class="s1">self.direction</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s3"># validate allow_exact_matches</span>
        <span class="s2">if not </span><span class="s1">is_bool(self.allow_exact_matches):</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;allow_exact_matches must be boolean, &quot;</span>
                <span class="s4">f&quot;passed </span><span class="s2">{</span><span class="s1">self.allow_exact_matches</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">MergeError(msg)</span>

        <span class="s1">_OrderedMerge.__init__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">left</span><span class="s2">,</span>
            <span class="s1">right</span><span class="s2">,</span>
            <span class="s1">on=on</span><span class="s2">,</span>
            <span class="s1">left_on=left_on</span><span class="s2">,</span>
            <span class="s1">right_on=right_on</span><span class="s2">,</span>
            <span class="s1">left_index=left_index</span><span class="s2">,</span>
            <span class="s1">right_index=right_index</span><span class="s2">,</span>
            <span class="s1">how=how</span><span class="s2">,</span>
            <span class="s1">suffixes=suffixes</span><span class="s2">,</span>
            <span class="s1">fill_method=</span><span class="s2">None,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_validate_left_right_on(self</span><span class="s2">, </span><span class="s1">left_on</span><span class="s2">, </span><span class="s1">right_on):</span>
        <span class="s1">left_on</span><span class="s2">, </span><span class="s1">right_on = super()._validate_left_right_on(left_on</span><span class="s2">, </span><span class="s1">right_on)</span>

        <span class="s3"># we only allow on to be a single item for on</span>
        <span class="s2">if </span><span class="s1">len(left_on) != </span><span class="s5">1 </span><span class="s2">and not </span><span class="s1">self.left_index:</span>
            <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;can only asof on a key for left&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">len(right_on) != </span><span class="s5">1 </span><span class="s2">and not </span><span class="s1">self.right_index:</span>
            <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;can only asof on a key for right&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.left_index </span><span class="s2">and </span><span class="s1">isinstance(self.left.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;left can only have one index&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.right_index </span><span class="s2">and </span><span class="s1">isinstance(self.right.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;right can only have one index&quot;</span><span class="s1">)</span>

        <span class="s3"># set 'by' columns</span>
        <span class="s2">if </span><span class="s1">self.by </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.left_by </span><span class="s2">is not None or </span><span class="s1">self.right_by </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;Can only pass by OR left_by and right_by&quot;</span><span class="s1">)</span>
            <span class="s1">self.left_by = self.right_by = self.by</span>
        <span class="s2">if </span><span class="s1">self.left_by </span><span class="s2">is None and </span><span class="s1">self.right_by </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;missing left_by&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.left_by </span><span class="s2">is not None and </span><span class="s1">self.right_by </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;missing right_by&quot;</span><span class="s1">)</span>

        <span class="s3"># GH#29130 Check that merge keys do not have dtype object</span>
        <span class="s2">if not </span><span class="s1">self.left_index:</span>
            <span class="s1">left_on_0 = left_on[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">isinstance(left_on_0</span><span class="s2">, </span><span class="s1">_known):</span>
                <span class="s1">lo_dtype = left_on_0.dtype</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lo_dtype = (</span>
                    <span class="s1">self.left._get_label_or_level_values(left_on_0).dtype</span>
                    <span class="s2">if </span><span class="s1">left_on_0 </span><span class="s2">in </span><span class="s1">self.left.columns</span>
                    <span class="s2">else </span><span class="s1">self.left.index.get_level_values(left_on_0)</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lo_dtype = self.left.index.dtype</span>

        <span class="s2">if not </span><span class="s1">self.right_index:</span>
            <span class="s1">right_on_0 = right_on[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">isinstance(right_on_0</span><span class="s2">, </span><span class="s1">_known):</span>
                <span class="s1">ro_dtype = right_on_0.dtype</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ro_dtype = (</span>
                    <span class="s1">self.right._get_label_or_level_values(right_on_0).dtype</span>
                    <span class="s2">if </span><span class="s1">right_on_0 </span><span class="s2">in </span><span class="s1">self.right.columns</span>
                    <span class="s2">else </span><span class="s1">self.right.index.get_level_values(right_on_0)</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ro_dtype = self.right.index.dtype</span>

        <span class="s2">if </span><span class="s1">is_object_dtype(lo_dtype) </span><span class="s2">or </span><span class="s1">is_object_dtype(ro_dtype):</span>
            <span class="s2">raise </span><span class="s1">MergeError(</span>
                <span class="s4">f&quot;Incompatible merge dtype, </span><span class="s2">{</span><span class="s1">repr(ro_dtype)</span><span class="s2">} </span><span class="s4">and &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">repr(lo_dtype)</span><span class="s2">}</span><span class="s4">, both sides must have numeric dtype&quot;</span>
            <span class="s1">)</span>

        <span class="s3"># add 'by' to our key-list so we can have it in the</span>
        <span class="s3"># output as a key</span>
        <span class="s2">if </span><span class="s1">self.left_by </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">is_list_like(self.left_by):</span>
                <span class="s1">self.left_by = [self.left_by]</span>
            <span class="s2">if not </span><span class="s1">is_list_like(self.right_by):</span>
                <span class="s1">self.right_by = [self.right_by]</span>

            <span class="s2">if </span><span class="s1">len(self.left_by) != len(self.right_by):</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;left_by and right_by must be the same length&quot;</span><span class="s1">)</span>

            <span class="s1">left_on = self.left_by + list(left_on)</span>
            <span class="s1">right_on = self.right_by + list(right_on)</span>

        <span class="s2">return </span><span class="s1">left_on</span><span class="s2">, </span><span class="s1">right_on</span>

    <span class="s2">def </span><span class="s1">_maybe_require_matching_dtypes(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">left_join_keys: list[ArrayLike]</span><span class="s2">, </span><span class="s1">right_join_keys: list[ArrayLike]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># TODO: why do we do this for AsOfMerge but not the others?</span>

        <span class="s2">def </span><span class="s1">_check_dtype_match(left: ArrayLike</span><span class="s2">, </span><span class="s1">right: ArrayLike</span><span class="s2">, </span><span class="s1">i: int):</span>
            <span class="s2">if </span><span class="s1">left.dtype != right.dtype:</span>
                <span class="s2">if </span><span class="s1">isinstance(left.dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype) </span><span class="s2">and </span><span class="s1">isinstance(</span>
                    <span class="s1">right.dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype</span>
                <span class="s1">):</span>
                    <span class="s3"># The generic error message is confusing for categoricals.</span>
                    <span class="s3">#</span>
                    <span class="s3"># In this function, the join keys include both the original</span>
                    <span class="s3"># ones of the merge_asof() call, and also the keys passed</span>
                    <span class="s3"># to its by= argument. Unordered but equal categories</span>
                    <span class="s3"># are not supported for the former, but will fail</span>
                    <span class="s3"># later with a ValueError, so we don't *need* to check</span>
                    <span class="s3"># for them here.</span>
                    <span class="s1">msg = (</span>
                        <span class="s4">f&quot;incompatible merge keys [</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">] </span><span class="s2">{</span><span class="s1">repr(left.dtype)</span><span class="s2">} </span><span class="s4">and &quot;</span>
                        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">repr(right.dtype)</span><span class="s2">}</span><span class="s4">, both sides category, but not equal ones&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">msg = (</span>
                        <span class="s4">f&quot;incompatible merge keys [</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">] </span><span class="s2">{</span><span class="s1">repr(left.dtype)</span><span class="s2">} </span><span class="s4">and &quot;</span>
                        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">repr(right.dtype)</span><span class="s2">}</span><span class="s4">, must be the same type&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">MergeError(msg)</span>

        <span class="s3"># validate index types are the same</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(lk</span><span class="s2">, </span><span class="s1">rk) </span><span class="s2">in </span><span class="s1">enumerate(zip(left_join_keys</span><span class="s2">, </span><span class="s1">right_join_keys)):</span>
            <span class="s1">_check_dtype_match(lk</span><span class="s2">, </span><span class="s1">rk</span><span class="s2">, </span><span class="s1">i)</span>

        <span class="s2">if </span><span class="s1">self.left_index:</span>
            <span class="s1">lt = self.left.index._values</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lt = left_join_keys[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self.right_index:</span>
            <span class="s1">rt = self.right.index._values</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rt = right_join_keys[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">_check_dtype_match(lt</span><span class="s2">, </span><span class="s1">rt</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_validate_tolerance(self</span><span class="s2">, </span><span class="s1">left_join_keys: list[ArrayLike]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># validate tolerance; datetime.timedelta or Timedelta if we have a DTI</span>
        <span class="s2">if </span><span class="s1">self.tolerance </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.left_index:</span>
                <span class="s1">lt = self.left.index._values</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lt = left_join_keys[-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s1">msg = (</span>
                <span class="s4">f&quot;incompatible tolerance </span><span class="s2">{</span><span class="s1">self.tolerance</span><span class="s2">}</span><span class="s4">, must be compat &quot;</span>
                <span class="s4">f&quot;with type </span><span class="s2">{</span><span class="s1">repr(lt.dtype)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">needs_i8_conversion(lt.dtype):</span>
                <span class="s2">if not </span><span class="s1">isinstance(self.tolerance</span><span class="s2">, </span><span class="s1">datetime.timedelta):</span>
                    <span class="s2">raise </span><span class="s1">MergeError(msg)</span>
                <span class="s2">if </span><span class="s1">self.tolerance &lt; Timedelta(</span><span class="s5">0</span><span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;tolerance must be positive&quot;</span><span class="s1">)</span>

            <span class="s2">elif </span><span class="s1">is_integer_dtype(lt.dtype):</span>
                <span class="s2">if not </span><span class="s1">is_integer(self.tolerance):</span>
                    <span class="s2">raise </span><span class="s1">MergeError(msg)</span>
                <span class="s2">if </span><span class="s1">self.tolerance &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;tolerance must be positive&quot;</span><span class="s1">)</span>

            <span class="s2">elif </span><span class="s1">is_float_dtype(lt.dtype):</span>
                <span class="s2">if not </span><span class="s1">is_number(self.tolerance):</span>
                    <span class="s2">raise </span><span class="s1">MergeError(msg)</span>
                <span class="s3"># error: Unsupported operand types for &gt; (&quot;int&quot; and &quot;Number&quot;)</span>
                <span class="s2">if </span><span class="s1">self.tolerance &lt; </span><span class="s5">0</span><span class="s1">:  </span><span class="s3"># type: ignore[operator]</span>
                    <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;tolerance must be positive&quot;</span><span class="s1">)</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">MergeError(</span><span class="s4">&quot;key must be integer, timestamp or float&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_convert_values_for_libjoin(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">values: AnyArrayLike</span><span class="s2">, </span><span class="s1">side: str</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s3"># we require sortedness and non-null values in the join keys</span>
        <span class="s2">if not </span><span class="s1">Index(values).is_monotonic_increasing:</span>
            <span class="s2">if </span><span class="s1">isna(values).any():</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Merge keys contain null values on </span><span class="s2">{</span><span class="s1">side</span><span class="s2">} </span><span class="s4">side&quot;</span><span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">side</span><span class="s2">} </span><span class="s4">keys must be sorted&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">ArrowExtensionArray):</span>
            <span class="s1">values = values._maybe_convert_datelike_array()</span>

        <span class="s2">if </span><span class="s1">needs_i8_conversion(values.dtype):</span>
            <span class="s1">values = values.view(</span><span class="s4">&quot;i8&quot;</span><span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">BaseMaskedArray):</span>
            <span class="s3"># we've verified above that no nulls exist</span>
            <span class="s1">values = values._data</span>
        <span class="s2">elif </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">ExtensionArray):</span>
            <span class="s1">values = values.to_numpy()</span>

        <span class="s3"># error: Incompatible return value type (got &quot;Union[ExtensionArray,</span>
        <span class="s3"># Any, ndarray[Any, Any], ndarray[Any, dtype[Any]], Index, Series]&quot;,</span>
        <span class="s3"># expected &quot;ndarray[Any, Any]&quot;)</span>
        <span class="s2">return </span><span class="s1">values  </span><span class="s3"># type: ignore[return-value]</span>

    <span class="s2">def </span><span class="s1">_get_join_indexers(self) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
        <span class="s0">&quot;&quot;&quot;return the join indexers&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">flip(xs: list[ArrayLike]) -&gt; np.ndarray:</span>
            <span class="s0">&quot;&quot;&quot;unlike np.transpose, this returns an array of tuples&quot;&quot;&quot;</span>

            <span class="s2">def </span><span class="s1">injection(obj: ArrayLike):</span>
                <span class="s2">if not </span><span class="s1">isinstance(obj.dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
                    <span class="s3"># ndarray</span>
                    <span class="s2">return </span><span class="s1">obj</span>
                <span class="s1">obj = extract_array(obj)</span>
                <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">NDArrayBackedExtensionArray):</span>
                    <span class="s3"># fastpath for e.g. dt64tz, categorical</span>
                    <span class="s2">return </span><span class="s1">obj._ndarray</span>
                <span class="s3"># FIXME: returning obj._values_for_argsort() here doesn't</span>
                <span class="s3">#  break in any existing test cases, but i (@jbrockmendel)</span>
                <span class="s3">#  am pretty sure it should!</span>
                <span class="s3">#  e.g.</span>
                <span class="s3">#  arr = pd.array([0, pd.NA, 255], dtype=&quot;UInt8&quot;)</span>
                <span class="s3">#  will have values_for_argsort (before GH#45434)</span>
                <span class="s3">#  np.array([0, 255, 255], dtype=np.uint8)</span>
                <span class="s3">#  and the non-injectivity should make a difference somehow</span>
                <span class="s3">#  shouldn't it?</span>
                <span class="s2">return </span><span class="s1">np.asarray(obj)</span>

            <span class="s1">xs = [injection(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs]</span>
            <span class="s1">labels = list(string.ascii_lowercase[: len(xs)])</span>
            <span class="s1">dtypes = [x.dtype </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs]</span>
            <span class="s1">labeled_dtypes = list(zip(labels</span><span class="s2">, </span><span class="s1">dtypes))</span>
            <span class="s2">return </span><span class="s1">np.array(list(zip(*xs))</span><span class="s2">, </span><span class="s1">labeled_dtypes)</span>

        <span class="s3"># values to compare</span>
        <span class="s1">left_values = (</span>
            <span class="s1">self.left.index._values </span><span class="s2">if </span><span class="s1">self.left_index </span><span class="s2">else </span><span class="s1">self.left_join_keys[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">right_values = (</span>
            <span class="s1">self.right.index._values </span><span class="s2">if </span><span class="s1">self.right_index </span><span class="s2">else </span><span class="s1">self.right_join_keys[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s3"># _maybe_require_matching_dtypes already checked for dtype matching</span>
        <span class="s2">assert </span><span class="s1">left_values.dtype == right_values.dtype</span>

        <span class="s1">tolerance = self.tolerance</span>
        <span class="s2">if </span><span class="s1">tolerance </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># TODO: can we reuse a tolerance-conversion function from</span>
            <span class="s3">#  e.g. TimedeltaIndex?</span>
            <span class="s2">if </span><span class="s1">needs_i8_conversion(left_values.dtype):</span>
                <span class="s1">tolerance = Timedelta(tolerance)</span>
                <span class="s3"># TODO: we have no test cases with PeriodDtype here; probably</span>
                <span class="s3">#  need to adjust tolerance for that case.</span>
                <span class="s2">if </span><span class="s1">left_values.dtype.kind </span><span class="s2">in </span><span class="s4">&quot;mM&quot;</span><span class="s1">:</span>
                    <span class="s3"># Make sure the i8 representation for tolerance</span>
                    <span class="s3">#  matches that for left_values/right_values.</span>
                    <span class="s1">lvs = ensure_wrapped_if_datetimelike(left_values)</span>
                    <span class="s1">tolerance = tolerance.as_unit(lvs.unit)</span>

                <span class="s1">tolerance = tolerance._value</span>

        <span class="s3"># initial type conversion as needed</span>
        <span class="s1">left_values = self._convert_values_for_libjoin(left_values</span><span class="s2">, </span><span class="s4">&quot;left&quot;</span><span class="s1">)</span>
        <span class="s1">right_values = self._convert_values_for_libjoin(right_values</span><span class="s2">, </span><span class="s4">&quot;right&quot;</span><span class="s1">)</span>

        <span class="s3"># a &quot;by&quot; parameter requires special handling</span>
        <span class="s2">if </span><span class="s1">self.left_by </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># remove 'on' parameter from values if one existed</span>
            <span class="s2">if </span><span class="s1">self.left_index </span><span class="s2">and </span><span class="s1">self.right_index:</span>
                <span class="s1">left_by_values = self.left_join_keys</span>
                <span class="s1">right_by_values = self.right_join_keys</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">left_by_values = self.left_join_keys[</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">right_by_values = self.right_join_keys[</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s3"># get tuple representation of values if more than one</span>
            <span class="s2">if </span><span class="s1">len(left_by_values) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">lbv = left_by_values[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">rbv = right_by_values[</span><span class="s5">0</span><span class="s1">]</span>

                <span class="s3"># TODO: conversions for EAs that can be no-copy.</span>
                <span class="s1">lbv = np.asarray(lbv)</span>
                <span class="s1">rbv = np.asarray(rbv)</span>
                <span class="s2">if </span><span class="s1">needs_i8_conversion(lbv.dtype):</span>
                    <span class="s1">lbv = lbv.view(</span><span class="s4">&quot;i8&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">needs_i8_conversion(rbv.dtype):</span>
                    <span class="s1">rbv = rbv.view(</span><span class="s4">&quot;i8&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># We get here with non-ndarrays in test_merge_by_col_tz_aware</span>
                <span class="s3">#  and test_merge_groupby_multiple_column_with_categorical_column</span>
                <span class="s1">lbv = flip(left_by_values)</span>
                <span class="s1">rbv = flip(right_by_values)</span>
                <span class="s1">lbv = ensure_object(lbv)</span>
                <span class="s1">rbv = ensure_object(rbv)</span>

            <span class="s3"># error: Incompatible types in assignment (expression has type</span>
            <span class="s3"># &quot;Union[ndarray[Any, dtype[Any]], ndarray[Any, dtype[object_]]]&quot;,</span>
            <span class="s3"># variable has type &quot;List[Union[Union[ExtensionArray,</span>
            <span class="s3"># ndarray[Any, Any]], Index, Series]]&quot;)</span>
            <span class="s1">right_by_values = rbv  </span><span class="s3"># type: ignore[assignment]</span>
            <span class="s3"># error: Incompatible types in assignment (expression has type</span>
            <span class="s3"># &quot;Union[ndarray[Any, dtype[Any]], ndarray[Any, dtype[object_]]]&quot;,</span>
            <span class="s3"># variable has type &quot;List[Union[Union[ExtensionArray,</span>
            <span class="s3"># ndarray[Any, Any]], Index, Series]]&quot;)</span>
            <span class="s1">left_by_values = lbv  </span><span class="s3"># type: ignore[assignment]</span>

            <span class="s3"># choose appropriate function by type</span>
            <span class="s1">func = _asof_by_function(self.direction)</span>
            <span class="s2">return </span><span class="s1">func(</span>
                <span class="s1">left_values</span><span class="s2">,</span>
                <span class="s1">right_values</span><span class="s2">,</span>
                <span class="s1">left_by_values</span><span class="s2">,</span>
                <span class="s1">right_by_values</span><span class="s2">,</span>
                <span class="s1">self.allow_exact_matches</span><span class="s2">,</span>
                <span class="s1">tolerance</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># choose appropriate function by type</span>
            <span class="s1">func = _asof_by_function(self.direction)</span>
            <span class="s2">return </span><span class="s1">func(</span>
                <span class="s1">left_values</span><span class="s2">,</span>
                <span class="s1">right_values</span><span class="s2">,</span>
                <span class="s2">None,</span>
                <span class="s2">None,</span>
                <span class="s1">self.allow_exact_matches</span><span class="s2">,</span>
                <span class="s1">tolerance</span><span class="s2">,</span>
                <span class="s2">False,</span>
            <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_get_multiindex_indexer(</span>
    <span class="s1">join_keys: list[ArrayLike]</span><span class="s2">, </span><span class="s1">index: MultiIndex</span><span class="s2">, </span><span class="s1">sort: bool</span>
<span class="s1">) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
    <span class="s3"># left &amp; right join labels and num. of levels at each location</span>
    <span class="s1">mapped = (</span>
        <span class="s1">_factorize_keys(index.levels[n]._values</span><span class="s2">, </span><span class="s1">join_keys[n]</span><span class="s2">, </span><span class="s1">sort=sort)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(index.nlevels)</span>
    <span class="s1">)</span>
    <span class="s1">zipped = zip(*mapped)</span>
    <span class="s1">rcodes</span><span class="s2">, </span><span class="s1">lcodes</span><span class="s2">, </span><span class="s1">shape = (list(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">zipped)</span>
    <span class="s2">if </span><span class="s1">sort:</span>
        <span class="s1">rcodes = list(map(np.take</span><span class="s2">, </span><span class="s1">rcodes</span><span class="s2">, </span><span class="s1">index.codes))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">i8copy = </span><span class="s2">lambda </span><span class="s1">a: a.astype(</span><span class="s4">&quot;i8&quot;</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">False, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">rcodes = list(map(i8copy</span><span class="s2">, </span><span class="s1">index.codes))</span>

    <span class="s3"># fix right labels if there were any nulls</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">join_key </span><span class="s2">in </span><span class="s1">enumerate(join_keys):</span>
        <span class="s1">mask = index.codes[i] == -</span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">mask.any():</span>
            <span class="s3"># check if there already was any nulls at this location</span>
            <span class="s3"># if there was, it is factorized to `shape[i] - 1`</span>
            <span class="s1">a = join_key[lcodes[i] == shape[i] - </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">a.size == </span><span class="s5">0 </span><span class="s2">or not </span><span class="s1">a[</span><span class="s5">0</span><span class="s1">] != a[</span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s1">shape[i] += </span><span class="s5">1</span>

            <span class="s1">rcodes[i][mask] = shape[i] - </span><span class="s5">1</span>

    <span class="s3"># get flat i8 join keys</span>
    <span class="s1">lkey</span><span class="s2">, </span><span class="s1">rkey = _get_join_keys(lcodes</span><span class="s2">, </span><span class="s1">rcodes</span><span class="s2">, </span><span class="s1">tuple(shape)</span><span class="s2">, </span><span class="s1">sort)</span>
    <span class="s2">return </span><span class="s1">lkey</span><span class="s2">, </span><span class="s1">rkey</span>


<span class="s2">def </span><span class="s1">_get_empty_indexer() -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
    <span class="s0">&quot;&quot;&quot;Return empty join indexers.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span><span class="s2">,</span>
        <span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_get_no_sort_one_missing_indexer(</span>
    <span class="s1">n: int</span><span class="s2">, </span><span class="s1">left_missing: bool</span>
<span class="s1">) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return join indexers where all of one side is selected without sorting 
    and none of the other side is selected. 
 
    Parameters 
    ---------- 
    n : int 
        Length of indexers to create. 
    left_missing : bool 
        If True, the left indexer will contain only -1's. 
        If False, the right indexer will contain only -1's. 
 
    Returns 
    ------- 
    np.ndarray[np.intp] 
        Left indexer 
    np.ndarray[np.intp] 
        Right indexer 
    &quot;&quot;&quot;</span>
    <span class="s1">idx = np.arange(n</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>
    <span class="s1">idx_missing = np.full(shape=n</span><span class="s2">, </span><span class="s1">fill_value=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>
    <span class="s2">if </span><span class="s1">left_missing:</span>
        <span class="s2">return </span><span class="s1">idx_missing</span><span class="s2">, </span><span class="s1">idx</span>
    <span class="s2">return </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">idx_missing</span>


<span class="s2">def </span><span class="s1">_left_join_on_index(</span>
    <span class="s1">left_ax: Index</span><span class="s2">, </span><span class="s1">right_ax: Index</span><span class="s2">, </span><span class="s1">join_keys: list[ArrayLike]</span><span class="s2">, </span><span class="s1">sort: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; tuple[Index</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp] | </span><span class="s2">None, </span><span class="s1">npt.NDArray[np.intp]]:</span>
    <span class="s2">if </span><span class="s1">isinstance(right_ax</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
        <span class="s1">lkey</span><span class="s2">, </span><span class="s1">rkey = _get_multiindex_indexer(join_keys</span><span class="s2">, </span><span class="s1">right_ax</span><span class="s2">, </span><span class="s1">sort=sort)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># error: Incompatible types in assignment (expression has type</span>
        <span class="s3"># &quot;Union[Union[ExtensionArray, ndarray[Any, Any]], Index, Series]&quot;,</span>
        <span class="s3"># variable has type &quot;ndarray[Any, dtype[signedinteger[Any]]]&quot;)</span>
        <span class="s1">lkey = join_keys[</span><span class="s5">0</span><span class="s1">]  </span><span class="s3"># type: ignore[assignment]</span>
        <span class="s3"># error: Incompatible types in assignment (expression has type &quot;Index&quot;,</span>
        <span class="s3"># variable has type &quot;ndarray[Any, dtype[signedinteger[Any]]]&quot;)</span>
        <span class="s1">rkey = right_ax._values  </span><span class="s3"># type: ignore[assignment]</span>

    <span class="s1">left_key</span><span class="s2">, </span><span class="s1">right_key</span><span class="s2">, </span><span class="s1">count = _factorize_keys(lkey</span><span class="s2">, </span><span class="s1">rkey</span><span class="s2">, </span><span class="s1">sort=sort)</span>
    <span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer = libjoin.left_outer_join(</span>
        <span class="s1">left_key</span><span class="s2">, </span><span class="s1">right_key</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">sort=sort</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">sort </span><span class="s2">or </span><span class="s1">len(left_ax) != len(left_indexer):</span>
        <span class="s3"># if asked to sort or there are 1-to-many matches</span>
        <span class="s1">join_index = left_ax.take(left_indexer)</span>
        <span class="s2">return </span><span class="s1">join_index</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">right_indexer</span>

    <span class="s3"># left frame preserves order &amp; length of its index</span>
    <span class="s2">return </span><span class="s1">left_ax</span><span class="s2">, None, </span><span class="s1">right_indexer</span>


<span class="s2">def </span><span class="s1">_factorize_keys(</span>
    <span class="s1">lk: ArrayLike</span><span class="s2">,</span>
    <span class="s1">rk: ArrayLike</span><span class="s2">,</span>
    <span class="s1">sort: bool = </span><span class="s2">True,</span>
    <span class="s1">how: MergeHow | Literal[</span><span class="s4">&quot;asof&quot;</span><span class="s1">] = </span><span class="s4">&quot;inner&quot;</span><span class="s2">,</span>
<span class="s1">) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">int]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Encode left and right keys as enumerated types. 
 
    This is used to get the join indexers to be used when merging DataFrames. 
 
    Parameters 
    ---------- 
    lk : ndarray, ExtensionArray 
        Left key. 
    rk : ndarray, ExtensionArray 
        Right key. 
    sort : bool, defaults to True 
        If True, the encoding is done such that the unique elements in the 
        keys are sorted. 
    how : {'left', 'right', 'outer', 'inner'}, default 'inner' 
        Type of merge. 
 
    Returns 
    ------- 
    np.ndarray[np.intp] 
        Left (resp. right if called with `key='right'`) labels, as enumerated type. 
    np.ndarray[np.intp] 
        Right (resp. left if called with `key='right'`) labels, as enumerated type. 
    int 
        Number of unique elements in union of left and right labels. 
 
    See Also 
    -------- 
    merge : Merge DataFrame or named Series objects 
        with a database-style join. 
    algorithms.factorize : Encode the object as an enumerated type 
        or categorical variable. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; lk = np.array([&quot;a&quot;, &quot;c&quot;, &quot;b&quot;]) 
    &gt;&gt;&gt; rk = np.array([&quot;a&quot;, &quot;c&quot;]) 
 
    Here, the unique values are `'a', 'b', 'c'`. With the default 
    `sort=True`, the encoding will be `{0: 'a', 1: 'b', 2: 'c'}`: 
 
    &gt;&gt;&gt; pd.core.reshape.merge._factorize_keys(lk, rk) 
    (array([0, 2, 1]), array([0, 2]), 3) 
 
    With the `sort=False`, the encoding will correspond to the order 
    in which the unique elements first appear: `{0: 'a', 1: 'c', 2: 'b'}`: 
 
    &gt;&gt;&gt; pd.core.reshape.merge._factorize_keys(lk, rk, sort=False) 
    (array([0, 1, 2]), array([0, 1]), 3) 
    &quot;&quot;&quot;</span>
    <span class="s3"># TODO: if either is a RangeIndex, we can likely factorize more efficiently?</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype) </span><span class="s2">and </span><span class="s1">isinstance(rk.dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype)</span>
    <span class="s1">) </span><span class="s2">or </span><span class="s1">(lib.is_np_dtype(lk.dtype</span><span class="s2">, </span><span class="s4">&quot;M&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">lib.is_np_dtype(rk.dtype</span><span class="s2">, </span><span class="s4">&quot;M&quot;</span><span class="s1">)):</span>
        <span class="s3"># Extract the ndarray (UTC-localized) values</span>
        <span class="s3"># Note: we dont need the dtypes to match, as these can still be compared</span>
        <span class="s1">lk</span><span class="s2">, </span><span class="s1">rk = cast(</span><span class="s4">&quot;DatetimeArray&quot;</span><span class="s2">, </span><span class="s1">lk)._ensure_matching_resos(rk)</span>
        <span class="s1">lk = cast(</span><span class="s4">&quot;DatetimeArray&quot;</span><span class="s2">, </span><span class="s1">lk)._ndarray</span>
        <span class="s1">rk = cast(</span><span class="s4">&quot;DatetimeArray&quot;</span><span class="s2">, </span><span class="s1">rk)._ndarray</span>

    <span class="s2">elif </span><span class="s1">(</span>
        <span class="s1">isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype)</span>
        <span class="s2">and </span><span class="s1">isinstance(rk.dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype)</span>
        <span class="s2">and </span><span class="s1">lk.dtype == rk.dtype</span>
    <span class="s1">):</span>
        <span class="s2">assert </span><span class="s1">isinstance(lk</span><span class="s2">, </span><span class="s1">Categorical)</span>
        <span class="s2">assert </span><span class="s1">isinstance(rk</span><span class="s2">, </span><span class="s1">Categorical)</span>
        <span class="s3"># Cast rk to encoding so we can compare codes with lk</span>

        <span class="s1">rk = lk._encode_with_my_categories(rk)</span>

        <span class="s1">lk = ensure_int64(lk.codes)</span>
        <span class="s1">rk = ensure_int64(rk.codes)</span>

    <span class="s2">elif </span><span class="s1">isinstance(lk</span><span class="s2">, </span><span class="s1">ExtensionArray) </span><span class="s2">and </span><span class="s1">lk.dtype == rk.dtype:</span>
        <span class="s2">if </span><span class="s1">(isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">ArrowDtype) </span><span class="s2">and </span><span class="s1">is_string_dtype(lk.dtype)) </span><span class="s2">or </span><span class="s1">(</span>
            <span class="s1">isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">StringDtype)</span>
            <span class="s2">and </span><span class="s1">lk.dtype.storage </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;pyarrow&quot;</span><span class="s2">, </span><span class="s4">&quot;pyarrow_numpy&quot;</span><span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s2">import </span><span class="s1">pyarrow </span><span class="s2">as </span><span class="s1">pa</span>
            <span class="s2">import </span><span class="s1">pyarrow.compute </span><span class="s2">as </span><span class="s1">pc</span>

            <span class="s1">len_lk = len(lk)</span>
            <span class="s1">lk = lk._pa_array  </span><span class="s3"># type: ignore[attr-defined]</span>
            <span class="s1">rk = rk._pa_array  </span><span class="s3"># type: ignore[union-attr]</span>
            <span class="s1">dc = (</span>
                <span class="s1">pa.chunked_array(lk.chunks + rk.chunks)  </span><span class="s3"># type: ignore[union-attr]</span>
                <span class="s1">.combine_chunks()</span>
                <span class="s1">.dictionary_encode()</span>
            <span class="s1">)</span>
            <span class="s1">length = len(dc.dictionary)</span>

            <span class="s1">llab</span><span class="s2">, </span><span class="s1">rlab</span><span class="s2">, </span><span class="s1">count = (</span>
                <span class="s1">pc.fill_null(dc.indices[slice(len_lk)]</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s1">.to_numpy()</span>
                <span class="s1">.astype(np.intp</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">pc.fill_null(dc.indices[slice(len_lk</span><span class="s2">, None</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">length)</span>
                <span class="s1">.to_numpy()</span>
                <span class="s1">.astype(np.intp</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">len(dc.dictionary)</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">dc.null_count &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">count += </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">how == </span><span class="s4">&quot;right&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">rlab</span><span class="s2">, </span><span class="s1">llab</span><span class="s2">, </span><span class="s1">count</span>
            <span class="s2">return </span><span class="s1">llab</span><span class="s2">, </span><span class="s1">rlab</span><span class="s2">, </span><span class="s1">count</span>

        <span class="s2">if not </span><span class="s1">isinstance(lk</span><span class="s2">, </span><span class="s1">BaseMaskedArray) </span><span class="s2">and not </span><span class="s1">(</span>
            <span class="s3"># exclude arrow dtypes that would get cast to object</span>
            <span class="s1">isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">ArrowDtype)</span>
            <span class="s2">and </span><span class="s1">(</span>
                <span class="s1">is_numeric_dtype(lk.dtype.numpy_dtype)</span>
                <span class="s2">or </span><span class="s1">is_string_dtype(lk.dtype)</span>
                <span class="s2">and not </span><span class="s1">sort</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">lk</span><span class="s2">, </span><span class="s1">_ = lk._values_for_factorize()</span>

            <span class="s3"># error: Item &quot;ndarray&quot; of &quot;Union[Any, ndarray]&quot; has no attribute</span>
            <span class="s3"># &quot;_values_for_factorize&quot;</span>
            <span class="s1">rk</span><span class="s2">, </span><span class="s1">_ = rk._values_for_factorize()  </span><span class="s3"># type: ignore[union-attr]</span>

    <span class="s2">if </span><span class="s1">needs_i8_conversion(lk.dtype) </span><span class="s2">and </span><span class="s1">lk.dtype == rk.dtype:</span>
        <span class="s3"># GH#23917 TODO: Needs tests for non-matching dtypes</span>
        <span class="s3"># GH#23917 TODO: needs tests for case where lk is integer-dtype</span>
        <span class="s3">#  and rk is datetime-dtype</span>
        <span class="s1">lk = np.asarray(lk</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s1">rk = np.asarray(rk</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span>

    <span class="s1">klass</span><span class="s2">, </span><span class="s1">lk</span><span class="s2">, </span><span class="s1">rk = _convert_arrays_and_get_rizer_klass(lk</span><span class="s2">, </span><span class="s1">rk)</span>

    <span class="s1">rizer = klass(max(len(lk)</span><span class="s2">, </span><span class="s1">len(rk)))</span>

    <span class="s2">if </span><span class="s1">isinstance(lk</span><span class="s2">, </span><span class="s1">BaseMaskedArray):</span>
        <span class="s2">assert </span><span class="s1">isinstance(rk</span><span class="s2">, </span><span class="s1">BaseMaskedArray)</span>
        <span class="s1">llab = rizer.factorize(lk._data</span><span class="s2">, </span><span class="s1">mask=lk._mask)</span>
        <span class="s1">rlab = rizer.factorize(rk._data</span><span class="s2">, </span><span class="s1">mask=rk._mask)</span>
    <span class="s2">elif </span><span class="s1">isinstance(lk</span><span class="s2">, </span><span class="s1">ArrowExtensionArray):</span>
        <span class="s2">assert </span><span class="s1">isinstance(rk</span><span class="s2">, </span><span class="s1">ArrowExtensionArray)</span>
        <span class="s3"># we can only get here with numeric dtypes</span>
        <span class="s3"># TODO: Remove when we have a Factorizer for Arrow</span>
        <span class="s1">llab = rizer.factorize(</span>
            <span class="s1">lk.to_numpy(na_value=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=lk.dtype.numpy_dtype)</span><span class="s2">, </span><span class="s1">mask=lk.isna()</span>
        <span class="s1">)</span>
        <span class="s1">rlab = rizer.factorize(</span>
            <span class="s1">rk.to_numpy(na_value=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=lk.dtype.numpy_dtype)</span><span class="s2">, </span><span class="s1">mask=rk.isna()</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Argument 1 to &quot;factorize&quot; of &quot;ObjectFactorizer&quot; has incompatible type</span>
        <span class="s3"># &quot;Union[ndarray[Any, dtype[signedinteger[_64Bit]]],</span>
        <span class="s3"># ndarray[Any, dtype[object_]]]&quot;; expected &quot;ndarray[Any, dtype[object_]]&quot;</span>
        <span class="s1">llab = rizer.factorize(lk)  </span><span class="s3"># type: ignore[arg-type]</span>
        <span class="s1">rlab = rizer.factorize(rk)  </span><span class="s3"># type: ignore[arg-type]</span>
    <span class="s2">assert </span><span class="s1">llab.dtype == np.dtype(np.intp)</span><span class="s2">, </span><span class="s1">llab.dtype</span>
    <span class="s2">assert </span><span class="s1">rlab.dtype == np.dtype(np.intp)</span><span class="s2">, </span><span class="s1">rlab.dtype</span>

    <span class="s1">count = rizer.get_count()</span>

    <span class="s2">if </span><span class="s1">sort:</span>
        <span class="s1">uniques = rizer.uniques.to_array()</span>
        <span class="s1">llab</span><span class="s2">, </span><span class="s1">rlab = _sort_labels(uniques</span><span class="s2">, </span><span class="s1">llab</span><span class="s2">, </span><span class="s1">rlab)</span>

    <span class="s3"># NA group</span>
    <span class="s1">lmask = llab == -</span><span class="s5">1</span>
    <span class="s1">lany = lmask.any()</span>
    <span class="s1">rmask = rlab == -</span><span class="s5">1</span>
    <span class="s1">rany = rmask.any()</span>

    <span class="s2">if </span><span class="s1">lany </span><span class="s2">or </span><span class="s1">rany:</span>
        <span class="s2">if </span><span class="s1">lany:</span>
            <span class="s1">np.putmask(llab</span><span class="s2">, </span><span class="s1">lmask</span><span class="s2">, </span><span class="s1">count)</span>
        <span class="s2">if </span><span class="s1">rany:</span>
            <span class="s1">np.putmask(rlab</span><span class="s2">, </span><span class="s1">rmask</span><span class="s2">, </span><span class="s1">count)</span>
        <span class="s1">count += </span><span class="s5">1</span>

    <span class="s2">if </span><span class="s1">how == </span><span class="s4">&quot;right&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">rlab</span><span class="s2">, </span><span class="s1">llab</span><span class="s2">, </span><span class="s1">count</span>
    <span class="s2">return </span><span class="s1">llab</span><span class="s2">, </span><span class="s1">rlab</span><span class="s2">, </span><span class="s1">count</span>


<span class="s2">def </span><span class="s1">_convert_arrays_and_get_rizer_klass(</span>
    <span class="s1">lk: ArrayLike</span><span class="s2">, </span><span class="s1">rk: ArrayLike</span>
<span class="s1">) -&gt; tuple[type[libhashtable.Factorizer]</span><span class="s2">, </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">ArrayLike]:</span>
    <span class="s1">klass: type[libhashtable.Factorizer]</span>
    <span class="s2">if </span><span class="s1">is_numeric_dtype(lk.dtype):</span>
        <span class="s2">if </span><span class="s1">lk.dtype != rk.dtype:</span>
            <span class="s1">dtype = find_common_type([lk.dtype</span><span class="s2">, </span><span class="s1">rk.dtype])</span>
            <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
                <span class="s1">cls = dtype.construct_array_type()</span>
                <span class="s2">if not </span><span class="s1">isinstance(lk</span><span class="s2">, </span><span class="s1">ExtensionArray):</span>
                    <span class="s1">lk = cls._from_sequence(lk</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">lk = lk.astype(dtype)</span>

                <span class="s2">if not </span><span class="s1">isinstance(rk</span><span class="s2">, </span><span class="s1">ExtensionArray):</span>
                    <span class="s1">rk = cls._from_sequence(rk</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">rk = rk.astype(dtype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lk = lk.astype(dtype)</span>
                <span class="s1">rk = rk.astype(dtype)</span>
        <span class="s2">if </span><span class="s1">isinstance(lk</span><span class="s2">, </span><span class="s1">BaseMaskedArray):</span>
            <span class="s3">#  Invalid index type &quot;type&quot; for &quot;Dict[Type[object], Type[Factorizer]]&quot;;</span>
            <span class="s3">#  expected type &quot;Type[object]&quot;</span>
            <span class="s1">klass = _factorizers[lk.dtype.type]  </span><span class="s3"># type: ignore[index]</span>
        <span class="s2">elif </span><span class="s1">isinstance(lk.dtype</span><span class="s2">, </span><span class="s1">ArrowDtype):</span>
            <span class="s1">klass = _factorizers[lk.dtype.numpy_dtype.type]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">klass = _factorizers[lk.dtype.type]</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">klass = libhashtable.ObjectFactorizer</span>
        <span class="s1">lk = ensure_object(lk)</span>
        <span class="s1">rk = ensure_object(rk)</span>
    <span class="s2">return </span><span class="s1">klass</span><span class="s2">, </span><span class="s1">lk</span><span class="s2">, </span><span class="s1">rk</span>


<span class="s2">def </span><span class="s1">_sort_labels(</span>
    <span class="s1">uniques: np.ndarray</span><span class="s2">, </span><span class="s1">left: npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">right: npt.NDArray[np.intp]</span>
<span class="s1">) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
    <span class="s1">llength = len(left)</span>
    <span class="s1">labels = np.concatenate([left</span><span class="s2">, </span><span class="s1">right])</span>

    <span class="s1">_</span><span class="s2">, </span><span class="s1">new_labels = algos.safe_sort(uniques</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">use_na_sentinel=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">new_left</span><span class="s2">, </span><span class="s1">new_right = new_labels[:llength]</span><span class="s2">, </span><span class="s1">new_labels[llength:]</span>

    <span class="s2">return </span><span class="s1">new_left</span><span class="s2">, </span><span class="s1">new_right</span>


<span class="s2">def </span><span class="s1">_get_join_keys(</span>
    <span class="s1">llab: list[npt.NDArray[np.int64 | np.intp]]</span><span class="s2">,</span>
    <span class="s1">rlab: list[npt.NDArray[np.int64 | np.intp]]</span><span class="s2">,</span>
    <span class="s1">shape: Shape</span><span class="s2">,</span>
    <span class="s1">sort: bool</span><span class="s2">,</span>
<span class="s1">) -&gt; tuple[npt.NDArray[np.int64]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.int64]]:</span>
    <span class="s3"># how many levels can be done without overflow</span>
    <span class="s1">nlev = next(</span>
        <span class="s1">lev</span>
        <span class="s2">for </span><span class="s1">lev </span><span class="s2">in </span><span class="s1">range(len(shape)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">is_int64_overflow_possible(shape[:lev])</span>
    <span class="s1">)</span>

    <span class="s3"># get keys for the first `nlev` levels</span>
    <span class="s1">stride = np.prod(shape[</span><span class="s5">1</span><span class="s1">:nlev]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s4">&quot;i8&quot;</span><span class="s1">)</span>
    <span class="s1">lkey = stride * llab[</span><span class="s5">0</span><span class="s1">].astype(</span><span class="s4">&quot;i8&quot;</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">False, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">rkey = stride * rlab[</span><span class="s5">0</span><span class="s1">].astype(</span><span class="s4">&quot;i8&quot;</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">False, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">nlev):</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">stride //= shape[i]</span>
        <span class="s1">lkey += llab[i] * stride</span>
        <span class="s1">rkey += rlab[i] * stride</span>

    <span class="s2">if </span><span class="s1">nlev == len(shape):  </span><span class="s3"># all done!</span>
        <span class="s2">return </span><span class="s1">lkey</span><span class="s2">, </span><span class="s1">rkey</span>

    <span class="s3"># densify current keys to avoid overflow</span>
    <span class="s1">lkey</span><span class="s2">, </span><span class="s1">rkey</span><span class="s2">, </span><span class="s1">count = _factorize_keys(lkey</span><span class="s2">, </span><span class="s1">rkey</span><span class="s2">, </span><span class="s1">sort=sort)</span>

    <span class="s1">llab = [lkey] + llab[nlev:]</span>
    <span class="s1">rlab = [rkey] + rlab[nlev:]</span>
    <span class="s1">shape = (count</span><span class="s2">,</span><span class="s1">) + shape[nlev:]</span>

    <span class="s2">return </span><span class="s1">_get_join_keys(llab</span><span class="s2">, </span><span class="s1">rlab</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">sort)</span>


<span class="s2">def </span><span class="s1">_should_fill(lname</span><span class="s2">, </span><span class="s1">rname) -&gt; bool:</span>
    <span class="s2">if not </span><span class="s1">isinstance(lname</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or not </span><span class="s1">isinstance(rname</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return True</span>
    <span class="s2">return </span><span class="s1">lname == rname</span>


<span class="s2">def </span><span class="s1">_any(x) -&gt; bool:</span>
    <span class="s2">return </span><span class="s1">x </span><span class="s2">is not None and </span><span class="s1">com.any_not_none(*x)</span>


<span class="s2">def </span><span class="s1">_validate_operand(obj: DataFrame | Series) -&gt; DataFrame:</span>
    <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">ABCDataFrame):</span>
        <span class="s2">return </span><span class="s1">obj</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">ABCSeries):</span>
        <span class="s2">if </span><span class="s1">obj.name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Cannot merge a Series without a name&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">obj.to_frame()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s4">f&quot;Can only merge Series or DataFrame objects, a </span><span class="s2">{</span><span class="s1">type(obj)</span><span class="s2">} </span><span class="s4">was passed&quot;</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_items_overlap_with_suffix(</span>
    <span class="s1">left: Index</span><span class="s2">, </span><span class="s1">right: Index</span><span class="s2">, </span><span class="s1">suffixes: Suffixes</span>
<span class="s1">) -&gt; tuple[Index</span><span class="s2">, </span><span class="s1">Index]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Suffixes type validation. 
 
    If two indices overlap, add suffixes to overlapping entries. 
 
    If corresponding suffix is empty, the entry is simply converted to string. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">is_list_like(suffixes</span><span class="s2">, </span><span class="s1">allow_sets=</span><span class="s2">False</span><span class="s1">) </span><span class="s2">or </span><span class="s1">isinstance(suffixes</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s4">f&quot;Passing 'suffixes' as a </span><span class="s2">{</span><span class="s1">type(suffixes)</span><span class="s2">}</span><span class="s4">, is not supported. &quot;</span>
            <span class="s4">&quot;Provide 'suffixes' as a tuple instead.&quot;</span>
        <span class="s1">)</span>

    <span class="s1">to_rename = left.intersection(right)</span>
    <span class="s2">if </span><span class="s1">len(to_rename) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span>

    <span class="s1">lsuffix</span><span class="s2">, </span><span class="s1">rsuffix = suffixes</span>

    <span class="s2">if not </span><span class="s1">lsuffix </span><span class="s2">and not </span><span class="s1">rsuffix:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;columns overlap but no suffix specified: </span><span class="s2">{</span><span class="s1">to_rename</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">renamer(x</span><span class="s2">, </span><span class="s1">suffix: str | </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Rename the left and right indices. 
 
        If there is overlap, and suffix is not None, add 
        suffix, otherwise, leave it as-is. 
 
        Parameters 
        ---------- 
        x : original column name 
        suffix : str or None 
 
        Returns 
        ------- 
        x : renamed column name 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">in </span><span class="s1">to_rename </span><span class="s2">and </span><span class="s1">suffix </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">x</span><span class="s2">}{</span><span class="s1">suffix</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s1">lrenamer = partial(renamer</span><span class="s2">, </span><span class="s1">suffix=lsuffix)</span>
    <span class="s1">rrenamer = partial(renamer</span><span class="s2">, </span><span class="s1">suffix=rsuffix)</span>

    <span class="s1">llabels = left._transform_index(lrenamer)</span>
    <span class="s1">rlabels = right._transform_index(rrenamer)</span>

    <span class="s1">dups = []</span>
    <span class="s2">if not </span><span class="s1">llabels.is_unique:</span>
        <span class="s3"># Only warn when duplicates are caused because of suffixes, already duplicated</span>
        <span class="s3"># columns in origin should not warn</span>
        <span class="s1">dups = llabels[(llabels.duplicated()) &amp; (~left.duplicated())].tolist()</span>
    <span class="s2">if not </span><span class="s1">rlabels.is_unique:</span>
        <span class="s1">dups.extend(rlabels[(rlabels.duplicated()) &amp; (~right.duplicated())].tolist())</span>
    <span class="s2">if </span><span class="s1">dups:</span>
        <span class="s2">raise </span><span class="s1">MergeError(</span>
            <span class="s4">f&quot;Passing 'suffixes' which cause duplicate columns </span><span class="s2">{</span><span class="s1">set(dups)</span><span class="s2">} </span><span class="s4">is &quot;</span>
            <span class="s4">f&quot;not allowed.&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">llabels</span><span class="s2">, </span><span class="s1">rlabels</span>
</pre>
</body>
</html>