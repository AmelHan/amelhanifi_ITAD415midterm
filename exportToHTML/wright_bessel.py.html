<html>
<head>
<title>wright_bessel.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wright_bessel.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Precompute coefficients of several series expansions 
of Wright's generalized Bessel function Phi(a, b, x). 
 
See https://dlmf.nist.gov/10.46.E1 with rho=a, beta=b, z=x. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">argparse </span><span class="s2">import </span><span class="s1">ArgumentParser</span><span class="s2">, </span><span class="s1">RawTextHelpFormatter</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy.integrate </span><span class="s2">import </span><span class="s1">quad</span>
<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">minimize_scalar</span><span class="s2">, </span><span class="s1">curve_fit</span>
<span class="s2">from </span><span class="s1">time </span><span class="s2">import </span><span class="s1">time</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">sympy</span>
    <span class="s2">from </span><span class="s1">sympy </span><span class="s2">import </span><span class="s1">EulerGamma</span><span class="s2">, </span><span class="s1">Rational</span><span class="s2">, </span><span class="s1">S</span><span class="s2">, </span><span class="s1">Sum</span><span class="s2">, </span><span class="s1">\</span>
        <span class="s1">factorial</span><span class="s2">, </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">gammasimp</span><span class="s2">, </span><span class="s1">pi</span><span class="s2">, </span><span class="s1">polygamma</span><span class="s2">, </span><span class="s1">symbols</span><span class="s2">, </span><span class="s1">zeta</span>
    <span class="s2">from </span><span class="s1">sympy.polys.polyfuncs </span><span class="s2">import </span><span class="s1">horner</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">series_small_a():</span>
    <span class="s0">&quot;&quot;&quot;Tylor series expansion of Phi(a, b, x) in a=0 up to order 5. 
    &quot;&quot;&quot;</span>
    <span class="s1">order = </span><span class="s3">5</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">k = symbols(</span><span class="s4">&quot;a b x k&quot;</span><span class="s1">)</span>
    <span class="s1">A = []  </span><span class="s5"># terms with a</span>
    <span class="s1">X = []  </span><span class="s5"># terms with x</span>
    <span class="s1">B = []  </span><span class="s5"># terms with b (polygammas)</span>
    <span class="s5"># Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i])</span>
    <span class="s1">expression = Sum(x**k/factorial(k)/gamma(a*k+b)</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">S.Infinity))</span>
    <span class="s1">expression = gamma(b)/sympy.exp(x) * expression</span>

    <span class="s5"># nth term of taylor series in a=0: a^n/n! * (d^n Phi(a, b, x)/da^n at a=0)</span>
    <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">order+</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">term = expression.diff(a</span><span class="s2">, </span><span class="s1">n).subs(a</span><span class="s2">, </span><span class="s3">0</span><span class="s1">).simplify().doit()</span>
        <span class="s5"># set the whole bracket involving polygammas to 1</span>
        <span class="s1">x_part = (term.subs(polygamma(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
                  <span class="s1">.replace(polygamma</span><span class="s2">, lambda </span><span class="s1">*args: </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s5"># sign convetion: x part always positive</span>
        <span class="s1">x_part *= (-</span><span class="s3">1</span><span class="s1">)**n</span>

        <span class="s1">A.append(a**n/factorial(n))</span>
        <span class="s1">X.append(horner(x_part))</span>
        <span class="s1">B.append(horner((term/x_part).simplify()))</span>

    <span class="s1">s = </span><span class="s4">&quot;Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i], i=0..5)</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">zip([</span><span class="s4">'A'</span><span class="s2">, </span><span class="s4">'X'</span><span class="s2">, </span><span class="s4">'B'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[A</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">B]):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(c)):</span>
            <span class="s1">s += </span><span class="s4">f&quot;</span><span class="s2">\n{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">] = &quot; </span><span class="s1">+ str(c[i])</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s5"># expansion of digamma</span>
<span class="s2">def </span><span class="s1">dg_series(z</span><span class="s2">, </span><span class="s1">n):</span>
    <span class="s0">&quot;&quot;&quot;Symbolic expansion of digamma(z) in z=0 to order n. 
 
    See https://dlmf.nist.gov/5.7.E4 and with https://dlmf.nist.gov/5.5.E2 
    &quot;&quot;&quot;</span>
    <span class="s1">k = symbols(</span><span class="s4">&quot;k&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s3">1</span><span class="s1">/z - EulerGamma + \</span>
        <span class="s1">sympy.summation((-</span><span class="s3">1</span><span class="s1">)**k * zeta(k) * z**(k-</span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">n+</span><span class="s3">1</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">pg_series(k</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">n):</span>
    <span class="s0">&quot;&quot;&quot;Symbolic expansion of polygamma(k, z) in z=0 to order n.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">sympy.diff(dg_series(z</span><span class="s2">, </span><span class="s1">n+k)</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">k)</span>


<span class="s2">def </span><span class="s1">series_small_a_small_b():</span>
    <span class="s0">&quot;&quot;&quot;Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5. 
 
    Be aware of cancellation of poles in b=0 of digamma(b)/Gamma(b) and 
    polygamma functions. 
 
    digamma(b)/Gamma(b) = -1 - 2*M_EG*b + O(b^2) 
    digamma(b)^2/Gamma(b) = 1/b + 3*M_EG + b*(-5/12*PI^2+7/2*M_EG^2) + O(b^2) 
    polygamma(1, b)/Gamma(b) = 1/b + M_EG + b*(1/12*PI^2 + 1/2*M_EG^2) + O(b^2) 
    and so on. 
    &quot;&quot;&quot;</span>
    <span class="s1">order = </span><span class="s3">5</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">k = symbols(</span><span class="s4">&quot;a b x k&quot;</span><span class="s1">)</span>
    <span class="s1">M_PI</span><span class="s2">, </span><span class="s1">M_EG</span><span class="s2">, </span><span class="s1">M_Z3 = symbols(</span><span class="s4">&quot;M_PI M_EG M_Z3&quot;</span><span class="s1">)</span>
    <span class="s1">c_subs = {pi: M_PI</span><span class="s2">, </span><span class="s1">EulerGamma: M_EG</span><span class="s2">, </span><span class="s1">zeta(</span><span class="s3">3</span><span class="s1">): M_Z3}</span>
    <span class="s1">A = []  </span><span class="s5"># terms with a</span>
    <span class="s1">X = []  </span><span class="s5"># terms with x</span>
    <span class="s1">B = []  </span><span class="s5"># terms with b (polygammas expanded)</span>
    <span class="s1">C = []  </span><span class="s5"># terms that generate B</span>
    <span class="s5"># Phi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i])</span>
    <span class="s5"># B[0] = 1</span>
    <span class="s5"># B[k] = sum(C[k] * b**k/k!, k=0..)</span>
    <span class="s5"># Note: C[k] can be obtained from a series expansion of 1/gamma(b).</span>
    <span class="s1">expression = gamma(b)/sympy.exp(x) * \</span>
        <span class="s1">Sum(x**k/factorial(k)/gamma(a*k+b)</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">S.Infinity))</span>

    <span class="s5"># nth term of taylor series in a=0: a^n/n! * (d^n Phi(a, b, x)/da^n at a=0)</span>
    <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">order+</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">term = expression.diff(a</span><span class="s2">, </span><span class="s1">n).subs(a</span><span class="s2">, </span><span class="s3">0</span><span class="s1">).simplify().doit()</span>
        <span class="s5"># set the whole bracket involving polygammas to 1</span>
        <span class="s1">x_part = (term.subs(polygamma(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
                  <span class="s1">.replace(polygamma</span><span class="s2">, lambda </span><span class="s1">*args: </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s5"># sign convetion: x part always positive</span>
        <span class="s1">x_part *= (-</span><span class="s3">1</span><span class="s1">)**n</span>
        <span class="s5"># expansion of polygamma part with 1/gamma(b)</span>
        <span class="s1">pg_part = term/x_part/gamma(b)</span>
        <span class="s2">if </span><span class="s1">n &gt;= </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s5"># Note: highest term is digamma^n</span>
            <span class="s1">pg_part = pg_part.replace(polygamma</span><span class="s2">,</span>
                                      <span class="s2">lambda </span><span class="s1">k</span><span class="s2">, </span><span class="s1">x: pg_series(k</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">order+</span><span class="s3">1</span><span class="s1">+n))</span>
            <span class="s1">pg_part = (pg_part.series(b</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">n=order+</span><span class="s3">1</span><span class="s1">-n)</span>
                       <span class="s1">.removeO()</span>
                       <span class="s1">.subs(polygamma(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">*zeta(</span><span class="s3">3</span><span class="s1">))</span>
                       <span class="s1">.simplify()</span>
                       <span class="s1">)</span>

        <span class="s1">A.append(a**n/factorial(n))</span>
        <span class="s1">X.append(horner(x_part))</span>
        <span class="s1">B.append(pg_part)</span>

    <span class="s5"># Calculate C and put in the k!</span>
    <span class="s1">C = sympy.Poly(B[</span><span class="s3">1</span><span class="s1">].subs(c_subs)</span><span class="s2">, </span><span class="s1">b).coeffs()</span>
    <span class="s1">C.reverse()</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(C)):</span>
        <span class="s1">C[i] = (C[i] * factorial(i)).simplify()</span>

    <span class="s1">s = </span><span class="s4">&quot;Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">Phi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i], i=0..5)</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;B[0] = 1</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;B[i] = sum(C[k+i-1] * b**k/k!, k=0..)</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">M_PI = pi&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">M_EG = EulerGamma&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">M_Z3 = zeta(3)&quot;</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">zip([</span><span class="s4">'A'</span><span class="s2">, </span><span class="s4">'X'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[A</span><span class="s2">, </span><span class="s1">X]):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(c)):</span>
            <span class="s1">s += </span><span class="s4">f&quot;</span><span class="s2">\n{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">] = &quot;</span>
            <span class="s1">s += str(c[i])</span>
    <span class="s5"># For C, do also compute the values numerically</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(C)):</span>
        <span class="s1">s += </span><span class="s4">f&quot;</span><span class="s2">\n</span><span class="s4"># C[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">] = &quot;</span>
        <span class="s1">s += str(C[i])</span>
        <span class="s1">s += </span><span class="s4">f&quot;</span><span class="s2">\n</span><span class="s4">C[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">] = &quot;</span>
        <span class="s1">s += str(C[i].subs({M_EG: EulerGamma</span><span class="s2">, </span><span class="s1">M_PI: pi</span><span class="s2">, </span><span class="s1">M_Z3: zeta(</span><span class="s3">3</span><span class="s1">)})</span>
                 <span class="s1">.evalf(</span><span class="s3">17</span><span class="s1">))</span>

    <span class="s5"># Does B have the assumed structure?</span>
    <span class="s1">s += </span><span class="s4">&quot;</span><span class="s2">\n\n</span><span class="s4">Test if B[i] does have the assumed structure.&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">C[i] are derived from B[1] allone.&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">Test B[2] == C[1] + b*C[2] + b^2/2*C[3] + b^3/6*C[4] + ..&quot;</span>
    <span class="s1">test = sum([b**k/factorial(k) * C[k+</span><span class="s3">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(order-</span><span class="s3">1</span><span class="s1">)])</span>
    <span class="s1">test = (test - B[</span><span class="s3">2</span><span class="s1">].subs(c_subs)).simplify()</span>
    <span class="s1">s += </span><span class="s4">f&quot;</span><span class="s2">\n</span><span class="s4">test successful = </span><span class="s2">{</span><span class="s1">test==S(</span><span class="s3">0</span><span class="s1">)</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">Test B[3] == C[2] + b*C[3] + b^2/2*C[4] + ..&quot;</span>
    <span class="s1">test = sum([b**k/factorial(k) * C[k+</span><span class="s3">2</span><span class="s1">] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(order-</span><span class="s3">2</span><span class="s1">)])</span>
    <span class="s1">test = (test - B[</span><span class="s3">3</span><span class="s1">].subs(c_subs)).simplify()</span>
    <span class="s1">s += </span><span class="s4">f&quot;</span><span class="s2">\n</span><span class="s4">test successful = </span><span class="s2">{</span><span class="s1">test==S(</span><span class="s3">0</span><span class="s1">)</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">asymptotic_series():</span>
    <span class="s0">&quot;&quot;&quot;Asymptotic expansion for large x. 
 
    Phi(a, b, x) ~ Z^(1/2-b) * exp((1+a)/a * Z) * sum_k (-1)^k * C_k / Z^k 
    Z = (a*x)^(1/(1+a)) 
 
    Wright (1935) lists the coefficients C_0 and C_1 (he calls them a_0 and 
    a_1). With slightly different notation, Paris (2017) lists coefficients 
    c_k up to order k=3. 
    Paris (2017) uses ZP = (1+a)/a * Z  (ZP = Z of Paris) and 
    C_k = C_0 * (-a/(1+a))^k * c_k 
    &quot;&quot;&quot;</span>
    <span class="s1">order = </span><span class="s3">8</span>

    <span class="s2">class </span><span class="s1">g(sympy.Function):</span>
        <span class="s0">&quot;&quot;&quot;Helper function g according to Wright (1935) 
 
        g(n, rho, v) = (1 + (rho+2)/3 * v + (rho+2)*(rho+3)/(2*3) * v^2 + ...) 
 
        Note: Wright (1935) uses square root of above definition. 
        &quot;&quot;&quot;</span>
        <span class="s1">nargs = </span><span class="s3">3</span>

        <span class="s1">@classmethod</span>
        <span class="s2">def </span><span class="s1">eval(cls</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">v):</span>
            <span class="s2">if not </span><span class="s1">n &gt;= </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;must have n &gt;= 0&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">n == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s3">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">g(n-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">v) \</span>
                    <span class="s1">+ gammasimp(gamma(rho+</span><span class="s3">2</span><span class="s1">+n)/gamma(rho+</span><span class="s3">2</span><span class="s1">)) \</span>
                    <span class="s1">/ gammasimp(gamma(</span><span class="s3">3</span><span class="s1">+n)/gamma(</span><span class="s3">3</span><span class="s1">))*v**n</span>

    <span class="s2">class </span><span class="s1">coef_C(sympy.Function):</span>
        <span class="s0">&quot;&quot;&quot;Calculate coefficients C_m for integer m. 
 
        C_m is the coefficient of v^(2*m) in the Taylor expansion in v=0 of 
        Gamma(m+1/2)/(2*pi) * (2/(rho+1))^(m+1/2) * (1-v)^(-b) 
            * g(rho, v)^(-m-1/2) 
        &quot;&quot;&quot;</span>
        <span class="s1">nargs = </span><span class="s3">3</span>

        <span class="s1">@classmethod</span>
        <span class="s2">def </span><span class="s1">eval(cls</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">beta):</span>
            <span class="s2">if not </span><span class="s1">m &gt;= </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;must have m &gt;= 0&quot;</span><span class="s1">)</span>

            <span class="s1">v = symbols(</span><span class="s4">&quot;v&quot;</span><span class="s1">)</span>
            <span class="s1">expression = (</span><span class="s3">1</span><span class="s1">-v)**(-beta) * g(</span><span class="s3">2</span><span class="s1">*m</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">v)**(-m-Rational(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span>
            <span class="s1">res = expression.diff(v</span><span class="s2">, </span><span class="s3">2</span><span class="s1">*m).subs(v</span><span class="s2">, </span><span class="s3">0</span><span class="s1">) / factorial(</span><span class="s3">2</span><span class="s1">*m)</span>
            <span class="s1">res = res * (gamma(m + Rational(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)) / (</span><span class="s3">2</span><span class="s1">*pi)</span>
                         <span class="s1">* (</span><span class="s3">2</span><span class="s1">/(rho+</span><span class="s3">1</span><span class="s1">))**(m + Rational(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)))</span>
            <span class="s2">return </span><span class="s1">res</span>

    <span class="s5"># in order to have nice ordering/sorting of expressions, we set a = xa.</span>
    <span class="s1">xa</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">xap1 = symbols(</span><span class="s4">&quot;xa b xap1&quot;</span><span class="s1">)</span>
    <span class="s1">C0 = coef_C(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">xa</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s5"># a1 = a(1, rho, beta)</span>
    <span class="s1">s = </span><span class="s4">&quot;Asymptotic expansion for large x</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;Phi(a, b, x) = Z**(1/2-b) * exp((1+a)/a * Z) </span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;               * sum((-1)**k * C[k]/Z**k, k=0..6)</span><span class="s2">\n\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;Z      = pow(a * x, 1/(1+a))</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;A[k]   = pow(a, k)</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;B[k]   = pow(b, k)</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;Ap1[k] = pow(1+a, k)</span><span class="s2">\n\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;C[0] = 1./sqrt(2. * M_PI * Ap1[1])</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">order+</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">expr = (coef_C(i</span><span class="s2">, </span><span class="s1">xa</span><span class="s2">, </span><span class="s1">b) / (C0/(</span><span class="s3">1</span><span class="s1">+xa)**i)).simplify()</span>
        <span class="s1">factor = [x.denominator() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">sympy.Poly(expr).coeffs()]</span>
        <span class="s1">factor = sympy.lcm(factor)</span>
        <span class="s1">expr = (expr * factor).simplify().collect(b</span><span class="s2">, </span><span class="s1">sympy.factor)</span>
        <span class="s1">expr = expr.xreplace({xa+</span><span class="s3">1</span><span class="s1">: xap1})</span>
        <span class="s1">s += </span><span class="s4">f&quot;C[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">] = C[0] / (</span><span class="s2">{</span><span class="s1">factor</span><span class="s2">} </span><span class="s4">* Ap1[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">])</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">s += </span><span class="s4">f&quot;C[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">] *= </span><span class="s2">{</span><span class="s1">str(expr)</span><span class="s2">}\n\n</span><span class="s4">&quot;</span>
    <span class="s2">import </span><span class="s1">re</span>
    <span class="s1">re_a = re.compile(</span><span class="s4">r'xa\*\*(\d+)'</span><span class="s1">)</span>
    <span class="s1">s = re_a.sub(</span><span class="s4">r'A[\1]'</span><span class="s2">, </span><span class="s1">s)</span>
    <span class="s1">re_b = re.compile(</span><span class="s4">r'b\*\*(\d+)'</span><span class="s1">)</span>
    <span class="s1">s = re_b.sub(</span><span class="s4">r'B[\1]'</span><span class="s2">, </span><span class="s1">s)</span>
    <span class="s1">s = s.replace(</span><span class="s4">'xap1'</span><span class="s2">, </span><span class="s4">'Ap1[1]'</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s4">'xa'</span><span class="s2">, </span><span class="s4">'a'</span><span class="s1">)</span>
    <span class="s5"># max integer = 2^31-1 = 2,147,483,647. Solution: Put a point after 10</span>
    <span class="s5"># or more digits.</span>
    <span class="s1">re_digits = re.compile(</span><span class="s4">r'(\d{10,})'</span><span class="s1">)</span>
    <span class="s1">s = re_digits.sub(</span><span class="s4">r'\1.'</span><span class="s2">, </span><span class="s1">s)</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">optimal_epsilon_integral():</span>
    <span class="s0">&quot;&quot;&quot;Fit optimal choice of epsilon for integral representation. 
 
    The integrand of 
        int_0^pi P(eps, a, b, x, phi) * dphi 
    can exhibit oscillatory behaviour. It stems from the cosine of P and can be 
    minimized by minimizing the arc length of the argument 
        f(phi) = eps * sin(phi) - x * eps^(-a) * sin(a * phi) + (1 - b) * phi 
    of cos(f(phi)). 
    We minimize the arc length in eps for a grid of values (a, b, x) and fit a 
    parametric function to it. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">fp(eps</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">phi):</span>
        <span class="s0">&quot;&quot;&quot;Derivative of f w.r.t. phi.&quot;&quot;&quot;</span>
        <span class="s1">eps_a = np.power(</span><span class="s3">1. </span><span class="s1">* eps</span><span class="s2">, </span><span class="s1">-a)</span>
        <span class="s2">return </span><span class="s1">eps * np.cos(phi) - a * x * eps_a * np.cos(a * phi) + </span><span class="s3">1 </span><span class="s1">- b</span>

    <span class="s2">def </span><span class="s1">arclength(eps</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">epsrel=</span><span class="s3">1e-2</span><span class="s2">, </span><span class="s1">limit=</span><span class="s3">100</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Compute Arc length of f. 
 
        Note that the arg length of a function f fro t0 to t1 is given by 
            int_t0^t1 sqrt(1 + f'(t)^2) dt 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">quad(</span><span class="s2">lambda </span><span class="s1">phi: np.sqrt(</span><span class="s3">1 </span><span class="s1">+ fp(eps</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">phi)**</span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s3">0</span><span class="s2">, </span><span class="s1">np.pi</span><span class="s2">,</span>
                    <span class="s1">epsrel=epsrel</span><span class="s2">, </span><span class="s1">limit=</span><span class="s3">100</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s5"># grid of minimal arc length values</span>
    <span class="s1">data_a = [</span><span class="s3">1e-3</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.9</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">8</span><span class="s1">]</span>
    <span class="s1">data_b = [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]</span>
    <span class="s1">data_x = [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1.5</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">20</span><span class="s2">, </span><span class="s3">50</span><span class="s2">, </span><span class="s3">100</span><span class="s2">, </span><span class="s3">200</span><span class="s2">, </span><span class="s3">500</span><span class="s2">, </span><span class="s3">1e3</span><span class="s2">, </span><span class="s3">5e3</span><span class="s2">, </span><span class="s3">1e4</span><span class="s1">]</span>
    <span class="s1">data_a</span><span class="s2">, </span><span class="s1">data_b</span><span class="s2">, </span><span class="s1">data_x = np.meshgrid(data_a</span><span class="s2">, </span><span class="s1">data_b</span><span class="s2">, </span><span class="s1">data_x)</span>
    <span class="s1">data_a</span><span class="s2">, </span><span class="s1">data_b</span><span class="s2">, </span><span class="s1">data_x = (data_a.flatten()</span><span class="s2">, </span><span class="s1">data_b.flatten()</span><span class="s2">,</span>
                              <span class="s1">data_x.flatten())</span>
    <span class="s1">best_eps = []</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(data_x.size):</span>
        <span class="s1">best_eps.append(</span>
            <span class="s1">minimize_scalar(</span><span class="s2">lambda </span><span class="s1">eps: arclength(eps</span><span class="s2">, </span><span class="s1">data_a[i]</span><span class="s2">, </span><span class="s1">data_b[i]</span><span class="s2">,</span>
                                                  <span class="s1">data_x[i])</span><span class="s2">,</span>
                            <span class="s1">bounds=(</span><span class="s3">1e-3</span><span class="s2">, </span><span class="s3">1000</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">method=</span><span class="s4">'Bounded'</span><span class="s2">, </span><span class="s1">options={</span><span class="s4">'xatol'</span><span class="s1">: </span><span class="s3">1e-3</span><span class="s1">}).x</span>
        <span class="s1">)</span>
    <span class="s1">best_eps = np.array(best_eps)</span>
    <span class="s5"># pandas would be nice, but here a dictionary is enough</span>
    <span class="s1">df = {</span><span class="s4">'a'</span><span class="s1">: data_a</span><span class="s2">,</span>
          <span class="s4">'b'</span><span class="s1">: data_b</span><span class="s2">,</span>
          <span class="s4">'x'</span><span class="s1">: data_x</span><span class="s2">,</span>
          <span class="s4">'eps'</span><span class="s1">: best_eps</span><span class="s2">,</span>
          <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">func(data</span><span class="s2">, </span><span class="s1">A0</span><span class="s2">, </span><span class="s1">A1</span><span class="s2">, </span><span class="s1">A2</span><span class="s2">, </span><span class="s1">A3</span><span class="s2">, </span><span class="s1">A4</span><span class="s2">, </span><span class="s1">A5):</span>
        <span class="s0">&quot;&quot;&quot;Compute parametric function to fit.&quot;&quot;&quot;</span>
        <span class="s1">a = data[</span><span class="s4">'a'</span><span class="s1">]</span>
        <span class="s1">b = data[</span><span class="s4">'b'</span><span class="s1">]</span>
        <span class="s1">x = data[</span><span class="s4">'x'</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">(A0 * b * np.exp(-</span><span class="s3">0.5 </span><span class="s1">* a)</span>
                <span class="s1">+ np.exp(A1 + </span><span class="s3">1 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">+ a) * np.log(x) - A2 * np.exp(-A3 * a)</span>
                         <span class="s1">+ A4 / (</span><span class="s3">1 </span><span class="s1">+ np.exp(A5 * a))))</span>

    <span class="s1">func_params = list(curve_fit(func</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">df[</span><span class="s4">'eps'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'trf'</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s1">s = </span><span class="s4">&quot;Fit optimal eps for integrand P via minimal arc length</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;with parametric function:</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;optimal_eps = (A0 * b * exp(-a/2) + exp(A1 + 1 / (1 + a) * log(x)</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;              - A2 * exp(-A3 * a) + A4 / (1 + exp(A5 * a)))</span><span class="s2">\n\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">&quot;Fitted parameters A0 to A5 are:</span><span class="s2">\n</span><span class="s4">&quot;</span>
    <span class="s1">s += </span><span class="s4">', '</span><span class="s1">.join([</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">x</span><span class="s2">:</span><span class="s4">.5g</span><span class="s2">}</span><span class="s4">' </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">func_params])</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">main():</span>
    <span class="s1">t0 = time()</span>
    <span class="s1">parser = ArgumentParser(description=__doc__</span><span class="s2">,</span>
                            <span class="s1">formatter_class=RawTextHelpFormatter)</span>
    <span class="s1">parser.add_argument(</span><span class="s4">'action'</span><span class="s2">, </span><span class="s1">type=int</span><span class="s2">, </span><span class="s1">choices=[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">help=</span><span class="s4">'chose what expansion to precompute</span><span class="s2">\n</span><span class="s4">'</span>
                             <span class="s4">'1 : Series for small a</span><span class="s2">\n</span><span class="s4">'</span>
                             <span class="s4">'2 : Series for small a and small b</span><span class="s2">\n</span><span class="s4">'</span>
                             <span class="s4">'3 : Asymptotic series for large x</span><span class="s2">\n</span><span class="s4">'</span>
                             <span class="s4">'    This may take some time (&gt;4h).</span><span class="s2">\n</span><span class="s4">'</span>
                             <span class="s4">'4 : Fit optimal eps for integral representation.'</span>
                        <span class="s1">)</span>
    <span class="s1">args = parser.parse_args()</span>

    <span class="s1">switch = {</span><span class="s3">1</span><span class="s1">: </span><span class="s2">lambda</span><span class="s1">: print(series_small_a())</span><span class="s2">,</span>
              <span class="s3">2</span><span class="s1">: </span><span class="s2">lambda</span><span class="s1">: print(series_small_a_small_b())</span><span class="s2">,</span>
              <span class="s3">3</span><span class="s1">: </span><span class="s2">lambda</span><span class="s1">: print(asymptotic_series())</span><span class="s2">,</span>
              <span class="s3">4</span><span class="s1">: </span><span class="s2">lambda</span><span class="s1">: print(optimal_epsilon_integral())</span>
              <span class="s1">}</span>
    <span class="s1">switch.get(args.action</span><span class="s2">, lambda</span><span class="s1">: print(</span><span class="s4">&quot;Invalid input.&quot;</span><span class="s1">))()</span>
    <span class="s1">print(</span><span class="s4">f&quot;</span><span class="s2">\n{</span><span class="s1">(time() - t0)/</span><span class="s3">60</span><span class="s2">:</span><span class="s4">.1f</span><span class="s2">} </span><span class="s4">minutes elapsed.</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s4">'__main__'</span><span class="s1">:</span>
    <span class="s1">main()</span>
</pre>
</body>
</html>