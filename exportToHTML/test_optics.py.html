<html>
<head>
<title>test_optics.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_optics.py</font>
</center></td></tr></table>
<pre><span class="s0"># Authors: Shane Grigsby &lt;refuge@rocktalus.com&gt;</span>
<span class="s0">#          Adrin Jalali &lt;adrin.jalali@gmail.com&gt;</span>
<span class="s0"># License: BSD 3 clause</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">sparse</span>

<span class="s2">from </span><span class="s1">sklearn.cluster </span><span class="s2">import </span><span class="s1">DBSCAN</span><span class="s2">, </span><span class="s1">OPTICS</span>
<span class="s2">from </span><span class="s1">sklearn.cluster._optics </span><span class="s2">import </span><span class="s1">_extend_region</span><span class="s2">, </span><span class="s1">_extract_xi_labels</span>
<span class="s2">from </span><span class="s1">sklearn.cluster.tests.common </span><span class="s2">import </span><span class="s1">generate_clustered_data</span>
<span class="s2">from </span><span class="s1">sklearn.datasets </span><span class="s2">import </span><span class="s1">make_blobs</span>
<span class="s2">from </span><span class="s1">sklearn.exceptions </span><span class="s2">import </span><span class="s1">DataConversionWarning</span><span class="s2">, </span><span class="s1">EfficiencyWarning</span>
<span class="s2">from </span><span class="s1">sklearn.metrics.cluster </span><span class="s2">import </span><span class="s1">contingency_matrix</span>
<span class="s2">from </span><span class="s1">sklearn.metrics.pairwise </span><span class="s2">import </span><span class="s1">pairwise_distances</span>
<span class="s2">from </span><span class="s1">sklearn.utils </span><span class="s2">import </span><span class="s1">shuffle</span>
<span class="s2">from </span><span class="s1">sklearn.utils._testing </span><span class="s2">import </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_array_equal</span>

<span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
<span class="s1">n_points_per_cluster = </span><span class="s3">10</span>
<span class="s1">C1 = [-</span><span class="s3">5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">0.8 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">C2 = [</span><span class="s3">4</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">0.1 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">C3 = [</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">0.2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">C4 = [-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] + </span><span class="s3">0.3 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">C5 = [</span><span class="s3">3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">1.6 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">C6 = [</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">] + </span><span class="s3">2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">X = np.vstack((C1</span><span class="s2">, </span><span class="s1">C2</span><span class="s2">, </span><span class="s1">C3</span><span class="s2">, </span><span class="s1">C4</span><span class="s2">, </span><span class="s1">C5</span><span class="s2">, </span><span class="s1">C6))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">(</span><span class="s4">&quot;r_plot&quot;</span><span class="s2">, </span><span class="s4">&quot;end&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">8.9</span><span class="s2">, </span><span class="s3">8.8</span><span class="s2">, </span><span class="s3">8.7</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">8.9</span><span class="s2">, </span><span class="s3">8.8</span><span class="s2">, </span><span class="s3">8.7</span><span class="s2">, </span><span class="s3">8.6</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">8.9</span><span class="s2">, </span><span class="s3">8.8</span><span class="s2">, </span><span class="s3">8.7</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">8.9</span><span class="s2">, </span><span class="s3">8.8</span><span class="s2">, </span><span class="s3">8.7</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_extend_downward(r_plot</span><span class="s2">, </span><span class="s1">end):</span>
    <span class="s1">r_plot = np.array(r_plot)</span>
    <span class="s1">ratio = r_plot[:-</span><span class="s3">1</span><span class="s1">] / r_plot[</span><span class="s3">1</span><span class="s1">:]</span>
    <span class="s1">steep_downward = ratio &gt;= </span><span class="s3">1 </span><span class="s1">/ </span><span class="s3">0.9</span>
    <span class="s1">upward = ratio &lt; </span><span class="s3">1</span>

    <span class="s1">e = _extend_region(steep_downward</span><span class="s2">, </span><span class="s1">upward</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">e == end</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">(</span><span class="s4">&quot;r_plot&quot;</span><span class="s2">, </span><span class="s4">&quot;end&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2.1</span><span class="s2">, </span><span class="s3">2.2</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2.1</span><span class="s2">, </span><span class="s3">2.2</span><span class="s2">, </span><span class="s3">2.3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s3">8</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2.1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2.1</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_extend_upward(r_plot</span><span class="s2">, </span><span class="s1">end):</span>
    <span class="s1">r_plot = np.array(r_plot)</span>
    <span class="s1">ratio = r_plot[:-</span><span class="s3">1</span><span class="s1">] / r_plot[</span><span class="s3">1</span><span class="s1">:]</span>
    <span class="s1">steep_upward = ratio &lt;= </span><span class="s3">0.9</span>
    <span class="s1">downward = ratio &gt; </span><span class="s3">1</span>

    <span class="s1">e = _extend_region(steep_upward</span><span class="s2">, </span><span class="s1">downward</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">e == end</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">(</span><span class="s4">&quot;ordering&quot;</span><span class="s2">, </span><span class="s4">&quot;clusters&quot;</span><span class="s2">, </span><span class="s4">&quot;expected&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_the_extract_xi_labels(ordering</span><span class="s2">, </span><span class="s1">clusters</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">labels = _extract_xi_labels(ordering</span><span class="s2">, </span><span class="s1">clusters)</span>

    <span class="s1">assert_array_equal(labels</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_extract_xi(global_dtype):</span>
    <span class="s0"># small and easy test (no clusters around other clusters)</span>
    <span class="s0"># but with a clear noise data.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">n_points_per_cluster = </span><span class="s3">5</span>

    <span class="s1">C1 = [-</span><span class="s3">5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">0.8 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">C2 = [</span><span class="s3">4</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">0.1 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">C3 = [</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">0.2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">C4 = [-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] + </span><span class="s3">0.3 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">C5 = [</span><span class="s3">3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">0.6 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">C6 = [</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">] + </span><span class="s3">0.2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">X = np.vstack((C1</span><span class="s2">, </span><span class="s1">C2</span><span class="s2">, </span><span class="s1">C3</span><span class="s2">, </span><span class="s1">C4</span><span class="s2">, </span><span class="s1">C5</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s3">100</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">C6)).astype(</span>
        <span class="s1">global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s1">expected_labels = np.r_[[</span><span class="s3">2</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">] * </span><span class="s3">5</span><span class="s1">]</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">expected_labels = shuffle(X</span><span class="s2">, </span><span class="s1">expected_labels</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

    <span class="s1">clust = OPTICS(</span>
        <span class="s1">min_samples=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">min_cluster_size=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">max_eps=</span><span class="s3">20</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;xi&quot;</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.4</span>
    <span class="s1">).fit(X)</span>
    <span class="s1">assert_array_equal(clust.labels_</span><span class="s2">, </span><span class="s1">expected_labels)</span>

    <span class="s0"># check float min_samples and min_cluster_size</span>
    <span class="s1">clust = OPTICS(</span>
        <span class="s1">min_samples=</span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">min_cluster_size=</span><span class="s3">0.08</span><span class="s2">, </span><span class="s1">max_eps=</span><span class="s3">20</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;xi&quot;</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.4</span>
    <span class="s1">).fit(X)</span>
    <span class="s1">assert_array_equal(clust.labels_</span><span class="s2">, </span><span class="s1">expected_labels)</span>

    <span class="s1">X = np.vstack((C1</span><span class="s2">, </span><span class="s1">C2</span><span class="s2">, </span><span class="s1">C3</span><span class="s2">, </span><span class="s1">C4</span><span class="s2">, </span><span class="s1">C5</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s3">100</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]] * </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">C6)).astype(</span>
        <span class="s1">global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s1">expected_labels = np.r_[</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">] * </span><span class="s3">5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">] * </span><span class="s3">5</span>
    <span class="s1">]</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">expected_labels = shuffle(X</span><span class="s2">, </span><span class="s1">expected_labels</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

    <span class="s1">clust = OPTICS(</span>
        <span class="s1">min_samples=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">min_cluster_size=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">max_eps=</span><span class="s3">20</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;xi&quot;</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.3</span>
    <span class="s1">).fit(X)</span>
    <span class="s0"># this may fail if the predecessor correction is not at work!</span>
    <span class="s1">assert_array_equal(clust.labels_</span><span class="s2">, </span><span class="s1">expected_labels)</span>

    <span class="s1">C1 = [[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]]</span>
    <span class="s1">C2 = [[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">11</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">9</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]]</span>
    <span class="s1">C3 = [[</span><span class="s3">100</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">100</span><span class="s2">, </span><span class="s3">90</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">100</span><span class="s2">, </span><span class="s3">110</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">90</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]]</span>
    <span class="s1">X = np.vstack((C1</span><span class="s2">, </span><span class="s1">C2</span><span class="s2">, </span><span class="s1">C3)).astype(global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">expected_labels = np.r_[[</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">4</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">4</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">] * </span><span class="s3">4</span><span class="s1">]</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">expected_labels = shuffle(X</span><span class="s2">, </span><span class="s1">expected_labels</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

    <span class="s1">clust = OPTICS(</span>
        <span class="s1">min_samples=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">min_cluster_size=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">max_eps=np.inf</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;xi&quot;</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.04</span>
    <span class="s1">).fit(X)</span>
    <span class="s1">assert_array_equal(clust.labels_</span><span class="s2">, </span><span class="s1">expected_labels)</span>


<span class="s2">def </span><span class="s1">test_cluster_hierarchy_(global_dtype):</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">n_points_per_cluster = </span><span class="s3">100</span>
    <span class="s1">C1 = [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] + </span><span class="s3">2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">).astype(</span>
        <span class="s1">global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s1">C2 = [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] + </span><span class="s3">50 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">).astype(</span>
        <span class="s1">global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s1">X = np.vstack((C1</span><span class="s2">, </span><span class="s1">C2))</span>
    <span class="s1">X = shuffle(X</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">clusters = OPTICS(min_samples=</span><span class="s3">20</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.1</span><span class="s1">).fit(X).cluster_hierarchy_</span>
    <span class="s2">assert </span><span class="s1">clusters.shape == (</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">diff = np.sum(clusters - np.array([[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">99</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">199</span><span class="s1">]]))</span>
    <span class="s2">assert </span><span class="s1">diff / len(X) &lt; </span><span class="s3">0.05</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;metric, is_sparse&quot;</span><span class="s2">,</span>
    <span class="s1">[[</span><span class="s4">&quot;minkowski&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;euclidean&quot;</span><span class="s2">, True</span><span class="s1">]]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_correct_number_of_clusters(metric</span><span class="s2">, </span><span class="s1">is_sparse):</span>
    <span class="s0"># in 'auto' mode</span>

    <span class="s1">n_clusters = </span><span class="s3">3</span>
    <span class="s1">X = generate_clustered_data(n_clusters=n_clusters)</span>
    <span class="s0"># Parameters chosen specifically for this task.</span>
    <span class="s0"># Compute OPTICS</span>
    <span class="s1">clust = OPTICS(max_eps=</span><span class="s3">5.0 </span><span class="s1">* </span><span class="s3">6.0</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">4</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">metric=metric)</span>
    <span class="s1">clust.fit(sparse.csr_matrix(X) </span><span class="s2">if </span><span class="s1">is_sparse </span><span class="s2">else </span><span class="s1">X)</span>
    <span class="s0"># number of clusters, ignoring noise if present</span>
    <span class="s1">n_clusters_1 = len(set(clust.labels_)) - int(-</span><span class="s3">1 </span><span class="s2">in </span><span class="s1">clust.labels_)</span>
    <span class="s2">assert </span><span class="s1">n_clusters_1 == n_clusters</span>

    <span class="s0"># check attribute types and sizes</span>
    <span class="s2">assert </span><span class="s1">clust.labels_.shape == (len(X)</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">clust.labels_.dtype.kind == </span><span class="s4">&quot;i&quot;</span>

    <span class="s2">assert </span><span class="s1">clust.reachability_.shape == (len(X)</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">clust.reachability_.dtype.kind == </span><span class="s4">&quot;f&quot;</span>

    <span class="s2">assert </span><span class="s1">clust.core_distances_.shape == (len(X)</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">clust.core_distances_.dtype.kind == </span><span class="s4">&quot;f&quot;</span>

    <span class="s2">assert </span><span class="s1">clust.ordering_.shape == (len(X)</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">clust.ordering_.dtype.kind == </span><span class="s4">&quot;i&quot;</span>
    <span class="s2">assert </span><span class="s1">set(clust.ordering_) == set(range(len(X)))</span>


<span class="s2">def </span><span class="s1">test_minimum_number_of_sample_check():</span>
    <span class="s0"># test that we check a minimum number of samples</span>
    <span class="s1">msg = </span><span class="s4">&quot;min_samples must be no greater than&quot;</span>

    <span class="s0"># Compute OPTICS</span>
    <span class="s1">X = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]]</span>
    <span class="s1">clust = OPTICS(max_eps=</span><span class="s3">5.0 </span><span class="s1">* </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">min_cluster_size=</span><span class="s3">1.0</span><span class="s1">)</span>

    <span class="s0"># Run the fit</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">clust.fit(X)</span>


<span class="s2">def </span><span class="s1">test_bad_extract():</span>
    <span class="s0"># Test an extraction of eps too close to original eps</span>
    <span class="s1">msg = </span><span class="s4">&quot;Specify an epsilon smaller than 0.15. Got 0.3.&quot;</span>
    <span class="s1">centers = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]]</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">labels_true = make_blobs(</span>
        <span class="s1">n_samples=</span><span class="s3">750</span><span class="s2">, </span><span class="s1">centers=centers</span><span class="s2">, </span><span class="s1">cluster_std=</span><span class="s3">0.4</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span>
    <span class="s1">)</span>

    <span class="s0"># Compute OPTICS</span>
    <span class="s1">clust = OPTICS(max_eps=</span><span class="s3">5.0 </span><span class="s1">* </span><span class="s3">0.03</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;dbscan&quot;</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">clust.fit(X)</span>


<span class="s2">def </span><span class="s1">test_bad_reachability():</span>
    <span class="s1">msg = </span><span class="s4">&quot;All reachability values are inf. Set a larger max_eps.&quot;</span>
    <span class="s1">centers = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]]</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">labels_true = make_blobs(</span>
        <span class="s1">n_samples=</span><span class="s3">750</span><span class="s2">, </span><span class="s1">centers=centers</span><span class="s2">, </span><span class="s1">cluster_std=</span><span class="s3">0.4</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span>
    <span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">clust = OPTICS(max_eps=</span><span class="s3">5.0 </span><span class="s1">* </span><span class="s3">0.003</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.015</span><span class="s1">)</span>
        <span class="s1">clust.fit(X)</span>


<span class="s2">def </span><span class="s1">test_nowarn_if_metric_bool_data_bool():</span>
    <span class="s0"># make sure no warning is raised if metric and data are both boolean</span>
    <span class="s0"># non-regression test for</span>
    <span class="s0"># https://github.com/scikit-learn/scikit-learn/issues/18996</span>

    <span class="s1">pairwise_metric = </span><span class="s4">&quot;rogerstanimoto&quot;</span>
    <span class="s1">X = np.random.randint(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">size=(</span><span class="s3">5</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=bool)</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;error&quot;</span><span class="s2">, </span><span class="s1">DataConversionWarning)</span>

        <span class="s1">OPTICS(metric=pairwise_metric).fit(X)</span>


<span class="s2">def </span><span class="s1">test_warn_if_metric_bool_data_no_bool():</span>
    <span class="s0"># make sure a *single* conversion warning is raised if metric is boolean</span>
    <span class="s0"># but data isn't</span>
    <span class="s0"># non-regression test for</span>
    <span class="s0"># https://github.com/scikit-learn/scikit-learn/issues/18996</span>

    <span class="s1">pairwise_metric = </span><span class="s4">&quot;rogerstanimoto&quot;</span>
    <span class="s1">X = np.random.randint(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">size=(</span><span class="s3">5</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
    <span class="s1">msg = </span><span class="s4">f&quot;Data will be converted to boolean for metric </span><span class="s2">{</span><span class="s1">pairwise_metric</span><span class="s2">}</span><span class="s4">&quot;</span>

    <span class="s2">with </span><span class="s1">pytest.warns(DataConversionWarning</span><span class="s2">, </span><span class="s1">match=msg) </span><span class="s2">as </span><span class="s1">warn_record:</span>
        <span class="s1">OPTICS(metric=pairwise_metric).fit(X)</span>
        <span class="s2">assert </span><span class="s1">len(warn_record) == </span><span class="s3">1</span>


<span class="s2">def </span><span class="s1">test_nowarn_if_metric_no_bool():</span>
    <span class="s0"># make sure no conversion warning is raised if</span>
    <span class="s0"># metric isn't boolean, no matter what the data type is</span>
    <span class="s1">pairwise_metric = </span><span class="s4">&quot;minkowski&quot;</span>
    <span class="s1">X_bool = np.random.randint(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">size=(</span><span class="s3">5</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">X_num = np.random.randint(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">size=(</span><span class="s3">5</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;error&quot;</span><span class="s2">, </span><span class="s1">DataConversionWarning)</span>

        <span class="s0"># fit boolean data</span>
        <span class="s1">OPTICS(metric=pairwise_metric).fit(X_bool)</span>
        <span class="s0"># fit numeric data</span>
        <span class="s1">OPTICS(metric=pairwise_metric).fit(X_num)</span>


<span class="s2">def </span><span class="s1">test_close_extract():</span>
    <span class="s0"># Test extract where extraction eps is close to scaled max_eps</span>

    <span class="s1">centers = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]]</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">labels_true = make_blobs(</span>
        <span class="s1">n_samples=</span><span class="s3">750</span><span class="s2">, </span><span class="s1">centers=centers</span><span class="s2">, </span><span class="s1">cluster_std=</span><span class="s3">0.4</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span>
    <span class="s1">)</span>

    <span class="s0"># Compute OPTICS</span>
    <span class="s1">clust = OPTICS(max_eps=</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;dbscan&quot;</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">min_samples=</span><span class="s3">10</span><span class="s1">).fit(X)</span>
    <span class="s0"># Cluster ordering starts at 0; max cluster label = 2 is 3 clusters</span>
    <span class="s2">assert </span><span class="s1">max(clust.labels_) == </span><span class="s3">2</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;eps&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;min_samples&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">20</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;metric, is_sparse&quot;</span><span class="s2">,</span>
    <span class="s1">[[</span><span class="s4">&quot;minkowski&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;euclidean&quot;</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;euclidean&quot;</span><span class="s2">, True</span><span class="s1">]]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dbscan_optics_parity(eps</span><span class="s2">, </span><span class="s1">min_samples</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">is_sparse</span><span class="s2">, </span><span class="s1">global_dtype):</span>
    <span class="s0"># Test that OPTICS clustering labels are &lt;= 5% difference of DBSCAN</span>

    <span class="s1">centers = [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]]</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">labels_true = make_blobs(</span>
        <span class="s1">n_samples=</span><span class="s3">150</span><span class="s2">, </span><span class="s1">centers=centers</span><span class="s2">, </span><span class="s1">cluster_std=</span><span class="s3">0.4</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">0</span>
    <span class="s1">)</span>
    <span class="s1">X = sparse.csr_matrix(X) </span><span class="s2">if </span><span class="s1">is_sparse </span><span class="s2">else </span><span class="s1">X</span>

    <span class="s1">X = X.astype(global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s0"># calculate optics with dbscan extract at 0.3 epsilon</span>
    <span class="s1">op = OPTICS(</span>
        <span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;dbscan&quot;</span><span class="s2">, </span><span class="s1">eps=eps</span><span class="s2">, </span><span class="s1">metric=metric</span>
    <span class="s1">).fit(X)</span>

    <span class="s0"># calculate dbscan labels</span>
    <span class="s1">db = DBSCAN(eps=eps</span><span class="s2">, </span><span class="s1">min_samples=min_samples).fit(X)</span>

    <span class="s1">contingency = contingency_matrix(db.labels_</span><span class="s2">, </span><span class="s1">op.labels_)</span>
    <span class="s1">agree = min(</span>
        <span class="s1">np.sum(np.max(contingency</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">))</span><span class="s2">, </span><span class="s1">np.sum(np.max(contingency</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">)</span>
    <span class="s1">disagree = X.shape[</span><span class="s3">0</span><span class="s1">] - agree</span>

    <span class="s1">percent_mismatch = np.round((disagree - </span><span class="s3">1</span><span class="s1">) / X.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0"># verify label mismatch is &lt;= 5% labels</span>
    <span class="s2">assert </span><span class="s1">percent_mismatch &lt;= </span><span class="s3">0.05</span>


<span class="s2">def </span><span class="s1">test_min_samples_edge_case(global_dtype):</span>
    <span class="s1">C1 = [[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s1">]]</span>
    <span class="s1">C2 = [[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">11</span><span class="s1">]]</span>
    <span class="s1">C3 = [[</span><span class="s3">100</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">100</span><span class="s2">, </span><span class="s3">96</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">100</span><span class="s2">, </span><span class="s3">106</span><span class="s1">]]</span>
    <span class="s1">X = np.vstack((C1</span><span class="s2">, </span><span class="s1">C2</span><span class="s2">, </span><span class="s1">C3)).astype(global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">expected_labels = np.r_[[</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">clust = OPTICS(min_samples=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">max_eps=</span><span class="s3">7</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;xi&quot;</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.04</span><span class="s1">).fit(X)</span>
    <span class="s1">assert_array_equal(clust.labels_</span><span class="s2">, </span><span class="s1">expected_labels)</span>

    <span class="s1">expected_labels = np.r_[[</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">clust = OPTICS(min_samples=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">max_eps=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;xi&quot;</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.04</span><span class="s1">).fit(X)</span>
    <span class="s1">assert_array_equal(clust.labels_</span><span class="s2">, </span><span class="s1">expected_labels)</span>

    <span class="s1">expected_labels = np.r_[[-</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">9</span><span class="s1">]</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;All reachability values&quot;</span><span class="s1">):</span>
        <span class="s1">clust = OPTICS(min_samples=</span><span class="s3">4</span><span class="s2">, </span><span class="s1">max_eps=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">cluster_method=</span><span class="s4">&quot;xi&quot;</span><span class="s2">, </span><span class="s1">xi=</span><span class="s3">0.04</span><span class="s1">).fit(X)</span>
        <span class="s1">assert_array_equal(clust.labels_</span><span class="s2">, </span><span class="s1">expected_labels)</span>


<span class="s0"># try arbitrary minimum sizes</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;min_cluster_size&quot;</span><span class="s2">, </span><span class="s1">range(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">X.shape[</span><span class="s3">0</span><span class="s1">] // </span><span class="s3">10</span><span class="s2">, </span><span class="s3">23</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_min_cluster_size(min_cluster_size</span><span class="s2">, </span><span class="s1">global_dtype):</span>
    <span class="s1">redX = X[::</span><span class="s3">2</span><span class="s1">].astype(global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)  </span><span class="s0"># reduce for speed</span>
    <span class="s1">clust = OPTICS(min_samples=</span><span class="s3">9</span><span class="s2">, </span><span class="s1">min_cluster_size=min_cluster_size).fit(redX)</span>
    <span class="s1">cluster_sizes = np.bincount(clust.labels_[clust.labels_ != -</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">cluster_sizes.size:</span>
        <span class="s2">assert </span><span class="s1">min(cluster_sizes) &gt;= min_cluster_size</span>
    <span class="s0"># check behaviour is the same when min_cluster_size is a fraction</span>
    <span class="s1">clust_frac = OPTICS(</span>
        <span class="s1">min_samples=</span><span class="s3">9</span><span class="s2">,</span>
        <span class="s1">min_cluster_size=min_cluster_size / redX.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">clust_frac.fit(redX)</span>
    <span class="s1">assert_array_equal(clust.labels_</span><span class="s2">, </span><span class="s1">clust_frac.labels_)</span>


<span class="s2">def </span><span class="s1">test_min_cluster_size_invalid2():</span>
    <span class="s1">clust = OPTICS(min_cluster_size=len(X) + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be no greater than the &quot;</span><span class="s1">):</span>
        <span class="s1">clust.fit(X)</span>

    <span class="s1">clust = OPTICS(min_cluster_size=len(X) + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;must be no greater than the &quot;</span><span class="s1">):</span>
        <span class="s1">clust.fit(sparse.csr_matrix(X))</span>


<span class="s2">def </span><span class="s1">test_processing_order():</span>
    <span class="s0"># Ensure that we consider all unprocessed points,</span>
    <span class="s0"># not only direct neighbors. when picking the next point.</span>
    <span class="s1">Y = [[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">25</span><span class="s1">]]</span>

    <span class="s1">clust = OPTICS(min_samples=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">max_eps=</span><span class="s3">15</span><span class="s1">).fit(Y)</span>
    <span class="s1">assert_array_equal(clust.reachability_</span><span class="s2">, </span><span class="s1">[np.inf</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">15</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(clust.core_distances_</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s2">, </span><span class="s3">15</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf])</span>
    <span class="s1">assert_array_equal(clust.ordering_</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_compare_to_ELKI():</span>
    <span class="s0"># Expected values, computed with (future) ELKI 0.7.5 using:</span>
    <span class="s0"># java -jar elki.jar cli -dbc.in csv -dbc.filter FixedDBIDsFilter</span>
    <span class="s0">#   -algorithm clustering.optics.OPTICSHeap -optics.minpts 5</span>
    <span class="s0"># where the FixedDBIDsFilter gives 0-indexed ids.</span>
    <span class="s1">r1 = [</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s3">1.0574896366427478</span><span class="s2">,</span>
        <span class="s3">0.7587934993548423</span><span class="s2">,</span>
        <span class="s3">0.7290174038973836</span><span class="s2">,</span>
        <span class="s3">0.7290174038973836</span><span class="s2">,</span>
        <span class="s3">0.7290174038973836</span><span class="s2">,</span>
        <span class="s3">0.6861627576116127</span><span class="s2">,</span>
        <span class="s3">0.7587934993548423</span><span class="s2">,</span>
        <span class="s3">0.9280118450166668</span><span class="s2">,</span>
        <span class="s3">1.1748022534146194</span><span class="s2">,</span>
        <span class="s3">3.3355455741292257</span><span class="s2">,</span>
        <span class="s3">0.49618389254482587</span><span class="s2">,</span>
        <span class="s3">0.2552805046961355</span><span class="s2">,</span>
        <span class="s3">0.2552805046961355</span><span class="s2">,</span>
        <span class="s3">0.24944622248445714</span><span class="s2">,</span>
        <span class="s3">0.24944622248445714</span><span class="s2">,</span>
        <span class="s3">0.24944622248445714</span><span class="s2">,</span>
        <span class="s3">0.2552805046961355</span><span class="s2">,</span>
        <span class="s3">0.2552805046961355</span><span class="s2">,</span>
        <span class="s3">0.3086779122185853</span><span class="s2">,</span>
        <span class="s3">4.163024452756142</span><span class="s2">,</span>
        <span class="s3">1.623152630340929</span><span class="s2">,</span>
        <span class="s3">0.45315840475822655</span><span class="s2">,</span>
        <span class="s3">0.25468325192031926</span><span class="s2">,</span>
        <span class="s3">0.2254004358159971</span><span class="s2">,</span>
        <span class="s3">0.18765711877083036</span><span class="s2">,</span>
        <span class="s3">0.1821471333893275</span><span class="s2">,</span>
        <span class="s3">0.1821471333893275</span><span class="s2">,</span>
        <span class="s3">0.18765711877083036</span><span class="s2">,</span>
        <span class="s3">0.18765711877083036</span><span class="s2">,</span>
        <span class="s3">0.2240202988740153</span><span class="s2">,</span>
        <span class="s3">1.154337614548715</span><span class="s2">,</span>
        <span class="s3">1.342604473837069</span><span class="s2">,</span>
        <span class="s3">1.323308536402633</span><span class="s2">,</span>
        <span class="s3">0.8607514948648837</span><span class="s2">,</span>
        <span class="s3">0.27219111215810565</span><span class="s2">,</span>
        <span class="s3">0.13260875220533205</span><span class="s2">,</span>
        <span class="s3">0.13260875220533205</span><span class="s2">,</span>
        <span class="s3">0.09890587675958984</span><span class="s2">,</span>
        <span class="s3">0.09890587675958984</span><span class="s2">,</span>
        <span class="s3">0.13548790801634494</span><span class="s2">,</span>
        <span class="s3">0.1575483940837384</span><span class="s2">,</span>
        <span class="s3">0.17515137170530226</span><span class="s2">,</span>
        <span class="s3">0.17575920159442388</span><span class="s2">,</span>
        <span class="s3">0.27219111215810565</span><span class="s2">,</span>
        <span class="s3">0.6101447895405373</span><span class="s2">,</span>
        <span class="s3">1.3189208094864302</span><span class="s2">,</span>
        <span class="s3">1.323308536402633</span><span class="s2">,</span>
        <span class="s3">2.2509184159764577</span><span class="s2">,</span>
        <span class="s3">2.4517810628594527</span><span class="s2">,</span>
        <span class="s3">3.675977064404973</span><span class="s2">,</span>
        <span class="s3">3.8264795626020365</span><span class="s2">,</span>
        <span class="s3">2.9130735341510614</span><span class="s2">,</span>
        <span class="s3">2.9130735341510614</span><span class="s2">,</span>
        <span class="s3">2.9130735341510614</span><span class="s2">,</span>
        <span class="s3">2.9130735341510614</span><span class="s2">,</span>
        <span class="s3">2.8459300127258036</span><span class="s2">,</span>
        <span class="s3">2.8459300127258036</span><span class="s2">,</span>
        <span class="s3">2.8459300127258036</span><span class="s2">,</span>
        <span class="s3">3.0321982337972537</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">o1 = [</span>
        <span class="s3">0</span><span class="s2">,</span>
        <span class="s3">3</span><span class="s2">,</span>
        <span class="s3">6</span><span class="s2">,</span>
        <span class="s3">4</span><span class="s2">,</span>
        <span class="s3">7</span><span class="s2">,</span>
        <span class="s3">8</span><span class="s2">,</span>
        <span class="s3">2</span><span class="s2">,</span>
        <span class="s3">9</span><span class="s2">,</span>
        <span class="s3">5</span><span class="s2">,</span>
        <span class="s3">1</span><span class="s2">,</span>
        <span class="s3">31</span><span class="s2">,</span>
        <span class="s3">30</span><span class="s2">,</span>
        <span class="s3">32</span><span class="s2">,</span>
        <span class="s3">34</span><span class="s2">,</span>
        <span class="s3">33</span><span class="s2">,</span>
        <span class="s3">38</span><span class="s2">,</span>
        <span class="s3">39</span><span class="s2">,</span>
        <span class="s3">35</span><span class="s2">,</span>
        <span class="s3">37</span><span class="s2">,</span>
        <span class="s3">36</span><span class="s2">,</span>
        <span class="s3">44</span><span class="s2">,</span>
        <span class="s3">21</span><span class="s2">,</span>
        <span class="s3">23</span><span class="s2">,</span>
        <span class="s3">24</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">25</span><span class="s2">,</span>
        <span class="s3">27</span><span class="s2">,</span>
        <span class="s3">29</span><span class="s2">,</span>
        <span class="s3">26</span><span class="s2">,</span>
        <span class="s3">28</span><span class="s2">,</span>
        <span class="s3">20</span><span class="s2">,</span>
        <span class="s3">40</span><span class="s2">,</span>
        <span class="s3">45</span><span class="s2">,</span>
        <span class="s3">46</span><span class="s2">,</span>
        <span class="s3">10</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">11</span><span class="s2">,</span>
        <span class="s3">13</span><span class="s2">,</span>
        <span class="s3">17</span><span class="s2">,</span>
        <span class="s3">19</span><span class="s2">,</span>
        <span class="s3">18</span><span class="s2">,</span>
        <span class="s3">12</span><span class="s2">,</span>
        <span class="s3">16</span><span class="s2">,</span>
        <span class="s3">14</span><span class="s2">,</span>
        <span class="s3">47</span><span class="s2">,</span>
        <span class="s3">49</span><span class="s2">,</span>
        <span class="s3">43</span><span class="s2">,</span>
        <span class="s3">48</span><span class="s2">,</span>
        <span class="s3">42</span><span class="s2">,</span>
        <span class="s3">41</span><span class="s2">,</span>
        <span class="s3">53</span><span class="s2">,</span>
        <span class="s3">57</span><span class="s2">,</span>
        <span class="s3">51</span><span class="s2">,</span>
        <span class="s3">52</span><span class="s2">,</span>
        <span class="s3">56</span><span class="s2">,</span>
        <span class="s3">59</span><span class="s2">,</span>
        <span class="s3">54</span><span class="s2">,</span>
        <span class="s3">55</span><span class="s2">,</span>
        <span class="s3">58</span><span class="s2">,</span>
        <span class="s3">50</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">p1 = [</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s3">0</span><span class="s2">,</span>
        <span class="s3">3</span><span class="s2">,</span>
        <span class="s3">6</span><span class="s2">,</span>
        <span class="s3">6</span><span class="s2">,</span>
        <span class="s3">6</span><span class="s2">,</span>
        <span class="s3">8</span><span class="s2">,</span>
        <span class="s3">3</span><span class="s2">,</span>
        <span class="s3">7</span><span class="s2">,</span>
        <span class="s3">5</span><span class="s2">,</span>
        <span class="s3">1</span><span class="s2">,</span>
        <span class="s3">31</span><span class="s2">,</span>
        <span class="s3">30</span><span class="s2">,</span>
        <span class="s3">30</span><span class="s2">,</span>
        <span class="s3">34</span><span class="s2">,</span>
        <span class="s3">34</span><span class="s2">,</span>
        <span class="s3">34</span><span class="s2">,</span>
        <span class="s3">32</span><span class="s2">,</span>
        <span class="s3">32</span><span class="s2">,</span>
        <span class="s3">37</span><span class="s2">,</span>
        <span class="s3">36</span><span class="s2">,</span>
        <span class="s3">44</span><span class="s2">,</span>
        <span class="s3">21</span><span class="s2">,</span>
        <span class="s3">23</span><span class="s2">,</span>
        <span class="s3">24</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">25</span><span class="s2">,</span>
        <span class="s3">25</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">21</span><span class="s2">,</span>
        <span class="s3">40</span><span class="s2">,</span>
        <span class="s3">45</span><span class="s2">,</span>
        <span class="s3">46</span><span class="s2">,</span>
        <span class="s3">10</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">13</span><span class="s2">,</span>
        <span class="s3">13</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">11</span><span class="s2">,</span>
        <span class="s3">19</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">10</span><span class="s2">,</span>
        <span class="s3">47</span><span class="s2">,</span>
        <span class="s3">12</span><span class="s2">,</span>
        <span class="s3">45</span><span class="s2">,</span>
        <span class="s3">14</span><span class="s2">,</span>
        <span class="s3">43</span><span class="s2">,</span>
        <span class="s3">42</span><span class="s2">,</span>
        <span class="s3">53</span><span class="s2">,</span>
        <span class="s3">57</span><span class="s2">,</span>
        <span class="s3">57</span><span class="s2">,</span>
        <span class="s3">57</span><span class="s2">,</span>
        <span class="s3">57</span><span class="s2">,</span>
        <span class="s3">59</span><span class="s2">,</span>
        <span class="s3">59</span><span class="s2">,</span>
        <span class="s3">59</span><span class="s2">,</span>
        <span class="s3">58</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s0"># Tests against known extraction array</span>
    <span class="s0"># Does NOT work with metric='euclidean', because sklearn euclidean has</span>
    <span class="s0"># worse numeric precision. 'minkowski' is slower but more accurate.</span>
    <span class="s1">clust1 = OPTICS(min_samples=</span><span class="s3">5</span><span class="s1">).fit(X)</span>

    <span class="s1">assert_array_equal(clust1.ordering_</span><span class="s2">, </span><span class="s1">np.array(o1))</span>
    <span class="s1">assert_array_equal(clust1.predecessor_[clust1.ordering_]</span><span class="s2">, </span><span class="s1">np.array(p1))</span>
    <span class="s1">assert_allclose(clust1.reachability_[clust1.ordering_]</span><span class="s2">, </span><span class="s1">np.array(r1))</span>
    <span class="s0"># ELKI currently does not print the core distances (which are not used much</span>
    <span class="s0"># in literature, but we can at least ensure to have this consistency:</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">clust1.ordering_[</span><span class="s3">1</span><span class="s1">:]:</span>
        <span class="s2">assert </span><span class="s1">clust1.reachability_[i] &gt;= clust1.core_distances_[clust1.predecessor_[i]]</span>

    <span class="s0"># Expected values, computed with (future) ELKI 0.7.5 using</span>
    <span class="s1">r2 = [</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s3">0.27219111215810565</span><span class="s2">,</span>
        <span class="s3">0.13260875220533205</span><span class="s2">,</span>
        <span class="s3">0.13260875220533205</span><span class="s2">,</span>
        <span class="s3">0.09890587675958984</span><span class="s2">,</span>
        <span class="s3">0.09890587675958984</span><span class="s2">,</span>
        <span class="s3">0.13548790801634494</span><span class="s2">,</span>
        <span class="s3">0.1575483940837384</span><span class="s2">,</span>
        <span class="s3">0.17515137170530226</span><span class="s2">,</span>
        <span class="s3">0.17575920159442388</span><span class="s2">,</span>
        <span class="s3">0.27219111215810565</span><span class="s2">,</span>
        <span class="s3">0.4928068613197889</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s3">0.2666183922512113</span><span class="s2">,</span>
        <span class="s3">0.18765711877083036</span><span class="s2">,</span>
        <span class="s3">0.1821471333893275</span><span class="s2">,</span>
        <span class="s3">0.1821471333893275</span><span class="s2">,</span>
        <span class="s3">0.1821471333893275</span><span class="s2">,</span>
        <span class="s3">0.18715928772277457</span><span class="s2">,</span>
        <span class="s3">0.18765711877083036</span><span class="s2">,</span>
        <span class="s3">0.18765711877083036</span><span class="s2">,</span>
        <span class="s3">0.25468325192031926</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s3">0.2552805046961355</span><span class="s2">,</span>
        <span class="s3">0.2552805046961355</span><span class="s2">,</span>
        <span class="s3">0.24944622248445714</span><span class="s2">,</span>
        <span class="s3">0.24944622248445714</span><span class="s2">,</span>
        <span class="s3">0.24944622248445714</span><span class="s2">,</span>
        <span class="s3">0.2552805046961355</span><span class="s2">,</span>
        <span class="s3">0.2552805046961355</span><span class="s2">,</span>
        <span class="s3">0.3086779122185853</span><span class="s2">,</span>
        <span class="s3">0.34466409325984865</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
        <span class="s1">np.inf</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">o2 = [</span>
        <span class="s3">0</span><span class="s2">,</span>
        <span class="s3">1</span><span class="s2">,</span>
        <span class="s3">2</span><span class="s2">,</span>
        <span class="s3">3</span><span class="s2">,</span>
        <span class="s3">4</span><span class="s2">,</span>
        <span class="s3">5</span><span class="s2">,</span>
        <span class="s3">6</span><span class="s2">,</span>
        <span class="s3">7</span><span class="s2">,</span>
        <span class="s3">8</span><span class="s2">,</span>
        <span class="s3">9</span><span class="s2">,</span>
        <span class="s3">10</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">11</span><span class="s2">,</span>
        <span class="s3">13</span><span class="s2">,</span>
        <span class="s3">17</span><span class="s2">,</span>
        <span class="s3">19</span><span class="s2">,</span>
        <span class="s3">18</span><span class="s2">,</span>
        <span class="s3">12</span><span class="s2">,</span>
        <span class="s3">16</span><span class="s2">,</span>
        <span class="s3">14</span><span class="s2">,</span>
        <span class="s3">47</span><span class="s2">,</span>
        <span class="s3">46</span><span class="s2">,</span>
        <span class="s3">20</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">25</span><span class="s2">,</span>
        <span class="s3">23</span><span class="s2">,</span>
        <span class="s3">27</span><span class="s2">,</span>
        <span class="s3">29</span><span class="s2">,</span>
        <span class="s3">24</span><span class="s2">,</span>
        <span class="s3">26</span><span class="s2">,</span>
        <span class="s3">28</span><span class="s2">,</span>
        <span class="s3">21</span><span class="s2">,</span>
        <span class="s3">30</span><span class="s2">,</span>
        <span class="s3">32</span><span class="s2">,</span>
        <span class="s3">34</span><span class="s2">,</span>
        <span class="s3">33</span><span class="s2">,</span>
        <span class="s3">38</span><span class="s2">,</span>
        <span class="s3">39</span><span class="s2">,</span>
        <span class="s3">35</span><span class="s2">,</span>
        <span class="s3">37</span><span class="s2">,</span>
        <span class="s3">36</span><span class="s2">,</span>
        <span class="s3">31</span><span class="s2">,</span>
        <span class="s3">40</span><span class="s2">,</span>
        <span class="s3">41</span><span class="s2">,</span>
        <span class="s3">42</span><span class="s2">,</span>
        <span class="s3">43</span><span class="s2">,</span>
        <span class="s3">44</span><span class="s2">,</span>
        <span class="s3">45</span><span class="s2">,</span>
        <span class="s3">48</span><span class="s2">,</span>
        <span class="s3">49</span><span class="s2">,</span>
        <span class="s3">50</span><span class="s2">,</span>
        <span class="s3">51</span><span class="s2">,</span>
        <span class="s3">52</span><span class="s2">,</span>
        <span class="s3">53</span><span class="s2">,</span>
        <span class="s3">54</span><span class="s2">,</span>
        <span class="s3">55</span><span class="s2">,</span>
        <span class="s3">56</span><span class="s2">,</span>
        <span class="s3">57</span><span class="s2">,</span>
        <span class="s3">58</span><span class="s2">,</span>
        <span class="s3">59</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">p2 = [</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s3">10</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">13</span><span class="s2">,</span>
        <span class="s3">13</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">11</span><span class="s2">,</span>
        <span class="s3">19</span><span class="s2">,</span>
        <span class="s3">15</span><span class="s2">,</span>
        <span class="s3">10</span><span class="s2">,</span>
        <span class="s3">47</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s3">20</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">25</span><span class="s2">,</span>
        <span class="s3">25</span><span class="s2">,</span>
        <span class="s3">25</span><span class="s2">,</span>
        <span class="s3">25</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">22</span><span class="s2">,</span>
        <span class="s3">23</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s3">30</span><span class="s2">,</span>
        <span class="s3">30</span><span class="s2">,</span>
        <span class="s3">34</span><span class="s2">,</span>
        <span class="s3">34</span><span class="s2">,</span>
        <span class="s3">34</span><span class="s2">,</span>
        <span class="s3">32</span><span class="s2">,</span>
        <span class="s3">32</span><span class="s2">,</span>
        <span class="s3">37</span><span class="s2">,</span>
        <span class="s3">38</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s3">1</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">clust2 = OPTICS(min_samples=</span><span class="s3">5</span><span class="s2">, </span><span class="s1">max_eps=</span><span class="s3">0.5</span><span class="s1">).fit(X)</span>

    <span class="s1">assert_array_equal(clust2.ordering_</span><span class="s2">, </span><span class="s1">np.array(o2))</span>
    <span class="s1">assert_array_equal(clust2.predecessor_[clust2.ordering_]</span><span class="s2">, </span><span class="s1">np.array(p2))</span>
    <span class="s1">assert_allclose(clust2.reachability_[clust2.ordering_]</span><span class="s2">, </span><span class="s1">np.array(r2))</span>

    <span class="s1">index = np.where(clust1.core_distances_ &lt;= </span><span class="s3">0.5</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">assert_allclose(clust1.core_distances_[index]</span><span class="s2">, </span><span class="s1">clust2.core_distances_[index])</span>


<span class="s2">def </span><span class="s1">test_extract_dbscan(global_dtype):</span>
    <span class="s0"># testing an easy dbscan case. Not including clusters with different</span>
    <span class="s0"># densities.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">n_points_per_cluster = </span><span class="s3">20</span>
    <span class="s1">C1 = [-</span><span class="s3">5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">0.2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">C2 = [</span><span class="s3">4</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">0.2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">C3 = [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">] + </span><span class="s3">0.2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">C4 = [-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] + </span><span class="s3">0.2 </span><span class="s1">* rng.randn(n_points_per_cluster</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">X = np.vstack((C1</span><span class="s2">, </span><span class="s1">C2</span><span class="s2">, </span><span class="s1">C3</span><span class="s2">, </span><span class="s1">C4)).astype(global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">clust = OPTICS(cluster_method=</span><span class="s4">&quot;dbscan&quot;</span><span class="s2">, </span><span class="s1">eps=</span><span class="s3">0.5</span><span class="s1">).fit(X)</span>
    <span class="s1">assert_array_equal(np.sort(np.unique(clust.labels_))</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;is_sparse&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_precomputed_dists(is_sparse</span><span class="s2">, </span><span class="s1">global_dtype):</span>
    <span class="s1">redX = X[::</span><span class="s3">2</span><span class="s1">].astype(global_dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">dists = pairwise_distances(redX</span><span class="s2">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span>
    <span class="s1">dists = sparse.csr_matrix(dists) </span><span class="s2">if </span><span class="s1">is_sparse </span><span class="s2">else </span><span class="s1">dists</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">EfficiencyWarning)</span>
        <span class="s1">clust1 = OPTICS(min_samples=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s2">, </span><span class="s1">metric=</span><span class="s4">&quot;precomputed&quot;</span><span class="s1">).fit(</span>
            <span class="s1">dists</span>
        <span class="s1">)</span>
    <span class="s1">clust2 = OPTICS(min_samples=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s2">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">).fit(redX)</span>

    <span class="s1">assert_allclose(clust1.reachability_</span><span class="s2">, </span><span class="s1">clust2.reachability_)</span>
    <span class="s1">assert_array_equal(clust1.labels_</span><span class="s2">, </span><span class="s1">clust2.labels_)</span>
</pre>
</body>
</html>