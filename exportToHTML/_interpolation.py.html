<html>
<head>
<title>_interpolation.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_interpolation.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) 2003-2005 Peter J. Verveer</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions</span>
<span class="s0"># are met:</span>
<span class="s0">#</span>
<span class="s0"># 1. Redistributions of source code must retain the above copyright</span>
<span class="s0">#    notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#</span>
<span class="s0"># 2. Redistributions in binary form must reproduce the above</span>
<span class="s0">#    copyright notice, this list of conditions and the following</span>
<span class="s0">#    disclaimer in the documentation and/or other materials provided</span>
<span class="s0">#    with the distribution.</span>
<span class="s0">#</span>
<span class="s0"># 3. The name of the author may not be used to endorse or promote</span>
<span class="s0">#    products derived from this software without specific prior</span>
<span class="s0">#    written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS</span>
<span class="s0"># OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0"># ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</span>
<span class="s0"># DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="s0"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE</span>
<span class="s0"># GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<span class="s0"># WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="s0"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="s0"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy</span>
<span class="s2">from </span><span class="s1">numpy.core.multiarray </span><span class="s2">import </span><span class="s1">normalize_axis_index</span>

<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">special</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_ni_support</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_nd_image</span>
<span class="s2">from </span><span class="s1">._ni_docstrings </span><span class="s2">import </span><span class="s1">docfiller</span>


<span class="s1">__all__ = [</span><span class="s3">'spline_filter1d'</span><span class="s2">, </span><span class="s3">'spline_filter'</span><span class="s2">, </span><span class="s3">'geometric_transform'</span><span class="s2">,</span>
           <span class="s3">'map_coordinates'</span><span class="s2">, </span><span class="s3">'affine_transform'</span><span class="s2">, </span><span class="s3">'shift'</span><span class="s2">, </span><span class="s3">'zoom'</span><span class="s2">, </span><span class="s3">'rotate'</span><span class="s1">]</span>


<span class="s1">@docfiller</span>
<span class="s2">def </span><span class="s1">spline_filter1d(input</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">output=numpy.float64</span><span class="s2">,</span>
                    <span class="s1">mode=</span><span class="s3">'mirror'</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate a 1-D spline filter along the given axis. 
 
    The lines of the array along the given axis are filtered by a 
    spline filter. The order of the spline must be &gt;= 2 and &lt;= 5. 
 
    Parameters 
    ---------- 
    %(input)s 
    order : int, optional 
        The order of the spline, default is 3. 
    axis : int, optional 
        The axis along which the spline filter is applied. Default is the last 
        axis. 
    output : ndarray or dtype, optional 
        The array in which to place the output, or the dtype of the returned 
        array. Default is ``numpy.float64``. 
    %(mode_interp_mirror)s 
 
    Returns 
    ------- 
    spline_filter1d : ndarray 
        The filtered input. 
 
    Notes 
    ----- 
    All of the interpolation functions in `ndimage` do spline interpolation of 
    the input image. If using B-splines of `order &gt; 1`, the input image 
    values have to be converted to B-spline coefficients first, which is 
    done by applying this 1-D filter sequentially along all 
    axes of the input. All functions that require B-spline coefficients 
    will automatically filter their inputs, a behavior controllable with 
    the `prefilter` keyword argument. For functions that accept a `mode` 
    parameter, the result will only be correct if it matches the `mode` 
    used when filtering. 
 
    For complex-valued `input`, this function processes the real and imaginary 
    components independently. 
 
    .. versionadded:: 1.6.0 
        Complex-valued support added. 
 
    See Also 
    -------- 
    spline_filter : Multidimensional spline filter. 
 
    Examples 
    -------- 
    We can filter an image using 1-D spline along the given axis: 
 
    &gt;&gt;&gt; from scipy.ndimage import spline_filter1d 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; orig_img = np.eye(20)  # create an image 
    &gt;&gt;&gt; orig_img[10, :] = 1.0 
    &gt;&gt;&gt; sp_filter_axis_0 = spline_filter1d(orig_img, axis=0) 
    &gt;&gt;&gt; sp_filter_axis_1 = spline_filter1d(orig_img, axis=1) 
    &gt;&gt;&gt; f, ax = plt.subplots(1, 3, sharex=True) 
    &gt;&gt;&gt; for ind, data in enumerate([[orig_img, &quot;original image&quot;], 
    ...             [sp_filter_axis_0, &quot;spline filter (axis=0)&quot;], 
    ...             [sp_filter_axis_1, &quot;spline filter (axis=1)&quot;]]): 
    ...     ax[ind].imshow(data[0], cmap='gray_r') 
    ...     ax[ind].set_title(data[1]) 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">order &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">order &gt; </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'spline order not supported'</span><span class="s1">)</span>
    <span class="s1">input = numpy.asarray(input)</span>
    <span class="s1">complex_output = numpy.iscomplexobj(input)</span>
    <span class="s1">output = _ni_support._get_output(output</span><span class="s2">, </span><span class="s1">input</span><span class="s2">,</span>
                                     <span class="s1">complex_output=complex_output)</span>
    <span class="s2">if </span><span class="s1">complex_output:</span>
        <span class="s1">spline_filter1d(input.real</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">output.real</span><span class="s2">, </span><span class="s1">mode)</span>
        <span class="s1">spline_filter1d(input.imag</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">output.imag</span><span class="s2">, </span><span class="s1">mode)</span>
        <span class="s2">return </span><span class="s1">output</span>
    <span class="s2">if </span><span class="s1">order </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s1">output[...] = numpy.array(input)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">mode = _ni_support._extend_mode_to_code(mode)</span>
        <span class="s1">axis = normalize_axis_index(axis</span><span class="s2">, </span><span class="s1">input.ndim)</span>
        <span class="s1">_nd_image.spline_filter1d(input</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, </span><span class="s1">mode)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">spline_filter(input</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">output=numpy.float64</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'mirror'</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Multidimensional spline filter. 
 
    For more details, see `spline_filter1d`. 
 
    See Also 
    -------- 
    spline_filter1d : Calculate a 1-D spline filter along the given axis. 
 
    Notes 
    ----- 
    The multidimensional filter is implemented as a sequence of 
    1-D spline filters. The intermediate arrays are stored 
    in the same data type as the output. Therefore, for output types 
    with a limited precision, the results may be imprecise because 
    intermediate results may be stored with insufficient precision. 
 
    For complex-valued `input`, this function processes the real and imaginary 
    components independently. 
 
    .. versionadded:: 1.6.0 
        Complex-valued support added. 
 
    Examples 
    -------- 
    We can filter an image using multidimentional splines: 
 
    &gt;&gt;&gt; from scipy.ndimage import spline_filter 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; orig_img = np.eye(20)  # create an image 
    &gt;&gt;&gt; orig_img[10, :] = 1.0 
    &gt;&gt;&gt; sp_filter = spline_filter(orig_img, order=3) 
    &gt;&gt;&gt; f, ax = plt.subplots(1, 2, sharex=True) 
    &gt;&gt;&gt; for ind, data in enumerate([[orig_img, &quot;original image&quot;], 
    ...                             [sp_filter, &quot;spline filter&quot;]]): 
    ...     ax[ind].imshow(data[0], cmap='gray_r') 
    ...     ax[ind].set_title(data[1]) 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">order &lt; </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">order &gt; </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'spline order not supported'</span><span class="s1">)</span>
    <span class="s1">input = numpy.asarray(input)</span>
    <span class="s1">complex_output = numpy.iscomplexobj(input)</span>
    <span class="s1">output = _ni_support._get_output(output</span><span class="s2">, </span><span class="s1">input</span><span class="s2">,</span>
                                     <span class="s1">complex_output=complex_output)</span>
    <span class="s2">if </span><span class="s1">complex_output:</span>
        <span class="s1">spline_filter(input.real</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">output.real</span><span class="s2">, </span><span class="s1">mode)</span>
        <span class="s1">spline_filter(input.imag</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">output.imag</span><span class="s2">, </span><span class="s1">mode)</span>
        <span class="s2">return </span><span class="s1">output</span>
    <span class="s2">if </span><span class="s1">order </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] </span><span class="s2">and </span><span class="s1">input.ndim &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range(input.ndim):</span>
            <span class="s1">spline_filter1d(input</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">output=output</span><span class="s2">, </span><span class="s1">mode=mode)</span>
            <span class="s1">input = output</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">output[...] = input[...]</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">_prepad_for_spline_filter(input</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval):</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nearest'</span><span class="s2">, </span><span class="s3">'grid-constant'</span><span class="s1">]:</span>
        <span class="s1">npad = </span><span class="s4">12</span>
        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'grid-constant'</span><span class="s1">:</span>
            <span class="s1">padded = numpy.pad(input</span><span class="s2">, </span><span class="s1">npad</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'constant'</span><span class="s2">,</span>
                               <span class="s1">constant_values=cval)</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">'nearest'</span><span class="s1">:</span>
            <span class="s1">padded = numpy.pad(input</span><span class="s2">, </span><span class="s1">npad</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'edge'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># other modes have exact boundary conditions implemented so</span>
        <span class="s0"># no prepadding is needed</span>
        <span class="s1">npad = </span><span class="s4">0</span>
        <span class="s1">padded = input</span>
    <span class="s2">return </span><span class="s1">padded</span><span class="s2">, </span><span class="s1">npad</span>


<span class="s1">@docfiller</span>
<span class="s2">def </span><span class="s1">geometric_transform(input</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">, </span><span class="s1">output_shape=</span><span class="s2">None,</span>
                        <span class="s1">output=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s4">3</span><span class="s2">,</span>
                        <span class="s1">mode=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">cval=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">prefilter=</span><span class="s2">True,</span>
                        <span class="s1">extra_arguments=()</span><span class="s2">, </span><span class="s1">extra_keywords={}):</span>
    <span class="s5">&quot;&quot;&quot; 
    Apply an arbitrary geometric transform. 
 
    The given mapping function is used to find, for each point in the 
    output, the corresponding coordinates in the input. The value of the 
    input at those coordinates is determined by spline interpolation of 
    the requested order. 
 
    Parameters 
    ---------- 
    %(input)s 
    mapping : {callable, scipy.LowLevelCallable} 
        A callable object that accepts a tuple of length equal to the output 
        array rank, and returns the corresponding input coordinates as a tuple 
        of length equal to the input array rank. 
    output_shape : tuple of ints, optional 
        Shape tuple. 
    %(output)s 
    order : int, optional 
        The order of the spline interpolation, default is 3. 
        The order has to be in the range 0-5. 
    %(mode_interp_constant)s 
    %(cval)s 
    %(prefilter)s 
    extra_arguments : tuple, optional 
        Extra arguments passed to `mapping`. 
    extra_keywords : dict, optional 
        Extra keywords passed to `mapping`. 
 
    Returns 
    ------- 
    output : ndarray 
        The filtered input. 
 
    See Also 
    -------- 
    map_coordinates, affine_transform, spline_filter1d 
 
 
    Notes 
    ----- 
    This function also accepts low-level callback functions with one 
    the following signatures and wrapped in `scipy.LowLevelCallable`: 
 
    .. code:: c 
 
       int mapping(npy_intp *output_coordinates, double *input_coordinates, 
                   int output_rank, int input_rank, void *user_data) 
       int mapping(intptr_t *output_coordinates, double *input_coordinates, 
                   int output_rank, int input_rank, void *user_data) 
 
    The calling function iterates over the elements of the output array, 
    calling the callback function at each element. The coordinates of the 
    current output element are passed through ``output_coordinates``. The 
    callback function must return the coordinates at which the input must 
    be interpolated in ``input_coordinates``. The rank of the input and 
    output arrays are given by ``input_rank`` and ``output_rank`` 
    respectively. ``user_data`` is the data pointer provided 
    to `scipy.LowLevelCallable` as-is. 
 
    The callback function must return an integer error status that is zero 
    if something went wrong and one otherwise. If an error occurs, you should 
    normally set the Python error status with an informative message 
    before returning, otherwise a default error message is set by the 
    calling function. 
 
    In addition, some other low-level function pointer specifications 
    are accepted, but these are for backward compatibility only and should 
    not be used in new code. 
 
    For complex-valued `input`, this function transforms the real and imaginary 
    components independently. 
 
    .. versionadded:: 1.6.0 
        Complex-valued support added. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.ndimage import geometric_transform 
    &gt;&gt;&gt; a = np.arange(12.).reshape((4, 3)) 
    &gt;&gt;&gt; def shift_func(output_coords): 
    ...     return (output_coords[0] - 0.5, output_coords[1] - 0.5) 
    ... 
    &gt;&gt;&gt; geometric_transform(a, shift_func) 
    array([[ 0.   ,  0.   ,  0.   ], 
           [ 0.   ,  1.362,  2.738], 
           [ 0.   ,  4.812,  6.187], 
           [ 0.   ,  8.263,  9.637]]) 
 
    &gt;&gt;&gt; b = [1, 2, 3, 4, 5] 
    &gt;&gt;&gt; def shift_func(output_coords): 
    ...     return (output_coords[0] - 3,) 
    ... 
    &gt;&gt;&gt; geometric_transform(b, shift_func, mode='constant') 
    array([0, 0, 0, 1, 2]) 
    &gt;&gt;&gt; geometric_transform(b, shift_func, mode='nearest') 
    array([1, 1, 1, 1, 2]) 
    &gt;&gt;&gt; geometric_transform(b, shift_func, mode='reflect') 
    array([3, 2, 1, 1, 2]) 
    &gt;&gt;&gt; geometric_transform(b, shift_func, mode='wrap') 
    array([2, 3, 4, 1, 2]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">order &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">order &gt; </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'spline order not supported'</span><span class="s1">)</span>
    <span class="s1">input = numpy.asarray(input)</span>
    <span class="s2">if </span><span class="s1">output_shape </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">output_shape = input.shape</span>
    <span class="s2">if </span><span class="s1">input.ndim &lt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">len(output_shape) &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'input and output rank must be &gt; 0'</span><span class="s1">)</span>
    <span class="s1">complex_output = numpy.iscomplexobj(input)</span>
    <span class="s1">output = _ni_support._get_output(output</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">shape=output_shape</span><span class="s2">,</span>
                                     <span class="s1">complex_output=complex_output)</span>
    <span class="s2">if </span><span class="s1">complex_output:</span>
        <span class="s1">kwargs = dict(order=order</span><span class="s2">, </span><span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">prefilter=prefilter</span><span class="s2">,</span>
                      <span class="s1">output_shape=output_shape</span><span class="s2">,</span>
                      <span class="s1">extra_arguments=extra_arguments</span><span class="s2">,</span>
                      <span class="s1">extra_keywords=extra_keywords)</span>
        <span class="s1">geometric_transform(input.real</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">, </span><span class="s1">output=output.real</span><span class="s2">,</span>
                            <span class="s1">cval=numpy.real(cval)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">geometric_transform(input.imag</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">, </span><span class="s1">output=output.imag</span><span class="s2">,</span>
                            <span class="s1">cval=numpy.imag(cval)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">output</span>

    <span class="s2">if </span><span class="s1">prefilter </span><span class="s2">and </span><span class="s1">order &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">padded</span><span class="s2">, </span><span class="s1">npad = _prepad_for_spline_filter(input</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval)</span>
        <span class="s1">filtered = spline_filter(padded</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">output=numpy.float64</span><span class="s2">,</span>
                                 <span class="s1">mode=mode)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">npad = </span><span class="s4">0</span>
        <span class="s1">filtered = input</span>
    <span class="s1">mode = _ni_support._extend_mode_to_code(mode)</span>
    <span class="s1">_nd_image.geometric_transform(filtered</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">, None, None, None, </span><span class="s1">output</span><span class="s2">,</span>
                                  <span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval</span><span class="s2">, </span><span class="s1">npad</span><span class="s2">, </span><span class="s1">extra_arguments</span><span class="s2">,</span>
                                  <span class="s1">extra_keywords)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s1">@docfiller</span>
<span class="s2">def </span><span class="s1">map_coordinates(input</span><span class="s2">, </span><span class="s1">coordinates</span><span class="s2">, </span><span class="s1">output=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s4">3</span><span class="s2">,</span>
                    <span class="s1">mode=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">cval=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">prefilter=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Map the input array to new coordinates by interpolation. 
 
    The array of coordinates is used to find, for each point in the output, 
    the corresponding coordinates in the input. The value of the input at 
    those coordinates is determined by spline interpolation of the 
    requested order. 
 
    The shape of the output is derived from that of the coordinate 
    array by dropping the first axis. The values of the array along 
    the first axis are the coordinates in the input array at which the 
    output value is found. 
 
    Parameters 
    ---------- 
    %(input)s 
    coordinates : array_like 
        The coordinates at which `input` is evaluated. 
    %(output)s 
    order : int, optional 
        The order of the spline interpolation, default is 3. 
        The order has to be in the range 0-5. 
    %(mode_interp_constant)s 
    %(cval)s 
    %(prefilter)s 
 
    Returns 
    ------- 
    map_coordinates : ndarray 
        The result of transforming the input. The shape of the output is 
        derived from that of `coordinates` by dropping the first axis. 
 
    See Also 
    -------- 
    spline_filter, geometric_transform, scipy.interpolate 
 
    Notes 
    ----- 
    For complex-valued `input`, this function maps the real and imaginary 
    components independently. 
 
    .. versionadded:: 1.6.0 
        Complex-valued support added. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.arange(12.).reshape((4, 3)) 
    &gt;&gt;&gt; a 
    array([[  0.,   1.,   2.], 
           [  3.,   4.,   5.], 
           [  6.,   7.,   8.], 
           [  9.,  10.,  11.]]) 
    &gt;&gt;&gt; ndimage.map_coordinates(a, [[0.5, 2], [0.5, 1]], order=1) 
    array([ 2.,  7.]) 
 
    Above, the interpolated value of a[0.5, 0.5] gives output[0], while 
    a[2, 1] is output[1]. 
 
    &gt;&gt;&gt; inds = np.array([[0.5, 2], [0.5, 4]]) 
    &gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, cval=-33.3) 
    array([  2. , -33.3]) 
    &gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, mode='nearest') 
    array([ 2.,  8.]) 
    &gt;&gt;&gt; ndimage.map_coordinates(a, inds, order=1, cval=0, output=bool) 
    array([ True, False], dtype=bool) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">order &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">order &gt; </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'spline order not supported'</span><span class="s1">)</span>
    <span class="s1">input = numpy.asarray(input)</span>
    <span class="s1">coordinates = numpy.asarray(coordinates)</span>
    <span class="s2">if </span><span class="s1">numpy.iscomplexobj(coordinates):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Complex type not supported'</span><span class="s1">)</span>
    <span class="s1">output_shape = coordinates.shape[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">input.ndim &lt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">len(output_shape) &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'input and output rank must be &gt; 0'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">coordinates.shape[</span><span class="s4">0</span><span class="s1">] != input.ndim:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'invalid shape for coordinate array'</span><span class="s1">)</span>
    <span class="s1">complex_output = numpy.iscomplexobj(input)</span>
    <span class="s1">output = _ni_support._get_output(output</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">shape=output_shape</span><span class="s2">,</span>
                                     <span class="s1">complex_output=complex_output)</span>
    <span class="s2">if </span><span class="s1">complex_output:</span>
        <span class="s1">kwargs = dict(order=order</span><span class="s2">, </span><span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">prefilter=prefilter)</span>
        <span class="s1">map_coordinates(input.real</span><span class="s2">, </span><span class="s1">coordinates</span><span class="s2">, </span><span class="s1">output=output.real</span><span class="s2">,</span>
                        <span class="s1">cval=numpy.real(cval)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">map_coordinates(input.imag</span><span class="s2">, </span><span class="s1">coordinates</span><span class="s2">, </span><span class="s1">output=output.imag</span><span class="s2">,</span>
                        <span class="s1">cval=numpy.imag(cval)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">output</span>
    <span class="s2">if </span><span class="s1">prefilter </span><span class="s2">and </span><span class="s1">order &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">padded</span><span class="s2">, </span><span class="s1">npad = _prepad_for_spline_filter(input</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval)</span>
        <span class="s1">filtered = spline_filter(padded</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">output=numpy.float64</span><span class="s2">,</span>
                                 <span class="s1">mode=mode)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">npad = </span><span class="s4">0</span>
        <span class="s1">filtered = input</span>
    <span class="s1">mode = _ni_support._extend_mode_to_code(mode)</span>
    <span class="s1">_nd_image.geometric_transform(filtered</span><span class="s2">, None, </span><span class="s1">coordinates</span><span class="s2">, None, None,</span>
                                  <span class="s1">output</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval</span><span class="s2">, </span><span class="s1">npad</span><span class="s2">, None, None</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s1">@docfiller</span>
<span class="s2">def </span><span class="s1">affine_transform(input</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">output_shape=</span><span class="s2">None,</span>
                     <span class="s1">output=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s4">3</span><span class="s2">,</span>
                     <span class="s1">mode=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">cval=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">prefilter=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Apply an affine transformation. 
 
    Given an output image pixel index vector ``o``, the pixel value 
    is determined from the input image at position 
    ``np.dot(matrix, o) + offset``. 
 
    This does 'pull' (or 'backward') resampling, transforming the output space 
    to the input to locate data. Affine transformations are often described in 
    the 'push' (or 'forward') direction, transforming input to output. If you 
    have a matrix for the 'push' transformation, use its inverse 
    (:func:`numpy.linalg.inv`) in this function. 
 
    Parameters 
    ---------- 
    %(input)s 
    matrix : ndarray 
        The inverse coordinate transformation matrix, mapping output 
        coordinates to input coordinates. If ``ndim`` is the number of 
        dimensions of ``input``, the given matrix must have one of the 
        following shapes: 
 
            - ``(ndim, ndim)``: the linear transformation matrix for each 
              output coordinate. 
            - ``(ndim,)``: assume that the 2-D transformation matrix is 
              diagonal, with the diagonal specified by the given value. A more 
              efficient algorithm is then used that exploits the separability 
              of the problem. 
            - ``(ndim + 1, ndim + 1)``: assume that the transformation is 
              specified using homogeneous coordinates [1]_. In this case, any 
              value passed to ``offset`` is ignored. 
            - ``(ndim, ndim + 1)``: as above, but the bottom row of a 
              homogeneous transformation matrix is always ``[0, 0, ..., 1]``, 
              and may be omitted. 
 
    offset : float or sequence, optional 
        The offset into the array where the transform is applied. If a float, 
        `offset` is the same for each axis. If a sequence, `offset` should 
        contain one value for each axis. 
    output_shape : tuple of ints, optional 
        Shape tuple. 
    %(output)s 
    order : int, optional 
        The order of the spline interpolation, default is 3. 
        The order has to be in the range 0-5. 
    %(mode_interp_constant)s 
    %(cval)s 
    %(prefilter)s 
 
    Returns 
    ------- 
    affine_transform : ndarray 
        The transformed input. 
 
    Notes 
    ----- 
    The given matrix and offset are used to find for each point in the 
    output the corresponding coordinates in the input by an affine 
    transformation. The value of the input at those coordinates is 
    determined by spline interpolation of the requested order. Points 
    outside the boundaries of the input are filled according to the given 
    mode. 
 
    .. versionchanged:: 0.18.0 
        Previously, the exact interpretation of the affine transformation 
        depended on whether the matrix was supplied as a 1-D or a 
        2-D array. If a 1-D array was supplied 
        to the matrix parameter, the output pixel value at index ``o`` 
        was determined from the input image at position 
        ``matrix * (o + offset)``. 
 
    For complex-valued `input`, this function transforms the real and imaginary 
    components independently. 
 
    .. versionadded:: 1.6.0 
        Complex-valued support added. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Homogeneous_coordinates 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">order &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">order &gt; </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'spline order not supported'</span><span class="s1">)</span>
    <span class="s1">input = numpy.asarray(input)</span>
    <span class="s2">if </span><span class="s1">output_shape </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(output</span><span class="s2">, </span><span class="s1">numpy.ndarray):</span>
            <span class="s1">output_shape = output.shape</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">output_shape = input.shape</span>
    <span class="s2">if </span><span class="s1">input.ndim &lt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">len(output_shape) &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'input and output rank must be &gt; 0'</span><span class="s1">)</span>
    <span class="s1">complex_output = numpy.iscomplexobj(input)</span>
    <span class="s1">output = _ni_support._get_output(output</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">shape=output_shape</span><span class="s2">,</span>
                                     <span class="s1">complex_output=complex_output)</span>
    <span class="s2">if </span><span class="s1">complex_output:</span>
        <span class="s1">kwargs = dict(offset=offset</span><span class="s2">, </span><span class="s1">output_shape=output_shape</span><span class="s2">, </span><span class="s1">order=order</span><span class="s2">,</span>
                      <span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">prefilter=prefilter)</span>
        <span class="s1">affine_transform(input.real</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">output=output.real</span><span class="s2">,</span>
                         <span class="s1">cval=numpy.real(cval)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">affine_transform(input.imag</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">output=output.imag</span><span class="s2">,</span>
                         <span class="s1">cval=numpy.imag(cval)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">output</span>
    <span class="s2">if </span><span class="s1">prefilter </span><span class="s2">and </span><span class="s1">order &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">padded</span><span class="s2">, </span><span class="s1">npad = _prepad_for_spline_filter(input</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval)</span>
        <span class="s1">filtered = spline_filter(padded</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">output=numpy.float64</span><span class="s2">,</span>
                                 <span class="s1">mode=mode)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">npad = </span><span class="s4">0</span>
        <span class="s1">filtered = input</span>
    <span class="s1">mode = _ni_support._extend_mode_to_code(mode)</span>
    <span class="s1">matrix = numpy.asarray(matrix</span><span class="s2">, </span><span class="s1">dtype=numpy.float64)</span>
    <span class="s2">if </span><span class="s1">matrix.ndim </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">] </span><span class="s2">or </span><span class="s1">matrix.shape[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'no proper affine matrix provided'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">(matrix.ndim == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">matrix.shape[</span><span class="s4">1</span><span class="s1">] == input.ndim + </span><span class="s4">1 </span><span class="s2">and</span>
            <span class="s1">(matrix.shape[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">[input.ndim</span><span class="s2">, </span><span class="s1">input.ndim + </span><span class="s4">1</span><span class="s1">])):</span>
        <span class="s2">if </span><span class="s1">matrix.shape[</span><span class="s4">0</span><span class="s1">] == input.ndim + </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">exptd = [</span><span class="s4">0</span><span class="s1">] * input.ndim + [</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">if not </span><span class="s1">numpy.all(matrix[input.ndim] == exptd):</span>
                <span class="s1">msg = (</span><span class="s3">'Expected homogeneous transformation matrix with '</span>
                       <span class="s3">'shape {} for image shape {}, but bottom row was '</span>
                       <span class="s3">'not equal to {}'</span><span class="s1">.format(matrix.shape</span><span class="s2">, </span><span class="s1">input.shape</span><span class="s2">, </span><span class="s1">exptd))</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s0"># assume input is homogeneous coordinate transformation matrix</span>
        <span class="s1">offset = matrix[:input.ndim</span><span class="s2">, </span><span class="s1">input.ndim]</span>
        <span class="s1">matrix = matrix[:input.ndim</span><span class="s2">, </span><span class="s1">:input.ndim]</span>
    <span class="s2">if </span><span class="s1">matrix.shape[</span><span class="s4">0</span><span class="s1">] != input.ndim:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'affine matrix has wrong number of rows'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">matrix.ndim == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">matrix.shape[</span><span class="s4">1</span><span class="s1">] != output.ndim:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'affine matrix has wrong number of columns'</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">matrix.flags.contiguous:</span>
        <span class="s1">matrix = matrix.copy()</span>
    <span class="s1">offset = _ni_support._normalize_sequence(offset</span><span class="s2">, </span><span class="s1">input.ndim)</span>
    <span class="s1">offset = numpy.asarray(offset</span><span class="s2">, </span><span class="s1">dtype=numpy.float64)</span>
    <span class="s2">if </span><span class="s1">offset.ndim != </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">offset.shape[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'no proper offset provided'</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">offset.flags.contiguous:</span>
        <span class="s1">offset = offset.copy()</span>
    <span class="s2">if </span><span class="s1">matrix.ndim == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;The behavior of affine_transform with a 1-D &quot;</span>
            <span class="s3">&quot;array supplied for the matrix parameter has changed in &quot;</span>
            <span class="s3">&quot;SciPy 0.18.0.&quot;</span>
        <span class="s1">)</span>
        <span class="s1">_nd_image.zoom_shift(filtered</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">offset/matrix</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, </span><span class="s1">order</span><span class="s2">,</span>
                             <span class="s1">mode</span><span class="s2">, </span><span class="s1">cval</span><span class="s2">, </span><span class="s1">npad</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">_nd_image.geometric_transform(filtered</span><span class="s2">, None, None, </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">,</span>
                                      <span class="s1">output</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval</span><span class="s2">, </span><span class="s1">npad</span><span class="s2">, None,</span>
                                      <span class="s2">None</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s1">@docfiller</span>
<span class="s2">def </span><span class="s1">shift(input</span><span class="s2">, </span><span class="s1">shift</span><span class="s2">, </span><span class="s1">output=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">cval=</span><span class="s4">0.0</span><span class="s2">,</span>
          <span class="s1">prefilter=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Shift an array. 
 
    The array is shifted using spline interpolation of the requested order. 
    Points outside the boundaries of the input are filled according to the 
    given mode. 
 
    Parameters 
    ---------- 
    %(input)s 
    shift : float or sequence 
        The shift along the axes. If a float, `shift` is the same for each 
        axis. If a sequence, `shift` should contain one value for each axis. 
    %(output)s 
    order : int, optional 
        The order of the spline interpolation, default is 3. 
        The order has to be in the range 0-5. 
    %(mode_interp_constant)s 
    %(cval)s 
    %(prefilter)s 
 
    Returns 
    ------- 
    shift : ndarray 
        The shifted input. 
 
    Notes 
    ----- 
    For complex-valued `input`, this function shifts the real and imaginary 
    components independently. 
 
    .. versionadded:: 1.6.0 
        Complex-valued support added. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">order &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">order &gt; </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'spline order not supported'</span><span class="s1">)</span>
    <span class="s1">input = numpy.asarray(input)</span>
    <span class="s2">if </span><span class="s1">input.ndim &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'input and output rank must be &gt; 0'</span><span class="s1">)</span>
    <span class="s1">complex_output = numpy.iscomplexobj(input)</span>
    <span class="s1">output = _ni_support._get_output(output</span><span class="s2">, </span><span class="s1">input</span><span class="s2">,</span>
                                     <span class="s1">complex_output=complex_output)</span>
    <span class="s2">if </span><span class="s1">complex_output:</span>
        <span class="s0"># import under different name to avoid confusion with shift parameter</span>
        <span class="s2">from </span><span class="s1">scipy.ndimage._interpolation </span><span class="s2">import </span><span class="s1">shift </span><span class="s2">as </span><span class="s1">_shift</span>

        <span class="s1">kwargs = dict(order=order</span><span class="s2">, </span><span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">prefilter=prefilter)</span>
        <span class="s1">_shift(input.real</span><span class="s2">, </span><span class="s1">shift</span><span class="s2">, </span><span class="s1">output=output.real</span><span class="s2">, </span><span class="s1">cval=numpy.real(cval)</span><span class="s2">,</span>
               <span class="s1">**kwargs)</span>
        <span class="s1">_shift(input.imag</span><span class="s2">, </span><span class="s1">shift</span><span class="s2">, </span><span class="s1">output=output.imag</span><span class="s2">, </span><span class="s1">cval=numpy.imag(cval)</span><span class="s2">,</span>
               <span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">output</span>
    <span class="s2">if </span><span class="s1">prefilter </span><span class="s2">and </span><span class="s1">order &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">padded</span><span class="s2">, </span><span class="s1">npad = _prepad_for_spline_filter(input</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval)</span>
        <span class="s1">filtered = spline_filter(padded</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">output=numpy.float64</span><span class="s2">,</span>
                                 <span class="s1">mode=mode)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">npad = </span><span class="s4">0</span>
        <span class="s1">filtered = input</span>
    <span class="s1">mode = _ni_support._extend_mode_to_code(mode)</span>
    <span class="s1">shift = _ni_support._normalize_sequence(shift</span><span class="s2">, </span><span class="s1">input.ndim)</span>
    <span class="s1">shift = [-ii </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">shift]</span>
    <span class="s1">shift = numpy.asarray(shift</span><span class="s2">, </span><span class="s1">dtype=numpy.float64)</span>
    <span class="s2">if not </span><span class="s1">shift.flags.contiguous:</span>
        <span class="s1">shift = shift.copy()</span>
    <span class="s1">_nd_image.zoom_shift(filtered</span><span class="s2">, None, </span><span class="s1">shift</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval</span><span class="s2">,</span>
                         <span class="s1">npad</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s1">@docfiller</span>
<span class="s2">def </span><span class="s1">zoom(input</span><span class="s2">, </span><span class="s1">zoom</span><span class="s2">, </span><span class="s1">output=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">cval=</span><span class="s4">0.0</span><span class="s2">,</span>
         <span class="s1">prefilter=</span><span class="s2">True, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">grid_mode=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Zoom an array. 
 
    The array is zoomed using spline interpolation of the requested order. 
 
    Parameters 
    ---------- 
    %(input)s 
    zoom : float or sequence 
        The zoom factor along the axes. If a float, `zoom` is the same for each 
        axis. If a sequence, `zoom` should contain one value for each axis. 
    %(output)s 
    order : int, optional 
        The order of the spline interpolation, default is 3. 
        The order has to be in the range 0-5. 
    %(mode_interp_constant)s 
    %(cval)s 
    %(prefilter)s 
    grid_mode : bool, optional 
        If False, the distance from the pixel centers is zoomed. Otherwise, the 
        distance including the full pixel extent is used. For example, a 1d 
        signal of length 5 is considered to have length 4 when `grid_mode` is 
        False, but length 5 when `grid_mode` is True. See the following 
        visual illustration: 
 
        .. code-block:: text 
 
                | pixel 1 | pixel 2 | pixel 3 | pixel 4 | pixel 5 | 
                     |&lt;--------------------------------------&gt;| 
                                        vs. 
                |&lt;-----------------------------------------------&gt;| 
 
        The starting point of the arrow in the diagram above corresponds to 
        coordinate location 0 in each mode. 
 
    Returns 
    ------- 
    zoom : ndarray 
        The zoomed input. 
 
    Notes 
    ----- 
    For complex-valued `input`, this function zooms the real and imaginary 
    components independently. 
 
    .. versionadded:: 1.6.0 
        Complex-valued support added. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.zoom(ascent, 3.0) 
    &gt;&gt;&gt; ax1.imshow(ascent, vmin=0, vmax=255) 
    &gt;&gt;&gt; ax2.imshow(result, vmin=0, vmax=255) 
    &gt;&gt;&gt; plt.show() 
 
    &gt;&gt;&gt; print(ascent.shape) 
    (512, 512) 
 
    &gt;&gt;&gt; print(result.shape) 
    (1536, 1536) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">order &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">order &gt; </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'spline order not supported'</span><span class="s1">)</span>
    <span class="s1">input = numpy.asarray(input)</span>
    <span class="s2">if </span><span class="s1">input.ndim &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'input and output rank must be &gt; 0'</span><span class="s1">)</span>
    <span class="s1">zoom = _ni_support._normalize_sequence(zoom</span><span class="s2">, </span><span class="s1">input.ndim)</span>
    <span class="s1">output_shape = tuple(</span>
            <span class="s1">[int(round(ii * jj)) </span><span class="s2">for </span><span class="s1">ii</span><span class="s2">, </span><span class="s1">jj </span><span class="s2">in </span><span class="s1">zip(input.shape</span><span class="s2">, </span><span class="s1">zoom)])</span>
    <span class="s1">complex_output = numpy.iscomplexobj(input)</span>
    <span class="s1">output = _ni_support._get_output(output</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">shape=output_shape</span><span class="s2">,</span>
                                     <span class="s1">complex_output=complex_output)</span>
    <span class="s2">if </span><span class="s1">complex_output:</span>
        <span class="s0"># import under different name to avoid confusion with zoom parameter</span>
        <span class="s2">from </span><span class="s1">scipy.ndimage._interpolation </span><span class="s2">import </span><span class="s1">zoom </span><span class="s2">as </span><span class="s1">_zoom</span>

        <span class="s1">kwargs = dict(order=order</span><span class="s2">, </span><span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">prefilter=prefilter)</span>
        <span class="s1">_zoom(input.real</span><span class="s2">, </span><span class="s1">zoom</span><span class="s2">, </span><span class="s1">output=output.real</span><span class="s2">, </span><span class="s1">cval=numpy.real(cval)</span><span class="s2">,</span>
              <span class="s1">**kwargs)</span>
        <span class="s1">_zoom(input.imag</span><span class="s2">, </span><span class="s1">zoom</span><span class="s2">, </span><span class="s1">output=output.imag</span><span class="s2">, </span><span class="s1">cval=numpy.imag(cval)</span><span class="s2">,</span>
              <span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">output</span>
    <span class="s2">if </span><span class="s1">prefilter </span><span class="s2">and </span><span class="s1">order &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">padded</span><span class="s2">, </span><span class="s1">npad = _prepad_for_spline_filter(input</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval)</span>
        <span class="s1">filtered = spline_filter(padded</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">output=numpy.float64</span><span class="s2">,</span>
                                 <span class="s1">mode=mode)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">npad = </span><span class="s4">0</span>
        <span class="s1">filtered = input</span>
    <span class="s2">if </span><span class="s1">grid_mode:</span>
        <span class="s0"># warn about modes that may have surprising behavior</span>
        <span class="s1">suggest_mode = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'constant'</span><span class="s1">:</span>
            <span class="s1">suggest_mode = </span><span class="s3">'grid-constant'</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">'wrap'</span><span class="s1">:</span>
            <span class="s1">suggest_mode = </span><span class="s3">'grid-wrap'</span>
        <span class="s2">if </span><span class="s1">suggest_mode </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s1">(</span><span class="s3">&quot;It is recommended to use mode = {} instead of {} when &quot;</span>
                 <span class="s3">&quot;grid_mode is True.&quot;</span><span class="s1">).format(suggest_mode</span><span class="s2">, </span><span class="s1">mode)</span>
            <span class="s1">)</span>
    <span class="s1">mode = _ni_support._extend_mode_to_code(mode)</span>

    <span class="s1">zoom_div = numpy.array(output_shape)</span>
    <span class="s1">zoom_nominator = numpy.array(input.shape)</span>
    <span class="s2">if not </span><span class="s1">grid_mode:</span>
        <span class="s1">zoom_div -= </span><span class="s4">1</span>
        <span class="s1">zoom_nominator -= </span><span class="s4">1</span>

    <span class="s0"># Zooming to infinite values is unpredictable, so just choose</span>
    <span class="s0"># zoom factor 1 instead</span>
    <span class="s1">zoom = numpy.divide(zoom_nominator</span><span class="s2">, </span><span class="s1">zoom_div</span><span class="s2">,</span>
                        <span class="s1">out=numpy.ones_like(input.shape</span><span class="s2">, </span><span class="s1">dtype=numpy.float64)</span><span class="s2">,</span>
                        <span class="s1">where=zoom_div != </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">zoom = numpy.ascontiguousarray(zoom)</span>
    <span class="s1">_nd_image.zoom_shift(filtered</span><span class="s2">, </span><span class="s1">zoom</span><span class="s2">, None, </span><span class="s1">output</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval</span><span class="s2">, </span><span class="s1">npad</span><span class="s2">,</span>
                         <span class="s1">grid_mode)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s1">@docfiller</span>
<span class="s2">def </span><span class="s1">rotate(input</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">axes=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">reshape=</span><span class="s2">True, </span><span class="s1">output=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s4">3</span><span class="s2">,</span>
           <span class="s1">mode=</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s1">cval=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">prefilter=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Rotate an array. 
 
    The array is rotated in the plane defined by the two axes given by the 
    `axes` parameter using spline interpolation of the requested order. 
 
    Parameters 
    ---------- 
    %(input)s 
    angle : float 
        The rotation angle in degrees. 
    axes : tuple of 2 ints, optional 
        The two axes that define the plane of rotation. Default is the first 
        two axes. 
    reshape : bool, optional 
        If `reshape` is true, the output shape is adapted so that the input 
        array is contained completely in the output. Default is True. 
    %(output)s 
    order : int, optional 
        The order of the spline interpolation, default is 3. 
        The order has to be in the range 0-5. 
    %(mode_interp_constant)s 
    %(cval)s 
    %(prefilter)s 
 
    Returns 
    ------- 
    rotate : ndarray 
        The rotated input. 
 
    Notes 
    ----- 
    For complex-valued `input`, this function rotates the real and imaginary 
    components independently. 
 
    .. versionadded:: 1.6.0 
        Complex-valued support added. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure(figsize=(10, 3)) 
    &gt;&gt;&gt; ax1, ax2, ax3 = fig.subplots(1, 3) 
    &gt;&gt;&gt; img = datasets.ascent() 
    &gt;&gt;&gt; img_45 = ndimage.rotate(img, 45, reshape=False) 
    &gt;&gt;&gt; full_img_45 = ndimage.rotate(img, 45, reshape=True) 
    &gt;&gt;&gt; ax1.imshow(img, cmap='gray') 
    &gt;&gt;&gt; ax1.set_axis_off() 
    &gt;&gt;&gt; ax2.imshow(img_45, cmap='gray') 
    &gt;&gt;&gt; ax2.set_axis_off() 
    &gt;&gt;&gt; ax3.imshow(full_img_45, cmap='gray') 
    &gt;&gt;&gt; ax3.set_axis_off() 
    &gt;&gt;&gt; fig.set_layout_engine('tight') 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; print(img.shape) 
    (512, 512) 
    &gt;&gt;&gt; print(img_45.shape) 
    (512, 512) 
    &gt;&gt;&gt; print(full_img_45.shape) 
    (724, 724) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input_arr = numpy.asarray(input)</span>
    <span class="s1">ndim = input_arr.ndim</span>

    <span class="s2">if </span><span class="s1">ndim &lt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'input array should be at least 2D'</span><span class="s1">)</span>

    <span class="s1">axes = list(axes)</span>

    <span class="s2">if </span><span class="s1">len(axes) != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'axes should contain exactly two values'</span><span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">all([float(ax).is_integer() </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axes]):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'axes should contain only integer values'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">axes[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">axes[</span><span class="s4">0</span><span class="s1">] += ndim</span>
    <span class="s2">if </span><span class="s1">axes[</span><span class="s4">1</span><span class="s1">] &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">axes[</span><span class="s4">1</span><span class="s1">] += ndim</span>
    <span class="s2">if </span><span class="s1">axes[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">axes[</span><span class="s4">1</span><span class="s1">] &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">axes[</span><span class="s4">0</span><span class="s1">] &gt;= ndim </span><span class="s2">or </span><span class="s1">axes[</span><span class="s4">1</span><span class="s1">] &gt;= ndim:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'invalid rotation plane specified'</span><span class="s1">)</span>

    <span class="s1">axes.sort()</span>

    <span class="s1">c</span><span class="s2">, </span><span class="s1">s = special.cosdg(angle)</span><span class="s2">, </span><span class="s1">special.sindg(angle)</span>

    <span class="s1">rot_matrix = numpy.array([[c</span><span class="s2">, </span><span class="s1">s]</span><span class="s2">,</span>
                              <span class="s1">[-s</span><span class="s2">, </span><span class="s1">c]])</span>

    <span class="s1">img_shape = numpy.asarray(input_arr.shape)</span>
    <span class="s1">in_plane_shape = img_shape[axes]</span>
    <span class="s2">if </span><span class="s1">reshape:</span>
        <span class="s0"># Compute transformed input bounds</span>
        <span class="s1">iy</span><span class="s2">, </span><span class="s1">ix = in_plane_shape</span>
        <span class="s1">out_bounds = rot_matrix @ [[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">iy</span><span class="s2">, </span><span class="s1">iy]</span><span class="s2">,</span>
                                   <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">ix</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">ix]]</span>
        <span class="s0"># Compute the shape of the transformed input plane</span>
        <span class="s1">out_plane_shape = (out_bounds.ptp(axis=</span><span class="s4">1</span><span class="s1">) + </span><span class="s4">0.5</span><span class="s1">).astype(int)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">out_plane_shape = img_shape[axes]</span>

    <span class="s1">out_center = rot_matrix @ ((out_plane_shape - </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">in_center = (in_plane_shape - </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span>
    <span class="s1">offset = in_center - out_center</span>

    <span class="s1">output_shape = img_shape</span>
    <span class="s1">output_shape[axes] = out_plane_shape</span>
    <span class="s1">output_shape = tuple(output_shape)</span>

    <span class="s1">complex_output = numpy.iscomplexobj(input_arr)</span>
    <span class="s1">output = _ni_support._get_output(output</span><span class="s2">, </span><span class="s1">input_arr</span><span class="s2">, </span><span class="s1">shape=output_shape</span><span class="s2">,</span>
                                     <span class="s1">complex_output=complex_output)</span>

    <span class="s2">if </span><span class="s1">ndim &lt;= </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">affine_transform(input_arr</span><span class="s2">, </span><span class="s1">rot_matrix</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">output_shape</span><span class="s2">, </span><span class="s1">output</span><span class="s2">,</span>
                         <span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval</span><span class="s2">, </span><span class="s1">prefilter)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># If ndim &gt; 2, the rotation is applied over all the planes</span>
        <span class="s0"># parallel to axes</span>
        <span class="s1">planes_coord = itertools.product(</span>
            <span class="s1">*[[slice(</span><span class="s2">None</span><span class="s1">)] </span><span class="s2">if </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axes </span><span class="s2">else </span><span class="s1">range(img_shape[ax])</span>
              <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">range(ndim)])</span>

        <span class="s1">out_plane_shape = tuple(out_plane_shape)</span>

        <span class="s2">for </span><span class="s1">coordinates </span><span class="s2">in </span><span class="s1">planes_coord:</span>
            <span class="s1">ia = input_arr[coordinates]</span>
            <span class="s1">oa = output[coordinates]</span>
            <span class="s1">affine_transform(ia</span><span class="s2">, </span><span class="s1">rot_matrix</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">out_plane_shape</span><span class="s2">,</span>
                             <span class="s1">oa</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">cval</span><span class="s2">, </span><span class="s1">prefilter)</span>

    <span class="s2">return </span><span class="s1">output</span>
</pre>
</body>
</html>