<html>
<head>
<title>test_simulate.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_simulate.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for simulation of time series 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_equal</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">scipy.signal </span><span class="s2">import </span><span class="s1">lfilter</span>

<span class="s2">from </span><span class="s1">.test_impulse_responses </span><span class="s2">import </span><span class="s1">TVSS</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s2">import </span><span class="s1">SpecificationWarning</span><span class="s2">, </span><span class="s1">\</span>
    <span class="s1">EstimationWarning</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">(sarimax</span><span class="s2">, </span><span class="s1">structural</span><span class="s2">, </span><span class="s1">varmax</span><span class="s2">,</span>
                                        <span class="s1">dynamic_factor)</span>


<span class="s2">def </span><span class="s1">test_arma_lfilter():</span>
    <span class="s3"># Tests of an ARMA model simulation against scipy.signal.lfilter</span>
    <span class="s3"># Note: the first elements of the generated SARIMAX datasets are based on</span>
    <span class="s3"># the initial state, so we do not include them in the comparisons</span>
    <span class="s1">np.random.seed(</span><span class="s4">10239</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s4">100</span>
    <span class="s1">eps = np.random.normal(size=nobs)</span>

    <span class="s3"># AR(1)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eps)</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># MA(1)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = lfilter([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eps)</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># ARMA(1, 1)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = lfilter([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eps)</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_arma_direct():</span>
    <span class="s3"># Tests of an ARMA model simulation against direct construction</span>
    <span class="s3"># This is useful for e.g. trend components</span>
    <span class="s3"># Note: the first elements of the generated SARIMAX datasets are based on</span>
    <span class="s3"># the initial state, so we do not include them in the comparisons</span>
    <span class="s1">np.random.seed(</span><span class="s4">10239</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s4">100</span>
    <span class="s1">eps = np.random.normal(size=nobs)</span>
    <span class="s1">exog = np.random.normal(size=nobs)</span>

    <span class="s3"># AR(1)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = np.zeros(nobs)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">desired[i] = eps[i]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">desired[i] = </span><span class="s4">0.5 </span><span class="s1">* desired[i - </span><span class="s4">1</span><span class="s1">] + eps[i]</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># MA(1)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = np.zeros(nobs)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">desired[i] = eps[i]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">desired[i] = </span><span class="s4">0.5 </span><span class="s1">* eps[i - </span><span class="s4">1</span><span class="s1">] + eps[i]</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># ARMA(1, 1)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = np.zeros(nobs)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">desired[i] = eps[i]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">desired[i] = </span><span class="s4">0.5 </span><span class="s1">* desired[i - </span><span class="s4">1</span><span class="s1">] + </span><span class="s4">0.2 </span><span class="s1">* eps[i - </span><span class="s4">1</span><span class="s1">] + eps[i]</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># ARMA(1, 1) + intercept</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.3</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = np.zeros(nobs)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s1">trend = </span><span class="s4">1.3</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">desired[i] = trend + eps[i]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">desired[i] = (trend + </span><span class="s4">0.5 </span><span class="s1">* desired[i - </span><span class="s4">1</span><span class="s1">] +</span>
                          <span class="s4">0.2 </span><span class="s1">* eps[i - </span><span class="s4">1</span><span class="s1">] + eps[i])</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># ARMA(1, 1) + intercept + time trend</span>
    <span class="s3"># Note: to allow time-varying SARIMAX to simulate 101 observations, need to</span>
    <span class="s3"># give it 101 observations up front</span>
    <span class="s1">mod = sarimax.SARIMAX(np.zeros(nobs + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'ct'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.3</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = np.zeros(nobs)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s1">trend = </span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">0.2 </span><span class="s1">* (i + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">desired[i] = trend + eps[i]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">desired[i] = (trend + </span><span class="s4">0.5 </span><span class="s1">* desired[i - </span><span class="s4">1</span><span class="s1">] +</span>
                          <span class="s4">0.2 </span><span class="s1">* eps[i - </span><span class="s4">1</span><span class="s1">] + eps[i])</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># ARMA(1, 1) + intercept + time trend + exog</span>
    <span class="s3"># Note: to allow time-varying SARIMAX to simulate 101 observations, need to</span>
    <span class="s3"># give it 101 observations up front</span>
    <span class="s3"># Note: the model is regression with SARIMAX errors, so the exog is</span>
    <span class="s3"># introduced into the observation equation rather than the ARMA part</span>
    <span class="s1">mod = sarimax.SARIMAX(np.zeros(nobs + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">exog]</span><span class="s2">,</span>
                          <span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'ct'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.3</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.r_[eps</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">desired = np.zeros(nobs)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s1">trend = </span><span class="s4">1.3 </span><span class="s1">+ </span><span class="s4">0.2 </span><span class="s1">* (i + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">desired[i] = trend + eps[i]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">desired[i] = (trend + </span><span class="s4">0.5 </span><span class="s1">* desired[i - </span><span class="s4">1</span><span class="s1">] +</span>
                          <span class="s4">0.2 </span><span class="s1">* eps[i - </span><span class="s4">1</span><span class="s1">] + eps[i])</span>
    <span class="s1">desired = desired - </span><span class="s4">0.5 </span><span class="s1">* exog</span>
    <span class="s1">assert_allclose(actual[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_structural():</span>
    <span class="s1">np.random.seed(</span><span class="s4">38947</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s4">100</span>
    <span class="s1">eps = np.random.normal(size=nobs)</span>
    <span class="s1">exog = np.random.normal(size=nobs)</span>

    <span class="s1">eps1 = np.zeros(nobs)</span>
    <span class="s1">eps2 = np.zeros(nobs)</span>
    <span class="s1">eps2[</span><span class="s4">49</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s1">eps3 = np.zeros(nobs)</span>
    <span class="s1">eps3[</span><span class="s4">50</span><span class="s1">:] = </span><span class="s4">1</span>

    <span class="s3"># AR(1)</span>
    <span class="s1">mod1 = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">autoregressive=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod1.simulate([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(mod1.k_states))</span>
    <span class="s1">desired = mod2.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                            <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># ARX(1)</span>
    <span class="s1">mod1 = structural.UnobservedComponents(np.zeros(nobs)</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                                           <span class="s1">autoregressive=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX(np.zeros(nobs)</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod1.simulate([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">desired = mod2.simulate([</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                            <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Irregular</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">eps)</span>

    <span class="s3"># Fixed intercept</span>
    <span class="s3"># (in practice this is a deterministic constant, because an irregular</span>
    <span class="s3">#  component must be added)</span>
    <span class="s1">warning = SpecificationWarning</span>
    <span class="s1">match = </span><span class="s5">'irregular component added'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'fixed intercept'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">initial_state=[</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">10 </span><span class="s1">+ eps)</span>

    <span class="s3"># Deterministic constant</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'deterministic constant'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">initial_state=[</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">10 </span><span class="s1">+ eps)</span>

    <span class="s3"># Local level</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'local level'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">eps + eps3)</span>

    <span class="s3"># Random walk</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'random walk'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">eps + eps3)</span>

    <span class="s3"># Fixed slope</span>
    <span class="s3"># (in practice this is a deterministic trend, because an irregular</span>
    <span class="s3">#  component must be added)</span>
    <span class="s1">warning = SpecificationWarning</span>
    <span class="s1">match = </span><span class="s5">'irregular component added'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'fixed slope'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">eps + np.arange(</span><span class="s4">100</span><span class="s1">))</span>

    <span class="s3"># Deterministic trend</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'deterministic trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">eps + np.arange(</span><span class="s4">100</span><span class="s1">))</span>

    <span class="s3"># Local linear deterministic trend</span>
    <span class="s1">mod = structural.UnobservedComponents(</span>
        <span class="s1">[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'local linear deterministic trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = eps + np.r_[np.arange(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ np.arange(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Random walk with drift</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'random walk with drift'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps2</span><span class="s2">,</span>
                          <span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = np.r_[np.arange(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ np.arange(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Local linear trend</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'local linear trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.c_[eps2</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = eps + np.r_[np.arange(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ np.arange(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps2]</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = eps + np.r_[np.arange(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">150</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Smooth trend</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'smooth trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps1</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = eps + np.r_[np.arange(</span><span class="s4">100</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = eps + np.r_[np.arange(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">150</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Random trend</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'random trend'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps1</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = np.r_[np.arange(</span><span class="s4">100</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = np.r_[np.arange(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">150</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Seasonal (deterministic)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">2</span><span class="s2">,</span>
                                          <span class="s1">stochastic_seasonal=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">initial_state=[</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">desired = eps + np.tile([</span><span class="s4">10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Seasonal (stochastic)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">desired = eps + np.r_[np.tile([</span><span class="s4">10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s4">25</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.tile([</span><span class="s4">11</span><span class="s2">, </span><span class="s1">-</span><span class="s4">11</span><span class="s1">]</span><span class="s2">, </span><span class="s4">25</span><span class="s1">)]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Cycle (deterministic)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s2">, </span><span class="s1">cycle=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">initial_state=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">x1 = [np.cos(</span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sin(</span><span class="s4">1.2</span><span class="s1">)]</span>
    <span class="s1">x2 = [-np.sin(</span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.cos(</span><span class="s4">1.2</span><span class="s1">)]</span>
    <span class="s1">T = np.array([x1</span><span class="s2">, </span><span class="s1">x2])</span>
    <span class="s1">desired = eps</span>
    <span class="s1">states = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s1">desired[i] += states[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">states = np.dot(T</span><span class="s2">, </span><span class="s1">states)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Cycle (stochastic)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'irregular'</span><span class="s2">, </span><span class="s1">cycle=</span><span class="s2">True,</span>
                                          <span class="s1">stochastic_cycle=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.c_[eps2</span><span class="s2">, </span><span class="s1">eps2]</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">x1 = [np.cos(</span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sin(</span><span class="s4">1.2</span><span class="s1">)]</span>
    <span class="s1">x2 = [-np.sin(</span><span class="s4">1.2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.cos(</span><span class="s4">1.2</span><span class="s1">)]</span>
    <span class="s1">T = np.array([x1</span><span class="s2">, </span><span class="s1">x2])</span>
    <span class="s1">desired = eps</span>
    <span class="s1">states = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s1">desired[i] += states[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">states = np.dot(T</span><span class="s2">, </span><span class="s1">states) + eps2[i]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_varmax():</span>
    <span class="s1">np.random.seed(</span><span class="s4">371934</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s4">100</span>
    <span class="s1">eps = np.random.normal(size=nobs)</span>
    <span class="s1">exog = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">eps1 = np.zeros(nobs)</span>
    <span class="s1">eps2 = np.zeros(nobs)</span>
    <span class="s1">eps2[</span><span class="s4">49</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s1">eps3 = np.zeros(nobs)</span>
    <span class="s1">eps3[</span><span class="s4">50</span><span class="s1">:] = </span><span class="s4">1</span>

    <span class="s3"># VAR(2) - single series</span>
    <span class="s1">mod1 = varmax.VARMAX([[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod1.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(mod1.k_states))</span>
    <span class="s1">desired = mod2.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                            <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VMA(2) - single series</span>
    <span class="s1">mod1 = varmax.VARMAX([[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">actual = mod1.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(mod1.k_states))</span>
    <span class="s1">desired = mod2.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                            <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VARMA(2, 2) - single series</span>
    <span class="s1">warning = EstimationWarning</span>
    <span class="s1">match = </span><span class="s5">r'VARMA\(p,q\) models is not'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">mod1 = varmax.VARMAX([[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">actual = mod1.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(mod1.k_states))</span>
    <span class="s1">desired = mod2.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                            <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VARMA(2, 2) + trend - single series</span>
    <span class="s1">warning = EstimationWarning</span>
    <span class="s1">match = </span><span class="s5">r'VARMA\(p,q\) models is not'</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">mod1 = varmax.VARMAX([[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s1">actual = mod1.simulate([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                           <span class="s1">state_shocks=eps</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(mod1.k_states))</span>
    <span class="s1">desired = mod2.simulate([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                            <span class="s1">state_shocks=eps</span><span class="s2">,</span>
                            <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VAR(1)</span>
    <span class="s1">transition = np.array([[</span><span class="s4">0.5</span><span class="s2">,  </span><span class="s4">0.1</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">[-</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]])</span>

    <span class="s1">mod = varmax.VARMAX([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate(np.r_[transition.ravel()</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">actual = mod.simulate(np.r_[transition.ravel()</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = np.zeros((nobs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">state = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s1">desired[i] = state</span>
        <span class="s1">state = np.dot(transition</span><span class="s2">, </span><span class="s1">state)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VAR(1) + measurement error</span>
    <span class="s1">mod = varmax.VARMAX([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s2">,</span>
                        <span class="s1">measurement_error=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">actual = mod.simulate(np.r_[transition.ravel()</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=np.c_[eps</span><span class="s2">, </span><span class="s1">eps]</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.c_[eps</span><span class="s2">, </span><span class="s1">eps])</span>

    <span class="s3"># VARX(1)</span>
    <span class="s1">mod = varmax.VARMAX(np.zeros((nobs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s2">,</span>
                        <span class="s1">exog=exog)</span>
    <span class="s1">actual = mod.simulate(np.r_[transition.ravel()</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">, </span><span class="s1">initial_state=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">desired = np.zeros((nobs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">state = np.r_[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nobs):</span>
        <span class="s1">desired[i] = state</span>
        <span class="s2">if </span><span class="s1">i &lt; nobs - </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">state = exog[i + </span><span class="s4">1</span><span class="s1">] * [</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">] + np.dot(transition</span><span class="s2">, </span><span class="s1">state)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># VMA(1)</span>
    <span class="s3"># TODO: This is just a smoke test</span>
    <span class="s1">mod = varmax.VARMAX(</span>
        <span class="s1">np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">mod.simulate(mod.start_params</span><span class="s2">, </span><span class="s1">nobs)</span>

    <span class="s3"># VARMA(2, 2) + trend + exog</span>
    <span class="s3"># TODO: This is just a smoke test</span>
    <span class="s1">warning = EstimationWarning</span>
    <span class="s1">match = </span><span class="s5">r&quot;VARMA\(p,q\) models is not&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.warns(warning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">mod = varmax.VARMAX(</span>
            <span class="s1">np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s2">,</span>
            <span class="s1">exog=exog)</span>
    <span class="s1">mod.simulate(mod.start_params</span><span class="s2">, </span><span class="s1">nobs)</span>


<span class="s2">def </span><span class="s1">test_dynamic_factor():</span>
    <span class="s1">np.random.seed(</span><span class="s4">93739</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s4">100</span>
    <span class="s1">eps = np.random.normal(size=nobs)</span>
    <span class="s1">exog = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">eps1 = np.zeros(nobs)</span>
    <span class="s1">eps2 = np.zeros(nobs)</span>
    <span class="s1">eps2[</span><span class="s4">49</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s1">eps3 = np.zeros(nobs)</span>
    <span class="s1">eps3[</span><span class="s4">50</span><span class="s1">:] = </span><span class="s4">1</span>

    <span class="s3"># DFM: 2 series, AR(2) factor</span>
    <span class="s1">mod1 = dynamic_factor.DynamicFactor([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod1.simulate([-</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                           <span class="s1">measurement_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">,</span>
                           <span class="s1">state_shocks=eps</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(mod1.k_states))</span>
    <span class="s1">desired = mod2.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                            <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.9 </span><span class="s1">* desired)</span>
    <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.8 </span><span class="s1">* desired)</span>

    <span class="s3"># DFM: 2 series, AR(2) factor, exog</span>
    <span class="s1">mod1 = dynamic_factor.DynamicFactor(np.zeros((nobs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">,</span>
                                        <span class="s1">factor_order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">mod2 = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">actual = mod1.simulate([-</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                           <span class="s1">measurement_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">,</span>
                           <span class="s1">state_shocks=eps</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(mod1.k_states))</span>
    <span class="s1">desired = mod2.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps</span><span class="s2">,</span>
                            <span class="s1">initial_state=np.zeros(mod2.k_states))</span>
    <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.9 </span><span class="s1">* desired + </span><span class="s4">5 </span><span class="s1">* exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.8 </span><span class="s1">* desired - </span><span class="s4">2 </span><span class="s1">* exog[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>

    <span class="s3"># DFM, 3 series, VAR(2) factor, exog, error VAR</span>
    <span class="s3"># TODO: This is just a smoke test</span>
    <span class="s1">mod = dynamic_factor.DynamicFactor(np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span><span class="s2">,</span>
                                       <span class="s1">k_factors=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                                       <span class="s1">error_order=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">error_var=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod.simulate(mod.start_params</span><span class="s2">, </span><span class="s1">nobs)</span>


<span class="s2">def </span><span class="s1">test_known_initialization():</span>
    <span class="s3"># Need to test that &quot;known&quot; initialization is taken into account in</span>
    <span class="s3"># time series simulation</span>
    <span class="s1">np.random.seed(</span><span class="s4">38947</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s4">100</span>
    <span class="s1">eps = np.random.normal(size=nobs)</span>

    <span class="s1">eps1 = np.zeros(nobs)</span>
    <span class="s1">eps2 = np.zeros(nobs)</span>
    <span class="s1">eps2[</span><span class="s4">49</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s1">eps3 = np.zeros(nobs)</span>
    <span class="s1">eps3[</span><span class="s4">50</span><span class="s1">:] = </span><span class="s4">1</span>

    <span class="s3"># SARIMAX</span>
    <span class="s3"># (test that when state shocks are shut down, the initial state</span>
    <span class="s3"># geometrically declines according to the AR parameter)</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">mod.ssm.initialize_known([</span><span class="s4">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">state_shocks=eps1)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">100 </span><span class="s1">* </span><span class="s4">0.5</span><span class="s1">**np.arange(nobs))</span>

    <span class="s3"># Unobserved components</span>
    <span class="s3"># (test that the initial level shifts the entire path)</span>
    <span class="s1">mod = structural.UnobservedComponents([</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'local level'</span><span class="s1">)</span>
    <span class="s1">mod.ssm.initialize_known([</span><span class="s4">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">actual = mod.simulate([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">measurement_shocks=eps</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps2)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">100 </span><span class="s1">+ eps + eps3)</span>

    <span class="s3"># VARMAX</span>
    <span class="s3"># (here just test that with an independent VAR we have each initial state</span>
    <span class="s3"># geometrically declining at the appropriate rate)</span>
    <span class="s1">transition = np.diag([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">])</span>
    <span class="s1">mod = varmax.VARMAX([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">mod.initialize_known([</span><span class="s4">100</span><span class="s2">, </span><span class="s4">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.diag([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
    <span class="s1">actual = mod.simulate(np.r_[transition.ravel()</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">,</span>
                          <span class="s1">state_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1])</span>

    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.c_[</span><span class="s4">100 </span><span class="s1">* </span><span class="s4">0.5</span><span class="s1">**np.arange(nobs)</span><span class="s2">,</span>
                                  <span class="s4">50 </span><span class="s1">* </span><span class="s4">0.2</span><span class="s1">**np.arange(nobs)])</span>

    <span class="s3"># Dynamic factor</span>
    <span class="s3"># (test that the initial state declines geometrically and then loads</span>
    <span class="s3"># correctly onto the series)</span>
    <span class="s1">mod = dynamic_factor.DynamicFactor([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">mod.initialize_known([</span><span class="s4">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s1">]])</span>

    <span class="s1">actual = mod.simulate([</span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=np.c_[eps1</span><span class="s2">, </span><span class="s1">eps1]</span><span class="s2">,</span>
                          <span class="s1">state_shocks=eps1)</span>
    <span class="s1">tmp = </span><span class="s4">100 </span><span class="s1">* </span><span class="s4">0.5</span><span class="s1">**np.arange(nobs)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.c_[</span><span class="s4">0.8 </span><span class="s1">* tmp</span><span class="s2">, </span><span class="s4">0.2 </span><span class="s1">* tmp])</span>


<span class="s2">def </span><span class="s1">test_sequential_simulate():</span>
    <span class="s3"># Test that we can perform simulation, change the system matrices, and then</span>
    <span class="s3"># perform simulation again (i.e. check that everything updates correctly</span>
    <span class="s3"># in the simulation smoother).</span>
    <span class="s1">n_simulations = </span><span class="s4">100</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'c'</span><span class="s1">)</span>

    <span class="s1">actual = mod.simulate([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n_simulations)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.ones(n_simulations))</span>

    <span class="s1">actual = mod.simulate([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n_simulations)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">np.ones(n_simulations) * </span><span class="s4">10</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sarimax_end_time_invariant_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-invariant SARIMAX model</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">assert_allclose(initial_state</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Compute the desired simulated values directly</span>
    <span class="s1">desired = </span><span class="s4">10 </span><span class="s1">* </span><span class="s4">0.5</span><span class="s1">**np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations))</span>


<span class="s2">def </span><span class="s1">test_sarimax_simple_differencing_end_time_invariant_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-invariant SARIMAX model</span>
    <span class="s3"># in which simple differencing is used.</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.cumsum(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">assert_allclose(initial_state</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Compute the desired simulated values directly</span>
    <span class="s1">desired = </span><span class="s4">10 </span><span class="s1">* </span><span class="s4">0.5</span><span class="s1">**np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations))</span>


<span class="s2">def </span><span class="s1">test_sarimax_time_invariant_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-invariant SARIMAX model,</span>
    <span class="s3"># with nonzero shocks</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">state_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = (</span>
        <span class="s1">lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.r_[initial_state</span><span class="s2">, </span><span class="s1">state_shocks])[:-</span><span class="s4">1</span><span class="s1">] +</span>
        <span class="s1">measurement_shocks)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_sarimax_simple_differencing_end_time_invariant_shocks():</span>
    <span class="s3"># Test simulating values from the end of a time-invariant SARIMAX model</span>
    <span class="s3"># in which simple differencing is used.</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.cumsum(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">state_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = (</span>
        <span class="s1">lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.r_[initial_state</span><span class="s2">, </span><span class="s1">state_shocks])[:-</span><span class="s4">1</span><span class="s1">] +</span>
        <span class="s1">measurement_shocks)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_sarimax_time_varying_trend_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-varying SARIMAX model</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'t'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">assert_allclose(initial_state</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Compute the desired simulated values directly</span>
    <span class="s1">desired = lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">12</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations))</span>


<span class="s2">def </span><span class="s1">test_sarimax_simple_differencing_time_varying_trend_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-varying SARIMAX model</span>
    <span class="s3"># in which simple differencing is used.</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.cumsum(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'t'</span><span class="s2">,</span>
                          <span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">assert_allclose(initial_state</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Compute the desired simulated values directly</span>
    <span class="s1">desired = lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.r_[</span><span class="s4">12</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations))</span>


<span class="s2">def </span><span class="s1">test_sarimax_time_varying_trend_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-varying SARIMAX model,</span>
    <span class="s3"># with nonzero shocks</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'t'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">state_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">x = np.r_[initial_state</span><span class="s2">, </span><span class="s1">state_shocks + np.arange(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)]</span>
    <span class="s1">desired = lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x)[:-</span><span class="s4">1</span><span class="s1">] + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_sarimax_simple_differencing_time_varying_trend_shocks(</span>
        <span class="s1">reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-varying SARIMAX model</span>
    <span class="s3"># in which simple differencing is used.</span>
    <span class="s3"># with nonzero shocks</span>
    <span class="s1">endog = np.cumsum(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'t'</span><span class="s2">,</span>
                          <span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">state_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">assert_allclose(initial_state</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">x = np.r_[initial_state</span><span class="s2">, </span><span class="s1">state_shocks + np.arange(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)]</span>
    <span class="s1">desired = lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x)[:-</span><span class="s4">1</span><span class="s1">] + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_sarimax_time_varying_exog_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-varying SARIMAX model</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s3"># Note that `exog` here has basically the same effect as measurement shocks</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Compute the desired simulated values directly</span>
    <span class="s1">desired = (lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.r_[initial_state</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">9</span><span class="s1">]) +</span>
               <span class="s1">exog[</span><span class="s4">10</span><span class="s1">:])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_sarimax_simple_differencing_time_varying_exog_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-varying SARIMAX model</span>
    <span class="s3"># with simple differencing</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.cumsum(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span>
    <span class="s1">exog = np.cumsum(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">11</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">11</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Compute the desired simulated values directly</span>
    <span class="s1">desired = (lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.r_[initial_state</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">9</span><span class="s1">]) +</span>
               <span class="s1">np.diff(exog)[</span><span class="s4">10</span><span class="s1">:])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">11</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">11</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_sarimax_time_varying_exog_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-varying SARIMAX model,</span>
    <span class="s3"># with nonzero shocks</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">state_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">x = np.r_[initial_state</span><span class="s2">, </span><span class="s1">state_shocks[:-</span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s1">desired = lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x) + exog[</span><span class="s4">10</span><span class="s1">:] + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_sarimax_simple_differencing_time_varying_exog_shocks(</span>
        <span class="s1">reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-varying SARIMAX model</span>
    <span class="s3"># Note that `exog` here has basically the same effect as measurement shocks</span>
    <span class="s1">endog = np.cumsum(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">))</span>
    <span class="s1">exog = np.cumsum(np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">11</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">state_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">11</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Compute the desired simulated values directly</span>
    <span class="s1">x = np.r_[initial_state</span><span class="s2">, </span><span class="s1">state_shocks[:-</span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s1">desired = (lfilter([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x) + np.diff(exog)[</span><span class="s4">10</span><span class="s1">:] +</span>
               <span class="s1">measurement_shocks)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">11</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_unobserved_components_end_time_invariant_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-invariant</span>
    <span class="s3"># UnobservedComponents model</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">mod = structural.UnobservedComponents(endog</span><span class="s2">, </span><span class="s5">'llevel'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># The mean of the simulated local level values is just the last value</span>
    <span class="s1">desired = initial_state[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations))</span>


<span class="s2">def </span><span class="s1">test_unobserved_components_end_time_invariant_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-invariant</span>
    <span class="s3"># UnobservedComponents model, with nonzero shocks</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">mod = structural.UnobservedComponents(endog</span><span class="s2">, </span><span class="s5">'llevel'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">state_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = (initial_state + np.cumsum(np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">state_shocks[:-</span><span class="s4">1</span><span class="s1">]]) +</span>
               <span class="s1">measurement_shocks)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_unobserved_components_end_time_varying_exog_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-varying</span>
    <span class="s3"># UnobservedComponents model with exog</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = structural.UnobservedComponents(endog</span><span class="s2">, </span><span class="s5">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># The mean of the simulated local level values is just the last value</span>
    <span class="s1">desired = initial_state[</span><span class="s4">0</span><span class="s1">] + exog[</span><span class="s4">10</span><span class="s1">:]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_unobserved_components_end_time_varying_exog_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-varying</span>
    <span class="s3"># UnobservedComponents model with exog</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = structural.UnobservedComponents(endog</span><span class="s2">, </span><span class="s5">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">state_shocks = np.random.normal(size=nsimulations)</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = (initial_state + np.cumsum(np.r_[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">state_shocks[:-</span><span class="s4">1</span><span class="s1">]]) +</span>
               <span class="s1">measurement_shocks + exog[</span><span class="s4">10</span><span class="s1">:])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_varmax_end_time_invariant_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-invariant VARMAX model</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = (initial_state[:</span><span class="s2">, None</span><span class="s1">] * </span><span class="s4">2 </span><span class="s1">** np.arange(</span><span class="s4">10</span><span class="s1">)).T</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations))</span>


<span class="s2">def </span><span class="s1">test_varmax_end_time_invariant_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-invariant VARMAX model,</span>
    <span class="s3"># with nonzero shocks</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">].sum() + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_varmax_end_time_varying_trend_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-varying VARMAX model</span>
    <span class="s3"># with a trend</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'ct'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>

    <span class="s3"># Need to set the final predicted state given the new trend</span>
    <span class="s2">with </span><span class="s1">res._set_final_predicted_state(exog=</span><span class="s2">None, </span><span class="s1">out_of_sample=</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s1">initial_state = res.predicted_state[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">].copy()</span>

    <span class="s3"># Simulation</span>
    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s1">tmp_trend = </span><span class="s4">1 </span><span class="s1">+ np.arange(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">].sum() + tmp_trend[i] + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations))</span>


<span class="s2">def </span><span class="s1">test_varmax_end_time_varying_trend_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-varying VARMAX model</span>
    <span class="s3"># with a trend</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'ct'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>

    <span class="s3"># Need to set the final predicted state given the new trend</span>
    <span class="s2">with </span><span class="s1">res._set_final_predicted_state(exog=</span><span class="s2">None, </span><span class="s1">out_of_sample=</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s1">initial_state = res.predicted_state[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">].copy()</span>

    <span class="s3"># Simulation</span>
    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s1">tmp_trend = </span><span class="s4">1 </span><span class="s1">+ np.arange(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">].sum() + tmp_trend[i] + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_varmax_end_time_varying_exog_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-varying VARMAX model</span>
    <span class="s3"># with exog</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>

    <span class="s3"># Need to set the final predicted state given the new exog</span>
    <span class="s1">tmp_exog = mod._validate_out_of_sample_exog(exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">out_of_sample=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">res._set_final_predicted_state(exog=tmp_exog</span><span class="s2">, </span><span class="s1">out_of_sample=</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s1">initial_state = res.predicted_state[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">].copy()</span>

    <span class="s3"># Simulation</span>
    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">].sum() + exog[</span><span class="s4">10 </span><span class="s1">+ i] + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_varmax_end_time_varying_exog_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-varying VARMAX model</span>
    <span class="s3"># with exog</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">23</span><span class="s1">).reshape(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = varmax.VARMAX(endog[:</span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">mod2 = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">11</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>

    <span class="s3"># Need to set the final predicted state given the new exog</span>
    <span class="s1">tmp_exog = mod._validate_out_of_sample_exog(exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">out_of_sample=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">res._set_final_predicted_state(exog=tmp_exog</span><span class="s2">, </span><span class="s1">out_of_sample=</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s1">initial_state = res.predicted_state[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">].copy()</span>

    <span class="s3"># Simulation</span>
    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>
    <span class="s1">actual2 = res2.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">11</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=-</span><span class="s4">1</span><span class="s2">,</span>
                            <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                            <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                            <span class="s1">initial_state=res2.predicted_state[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">])</span>

    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">].sum() + exog[</span><span class="s4">10 </span><span class="s1">+ i] + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_allclose(actual2</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_dynamic_factor_end_time_invariant_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-invariant dynamic factor</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3"># Simulation</span>
    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Construct the simulation directly</span>
    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">] + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations))</span>


<span class="s2">def </span><span class="s1">test_dynamic_factor_end_time_invariant_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-invariant dynamic factor</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mod = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3"># Simulation</span>
    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Construct the simulation directly</span>
    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">] + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_dynamic_factor_end_time_varying_exog_noshocks():</span>
    <span class="s3"># Test simulating values from the end of a time-varying dynamic factor</span>
    <span class="s3"># model with exogenous inputs</span>
    <span class="s3"># In this test, we suppress randomness by setting the shocks to zeros</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">).reshape(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">1</span><span class="s2">,</span>
                                       <span class="s1">exog=exog[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3"># Simulation</span>
    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Construct the simulation directly</span>
    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">] + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks + exog[</span><span class="s4">10</span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternatively, since we've shut down the shocks, we can compare against</span>
    <span class="s3"># the forecast values</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">res.forecast(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_dynamic_factor_end_time_varying_exog_shocks(reset_randomstate):</span>
    <span class="s3"># Test simulating values from the end of a time-varying dynamic factor</span>
    <span class="s3"># model with exogenous inputs</span>
    <span class="s1">endog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">23</span><span class="s1">).reshape(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)**</span><span class="s4">2</span>
    <span class="s1">mod = dynamic_factor.DynamicFactor(</span>
        <span class="s1">endog[:</span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">10</span><span class="s1">])</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res = mod.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">mod2 = dynamic_factor.DynamicFactor(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s4">11</span><span class="s1">])</span>
    <span class="s1">mod2.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res2 = mod2.filter([</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">nsimulations = </span><span class="s4">10</span>
    <span class="s1">measurement_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">state_shocks = np.random.normal(size=(nsimulations</span><span class="s2">, </span><span class="s1">mod.k_states))</span>
    <span class="s1">initial_state = res.predicted_state[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3"># Simulations</span>
    <span class="s1">actual = res.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
                          <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                          <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                          <span class="s1">initial_state=initial_state)</span>
    <span class="s1">actual2 = res2.simulate(nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">11</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=-</span><span class="s4">1</span><span class="s2">,</span>
                            <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
                            <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
                            <span class="s1">initial_state=initial_state)</span>

    <span class="s3"># Construct the simulation directly</span>
    <span class="s1">desired = np.zeros((nsimulations</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">desired[</span><span class="s4">0</span><span class="s1">] = initial_state</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nsimulations):</span>
        <span class="s1">desired[i] = desired[i - </span><span class="s4">1</span><span class="s1">] + state_shocks[i - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">desired = desired + measurement_shocks + exog[</span><span class="s4">10</span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_allclose(actual2</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Test using the model versus the results class</span>
    <span class="s1">mod_actual = mod.simulate(</span>
        <span class="s1">res.params</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s4">10</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s5">'end'</span><span class="s2">,</span>
        <span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
        <span class="s1">state_shocks=state_shocks</span><span class="s2">,</span>
        <span class="s1">initial_state=initial_state)</span>

    <span class="s1">assert_allclose(mod_actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_pandas_univariate_rangeindex():</span>
    <span class="s3"># Simulate will also have RangeIndex</span>
    <span class="s1">endog = pd.Series(np.zeros(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s3"># Default simulate anchors to the start of the sample</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">desired = pd.Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternative anchor changes the index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">ix = pd.RangeIndex(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">desired = pd.Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>


<span class="s2">def </span><span class="s1">test_pandas_univariate_rangeindex_repetitions():</span>
    <span class="s3"># Simulate will also have RangeIndex</span>
    <span class="s1">endog = pd.Series(np.zeros(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s3"># Default simulate anchors to the start of the sample</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repetitions=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">columns = pd.MultiIndex.from_product([[</span><span class="s5">'y'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">columns=columns)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.columns.equals(desired.columns))</span>

    <span class="s3"># Alternative anchor changes the index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repetitions=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">ix = pd.RangeIndex(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">columns = pd.MultiIndex.from_product([[</span><span class="s5">'y'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix</span><span class="s2">, </span><span class="s1">columns=columns)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>
    <span class="s1">assert_(actual.columns.equals(desired.columns))</span>


<span class="s2">def </span><span class="s1">test_pandas_univariate_dateindex():</span>
    <span class="s3"># Simulation will maintain have date index</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.Series(np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s3"># Default simulate anchors to the start of the sample</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000-01'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">desired = pd.Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>

    <span class="s3"># Alternative anchor changes the index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000-03'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">desired = pd.Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_pandas_univariate_dateindex_repetitions():</span>
    <span class="s3"># Simulation will maintain have date index</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.Series(np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s3"># Default simulate anchors to the start of the sample</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repetitions=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000-01'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">columns = pd.MultiIndex.from_product([[</span><span class="s5">'y'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix</span><span class="s2">, </span><span class="s1">columns=columns)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.columns.equals(desired.columns))</span>

    <span class="s3"># Alternative anchor changes the index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repetitions=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000-03'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">columns = pd.MultiIndex.from_product([[</span><span class="s5">'y'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix</span><span class="s2">, </span><span class="s1">columns=columns)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>
    <span class="s1">assert_(actual.columns.equals(desired.columns))</span>


<span class="s2">def </span><span class="s1">test_pandas_multivariate_rangeindex():</span>
    <span class="s3"># Simulate will also have RangeIndex</span>
    <span class="s1">endog = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s3"># Default simulate anchors to the start of the sample</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternative anchor changes the index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">ix = pd.RangeIndex(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>


<span class="s2">def </span><span class="s1">test_pandas_multivariate_rangeindex_repetitions():</span>
    <span class="s3"># Simulate will also have RangeIndex</span>
    <span class="s1">endog = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s5">'y1'</span><span class="s2">, </span><span class="s5">'y2'</span><span class="s1">])</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s3"># Default simulate anchors to the start of the sample</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repetitions=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">columns = pd.MultiIndex.from_product([[</span><span class="s5">'y1'</span><span class="s2">, </span><span class="s5">'y2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">columns=columns)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.columns.equals(desired.columns))</span>

    <span class="s3"># Alternative anchor changes the index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repetitions=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">ix = pd.RangeIndex(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">columns = pd.MultiIndex.from_product([[</span><span class="s5">'y1'</span><span class="s2">, </span><span class="s5">'y2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix</span><span class="s2">, </span><span class="s1">columns=columns)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>
    <span class="s1">assert_(actual.columns.equals(desired.columns))</span>


<span class="s2">def </span><span class="s1">test_pandas_multivariate_dateindex():</span>
    <span class="s3"># Simulate will also have RangeIndex</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s3"># Default simulate anchors to the start of the sample</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s3"># Alternative anchor changes the index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000-03'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>


<span class="s2">def </span><span class="s1">test_pandas_multivariate_dateindex_repetitions():</span>
    <span class="s3"># Simulate will also have RangeIndex</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s5">'y1'</span><span class="s2">, </span><span class="s5">'y2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s5">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s3"># Default simulate anchors to the start of the sample</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repetitions=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">columns = pd.MultiIndex.from_product([[</span><span class="s5">'y1'</span><span class="s2">, </span><span class="s5">'y2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">columns=columns</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.columns.equals(desired.columns))</span>

    <span class="s3"># Alternative anchor changes the index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repetitions=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000-03'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">columns = pd.MultiIndex.from_product([[</span><span class="s5">'y1'</span><span class="s2">, </span><span class="s5">'y2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">desired = pd.DataFrame(np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=ix</span><span class="s2">, </span><span class="s1">columns=columns)</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>
    <span class="s1">assert_(actual.columns.equals(desired.columns))</span>


<span class="s2">def </span><span class="s1">test_pandas_anchor():</span>
    <span class="s3"># Test that anchor with dates works</span>
    <span class="s1">ix = pd.date_range(start=</span><span class="s5">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.Series(np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.filter([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>

    <span class="s1">desired = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s3"># Anchor to date</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=ix[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>

    <span class="s3"># Anchor to negative index</span>
    <span class="s1">actual = res.simulate(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">anchor=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">state_shocks=np.zeros(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">initial_state=np.zeros(</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_(actual.index.equals(desired.index))</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_time_varying(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">mod.simulate([]</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_time_varying_obs_cov(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">mod[</span><span class="s5">'obs_cov'</span><span class="s1">] = np.zeros((mod.k_endog</span><span class="s2">, </span><span class="s1">mod.k_endog</span><span class="s2">, </span><span class="s1">mod.nobs))</span>
    <span class="s1">mod[</span><span class="s5">'obs_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s4">9</span><span class="s1">] = np.eye(mod.k_endog)</span>
    <span class="s1">mod[</span><span class="s5">'state_intercept'</span><span class="s2">, </span><span class="s1">:] = </span><span class="s4">0</span>
    <span class="s1">mod[</span><span class="s5">'state_cov'</span><span class="s1">] = mod[</span><span class="s5">'state_cov'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] * </span><span class="s4">0</span>
    <span class="s1">mod[</span><span class="s5">'selection'</span><span class="s1">] = mod[</span><span class="s5">'selection'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">assert_equal(mod[</span><span class="s5">'state_cov'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(mod.ssm.k_posdef</span><span class="s2">, </span><span class="s1">mod.ssm.k_posdef))</span>
    <span class="s1">assert_equal(mod[</span><span class="s5">'selection'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(mod.k_states</span><span class="s2">, </span><span class="s1">mod.ssm.k_posdef))</span>

    <span class="s1">sim = mod.simulate([]</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">initial_state=np.zeros(mod.k_states))</span>
    <span class="s1">assert_allclose(sim[:</span><span class="s4">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mod[</span><span class="s5">'obs_intercept'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s4">9</span><span class="s1">].T)</span>


<span class="s2">def </span><span class="s1">test_time_varying_state_cov(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">mod[</span><span class="s5">'obs_cov'</span><span class="s1">] = mod[</span><span class="s5">'obs_cov'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] * </span><span class="s4">0</span>
    <span class="s1">mod[</span><span class="s5">'selection'</span><span class="s1">] = mod[</span><span class="s5">'selection'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">mod[</span><span class="s5">'state_intercept'</span><span class="s2">, </span><span class="s1">:] = </span><span class="s4">0</span>
    <span class="s1">mod[</span><span class="s5">'state_cov'</span><span class="s1">] = np.zeros((mod.ssm.k_posdef</span><span class="s2">, </span><span class="s1">mod.ssm.k_posdef</span><span class="s2">, </span><span class="s1">mod.nobs))</span>
    <span class="s1">mod[</span><span class="s5">'state_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">] = np.eye(mod.ssm.k_posdef)</span>
    <span class="s1">assert_equal(mod[</span><span class="s5">'obs_cov'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(mod.k_endog</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">assert_equal(mod[</span><span class="s5">'selection'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(mod.k_states</span><span class="s2">, </span><span class="s1">mod.ssm.k_posdef))</span>
    <span class="s1">sim = mod.simulate([]</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(sim</span><span class="s2">, </span><span class="s1">mod[</span><span class="s5">'obs_intercept'</span><span class="s1">].T)</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_time_varying_selection(reset_randomstate):</span>
    <span class="s1">mod = TVSS(np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">mod[</span><span class="s5">'obs_cov'</span><span class="s1">] = mod[</span><span class="s5">'obs_cov'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">mod[</span><span class="s5">'state_cov'</span><span class="s1">] = mod[</span><span class="s5">'state_cov'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">assert_equal(mod[</span><span class="s5">'obs_cov'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(mod.k_endog</span><span class="s2">, </span><span class="s1">mod.k_endog))</span>
    <span class="s1">assert_equal(mod[</span><span class="s5">'state_cov'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(mod.ssm.k_posdef</span><span class="s2">, </span><span class="s1">mod.ssm.k_posdef))</span>
    <span class="s1">mod.simulate([]</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
</pre>
</body>
</html>