<html>
<head>
<title>axisgrid.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
axisgrid.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">product</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">signature</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">dedent</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>

<span class="s0">from </span><span class="s1">._base </span><span class="s0">import </span><span class="s1">VectorPlotter</span><span class="s0">, </span><span class="s1">variable_type</span><span class="s0">, </span><span class="s1">categorical_order</span>
<span class="s0">from </span><span class="s1">._core.data </span><span class="s0">import </span><span class="s1">handle_data_source</span>
<span class="s0">from </span><span class="s1">._compat </span><span class="s0">import </span><span class="s1">share_axis</span><span class="s0">, </span><span class="s1">get_legend_handles</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">utils</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">adjust_legend_subtitles</span><span class="s0">,</span>
    <span class="s1">set_hls_values</span><span class="s0">,</span>
    <span class="s1">_check_argument</span><span class="s0">,</span>
    <span class="s1">_draw_figure</span><span class="s0">,</span>
    <span class="s1">_disable_autolayout</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">.palettes </span><span class="s0">import </span><span class="s1">color_palette</span><span class="s0">, </span><span class="s1">blend_palette</span>
<span class="s0">from </span><span class="s1">._docstrings </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DocstringComponents</span><span class="s0">,</span>
    <span class="s1">_core_docs</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">__all__ = [</span><span class="s2">&quot;FacetGrid&quot;</span><span class="s0">, </span><span class="s2">&quot;PairGrid&quot;</span><span class="s0">, </span><span class="s2">&quot;JointGrid&quot;</span><span class="s0">, </span><span class="s2">&quot;pairplot&quot;</span><span class="s0">, </span><span class="s2">&quot;jointplot&quot;</span><span class="s1">]</span>


<span class="s1">_param_docs = DocstringComponents.from_nested_components(</span>
    <span class="s1">core=_core_docs[</span><span class="s2">&quot;params&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">class </span><span class="s1">_BaseGrid:</span>
    <span class="s3">&quot;&quot;&quot;Base class for grids of subplots.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Set attributes on each subplot Axes.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self.axes.flat:</span>
            <span class="s0">if </span><span class="s1">ax </span><span class="s0">is not None</span><span class="s1">:  </span><span class="s4"># Handle removed axes</span>
                <span class="s1">ax.set(**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">fig(self):</span>
        <span class="s3">&quot;&quot;&quot;DEPRECATED: prefer the `figure` property.&quot;&quot;&quot;</span>
        <span class="s4"># Grid.figure is preferred because it matches the Axes attribute name.</span>
        <span class="s4"># But as the maintanace burden on having this property is minimal,</span>
        <span class="s4"># let's be slow about formally deprecating it. For now just note its deprecation</span>
        <span class="s4"># in the docstring; add a warning in version 0.13, and eventually remove it.</span>
        <span class="s0">return </span><span class="s1">self._figure</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">figure(self):</span>
        <span class="s3">&quot;&quot;&quot;Access the :class:`matplotlib.figure.Figure` object underlying the grid.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._figure</span>

    <span class="s0">def </span><span class="s1">apply(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Pass the grid to a user-supplied function and return self. 
 
        The `func` must accept an object of this type for its first 
        positional argument. Additional arguments are passed through. 
        The return value of `func` is ignored; this method returns self. 
        See the `pipe` method if you want the return value. 
 
        Added in v0.12.0. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">pipe(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Pass the grid to a user-supplied function and return its value. 
 
        The `func` must accept an object of this type for its first 
        positional argument. Additional arguments are passed through. 
        The return value of `func` becomes the return value of this method. 
        See the `apply` method if you want to return self instead. 
 
        Added in v0.12.0. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">func(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">savefig(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Save an image of the plot. 
 
        This wraps :meth:`matplotlib.figure.Figure.savefig`, using bbox_inches=&quot;tight&quot; 
        by default. Parameters are passed through to the matplotlib function. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs = kwargs.copy()</span>
        <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;bbox_inches&quot;</span><span class="s0">, </span><span class="s2">&quot;tight&quot;</span><span class="s1">)</span>
        <span class="s1">self.figure.savefig(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">class </span><span class="s1">Grid(_BaseGrid):</span>
    <span class="s3">&quot;&quot;&quot;A grid that can have multiple subplots and an external legend.&quot;&quot;&quot;</span>
    <span class="s1">_margin_titles = </span><span class="s0">False</span>
    <span class="s1">_legend_out = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>

        <span class="s1">self._tight_layout_rect = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">self._tight_layout_pad = </span><span class="s0">None</span>

        <span class="s4"># This attribute is set externally and is a hack to handle newer functions that</span>
        <span class="s4"># don't add proxy artists onto the Axes. We need an overall cleaner approach.</span>
        <span class="s1">self._extract_legend_handles = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">tight_layout(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Call fig.tight_layout within rect that exclude the legend.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = kwargs.copy()</span>
        <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;rect&quot;</span><span class="s0">, </span><span class="s1">self._tight_layout_rect)</span>
        <span class="s0">if </span><span class="s1">self._tight_layout_pad </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s1">self._tight_layout_pad)</span>
        <span class="s1">self._figure.tight_layout(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">add_legend(self</span><span class="s0">, </span><span class="s1">legend_data=</span><span class="s0">None, </span><span class="s1">title=</span><span class="s0">None, </span><span class="s1">label_order=</span><span class="s0">None,</span>
                   <span class="s1">adjust_subtitles=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Draw a legend, maybe placing it outside axes and resizing the figure. 
 
        Parameters 
        ---------- 
        legend_data : dict 
            Dictionary mapping label names (or two-element tuples where the 
            second element is a label name) to matplotlib artist handles. The 
            default reads from ``self._legend_data``. 
        title : string 
            Title for the legend. The default reads from ``self._hue_var``. 
        label_order : list of labels 
            The order that the legend entries should appear in. The default 
            reads from ``self.hue_names``. 
        adjust_subtitles : bool 
            If True, modify entries with invisible artists to left-align 
            the labels and set the font size to that of a title. 
        kwargs : key, value pairings 
            Other keyword arguments are passed to the underlying legend methods 
            on the Figure or Axes object. 
 
        Returns 
        ------- 
        self : Grid instance 
            Returns self for easy chaining. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># Find the data for the legend</span>
        <span class="s0">if </span><span class="s1">legend_data </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">legend_data = self._legend_data</span>
        <span class="s0">if </span><span class="s1">label_order </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.hue_names </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">label_order = list(legend_data.keys())</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">label_order = list(map(utils.to_utf8</span><span class="s0">, </span><span class="s1">self.hue_names))</span>

        <span class="s1">blank_handle = mpl.patches.Patch(alpha=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">linewidth=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">handles = [legend_data.get(lab</span><span class="s0">, </span><span class="s1">blank_handle) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">label_order]</span>
        <span class="s1">title = self._hue_var </span><span class="s0">if </span><span class="s1">title </span><span class="s0">is None else </span><span class="s1">title</span>
        <span class="s1">title_size = mpl.rcParams[</span><span class="s2">&quot;legend.title_fontsize&quot;</span><span class="s1">]</span>

        <span class="s4"># Unpack nested labels from a hierarchical legend</span>
        <span class="s1">labels = []</span>
        <span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">label_order:</span>
            <span class="s0">if </span><span class="s1">isinstance(entry</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">_</span><span class="s0">, </span><span class="s1">label = entry</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">label = entry</span>
            <span class="s1">labels.append(label)</span>

        <span class="s4"># Set default legend kwargs</span>
        <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;scatterpoints&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self._legend_out:</span>

            <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;frameon&quot;</span><span class="s0">, False</span><span class="s1">)</span>
            <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;loc&quot;</span><span class="s0">, </span><span class="s2">&quot;center right&quot;</span><span class="s1">)</span>

            <span class="s4"># Draw a full-figure legend outside the grid</span>
            <span class="s1">figlegend = self._figure.legend(handles</span><span class="s0">, </span><span class="s1">labels</span><span class="s0">, </span><span class="s1">**kwargs)</span>

            <span class="s1">self._legend = figlegend</span>
            <span class="s1">figlegend.set_title(title</span><span class="s0">, </span><span class="s1">prop={</span><span class="s2">&quot;size&quot;</span><span class="s1">: title_size})</span>

            <span class="s0">if </span><span class="s1">adjust_subtitles:</span>
                <span class="s1">adjust_legend_subtitles(figlegend)</span>

            <span class="s4"># Draw the plot to set the bounding boxes correctly</span>
            <span class="s1">_draw_figure(self._figure)</span>

            <span class="s4"># Calculate and set the new width of the figure so the legend fits</span>
            <span class="s1">legend_width = figlegend.get_window_extent().width / self._figure.dpi</span>
            <span class="s1">fig_width</span><span class="s0">, </span><span class="s1">fig_height = self._figure.get_size_inches()</span>
            <span class="s1">self._figure.set_size_inches(fig_width + legend_width</span><span class="s0">, </span><span class="s1">fig_height)</span>

            <span class="s4"># Draw the plot again to get the new transformations</span>
            <span class="s1">_draw_figure(self._figure)</span>

            <span class="s4"># Now calculate how much space we need on the right side</span>
            <span class="s1">legend_width = figlegend.get_window_extent().width / self._figure.dpi</span>
            <span class="s1">space_needed = legend_width / (fig_width + legend_width)</span>
            <span class="s1">margin = </span><span class="s5">.04 </span><span class="s0">if </span><span class="s1">self._margin_titles </span><span class="s0">else </span><span class="s5">.01</span>
            <span class="s1">self._space_needed = margin + space_needed</span>
            <span class="s1">right = </span><span class="s5">1 </span><span class="s1">- self._space_needed</span>

            <span class="s4"># Place the subplot axes to give space for the legend</span>
            <span class="s1">self._figure.subplots_adjust(right=right)</span>
            <span class="s1">self._tight_layout_rect[</span><span class="s5">2</span><span class="s1">] = right</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># Draw a legend in the first axis</span>
            <span class="s1">ax = self.axes.flat[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;loc&quot;</span><span class="s0">, </span><span class="s2">&quot;best&quot;</span><span class="s1">)</span>

            <span class="s1">leg = ax.legend(handles</span><span class="s0">, </span><span class="s1">labels</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s1">leg.set_title(title</span><span class="s0">, </span><span class="s1">prop={</span><span class="s2">&quot;size&quot;</span><span class="s1">: title_size})</span>
            <span class="s1">self._legend = leg</span>

            <span class="s0">if </span><span class="s1">adjust_subtitles:</span>
                <span class="s1">adjust_legend_subtitles(leg)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_update_legend_data(self</span><span class="s0">, </span><span class="s1">ax):</span>
        <span class="s3">&quot;&quot;&quot;Extract the legend data from an axes object and save it.&quot;&quot;&quot;</span>
        <span class="s1">data = {}</span>

        <span class="s4"># Get data directly from the legend, which is necessary</span>
        <span class="s4"># for newer functions that don't add labeled proxy artists</span>
        <span class="s0">if </span><span class="s1">ax.legend_ </span><span class="s0">is not None and </span><span class="s1">self._extract_legend_handles:</span>
            <span class="s1">handles = get_legend_handles(ax.legend_)</span>
            <span class="s1">labels = [t.get_text() </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">ax.legend_.texts]</span>
            <span class="s1">data.update({label: handle </span><span class="s0">for </span><span class="s1">handle</span><span class="s0">, </span><span class="s1">label </span><span class="s0">in </span><span class="s1">zip(handles</span><span class="s0">, </span><span class="s1">labels)})</span>

        <span class="s1">handles</span><span class="s0">, </span><span class="s1">labels = ax.get_legend_handles_labels()</span>
        <span class="s1">data.update({label: handle </span><span class="s0">for </span><span class="s1">handle</span><span class="s0">, </span><span class="s1">label </span><span class="s0">in </span><span class="s1">zip(handles</span><span class="s0">, </span><span class="s1">labels)})</span>

        <span class="s1">self._legend_data.update(data)</span>

        <span class="s4"># Now clear the legend</span>
        <span class="s1">ax.legend_ = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_get_palette(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">hue_order</span><span class="s0">, </span><span class="s1">palette):</span>
        <span class="s3">&quot;&quot;&quot;Get a list of colors for the hue variable.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hue </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">palette = color_palette(n_colors=</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hue_names = categorical_order(data[hue]</span><span class="s0">, </span><span class="s1">hue_order)</span>
            <span class="s1">n_colors = len(hue_names)</span>

            <span class="s4"># By default use either the current color palette or HUSL</span>
            <span class="s0">if </span><span class="s1">palette </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">current_palette = utils.get_color_cycle()</span>
                <span class="s0">if </span><span class="s1">n_colors &gt; len(current_palette):</span>
                    <span class="s1">colors = color_palette(</span><span class="s2">&quot;husl&quot;</span><span class="s0">, </span><span class="s1">n_colors)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">colors = color_palette(n_colors=n_colors)</span>

            <span class="s4"># Allow for palette to map from hue variable names</span>
            <span class="s0">elif </span><span class="s1">isinstance(palette</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s1">color_names = [palette[h] </span><span class="s0">for </span><span class="s1">h </span><span class="s0">in </span><span class="s1">hue_names]</span>
                <span class="s1">colors = color_palette(color_names</span><span class="s0">, </span><span class="s1">n_colors)</span>

            <span class="s4"># Otherwise act as if we just got a list of colors</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">colors = color_palette(palette</span><span class="s0">, </span><span class="s1">n_colors)</span>

            <span class="s1">palette = color_palette(colors</span><span class="s0">, </span><span class="s1">n_colors)</span>

        <span class="s0">return </span><span class="s1">palette</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">legend(self):</span>
        <span class="s3">&quot;&quot;&quot;The :class:`matplotlib.legend.Legend` object, if present.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._legend</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">tick_params(self</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">'both'</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Modify the ticks, tick labels, and gridlines. 
 
        Parameters 
        ---------- 
        axis : {'x', 'y', 'both'} 
            The axis on which to apply the formatting. 
        kwargs : keyword arguments 
            Additional keyword arguments to pass to 
            :meth:`matplotlib.axes.Axes.tick_params`. 
 
        Returns 
        ------- 
        self : Grid instance 
            Returns self for easy chaining. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self.figure.axes:</span>
            <span class="s1">ax.tick_params(axis=axis</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s1">_facet_docs = dict(</span>

    <span class="s1">data=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">data : DataFrame 
        Tidy (&quot;long-form&quot;) dataframe where each column is a variable and each 
        row is an observation.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">rowcol=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">row, col : vectors or keys in ``data`` 
        Variables that define subsets to plot on different facets.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">rowcol_order=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">{row,col}_order : vector of strings 
        Specify the order in which levels of the ``row`` and/or ``col`` variables 
        appear in the grid of subplots.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">col_wrap=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">col_wrap : int 
        &quot;Wrap&quot; the column variable at this width, so that the column facets 
        span multiple rows. Incompatible with a ``row`` facet.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">share_xy=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">share{x,y} : bool, 'col', or 'row' optional 
        If true, the facets will share y axes across columns and/or x axes 
        across rows.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">height=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">height : scalar 
        Height (in inches) of each facet. See also: ``aspect``.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">aspect=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">aspect : scalar 
        Aspect ratio of each facet, so that ``aspect * height`` gives the width 
        of each facet in inches.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">palette=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">palette : palette name, list, or dict 
        Colors to use for the different levels of the ``hue`` variable. Should 
        be something that can be interpreted by :func:`color_palette`, or a 
        dictionary mapping hue levels to matplotlib colors.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">legend_out=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">legend_out : bool 
        If ``True``, the figure size will be extended, and the legend will be 
        drawn outside the plot on the center right.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">margin_titles=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">margin_titles : bool 
        If ``True``, the titles for the row variable are drawn to the right of 
        the last column. This option is experimental and may not work in all 
        cases.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">facet_kws=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">facet_kws : dict 
        Additional parameters passed to :class:`FacetGrid`. 
    &quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">class </span><span class="s1">FacetGrid(Grid):</span>
    <span class="s3">&quot;&quot;&quot;Multi-plot grid for plotting conditional relationships.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">*</span><span class="s0">,</span>
        <span class="s1">row=</span><span class="s0">None, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">col_wrap=</span><span class="s0">None,</span>
        <span class="s1">sharex=</span><span class="s0">True, </span><span class="s1">sharey=</span><span class="s0">True, </span><span class="s1">height=</span><span class="s5">3</span><span class="s0">, </span><span class="s1">aspect=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">palette=</span><span class="s0">None,</span>
        <span class="s1">row_order=</span><span class="s0">None, </span><span class="s1">col_order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">hue_kws=</span><span class="s0">None,</span>
        <span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">legend_out=</span><span class="s0">True, </span><span class="s1">despine=</span><span class="s0">True,</span>
        <span class="s1">margin_titles=</span><span class="s0">False, </span><span class="s1">xlim=</span><span class="s0">None, </span><span class="s1">ylim=</span><span class="s0">None, </span><span class="s1">subplot_kws=</span><span class="s0">None,</span>
        <span class="s1">gridspec_kws=</span><span class="s0">None,</span>
    <span class="s1">):</span>

        <span class="s1">super().__init__()</span>
        <span class="s1">data = handle_data_source(data)</span>

        <span class="s4"># Determine the hue facet layer information</span>
        <span class="s1">hue_var = hue</span>
        <span class="s0">if </span><span class="s1">hue </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">hue_names = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hue_names = categorical_order(data[hue]</span><span class="s0">, </span><span class="s1">hue_order)</span>

        <span class="s1">colors = self._get_palette(data</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">hue_order</span><span class="s0">, </span><span class="s1">palette)</span>

        <span class="s4"># Set up the lists of names for the row and column facet variables</span>
        <span class="s0">if </span><span class="s1">row </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">row_names = []</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">row_names = categorical_order(data[row]</span><span class="s0">, </span><span class="s1">row_order)</span>

        <span class="s0">if </span><span class="s1">col </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">col_names = []</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">col_names = categorical_order(data[col]</span><span class="s0">, </span><span class="s1">col_order)</span>

        <span class="s4"># Additional dict of kwarg -&gt; list of values for mapping the hue var</span>
        <span class="s1">hue_kws = hue_kws </span><span class="s0">if </span><span class="s1">hue_kws </span><span class="s0">is not None else </span><span class="s1">{}</span>

        <span class="s4"># Make a boolean mask that is True anywhere there is an NA</span>
        <span class="s4"># value in one of the faceting variables, but only if dropna is True</span>
        <span class="s1">none_na = np.zeros(len(data)</span><span class="s0">, </span><span class="s1">bool)</span>
        <span class="s0">if </span><span class="s1">dropna:</span>
            <span class="s1">row_na = none_na </span><span class="s0">if </span><span class="s1">row </span><span class="s0">is None else </span><span class="s1">data[row].isnull()</span>
            <span class="s1">col_na = none_na </span><span class="s0">if </span><span class="s1">col </span><span class="s0">is None else </span><span class="s1">data[col].isnull()</span>
            <span class="s1">hue_na = none_na </span><span class="s0">if </span><span class="s1">hue </span><span class="s0">is None else </span><span class="s1">data[hue].isnull()</span>
            <span class="s1">not_na = ~(row_na | col_na | hue_na)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">not_na = ~none_na</span>

        <span class="s4"># Compute the grid shape</span>
        <span class="s1">ncol = </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">col </span><span class="s0">is None else </span><span class="s1">len(col_names)</span>
        <span class="s1">nrow = </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">row </span><span class="s0">is None else </span><span class="s1">len(row_names)</span>
        <span class="s1">self._n_facets = ncol * nrow</span>

        <span class="s1">self._col_wrap = col_wrap</span>
        <span class="s0">if </span><span class="s1">col_wrap </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">row </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">err = </span><span class="s2">&quot;Cannot use `row` and `col_wrap` together.&quot;</span>
                <span class="s0">raise </span><span class="s1">ValueError(err)</span>
            <span class="s1">ncol = col_wrap</span>
            <span class="s1">nrow = int(np.ceil(len(col_names) / col_wrap))</span>
        <span class="s1">self._ncol = ncol</span>
        <span class="s1">self._nrow = nrow</span>

        <span class="s4"># Calculate the base figure size</span>
        <span class="s4"># This can get stretched later by a legend</span>
        <span class="s4"># TODO this doesn't account for axis labels</span>
        <span class="s1">figsize = (ncol * height * aspect</span><span class="s0">, </span><span class="s1">nrow * height)</span>

        <span class="s4"># Validate some inputs</span>
        <span class="s0">if </span><span class="s1">col_wrap </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">margin_titles = </span><span class="s0">False</span>

        <span class="s4"># Build the subplot keyword dictionary</span>
        <span class="s1">subplot_kws = {} </span><span class="s0">if </span><span class="s1">subplot_kws </span><span class="s0">is None else </span><span class="s1">subplot_kws.copy()</span>
        <span class="s1">gridspec_kws = {} </span><span class="s0">if </span><span class="s1">gridspec_kws </span><span class="s0">is None else </span><span class="s1">gridspec_kws.copy()</span>
        <span class="s0">if </span><span class="s1">xlim </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">subplot_kws[</span><span class="s2">&quot;xlim&quot;</span><span class="s1">] = xlim</span>
        <span class="s0">if </span><span class="s1">ylim </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">subplot_kws[</span><span class="s2">&quot;ylim&quot;</span><span class="s1">] = ylim</span>

        <span class="s4"># --- Initialize the subplot grid</span>

        <span class="s0">with </span><span class="s1">_disable_autolayout():</span>
            <span class="s1">fig = plt.figure(figsize=figsize)</span>

        <span class="s0">if </span><span class="s1">col_wrap </span><span class="s0">is None</span><span class="s1">:</span>

            <span class="s1">kwargs = dict(squeeze=</span><span class="s0">False,</span>
                          <span class="s1">sharex=sharex</span><span class="s0">, </span><span class="s1">sharey=sharey</span><span class="s0">,</span>
                          <span class="s1">subplot_kw=subplot_kws</span><span class="s0">,</span>
                          <span class="s1">gridspec_kw=gridspec_kws)</span>

            <span class="s1">axes = fig.subplots(nrow</span><span class="s0">, </span><span class="s1">ncol</span><span class="s0">, </span><span class="s1">**kwargs)</span>

            <span class="s0">if </span><span class="s1">col </span><span class="s0">is None and </span><span class="s1">row </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">axes_dict = {}</span>
            <span class="s0">elif </span><span class="s1">col </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">axes_dict = dict(zip(row_names</span><span class="s0">, </span><span class="s1">axes.flat))</span>
            <span class="s0">elif </span><span class="s1">row </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">axes_dict = dict(zip(col_names</span><span class="s0">, </span><span class="s1">axes.flat))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">facet_product = product(row_names</span><span class="s0">, </span><span class="s1">col_names)</span>
                <span class="s1">axes_dict = dict(zip(facet_product</span><span class="s0">, </span><span class="s1">axes.flat))</span>

        <span class="s0">else</span><span class="s1">:</span>

            <span class="s4"># If wrapping the col variable we need to make the grid ourselves</span>
            <span class="s0">if </span><span class="s1">gridspec_kws:</span>
                <span class="s1">warnings.warn(</span><span class="s2">&quot;`gridspec_kws` ignored when using `col_wrap`&quot;</span><span class="s1">)</span>

            <span class="s1">n_axes = len(col_names)</span>
            <span class="s1">axes = np.empty(n_axes</span><span class="s0">, </span><span class="s1">object)</span>
            <span class="s1">axes[</span><span class="s5">0</span><span class="s1">] = fig.add_subplot(nrow</span><span class="s0">, </span><span class="s1">ncol</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">**subplot_kws)</span>
            <span class="s0">if </span><span class="s1">sharex:</span>
                <span class="s1">subplot_kws[</span><span class="s2">&quot;sharex&quot;</span><span class="s1">] = axes[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">sharey:</span>
                <span class="s1">subplot_kws[</span><span class="s2">&quot;sharey&quot;</span><span class="s1">] = axes[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">n_axes):</span>
                <span class="s1">axes[i] = fig.add_subplot(nrow</span><span class="s0">, </span><span class="s1">ncol</span><span class="s0">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">**subplot_kws)</span>

            <span class="s1">axes_dict = dict(zip(col_names</span><span class="s0">, </span><span class="s1">axes))</span>

        <span class="s4"># --- Set up the class attributes</span>

        <span class="s4"># Attributes that are part of the public API but accessed through</span>
        <span class="s4"># a  property so that Sphinx adds them to the auto class doc</span>
        <span class="s1">self._figure = fig</span>
        <span class="s1">self._axes = axes</span>
        <span class="s1">self._axes_dict = axes_dict</span>
        <span class="s1">self._legend = </span><span class="s0">None</span>

        <span class="s4"># Public attributes that aren't explicitly documented</span>
        <span class="s4"># (It's not obvious that having them be public was a good idea)</span>
        <span class="s1">self.data = data</span>
        <span class="s1">self.row_names = row_names</span>
        <span class="s1">self.col_names = col_names</span>
        <span class="s1">self.hue_names = hue_names</span>
        <span class="s1">self.hue_kws = hue_kws</span>

        <span class="s4"># Next the private variables</span>
        <span class="s1">self._nrow = nrow</span>
        <span class="s1">self._row_var = row</span>
        <span class="s1">self._ncol = ncol</span>
        <span class="s1">self._col_var = col</span>

        <span class="s1">self._margin_titles = margin_titles</span>
        <span class="s1">self._margin_titles_texts = []</span>
        <span class="s1">self._col_wrap = col_wrap</span>
        <span class="s1">self._hue_var = hue_var</span>
        <span class="s1">self._colors = colors</span>
        <span class="s1">self._legend_out = legend_out</span>
        <span class="s1">self._legend_data = {}</span>
        <span class="s1">self._x_var = </span><span class="s0">None</span>
        <span class="s1">self._y_var = </span><span class="s0">None</span>
        <span class="s1">self._sharex = sharex</span>
        <span class="s1">self._sharey = sharey</span>
        <span class="s1">self._dropna = dropna</span>
        <span class="s1">self._not_na = not_na</span>

        <span class="s4"># --- Make the axes look good</span>

        <span class="s1">self.set_titles()</span>
        <span class="s1">self.tight_layout()</span>

        <span class="s0">if </span><span class="s1">despine:</span>
            <span class="s1">self.despine()</span>

        <span class="s0">if </span><span class="s1">sharex </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, </span><span class="s2">'col'</span><span class="s1">]:</span>
            <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._not_bottom_axes:</span>
                <span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">ax.get_xticklabels():</span>
                    <span class="s1">label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s1">ax.xaxis.offsetText.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s1">ax.xaxis.label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">sharey </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, </span><span class="s2">'row'</span><span class="s1">]:</span>
            <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._not_left_axes:</span>
                <span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">ax.get_yticklabels():</span>
                    <span class="s1">label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s1">ax.yaxis.offsetText.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s1">ax.yaxis.label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">__init__.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
        </span><span class="s2">Initialize the matplotlib figure and FacetGrid object. 
 
        This class maps a dataset onto multiple axes arrayed in a grid of rows 
        and columns that correspond to *levels* of variables in the dataset. 
        The plots it produces are often called &quot;lattice&quot;, &quot;trellis&quot;, or 
        &quot;small-multiple&quot; graphics. 
 
        It can also represent levels of a third variable with the ``hue`` 
        parameter, which plots different subsets of data in different colors. 
        This uses color to resolve elements on a third dimension, but only 
        draws subsets on top of each other and will not tailor the ``hue`` 
        parameter for the specific visualization the way that axes-level 
        functions that accept ``hue`` will. 
 
        The basic workflow is to initialize the :class:`FacetGrid` object with 
        the dataset and the variables that are used to structure the grid. Then 
        one or more plotting functions can be applied to each subset by calling 
        :meth:`FacetGrid.map` or :meth:`FacetGrid.map_dataframe`. Finally, the 
        plot can be tweaked with other methods to do things like change the 
        axis labels, use different ticks, or add a legend. See the detailed 
        code examples below for more information. 
 
        .. warning:: 
 
            When using seaborn functions that infer semantic mappings from a 
            dataset, care must be taken to synchronize those mappings across 
            facets (e.g., by defining the ``hue`` mapping with a palette dict or 
            setting the data type of the variables to ``category``). In most cases, 
            it will be better to use a figure-level function (e.g. :func:`relplot` 
            or :func:`catplot`) than to use :class:`FacetGrid` directly. 
 
        See the :ref:`tutorial &lt;grid_tutorial&gt;` for more information. 
 
        Parameters 
        ---------- 
        {data} 
        row, col, hue : strings 
            Variables that define subsets of the data, which will be drawn on 
            separate facets in the grid. See the ``{{var}}_order`` parameters to 
            control the order of levels of this variable. 
        {col_wrap} 
        {share_xy} 
        {height} 
        {aspect} 
        {palette} 
        {{row,col,hue}}_order : lists 
            Order for the levels of the faceting variables. By default, this 
            will be the order that the levels appear in ``data`` or, if the 
            variables are pandas categoricals, the category order. 
        hue_kws : dictionary of param -&gt; list of values mapping 
            Other keyword arguments to insert into the plotting call to let 
            other plot attributes vary across levels of the hue variable (e.g. 
            the markers in a scatterplot). 
        {legend_out} 
        despine : boolean 
            Remove the top and right spines from the plots. 
        {margin_titles} 
        {{x, y}}lim: tuples 
            Limits for each of the axes on each facet (only relevant when 
            share{{x, y}} is True). 
        subplot_kws : dict 
            Dictionary of keyword arguments passed to matplotlib subplot(s) 
            methods. 
        gridspec_kws : dict 
            Dictionary of keyword arguments passed to 
            :class:`matplotlib.gridspec.GridSpec` 
            (via :meth:`matplotlib.figure.Figure.subplots`). 
            Ignored if ``col_wrap`` is not ``None``. 
 
        See Also 
        -------- 
        PairGrid : Subplot grid for plotting pairwise relationships 
        relplot : Combine a relational plot and a :class:`FacetGrid` 
        displot : Combine a distribution plot and a :class:`FacetGrid` 
        catplot : Combine a categorical plot and a :class:`FacetGrid` 
        lmplot : Combine a regression plot and a :class:`FacetGrid` 
 
        Examples 
        -------- 
 
        .. note:: 
 
            These examples use seaborn functions to demonstrate some of the 
            advanced features of the class, but in most cases you will want 
            to use figue-level functions (e.g. :func:`displot`, :func:`relplot`) 
            to make the plots shown here. 
 
        .. include:: ../docstrings/FacetGrid.rst 
 
        &quot;&quot;&quot;</span><span class="s1">).format(**_facet_docs)</span>

    <span class="s0">def </span><span class="s1">facet_data(self):</span>
        <span class="s3">&quot;&quot;&quot;Generator for name indices and data subsets for each facet. 
 
        Yields 
        ------ 
        (i, j, k), data_ijk : tuple of ints, DataFrame 
            The ints provide an index into the {row, col, hue}_names attribute, 
            and the dataframe contains a subset of the full data corresponding 
            to each facet. The generator yields subsets that correspond with 
            the self.axes.flat iterator, or self.axes[i, j] when `col_wrap` 
            is None. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">data = self.data</span>

        <span class="s4"># Construct masks for the row variable</span>
        <span class="s0">if </span><span class="s1">self.row_names:</span>
            <span class="s1">row_masks = [data[self._row_var] == n </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">self.row_names]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">row_masks = [np.repeat(</span><span class="s0">True, </span><span class="s1">len(self.data))]</span>

        <span class="s4"># Construct masks for the column variable</span>
        <span class="s0">if </span><span class="s1">self.col_names:</span>
            <span class="s1">col_masks = [data[self._col_var] == n </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">self.col_names]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">col_masks = [np.repeat(</span><span class="s0">True, </span><span class="s1">len(self.data))]</span>

        <span class="s4"># Construct masks for the hue variable</span>
        <span class="s0">if </span><span class="s1">self.hue_names:</span>
            <span class="s1">hue_masks = [data[self._hue_var] == n </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">self.hue_names]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hue_masks = [np.repeat(</span><span class="s0">True, </span><span class="s1">len(self.data))]</span>

        <span class="s4"># Here is the main generator loop</span>
        <span class="s0">for </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">row)</span><span class="s0">, </span><span class="s1">(j</span><span class="s0">, </span><span class="s1">col)</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">hue) </span><span class="s0">in </span><span class="s1">product(enumerate(row_masks)</span><span class="s0">,</span>
                                                    <span class="s1">enumerate(col_masks)</span><span class="s0">,</span>
                                                    <span class="s1">enumerate(hue_masks)):</span>
            <span class="s1">data_ijk = data[row &amp; col &amp; hue &amp; self._not_na]</span>
            <span class="s0">yield </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">data_ijk</span>

    <span class="s0">def </span><span class="s1">map(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Apply a plotting function to each facet's subset of the data. 
 
        Parameters 
        ---------- 
        func : callable 
            A plotting function that takes data and keyword arguments. It 
            must plot to the currently active matplotlib Axes and take a 
            `color` keyword argument. If faceting on the `hue` dimension, 
            it must also take a `label` keyword argument. 
        args : strings 
            Column names in self.data that identify variables with data to 
            plot. The data for each variable is passed to `func` in the 
            order the variables are specified in the call. 
        kwargs : keyword arguments 
            All keyword arguments are passed to the plotting function. 
 
        Returns 
        ------- 
        self : object 
            Returns self. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># If color was a keyword argument, grab it here</span>
        <span class="s1">kw_color = kwargs.pop(</span><span class="s2">&quot;color&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s4"># How we use the function depends on where it comes from</span>
        <span class="s1">func_module = str(getattr(func</span><span class="s0">, </span><span class="s2">&quot;__module__&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">))</span>

        <span class="s4"># Check for categorical plots without order information</span>
        <span class="s0">if </span><span class="s1">func_module == </span><span class="s2">&quot;seaborn.categorical&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s2">&quot;order&quot; </span><span class="s0">not in </span><span class="s1">kwargs:</span>
                <span class="s1">warning = (</span><span class="s2">&quot;Using the {} function without specifying &quot;</span>
                           <span class="s2">&quot;`order` is likely to produce an incorrect &quot;</span>
                           <span class="s2">&quot;plot.&quot;</span><span class="s1">.format(func.__name__))</span>
                <span class="s1">warnings.warn(warning)</span>
            <span class="s0">if </span><span class="s1">len(args) == </span><span class="s5">3 </span><span class="s0">and </span><span class="s2">&quot;hue_order&quot; </span><span class="s0">not in </span><span class="s1">kwargs:</span>
                <span class="s1">warning = (</span><span class="s2">&quot;Using the {} function without specifying &quot;</span>
                           <span class="s2">&quot;`hue_order` is likely to produce an incorrect &quot;</span>
                           <span class="s2">&quot;plot.&quot;</span><span class="s1">.format(func.__name__))</span>
                <span class="s1">warnings.warn(warning)</span>

        <span class="s4"># Iterate over the data subsets</span>
        <span class="s0">for </span><span class="s1">(row_i</span><span class="s0">, </span><span class="s1">col_j</span><span class="s0">, </span><span class="s1">hue_k)</span><span class="s0">, </span><span class="s1">data_ijk </span><span class="s0">in </span><span class="s1">self.facet_data():</span>

            <span class="s4"># If this subset is null, move on</span>
            <span class="s0">if not </span><span class="s1">data_ijk.values.size:</span>
                <span class="s0">continue</span>

            <span class="s4"># Get the current axis</span>
            <span class="s1">modify_state = </span><span class="s0">not </span><span class="s1">func_module.startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">)</span>
            <span class="s1">ax = self.facet_axis(row_i</span><span class="s0">, </span><span class="s1">col_j</span><span class="s0">, </span><span class="s1">modify_state)</span>

            <span class="s4"># Decide what color to plot with</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = self._facet_color(hue_k</span><span class="s0">, </span><span class="s1">kw_color)</span>

            <span class="s4"># Insert the other hue aesthetics if appropriate</span>
            <span class="s0">for </span><span class="s1">kw</span><span class="s0">, </span><span class="s1">val_list </span><span class="s0">in </span><span class="s1">self.hue_kws.items():</span>
                <span class="s1">kwargs[kw] = val_list[hue_k]</span>

            <span class="s4"># Insert a label in the keyword arguments for the legend</span>
            <span class="s0">if </span><span class="s1">self._hue_var </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;label&quot;</span><span class="s1">] = utils.to_utf8(self.hue_names[hue_k])</span>

            <span class="s4"># Get the actual data we are going to plot with</span>
            <span class="s1">plot_data = data_ijk[list(args)]</span>
            <span class="s0">if </span><span class="s1">self._dropna:</span>
                <span class="s1">plot_data = plot_data.dropna()</span>
            <span class="s1">plot_args = [v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">plot_data.items()]</span>

            <span class="s4"># Some matplotlib functions don't handle pandas objects correctly</span>
            <span class="s0">if </span><span class="s1">func_module.startswith(</span><span class="s2">&quot;matplotlib&quot;</span><span class="s1">):</span>
                <span class="s1">plot_args = [v.values </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">plot_args]</span>

            <span class="s4"># Draw the plot</span>
            <span class="s1">self._facet_plot(func</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">plot_args</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s4"># Finalize the annotations and layout</span>
        <span class="s1">self._finalize_grid(args[:</span><span class="s5">2</span><span class="s1">])</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">map_dataframe(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Like ``.map`` but passes args as strings and inserts data in kwargs. 
 
        This method is suitable for plotting with functions that accept a 
        long-form DataFrame as a `data` keyword argument and access the 
        data in that DataFrame using string variable names. 
 
        Parameters 
        ---------- 
        func : callable 
            A plotting function that takes data and keyword arguments. Unlike 
            the `map` method, a function used here must &quot;understand&quot; Pandas 
            objects. It also must plot to the currently active matplotlib Axes 
            and take a `color` keyword argument. If faceting on the `hue` 
            dimension, it must also take a `label` keyword argument. 
        args : strings 
            Column names in self.data that identify variables with data to 
            plot. The data for each variable is passed to `func` in the 
            order the variables are specified in the call. 
        kwargs : keyword arguments 
            All keyword arguments are passed to the plotting function. 
 
        Returns 
        ------- 
        self : object 
            Returns self. 
 
        &quot;&quot;&quot;</span>

        <span class="s4"># If color was a keyword argument, grab it here</span>
        <span class="s1">kw_color = kwargs.pop(</span><span class="s2">&quot;color&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s4"># Iterate over the data subsets</span>
        <span class="s0">for </span><span class="s1">(row_i</span><span class="s0">, </span><span class="s1">col_j</span><span class="s0">, </span><span class="s1">hue_k)</span><span class="s0">, </span><span class="s1">data_ijk </span><span class="s0">in </span><span class="s1">self.facet_data():</span>

            <span class="s4"># If this subset is null, move on</span>
            <span class="s0">if not </span><span class="s1">data_ijk.values.size:</span>
                <span class="s0">continue</span>

            <span class="s4"># Get the current axis</span>
            <span class="s1">modify_state = </span><span class="s0">not </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">)</span>
            <span class="s1">ax = self.facet_axis(row_i</span><span class="s0">, </span><span class="s1">col_j</span><span class="s0">, </span><span class="s1">modify_state)</span>

            <span class="s4"># Decide what color to plot with</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = self._facet_color(hue_k</span><span class="s0">, </span><span class="s1">kw_color)</span>

            <span class="s4"># Insert the other hue aesthetics if appropriate</span>
            <span class="s0">for </span><span class="s1">kw</span><span class="s0">, </span><span class="s1">val_list </span><span class="s0">in </span><span class="s1">self.hue_kws.items():</span>
                <span class="s1">kwargs[kw] = val_list[hue_k]</span>

            <span class="s4"># Insert a label in the keyword arguments for the legend</span>
            <span class="s0">if </span><span class="s1">self._hue_var </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;label&quot;</span><span class="s1">] = self.hue_names[hue_k]</span>

            <span class="s4"># Stick the facet dataframe into the kwargs</span>
            <span class="s0">if </span><span class="s1">self._dropna:</span>
                <span class="s1">data_ijk = data_ijk.dropna()</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;data&quot;</span><span class="s1">] = data_ijk</span>

            <span class="s4"># Draw the plot</span>
            <span class="s1">self._facet_plot(func</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s4"># For axis labels, prefer to use positional args for backcompat</span>
        <span class="s4"># but also extract the x/y kwargs and use if no corresponding arg</span>
        <span class="s1">axis_labels = [kwargs.get(</span><span class="s2">&quot;x&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">kwargs.get(</span><span class="s2">&quot;y&quot;</span><span class="s0">, None</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">enumerate(args[:</span><span class="s5">2</span><span class="s1">]):</span>
            <span class="s1">axis_labels[i] = val</span>
        <span class="s1">self._finalize_grid(axis_labels)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_facet_color(self</span><span class="s0">, </span><span class="s1">hue_index</span><span class="s0">, </span><span class="s1">kw_color):</span>

        <span class="s1">color = self._colors[hue_index]</span>
        <span class="s0">if </span><span class="s1">kw_color </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">kw_color</span>
        <span class="s0">elif </span><span class="s1">color </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">color</span>

    <span class="s0">def </span><span class="s1">_facet_plot(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">plot_args</span><span class="s0">, </span><span class="s1">plot_kwargs):</span>

        <span class="s4"># Draw the plot</span>
        <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
            <span class="s1">plot_kwargs = plot_kwargs.copy()</span>
            <span class="s1">semantics = [</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;hue&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s2">&quot;style&quot;</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">zip(semantics</span><span class="s0">, </span><span class="s1">plot_args):</span>
                <span class="s1">plot_kwargs[key] = val</span>
            <span class="s1">plot_args = []</span>
            <span class="s1">plot_kwargs[</span><span class="s2">&quot;ax&quot;</span><span class="s1">] = ax</span>
        <span class="s1">func(*plot_args</span><span class="s0">, </span><span class="s1">**plot_kwargs)</span>

        <span class="s4"># Sort out the supporting information</span>
        <span class="s1">self._update_legend_data(ax)</span>

    <span class="s0">def </span><span class="s1">_finalize_grid(self</span><span class="s0">, </span><span class="s1">axlabels):</span>
        <span class="s3">&quot;&quot;&quot;Finalize the annotations and layout.&quot;&quot;&quot;</span>
        <span class="s1">self.set_axis_labels(*axlabels)</span>
        <span class="s1">self.tight_layout()</span>

    <span class="s0">def </span><span class="s1">facet_axis(self</span><span class="s0">, </span><span class="s1">row_i</span><span class="s0">, </span><span class="s1">col_j</span><span class="s0">, </span><span class="s1">modify_state=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Make the axis identified by these indices active and return it.&quot;&quot;&quot;</span>

        <span class="s4"># Calculate the actual indices of the axes to plot on</span>
        <span class="s0">if </span><span class="s1">self._col_wrap </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">ax = self.axes.flat[col_j]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ax = self.axes[row_i</span><span class="s0">, </span><span class="s1">col_j]</span>

        <span class="s4"># Get a reference to the axes object we want, and make it active</span>
        <span class="s0">if </span><span class="s1">modify_state:</span>
            <span class="s1">plt.sca(ax)</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">def </span><span class="s1">despine(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Remove axis spines from the facets.&quot;&quot;&quot;</span>
        <span class="s1">utils.despine(self._figure</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">set_axis_labels(self</span><span class="s0">, </span><span class="s1">x_var=</span><span class="s0">None, </span><span class="s1">y_var=</span><span class="s0">None, </span><span class="s1">clear_inner=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Set axis labels on the left column and bottom row of the grid.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">x_var </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._x_var = x_var</span>
            <span class="s1">self.set_xlabels(x_var</span><span class="s0">, </span><span class="s1">clear_inner=clear_inner</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">y_var </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._y_var = y_var</span>
            <span class="s1">self.set_ylabels(y_var</span><span class="s0">, </span><span class="s1">clear_inner=clear_inner</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">set_xlabels(self</span><span class="s0">, </span><span class="s1">label=</span><span class="s0">None, </span><span class="s1">clear_inner=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Label the x axis on the bottom row of the grid.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">label </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">label = self._x_var</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._bottom_axes:</span>
            <span class="s1">ax.set_xlabel(label</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">clear_inner:</span>
            <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._not_bottom_axes:</span>
                <span class="s1">ax.set_xlabel(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">set_ylabels(self</span><span class="s0">, </span><span class="s1">label=</span><span class="s0">None, </span><span class="s1">clear_inner=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Label the y axis on the left column of the grid.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">label </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">label = self._y_var</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._left_axes:</span>
            <span class="s1">ax.set_ylabel(label</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">clear_inner:</span>
            <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._not_left_axes:</span>
                <span class="s1">ax.set_ylabel(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">set_xticklabels(self</span><span class="s0">, </span><span class="s1">labels=</span><span class="s0">None, </span><span class="s1">step=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Set x axis tick labels of the grid.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self.axes.flat:</span>
            <span class="s1">curr_ticks = ax.get_xticks()</span>
            <span class="s1">ax.set_xticks(curr_ticks)</span>
            <span class="s0">if </span><span class="s1">labels </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">curr_labels = [label.get_text() </span><span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">ax.get_xticklabels()]</span>
                <span class="s0">if </span><span class="s1">step </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">xticks = ax.get_xticks()[::step]</span>
                    <span class="s1">curr_labels = curr_labels[::step]</span>
                    <span class="s1">ax.set_xticks(xticks)</span>
                <span class="s1">ax.set_xticklabels(curr_labels</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ax.set_xticklabels(labels</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">set_yticklabels(self</span><span class="s0">, </span><span class="s1">labels=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Set y axis tick labels on the left column of the grid.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self.axes.flat:</span>
            <span class="s1">curr_ticks = ax.get_yticks()</span>
            <span class="s1">ax.set_yticks(curr_ticks)</span>
            <span class="s0">if </span><span class="s1">labels </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">curr_labels = [label.get_text() </span><span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">ax.get_yticklabels()]</span>
                <span class="s1">ax.set_yticklabels(curr_labels</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ax.set_yticklabels(labels</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">set_titles(self</span><span class="s0">, </span><span class="s1">template=</span><span class="s0">None, </span><span class="s1">row_template=</span><span class="s0">None, </span><span class="s1">col_template=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Draw titles either above each facet or on the grid margins. 
 
        Parameters 
        ---------- 
        template : string 
            Template for all titles with the formatting keys {col_var} and 
            {col_name} (if using a `col` faceting variable) and/or {row_var} 
            and {row_name} (if using a `row` faceting variable). 
        row_template: 
            Template for the row variable when titles are drawn on the grid 
            margins. Must have {row_var} and {row_name} formatting keys. 
        col_template: 
            Template for the column variable when titles are drawn on the grid 
            margins. Must have {col_var} and {col_name} formatting keys. 
 
        Returns 
        ------- 
        self: object 
            Returns self. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">args = dict(row_var=self._row_var</span><span class="s0">, </span><span class="s1">col_var=self._col_var)</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;size&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s1">mpl.rcParams[</span><span class="s2">&quot;axes.labelsize&quot;</span><span class="s1">])</span>

        <span class="s4"># Establish default templates</span>
        <span class="s0">if </span><span class="s1">row_template </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">row_template = </span><span class="s2">&quot;{row_var} = {row_name}&quot;</span>
        <span class="s0">if </span><span class="s1">col_template </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">col_template = </span><span class="s2">&quot;{col_var} = {col_name}&quot;</span>
        <span class="s0">if </span><span class="s1">template </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self._row_var </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">template = col_template</span>
            <span class="s0">elif </span><span class="s1">self._col_var </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">template = row_template</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">template = </span><span class="s2">&quot; | &quot;</span><span class="s1">.join([row_template</span><span class="s0">, </span><span class="s1">col_template])</span>

        <span class="s1">row_template = utils.to_utf8(row_template)</span>
        <span class="s1">col_template = utils.to_utf8(col_template)</span>
        <span class="s1">template = utils.to_utf8(template)</span>

        <span class="s0">if </span><span class="s1">self._margin_titles:</span>

            <span class="s4"># Remove any existing title texts</span>
            <span class="s0">for </span><span class="s1">text </span><span class="s0">in </span><span class="s1">self._margin_titles_texts:</span>
                <span class="s1">text.remove()</span>
            <span class="s1">self._margin_titles_texts = []</span>

            <span class="s0">if </span><span class="s1">self.row_names </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s4"># Draw the row titles on the right edge of the grid</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">row_name </span><span class="s0">in </span><span class="s1">enumerate(self.row_names):</span>
                    <span class="s1">ax = self.axes[i</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">args.update(dict(row_name=row_name))</span>
                    <span class="s1">title = row_template.format(**args)</span>
                    <span class="s1">text = ax.annotate(</span>
                        <span class="s1">title</span><span class="s0">, </span><span class="s1">xy=(</span><span class="s5">1.02</span><span class="s0">, </span><span class="s5">.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">xycoords=</span><span class="s2">&quot;axes fraction&quot;</span><span class="s0">,</span>
                        <span class="s1">rotation=</span><span class="s5">270</span><span class="s0">, </span><span class="s1">ha=</span><span class="s2">&quot;left&quot;</span><span class="s0">, </span><span class="s1">va=</span><span class="s2">&quot;center&quot;</span><span class="s0">,</span>
                        <span class="s1">**kwargs</span>
                    <span class="s1">)</span>
                    <span class="s1">self._margin_titles_texts.append(text)</span>

            <span class="s0">if </span><span class="s1">self.col_names </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s4"># Draw the column titles  as normal titles</span>
                <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">col_name </span><span class="s0">in </span><span class="s1">enumerate(self.col_names):</span>
                    <span class="s1">args.update(dict(col_name=col_name))</span>
                    <span class="s1">title = col_template.format(**args)</span>
                    <span class="s1">self.axes[</span><span class="s5">0</span><span class="s0">, </span><span class="s1">j].set_title(title</span><span class="s0">, </span><span class="s1">**kwargs)</span>

            <span class="s0">return </span><span class="s1">self</span>

        <span class="s4"># Otherwise title each facet with all the necessary information</span>
        <span class="s0">if </span><span class="s1">(self._row_var </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(self._col_var </span><span class="s0">is not None</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">row_name </span><span class="s0">in </span><span class="s1">enumerate(self.row_names):</span>
                <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">col_name </span><span class="s0">in </span><span class="s1">enumerate(self.col_names):</span>
                    <span class="s1">args.update(dict(row_name=row_name</span><span class="s0">, </span><span class="s1">col_name=col_name))</span>
                    <span class="s1">title = template.format(**args)</span>
                    <span class="s1">self.axes[i</span><span class="s0">, </span><span class="s1">j].set_title(title</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">elif </span><span class="s1">self.row_names </span><span class="s0">is not None and </span><span class="s1">len(self.row_names):</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">row_name </span><span class="s0">in </span><span class="s1">enumerate(self.row_names):</span>
                <span class="s1">args.update(dict(row_name=row_name))</span>
                <span class="s1">title = template.format(**args)</span>
                <span class="s1">self.axes[i</span><span class="s0">, </span><span class="s5">0</span><span class="s1">].set_title(title</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">elif </span><span class="s1">self.col_names </span><span class="s0">is not None and </span><span class="s1">len(self.col_names):</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">col_name </span><span class="s0">in </span><span class="s1">enumerate(self.col_names):</span>
                <span class="s1">args.update(dict(col_name=col_name))</span>
                <span class="s1">title = template.format(**args)</span>
                <span class="s4"># Index the flat array so col_wrap works</span>
                <span class="s1">self.axes.flat[i].set_title(title</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">refline(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s2">'.5'</span><span class="s0">, </span><span class="s1">linestyle=</span><span class="s2">'--'</span><span class="s0">, </span><span class="s1">**line_kws):</span>
        <span class="s3">&quot;&quot;&quot;Add a reference line(s) to each facet. 
 
        Parameters 
        ---------- 
        x, y : numeric 
            Value(s) to draw the line(s) at. 
        color : :mod:`matplotlib color &lt;matplotlib.colors&gt;` 
            Specifies the color of the reference line(s). Pass ``color=None`` to 
            use ``hue`` mapping. 
        linestyle : str 
            Specifies the style of the reference line(s). 
        line_kws : key, value mappings 
            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline` 
            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y`` 
            is not None. 
 
        Returns 
        ------- 
        :class:`FacetGrid` instance 
            Returns ``self`` for easy method chaining. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">line_kws[</span><span class="s2">'color'</span><span class="s1">] = color</span>
        <span class="s1">line_kws[</span><span class="s2">'linestyle'</span><span class="s1">] = linestyle</span>

        <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.map(plt.axvline</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">**line_kws)</span>

        <span class="s0">if </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.map(plt.axhline</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">**line_kws)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s4"># ------ Properties that are part of the public API and documented by Sphinx</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">axes(self):</span>
        <span class="s3">&quot;&quot;&quot;An array of the :class:`matplotlib.axes.Axes` objects in the grid.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._axes</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">ax(self):</span>
        <span class="s3">&quot;&quot;&quot;The :class:`matplotlib.axes.Axes` when no faceting variables are assigned.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.axes.shape == (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">self.axes[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">err = (</span>
                <span class="s2">&quot;Use the `.axes` attribute when facet variables are assigned.&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">AttributeError(err)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">axes_dict(self):</span>
        <span class="s3">&quot;&quot;&quot;A mapping of facet names to corresponding :class:`matplotlib.axes.Axes`. 
 
        If only one of ``row`` or ``col`` is assigned, each key is a string 
        representing a level of that variable. If both facet dimensions are 
        assigned, each key is a ``({row_level}, {col_level})`` tuple. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._axes_dict</span>

    <span class="s4"># ------ Private properties, that require some computation to get</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_inner_axes(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a flat array of the inner axes.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._col_wrap </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.axes[:-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">:].flat</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes = []</span>
            <span class="s1">n_empty = self._nrow * self._ncol - self._n_facets</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(self.axes):</span>
                <span class="s1">append = (</span>
                    <span class="s1">i % self._ncol</span>
                    <span class="s0">and </span><span class="s1">i &lt; (self._ncol * (self._nrow - </span><span class="s5">1</span><span class="s1">))</span>
                    <span class="s0">and </span><span class="s1">i &lt; (self._ncol * (self._nrow - </span><span class="s5">1</span><span class="s1">) - n_empty)</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">append:</span>
                    <span class="s1">axes.append(ax)</span>
            <span class="s0">return </span><span class="s1">np.array(axes</span><span class="s0">, </span><span class="s1">object).flat</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_left_axes(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a flat array of the left column of axes.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._col_wrap </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.axes[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">].flat</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes = []</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(self.axes):</span>
                <span class="s0">if not </span><span class="s1">i % self._ncol:</span>
                    <span class="s1">axes.append(ax)</span>
            <span class="s0">return </span><span class="s1">np.array(axes</span><span class="s0">, </span><span class="s1">object).flat</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_not_left_axes(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a flat array of axes that aren't on the left column.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._col_wrap </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.axes[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">:].flat</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes = []</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(self.axes):</span>
                <span class="s0">if </span><span class="s1">i % self._ncol:</span>
                    <span class="s1">axes.append(ax)</span>
            <span class="s0">return </span><span class="s1">np.array(axes</span><span class="s0">, </span><span class="s1">object).flat</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_bottom_axes(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a flat array of the bottom row of axes.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._col_wrap </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.axes[-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">:].flat</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes = []</span>
            <span class="s1">n_empty = self._nrow * self._ncol - self._n_facets</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(self.axes):</span>
                <span class="s1">append = (</span>
                    <span class="s1">i &gt;= (self._ncol * (self._nrow - </span><span class="s5">1</span><span class="s1">))</span>
                    <span class="s0">or </span><span class="s1">i &gt;= (self._ncol * (self._nrow - </span><span class="s5">1</span><span class="s1">) - n_empty)</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">append:</span>
                    <span class="s1">axes.append(ax)</span>
            <span class="s0">return </span><span class="s1">np.array(axes</span><span class="s0">, </span><span class="s1">object).flat</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_not_bottom_axes(self):</span>
        <span class="s3">&quot;&quot;&quot;Return a flat array of axes that aren't on the bottom row.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._col_wrap </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.axes[:-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">:].flat</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes = []</span>
            <span class="s1">n_empty = self._nrow * self._ncol - self._n_facets</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(self.axes):</span>
                <span class="s1">append = (</span>
                    <span class="s1">i &lt; (self._ncol * (self._nrow - </span><span class="s5">1</span><span class="s1">))</span>
                    <span class="s0">and </span><span class="s1">i &lt; (self._ncol * (self._nrow - </span><span class="s5">1</span><span class="s1">) - n_empty)</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">append:</span>
                    <span class="s1">axes.append(ax)</span>
            <span class="s0">return </span><span class="s1">np.array(axes</span><span class="s0">, </span><span class="s1">object).flat</span>


<span class="s0">class </span><span class="s1">PairGrid(Grid):</span>
    <span class="s3">&quot;&quot;&quot;Subplot grid for plotting pairwise relationships in a dataset. 
 
    This object maps each variable in a dataset onto a column and row in a 
    grid of multiple axes. Different axes-level plotting functions can be 
    used to draw bivariate plots in the upper and lower triangles, and the 
    marginal distribution of each variable can be shown on the diagonal. 
 
    Several different common plots can be generated in a single line using 
    :func:`pairplot`. Use :class:`PairGrid` when you need more flexibility. 
 
    See the :ref:`tutorial &lt;grid_tutorial&gt;` for more information. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">vars=</span><span class="s0">None, </span><span class="s1">x_vars=</span><span class="s0">None, </span><span class="s1">y_vars=</span><span class="s0">None,</span>
        <span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">hue_kws=</span><span class="s0">None, </span><span class="s1">corner=</span><span class="s0">False, </span><span class="s1">diag_sharey=</span><span class="s0">True,</span>
        <span class="s1">height=</span><span class="s5">2.5</span><span class="s0">, </span><span class="s1">aspect=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">layout_pad=</span><span class="s5">.5</span><span class="s0">, </span><span class="s1">despine=</span><span class="s0">True, </span><span class="s1">dropna=</span><span class="s0">False,</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Initialize the plot figure and PairGrid object. 
 
        Parameters 
        ---------- 
        data : DataFrame 
            Tidy (long-form) dataframe where each column is a variable and 
            each row is an observation. 
        hue : string (variable name) 
            Variable in ``data`` to map plot aspects to different colors. This 
            variable will be excluded from the default x and y variables. 
        vars : list of variable names 
            Variables within ``data`` to use, otherwise use every column with 
            a numeric datatype. 
        {x, y}_vars : lists of variable names 
            Variables within ``data`` to use separately for the rows and 
            columns of the figure; i.e. to make a non-square plot. 
        hue_order : list of strings 
            Order for the levels of the hue variable in the palette 
        palette : dict or seaborn color palette 
            Set of colors for mapping the ``hue`` variable. If a dict, keys 
            should be values  in the ``hue`` variable. 
        hue_kws : dictionary of param -&gt; list of values mapping 
            Other keyword arguments to insert into the plotting call to let 
            other plot attributes vary across levels of the hue variable (e.g. 
            the markers in a scatterplot). 
        corner : bool 
            If True, don't add axes to the upper (off-diagonal) triangle of the 
            grid, making this a &quot;corner&quot; plot. 
        height : scalar 
            Height (in inches) of each facet. 
        aspect : scalar 
            Aspect * height gives the width (in inches) of each facet. 
        layout_pad : scalar 
            Padding between axes; passed to ``fig.tight_layout``. 
        despine : boolean 
            Remove the top and right spines from the plots. 
        dropna : boolean 
            Drop missing values from the data before plotting. 
 
        See Also 
        -------- 
        pairplot : Easily drawing common uses of :class:`PairGrid`. 
        FacetGrid : Subplot grid for plotting conditional relationships. 
 
        Examples 
        -------- 
 
        .. include:: ../docstrings/PairGrid.rst 
 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__()</span>
        <span class="s1">data = handle_data_source(data)</span>

        <span class="s4"># Sort out the variables that define the grid</span>
        <span class="s1">numeric_cols = self._find_numeric_cols(data)</span>
        <span class="s0">if </span><span class="s1">hue </span><span class="s0">in </span><span class="s1">numeric_cols:</span>
            <span class="s1">numeric_cols.remove(hue)</span>
        <span class="s0">if </span><span class="s1">vars </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">x_vars = list(vars)</span>
            <span class="s1">y_vars = list(vars)</span>
        <span class="s0">if </span><span class="s1">x_vars </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">x_vars = numeric_cols</span>
        <span class="s0">if </span><span class="s1">y_vars </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">y_vars = numeric_cols</span>

        <span class="s0">if </span><span class="s1">np.isscalar(x_vars):</span>
            <span class="s1">x_vars = [x_vars]</span>
        <span class="s0">if </span><span class="s1">np.isscalar(y_vars):</span>
            <span class="s1">y_vars = [y_vars]</span>

        <span class="s1">self.x_vars = x_vars = list(x_vars)</span>
        <span class="s1">self.y_vars = y_vars = list(y_vars)</span>
        <span class="s1">self.square_grid = self.x_vars == self.y_vars</span>

        <span class="s0">if not </span><span class="s1">x_vars:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No variables found for grid columns.&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">y_vars:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No variables found for grid rows.&quot;</span><span class="s1">)</span>

        <span class="s4"># Create the figure and the array of subplots</span>
        <span class="s1">figsize = len(x_vars) * height * aspect</span><span class="s0">, </span><span class="s1">len(y_vars) * height</span>

        <span class="s0">with </span><span class="s1">_disable_autolayout():</span>
            <span class="s1">fig = plt.figure(figsize=figsize)</span>

        <span class="s1">axes = fig.subplots(len(y_vars)</span><span class="s0">, </span><span class="s1">len(x_vars)</span><span class="s0">,</span>
                            <span class="s1">sharex=</span><span class="s2">&quot;col&quot;</span><span class="s0">, </span><span class="s1">sharey=</span><span class="s2">&quot;row&quot;</span><span class="s0">,</span>
                            <span class="s1">squeeze=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s4"># Possibly remove upper axes to make a corner grid</span>
        <span class="s4"># Note: setting up the axes is usually the most time-intensive part</span>
        <span class="s4"># of using the PairGrid. We are foregoing the speed improvement that</span>
        <span class="s4"># we would get by just not setting up the hidden axes so that we can</span>
        <span class="s4"># avoid implementing fig.subplots ourselves. But worth thinking about.</span>
        <span class="s1">self._corner = corner</span>
        <span class="s0">if </span><span class="s1">corner:</span>
            <span class="s1">hide_indices = np.triu_indices_from(axes</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip(*hide_indices):</span>
                <span class="s1">axes[i</span><span class="s0">, </span><span class="s1">j].remove()</span>
                <span class="s1">axes[i</span><span class="s0">, </span><span class="s1">j] = </span><span class="s0">None</span>

        <span class="s1">self._figure = fig</span>
        <span class="s1">self.axes = axes</span>
        <span class="s1">self.data = data</span>

        <span class="s4"># Save what we are going to do with the diagonal</span>
        <span class="s1">self.diag_sharey = diag_sharey</span>
        <span class="s1">self.diag_vars = </span><span class="s0">None</span>
        <span class="s1">self.diag_axes = </span><span class="s0">None</span>

        <span class="s1">self._dropna = dropna</span>

        <span class="s4"># Label the axes</span>
        <span class="s1">self._add_axis_labels()</span>

        <span class="s4"># Sort out the hue variable</span>
        <span class="s1">self._hue_var = hue</span>
        <span class="s0">if </span><span class="s1">hue </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.hue_names = hue_order = [</span><span class="s2">&quot;_nolegend_&quot;</span><span class="s1">]</span>
            <span class="s1">self.hue_vals = pd.Series([</span><span class="s2">&quot;_nolegend_&quot;</span><span class="s1">] * len(data)</span><span class="s0">,</span>
                                      <span class="s1">index=data.index)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># We need hue_order and hue_names because the former is used to control</span>
            <span class="s4"># the order of drawing and the latter is used to control the order of</span>
            <span class="s4"># the legend. hue_names can become string-typed while hue_order must</span>
            <span class="s4"># retain the type of the input data. This is messy but results from</span>
            <span class="s4"># the fact that PairGrid can implement the hue-mapping logic itself</span>
            <span class="s4"># (and was originally written exclusively that way) but now can delegate</span>
            <span class="s4"># to the axes-level functions, while always handling legend creation.</span>
            <span class="s4"># See GH2307</span>
            <span class="s1">hue_names = hue_order = categorical_order(data[hue]</span><span class="s0">, </span><span class="s1">hue_order)</span>
            <span class="s0">if </span><span class="s1">dropna:</span>
                <span class="s4"># Filter NA from the list of unique hue names</span>
                <span class="s1">hue_names = list(filter(pd.notnull</span><span class="s0">, </span><span class="s1">hue_names))</span>
            <span class="s1">self.hue_names = hue_names</span>
            <span class="s1">self.hue_vals = data[hue]</span>

        <span class="s4"># Additional dict of kwarg -&gt; list of values for mapping the hue var</span>
        <span class="s1">self.hue_kws = hue_kws </span><span class="s0">if </span><span class="s1">hue_kws </span><span class="s0">is not None else </span><span class="s1">{}</span>

        <span class="s1">self._orig_palette = palette</span>
        <span class="s1">self._hue_order = hue_order</span>
        <span class="s1">self.palette = self._get_palette(data</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">hue_order</span><span class="s0">, </span><span class="s1">palette)</span>
        <span class="s1">self._legend_data = {}</span>

        <span class="s4"># Make the plot look nice</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axes[:-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">:].flat:</span>
            <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">ax.get_xticklabels():</span>
                <span class="s1">label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">ax.xaxis.offsetText.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">ax.xaxis.label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axes[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">:].flat:</span>
            <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">ax.get_yticklabels():</span>
                <span class="s1">label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">ax.yaxis.offsetText.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">ax.yaxis.label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">self._tight_layout_rect = [</span><span class="s5">.01</span><span class="s0">, </span><span class="s5">.01</span><span class="s0">, </span><span class="s5">.99</span><span class="s0">, </span><span class="s5">.99</span><span class="s1">]</span>
        <span class="s1">self._tight_layout_pad = layout_pad</span>
        <span class="s1">self._despine = despine</span>
        <span class="s0">if </span><span class="s1">despine:</span>
            <span class="s1">utils.despine(fig=fig)</span>
        <span class="s1">self.tight_layout(pad=layout_pad)</span>

    <span class="s0">def </span><span class="s1">map(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Plot with the same function in every subplot. 
 
        Parameters 
        ---------- 
        func : callable plotting function 
            Must take x, y arrays as positional arguments and draw onto the 
            &quot;currently active&quot; matplotlib Axes. Also needs to accept kwargs 
            called ``color`` and  ``label``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">row_indices</span><span class="s0">, </span><span class="s1">col_indices = np.indices(self.axes.shape)</span>
        <span class="s1">indices = zip(row_indices.flat</span><span class="s0">, </span><span class="s1">col_indices.flat)</span>
        <span class="s1">self._map_bivariate(func</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">map_lower(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Plot with a bivariate function on the lower diagonal subplots. 
 
        Parameters 
        ---------- 
        func : callable plotting function 
            Must take x, y arrays as positional arguments and draw onto the 
            &quot;currently active&quot; matplotlib Axes. Also needs to accept kwargs 
            called ``color`` and  ``label``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">indices = zip(*np.tril_indices_from(self.axes</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">self._map_bivariate(func</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">map_upper(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Plot with a bivariate function on the upper diagonal subplots. 
 
        Parameters 
        ---------- 
        func : callable plotting function 
            Must take x, y arrays as positional arguments and draw onto the 
            &quot;currently active&quot; matplotlib Axes. Also needs to accept kwargs 
            called ``color`` and  ``label``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">indices = zip(*np.triu_indices_from(self.axes</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">self._map_bivariate(func</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">map_offdiag(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Plot with a bivariate function on the off-diagonal subplots. 
 
        Parameters 
        ---------- 
        func : callable plotting function 
            Must take x, y arrays as positional arguments and draw onto the 
            &quot;currently active&quot; matplotlib Axes. Also needs to accept kwargs 
            called ``color`` and  ``label``. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.square_grid:</span>
            <span class="s1">self.map_lower(func</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">if not </span><span class="s1">self._corner:</span>
                <span class="s1">self.map_upper(func</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">indices = []</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(y_var) </span><span class="s0">in </span><span class="s1">enumerate(self.y_vars):</span>
                <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">(x_var) </span><span class="s0">in </span><span class="s1">enumerate(self.x_vars):</span>
                    <span class="s0">if </span><span class="s1">x_var != y_var:</span>
                        <span class="s1">indices.append((i</span><span class="s0">, </span><span class="s1">j))</span>
            <span class="s1">self._map_bivariate(func</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">map_diag(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Plot with a univariate function on each diagonal subplot. 
 
        Parameters 
        ---------- 
        func : callable plotting function 
            Must take an x array as a positional argument and draw onto the 
            &quot;currently active&quot; matplotlib Axes. Also needs to accept kwargs 
            called ``color`` and  ``label``. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># Add special diagonal axes for the univariate plot</span>
        <span class="s0">if </span><span class="s1">self.diag_axes </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">diag_vars = []</span>
            <span class="s1">diag_axes = []</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">y_var </span><span class="s0">in </span><span class="s1">enumerate(self.y_vars):</span>
                <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">x_var </span><span class="s0">in </span><span class="s1">enumerate(self.x_vars):</span>
                    <span class="s0">if </span><span class="s1">x_var == y_var:</span>

                        <span class="s4"># Make the density axes</span>
                        <span class="s1">diag_vars.append(x_var)</span>
                        <span class="s1">ax = self.axes[i</span><span class="s0">, </span><span class="s1">j]</span>
                        <span class="s1">diag_ax = ax.twinx()</span>
                        <span class="s1">diag_ax.set_axis_off()</span>
                        <span class="s1">diag_axes.append(diag_ax)</span>

                        <span class="s4"># Work around matplotlib bug</span>
                        <span class="s4"># https://github.com/matplotlib/matplotlib/issues/15188</span>
                        <span class="s0">if not </span><span class="s1">plt.rcParams.get(</span><span class="s2">&quot;ytick.left&quot;</span><span class="s0">, True</span><span class="s1">):</span>
                            <span class="s0">for </span><span class="s1">tick </span><span class="s0">in </span><span class="s1">ax.yaxis.majorTicks:</span>
                                <span class="s1">tick.tick1line.set_visible(</span><span class="s0">False</span><span class="s1">)</span>

                        <span class="s4"># Remove main y axis from density axes in a corner plot</span>
                        <span class="s0">if </span><span class="s1">self._corner:</span>
                            <span class="s1">ax.yaxis.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
                            <span class="s0">if </span><span class="s1">self._despine:</span>
                                <span class="s1">utils.despine(ax=ax</span><span class="s0">, </span><span class="s1">left=</span><span class="s0">True</span><span class="s1">)</span>
                            <span class="s4"># TODO add optional density ticks (on the right)</span>
                            <span class="s4"># when drawing a corner plot?</span>

            <span class="s0">if </span><span class="s1">self.diag_sharey </span><span class="s0">and </span><span class="s1">diag_axes:</span>
                <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">diag_axes[</span><span class="s5">1</span><span class="s1">:]:</span>
                    <span class="s1">share_axis(diag_axes[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">)</span>

            <span class="s1">self.diag_vars = diag_vars</span>
            <span class="s1">self.diag_axes = diag_axes</span>

        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">not in </span><span class="s1">signature(func).parameters:</span>
            <span class="s0">return </span><span class="s1">self._map_diag_iter_hue(func</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Loop over diagonal variables and axes, making one plot in each</span>
        <span class="s0">for </span><span class="s1">var</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">zip(self.diag_vars</span><span class="s0">, </span><span class="s1">self.diag_axes):</span>

            <span class="s1">plot_kwargs = kwargs.copy()</span>
            <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
                <span class="s1">plot_kwargs[</span><span class="s2">&quot;ax&quot;</span><span class="s1">] = ax</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">plt.sca(ax)</span>

            <span class="s1">vector = self.data[var]</span>
            <span class="s0">if </span><span class="s1">self._hue_var </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">hue = self.data[self._hue_var]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">hue = </span><span class="s0">None</span>

            <span class="s0">if </span><span class="s1">self._dropna:</span>
                <span class="s1">not_na = vector.notna()</span>
                <span class="s0">if </span><span class="s1">hue </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">not_na &amp;= hue.notna()</span>
                <span class="s1">vector = vector[not_na]</span>
                <span class="s0">if </span><span class="s1">hue </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">hue = hue[not_na]</span>

            <span class="s1">plot_kwargs.setdefault(</span><span class="s2">&quot;hue&quot;</span><span class="s0">, </span><span class="s1">hue)</span>
            <span class="s1">plot_kwargs.setdefault(</span><span class="s2">&quot;hue_order&quot;</span><span class="s0">, </span><span class="s1">self._hue_order)</span>
            <span class="s1">plot_kwargs.setdefault(</span><span class="s2">&quot;palette&quot;</span><span class="s0">, </span><span class="s1">self._orig_palette)</span>
            <span class="s1">func(x=vector</span><span class="s0">, </span><span class="s1">**plot_kwargs)</span>
            <span class="s1">ax.legend_ = </span><span class="s0">None</span>

        <span class="s1">self._add_axis_labels()</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_map_diag_iter_hue(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Put marginal plot on each diagonal axes, iterating over hue.&quot;&quot;&quot;</span>
        <span class="s4"># Plot on each of the diagonal axes</span>
        <span class="s1">fixed_color = kwargs.pop(</span><span class="s2">&quot;color&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">var</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">zip(self.diag_vars</span><span class="s0">, </span><span class="s1">self.diag_axes):</span>
            <span class="s1">hue_grouped = self.data[var].groupby(self.hue_vals</span><span class="s0">, </span><span class="s1">observed=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">plot_kwargs = kwargs.copy()</span>
            <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
                <span class="s1">plot_kwargs[</span><span class="s2">&quot;ax&quot;</span><span class="s1">] = ax</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">plt.sca(ax)</span>

            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">label_k </span><span class="s0">in </span><span class="s1">enumerate(self._hue_order):</span>

                <span class="s4"># Attempt to get data for this level, allowing for empty</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">data_k = hue_grouped.get_group(label_k)</span>
                <span class="s0">except </span><span class="s1">KeyError:</span>
                    <span class="s1">data_k = pd.Series([]</span><span class="s0">, </span><span class="s1">dtype=float)</span>

                <span class="s0">if </span><span class="s1">fixed_color </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">color = self.palette[k]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">color = fixed_color</span>

                <span class="s0">if </span><span class="s1">self._dropna:</span>
                    <span class="s1">data_k = utils.remove_na(data_k)</span>

                <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
                    <span class="s1">func(x=data_k</span><span class="s0">, </span><span class="s1">label=label_k</span><span class="s0">, </span><span class="s1">color=color</span><span class="s0">, </span><span class="s1">**plot_kwargs)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">func(data_k</span><span class="s0">, </span><span class="s1">label=label_k</span><span class="s0">, </span><span class="s1">color=color</span><span class="s0">, </span><span class="s1">**plot_kwargs)</span>

        <span class="s1">self._add_axis_labels()</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_map_bivariate(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Draw a bivariate plot on the indicated axes.&quot;&quot;&quot;</span>
        <span class="s4"># This is a hack to handle the fact that new distribution plots don't add</span>
        <span class="s4"># their artists onto the axes. This is probably superior in general, but</span>
        <span class="s4"># we'll need a better way to handle it in the axisgrid functions.</span>
        <span class="s0">from </span><span class="s1">.distributions </span><span class="s0">import </span><span class="s1">histplot</span><span class="s0">, </span><span class="s1">kdeplot</span>
        <span class="s0">if </span><span class="s1">func </span><span class="s0">is </span><span class="s1">histplot </span><span class="s0">or </span><span class="s1">func </span><span class="s0">is </span><span class="s1">kdeplot:</span>
            <span class="s1">self._extract_legend_handles = </span><span class="s0">True</span>

        <span class="s1">kws = kwargs.copy()  </span><span class="s4"># Use copy as we insert other kwargs</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">indices:</span>
            <span class="s1">x_var = self.x_vars[j]</span>
            <span class="s1">y_var = self.y_vars[i]</span>
            <span class="s1">ax = self.axes[i</span><span class="s0">, </span><span class="s1">j]</span>
            <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:  </span><span class="s4"># i.e. we are in corner mode</span>
                <span class="s0">continue</span>
            <span class="s1">self._plot_bivariate(x_var</span><span class="s0">, </span><span class="s1">y_var</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kws)</span>
        <span class="s1">self._add_axis_labels()</span>

        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">signature(func).parameters:</span>
            <span class="s1">self.hue_names = list(self._legend_data)</span>

    <span class="s0">def </span><span class="s1">_plot_bivariate(self</span><span class="s0">, </span><span class="s1">x_var</span><span class="s0">, </span><span class="s1">y_var</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Draw a bivariate plot on the specified axes.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">not in </span><span class="s1">signature(func).parameters:</span>
            <span class="s1">self._plot_bivariate_iter_hue(x_var</span><span class="s0">, </span><span class="s1">y_var</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">return</span>

        <span class="s1">kwargs = kwargs.copy()</span>
        <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;ax&quot;</span><span class="s1">] = ax</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">plt.sca(ax)</span>

        <span class="s0">if </span><span class="s1">x_var == y_var:</span>
            <span class="s1">axes_vars = [x_var]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes_vars = [x_var</span><span class="s0">, </span><span class="s1">y_var]</span>

        <span class="s0">if </span><span class="s1">self._hue_var </span><span class="s0">is not None and </span><span class="s1">self._hue_var </span><span class="s0">not in </span><span class="s1">axes_vars:</span>
            <span class="s1">axes_vars.append(self._hue_var)</span>

        <span class="s1">data = self.data[axes_vars]</span>
        <span class="s0">if </span><span class="s1">self._dropna:</span>
            <span class="s1">data = data.dropna()</span>

        <span class="s1">x = data[x_var]</span>
        <span class="s1">y = data[y_var]</span>
        <span class="s0">if </span><span class="s1">self._hue_var </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">hue = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hue = data.get(self._hue_var)</span>

        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">not in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs.update({</span>
                <span class="s2">&quot;hue&quot;</span><span class="s1">: hue</span><span class="s0">, </span><span class="s2">&quot;hue_order&quot;</span><span class="s1">: self._hue_order</span><span class="s0">, </span><span class="s2">&quot;palette&quot;</span><span class="s1">: self._orig_palette</span><span class="s0">,</span>
            <span class="s1">})</span>
        <span class="s1">func(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">self._update_legend_data(ax)</span>

    <span class="s0">def </span><span class="s1">_plot_bivariate_iter_hue(self</span><span class="s0">, </span><span class="s1">x_var</span><span class="s0">, </span><span class="s1">y_var</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Draw a bivariate plot while iterating over hue subsets.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = kwargs.copy()</span>
        <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;ax&quot;</span><span class="s1">] = ax</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">plt.sca(ax)</span>

        <span class="s0">if </span><span class="s1">x_var == y_var:</span>
            <span class="s1">axes_vars = [x_var]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes_vars = [x_var</span><span class="s0">, </span><span class="s1">y_var]</span>

        <span class="s1">hue_grouped = self.data.groupby(self.hue_vals</span><span class="s0">, </span><span class="s1">observed=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">label_k </span><span class="s0">in </span><span class="s1">enumerate(self._hue_order):</span>

            <span class="s1">kws = kwargs.copy()</span>

            <span class="s4"># Attempt to get data for this level, allowing for empty</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">data_k = hue_grouped.get_group(label_k)</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s1">data_k = pd.DataFrame(columns=axes_vars</span><span class="s0">,</span>
                                      <span class="s1">dtype=float)</span>

            <span class="s0">if </span><span class="s1">self._dropna:</span>
                <span class="s1">data_k = data_k[axes_vars].dropna()</span>

            <span class="s1">x = data_k[x_var]</span>
            <span class="s1">y = data_k[y_var]</span>

            <span class="s0">for </span><span class="s1">kw</span><span class="s0">, </span><span class="s1">val_list </span><span class="s0">in </span><span class="s1">self.hue_kws.items():</span>
                <span class="s1">kws[kw] = val_list[k]</span>
            <span class="s1">kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">self.palette[k])</span>
            <span class="s0">if </span><span class="s1">self._hue_var </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">kws[</span><span class="s2">&quot;label&quot;</span><span class="s1">] = label_k</span>

            <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
                <span class="s1">func(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">**kws)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">func(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">**kws)</span>

        <span class="s1">self._update_legend_data(ax)</span>

    <span class="s0">def </span><span class="s1">_add_axis_labels(self):</span>
        <span class="s3">&quot;&quot;&quot;Add labels to the left and bottom Axes.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">label </span><span class="s0">in </span><span class="s1">zip(self.axes[-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">self.x_vars):</span>
            <span class="s1">ax.set_xlabel(label)</span>
        <span class="s0">for </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">label </span><span class="s0">in </span><span class="s1">zip(self.axes[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.y_vars):</span>
            <span class="s1">ax.set_ylabel(label)</span>

    <span class="s0">def </span><span class="s1">_find_numeric_cols(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s3">&quot;&quot;&quot;Find which variables in a DataFrame are numeric.&quot;&quot;&quot;</span>
        <span class="s1">numeric_cols = []</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">data:</span>
            <span class="s0">if </span><span class="s1">variable_type(data[col]) == </span><span class="s2">&quot;numeric&quot;</span><span class="s1">:</span>
                <span class="s1">numeric_cols.append(col)</span>
        <span class="s0">return </span><span class="s1">numeric_cols</span>


<span class="s0">class </span><span class="s1">JointGrid(_BaseGrid):</span>
    <span class="s3">&quot;&quot;&quot;Grid for drawing a bivariate plot with marginal univariate plots. 
 
    Many plots can be drawn by using the figure-level interface :func:`jointplot`. 
    Use this class directly when you need more flexibility. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
        <span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None,</span>
        <span class="s1">height=</span><span class="s5">6</span><span class="s0">, </span><span class="s1">ratio=</span><span class="s5">5</span><span class="s0">, </span><span class="s1">space=</span><span class="s5">.2</span><span class="s0">,</span>
        <span class="s1">palette=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">hue_norm=</span><span class="s0">None,</span>
        <span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">xlim=</span><span class="s0">None, </span><span class="s1">ylim=</span><span class="s0">None, </span><span class="s1">marginal_ticks=</span><span class="s0">False,</span>
    <span class="s1">):</span>

        <span class="s4"># Set up the subplot grid</span>
        <span class="s1">f = plt.figure(figsize=(height</span><span class="s0">, </span><span class="s1">height))</span>
        <span class="s1">gs = plt.GridSpec(ratio + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">ratio + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">ax_joint = f.add_subplot(gs[</span><span class="s5">1</span><span class="s1">:</span><span class="s0">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">ax_marg_x = f.add_subplot(gs[</span><span class="s5">0</span><span class="s0">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sharex=ax_joint)</span>
        <span class="s1">ax_marg_y = f.add_subplot(gs[</span><span class="s5">1</span><span class="s1">:</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sharey=ax_joint)</span>

        <span class="s1">self._figure = f</span>
        <span class="s1">self.ax_joint = ax_joint</span>
        <span class="s1">self.ax_marg_x = ax_marg_x</span>
        <span class="s1">self.ax_marg_y = ax_marg_y</span>

        <span class="s4"># Turn off tick visibility for the measure axis on the marginal plots</span>
        <span class="s1">plt.setp(ax_marg_x.get_xticklabels()</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">plt.setp(ax_marg_y.get_yticklabels()</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">plt.setp(ax_marg_x.get_xticklabels(minor=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">plt.setp(ax_marg_y.get_yticklabels(minor=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s4"># Turn off the ticks on the density axis for the marginal plots</span>
        <span class="s0">if not </span><span class="s1">marginal_ticks:</span>
            <span class="s1">plt.setp(ax_marg_x.yaxis.get_majorticklines()</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">plt.setp(ax_marg_x.yaxis.get_minorticklines()</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">plt.setp(ax_marg_y.xaxis.get_majorticklines()</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">plt.setp(ax_marg_y.xaxis.get_minorticklines()</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">plt.setp(ax_marg_x.get_yticklabels()</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">plt.setp(ax_marg_y.get_xticklabels()</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">plt.setp(ax_marg_x.get_yticklabels(minor=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">plt.setp(ax_marg_y.get_xticklabels(minor=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">ax_marg_x.yaxis.grid(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">ax_marg_y.xaxis.grid(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s4"># Process the input variables</span>
        <span class="s1">p = VectorPlotter(data=data</span><span class="s0">, </span><span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue))</span>
        <span class="s1">plot_data = p.plot_data.loc[:</span><span class="s0">, </span><span class="s1">p.plot_data.notna().any()]</span>

        <span class="s4"># Possibly drop NA</span>
        <span class="s0">if </span><span class="s1">dropna:</span>
            <span class="s1">plot_data = plot_data.dropna()</span>

        <span class="s0">def </span><span class="s1">get_var(var):</span>
            <span class="s1">vector = plot_data.get(var</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">vector </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">vector = vector.rename(p.variables.get(var</span><span class="s0">, None</span><span class="s1">))</span>
            <span class="s0">return </span><span class="s1">vector</span>

        <span class="s1">self.x = get_var(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">self.y = get_var(</span><span class="s2">&quot;y&quot;</span><span class="s1">)</span>
        <span class="s1">self.hue = get_var(</span><span class="s2">&quot;hue&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s2">&quot;xy&quot;</span><span class="s1">:</span>
            <span class="s1">name = p.variables.get(axis</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">getattr(ax_joint</span><span class="s0">, </span><span class="s2">f&quot;set_</span><span class="s0">{</span><span class="s1">axis</span><span class="s0">}</span><span class="s2">label&quot;</span><span class="s1">)(name)</span>

        <span class="s0">if </span><span class="s1">xlim </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">ax_joint.set_xlim(xlim)</span>
        <span class="s0">if </span><span class="s1">ylim </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">ax_joint.set_ylim(ylim)</span>

        <span class="s4"># Store the semantic mapping parameters for axes-level functions</span>
        <span class="s1">self._hue_params = dict(palette=palette</span><span class="s0">, </span><span class="s1">hue_order=hue_order</span><span class="s0">, </span><span class="s1">hue_norm=hue_norm)</span>

        <span class="s4"># Make the grid look nice</span>
        <span class="s1">utils.despine(f)</span>
        <span class="s0">if not </span><span class="s1">marginal_ticks:</span>
            <span class="s1">utils.despine(ax=ax_marg_x</span><span class="s0">, </span><span class="s1">left=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">utils.despine(ax=ax_marg_y</span><span class="s0">, </span><span class="s1">bottom=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">axes </span><span class="s0">in </span><span class="s1">[ax_marg_x</span><span class="s0">, </span><span class="s1">ax_marg_y]:</span>
            <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[axes.xaxis</span><span class="s0">, </span><span class="s1">axes.yaxis]:</span>
                <span class="s1">axis.label.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">f.tight_layout()</span>
        <span class="s1">f.subplots_adjust(hspace=space</span><span class="s0">, </span><span class="s1">wspace=space)</span>

    <span class="s0">def </span><span class="s1">_inject_kwargs(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">kws</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s3">&quot;&quot;&quot;Add params to kws if they are accepted by func.&quot;&quot;&quot;</span>
        <span class="s1">func_params = signature(func).parameters</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">params.items():</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">func_params:</span>
                <span class="s1">kws.setdefault(key</span><span class="s0">, </span><span class="s1">val)</span>

    <span class="s0">def </span><span class="s1">plot(self</span><span class="s0">, </span><span class="s1">joint_func</span><span class="s0">, </span><span class="s1">marginal_func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Draw the plot by passing functions for joint and marginal axes. 
 
        This method passes the ``kwargs`` dictionary to both functions. If you 
        need more control, call :meth:`JointGrid.plot_joint` and 
        :meth:`JointGrid.plot_marginals` directly with specific parameters. 
 
        Parameters 
        ---------- 
        joint_func, marginal_func : callables 
            Functions to draw the bivariate and univariate plots. See methods 
            referenced above for information about the required characteristics 
            of these functions. 
        kwargs 
            Additional keyword arguments are passed to both functions. 
 
        Returns 
        ------- 
        :class:`JointGrid` instance 
            Returns ``self`` for easy method chaining. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.plot_marginals(marginal_func</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.plot_joint(joint_func</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">plot_joint(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Draw a bivariate plot on the joint axes of the grid. 
 
        Parameters 
        ---------- 
        func : plotting callable 
            If a seaborn function, it should accept ``x`` and ``y``. Otherwise, 
            it must accept ``x`` and ``y`` vectors of data as the first two 
            positional arguments, and it must plot on the &quot;current&quot; axes. 
            If ``hue`` was defined in the class constructor, the function must 
            accept ``hue`` as a parameter. 
        kwargs 
            Keyword argument are passed to the plotting function. 
 
        Returns 
        ------- 
        :class:`JointGrid` instance 
            Returns ``self`` for easy method chaining. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs = kwargs.copy()</span>
        <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;ax&quot;</span><span class="s1">] = self.ax_joint</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">plt.sca(self.ax_joint)</span>
        <span class="s0">if </span><span class="s1">self.hue </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] = self.hue</span>
            <span class="s1">self._inject_kwargs(func</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">self._hue_params)</span>

        <span class="s0">if </span><span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">):</span>
            <span class="s1">func(x=self.x</span><span class="s0">, </span><span class="s1">y=self.y</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">func(self.x</span><span class="s0">, </span><span class="s1">self.y</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">plot_marginals(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Draw univariate plots on each marginal axes. 
 
        Parameters 
        ---------- 
        func : plotting callable 
            If a seaborn function, it should  accept ``x`` and ``y`` and plot 
            when only one of them is defined. Otherwise, it must accept a vector 
            of data as the first positional argument and determine its orientation 
            using the ``vertical`` parameter, and it must plot on the &quot;current&quot; axes. 
            If ``hue`` was defined in the class constructor, it must accept ``hue`` 
            as a parameter. 
        kwargs 
            Keyword argument are passed to the plotting function. 
 
        Returns 
        ------- 
        :class:`JointGrid` instance 
            Returns ``self`` for easy method chaining. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">seaborn_func = (</span>
            <span class="s1">str(func.__module__).startswith(</span><span class="s2">&quot;seaborn&quot;</span><span class="s1">)</span>
            <span class="s4"># deprecated distplot has a legacy API, special case it</span>
            <span class="s0">and not </span><span class="s1">func.__name__ == </span><span class="s2">&quot;distplot&quot;</span>
        <span class="s1">)</span>
        <span class="s1">func_params = signature(func).parameters</span>
        <span class="s1">kwargs = kwargs.copy()</span>
        <span class="s0">if </span><span class="s1">self.hue </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] = self.hue</span>
            <span class="s1">self._inject_kwargs(func</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">self._hue_params)</span>

        <span class="s0">if </span><span class="s2">&quot;legend&quot; </span><span class="s0">in </span><span class="s1">func_params:</span>
            <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;legend&quot;</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s2">&quot;orientation&quot; </span><span class="s0">in </span><span class="s1">func_params:</span>
            <span class="s4"># e.g. plt.hist</span>
            <span class="s1">orient_kw_x = {</span><span class="s2">&quot;orientation&quot;</span><span class="s1">: </span><span class="s2">&quot;vertical&quot;</span><span class="s1">}</span>
            <span class="s1">orient_kw_y = {</span><span class="s2">&quot;orientation&quot;</span><span class="s1">: </span><span class="s2">&quot;horizontal&quot;</span><span class="s1">}</span>
        <span class="s0">elif </span><span class="s2">&quot;vertical&quot; </span><span class="s0">in </span><span class="s1">func_params:</span>
            <span class="s4"># e.g. sns.distplot (also how did this get backwards?)</span>
            <span class="s1">orient_kw_x = {</span><span class="s2">&quot;vertical&quot;</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>
            <span class="s1">orient_kw_y = {</span><span class="s2">&quot;vertical&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>

        <span class="s0">if </span><span class="s1">seaborn_func:</span>
            <span class="s1">func(x=self.x</span><span class="s0">, </span><span class="s1">ax=self.ax_marg_x</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">plt.sca(self.ax_marg_x)</span>
            <span class="s1">func(self.x</span><span class="s0">, </span><span class="s1">**orient_kw_x</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">if </span><span class="s1">seaborn_func:</span>
            <span class="s1">func(y=self.y</span><span class="s0">, </span><span class="s1">ax=self.ax_marg_y</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">plt.sca(self.ax_marg_y)</span>
            <span class="s1">func(self.y</span><span class="s0">, </span><span class="s1">**orient_kw_y</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">self.ax_marg_x.yaxis.get_label().set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">self.ax_marg_y.xaxis.get_label().set_visible(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">refline(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">joint=</span><span class="s0">True, </span><span class="s1">marginal=</span><span class="s0">True,</span>
        <span class="s1">color=</span><span class="s2">'.5'</span><span class="s0">, </span><span class="s1">linestyle=</span><span class="s2">'--'</span><span class="s0">, </span><span class="s1">**line_kws</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Add a reference line(s) to joint and/or marginal axes. 
 
        Parameters 
        ---------- 
        x, y : numeric 
            Value(s) to draw the line(s) at. 
        joint, marginal : bools 
            Whether to add the reference line(s) to the joint/marginal axes. 
        color : :mod:`matplotlib color &lt;matplotlib.colors&gt;` 
            Specifies the color of the reference line(s). 
        linestyle : str 
            Specifies the style of the reference line(s). 
        line_kws : key, value mappings 
            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline` 
            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y`` 
            is not None. 
 
        Returns 
        ------- 
        :class:`JointGrid` instance 
            Returns ``self`` for easy method chaining. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">line_kws[</span><span class="s2">'color'</span><span class="s1">] = color</span>
        <span class="s1">line_kws[</span><span class="s2">'linestyle'</span><span class="s1">] = linestyle</span>

        <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">joint:</span>
                <span class="s1">self.ax_joint.axvline(x</span><span class="s0">, </span><span class="s1">**line_kws)</span>
            <span class="s0">if </span><span class="s1">marginal:</span>
                <span class="s1">self.ax_marg_x.axvline(x</span><span class="s0">, </span><span class="s1">**line_kws)</span>

        <span class="s0">if </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">joint:</span>
                <span class="s1">self.ax_joint.axhline(y</span><span class="s0">, </span><span class="s1">**line_kws)</span>
            <span class="s0">if </span><span class="s1">marginal:</span>
                <span class="s1">self.ax_marg_y.axhline(y</span><span class="s0">, </span><span class="s1">**line_kws)</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">set_axis_labels(self</span><span class="s0">, </span><span class="s1">xlabel=</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">ylabel=</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot;Set axis labels on the bivariate axes. 
 
        Parameters 
        ---------- 
        xlabel, ylabel : strings 
            Label names for the x and y variables. 
        kwargs : key, value mappings 
            Other keyword arguments are passed to the following functions: 
 
            - :meth:`matplotlib.axes.Axes.set_xlabel` 
            - :meth:`matplotlib.axes.Axes.set_ylabel` 
 
        Returns 
        ------- 
        :class:`JointGrid` instance 
            Returns ``self`` for easy method chaining. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ax_joint.set_xlabel(xlabel</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.ax_joint.set_ylabel(ylabel</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s1">JointGrid.__init__.__doc__ = </span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s2">Set up the grid of subplots and store data internally for easy plotting. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
height : number 
    Size of each side of the figure in inches (it will be square). 
ratio : number 
    Ratio of joint axes height to marginal axes height. 
space : number 
    Space between the joint and marginal axes 
dropna : bool 
    If True, remove missing observations before plotting. 
{{x, y}}lim : pairs of numbers 
    Set axis limits to these values before plotting. 
marginal_ticks : bool 
    If False, suppress ticks on the count/density axis of the marginal plots. 
{params.core.hue} 
    Note: unlike in :class:`FacetGrid` or :class:`PairGrid`, the axes-level 
    functions must support ``hue`` to use it in :class:`JointGrid`. 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
 
See Also 
-------- 
{seealso.jointplot} 
{seealso.pairgrid} 
{seealso.pairplot} 
 
Examples 
-------- 
 
.. include:: ../docstrings/JointGrid.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">params=_param_docs</span><span class="s0">,</span>
    <span class="s1">seealso=_core_docs[</span><span class="s2">&quot;seealso&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">pairplot(</span>
    <span class="s1">data</span><span class="s0">, </span><span class="s1">*</span><span class="s0">,</span>
    <span class="s1">hue=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None,</span>
    <span class="s1">vars=</span><span class="s0">None, </span><span class="s1">x_vars=</span><span class="s0">None, </span><span class="s1">y_vars=</span><span class="s0">None,</span>
    <span class="s1">kind=</span><span class="s2">&quot;scatter&quot;</span><span class="s0">, </span><span class="s1">diag_kind=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">markers=</span><span class="s0">None,</span>
    <span class="s1">height=</span><span class="s5">2.5</span><span class="s0">, </span><span class="s1">aspect=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">corner=</span><span class="s0">False, </span><span class="s1">dropna=</span><span class="s0">False,</span>
    <span class="s1">plot_kws=</span><span class="s0">None, </span><span class="s1">diag_kws=</span><span class="s0">None, </span><span class="s1">grid_kws=</span><span class="s0">None, </span><span class="s1">size=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Plot pairwise relationships in a dataset. 
 
    By default, this function will create a grid of Axes such that each numeric 
    variable in ``data`` will by shared across the y-axes across a single row and 
    the x-axes across a single column. The diagonal plots are treated 
    differently: a univariate distribution plot is drawn to show the marginal 
    distribution of the data in each column. 
 
    It is also possible to show a subset of variables or plot different 
    variables on the rows and columns. 
 
    This is a high-level interface for :class:`PairGrid` that is intended to 
    make it easy to draw a few common styles. You should use :class:`PairGrid` 
    directly if you need more flexibility. 
 
    Parameters 
    ---------- 
    data : `pandas.DataFrame` 
        Tidy (long-form) dataframe where each column is a variable and 
        each row is an observation. 
    hue : name of variable in ``data`` 
        Variable in ``data`` to map plot aspects to different colors. 
    hue_order : list of strings 
        Order for the levels of the hue variable in the palette 
    palette : dict or seaborn color palette 
        Set of colors for mapping the ``hue`` variable. If a dict, keys 
        should be values  in the ``hue`` variable. 
    vars : list of variable names 
        Variables within ``data`` to use, otherwise use every column with 
        a numeric datatype. 
    {x, y}_vars : lists of variable names 
        Variables within ``data`` to use separately for the rows and 
        columns of the figure; i.e. to make a non-square plot. 
    kind : {'scatter', 'kde', 'hist', 'reg'} 
        Kind of plot to make. 
    diag_kind : {'auto', 'hist', 'kde', None} 
        Kind of plot for the diagonal subplots. If 'auto', choose based on 
        whether or not ``hue`` is used. 
    markers : single matplotlib marker code or list 
        Either the marker to use for all scatterplot points or a list of markers 
        with a length the same as the number of levels in the hue variable so that 
        differently colored points will also have different scatterplot 
        markers. 
    height : scalar 
        Height (in inches) of each facet. 
    aspect : scalar 
        Aspect * height gives the width (in inches) of each facet. 
    corner : bool 
        If True, don't add axes to the upper (off-diagonal) triangle of the 
        grid, making this a &quot;corner&quot; plot. 
    dropna : boolean 
        Drop missing values from the data before plotting. 
    {plot, diag, grid}_kws : dicts 
        Dictionaries of keyword arguments. ``plot_kws`` are passed to the 
        bivariate plotting function, ``diag_kws`` are passed to the univariate 
        plotting function, and ``grid_kws`` are passed to the :class:`PairGrid` 
        constructor. 
 
    Returns 
    ------- 
    grid : :class:`PairGrid` 
        Returns the underlying :class:`PairGrid` instance for further tweaking. 
 
    See Also 
    -------- 
    PairGrid : Subplot grid for more flexible plotting of pairwise relationships. 
    JointGrid : Grid for plotting joint and marginal distributions of two variables. 
 
    Examples 
    -------- 
 
    .. include:: ../docstrings/pairplot.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># Avoid circular import</span>
    <span class="s0">from </span><span class="s1">.distributions </span><span class="s0">import </span><span class="s1">histplot</span><span class="s0">, </span><span class="s1">kdeplot</span>

    <span class="s4"># Handle deprecations</span>
    <span class="s0">if </span><span class="s1">size </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">height = size</span>
        <span class="s1">msg = (</span><span class="s2">&quot;The `size` parameter has been renamed to `height`; &quot;</span>
               <span class="s2">&quot;please update your code.&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">UserWarning)</span>

    <span class="s0">if not </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">pd.DataFrame):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s2">f&quot;'data' must be pandas DataFrame object, not: </span><span class="s0">{</span><span class="s1">type(data)</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s1">plot_kws = {} </span><span class="s0">if </span><span class="s1">plot_kws </span><span class="s0">is None else </span><span class="s1">plot_kws.copy()</span>
    <span class="s1">diag_kws = {} </span><span class="s0">if </span><span class="s1">diag_kws </span><span class="s0">is None else </span><span class="s1">diag_kws.copy()</span>
    <span class="s1">grid_kws = {} </span><span class="s0">if </span><span class="s1">grid_kws </span><span class="s0">is None else </span><span class="s1">grid_kws.copy()</span>

    <span class="s4"># Resolve &quot;auto&quot; diag kind</span>
    <span class="s0">if </span><span class="s1">diag_kind == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">hue </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">diag_kind = </span><span class="s2">&quot;kde&quot; </span><span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;kde&quot; </span><span class="s0">else </span><span class="s2">&quot;hist&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">diag_kind = </span><span class="s2">&quot;hist&quot; </span><span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;hist&quot; </span><span class="s0">else </span><span class="s2">&quot;kde&quot;</span>

    <span class="s4"># Set up the PairGrid</span>
    <span class="s1">grid_kws.setdefault(</span><span class="s2">&quot;diag_sharey&quot;</span><span class="s0">, </span><span class="s1">diag_kind == </span><span class="s2">&quot;hist&quot;</span><span class="s1">)</span>
    <span class="s1">grid = PairGrid(data</span><span class="s0">, </span><span class="s1">vars=vars</span><span class="s0">, </span><span class="s1">x_vars=x_vars</span><span class="s0">, </span><span class="s1">y_vars=y_vars</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">,</span>
                    <span class="s1">hue_order=hue_order</span><span class="s0">, </span><span class="s1">palette=palette</span><span class="s0">, </span><span class="s1">corner=corner</span><span class="s0">,</span>
                    <span class="s1">height=height</span><span class="s0">, </span><span class="s1">aspect=aspect</span><span class="s0">, </span><span class="s1">dropna=dropna</span><span class="s0">, </span><span class="s1">**grid_kws)</span>

    <span class="s4"># Add the markers here as PairGrid has figured out how many levels of the</span>
    <span class="s4"># hue variable are needed and we don't want to duplicate that process</span>
    <span class="s0">if </span><span class="s1">markers </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;reg&quot;</span><span class="s1">:</span>
            <span class="s4"># Needed until regplot supports style</span>
            <span class="s0">if </span><span class="s1">grid.hue_names </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">n_markers = </span><span class="s5">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">n_markers = len(grid.hue_names)</span>
            <span class="s0">if not </span><span class="s1">isinstance(markers</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">markers = [markers] * n_markers</span>
            <span class="s0">if </span><span class="s1">len(markers) != n_markers:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;markers must be a singleton or a list of &quot;</span>
                                 <span class="s2">&quot;markers for each level of the hue variable&quot;</span><span class="s1">)</span>
            <span class="s1">grid.hue_kws = {</span><span class="s2">&quot;marker&quot;</span><span class="s1">: markers}</span>
        <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;scatter&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(markers</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">plot_kws[</span><span class="s2">&quot;marker&quot;</span><span class="s1">] = markers</span>
            <span class="s0">elif </span><span class="s1">hue </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">plot_kws[</span><span class="s2">&quot;style&quot;</span><span class="s1">] = data[hue]</span>
                <span class="s1">plot_kws[</span><span class="s2">&quot;markers&quot;</span><span class="s1">] = markers</span>

    <span class="s4"># Draw the marginal plots on the diagonal</span>
    <span class="s1">diag_kws = diag_kws.copy()</span>
    <span class="s1">diag_kws.setdefault(</span><span class="s2">&quot;legend&quot;</span><span class="s0">, False</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">diag_kind == </span><span class="s2">&quot;hist&quot;</span><span class="s1">:</span>
        <span class="s1">grid.map_diag(histplot</span><span class="s0">, </span><span class="s1">**diag_kws)</span>
    <span class="s0">elif </span><span class="s1">diag_kind == </span><span class="s2">&quot;kde&quot;</span><span class="s1">:</span>
        <span class="s1">diag_kws.setdefault(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">diag_kws.setdefault(</span><span class="s2">&quot;warn_singular&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">grid.map_diag(kdeplot</span><span class="s0">, </span><span class="s1">**diag_kws)</span>

    <span class="s4"># Maybe plot on the off-diagonals</span>
    <span class="s0">if </span><span class="s1">diag_kind </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">plotter = grid.map_offdiag</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">plotter = grid.map</span>

    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;scatter&quot;</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">.relational </span><span class="s0">import </span><span class="s1">scatterplot  </span><span class="s4"># Avoid circular import</span>
        <span class="s1">plotter(scatterplot</span><span class="s0">, </span><span class="s1">**plot_kws)</span>
    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;reg&quot;</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">.regression </span><span class="s0">import </span><span class="s1">regplot  </span><span class="s4"># Avoid circular import</span>
        <span class="s1">plotter(regplot</span><span class="s0">, </span><span class="s1">**plot_kws)</span>
    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;kde&quot;</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">.distributions </span><span class="s0">import </span><span class="s1">kdeplot  </span><span class="s4"># Avoid circular import</span>
        <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;warn_singular&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">plotter(kdeplot</span><span class="s0">, </span><span class="s1">**plot_kws)</span>
    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;hist&quot;</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">.distributions </span><span class="s0">import </span><span class="s1">histplot  </span><span class="s4"># Avoid circular import</span>
        <span class="s1">plotter(histplot</span><span class="s0">, </span><span class="s1">**plot_kws)</span>

    <span class="s4"># Add a legend</span>
    <span class="s0">if </span><span class="s1">hue </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">grid.add_legend()</span>

    <span class="s1">grid.tight_layout()</span>

    <span class="s0">return </span><span class="s1">grid</span>


<span class="s0">def </span><span class="s1">jointplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">kind=</span><span class="s2">&quot;scatter&quot;</span><span class="s0">,</span>
    <span class="s1">height=</span><span class="s5">6</span><span class="s0">, </span><span class="s1">ratio=</span><span class="s5">5</span><span class="s0">, </span><span class="s1">space=</span><span class="s5">.2</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">xlim=</span><span class="s0">None, </span><span class="s1">ylim=</span><span class="s0">None,</span>
    <span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">hue_norm=</span><span class="s0">None, </span><span class="s1">marginal_ticks=</span><span class="s0">False,</span>
    <span class="s1">joint_kws=</span><span class="s0">None, </span><span class="s1">marginal_kws=</span><span class="s0">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s4"># Avoid circular imports</span>
    <span class="s0">from </span><span class="s1">.relational </span><span class="s0">import </span><span class="s1">scatterplot</span>
    <span class="s0">from </span><span class="s1">.regression </span><span class="s0">import </span><span class="s1">regplot</span><span class="s0">, </span><span class="s1">residplot</span>
    <span class="s0">from </span><span class="s1">.distributions </span><span class="s0">import </span><span class="s1">histplot</span><span class="s0">, </span><span class="s1">kdeplot</span><span class="s0">, </span><span class="s1">_freedman_diaconis_bins</span>

    <span class="s0">if </span><span class="s1">kwargs.pop(</span><span class="s2">&quot;ax&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s2">&quot;Ignoring `ax`; jointplot is a figure-level function.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">UserWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s4"># Set up empty default kwarg dicts</span>
    <span class="s1">joint_kws = {} </span><span class="s0">if </span><span class="s1">joint_kws </span><span class="s0">is None else </span><span class="s1">joint_kws.copy()</span>
    <span class="s1">joint_kws.update(kwargs)</span>
    <span class="s1">marginal_kws = {} </span><span class="s0">if </span><span class="s1">marginal_kws </span><span class="s0">is None else </span><span class="s1">marginal_kws.copy()</span>

    <span class="s4"># Handle deprecations of distplot-specific kwargs</span>
    <span class="s1">distplot_keys = [</span>
        <span class="s2">&quot;rug&quot;</span><span class="s0">, </span><span class="s2">&quot;fit&quot;</span><span class="s0">, </span><span class="s2">&quot;hist_kws&quot;</span><span class="s0">, </span><span class="s2">&quot;norm_hist&quot; &quot;hist_kws&quot;</span><span class="s0">, </span><span class="s2">&quot;rug_kws&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">unused_keys = []</span>
    <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">distplot_keys:</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">marginal_kws:</span>
            <span class="s1">unused_keys.append(key)</span>
            <span class="s1">marginal_kws.pop(key)</span>
    <span class="s0">if </span><span class="s1">unused_keys </span><span class="s0">and </span><span class="s1">kind != </span><span class="s2">&quot;kde&quot;</span><span class="s1">:</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;The marginal plotting function has changed to `histplot`,&quot;</span>
            <span class="s2">&quot; which does not accept the following argument(s): {}.&quot;</span>
        <span class="s1">).format(</span><span class="s2">&quot;, &quot;</span><span class="s1">.join(unused_keys))</span>
        <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">UserWarning)</span>

    <span class="s4"># Validate the plot kind</span>
    <span class="s1">plot_kinds = [</span><span class="s2">&quot;scatter&quot;</span><span class="s0">, </span><span class="s2">&quot;hist&quot;</span><span class="s0">, </span><span class="s2">&quot;hex&quot;</span><span class="s0">, </span><span class="s2">&quot;kde&quot;</span><span class="s0">, </span><span class="s2">&quot;reg&quot;</span><span class="s0">, </span><span class="s2">&quot;resid&quot;</span><span class="s1">]</span>
    <span class="s1">_check_argument(</span><span class="s2">&quot;kind&quot;</span><span class="s0">, </span><span class="s1">plot_kinds</span><span class="s0">, </span><span class="s1">kind)</span>

    <span class="s4"># Raise early if using `hue` with a kind that does not support it</span>
    <span class="s0">if </span><span class="s1">hue </span><span class="s0">is not None and </span><span class="s1">kind </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;hex&quot;</span><span class="s0">, </span><span class="s2">&quot;reg&quot;</span><span class="s0">, </span><span class="s2">&quot;resid&quot;</span><span class="s1">]:</span>
        <span class="s1">msg = </span><span class="s2">f&quot;Use of `hue` with `kind='</span><span class="s0">{</span><span class="s1">kind</span><span class="s0">}</span><span class="s2">'` is not currently supported.&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s4"># Make a colormap based off the plot color</span>
    <span class="s4"># (Currently used only for kind=&quot;hex&quot;)</span>
    <span class="s0">if </span><span class="s1">color </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">color = </span><span class="s2">&quot;C0&quot;</span>
    <span class="s1">color_rgb = mpl.colors.colorConverter.to_rgb(color)</span>
    <span class="s1">colors = [set_hls_values(color_rgb</span><span class="s0">, </span><span class="s1">l=val) </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">np.linspace(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">12</span><span class="s1">)]</span>
    <span class="s1">cmap = blend_palette(colors</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s4"># Matplotlib's hexbin plot is not na-robust</span>
    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;hex&quot;</span><span class="s1">:</span>
        <span class="s1">dropna = </span><span class="s0">True</span>

    <span class="s4"># Initialize the JointGrid object</span>
    <span class="s1">grid = JointGrid(</span>
        <span class="s1">data=data</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">,</span>
        <span class="s1">palette=palette</span><span class="s0">, </span><span class="s1">hue_order=hue_order</span><span class="s0">, </span><span class="s1">hue_norm=hue_norm</span><span class="s0">,</span>
        <span class="s1">dropna=dropna</span><span class="s0">, </span><span class="s1">height=height</span><span class="s0">, </span><span class="s1">ratio=ratio</span><span class="s0">, </span><span class="s1">space=space</span><span class="s0">,</span>
        <span class="s1">xlim=xlim</span><span class="s0">, </span><span class="s1">ylim=ylim</span><span class="s0">, </span><span class="s1">marginal_ticks=marginal_ticks</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">grid.hue </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;legend&quot;</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s4"># Plot the data using the grid</span>
    <span class="s0">if </span><span class="s1">kind.startswith(</span><span class="s2">&quot;scatter&quot;</span><span class="s1">):</span>

        <span class="s1">joint_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">grid.plot_joint(scatterplot</span><span class="s0">, </span><span class="s1">**joint_kws)</span>

        <span class="s0">if </span><span class="s1">grid.hue </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">marg_func = histplot</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">marg_func = kdeplot</span>
            <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;warn_singular&quot;</span><span class="s0">, False</span><span class="s1">)</span>
            <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">grid.plot_marginals(marg_func</span><span class="s0">, </span><span class="s1">**marginal_kws)</span>

    <span class="s0">elif </span><span class="s1">kind.startswith(</span><span class="s2">&quot;hist&quot;</span><span class="s1">):</span>

        <span class="s4"># TODO process pair parameters for bins, etc. and pass</span>
        <span class="s4"># to both joint and marginal plots</span>

        <span class="s1">joint_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">grid.plot_joint(histplot</span><span class="s0">, </span><span class="s1">**joint_kws)</span>

        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;kde&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s1">marg_x_kws = marginal_kws.copy()</span>
        <span class="s1">marg_y_kws = marginal_kws.copy()</span>

        <span class="s1">pair_keys = </span><span class="s2">&quot;bins&quot;</span><span class="s0">, </span><span class="s2">&quot;binwidth&quot;</span><span class="s0">, </span><span class="s2">&quot;binrange&quot;</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">pair_keys:</span>
            <span class="s0">if </span><span class="s1">isinstance(joint_kws.get(key)</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">x_val</span><span class="s0">, </span><span class="s1">y_val = joint_kws[key]</span>
                <span class="s1">marg_x_kws.setdefault(key</span><span class="s0">, </span><span class="s1">x_val)</span>
                <span class="s1">marg_y_kws.setdefault(key</span><span class="s0">, </span><span class="s1">y_val)</span>

        <span class="s1">histplot(data=data</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">**marg_x_kws</span><span class="s0">, </span><span class="s1">ax=grid.ax_marg_x)</span>
        <span class="s1">histplot(data=data</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">**marg_y_kws</span><span class="s0">, </span><span class="s1">ax=grid.ax_marg_y)</span>

    <span class="s0">elif </span><span class="s1">kind.startswith(</span><span class="s2">&quot;kde&quot;</span><span class="s1">):</span>

        <span class="s1">joint_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">joint_kws.setdefault(</span><span class="s2">&quot;warn_singular&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">grid.plot_joint(kdeplot</span><span class="s0">, </span><span class="s1">**joint_kws)</span>

        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s0">if </span><span class="s2">&quot;fill&quot; </span><span class="s0">in </span><span class="s1">joint_kws:</span>
            <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, </span><span class="s1">joint_kws[</span><span class="s2">&quot;fill&quot;</span><span class="s1">])</span>

        <span class="s1">grid.plot_marginals(kdeplot</span><span class="s0">, </span><span class="s1">**marginal_kws)</span>

    <span class="s0">elif </span><span class="s1">kind.startswith(</span><span class="s2">&quot;hex&quot;</span><span class="s1">):</span>

        <span class="s1">x_bins = min(_freedman_diaconis_bins(grid.x)</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">y_bins = min(_freedman_diaconis_bins(grid.y)</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">gridsize = int(np.mean([x_bins</span><span class="s0">, </span><span class="s1">y_bins]))</span>

        <span class="s1">joint_kws.setdefault(</span><span class="s2">&quot;gridsize&quot;</span><span class="s0">, </span><span class="s1">gridsize)</span>
        <span class="s1">joint_kws.setdefault(</span><span class="s2">&quot;cmap&quot;</span><span class="s0">, </span><span class="s1">cmap)</span>
        <span class="s1">grid.plot_joint(plt.hexbin</span><span class="s0">, </span><span class="s1">**joint_kws)</span>

        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;kde&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">grid.plot_marginals(histplot</span><span class="s0">, </span><span class="s1">**marginal_kws)</span>

    <span class="s0">elif </span><span class="s1">kind.startswith(</span><span class="s2">&quot;reg&quot;</span><span class="s1">):</span>

        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;kde&quot;</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">grid.plot_marginals(histplot</span><span class="s0">, </span><span class="s1">**marginal_kws)</span>

        <span class="s1">joint_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">grid.plot_joint(regplot</span><span class="s0">, </span><span class="s1">**joint_kws)</span>

    <span class="s0">elif </span><span class="s1">kind.startswith(</span><span class="s2">&quot;resid&quot;</span><span class="s1">):</span>

        <span class="s1">joint_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">grid.plot_joint(residplot</span><span class="s0">, </span><span class="s1">**joint_kws)</span>

        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = grid.ax_joint.collections[</span><span class="s5">0</span><span class="s1">].get_offsets().T</span>
        <span class="s1">marginal_kws.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">color)</span>
        <span class="s1">histplot(x=x</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">ax=grid.ax_marg_x</span><span class="s0">, </span><span class="s1">**marginal_kws)</span>
        <span class="s1">histplot(y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">ax=grid.ax_marg_y</span><span class="s0">, </span><span class="s1">**marginal_kws)</span>

    <span class="s4"># Make the main axes active in the matplotlib state machine</span>
    <span class="s1">plt.sca(grid.ax_joint)</span>

    <span class="s0">return </span><span class="s1">grid</span>


<span class="s1">jointplot.__doc__ = </span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s2">Draw a plot of two variables with bivariate and univariate graphs. 
 
This function provides a convenient interface to the :class:`JointGrid` 
class, with several canned plot kinds. This is intended to be a fairly 
lightweight wrapper; if you need more flexibility, you should use 
:class:`JointGrid` directly. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
{params.core.hue} 
kind : {{ &quot;scatter&quot; | &quot;kde&quot; | &quot;hist&quot; | &quot;hex&quot; | &quot;reg&quot; | &quot;resid&quot; }} 
    Kind of plot to draw. See the examples for references to the underlying functions. 
height : numeric 
    Size of the figure (it will be square). 
ratio : numeric 
    Ratio of joint axes height to marginal axes height. 
space : numeric 
    Space between the joint and marginal axes 
dropna : bool 
    If True, remove observations that are missing from ``x`` and ``y``. 
{{x, y}}lim : pairs of numbers 
    Axis limits to set before plotting. 
{params.core.color} 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
marginal_ticks : bool 
    If False, suppress ticks on the count/density axis of the marginal plots. 
{{joint, marginal}}_kws : dicts 
    Additional keyword arguments for the plot components. 
kwargs 
    Additional keyword arguments are passed to the function used to 
    draw the plot on the joint Axes, superseding items in the 
    ``joint_kws`` dictionary. 
 
Returns 
------- 
{returns.jointgrid} 
 
See Also 
-------- 
{seealso.jointgrid} 
{seealso.pairgrid} 
{seealso.pairplot} 
 
Examples 
-------- 
 
.. include:: ../docstrings/jointplot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">params=_param_docs</span><span class="s0">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s2">&quot;returns&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">seealso=_core_docs[</span><span class="s2">&quot;seealso&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
</pre>
</body>
</html>