<html>
<head>
<title>test_minpack.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_minpack.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Unit tests for optimization routines from minpack.py. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_</span><span class="s2">, </span><span class="s1">assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_array_equal</span><span class="s2">,</span>
                           <span class="s1">assert_array_almost_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">,</span>
                           <span class="s1">assert_warns</span><span class="s2">, </span><span class="s1">suppress_warnings)</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">array</span><span class="s2">, </span><span class="s1">float64</span>
<span class="s2">from </span><span class="s1">multiprocessing.pool </span><span class="s2">import </span><span class="s1">ThreadPool</span>

<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">optimize</span><span class="s2">, </span><span class="s1">linalg</span>
<span class="s2">from </span><span class="s1">scipy.special </span><span class="s2">import </span><span class="s1">lambertw</span>
<span class="s2">from </span><span class="s1">scipy.optimize._minpack_py </span><span class="s2">import </span><span class="s1">leastsq</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, </span><span class="s1">fixed_point</span>
<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">OptimizeWarning</span>
<span class="s2">from </span><span class="s1">scipy.optimize._minimize </span><span class="s2">import </span><span class="s1">Bounds</span>


<span class="s2">class </span><span class="s1">ReturnShape:</span>
    <span class="s0">&quot;&quot;&quot;This class exists to create a callable that does not have a '__name__' attribute. 
 
    __init__ takes the argument 'shape', which should be a tuple of ints. When an instance 
    is called with a single argument 'x', it returns numpy.ones(shape). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">shape):</span>
        <span class="s1">self.shape = shape</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.ones(self.shape)</span>


<span class="s2">def </span><span class="s1">dummy_func(x</span><span class="s2">, </span><span class="s1">shape):</span>
    <span class="s0">&quot;&quot;&quot;A function that returns an array of ones of the given shape. 
    `x` is ignored. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np.ones(shape)</span>


<span class="s2">def </span><span class="s1">sequence_parallel(fs):</span>
    <span class="s2">with </span><span class="s1">ThreadPool(len(fs)) </span><span class="s2">as </span><span class="s1">pool:</span>
        <span class="s2">return </span><span class="s1">pool.map(</span><span class="s2">lambda </span><span class="s1">f: f()</span><span class="s2">, </span><span class="s1">fs)</span>


<span class="s3"># Function and Jacobian for tests of solvers for systems of nonlinear</span>
<span class="s3"># equations</span>


<span class="s2">def </span><span class="s1">pressure_network(flow_rates</span><span class="s2">, </span><span class="s1">Qtot</span><span class="s2">, </span><span class="s1">k):</span>
    <span class="s0">&quot;&quot;&quot;Evaluate non-linear equation system representing 
    the pressures and flows in a system of n parallel pipes:: 
 
        f_i = P_i - P_0, for i = 1..n 
        f_0 = sum(Q_i) - Qtot 
 
    where Q_i is the flow rate in pipe i and P_i the pressure in that pipe. 
    Pressure is modeled as a P=kQ**2 where k is a valve coefficient and 
    Q is the flow rate. 
 
    Parameters 
    ---------- 
    flow_rates : float 
        A 1-D array of n flow rates [kg/s]. 
    k : float 
        A 1-D array of n valve coefficients [1/kg m]. 
    Qtot : float 
        A scalar, the total input flow rate [kg/s]. 
 
    Returns 
    ------- 
    F : float 
        A 1-D array, F[i] == f_i. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">P = k * flow_rates**</span><span class="s4">2</span>
    <span class="s1">F = np.hstack((P[</span><span class="s4">1</span><span class="s1">:] - P[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">flow_rates.sum() - Qtot))</span>
    <span class="s2">return </span><span class="s1">F</span>


<span class="s2">def </span><span class="s1">pressure_network_jacobian(flow_rates</span><span class="s2">, </span><span class="s1">Qtot</span><span class="s2">, </span><span class="s1">k):</span>
    <span class="s0">&quot;&quot;&quot;Return the jacobian of the equation system F(flow_rates) 
    computed by `pressure_network` with respect to 
    *flow_rates*. See `pressure_network` for the detailed 
    description of parrameters. 
 
    Returns 
    ------- 
    jac : float 
        *n* by *n* matrix ``df_i/dQ_i`` where ``n = len(flow_rates)`` 
        and *f_i* and *Q_i* are described in the doc for `pressure_network` 
    &quot;&quot;&quot;</span>
    <span class="s1">n = len(flow_rates)</span>
    <span class="s1">pdiff = np.diag(flow_rates[</span><span class="s4">1</span><span class="s1">:] * </span><span class="s4">2 </span><span class="s1">* k[</span><span class="s4">1</span><span class="s1">:] - </span><span class="s4">2 </span><span class="s1">* flow_rates[</span><span class="s4">0</span><span class="s1">] * k[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">jac = np.empty((n</span><span class="s2">, </span><span class="s1">n))</span>
    <span class="s1">jac[:n-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:n-</span><span class="s4">1</span><span class="s1">] = pdiff * </span><span class="s4">0</span>
    <span class="s1">jac[:n-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">jac[n-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:] = np.ones(n)</span>

    <span class="s2">return </span><span class="s1">jac</span>


<span class="s2">def </span><span class="s1">pressure_network_fun_and_grad(flow_rates</span><span class="s2">, </span><span class="s1">Qtot</span><span class="s2">, </span><span class="s1">k):</span>
    <span class="s2">return </span><span class="s1">(pressure_network(flow_rates</span><span class="s2">, </span><span class="s1">Qtot</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">,</span>
            <span class="s1">pressure_network_jacobian(flow_rates</span><span class="s2">, </span><span class="s1">Qtot</span><span class="s2">, </span><span class="s1">k))</span>


<span class="s2">class </span><span class="s1">TestFSolve:</span>
    <span class="s2">def </span><span class="s1">test_pressure_network_no_gradient(self):</span>
        <span class="s3"># fsolve without gradient, equal pipes -&gt; equal flows.</span>
        <span class="s1">k = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">Qtot = </span><span class="s4">4</span>
        <span class="s1">initial_guess = array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">])</span>
        <span class="s1">final_flows</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">ier</span><span class="s2">, </span><span class="s1">mesg = optimize.fsolve(</span>
            <span class="s1">pressure_network</span><span class="s2">, </span><span class="s1">initial_guess</span><span class="s2">, </span><span class="s1">args=(Qtot</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">,</span>
            <span class="s1">full_output=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(final_flows</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">assert_(ier == </span><span class="s4">1</span><span class="s2">, </span><span class="s1">mesg)</span>

    <span class="s2">def </span><span class="s1">test_pressure_network_with_gradient(self):</span>
        <span class="s3"># fsolve with gradient, equal pipes -&gt; equal flows</span>
        <span class="s1">k = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">Qtot = </span><span class="s4">4</span>
        <span class="s1">initial_guess = array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">])</span>
        <span class="s1">final_flows = optimize.fsolve(</span>
            <span class="s1">pressure_network</span><span class="s2">, </span><span class="s1">initial_guess</span><span class="s2">, </span><span class="s1">args=(Qtot</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">,</span>
            <span class="s1">fprime=pressure_network_jacobian)</span>
        <span class="s1">assert_array_almost_equal(final_flows</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_wrong_shape_func_callable(self):</span>
        <span class="s1">func = ReturnShape(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3"># x0 is a list of two elements, but func will return an array with</span>
        <span class="s3"># length 1, so this should result in a TypeError.</span>
        <span class="s1">x0 = [</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">optimize.fsolve</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0)</span>

    <span class="s2">def </span><span class="s1">test_wrong_shape_func_function(self):</span>
        <span class="s3"># x0 is a list of two elements, but func will return an array with</span>
        <span class="s3"># length 1, so this should result in a TypeError.</span>
        <span class="s1">x0 = [</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">optimize.fsolve</span><span class="s2">, </span><span class="s1">dummy_func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args=((</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_wrong_shape_fprime_callable(self):</span>
        <span class="s1">func = ReturnShape(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">deriv_func = ReturnShape((</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">optimize.fsolve</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fprime=deriv_func)</span>

    <span class="s2">def </span><span class="s1">test_wrong_shape_fprime_function(self):</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">dummy_func(x</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">def </span><span class="s1">deriv_func(x):</span>
            <span class="s2">return </span><span class="s1">dummy_func(x</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">optimize.fsolve</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fprime=deriv_func)</span>

    <span class="s2">def </span><span class="s1">test_func_can_raise(self):</span>
        <span class="s2">def </span><span class="s1">func(*args):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'I raised'</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">'I raised'</span><span class="s1">):</span>
            <span class="s1">optimize.fsolve(func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_Dfun_can_raise(self):</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">x - np.array([</span><span class="s4">10</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">deriv_func(*args):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'I raised'</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">'I raised'</span><span class="s1">):</span>
            <span class="s1">optimize.fsolve(func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fprime=deriv_func)</span>

    <span class="s2">def </span><span class="s1">test_float32(self):</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">100</span><span class="s2">, </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1000</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.float32) ** </span><span class="s4">2</span>
        <span class="s1">p = optimize.fsolve(func</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.float32))</span>
        <span class="s1">assert_allclose(func(p)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_reentrant_func(self):</span>
        <span class="s2">def </span><span class="s1">func(*args):</span>
            <span class="s1">self.test_pressure_network_no_gradient()</span>
            <span class="s2">return </span><span class="s1">pressure_network(*args)</span>

        <span class="s3"># fsolve without gradient, equal pipes -&gt; equal flows.</span>
        <span class="s1">k = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">Qtot = </span><span class="s4">4</span>
        <span class="s1">initial_guess = array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">])</span>
        <span class="s1">final_flows</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">ier</span><span class="s2">, </span><span class="s1">mesg = optimize.fsolve(</span>
            <span class="s1">func</span><span class="s2">, </span><span class="s1">initial_guess</span><span class="s2">, </span><span class="s1">args=(Qtot</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">,</span>
            <span class="s1">full_output=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(final_flows</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">assert_(ier == </span><span class="s4">1</span><span class="s2">, </span><span class="s1">mesg)</span>

    <span class="s2">def </span><span class="s1">test_reentrant_Dfunc(self):</span>
        <span class="s2">def </span><span class="s1">deriv_func(*args):</span>
            <span class="s1">self.test_pressure_network_with_gradient()</span>
            <span class="s2">return </span><span class="s1">pressure_network_jacobian(*args)</span>

        <span class="s3"># fsolve with gradient, equal pipes -&gt; equal flows</span>
        <span class="s1">k = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">Qtot = </span><span class="s4">4</span>
        <span class="s1">initial_guess = array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">])</span>
        <span class="s1">final_flows = optimize.fsolve(</span>
            <span class="s1">pressure_network</span><span class="s2">, </span><span class="s1">initial_guess</span><span class="s2">, </span><span class="s1">args=(Qtot</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">,</span>
            <span class="s1">fprime=deriv_func)</span>
        <span class="s1">assert_array_almost_equal(final_flows</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_concurrent_no_gradient(self):</span>
        <span class="s1">v = sequence_parallel([self.test_pressure_network_no_gradient] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">all([result </span><span class="s2">is None for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">v])</span>

    <span class="s2">def </span><span class="s1">test_concurrent_with_gradient(self):</span>
        <span class="s1">v = sequence_parallel([self.test_pressure_network_with_gradient] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">all([result </span><span class="s2">is None for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">v])</span>


<span class="s2">class </span><span class="s1">TestRootHybr:</span>
    <span class="s2">def </span><span class="s1">test_pressure_network_no_gradient(self):</span>
        <span class="s3"># root/hybr without gradient, equal pipes -&gt; equal flows</span>
        <span class="s1">k = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">Qtot = </span><span class="s4">4</span>
        <span class="s1">initial_guess = array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">])</span>
        <span class="s1">final_flows = optimize.root(pressure_network</span><span class="s2">, </span><span class="s1">initial_guess</span><span class="s2">,</span>
                                    <span class="s1">method=</span><span class="s5">'hybr'</span><span class="s2">, </span><span class="s1">args=(Qtot</span><span class="s2">, </span><span class="s1">k)).x</span>
        <span class="s1">assert_array_almost_equal(final_flows</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_pressure_network_with_gradient(self):</span>
        <span class="s3"># root/hybr with gradient, equal pipes -&gt; equal flows</span>
        <span class="s1">k = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">Qtot = </span><span class="s4">4</span>
        <span class="s1">initial_guess = array([[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]])</span>
        <span class="s1">final_flows = optimize.root(pressure_network</span><span class="s2">, </span><span class="s1">initial_guess</span><span class="s2">,</span>
                                    <span class="s1">args=(Qtot</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'hybr'</span><span class="s2">,</span>
                                    <span class="s1">jac=pressure_network_jacobian).x</span>
        <span class="s1">assert_array_almost_equal(final_flows</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_pressure_network_with_gradient_combined(self):</span>
        <span class="s3"># root/hybr with gradient and function combined, equal pipes -&gt; equal</span>
        <span class="s3"># flows</span>
        <span class="s1">k = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">Qtot = </span><span class="s4">4</span>
        <span class="s1">initial_guess = array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">])</span>
        <span class="s1">final_flows = optimize.root(pressure_network_fun_and_grad</span><span class="s2">,</span>
                                    <span class="s1">initial_guess</span><span class="s2">, </span><span class="s1">args=(Qtot</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">,</span>
                                    <span class="s1">method=</span><span class="s5">'hybr'</span><span class="s2">, </span><span class="s1">jac=</span><span class="s2">True</span><span class="s1">).x</span>
        <span class="s1">assert_array_almost_equal(final_flows</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TestRootLM:</span>
    <span class="s2">def </span><span class="s1">test_pressure_network_no_gradient(self):</span>
        <span class="s3"># root/lm without gradient, equal pipes -&gt; equal flows</span>
        <span class="s1">k = np.full(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">Qtot = </span><span class="s4">4</span>
        <span class="s1">initial_guess = array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">])</span>
        <span class="s1">final_flows = optimize.root(pressure_network</span><span class="s2">, </span><span class="s1">initial_guess</span><span class="s2">,</span>
                                    <span class="s1">method=</span><span class="s5">'lm'</span><span class="s2">, </span><span class="s1">args=(Qtot</span><span class="s2">, </span><span class="s1">k)).x</span>
        <span class="s1">assert_array_almost_equal(final_flows</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">4</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TestLeastSq:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">40</span><span class="s1">)</span>
        <span class="s1">a</span><span class="s2">,</span><span class="s1">b</span><span class="s2">,</span><span class="s1">c = </span><span class="s4">3.1</span><span class="s2">, </span><span class="s4">42</span><span class="s2">, </span><span class="s1">-</span><span class="s4">304.2</span>
        <span class="s1">self.x = x</span>
        <span class="s1">self.abc = a</span><span class="s2">,</span><span class="s1">b</span><span class="s2">,</span><span class="s1">c</span>
        <span class="s1">y_true = a*x**</span><span class="s4">2 </span><span class="s1">+ b*x + c</span>
        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.y_meas = y_true + </span><span class="s4">0.01</span><span class="s1">*np.random.standard_normal(y_true.shape)</span>

    <span class="s2">def </span><span class="s1">residuals(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">a</span><span class="s2">,</span><span class="s1">b</span><span class="s2">,</span><span class="s1">c = p</span>
        <span class="s1">err = y-(a*x**</span><span class="s4">2 </span><span class="s1">+ b*x + c)</span>
        <span class="s2">return </span><span class="s1">err</span>

    <span class="s2">def </span><span class="s1">residuals_jacobian(self</span><span class="s2">, </span><span class="s1">_p</span><span class="s2">, </span><span class="s1">_y</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">-np.vstack([x**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">np.ones_like(x)]).T</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">p0 = array([</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">params_fit</span><span class="s2">, </span><span class="s1">ier = leastsq(self.residuals</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">,</span>
                                  <span class="s1">args=(self.y_meas</span><span class="s2">, </span><span class="s1">self.x))</span>
        <span class="s1">assert_(ier </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'solution not found (ier=%d)' </span><span class="s1">% ier)</span>
        <span class="s3"># low precision due to random</span>
        <span class="s1">assert_array_almost_equal(params_fit</span><span class="s2">, </span><span class="s1">self.abc</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_basic_with_gradient(self):</span>
        <span class="s1">p0 = array([</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">params_fit</span><span class="s2">, </span><span class="s1">ier = leastsq(self.residuals</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">,</span>
                                  <span class="s1">args=(self.y_meas</span><span class="s2">, </span><span class="s1">self.x)</span><span class="s2">,</span>
                                  <span class="s1">Dfun=self.residuals_jacobian)</span>
        <span class="s1">assert_(ier </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'solution not found (ier=%d)' </span><span class="s1">% ier)</span>
        <span class="s3"># low precision due to random</span>
        <span class="s1">assert_array_almost_equal(params_fit</span><span class="s2">, </span><span class="s1">self.abc</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_full_output(self):</span>
        <span class="s1">p0 = array([[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s1">full_output = leastsq(self.residuals</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">,</span>
                              <span class="s1">args=(self.y_meas</span><span class="s2">, </span><span class="s1">self.x)</span><span class="s2">,</span>
                              <span class="s1">full_output=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">params_fit</span><span class="s2">, </span><span class="s1">cov_x</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = full_output</span>
        <span class="s1">assert_(ier </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'solution not found: %s' </span><span class="s1">% mesg)</span>

    <span class="s2">def </span><span class="s1">test_input_untouched(self):</span>
        <span class="s1">p0 = array([</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span><span class="s1">dtype=float64)</span>
        <span class="s1">p0_copy = array(p0</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">full_output = leastsq(self.residuals</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">,</span>
                              <span class="s1">args=(self.y_meas</span><span class="s2">, </span><span class="s1">self.x)</span><span class="s2">,</span>
                              <span class="s1">full_output=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">params_fit</span><span class="s2">, </span><span class="s1">cov_x</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">ier = full_output</span>
        <span class="s1">assert_(ier </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'solution not found: %s' </span><span class="s1">% mesg)</span>
        <span class="s1">assert_array_equal(p0</span><span class="s2">, </span><span class="s1">p0_copy)</span>

    <span class="s2">def </span><span class="s1">test_wrong_shape_func_callable(self):</span>
        <span class="s1">func = ReturnShape(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3"># x0 is a list of two elements, but func will return an array with</span>
        <span class="s3"># length 1, so this should result in a TypeError.</span>
        <span class="s1">x0 = [</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">optimize.leastsq</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0)</span>

    <span class="s2">def </span><span class="s1">test_wrong_shape_func_function(self):</span>
        <span class="s3"># x0 is a list of two elements, but func will return an array with</span>
        <span class="s3"># length 1, so this should result in a TypeError.</span>
        <span class="s1">x0 = [</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">optimize.leastsq</span><span class="s2">, </span><span class="s1">dummy_func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args=((</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_wrong_shape_Dfun_callable(self):</span>
        <span class="s1">func = ReturnShape(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">deriv_func = ReturnShape((</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">optimize.leastsq</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Dfun=deriv_func)</span>

    <span class="s2">def </span><span class="s1">test_wrong_shape_Dfun_function(self):</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">dummy_func(x</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">def </span><span class="s1">deriv_func(x):</span>
            <span class="s2">return </span><span class="s1">dummy_func(x</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">optimize.leastsq</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Dfun=deriv_func)</span>

    <span class="s2">def </span><span class="s1">test_float32(self):</span>
        <span class="s3"># Regression test for gh-1447</span>
        <span class="s2">def </span><span class="s1">func(p</span><span class="s2">,</span><span class="s1">x</span><span class="s2">,</span><span class="s1">y):</span>
            <span class="s1">q = p[</span><span class="s4">0</span><span class="s1">]*np.exp(-(x-p[</span><span class="s4">1</span><span class="s1">])**</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">2.0</span><span class="s1">*p[</span><span class="s4">2</span><span class="s1">]**</span><span class="s4">2</span><span class="s1">))+p[</span><span class="s4">3</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">q - y</span>

        <span class="s1">x = np.array([</span><span class="s4">1.475</span><span class="s2">,</span><span class="s4">1.429</span><span class="s2">,</span><span class="s4">1.409</span><span class="s2">,</span><span class="s4">1.419</span><span class="s2">,</span><span class="s4">1.455</span><span class="s2">,</span><span class="s4">1.519</span><span class="s2">,</span><span class="s4">1.472</span><span class="s2">, </span><span class="s4">1.368</span><span class="s2">,</span><span class="s4">1.286</span><span class="s2">,</span>
                       <span class="s4">1.231</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">y = np.array([</span><span class="s4">0.0168</span><span class="s2">,</span><span class="s4">0.0193</span><span class="s2">,</span><span class="s4">0.0211</span><span class="s2">,</span><span class="s4">0.0202</span><span class="s2">,</span><span class="s4">0.0171</span><span class="s2">,</span><span class="s4">0.0151</span><span class="s2">,</span><span class="s4">0.0185</span><span class="s2">,</span><span class="s4">0.0258</span><span class="s2">,</span>
                      <span class="s4">0.034</span><span class="s2">,</span><span class="s4">0.0396</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">p0 = np.array([</span><span class="s4">1.0</span><span class="s2">,</span><span class="s4">1.0</span><span class="s2">,</span><span class="s4">1.0</span><span class="s2">,</span><span class="s4">1.0</span><span class="s1">])</span>
        <span class="s1">p1</span><span class="s2">, </span><span class="s1">success = optimize.leastsq(func</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">, </span><span class="s1">args=(x</span><span class="s2">,</span><span class="s1">y))</span>

        <span class="s1">assert_(success </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">assert_((func(p1</span><span class="s2">,</span><span class="s1">x</span><span class="s2">,</span><span class="s1">y)**</span><span class="s4">2</span><span class="s1">).sum() &lt; </span><span class="s4">1e-4 </span><span class="s1">* (func(p0</span><span class="s2">,</span><span class="s1">x</span><span class="s2">,</span><span class="s1">y)**</span><span class="s4">2</span><span class="s1">).sum())</span>

    <span class="s2">def </span><span class="s1">test_func_can_raise(self):</span>
        <span class="s2">def </span><span class="s1">func(*args):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'I raised'</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">'I raised'</span><span class="s1">):</span>
            <span class="s1">optimize.leastsq(func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_Dfun_can_raise(self):</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">x - np.array([</span><span class="s4">10</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">deriv_func(*args):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'I raised'</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">'I raised'</span><span class="s1">):</span>
            <span class="s1">optimize.leastsq(func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Dfun=deriv_func)</span>

    <span class="s2">def </span><span class="s1">test_reentrant_func(self):</span>
        <span class="s2">def </span><span class="s1">func(*args):</span>
            <span class="s1">self.test_basic()</span>
            <span class="s2">return </span><span class="s1">self.residuals(*args)</span>

        <span class="s1">p0 = array([</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">params_fit</span><span class="s2">, </span><span class="s1">ier = leastsq(func</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">,</span>
                                  <span class="s1">args=(self.y_meas</span><span class="s2">, </span><span class="s1">self.x))</span>
        <span class="s1">assert_(ier </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'solution not found (ier=%d)' </span><span class="s1">% ier)</span>
        <span class="s3"># low precision due to random</span>
        <span class="s1">assert_array_almost_equal(params_fit</span><span class="s2">, </span><span class="s1">self.abc</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_reentrant_Dfun(self):</span>
        <span class="s2">def </span><span class="s1">deriv_func(*args):</span>
            <span class="s1">self.test_basic()</span>
            <span class="s2">return </span><span class="s1">self.residuals_jacobian(*args)</span>

        <span class="s1">p0 = array([</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">params_fit</span><span class="s2">, </span><span class="s1">ier = leastsq(self.residuals</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">,</span>
                                  <span class="s1">args=(self.y_meas</span><span class="s2">, </span><span class="s1">self.x)</span><span class="s2">,</span>
                                  <span class="s1">Dfun=deriv_func)</span>
        <span class="s1">assert_(ier </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'solution not found (ier=%d)' </span><span class="s1">% ier)</span>
        <span class="s3"># low precision due to random</span>
        <span class="s1">assert_array_almost_equal(params_fit</span><span class="s2">, </span><span class="s1">self.abc</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_concurrent_no_gradient(self):</span>
        <span class="s1">v = sequence_parallel([self.test_basic] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">all([result </span><span class="s2">is None for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">v])</span>

    <span class="s2">def </span><span class="s1">test_concurrent_with_gradient(self):</span>
        <span class="s1">v = sequence_parallel([self.test_basic_with_gradient] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">all([result </span><span class="s2">is None for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">v])</span>

    <span class="s2">def </span><span class="s1">test_func_input_output_length_check(self):</span>

        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s4">2 </span><span class="s1">* (x[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">3</span><span class="s1">) ** </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span>

        <span class="s2">with </span><span class="s1">assert_raises(TypeError</span><span class="s2">,</span>
                           <span class="s1">match=</span><span class="s5">'Improper input: func input vector length N='</span><span class="s1">):</span>
            <span class="s1">optimize.leastsq(func</span><span class="s2">, </span><span class="s1">x0=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">TestCurveFit:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.y = array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">3.2</span><span class="s2">, </span><span class="s4">9.5</span><span class="s2">, </span><span class="s4">13.7</span><span class="s1">])</span>
        <span class="s1">self.x = array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_one_argument(self):</span>
        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">,</span><span class="s1">a):</span>
            <span class="s2">return </span><span class="s1">x**a</span>
        <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(func</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.y)</span>
        <span class="s1">assert_(len(popt) == </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_(pcov.shape == (</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(popt[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1.9149</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pcov[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.0016</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>

        <span class="s3"># Test if we get the same with full_output. Regression test for #1415.</span>
        <span class="s3"># Also test if check_finite can be turned off.</span>
        <span class="s1">res = curve_fit(func</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.y</span><span class="s2">,</span>
                        <span class="s1">full_output=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">check_finite=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">(popt2</span><span class="s2">, </span><span class="s1">pcov2</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">errmsg</span><span class="s2">, </span><span class="s1">ier) = res</span>
        <span class="s1">assert_array_almost_equal(popt</span><span class="s2">, </span><span class="s1">popt2)</span>

    <span class="s2">def </span><span class="s1">test_two_argument(self):</span>
        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">b*x**a</span>
        <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(func</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.y)</span>
        <span class="s1">assert_(len(popt) == </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_(pcov.shape == (</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(popt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.7989</span><span class="s2">, </span><span class="s4">1.1642</span><span class="s1">]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(pcov</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0.0852</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1260</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.1260</span><span class="s2">, </span><span class="s4">0.1912</span><span class="s1">]]</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_func_is_classmethod(self):</span>
        <span class="s2">class </span><span class="s1">test_self:</span>
            <span class="s0">&quot;&quot;&quot;This class tests if curve_fit passes the correct number of 
               arguments when the model function is a class instance method. 
            &quot;&quot;&quot;</span>

            <span class="s2">def </span><span class="s1">func(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
                <span class="s2">return </span><span class="s1">b * x**a</span>

        <span class="s1">test_self_inst = test_self()</span>
        <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(test_self_inst.func</span><span class="s2">, </span><span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.y)</span>
        <span class="s1">assert_(pcov.shape == (</span><span class="s4">2</span><span class="s2">,</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(popt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.7989</span><span class="s2">, </span><span class="s4">1.1642</span><span class="s1">]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(pcov</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0.0852</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1260</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.1260</span><span class="s2">, </span><span class="s4">0.1912</span><span class="s1">]]</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_regression_2639(self):</span>
        <span class="s3"># This test fails if epsfcn in leastsq is too large.</span>
        <span class="s1">x = [</span><span class="s4">574.14200000000005</span><span class="s2">, </span><span class="s4">574.154</span><span class="s2">, </span><span class="s4">574.16499999999996</span><span class="s2">,</span>
             <span class="s4">574.17700000000002</span><span class="s2">, </span><span class="s4">574.18799999999999</span><span class="s2">, </span><span class="s4">574.19899999999996</span><span class="s2">,</span>
             <span class="s4">574.21100000000001</span><span class="s2">, </span><span class="s4">574.22199999999998</span><span class="s2">, </span><span class="s4">574.23400000000004</span><span class="s2">,</span>
             <span class="s4">574.245</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">859.0</span><span class="s2">, </span><span class="s4">997.0</span><span class="s2">, </span><span class="s4">1699.0</span><span class="s2">, </span><span class="s4">2604.0</span><span class="s2">, </span><span class="s4">2013.0</span><span class="s2">, </span><span class="s4">1964.0</span><span class="s2">, </span><span class="s4">2435.0</span><span class="s2">,</span>
             <span class="s4">1550.0</span><span class="s2">, </span><span class="s4">949.0</span><span class="s2">, </span><span class="s4">841.0</span><span class="s1">]</span>
        <span class="s1">guess = [</span><span class="s4">574.1861428571428</span><span class="s2">, </span><span class="s4">574.2155714285715</span><span class="s2">, </span><span class="s4">1302.0</span><span class="s2">, </span><span class="s4">1302.0</span><span class="s2">,</span>
                 <span class="s4">0.0035019999999983615</span><span class="s2">, </span><span class="s4">859.0</span><span class="s1">]</span>
        <span class="s1">good = [</span><span class="s4">5.74177150e+02</span><span class="s2">, </span><span class="s4">5.74209188e+02</span><span class="s2">, </span><span class="s4">1.74187044e+03</span><span class="s2">, </span><span class="s4">1.58646166e+03</span><span class="s2">,</span>
                <span class="s4">1.0068462e-02</span><span class="s2">, </span><span class="s4">8.57450661e+02</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">f_double_gauss(x</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">A0</span><span class="s2">, </span><span class="s1">A1</span><span class="s2">, </span><span class="s1">sigma</span><span class="s2">, </span><span class="s1">c):</span>
            <span class="s2">return </span><span class="s1">(A0*np.exp(-(x-x0)**</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">2.</span><span class="s1">*sigma**</span><span class="s4">2</span><span class="s1">))</span>
                    <span class="s1">+ A1*np.exp(-(x-x1)**</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">2.</span><span class="s1">*sigma**</span><span class="s4">2</span><span class="s1">)) + c)</span>
        <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f_double_gauss</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">guess</span><span class="s2">, </span><span class="s1">maxfev=</span><span class="s4">10000</span><span class="s1">)</span>
        <span class="s1">assert_allclose(popt</span><span class="s2">, </span><span class="s1">good</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pcov(self):</span>
        <span class="s1">xdata = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
        <span class="s1">ydata = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">12</span><span class="s1">])</span>
        <span class="s1">sigma = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a*x + b</span>

        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'lm'</span><span class="s2">, </span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s1">]:</span>
            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">p0=[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sigma=sigma</span><span class="s2">,</span>
                                   <span class="s1">method=method)</span>
            <span class="s1">perr_scaled = np.sqrt(np.diag(pcov))</span>
            <span class="s1">assert_allclose(perr_scaled</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.20659803</span><span class="s2">, </span><span class="s4">0.57204404</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>

            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">p0=[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">3</span><span class="s1">*sigma</span><span class="s2">,</span>
                                   <span class="s1">method=method)</span>
            <span class="s1">perr_scaled = np.sqrt(np.diag(pcov))</span>
            <span class="s1">assert_allclose(perr_scaled</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.20659803</span><span class="s2">, </span><span class="s4">0.57204404</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>

            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">p0=[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sigma=sigma</span><span class="s2">,</span>
                                   <span class="s1">absolute_sigma=</span><span class="s2">True, </span><span class="s1">method=method)</span>
            <span class="s1">perr = np.sqrt(np.diag(pcov))</span>
            <span class="s1">assert_allclose(perr</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.30714756</span><span class="s2">, </span><span class="s4">0.85045308</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>

            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">p0=[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">3</span><span class="s1">*sigma</span><span class="s2">,</span>
                                   <span class="s1">absolute_sigma=</span><span class="s2">True, </span><span class="s1">method=method)</span>
            <span class="s1">perr = np.sqrt(np.diag(pcov))</span>
            <span class="s1">assert_allclose(perr</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s1">*</span><span class="s4">0.30714756</span><span class="s2">, </span><span class="s4">3</span><span class="s1">*</span><span class="s4">0.85045308</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>

        <span class="s3"># infinite variances</span>

        <span class="s2">def </span><span class="s1">f_flat(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a*x</span>

        <span class="s1">pcov_expected = np.array([np.inf]*</span><span class="s4">4</span><span class="s1">).reshape(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(OptimizeWarning</span><span class="s2">,</span>
                       <span class="s5">&quot;Covariance of the parameters could not be estimated&quot;</span><span class="s1">)</span>
            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f_flat</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">p0=[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sigma=sigma)</span>
            <span class="s1">popt1</span><span class="s2">, </span><span class="s1">pcov1 = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata[:</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ydata[:</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p0=[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">assert_(pcov.shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(pcov</span><span class="s2">, </span><span class="s1">pcov_expected)</span>

        <span class="s1">assert_(pcov1.shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(pcov1</span><span class="s2">, </span><span class="s1">pcov_expected)</span>

    <span class="s2">def </span><span class="s1">test_array_like(self):</span>
        <span class="s3"># Test sequence input. Regression test for gh-3037.</span>
        <span class="s2">def </span><span class="s1">f_linear(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a*x + b</span>

        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span>
        <span class="s1">assert_allclose(curve_fit(f_linear</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_indeterminate_covariance(self):</span>
        <span class="s3"># Test that a warning is returned when pcov is indeterminate</span>
        <span class="s1">xdata = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">])</span>
        <span class="s1">ydata = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5.5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">])</span>
        <span class="s1">assert_warns(OptimizeWarning</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">,</span>
                     <span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: a*x</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata)</span>

    <span class="s2">def </span><span class="s1">test_NaN_handling(self):</span>
        <span class="s3"># Test for correct handling of NaNs in input data: gh-3422</span>

        <span class="s3"># create input with NaNs</span>
        <span class="s1">xdata = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">ydata = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>

        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">,</span>
                      <span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: a*x + b</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">,</span>
                      <span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: a*x + b</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">xdata)</span>

        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: a*x + b</span><span class="s2">,</span>
                      <span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">**{</span><span class="s5">&quot;check_finite&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">})</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_check_nan_policy(f</span><span class="s2">, </span><span class="s1">xdata_with_nan</span><span class="s2">, </span><span class="s1">xdata_without_nan</span><span class="s2">,</span>
                          <span class="s1">ydata_with_nan</span><span class="s2">, </span><span class="s1">ydata_without_nan</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s1">kwargs = {</span><span class="s5">'f'</span><span class="s1">: f</span><span class="s2">, </span><span class="s5">'xdata'</span><span class="s1">: xdata_with_nan</span><span class="s2">, </span><span class="s5">'ydata'</span><span class="s1">: ydata_with_nan</span><span class="s2">,</span>
                  <span class="s5">'method'</span><span class="s1">: method</span><span class="s2">, </span><span class="s5">'check_finite'</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span>
        <span class="s3"># propagate test</span>
        <span class="s1">error_msg = (</span><span class="s5">&quot;`nan_policy='propagate'` is not supported &quot;</span>
                     <span class="s5">&quot;by this function.&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_msg):</span>
            <span class="s1">curve_fit(**kwargs</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s5">&quot;propagate&quot;</span><span class="s2">, </span><span class="s1">maxfev=</span><span class="s4">2000</span><span class="s1">)</span>

        <span class="s3"># raise test</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;The input contains nan&quot;</span><span class="s1">):</span>
            <span class="s1">curve_fit(**kwargs</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s5">&quot;raise&quot;</span><span class="s1">)</span>

        <span class="s3"># omit test</span>
        <span class="s1">result_with_nan</span><span class="s2">, </span><span class="s1">_ = curve_fit(**kwargs</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s5">&quot;omit&quot;</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s5">'xdata'</span><span class="s1">] = xdata_without_nan</span>
        <span class="s1">kwargs[</span><span class="s5">'ydata'</span><span class="s1">] = ydata_without_nan</span>
        <span class="s1">result_without_nan</span><span class="s2">, </span><span class="s1">_ = curve_fit(**kwargs)</span>
        <span class="s1">assert_allclose(result_with_nan</span><span class="s2">, </span><span class="s1">result_without_nan)</span>

        <span class="s3"># not valid policy test</span>
        <span class="s1">error_msg = (</span><span class="s5">&quot;nan_policy must be one of &quot;</span>
                     <span class="s5">&quot;{'None', 'raise', 'omit'}&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_msg):</span>
            <span class="s1">curve_fit(**kwargs</span><span class="s2">, </span><span class="s1">nan_policy=</span><span class="s5">&quot;hi&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;lm&quot;</span><span class="s2">, </span><span class="s5">&quot;trf&quot;</span><span class="s2">, </span><span class="s5">&quot;dogbox&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_nan_policy_1d(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a*x + b</span>

        <span class="s1">xdata_with_nan = np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">ydata_with_nan = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">7</span><span class="s1">])</span>
        <span class="s1">xdata_without_nan = np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">ydata_without_nan = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>

        <span class="s1">self._check_nan_policy(f</span><span class="s2">, </span><span class="s1">xdata_with_nan</span><span class="s2">, </span><span class="s1">xdata_without_nan</span><span class="s2">,</span>
                               <span class="s1">ydata_with_nan</span><span class="s2">, </span><span class="s1">ydata_without_nan</span><span class="s2">, </span><span class="s1">method)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;lm&quot;</span><span class="s2">, </span><span class="s5">&quot;trf&quot;</span><span class="s2">, </span><span class="s5">&quot;dogbox&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_nan_policy_2d(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s1">x1 = x[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">x2 = x[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s2">return </span><span class="s1">a*x1 + b + x2</span>

        <span class="s1">xdata_with_nan = np.array([[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                                   <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]])</span>
        <span class="s1">ydata_with_nan = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>
        <span class="s1">xdata_without_nan = np.array([[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]])</span>
        <span class="s1">ydata_without_nan = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>

        <span class="s1">self._check_nan_policy(f</span><span class="s2">, </span><span class="s1">xdata_with_nan</span><span class="s2">, </span><span class="s1">xdata_without_nan</span><span class="s2">,</span>
                               <span class="s1">ydata_with_nan</span><span class="s2">, </span><span class="s1">ydata_without_nan</span><span class="s2">, </span><span class="s1">method)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'n'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;lm&quot;</span><span class="s2">, </span><span class="s5">&quot;trf&quot;</span><span class="s2">, </span><span class="s5">&quot;dogbox&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_nan_policy_2_3d(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s1">x1 = x[...</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">:].squeeze()</span>
            <span class="s1">x2 = x[...</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">:].squeeze()</span>
            <span class="s2">return </span><span class="s1">a*x1 + b + x2</span>

        <span class="s1">xdata_with_nan = np.array([[[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                                   <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]]])</span>
        <span class="s1">xdata_with_nan = xdata_with_nan.squeeze() </span><span class="s2">if </span><span class="s1">n == </span><span class="s4">2 </span><span class="s2">else </span><span class="s1">xdata_with_nan</span>
        <span class="s1">ydata_with_nan = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>
        <span class="s1">xdata_without_nan = np.array([[[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]]])</span>
        <span class="s1">ydata_without_nan = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>

        <span class="s1">self._check_nan_policy(f</span><span class="s2">, </span><span class="s1">xdata_with_nan</span><span class="s2">, </span><span class="s1">xdata_without_nan</span><span class="s2">,</span>
                               <span class="s1">ydata_with_nan</span><span class="s2">, </span><span class="s1">ydata_without_nan</span><span class="s2">, </span><span class="s1">method)</span>

    <span class="s2">def </span><span class="s1">test_empty_inputs(self):</span>
        <span class="s3"># Test both with and without bounds (regression test for gh-9864)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a: a*x</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a: a*x</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">,</span>
                      <span class="s1">bounds=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a: a*x</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a: a*x</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">,</span>
                      <span class="s1">bounds=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_function_zero_params(self):</span>
        <span class="s3"># Fit args is zero, so &quot;Unable to determine number of fit parameters.&quot;</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_None_x(self):  </span><span class="s3"># Added in GH10196</span>
        <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(</span><span class="s2">lambda </span><span class="s1">_</span><span class="s2">, </span><span class="s1">a: a * np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s2">None, </span><span class="s4">2 </span><span class="s1">* np.arange(</span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">assert_allclose(popt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_method_argument(self):</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a * np.exp(-b*x)</span>

        <span class="s1">xdata = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">ydata = f(xdata</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s2">, </span><span class="s5">'lm'</span><span class="s2">, None</span><span class="s1">]:</span>
            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">method=method)</span>
            <span class="s1">assert_allclose(popt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">])</span>

        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'unknown'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_full_output(self):</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a * np.exp(-b * x)</span>

        <span class="s1">xdata = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">ydata = f(xdata</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s2">, </span><span class="s5">'lm'</span><span class="s2">, None</span><span class="s1">]:</span>
            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov</span><span class="s2">, </span><span class="s1">infodict</span><span class="s2">, </span><span class="s1">errmsg</span><span class="s2">, </span><span class="s1">ier = curve_fit(</span>
                <span class="s1">f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">full_output=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">assert_allclose(popt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">])</span>
            <span class="s2">assert </span><span class="s5">&quot;nfev&quot; </span><span class="s2">in </span><span class="s1">infodict</span>
            <span class="s2">assert </span><span class="s5">&quot;fvec&quot; </span><span class="s2">in </span><span class="s1">infodict</span>
            <span class="s2">if </span><span class="s1">method == </span><span class="s5">'lm' </span><span class="s2">or </span><span class="s1">method </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s5">&quot;fjac&quot; </span><span class="s2">in </span><span class="s1">infodict</span>
                <span class="s2">assert </span><span class="s5">&quot;ipvt&quot; </span><span class="s2">in </span><span class="s1">infodict</span>
                <span class="s2">assert </span><span class="s5">&quot;qtf&quot; </span><span class="s2">in </span><span class="s1">infodict</span>
            <span class="s2">assert </span><span class="s1">isinstance(errmsg</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s2">assert </span><span class="s1">ier </span><span class="s2">in </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bounds(self):</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a * np.exp(-b*x)</span>

        <span class="s1">xdata = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">ydata = f(xdata</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span>

        <span class="s3"># The minimum w/out bounds is at [2., 2.],</span>
        <span class="s3"># and with bounds it's at [1.5, smth].</span>
        <span class="s1">lb = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">ub = [</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">]</span>

        <span class="s3"># Test that both variants of the bounds yield the same result</span>
        <span class="s1">bounds = (lb</span><span class="s2">, </span><span class="s1">ub)</span>
        <span class="s1">bounds_class = Bounds(lb</span><span class="s2">, </span><span class="s1">ub)</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s2">None, </span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s1">]:</span>
            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">,</span>
                                   <span class="s1">method=method)</span>
            <span class="s1">assert_allclose(popt[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span>

            <span class="s1">popt_class</span><span class="s2">, </span><span class="s1">pcov_class = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">,</span>
                                               <span class="s1">bounds=bounds_class</span><span class="s2">,</span>
                                               <span class="s1">method=method)</span>
            <span class="s1">assert_allclose(popt_class</span><span class="s2">, </span><span class="s1">popt)</span>

        <span class="s3"># With bounds, the starting estimate is feasible.</span>
        <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'trf'</span><span class="s2">,</span>
                               <span class="s1">bounds=([</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.6</span><span class="s2">, </span><span class="s1">np.inf]))</span>
        <span class="s1">assert_allclose(popt[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">)</span>

        <span class="s3"># method='lm' doesn't support bounds.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">curve_fit</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">,</span>
                      <span class="s1">method=</span><span class="s5">'lm'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bounds_p0(self):</span>
        <span class="s3"># This test is for issue #5719. The problem was that an initial guess</span>
        <span class="s3"># was ignored when 'trf' or 'dogbox' methods were invoked.</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a):</span>
            <span class="s2">return </span><span class="s1">np.sin(x + a)</span>

        <span class="s1">xdata = np.linspace(-</span><span class="s4">2</span><span class="s1">*np.pi</span><span class="s2">, </span><span class="s4">2</span><span class="s1">*np.pi</span><span class="s2">, </span><span class="s4">40</span><span class="s1">)</span>
        <span class="s1">ydata = np.sin(xdata)</span>
        <span class="s1">bounds = (-</span><span class="s4">3 </span><span class="s1">* np.pi</span><span class="s2">, </span><span class="s4">3 </span><span class="s1">* np.pi)</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s1">]:</span>
            <span class="s1">popt_1</span><span class="s2">, </span><span class="s1">_ = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">p0=</span><span class="s4">2.1</span><span class="s1">*np.pi)</span>
            <span class="s1">popt_2</span><span class="s2">, </span><span class="s1">_ = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">p0=</span><span class="s4">2.1</span><span class="s1">*np.pi</span><span class="s2">,</span>
                                  <span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">method=method)</span>

            <span class="s3"># If the initial guess is ignored, then popt_2 would be close 0.</span>
            <span class="s1">assert_allclose(popt_1</span><span class="s2">, </span><span class="s1">popt_2)</span>

    <span class="s2">def </span><span class="s1">test_jac(self):</span>
        <span class="s3"># Test that Jacobian callable is handled correctly and</span>
        <span class="s3"># weighted if sigma is provided.</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a * np.exp(-b*x)</span>

        <span class="s2">def </span><span class="s1">jac(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s1">e = np.exp(-b*x)</span>
            <span class="s2">return </span><span class="s1">np.vstack((e</span><span class="s2">, </span><span class="s1">-a * x * e)).T</span>

        <span class="s1">xdata = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">ydata = f(xdata</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span>

        <span class="s3"># Test numerical options for least_squares backend.</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'2-point'</span><span class="s2">, </span><span class="s5">'3-point'</span><span class="s2">, </span><span class="s5">'cs'</span><span class="s1">]:</span>
                <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">jac=scheme</span><span class="s2">,</span>
                                       <span class="s1">method=method)</span>
                <span class="s1">assert_allclose(popt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>

        <span class="s3"># Test the analytic option.</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'lm'</span><span class="s2">, </span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s1">]:</span>
            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">jac=jac)</span>
            <span class="s1">assert_allclose(popt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>

        <span class="s3"># Now add an outlier and provide sigma.</span>
        <span class="s1">ydata[</span><span class="s4">5</span><span class="s1">] = </span><span class="s4">100</span>
        <span class="s1">sigma = np.ones(xdata.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">sigma[</span><span class="s4">5</span><span class="s1">] = </span><span class="s4">200</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'lm'</span><span class="s2">, </span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s1">]:</span>
            <span class="s1">popt</span><span class="s2">, </span><span class="s1">pcov = curve_fit(f</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">sigma=sigma</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">,</span>
                                   <span class="s1">jac=jac)</span>
            <span class="s3"># Still the optimization process is influenced somehow,</span>
            <span class="s3"># have to set rtol=1e-3.</span>
            <span class="s1">assert_allclose(popt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_maxfev_and_bounds(self):</span>
        <span class="s3"># gh-6340: with no bounds, curve_fit accepts parameter maxfev (via leastsq)</span>
        <span class="s3"># but with bounds, the parameter is `max_nfev` (via least_squares)</span>
        <span class="s1">x = np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">y = </span><span class="s4">2</span><span class="s1">*x</span>
        <span class="s1">popt1</span><span class="s2">, </span><span class="s1">_ = curve_fit(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">,</span><span class="s1">p: p*x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">bounds=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">maxfev=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">popt2</span><span class="s2">, </span><span class="s1">_ = curve_fit(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">,</span><span class="s1">p: p*x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">bounds=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">max_nfev=</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s1">assert_allclose(popt1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(popt2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_curvefit_simplecovariance(self):</span>

        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a * np.exp(-b*x)</span>

        <span class="s2">def </span><span class="s1">jac(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s1">e = np.exp(-b*x)</span>
            <span class="s2">return </span><span class="s1">np.vstack((e</span><span class="s2">, </span><span class="s1">-a * x * e)).T</span>

        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">xdata = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">y = func(xdata</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">1.3</span><span class="s1">)</span>
        <span class="s1">ydata = y + </span><span class="s4">0.2 </span><span class="s1">* np.random.normal(size=len(xdata))</span>

        <span class="s1">sigma = np.zeros(len(xdata)) + </span><span class="s4">0.2</span>
        <span class="s1">covar = np.diag(sigma**</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">jac1</span><span class="s2">, </span><span class="s1">jac2 </span><span class="s2">in </span><span class="s1">[(jac</span><span class="s2">, </span><span class="s1">jac)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, None</span><span class="s1">)]:</span>
            <span class="s2">for </span><span class="s1">absolute_sigma </span><span class="s2">in </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">]:</span>
                <span class="s1">popt1</span><span class="s2">, </span><span class="s1">pcov1 = curve_fit(func</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">sigma=sigma</span><span class="s2">,</span>
                        <span class="s1">jac=jac1</span><span class="s2">, </span><span class="s1">absolute_sigma=absolute_sigma)</span>
                <span class="s1">popt2</span><span class="s2">, </span><span class="s1">pcov2 = curve_fit(func</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">sigma=covar</span><span class="s2">,</span>
                        <span class="s1">jac=jac2</span><span class="s2">, </span><span class="s1">absolute_sigma=absolute_sigma)</span>

                <span class="s1">assert_allclose(popt1</span><span class="s2">, </span><span class="s1">popt2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>
                <span class="s1">assert_allclose(pcov1</span><span class="s2">, </span><span class="s1">pcov2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_curvefit_covariance(self):</span>

        <span class="s2">def </span><span class="s1">funcp(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s1">rotn = np.array([[</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]])</span>
            <span class="s2">return </span><span class="s1">rotn.dot(a * np.exp(-b*x))</span>

        <span class="s2">def </span><span class="s1">jacp(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s1">rotn = np.array([[</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]])</span>
            <span class="s1">e = np.exp(-b*x)</span>
            <span class="s2">return </span><span class="s1">rotn.dot(np.vstack((e</span><span class="s2">, </span><span class="s1">-a * x * e)).T)</span>

        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a * np.exp(-b*x)</span>

        <span class="s2">def </span><span class="s1">jac(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s1">e = np.exp(-b*x)</span>
            <span class="s2">return </span><span class="s1">np.vstack((e</span><span class="s2">, </span><span class="s1">-a * x * e)).T</span>

        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">xdata = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">y = func(xdata</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">ydata = y + </span><span class="s4">0.2 </span><span class="s1">* np.random.normal(size=len(xdata))</span>
        <span class="s1">sigma = np.zeros(len(xdata)) + </span><span class="s4">0.2</span>
        <span class="s1">covar = np.diag(sigma**</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3"># Get a rotation matrix, and obtain ydatap = R ydata</span>
        <span class="s3"># Chisq = ydata^T C^{-1} ydata</span>
        <span class="s3">#       = ydata^T R^T R C^{-1} R^T R ydata</span>
        <span class="s3">#       = ydatap^T Cp^{-1} ydatap</span>
        <span class="s3"># Cp^{-1} = R C^{-1} R^T</span>
        <span class="s3"># Cp      = R C R^T, since R^-1 = R^T</span>
        <span class="s1">rotn = np.array([[</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]])</span>
        <span class="s1">ydatap = rotn.dot(ydata)</span>
        <span class="s1">covarp = rotn.dot(covar).dot(rotn.T)</span>

        <span class="s2">for </span><span class="s1">jac1</span><span class="s2">, </span><span class="s1">jac2 </span><span class="s2">in </span><span class="s1">[(jac</span><span class="s2">, </span><span class="s1">jacp)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, None</span><span class="s1">)]:</span>
            <span class="s2">for </span><span class="s1">absolute_sigma </span><span class="s2">in </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">]:</span>
                <span class="s1">popt1</span><span class="s2">, </span><span class="s1">pcov1 = curve_fit(func</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">sigma=sigma</span><span class="s2">,</span>
                        <span class="s1">jac=jac1</span><span class="s2">, </span><span class="s1">absolute_sigma=absolute_sigma)</span>
                <span class="s1">popt2</span><span class="s2">, </span><span class="s1">pcov2 = curve_fit(funcp</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydatap</span><span class="s2">, </span><span class="s1">sigma=covarp</span><span class="s2">,</span>
                        <span class="s1">jac=jac2</span><span class="s2">, </span><span class="s1">absolute_sigma=absolute_sigma)</span>

                <span class="s1">assert_allclose(popt1</span><span class="s2">, </span><span class="s1">popt2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1.2e-7</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>
                <span class="s1">assert_allclose(pcov1</span><span class="s2">, </span><span class="s1">pcov2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1.2e-7</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dtypes(self):</span>
        <span class="s3"># regression test for gh-9581: curve_fit fails if x and y dtypes differ</span>
        <span class="s1">x = np.arange(-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">y = </span><span class="s4">1.5</span><span class="s1">*x + </span><span class="s4">3.0 </span><span class="s1">+ </span><span class="s4">0.5</span><span class="s1">*np.sin(x)</span>

        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a*x + b</span>

        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'lm'</span><span class="s2">, </span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">dtx </span><span class="s2">in </span><span class="s1">[np.float32</span><span class="s2">, </span><span class="s1">np.float64]:</span>
                <span class="s2">for </span><span class="s1">dty </span><span class="s2">in </span><span class="s1">[np.float32</span><span class="s2">, </span><span class="s1">np.float64]:</span>
                    <span class="s1">x = x.astype(dtx)</span>
                    <span class="s1">y = y.astype(dty)</span>

                <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
                    <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s2">, </span><span class="s1">OptimizeWarning)</span>
                    <span class="s1">p</span><span class="s2">, </span><span class="s1">cov = curve_fit(func</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">method=method)</span>

                    <span class="s2">assert </span><span class="s1">np.isfinite(cov).all()</span>
                    <span class="s2">assert not </span><span class="s1">np.allclose(p</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)   </span><span class="s3"># curve_fit's initial value</span>

    <span class="s2">def </span><span class="s1">test_dtypes2(self):</span>
        <span class="s3"># regression test for gh-7117: curve_fit fails if</span>
        <span class="s3"># both inputs are float32</span>
        <span class="s2">def </span><span class="s1">hyperbola(x</span><span class="s2">, </span><span class="s1">s_1</span><span class="s2">, </span><span class="s1">s_2</span><span class="s2">, </span><span class="s1">o_x</span><span class="s2">, </span><span class="s1">o_y</span><span class="s2">, </span><span class="s1">c):</span>
            <span class="s1">b_2 = (s_1 + s_2) / </span><span class="s4">2</span>
            <span class="s1">b_1 = (s_2 - s_1) / </span><span class="s4">2</span>
            <span class="s2">return </span><span class="s1">o_y + b_1*(x-o_x) + b_2*np.sqrt((x-o_x)**</span><span class="s4">2 </span><span class="s1">+ c**</span><span class="s4">2</span><span class="s1">/</span><span class="s4">4</span><span class="s1">)</span>

        <span class="s1">min_fit = np.array([-</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">])</span>
        <span class="s1">max_fit = np.array([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">10.0</span><span class="s1">])</span>
        <span class="s1">guess = np.array([-</span><span class="s4">2.5</span><span class="s1">/</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">/</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>

        <span class="s1">params = [-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">.4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">9.5</span><span class="s1">]</span>
        <span class="s1">xdata = np.array([-</span><span class="s4">32</span><span class="s2">, </span><span class="s1">-</span><span class="s4">16</span><span class="s2">, </span><span class="s1">-</span><span class="s4">8</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">32</span><span class="s1">])</span>
        <span class="s1">ydata = hyperbola(xdata</span><span class="s2">, </span><span class="s1">*params)</span>

        <span class="s3"># run optimization twice, with xdata being float32 and float64</span>
        <span class="s1">popt_64</span><span class="s2">, </span><span class="s1">_ = curve_fit(f=hyperbola</span><span class="s2">, </span><span class="s1">xdata=xdata</span><span class="s2">, </span><span class="s1">ydata=ydata</span><span class="s2">, </span><span class="s1">p0=guess</span><span class="s2">,</span>
                               <span class="s1">bounds=(min_fit</span><span class="s2">, </span><span class="s1">max_fit))</span>

        <span class="s1">xdata = xdata.astype(np.float32)</span>
        <span class="s1">ydata = hyperbola(xdata</span><span class="s2">, </span><span class="s1">*params)</span>

        <span class="s1">popt_32</span><span class="s2">, </span><span class="s1">_ = curve_fit(f=hyperbola</span><span class="s2">, </span><span class="s1">xdata=xdata</span><span class="s2">, </span><span class="s1">ydata=ydata</span><span class="s2">, </span><span class="s1">p0=guess</span><span class="s2">,</span>
                               <span class="s1">bounds=(min_fit</span><span class="s2">, </span><span class="s1">max_fit))</span>

        <span class="s1">assert_allclose(popt_32</span><span class="s2">, </span><span class="s1">popt_64</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_broadcast_y(self):</span>
        <span class="s1">xdata = np.arange(</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">target = </span><span class="s4">4.7 </span><span class="s1">* xdata ** </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">3.5 </span><span class="s1">* xdata + np.random.rand(len(xdata))</span>
        <span class="s2">def </span><span class="s1">fit_func(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a * x ** </span><span class="s4">2 </span><span class="s1">+ b * x - target</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'lm'</span><span class="s2">, </span><span class="s5">'trf'</span><span class="s2">, </span><span class="s5">'dogbox'</span><span class="s1">]:</span>
            <span class="s1">popt0</span><span class="s2">, </span><span class="s1">pcov0 = curve_fit(fit_func</span><span class="s2">,</span>
                                     <span class="s1">xdata=xdata</span><span class="s2">,</span>
                                     <span class="s1">ydata=np.zeros_like(xdata)</span><span class="s2">,</span>
                                     <span class="s1">method=method)</span>
            <span class="s1">popt1</span><span class="s2">, </span><span class="s1">pcov1 = curve_fit(fit_func</span><span class="s2">,</span>
                                     <span class="s1">xdata=xdata</span><span class="s2">,</span>
                                     <span class="s1">ydata=</span><span class="s4">0</span><span class="s2">,</span>
                                     <span class="s1">method=method)</span>
            <span class="s1">assert_allclose(pcov0</span><span class="s2">, </span><span class="s1">pcov1)</span>

    <span class="s2">def </span><span class="s1">test_args_in_kwargs(self):</span>
        <span class="s3"># Ensure that `args` cannot be passed as keyword argument to `curve_fit`</span>

        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s2">return </span><span class="s1">a * x + b</span>

        <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">curve_fit(func</span><span class="s2">,</span>
                      <span class="s1">xdata=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">ydata=[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">17</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">p0=[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">args=(</span><span class="s4">1</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_data_point_number_validation(self):</span>
        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e):</span>
            <span class="s2">return </span><span class="s1">a * np.exp(-b * x) + c + d + e</span>

        <span class="s2">with </span><span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;The number of func parameters=&quot;</span><span class="s1">):</span>
            <span class="s1">curve_fit(func</span><span class="s2">,</span>
                      <span class="s1">xdata=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">ydata=[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">17</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s5">'ignore::RuntimeWarning'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_gh4555(self):</span>
        <span class="s3"># gh-4555 reported that covariance matrices returned by `leastsq`</span>
        <span class="s3"># can have negative diagonal elements and eigenvalues. (In fact,</span>
        <span class="s3"># they can also be asymmetric.) This shows up in the output of</span>
        <span class="s3"># `scipy.optimize.curve_fit`. Check that it has been resolved.giit</span>
        <span class="s2">def </span><span class="s1">f(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e):</span>
            <span class="s2">return </span><span class="s1">a*np.log(x + </span><span class="s4">1 </span><span class="s1">+ b) + c*np.log(x + </span><span class="s4">1 </span><span class="s1">+ d) + e</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">408113519974467917</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s4">100</span>
        <span class="s1">x = np.arange(n)</span>
        <span class="s1">y = np.linspace(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s1">n) + rng.random(n)</span>
        <span class="s1">p</span><span class="s2">, </span><span class="s1">cov = optimize.curve_fit(f</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">maxfev=</span><span class="s4">100000</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">np.all(np.diag(cov) &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">eigs = linalg.eigh(cov)[</span><span class="s4">0</span><span class="s1">]  </span><span class="s3"># separate line for debugging</span>
        <span class="s3"># some platforms see a small negative eigevenvalue</span>
        <span class="s2">assert </span><span class="s1">np.all(eigs &gt; -</span><span class="s4">1e-2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(cov</span><span class="s2">, </span><span class="s1">cov.T)</span>

    <span class="s2">def </span><span class="s1">test_gh4555b(self):</span>
        <span class="s3"># check that PR gh-17247 did not significantly change covariance matrix</span>
        <span class="s3"># for simple cases</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">408113519974467917</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c):</span>
            <span class="s2">return </span><span class="s1">a * np.exp(-b * x) + c</span>

        <span class="s1">xdata = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">y = func(xdata</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">1.3</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">y_noise = </span><span class="s4">0.2 </span><span class="s1">* rng.normal(size=xdata.size)</span>
        <span class="s1">ydata = y + y_noise</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">res = curve_fit(func</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata)</span>
        <span class="s3"># reference from commit 1d80a2f254380d2b45733258ca42eb6b55c8755b</span>
        <span class="s1">ref = [[+</span><span class="s4">0.0158972536486215</span><span class="s2">, </span><span class="s4">0.0069207183284242</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0007474400714749</span><span class="s1">]</span><span class="s2">,</span>
               <span class="s1">[+</span><span class="s4">0.0069207183284242</span><span class="s2">, </span><span class="s4">0.0205057958128679</span><span class="s2">, </span><span class="s1">+</span><span class="s4">0.0053997711275403</span><span class="s1">]</span><span class="s2">,</span>
               <span class="s1">[-</span><span class="s4">0.0007474400714749</span><span class="s2">, </span><span class="s4">0.0053997711275403</span><span class="s2">, </span><span class="s1">+</span><span class="s4">0.0027833930320877</span><span class="s1">]]</span>
        <span class="s3"># Linux_Python_38_32bit_full fails with default tolerance</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s4">2e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gh13670(self):</span>
        <span class="s3"># gh-13670 reported that `curve_fit` executes callables</span>
        <span class="s3"># with the same values of the parameters at the beginning of</span>
        <span class="s3"># optimization. Check that this has been resolved.</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">8250058582555444926</span><span class="s1">)</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">101</span><span class="s1">)</span>
        <span class="s1">y = </span><span class="s4">2 </span><span class="s1">* x + </span><span class="s4">1 </span><span class="s1">+ rng.normal(size=</span><span class="s4">101</span><span class="s1">) * </span><span class="s4">0.5</span>

        <span class="s2">def </span><span class="s1">line(x</span><span class="s2">, </span><span class="s1">*p):</span>
            <span class="s2">assert not </span><span class="s1">np.all(line.last_p == p)</span>
            <span class="s1">line.last_p = p</span>
            <span class="s2">return </span><span class="s1">x * p[</span><span class="s4">0</span><span class="s1">] + p[</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">jac(x</span><span class="s2">, </span><span class="s1">*p):</span>
            <span class="s2">assert not </span><span class="s1">np.all(jac.last_p == p)</span>
            <span class="s1">jac.last_p = p</span>
            <span class="s2">return </span><span class="s1">np.array([x</span><span class="s2">, </span><span class="s1">np.ones_like(x)]).T</span>

        <span class="s1">line.last_p = </span><span class="s2">None</span>
        <span class="s1">jac.last_p = </span><span class="s2">None</span>
        <span class="s1">p0 = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">])</span>
        <span class="s1">curve_fit(line</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'lm'</span><span class="s2">, </span><span class="s1">jac=jac)</span>


<span class="s2">class </span><span class="s1">TestFixedPoint:</span>

    <span class="s2">def </span><span class="s1">test_scalar_trivial(self):</span>
        <span class="s3"># f(x) = 2x; fixed point should be x=0</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s4">2.0</span><span class="s1">*x</span>
        <span class="s1">x0 = </span><span class="s4">1.0</span>
        <span class="s1">x = fixed_point(func</span><span class="s2">, </span><span class="s1">x0)</span>
        <span class="s1">assert_almost_equal(x</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_scalar_basic1(self):</span>
        <span class="s3"># f(x) = x**2; x0=1.05; fixed point should be x=1</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">x**</span><span class="s4">2</span>
        <span class="s1">x0 = </span><span class="s4">1.05</span>
        <span class="s1">x = fixed_point(func</span><span class="s2">, </span><span class="s1">x0)</span>
        <span class="s1">assert_almost_equal(x</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_scalar_basic2(self):</span>
        <span class="s3"># f(x) = x**0.5; x0=1.05; fixed point should be x=1</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">x**</span><span class="s4">0.5</span>
        <span class="s1">x0 = </span><span class="s4">1.05</span>
        <span class="s1">x = fixed_point(func</span><span class="s2">, </span><span class="s1">x0)</span>
        <span class="s1">assert_almost_equal(x</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_array_trivial(self):</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s4">2.0</span><span class="s1">*x</span>
        <span class="s1">x0 = [</span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.15</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">x = fixed_point(func</span><span class="s2">, </span><span class="s1">x0)</span>
        <span class="s1">assert_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_array_basic1(self):</span>
        <span class="s3"># f(x) = c * x**2; fixed point should be x=1/c</span>
        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">c):</span>
            <span class="s2">return </span><span class="s1">c * x**</span><span class="s4">2</span>
        <span class="s1">c = array([</span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.25</span><span class="s1">])</span>
        <span class="s1">x0 = [</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.15</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">x = fixed_point(func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args=(c</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(x</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/c)</span>

    <span class="s2">def </span><span class="s1">test_array_basic2(self):</span>
        <span class="s3"># f(x) = c * x**0.5; fixed point should be x=c**2</span>
        <span class="s2">def </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">c):</span>
            <span class="s2">return </span><span class="s1">c * x**</span><span class="s4">0.5</span>
        <span class="s1">c = array([</span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.25</span><span class="s1">])</span>
        <span class="s1">x0 = [</span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.1</span><span class="s1">]</span>
        <span class="s1">x = fixed_point(func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args=(c</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(x</span><span class="s2">, </span><span class="s1">c**</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_lambertw(self):</span>
        <span class="s3"># python-list/2010-December/594592.html</span>
        <span class="s1">xxroot = fixed_point(</span><span class="s2">lambda </span><span class="s1">xx: np.exp(-</span><span class="s4">2.0</span><span class="s1">*xx)/</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">,</span>
                <span class="s1">args=()</span><span class="s2">, </span><span class="s1">xtol=</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">500</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xxroot</span><span class="s2">, </span><span class="s1">np.exp(-</span><span class="s4">2.0</span><span class="s1">*xxroot)/</span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(xxroot</span><span class="s2">, </span><span class="s1">lambertw(</span><span class="s4">1</span><span class="s1">)/</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_no_acceleration(self):</span>
        <span class="s3"># github issue 5460</span>
        <span class="s1">ks = </span><span class="s4">2</span>
        <span class="s1">kl = </span><span class="s4">6</span>
        <span class="s1">m = </span><span class="s4">1.3</span>
        <span class="s1">n0 = </span><span class="s4">1.001</span>
        <span class="s1">i0 = ((m-</span><span class="s4">1</span><span class="s1">)/m)*(kl/ks/m)**(</span><span class="s4">1</span><span class="s1">/(m-</span><span class="s4">1</span><span class="s1">))</span>

        <span class="s2">def </span><span class="s1">func(n):</span>
            <span class="s2">return </span><span class="s1">np.log(kl/ks/n) / np.log(i0*n/(n - </span><span class="s4">1</span><span class="s1">)) + </span><span class="s4">1</span>

        <span class="s1">n = fixed_point(func</span><span class="s2">, </span><span class="s1">n0</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'iteration'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(n</span><span class="s2">, </span><span class="s1">m)</span>
</pre>
</body>
</html>