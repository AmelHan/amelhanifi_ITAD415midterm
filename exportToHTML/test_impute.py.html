<html>
<head>
<title>test_impute.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_impute.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">io</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">sparse</span>
<span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">kstest</span>

<span class="s0">from </span><span class="s1">sklearn </span><span class="s0">import </span><span class="s1">tree</span>
<span class="s0">from </span><span class="s1">sklearn.datasets </span><span class="s0">import </span><span class="s1">load_diabetes</span>
<span class="s0">from </span><span class="s1">sklearn.dummy </span><span class="s0">import </span><span class="s1">DummyRegressor</span>
<span class="s0">from </span><span class="s1">sklearn.exceptions </span><span class="s0">import </span><span class="s1">ConvergenceWarning</span>

<span class="s2"># make IterativeImputer available</span>
<span class="s0">from </span><span class="s1">sklearn.experimental </span><span class="s0">import </span><span class="s1">enable_iterative_imputer  </span><span class="s2"># noqa</span>
<span class="s0">from </span><span class="s1">sklearn.impute </span><span class="s0">import </span><span class="s1">IterativeImputer</span><span class="s0">, </span><span class="s1">KNNImputer</span><span class="s0">, </span><span class="s1">MissingIndicator</span><span class="s0">, </span><span class="s1">SimpleImputer</span>
<span class="s0">from </span><span class="s1">sklearn.impute._base </span><span class="s0">import </span><span class="s1">_most_frequent</span>
<span class="s0">from </span><span class="s1">sklearn.linear_model </span><span class="s0">import </span><span class="s1">ARDRegression</span><span class="s0">, </span><span class="s1">BayesianRidge</span><span class="s0">, </span><span class="s1">RidgeCV</span>
<span class="s0">from </span><span class="s1">sklearn.model_selection </span><span class="s0">import </span><span class="s1">GridSearchCV</span>
<span class="s0">from </span><span class="s1">sklearn.pipeline </span><span class="s0">import </span><span class="s1">Pipeline</span><span class="s0">, </span><span class="s1">make_union</span>
<span class="s0">from </span><span class="s1">sklearn.random_projection </span><span class="s0">import </span><span class="s1">_sparse_random_matrix</span>
<span class="s0">from </span><span class="s1">sklearn.utils._testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_convert_container</span><span class="s0">,</span>
    <span class="s1">assert_allclose</span><span class="s0">,</span>
    <span class="s1">assert_allclose_dense_sparse</span><span class="s0">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s0">,</span>
    <span class="s1">assert_array_equal</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">_assert_array_equal_and_same_dtype(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s1">assert_array_equal(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s0">assert </span><span class="s1">x.dtype == y.dtype</span>


<span class="s0">def </span><span class="s1">_assert_allclose_and_same_dtype(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s0">assert </span><span class="s1">x.dtype == y.dtype</span>


<span class="s0">def </span><span class="s1">_check_statistics(X</span><span class="s0">, </span><span class="s1">X_true</span><span class="s0">, </span><span class="s1">strategy</span><span class="s0">, </span><span class="s1">statistics</span><span class="s0">, </span><span class="s1">missing_values):</span>
    <span class="s3">&quot;&quot;&quot;Utility function for testing imputation for a given strategy. 
 
    Test with dense and sparse arrays 
 
    Check that: 
        - the statistics (mean, median, mode) are correct 
        - the missing values are imputed correctly&quot;&quot;&quot;</span>

    <span class="s1">err_msg = </span><span class="s4">&quot;Parameters: strategy = %s, missing_values = %s, sparse = {0}&quot; </span><span class="s1">% (</span>
        <span class="s1">strategy</span><span class="s0">,</span>
        <span class="s1">missing_values</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">assert_ae = assert_array_equal</span>

    <span class="s0">if </span><span class="s1">X.dtype.kind == </span><span class="s4">&quot;f&quot; </span><span class="s0">or </span><span class="s1">X_true.dtype.kind == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s1">assert_ae = assert_array_almost_equal</span>

    <span class="s2"># Normal matrix</span>
    <span class="s1">imputer = SimpleImputer(missing_values=missing_values</span><span class="s0">, </span><span class="s1">strategy=strategy)</span>
    <span class="s1">X_trans = imputer.fit(X).transform(X.copy())</span>
    <span class="s1">assert_ae(imputer.statistics_</span><span class="s0">, </span><span class="s1">statistics</span><span class="s0">, </span><span class="s1">err_msg=err_msg.format(</span><span class="s0">False</span><span class="s1">))</span>
    <span class="s1">assert_ae(X_trans</span><span class="s0">, </span><span class="s1">X_true</span><span class="s0">, </span><span class="s1">err_msg=err_msg.format(</span><span class="s0">False</span><span class="s1">))</span>

    <span class="s2"># Sparse matrix</span>
    <span class="s1">imputer = SimpleImputer(missing_values=missing_values</span><span class="s0">, </span><span class="s1">strategy=strategy)</span>
    <span class="s1">imputer.fit(sparse.csc_matrix(X))</span>
    <span class="s1">X_trans = imputer.transform(sparse.csc_matrix(X.copy()))</span>

    <span class="s0">if </span><span class="s1">sparse.issparse(X_trans):</span>
        <span class="s1">X_trans = X_trans.toarray()</span>

    <span class="s1">assert_ae(imputer.statistics_</span><span class="s0">, </span><span class="s1">statistics</span><span class="s0">, </span><span class="s1">err_msg=err_msg.format(</span><span class="s0">True</span><span class="s1">))</span>
    <span class="s1">assert_ae(X_trans</span><span class="s0">, </span><span class="s1">X_true</span><span class="s0">, </span><span class="s1">err_msg=err_msg.format(</span><span class="s0">True</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s0">, </span><span class="s4">&quot;constant&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_shape(strategy):</span>
    <span class="s2"># Verify the shapes of the imputed matrix for different strategies.</span>
    <span class="s1">X = np.random.randn(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">X[::</span><span class="s5">2</span><span class="s1">] = np.nan</span>

    <span class="s1">imputer = SimpleImputer(strategy=strategy)</span>
    <span class="s1">X_imputed = imputer.fit_transform(sparse.csr_matrix(X))</span>
    <span class="s0">assert </span><span class="s1">X_imputed.shape == (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">X_imputed = imputer.fit_transform(X)</span>
    <span class="s0">assert </span><span class="s1">X_imputed.shape == (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">iterative_imputer = IterativeImputer(initial_strategy=strategy)</span>
    <span class="s1">X_imputed = iterative_imputer.fit_transform(X)</span>
    <span class="s0">assert </span><span class="s1">X_imputed.shape == (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_deletion_warning(strategy):</span>
    <span class="s1">X = np.ones((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s1">X[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
    <span class="s1">imputer = SimpleImputer(strategy=strategy).fit(X)</span>

    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Skipping&quot;</span><span class="s1">):</span>
        <span class="s1">imputer.transform(X)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_deletion_warning_feature_names(strategy):</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s4">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">missing_values = np.nan</span>
    <span class="s1">feature_names = np.array([</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">X = pd.DataFrame(</span>
        <span class="s1">[</span>
            <span class="s1">[missing_values</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">missing_values]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">columns=feature_names</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">imputer = SimpleImputer(strategy=strategy).fit(X)</span>

    <span class="s2"># check SimpleImputer returning feature name attribute correctly</span>
    <span class="s1">assert_array_equal(imputer.feature_names_in_</span><span class="s0">, </span><span class="s1">feature_names)</span>

    <span class="s2"># ensure that skipped feature warning includes feature name</span>
    <span class="s0">with </span><span class="s1">pytest.warns(</span>
        <span class="s1">UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Skipping features without any observed values: \['b'\]&quot;</span>
    <span class="s1">):</span>
        <span class="s1">imputer.transform(X)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s0">, </span><span class="s4">&quot;constant&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_error_sparse_0(strategy):</span>
    <span class="s2"># check that error are raised when missing_values = 0 and input is sparse</span>
    <span class="s1">X = np.ones((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s1">X[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>
    <span class="s1">X = sparse.csc_matrix(X)</span>

    <span class="s1">imputer = SimpleImputer(strategy=strategy</span><span class="s0">, </span><span class="s1">missing_values=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Provide a dense array&quot;</span><span class="s1">):</span>
        <span class="s1">imputer.fit(X)</span>

    <span class="s1">imputer.fit(X.toarray())</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Provide a dense array&quot;</span><span class="s1">):</span>
        <span class="s1">imputer.transform(X)</span>


<span class="s0">def </span><span class="s1">safe_median(arr</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s2"># np.median([]) raises a TypeError for numpy &gt;= 1.10.1</span>
    <span class="s1">length = arr.size </span><span class="s0">if </span><span class="s1">hasattr(arr</span><span class="s0">, </span><span class="s4">&quot;size&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">len(arr)</span>
    <span class="s0">return </span><span class="s1">np.nan </span><span class="s0">if </span><span class="s1">length == </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">np.median(arr</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">safe_mean(arr</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s2"># np.mean([]) raises a RuntimeWarning for numpy &gt;= 1.10.1</span>
    <span class="s1">length = arr.size </span><span class="s0">if </span><span class="s1">hasattr(arr</span><span class="s0">, </span><span class="s4">&quot;size&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">len(arr)</span>
    <span class="s0">return </span><span class="s1">np.nan </span><span class="s0">if </span><span class="s1">length == </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">np.mean(arr</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">test_imputation_mean_median():</span>
    <span class="s2"># Test imputation using the mean and median strategies, when</span>
    <span class="s2"># missing_values != 0.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">dim = </span><span class="s5">10</span>
    <span class="s1">dec = </span><span class="s5">10</span>
    <span class="s1">shape = (dim * dim</span><span class="s0">, </span><span class="s1">dim + dec)</span>

    <span class="s1">zeros = np.zeros(shape[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">values = np.arange(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">shape[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">values[</span><span class="s5">4</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = -values[</span><span class="s5">4</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>

    <span class="s1">tests = [</span>
        <span class="s1">(</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, lambda </span><span class="s1">z</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">p: safe_mean(np.hstack((z</span><span class="s0">, </span><span class="s1">v))))</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, lambda </span><span class="s1">z</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">p: safe_median(np.hstack((z</span><span class="s0">, </span><span class="s1">v))))</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s0">for </span><span class="s1">strategy</span><span class="s0">, </span><span class="s1">test_missing_values</span><span class="s0">, </span><span class="s1">true_value_fun </span><span class="s0">in </span><span class="s1">tests:</span>
        <span class="s1">X = np.empty(shape)</span>
        <span class="s1">X_true = np.empty(shape)</span>
        <span class="s1">true_statistics = np.empty(shape[</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s2"># Create a matrix X with columns</span>
        <span class="s2">#    - with only zeros,</span>
        <span class="s2">#    - with only missing values</span>
        <span class="s2">#    - with zeros, missing values and values</span>
        <span class="s2"># And a matrix X_true containing all true values</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(shape[</span><span class="s5">1</span><span class="s1">]):</span>
            <span class="s1">nb_zeros = (j - dec + </span><span class="s5">1 </span><span class="s1">&gt; </span><span class="s5">0</span><span class="s1">) * (j - dec + </span><span class="s5">1</span><span class="s1">) * (j - dec + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">nb_missing_values = max(shape[</span><span class="s5">0</span><span class="s1">] + dec * dec - (j + dec) * (j + dec)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">nb_values = shape[</span><span class="s5">0</span><span class="s1">] - nb_zeros - nb_missing_values</span>

            <span class="s1">z = zeros[:nb_zeros]</span>
            <span class="s1">p = np.repeat(test_missing_values</span><span class="s0">, </span><span class="s1">nb_missing_values)</span>
            <span class="s1">v = values[rng.permutation(len(values))[:nb_values]]</span>

            <span class="s1">true_statistics[j] = true_value_fun(z</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">p)</span>

            <span class="s2"># Create the columns</span>
            <span class="s1">X[:</span><span class="s0">, </span><span class="s1">j] = np.hstack((v</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">p))</span>

            <span class="s0">if </span><span class="s5">0 </span><span class="s1">== test_missing_values:</span>
                <span class="s2"># XXX unreached code as of v0.22</span>
                <span class="s1">X_true[:</span><span class="s0">, </span><span class="s1">j] = np.hstack(</span>
                    <span class="s1">(v</span><span class="s0">, </span><span class="s1">np.repeat(true_statistics[j]</span><span class="s0">, </span><span class="s1">nb_missing_values + nb_zeros))</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">X_true[:</span><span class="s0">, </span><span class="s1">j] = np.hstack(</span>
                    <span class="s1">(v</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">np.repeat(true_statistics[j]</span><span class="s0">, </span><span class="s1">nb_missing_values))</span>
                <span class="s1">)</span>

            <span class="s2"># Shuffle them the same way</span>
            <span class="s1">np.random.RandomState(j).shuffle(X[:</span><span class="s0">, </span><span class="s1">j])</span>
            <span class="s1">np.random.RandomState(j).shuffle(X_true[:</span><span class="s0">, </span><span class="s1">j])</span>

        <span class="s2"># Mean doesn't support columns containing NaNs, median does</span>
        <span class="s0">if </span><span class="s1">strategy == </span><span class="s4">&quot;median&quot;</span><span class="s1">:</span>
            <span class="s1">cols_to_keep = ~np.isnan(X_true).any(axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">cols_to_keep = ~np.isnan(X_true).all(axis=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">X_true = X_true[:</span><span class="s0">, </span><span class="s1">cols_to_keep]</span>

        <span class="s1">_check_statistics(X</span><span class="s0">, </span><span class="s1">X_true</span><span class="s0">, </span><span class="s1">strategy</span><span class="s0">, </span><span class="s1">true_statistics</span><span class="s0">, </span><span class="s1">test_missing_values)</span>


<span class="s0">def </span><span class="s1">test_imputation_median_special_cases():</span>
    <span class="s2"># Test median imputation with sparse boundary cases</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,  </span><span class="s2"># odd: implicit zero</span>
            <span class="s1">[</span><span class="s5">5</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,  </span><span class="s2"># odd: explicit nonzero</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,  </span><span class="s2"># even: average two zeros</span>
            <span class="s1">[-</span><span class="s5">5</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,  </span><span class="s2"># even: avg zero and neg</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,  </span><span class="s2"># even: avg zero and pos</span>
            <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,  </span><span class="s2"># even: avg nonzeros</span>
            <span class="s1">[-</span><span class="s5">4</span><span class="s0">, </span><span class="s1">-</span><span class="s5">5</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,  </span><span class="s2"># even: avg negatives</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,  </span><span class="s2"># even: crossing neg and pos</span>
        <span class="s1">]</span>
    <span class="s1">).transpose()</span>

    <span class="s1">X_imputed_median = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">5</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2.5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">2.5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">4.5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">4</span><span class="s0">, </span><span class="s1">-</span><span class="s5">5</span><span class="s0">, </span><span class="s1">-</span><span class="s5">4.5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">0.5</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">).transpose()</span>
    <span class="s1">statistics_median = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2.5</span><span class="s0">, </span><span class="s5">2.5</span><span class="s0">, </span><span class="s5">4.5</span><span class="s0">, </span><span class="s1">-</span><span class="s5">4.5</span><span class="s0">, </span><span class="s5">0.5</span><span class="s1">]</span>

    <span class="s1">_check_statistics(X</span><span class="s0">, </span><span class="s1">X_imputed_median</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s1">statistics_median</span><span class="s0">, </span><span class="s1">np.nan)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">object</span><span class="s0">, </span><span class="s1">str])</span>
<span class="s0">def </span><span class="s1">test_imputation_mean_median_error_invalid_type(strategy</span><span class="s0">, </span><span class="s1">dtype):</span>
    <span class="s1">X = np.array([[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s4">&quot;e&quot;</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s4">&quot;h&quot;</span><span class="s0">, </span><span class="s5">9</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">msg = </span><span class="s4">&quot;non-numeric data:</span><span class="s0">\n</span><span class="s4">could not convert string to float:&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">imputer = SimpleImputer(strategy=strategy)</span>
        <span class="s1">imputer.fit_transform(X)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;type&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;list&quot;</span><span class="s0">, </span><span class="s4">&quot;dataframe&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_mean_median_error_invalid_type_list_pandas(strategy</span><span class="s0">, </span><span class="s1">type):</span>
    <span class="s1">X = [[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s4">&quot;e&quot;</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s4">&quot;h&quot;</span><span class="s0">, </span><span class="s5">9</span><span class="s1">]]</span>
    <span class="s0">if </span><span class="s1">type == </span><span class="s4">&quot;dataframe&quot;</span><span class="s1">:</span>
        <span class="s1">pd = pytest.importorskip(</span><span class="s4">&quot;pandas&quot;</span><span class="s1">)</span>
        <span class="s1">X = pd.DataFrame(X)</span>
    <span class="s1">msg = </span><span class="s4">&quot;non-numeric data:</span><span class="s0">\n</span><span class="s4">could not convert string to float:&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">imputer = SimpleImputer(strategy=strategy)</span>
        <span class="s1">imputer.fit_transform(X)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[str</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s4">&quot;U&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s4">&quot;S&quot;</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_imputation_const_mostf_error_invalid_types(strategy</span><span class="s0">, </span><span class="s1">dtype):</span>
    <span class="s2"># Test imputation on non-numeric data using &quot;most_frequent&quot; and &quot;constant&quot;</span>
    <span class="s2"># strategy</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s4">&quot;h&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=dtype</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">err_msg = </span><span class="s4">&quot;SimpleImputer does not support data&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">imputer = SimpleImputer(strategy=strategy)</span>
        <span class="s1">imputer.fit(X).transform(X)</span>


<span class="s0">def </span><span class="s1">test_imputation_most_frequent():</span>
    <span class="s2"># Test imputation using the most-frequent strategy.</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">7</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">X_true = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">7</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s2"># scipy.stats.mode, used in SimpleImputer, doesn't return the first most</span>
    <span class="s2"># frequent as promised in the doc but the lowest most frequent. When this</span>
    <span class="s2"># test will fail after an update of scipy, SimpleImputer will need to be</span>
    <span class="s2"># updated to be consistent with the new (correct) behaviour</span>
    <span class="s1">_check_statistics(X</span><span class="s0">, </span><span class="s1">X_true</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;marker&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">&quot;NAN&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_most_frequent_objects(marker):</span>
    <span class="s2"># Test imputation using the most-frequent strategy.</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[marker</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[marker</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[marker</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s1">marker]</span><span class="s0">,</span>
            <span class="s1">[marker</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s4">&quot;h&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=object</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">X_true = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s4">&quot;h&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=object</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">imputer = SimpleImputer(missing_values=marker</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">)</span>
    <span class="s1">X_trans = imputer.fit(X).transform(X)</span>

    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">X_true)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[object</span><span class="s0">, </span><span class="s4">&quot;category&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_most_frequent_pandas(dtype):</span>
    <span class="s2"># Test imputation using the most frequent strategy on pandas df</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s4">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">f = io.StringIO(</span><span class="s4">&quot;Cat1,Cat2,Cat3,Cat4</span><span class="s0">\n</span><span class="s4">,i,x,</span><span class="s0">\n</span><span class="s4">a,,y,</span><span class="s0">\n</span><span class="s4">a,j,,</span><span class="s0">\n</span><span class="s4">b,j,x,&quot;</span><span class="s1">)</span>

    <span class="s1">df = pd.read_csv(f</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">X_true = np.array(</span>
        <span class="s1">[[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;j&quot;</span><span class="s0">, </span><span class="s4">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;j&quot;</span><span class="s0">, </span><span class="s4">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;j&quot;</span><span class="s0">, </span><span class="s4">&quot;x&quot;</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">dtype=object</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">imputer = SimpleImputer(strategy=</span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">)</span>
    <span class="s1">X_trans = imputer.fit_transform(df)</span>

    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">X_true)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;X_data, missing_value&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1.0</span><span class="s0">, </span><span class="s1">np.nan)])</span>
<span class="s0">def </span><span class="s1">test_imputation_constant_error_invalid_type(X_data</span><span class="s0">, </span><span class="s1">missing_value):</span>
    <span class="s2"># Verify that exceptions are raised on invalid fill_value type</span>
    <span class="s1">X = np.full((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">X_data</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">X[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = missing_value</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;imputing numerical&quot;</span><span class="s1">):</span>
        <span class="s1">imputer = SimpleImputer(</span>
            <span class="s1">missing_values=missing_value</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s4">&quot;x&quot;</span>
        <span class="s1">)</span>
        <span class="s1">imputer.fit_transform(X)</span>


<span class="s0">def </span><span class="s1">test_imputation_constant_integer():</span>
    <span class="s2"># Test imputation using the constant strategy on integers</span>
    <span class="s1">X = np.array([[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]])</span>

    <span class="s1">X_true = np.array([[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]])</span>

    <span class="s1">imputer = SimpleImputer(missing_values=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">X_trans = imputer.fit_transform(X)</span>

    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">X_true)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;array_constructor&quot;</span><span class="s0">, </span><span class="s1">[sparse.csr_matrix</span><span class="s0">, </span><span class="s1">np.asarray])</span>
<span class="s0">def </span><span class="s1">test_imputation_constant_float(array_constructor):</span>
    <span class="s2"># Test imputation using the constant strategy on floats</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">1.1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1.2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">1.3</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1.4</span><span class="s0">, </span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">X_true = np.array(</span>
        <span class="s1">[[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1.1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1.2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1.3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1.4</span><span class="s0">, </span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]]</span>
    <span class="s1">)</span>

    <span class="s1">X = array_constructor(X)</span>

    <span class="s1">X_true = array_constructor(X_true)</span>

    <span class="s1">imputer = SimpleImputer(strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">fill_value=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">X_trans = imputer.fit_transform(X)</span>

    <span class="s1">assert_allclose_dense_sparse(X_trans</span><span class="s0">, </span><span class="s1">X_true)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;marker&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">&quot;NAN&quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_constant_object(marker):</span>
    <span class="s2"># Test imputation using the constant strategy on objects</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[marker</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s1">marker]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s1">marker]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;e&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s1">marker]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s4">&quot;h&quot;</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s1">marker]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=object</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">X_true = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">&quot;missing&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;missing&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;missing&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s4">&quot;missing&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;e&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s0">, </span><span class="s4">&quot;missing&quot;</span><span class="s0">, </span><span class="s4">&quot;missing&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s4">&quot;h&quot;</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;missing&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=object</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">imputer = SimpleImputer(</span>
        <span class="s1">missing_values=marker</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s4">&quot;missing&quot;</span>
    <span class="s1">)</span>
    <span class="s1">X_trans = imputer.fit_transform(X)</span>

    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">X_true)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[object</span><span class="s0">, </span><span class="s4">&quot;category&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_imputation_constant_pandas(dtype):</span>
    <span class="s2"># Test imputation using the constant strategy on pandas df</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s4">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">f = io.StringIO(</span><span class="s4">&quot;Cat1,Cat2,Cat3,Cat4</span><span class="s0">\n</span><span class="s4">,i,x,</span><span class="s0">\n</span><span class="s4">a,,y,</span><span class="s0">\n</span><span class="s4">a,j,,</span><span class="s0">\n</span><span class="s4">b,j,x,&quot;</span><span class="s1">)</span>

    <span class="s1">df = pd.read_csv(f</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">X_true = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">&quot;missing_value&quot;</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s4">&quot;missing_value&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;missing_value&quot;</span><span class="s0">, </span><span class="s4">&quot;y&quot;</span><span class="s0">, </span><span class="s4">&quot;missing_value&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;j&quot;</span><span class="s0">, </span><span class="s4">&quot;missing_value&quot;</span><span class="s0">, </span><span class="s4">&quot;missing_value&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;j&quot;</span><span class="s0">, </span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s4">&quot;missing_value&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=object</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">imputer = SimpleImputer(strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s1">)</span>
    <span class="s1">X_trans = imputer.fit_transform(df)</span>

    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">X_true)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;X&quot;</span><span class="s0">, </span><span class="s1">[[[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan]]])</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_one_feature(X):</span>
    <span class="s2"># check we exit early when there is a single feature</span>
    <span class="s1">imputer = IterativeImputer().fit(X)</span>
    <span class="s0">assert </span><span class="s1">imputer.n_iter_ == </span><span class="s5">0</span>
    <span class="s1">imputer = IterativeImputer()</span>
    <span class="s1">imputer.fit([[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]])</span>
    <span class="s0">assert </span><span class="s1">imputer.n_iter_ == </span><span class="s5">0</span>
    <span class="s1">imputer.fit([[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan]])</span>
    <span class="s0">assert </span><span class="s1">imputer.n_iter_ == </span><span class="s5">0</span>


<span class="s0">def </span><span class="s1">test_imputation_pipeline_grid_search():</span>
    <span class="s2"># Test imputation within a pipeline + gridsearch.</span>
    <span class="s1">X = _sparse_random_matrix(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">100</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s1">)</span>
    <span class="s1">missing_values = X.data[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">pipeline = Pipeline(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">&quot;imputer&quot;</span><span class="s0">, </span><span class="s1">SimpleImputer(missing_values=missing_values))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;tree&quot;</span><span class="s0">, </span><span class="s1">tree.DecisionTreeRegressor(random_state=</span><span class="s5">0</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">parameters = {</span><span class="s4">&quot;imputer__strategy&quot;</span><span class="s1">: [</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">]}</span>

    <span class="s1">Y = _sparse_random_matrix(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s1">).toarray()</span>
    <span class="s1">gs = GridSearchCV(pipeline</span><span class="s0">, </span><span class="s1">parameters)</span>
    <span class="s1">gs.fit(X</span><span class="s0">, </span><span class="s1">Y)</span>


<span class="s0">def </span><span class="s1">test_imputation_copy():</span>
    <span class="s2"># Test imputation with copy</span>
    <span class="s1">X_orig = _sparse_random_matrix(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.75</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2"># copy=True, dense =&gt; copy</span>
    <span class="s1">X = X_orig.copy().toarray()</span>
    <span class="s1">imputer = SimpleImputer(missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">Xt = imputer.fit(X).transform(X)</span>
    <span class="s1">Xt[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1</span>
    <span class="s0">assert not </span><span class="s1">np.all(X == Xt)</span>

    <span class="s2"># copy=True, sparse csr =&gt; copy</span>
    <span class="s1">X = X_orig.copy()</span>
    <span class="s1">imputer = SimpleImputer(missing_values=X.data[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">Xt = imputer.fit(X).transform(X)</span>
    <span class="s1">Xt.data[</span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1</span>
    <span class="s0">assert not </span><span class="s1">np.all(X.data == Xt.data)</span>

    <span class="s2"># copy=False, dense =&gt; no copy</span>
    <span class="s1">X = X_orig.copy().toarray()</span>
    <span class="s1">imputer = SimpleImputer(missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">Xt = imputer.fit(X).transform(X)</span>
    <span class="s1">Xt[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1</span>
    <span class="s1">assert_array_almost_equal(X</span><span class="s0">, </span><span class="s1">Xt)</span>

    <span class="s2"># copy=False, sparse csc =&gt; no copy</span>
    <span class="s1">X = X_orig.copy().tocsc()</span>
    <span class="s1">imputer = SimpleImputer(missing_values=X.data[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">Xt = imputer.fit(X).transform(X)</span>
    <span class="s1">Xt.data[</span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1</span>
    <span class="s1">assert_array_almost_equal(X.data</span><span class="s0">, </span><span class="s1">Xt.data)</span>

    <span class="s2"># copy=False, sparse csr =&gt; copy</span>
    <span class="s1">X = X_orig.copy()</span>
    <span class="s1">imputer = SimpleImputer(missing_values=X.data[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">Xt = imputer.fit(X).transform(X)</span>
    <span class="s1">Xt.data[</span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1</span>
    <span class="s0">assert not </span><span class="s1">np.all(X.data == Xt.data)</span>

    <span class="s2"># Note: If X is sparse and if missing_values=0, then a (dense) copy of X is</span>
    <span class="s2"># made, even if copy=False.</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_zero_iters():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">10</span>
    <span class="s1">X = _sparse_random_matrix(n</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s0">, </span><span class="s1">random_state=rng).toarray()</span>
    <span class="s1">missing_flag = X == </span><span class="s5">0</span>
    <span class="s1">X[missing_flag] = np.nan</span>

    <span class="s1">imputer = IterativeImputer(max_iter=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">X_imputed = imputer.fit_transform(X)</span>
    <span class="s2"># with max_iter=0, only initial imputation is performed</span>
    <span class="s1">assert_allclose(X_imputed</span><span class="s0">, </span><span class="s1">imputer.initial_imputer_.transform(X))</span>

    <span class="s2"># repeat but force n_iter_ to 0</span>
    <span class="s1">imputer = IterativeImputer(max_iter=</span><span class="s5">5</span><span class="s1">).fit(X)</span>
    <span class="s2"># transformed should not be equal to initial imputation</span>
    <span class="s0">assert not </span><span class="s1">np.all(imputer.transform(X) == imputer.initial_imputer_.transform(X))</span>

    <span class="s1">imputer.n_iter_ = </span><span class="s5">0</span>
    <span class="s2"># now they should be equal as only initial imputation is done</span>
    <span class="s1">assert_allclose(imputer.transform(X)</span><span class="s0">, </span><span class="s1">imputer.initial_imputer_.transform(X))</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_verbose():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">3</span>
    <span class="s1">X = _sparse_random_matrix(n</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s0">, </span><span class="s1">random_state=rng).toarray()</span>
    <span class="s1">imputer = IterativeImputer(missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_iter=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">verbose=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">imputer.fit(X)</span>
    <span class="s1">imputer.transform(X)</span>
    <span class="s1">imputer = IterativeImputer(missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_iter=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">verbose=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">imputer.fit(X)</span>
    <span class="s1">imputer.transform(X)</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_all_missing():</span>
    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">3</span>
    <span class="s1">X = np.zeros((n</span><span class="s0">, </span><span class="s1">d))</span>
    <span class="s1">imputer = IterativeImputer(missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_iter=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">X_imputed = imputer.fit_transform(X)</span>
    <span class="s1">assert_allclose(X_imputed</span><span class="s0">, </span><span class="s1">imputer.initial_imputer_.transform(X))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;imputation_order&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;random&quot;</span><span class="s0">, </span><span class="s4">&quot;roman&quot;</span><span class="s0">, </span><span class="s4">&quot;ascending&quot;</span><span class="s0">, </span><span class="s4">&quot;descending&quot;</span><span class="s0">, </span><span class="s4">&quot;arabic&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_imputation_order(imputation_order):</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">10</span>
    <span class="s1">max_iter = </span><span class="s5">2</span>
    <span class="s1">X = _sparse_random_matrix(n</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s0">, </span><span class="s1">random_state=rng).toarray()</span>
    <span class="s1">X[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1  </span><span class="s2"># this column should not be discarded by IterativeImputer</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">missing_values=</span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">max_iter=max_iter</span><span class="s0">,</span>
        <span class="s1">n_nearest_features=</span><span class="s5">5</span><span class="s0">,</span>
        <span class="s1">sample_posterior=</span><span class="s0">False,</span>
        <span class="s1">skip_complete=</span><span class="s0">True,</span>
        <span class="s1">min_value=</span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">max_value=</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">verbose=</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">imputation_order=imputation_order</span><span class="s0">,</span>
        <span class="s1">random_state=rng</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">imputer.fit_transform(X)</span>
    <span class="s1">ordered_idx = [i.feat_idx </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">imputer.imputation_sequence_]</span>

    <span class="s0">assert </span><span class="s1">len(ordered_idx) // imputer.n_iter_ == imputer.n_features_with_missing_</span>

    <span class="s0">if </span><span class="s1">imputation_order == </span><span class="s4">&quot;roman&quot;</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">np.all(ordered_idx[: d - </span><span class="s5">1</span><span class="s1">] == np.arange(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">d))</span>
    <span class="s0">elif </span><span class="s1">imputation_order == </span><span class="s4">&quot;arabic&quot;</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">np.all(ordered_idx[: d - </span><span class="s5">1</span><span class="s1">] == np.arange(d - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s0">elif </span><span class="s1">imputation_order == </span><span class="s4">&quot;random&quot;</span><span class="s1">:</span>
        <span class="s1">ordered_idx_round_1 = ordered_idx[: d - </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">ordered_idx_round_2 = ordered_idx[d - </span><span class="s5">1 </span><span class="s1">:]</span>
        <span class="s0">assert </span><span class="s1">ordered_idx_round_1 != ordered_idx_round_2</span>
    <span class="s0">elif </span><span class="s4">&quot;ending&quot; </span><span class="s0">in </span><span class="s1">imputation_order:</span>
        <span class="s0">assert </span><span class="s1">len(ordered_idx) == max_iter * (d - </span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;estimator&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">DummyRegressor()</span><span class="s0">, </span><span class="s1">BayesianRidge()</span><span class="s0">, </span><span class="s1">ARDRegression()</span><span class="s0">, </span><span class="s1">RidgeCV()]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_estimators(estimator):</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">10</span>
    <span class="s1">X = _sparse_random_matrix(n</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s0">, </span><span class="s1">random_state=rng).toarray()</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_iter=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">estimator=estimator</span><span class="s0">, </span><span class="s1">random_state=rng</span>
    <span class="s1">)</span>
    <span class="s1">imputer.fit_transform(X)</span>

    <span class="s2"># check that types are correct for estimators</span>
    <span class="s1">hashes = []</span>
    <span class="s0">for </span><span class="s1">triplet </span><span class="s0">in </span><span class="s1">imputer.imputation_sequence_:</span>
        <span class="s1">expected_type = (</span>
            <span class="s1">type(estimator) </span><span class="s0">if </span><span class="s1">estimator </span><span class="s0">is not None else </span><span class="s1">type(BayesianRidge())</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">isinstance(triplet.estimator</span><span class="s0">, </span><span class="s1">expected_type)</span>
        <span class="s1">hashes.append(id(triplet.estimator))</span>

    <span class="s2"># check that each estimator is unique</span>
    <span class="s0">assert </span><span class="s1">len(set(hashes)) == len(hashes)</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_clip():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">10</span>
    <span class="s1">X = _sparse_random_matrix(n</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s0">, </span><span class="s1">random_state=rng).toarray()</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_iter=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">min_value=</span><span class="s5">0.1</span><span class="s0">, </span><span class="s1">max_value=</span><span class="s5">0.2</span><span class="s0">, </span><span class="s1">random_state=rng</span>
    <span class="s1">)</span>

    <span class="s1">Xt = imputer.fit_transform(X)</span>
    <span class="s1">assert_allclose(np.min(Xt[X == </span><span class="s5">0</span><span class="s1">])</span><span class="s0">, </span><span class="s5">0.1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(np.max(Xt[X == </span><span class="s5">0</span><span class="s1">])</span><span class="s0">, </span><span class="s5">0.2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(Xt[X != </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">X[X != </span><span class="s5">0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_clip_truncnorm():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">10</span>
    <span class="s1">X = _sparse_random_matrix(n</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s0">, </span><span class="s1">random_state=rng).toarray()</span>
    <span class="s1">X[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">missing_values=</span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">max_iter=</span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">n_nearest_features=</span><span class="s5">5</span><span class="s0">,</span>
        <span class="s1">sample_posterior=</span><span class="s0">True,</span>
        <span class="s1">min_value=</span><span class="s5">0.1</span><span class="s0">,</span>
        <span class="s1">max_value=</span><span class="s5">0.2</span><span class="s0">,</span>
        <span class="s1">verbose=</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">imputation_order=</span><span class="s4">&quot;random&quot;</span><span class="s0">,</span>
        <span class="s1">random_state=rng</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">Xt = imputer.fit_transform(X)</span>
    <span class="s1">assert_allclose(np.min(Xt[X == </span><span class="s5">0</span><span class="s1">])</span><span class="s0">, </span><span class="s5">0.1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(np.max(Xt[X == </span><span class="s5">0</span><span class="s1">])</span><span class="s0">, </span><span class="s5">0.2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(Xt[X != </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">X[X != </span><span class="s5">0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_truncated_normal_posterior():</span>
    <span class="s2">#  test that the values that are imputed using `sample_posterior=True`</span>
    <span class="s2">#  with boundaries (`min_value` and `max_value` are not None) are drawn</span>
    <span class="s2">#  from a distribution that looks gaussian via the Kolmogorov Smirnov test.</span>
    <span class="s2">#  note that starting from the wrong random seed will make this test fail</span>
    <span class="s2">#  because random sampling doesn't occur at all when the imputation</span>
    <span class="s2">#  is outside of the (min_value, max_value) range</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">42</span><span class="s1">)</span>

    <span class="s1">X = rng.normal(size=(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s1">X[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] = np.nan</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">min_value=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_value=</span><span class="s5">0.5</span><span class="s0">, </span><span class="s1">sample_posterior=</span><span class="s0">True, </span><span class="s1">random_state=rng</span>
    <span class="s1">)</span>

    <span class="s1">imputer.fit_transform(X)</span>
    <span class="s2"># generate multiple imputations for the single missing value</span>
    <span class="s1">imputations = np.array([imputer.transform(X)[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">100</span><span class="s1">)])</span>

    <span class="s0">assert </span><span class="s1">all(imputations &gt;= </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">all(imputations &lt;= </span><span class="s5">0.5</span><span class="s1">)</span>

    <span class="s1">mu</span><span class="s0">, </span><span class="s1">sigma = imputations.mean()</span><span class="s0">, </span><span class="s1">imputations.std()</span>
    <span class="s1">ks_statistic</span><span class="s0">, </span><span class="s1">p_value = kstest((imputations - mu) / sigma</span><span class="s0">, </span><span class="s4">&quot;norm&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">sigma == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">sigma += </span><span class="s5">1e-12</span>
    <span class="s1">ks_statistic</span><span class="s0">, </span><span class="s1">p_value = kstest((imputations - mu) / sigma</span><span class="s0">, </span><span class="s4">&quot;norm&quot;</span><span class="s1">)</span>
    <span class="s2"># we want to fail to reject null hypothesis</span>
    <span class="s2"># null hypothesis: distributions are the same</span>
    <span class="s0">assert </span><span class="s1">ks_statistic &lt; </span><span class="s5">0.2 </span><span class="s0">or </span><span class="s1">p_value &gt; </span><span class="s5">0.1</span><span class="s0">, </span><span class="s4">&quot;The posterior does appear to be normal&quot;</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_missing_at_transform(strategy):</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">10</span>
    <span class="s1">X_train = rng.randint(low=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">high=</span><span class="s5">3</span><span class="s0">, </span><span class="s1">size=(n</span><span class="s0">, </span><span class="s1">d))</span>
    <span class="s1">X_test = rng.randint(low=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">high=</span><span class="s5">3</span><span class="s0">, </span><span class="s1">size=(n</span><span class="s0">, </span><span class="s1">d))</span>

    <span class="s1">X_train[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1  </span><span class="s2"># definitely no missing values in 0th column</span>
    <span class="s1">X_test[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0  </span><span class="s2"># definitely missing value in 0th column</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_iter=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">initial_strategy=strategy</span><span class="s0">, </span><span class="s1">random_state=rng</span>
    <span class="s1">).fit(X_train)</span>
    <span class="s1">initial_imputer = SimpleImputer(missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">strategy=strategy).fit(X_train)</span>

    <span class="s2"># if there were no missing values at time of fit, then imputer will</span>
    <span class="s2"># only use the initial imputer for that feature at transform</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">imputer.transform(X_test)[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">initial_imputer.transform(X_test)[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_transform_stochasticity():</span>
    <span class="s1">rng1 = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">rng2 = np.random.RandomState(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">10</span>
    <span class="s1">X = _sparse_random_matrix(n</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">density=</span><span class="s5">0.10</span><span class="s0">, </span><span class="s1">random_state=rng1).toarray()</span>

    <span class="s2"># when sample_posterior=True, two transforms shouldn't be equal</span>
    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">missing_values=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">max_iter=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">sample_posterior=</span><span class="s0">True, </span><span class="s1">random_state=rng1</span>
    <span class="s1">)</span>
    <span class="s1">imputer.fit(X)</span>

    <span class="s1">X_fitted_1 = imputer.transform(X)</span>
    <span class="s1">X_fitted_2 = imputer.transform(X)</span>

    <span class="s2"># sufficient to assert that the means are not the same</span>
    <span class="s0">assert </span><span class="s1">np.mean(X_fitted_1) != pytest.approx(np.mean(X_fitted_2))</span>

    <span class="s2"># when sample_posterior=False, and n_nearest_features=None</span>
    <span class="s2"># and imputation_order is not random</span>
    <span class="s2"># the two transforms should be identical even if rng are different</span>
    <span class="s1">imputer1 = IterativeImputer(</span>
        <span class="s1">missing_values=</span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">max_iter=</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">sample_posterior=</span><span class="s0">False,</span>
        <span class="s1">n_nearest_features=</span><span class="s0">None,</span>
        <span class="s1">imputation_order=</span><span class="s4">&quot;ascending&quot;</span><span class="s0">,</span>
        <span class="s1">random_state=rng1</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">imputer2 = IterativeImputer(</span>
        <span class="s1">missing_values=</span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">max_iter=</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">sample_posterior=</span><span class="s0">False,</span>
        <span class="s1">n_nearest_features=</span><span class="s0">None,</span>
        <span class="s1">imputation_order=</span><span class="s4">&quot;ascending&quot;</span><span class="s0">,</span>
        <span class="s1">random_state=rng2</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">imputer1.fit(X)</span>
    <span class="s1">imputer2.fit(X)</span>

    <span class="s1">X_fitted_1a = imputer1.transform(X)</span>
    <span class="s1">X_fitted_1b = imputer1.transform(X)</span>
    <span class="s1">X_fitted_2 = imputer2.transform(X)</span>

    <span class="s1">assert_allclose(X_fitted_1a</span><span class="s0">, </span><span class="s1">X_fitted_1b)</span>
    <span class="s1">assert_allclose(X_fitted_1a</span><span class="s0">, </span><span class="s1">X_fitted_2)</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_no_missing():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">X[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
    <span class="s1">m1 = IterativeImputer(max_iter=</span><span class="s5">10</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
    <span class="s1">m2 = IterativeImputer(max_iter=</span><span class="s5">10</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
    <span class="s1">pred1 = m1.fit(X).transform(X)</span>
    <span class="s1">pred2 = m2.fit_transform(X)</span>
    <span class="s2"># should exclude the first column entirely</span>
    <span class="s1">assert_allclose(X[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">pred1)</span>
    <span class="s2"># fit and fit_transform should both be identical</span>
    <span class="s1">assert_allclose(pred1</span><span class="s0">, </span><span class="s1">pred2)</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_rank_one():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">d = </span><span class="s5">50</span>
    <span class="s1">A = rng.rand(d</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">B = rng.rand(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">d)</span>
    <span class="s1">X = np.dot(A</span><span class="s0">, </span><span class="s1">B)</span>
    <span class="s1">nan_mask = rng.rand(d</span><span class="s0">, </span><span class="s1">d) &lt; </span><span class="s5">0.5</span>
    <span class="s1">X_missing = X.copy()</span>
    <span class="s1">X_missing[nan_mask] = np.nan</span>

    <span class="s1">imputer = IterativeImputer(max_iter=</span><span class="s5">5</span><span class="s0">, </span><span class="s1">verbose=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
    <span class="s1">X_filled = imputer.fit_transform(X_missing)</span>
    <span class="s1">assert_allclose(X_filled</span><span class="s0">, </span><span class="s1">X</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">0.02</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;rank&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_transform_recovery(rank):</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">70</span>
    <span class="s1">d = </span><span class="s5">70</span>
    <span class="s1">A = rng.rand(n</span><span class="s0">, </span><span class="s1">rank)</span>
    <span class="s1">B = rng.rand(rank</span><span class="s0">, </span><span class="s1">d)</span>
    <span class="s1">X_filled = np.dot(A</span><span class="s0">, </span><span class="s1">B)</span>
    <span class="s1">nan_mask = rng.rand(n</span><span class="s0">, </span><span class="s1">d) &lt; </span><span class="s5">0.5</span>
    <span class="s1">X_missing = X_filled.copy()</span>
    <span class="s1">X_missing[nan_mask] = np.nan</span>

    <span class="s2"># split up data in half</span>
    <span class="s1">n = n // </span><span class="s5">2</span>
    <span class="s1">X_train = X_missing[:n]</span>
    <span class="s1">X_test_filled = X_filled[n:]</span>
    <span class="s1">X_test = X_missing[n:]</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">max_iter=</span><span class="s5">5</span><span class="s0">, </span><span class="s1">imputation_order=</span><span class="s4">&quot;descending&quot;</span><span class="s0">, </span><span class="s1">verbose=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">random_state=rng</span>
    <span class="s1">).fit(X_train)</span>
    <span class="s1">X_test_est = imputer.transform(X_test)</span>
    <span class="s1">assert_allclose(X_test_filled</span><span class="s0">, </span><span class="s1">X_test_est</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">0.1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_additive_matrix():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">d = </span><span class="s5">10</span>
    <span class="s1">A = rng.randn(n</span><span class="s0">, </span><span class="s1">d)</span>
    <span class="s1">B = rng.randn(n</span><span class="s0">, </span><span class="s1">d)</span>
    <span class="s1">X_filled = np.zeros(A.shape)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(d):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(d):</span>
            <span class="s1">X_filled[:</span><span class="s0">, </span><span class="s1">(i + j) % d] += (A[:</span><span class="s0">, </span><span class="s1">i] + B[:</span><span class="s0">, </span><span class="s1">j]) / </span><span class="s5">2</span>
    <span class="s2"># a quarter is randomly missing</span>
    <span class="s1">nan_mask = rng.rand(n</span><span class="s0">, </span><span class="s1">d) &lt; </span><span class="s5">0.25</span>
    <span class="s1">X_missing = X_filled.copy()</span>
    <span class="s1">X_missing[nan_mask] = np.nan</span>

    <span class="s2"># split up data</span>
    <span class="s1">n = n // </span><span class="s5">2</span>
    <span class="s1">X_train = X_missing[:n]</span>
    <span class="s1">X_test_filled = X_filled[n:]</span>
    <span class="s1">X_test = X_missing[n:]</span>

    <span class="s1">imputer = IterativeImputer(max_iter=</span><span class="s5">10</span><span class="s0">, </span><span class="s1">verbose=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">random_state=rng).fit(X_train)</span>
    <span class="s1">X_test_est = imputer.transform(X_test)</span>
    <span class="s1">assert_allclose(X_test_filled</span><span class="s0">, </span><span class="s1">X_test_est</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">0.01</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_early_stopping():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">50</span>
    <span class="s1">d = </span><span class="s5">5</span>
    <span class="s1">A = rng.rand(n</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">B = rng.rand(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">d)</span>
    <span class="s1">X = np.dot(A</span><span class="s0">, </span><span class="s1">B)</span>
    <span class="s1">nan_mask = rng.rand(n</span><span class="s0">, </span><span class="s1">d) &lt; </span><span class="s5">0.5</span>
    <span class="s1">X_missing = X.copy()</span>
    <span class="s1">X_missing[nan_mask] = np.nan</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">max_iter=</span><span class="s5">100</span><span class="s0">, </span><span class="s1">tol=</span><span class="s5">1e-2</span><span class="s0">, </span><span class="s1">sample_posterior=</span><span class="s0">False, </span><span class="s1">verbose=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">random_state=rng</span>
    <span class="s1">)</span>
    <span class="s1">X_filled_100 = imputer.fit_transform(X_missing)</span>
    <span class="s0">assert </span><span class="s1">len(imputer.imputation_sequence_) == d * imputer.n_iter_</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">max_iter=imputer.n_iter_</span><span class="s0">, </span><span class="s1">sample_posterior=</span><span class="s0">False, </span><span class="s1">verbose=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">random_state=rng</span>
    <span class="s1">)</span>
    <span class="s1">X_filled_early = imputer.fit_transform(X_missing)</span>
    <span class="s1">assert_allclose(X_filled_100</span><span class="s0">, </span><span class="s1">X_filled_early</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">max_iter=</span><span class="s5">100</span><span class="s0">, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">sample_posterior=</span><span class="s0">False, </span><span class="s1">verbose=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">random_state=rng</span>
    <span class="s1">)</span>
    <span class="s1">imputer.fit(X_missing)</span>
    <span class="s0">assert </span><span class="s1">imputer.n_iter_ == imputer.max_iter</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_catch_warning():</span>
    <span class="s2"># check that we catch a RuntimeWarning due to a division by zero when a</span>
    <span class="s2"># feature is constant in the dataset</span>
    <span class="s1">X</span><span class="s0">, </span><span class="s1">y = load_diabetes(return_X_y=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">n_samples</span><span class="s0">, </span><span class="s1">n_features = X.shape</span>

    <span class="s2"># simulate that a feature only contain one category during fit</span>
    <span class="s1">X[:</span><span class="s0">, </span><span class="s5">3</span><span class="s1">] = </span><span class="s5">1</span>

    <span class="s2"># add some missing values</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">missing_rate = </span><span class="s5">0.15</span>
    <span class="s0">for </span><span class="s1">feat </span><span class="s0">in </span><span class="s1">range(n_features):</span>
        <span class="s1">sample_idx = rng.choice(</span>
            <span class="s1">np.arange(n_samples)</span><span class="s0">, </span><span class="s1">size=int(n_samples * missing_rate)</span><span class="s0">, </span><span class="s1">replace=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s1">X[sample_idx</span><span class="s0">, </span><span class="s1">feat] = np.nan</span>

    <span class="s1">imputer = IterativeImputer(n_nearest_features=</span><span class="s5">5</span><span class="s0">, </span><span class="s1">sample_posterior=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;error&quot;</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>
        <span class="s1">X_fill = imputer.fit_transform(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s0">assert not </span><span class="s1">np.any(np.isnan(X_fill))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;min_value, max_value, correct_output&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">100</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s5">0</span><span class="s1">] * </span><span class="s5">3</span><span class="s0">, </span><span class="s1">[</span><span class="s5">100</span><span class="s1">] * </span><span class="s5">3</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s0">None, None, </span><span class="s1">np.array([[-np.inf] * </span><span class="s5">3</span><span class="s0">, </span><span class="s1">[np.inf] * </span><span class="s5">3</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">(-np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.array([[-np.inf] * </span><span class="s5">3</span><span class="s0">, </span><span class="s1">[np.inf] * </span><span class="s5">3</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">([-</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">100</span><span class="s0">, </span><span class="s5">200</span><span class="s0">, </span><span class="s5">300</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([[-</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">100</span><span class="s0">, </span><span class="s5">200</span><span class="s0">, </span><span class="s5">300</span><span class="s1">]]))</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">[-</span><span class="s5">5</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">100</span><span class="s0">, </span><span class="s5">200</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">,</span>
            <span class="s1">np.array([[-</span><span class="s5">5</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">100</span><span class="s0">, </span><span class="s5">200</span><span class="s0">, </span><span class="s1">np.inf]])</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">ids=[</span><span class="s4">&quot;scalars&quot;</span><span class="s0">, </span><span class="s4">&quot;None-default&quot;</span><span class="s0">, </span><span class="s4">&quot;inf&quot;</span><span class="s0">, </span><span class="s4">&quot;lists&quot;</span><span class="s0">, </span><span class="s4">&quot;lists-with-inf&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_min_max_array_like(min_value</span><span class="s0">, </span><span class="s1">max_value</span><span class="s0">, </span><span class="s1">correct_output):</span>
    <span class="s2"># check that passing scalar or array-like</span>
    <span class="s2"># for min_value and max_value in IterativeImputer works</span>
    <span class="s1">X = np.random.RandomState(</span><span class="s5">0</span><span class="s1">).randn(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">imputer = IterativeImputer(min_value=min_value</span><span class="s0">, </span><span class="s1">max_value=max_value)</span>
    <span class="s1">imputer.fit(X)</span>

    <span class="s0">assert </span><span class="s1">isinstance(imputer._min_value</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">isinstance(</span>
        <span class="s1">imputer._max_value</span><span class="s0">, </span><span class="s1">np.ndarray</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">(imputer._min_value.shape[</span><span class="s5">0</span><span class="s1">] == X.shape[</span><span class="s5">1</span><span class="s1">]) </span><span class="s0">and </span><span class="s1">(</span>
        <span class="s1">imputer._max_value.shape[</span><span class="s5">0</span><span class="s1">] == X.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">assert_allclose(correct_output[</span><span class="s5">0</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">imputer._min_value)</span>
    <span class="s1">assert_allclose(correct_output[</span><span class="s5">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">imputer._max_value)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;min_value, max_value, err_msg&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s4">&quot;min_value &gt;= max_value.&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">&quot;min_value &gt;= max_value.&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([-</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">100</span><span class="s0">, </span><span class="s5">200</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">&quot;_value' should be of shape&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_catch_min_max_error(min_value</span><span class="s0">, </span><span class="s1">max_value</span><span class="s0">, </span><span class="s1">err_msg):</span>
    <span class="s2"># check that passing scalar or array-like</span>
    <span class="s2"># for min_value and max_value in IterativeImputer works</span>
    <span class="s1">X = np.random.random((</span><span class="s5">10</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">imputer = IterativeImputer(min_value=min_value</span><span class="s0">, </span><span class="s1">max_value=max_value)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">imputer.fit(X)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;min_max_1, min_max_2&quot;</span><span class="s0">,</span>
    <span class="s1">[([</span><span class="s0">None, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-np.inf</span><span class="s0">, </span><span class="s1">np.inf])</span><span class="s0">, </span><span class="s1">([-</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[-</span><span class="s5">10</span><span class="s1">] * </span><span class="s5">4</span><span class="s0">, </span><span class="s1">[</span><span class="s5">10</span><span class="s1">] * </span><span class="s5">4</span><span class="s1">])]</span><span class="s0">,</span>
    <span class="s1">ids=[</span><span class="s4">&quot;None-vs-inf&quot;</span><span class="s0">, </span><span class="s4">&quot;Scalar-vs-vector&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_min_max_array_like_imputation(min_max_1</span><span class="s0">, </span><span class="s1">min_max_2):</span>
    <span class="s2"># Test that None/inf and scalar/vector give the same imputation</span>
    <span class="s1">X_train = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">10</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">7</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">X_test = np.array(</span>
        <span class="s1">[[np.nan</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]]</span>
    <span class="s1">)</span>
    <span class="s1">imputer1 = IterativeImputer(</span>
        <span class="s1">min_value=min_max_1[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">max_value=min_max_1[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s5">0</span>
    <span class="s1">)</span>
    <span class="s1">imputer2 = IterativeImputer(</span>
        <span class="s1">min_value=min_max_2[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">max_value=min_max_2[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s5">0</span>
    <span class="s1">)</span>
    <span class="s1">X_test_imputed1 = imputer1.fit(X_train).transform(X_test)</span>
    <span class="s1">X_test_imputed2 = imputer2.fit(X_train).transform(X_test)</span>
    <span class="s1">assert_allclose(X_test_imputed1[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">X_test_imputed2[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;skip_complete&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_skip_non_missing(skip_complete):</span>
    <span class="s2"># check the imputing strategy when missing data are present in the</span>
    <span class="s2"># testing set only.</span>
    <span class="s2"># taken from: https://github.com/scikit-learn/scikit-learn/issues/14383</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">X_train = np.array([[</span><span class="s5">5</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">10</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">8</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]])</span>
    <span class="s1">X_test = np.array([[np.nan</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">initial_strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">skip_complete=skip_complete</span><span class="s0">, </span><span class="s1">random_state=rng</span>
    <span class="s1">)</span>
    <span class="s1">X_test_est = imputer.fit(X_train).transform(X_test)</span>
    <span class="s0">if </span><span class="s1">skip_complete:</span>
        <span class="s2"># impute with the initial strategy: 'mean'</span>
        <span class="s1">assert_allclose(X_test_est[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.mean(X_train[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">assert_allclose(X_test_est[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">11</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;rs_imputer&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.random.RandomState(seed=</span><span class="s5">1</span><span class="s1">)])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;rs_estimator&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.random.RandomState(seed=</span><span class="s5">1</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_dont_set_random_state(rs_imputer</span><span class="s0">, </span><span class="s1">rs_estimator):</span>
    <span class="s0">class </span><span class="s1">ZeroEstimator:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">random_state):</span>
            <span class="s1">self.random_state = random_state</span>

        <span class="s0">def </span><span class="s1">fit(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kgards):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">def </span><span class="s1">predict(self</span><span class="s0">, </span><span class="s1">X):</span>
            <span class="s0">return </span><span class="s1">np.zeros(X.shape[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s1">estimator = ZeroEstimator(random_state=rs_estimator)</span>
    <span class="s1">imputer = IterativeImputer(random_state=rs_imputer)</span>
    <span class="s1">X_train = np.zeros((</span><span class="s5">10</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">imputer.fit(X_train)</span>
    <span class="s0">assert </span><span class="s1">estimator.random_state == rs_estimator</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;X_fit, X_trans, params, msg_err&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">np.array([[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">np.array([[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s4">&quot;features&quot;</span><span class="s1">: </span><span class="s4">&quot;missing-only&quot;</span><span class="s0">, </span><span class="s4">&quot;sparse&quot;</span><span class="s1">: </span><span class="s4">&quot;auto&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s4">&quot;have missing values in transform but have no missing values in fit&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">np.array([[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=str)</span><span class="s0">,</span>
            <span class="s1">np.array([[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=str)</span><span class="s0">,</span>
            <span class="s1">{}</span><span class="s0">,</span>
            <span class="s4">&quot;MissingIndicator does not support data with dtype&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_missing_indicator_error(X_fit</span><span class="s0">, </span><span class="s1">X_trans</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">msg_err):</span>
    <span class="s1">indicator = MissingIndicator(missing_values=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">indicator.set_params(**params)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg_err):</span>
        <span class="s1">indicator.fit(X_fit).transform(X_trans)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;missing_values, dtype, arr_type&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.array)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">np.array)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">np.array)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">sparse.csc_matrix)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">sparse.csc_matrix)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">sparse.csr_matrix)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">sparse.csr_matrix)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">sparse.coo_matrix)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">sparse.coo_matrix)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">sparse.lil_matrix)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">sparse.lil_matrix)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">sparse.bsr_matrix)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">sparse.bsr_matrix)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;param_features, n_features, features_indices&quot;</span><span class="s0">,</span>
    <span class="s1">[(</span><span class="s4">&quot;missing-only&quot;</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]))]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_missing_indicator_new(</span>
    <span class="s1">missing_values</span><span class="s0">, </span><span class="s1">arr_type</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">param_features</span><span class="s0">, </span><span class="s1">n_features</span><span class="s0">, </span><span class="s1">features_indices</span>
<span class="s1">):</span>
    <span class="s1">X_fit = np.array([[missing_values</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">missing_values]])</span>
    <span class="s1">X_trans = np.array([[missing_values</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]])</span>
    <span class="s1">X_fit_expected = np.array([[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">X_trans_expected = np.array([[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]])</span>

    <span class="s2"># convert the input to the right array format and right dtype</span>
    <span class="s1">X_fit = arr_type(X_fit).astype(dtype)</span>
    <span class="s1">X_trans = arr_type(X_trans).astype(dtype)</span>
    <span class="s1">X_fit_expected = X_fit_expected.astype(dtype)</span>
    <span class="s1">X_trans_expected = X_trans_expected.astype(dtype)</span>

    <span class="s1">indicator = MissingIndicator(</span>
        <span class="s1">missing_values=missing_values</span><span class="s0">, </span><span class="s1">features=param_features</span><span class="s0">, </span><span class="s1">sparse=</span><span class="s0">False</span>
    <span class="s1">)</span>
    <span class="s1">X_fit_mask = indicator.fit_transform(X_fit)</span>
    <span class="s1">X_trans_mask = indicator.transform(X_trans)</span>

    <span class="s0">assert </span><span class="s1">X_fit_mask.shape[</span><span class="s5">1</span><span class="s1">] == n_features</span>
    <span class="s0">assert </span><span class="s1">X_trans_mask.shape[</span><span class="s5">1</span><span class="s1">] == n_features</span>

    <span class="s1">assert_array_equal(indicator.features_</span><span class="s0">, </span><span class="s1">features_indices)</span>
    <span class="s1">assert_allclose(X_fit_mask</span><span class="s0">, </span><span class="s1">X_fit_expected[:</span><span class="s0">, </span><span class="s1">features_indices])</span>
    <span class="s1">assert_allclose(X_trans_mask</span><span class="s0">, </span><span class="s1">X_trans_expected[:</span><span class="s0">, </span><span class="s1">features_indices])</span>

    <span class="s0">assert </span><span class="s1">X_fit_mask.dtype == bool</span>
    <span class="s0">assert </span><span class="s1">X_trans_mask.dtype == bool</span>
    <span class="s0">assert </span><span class="s1">isinstance(X_fit_mask</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
    <span class="s0">assert </span><span class="s1">isinstance(X_trans_mask</span><span class="s0">, </span><span class="s1">np.ndarray)</span>

    <span class="s1">indicator.set_params(sparse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">X_fit_mask_sparse = indicator.fit_transform(X_fit)</span>
    <span class="s1">X_trans_mask_sparse = indicator.transform(X_trans)</span>

    <span class="s0">assert </span><span class="s1">X_fit_mask_sparse.dtype == bool</span>
    <span class="s0">assert </span><span class="s1">X_trans_mask_sparse.dtype == bool</span>
    <span class="s0">assert </span><span class="s1">X_fit_mask_sparse.format == </span><span class="s4">&quot;csc&quot;</span>
    <span class="s0">assert </span><span class="s1">X_trans_mask_sparse.format == </span><span class="s4">&quot;csc&quot;</span>
    <span class="s1">assert_allclose(X_fit_mask_sparse.toarray()</span><span class="s0">, </span><span class="s1">X_fit_mask)</span>
    <span class="s1">assert_allclose(X_trans_mask_sparse.toarray()</span><span class="s0">, </span><span class="s1">X_trans_mask)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;arr_type&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">sparse.csc_matrix</span><span class="s0">,</span>
        <span class="s1">sparse.csr_matrix</span><span class="s0">,</span>
        <span class="s1">sparse.coo_matrix</span><span class="s0">,</span>
        <span class="s1">sparse.lil_matrix</span><span class="s0">,</span>
        <span class="s1">sparse.bsr_matrix</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_missing_indicator_raise_on_sparse_with_missing_0(arr_type):</span>
    <span class="s2"># test for sparse input and missing_value == 0</span>

    <span class="s1">missing_values = </span><span class="s5">0</span>
    <span class="s1">X_fit = np.array([[missing_values</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]])</span>
    <span class="s1">X_trans = np.array([[missing_values</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]])</span>

    <span class="s2"># convert the input to the right array format</span>
    <span class="s1">X_fit_sparse = arr_type(X_fit)</span>
    <span class="s1">X_trans_sparse = arr_type(X_trans)</span>

    <span class="s1">indicator = MissingIndicator(missing_values=missing_values)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Sparse input with missing_values=0&quot;</span><span class="s1">):</span>
        <span class="s1">indicator.fit_transform(X_fit_sparse)</span>

    <span class="s1">indicator.fit_transform(X_fit)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Sparse input with missing_values=0&quot;</span><span class="s1">):</span>
        <span class="s1">indicator.transform(X_trans_sparse)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;param_sparse&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, </span><span class="s4">&quot;auto&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;missing_values, arr_type&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">np.array)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.array)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">sparse.csc_matrix)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">sparse.csr_matrix)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">sparse.coo_matrix)</span><span class="s0">,</span>
        <span class="s1">(np.nan</span><span class="s0">, </span><span class="s1">sparse.lil_matrix)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_missing_indicator_sparse_param(arr_type</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s1">param_sparse):</span>
    <span class="s2"># check the format of the output with different sparse parameter</span>
    <span class="s1">X_fit = np.array([[missing_values</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]])</span>
    <span class="s1">X_trans = np.array([[missing_values</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]])</span>
    <span class="s1">X_fit = arr_type(X_fit).astype(np.float64)</span>
    <span class="s1">X_trans = arr_type(X_trans).astype(np.float64)</span>

    <span class="s1">indicator = MissingIndicator(missing_values=missing_values</span><span class="s0">, </span><span class="s1">sparse=param_sparse)</span>
    <span class="s1">X_fit_mask = indicator.fit_transform(X_fit)</span>
    <span class="s1">X_trans_mask = indicator.transform(X_trans)</span>

    <span class="s0">if </span><span class="s1">param_sparse </span><span class="s0">is True</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">X_fit_mask.format == </span><span class="s4">&quot;csc&quot;</span>
        <span class="s0">assert </span><span class="s1">X_trans_mask.format == </span><span class="s4">&quot;csc&quot;</span>
    <span class="s0">elif </span><span class="s1">param_sparse == </span><span class="s4">&quot;auto&quot; </span><span class="s0">and </span><span class="s1">missing_values == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">isinstance(X_fit_mask</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
        <span class="s0">assert </span><span class="s1">isinstance(X_trans_mask</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
    <span class="s0">elif </span><span class="s1">param_sparse </span><span class="s0">is False</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">isinstance(X_fit_mask</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
        <span class="s0">assert </span><span class="s1">isinstance(X_trans_mask</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">sparse.issparse(X_fit):</span>
            <span class="s0">assert </span><span class="s1">X_fit_mask.format == </span><span class="s4">&quot;csc&quot;</span>
            <span class="s0">assert </span><span class="s1">X_trans_mask.format == </span><span class="s4">&quot;csc&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">isinstance(X_fit_mask</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
            <span class="s0">assert </span><span class="s1">isinstance(X_trans_mask</span><span class="s0">, </span><span class="s1">np.ndarray)</span>


<span class="s0">def </span><span class="s1">test_missing_indicator_string():</span>
    <span class="s1">X = np.array([[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">indicator = MissingIndicator(missing_values=</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s1">features=</span><span class="s4">&quot;all&quot;</span><span class="s1">)</span>
    <span class="s1">X_trans = indicator.fit_transform(X)</span>
    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s0">True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, False, True</span><span class="s1">]]))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;X, missing_values, X_trans_exp&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">np.array([[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
            <span class="s4">&quot;a&quot;</span><span class="s0">,</span>
            <span class="s1">np.array([[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, False, True</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">np.array([[np.nan</span><span class="s0">, </span><span class="s5">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1.0</span><span class="s0">, </span><span class="s1">np.nan]])</span><span class="s0">,</span>
            <span class="s1">np.nan</span><span class="s0">,</span>
            <span class="s1">np.array([[</span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s0">, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s0">, False, True</span><span class="s1">]])</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">np.array([[np.nan</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
            <span class="s1">np.nan</span><span class="s0">,</span>
            <span class="s1">np.array([[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, False, True</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">np.array([[</span><span class="s0">None, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, None</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
            <span class="s0">None,</span>
            <span class="s1">np.array([[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, False, True</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_missing_indicator_with_imputer(X</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s1">X_trans_exp):</span>
    <span class="s1">trans = make_union(</span>
        <span class="s1">SimpleImputer(missing_values=missing_values</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">MissingIndicator(missing_values=missing_values)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">X_trans = trans.fit_transform(X)</span>
    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">X_trans_exp)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;imputer_constructor&quot;</span><span class="s0">, </span><span class="s1">[SimpleImputer</span><span class="s0">, </span><span class="s1">IterativeImputer])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;imputer_missing_values, missing_value, err_msg&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s4">&quot;NaN&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">&quot;Input X contains NaN&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">&quot;-1&quot;</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s4">&quot;types are expected to be both numerical.&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_inconsistent_dtype_X_missing_values(</span>
    <span class="s1">imputer_constructor</span><span class="s0">, </span><span class="s1">imputer_missing_values</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s1">err_msg</span>
<span class="s1">):</span>
    <span class="s2"># regression test for issue #11390. Comparison between incoherent dtype</span>
    <span class="s2"># for X and missing_values was not raising a proper error.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">42</span><span class="s1">)</span>
    <span class="s1">X = rng.randn(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">X[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = missing_value</span>

    <span class="s1">imputer = imputer_constructor(missing_values=imputer_missing_values)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">imputer.fit_transform(X)</span>


<span class="s0">def </span><span class="s1">test_missing_indicator_no_missing():</span>
    <span class="s2"># check that all features are dropped if there are no missing values when</span>
    <span class="s2"># features='missing-only' (#13491)</span>
    <span class="s1">X = np.array([[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]])</span>

    <span class="s1">mi = MissingIndicator(features=</span><span class="s4">&quot;missing-only&quot;</span><span class="s0">, </span><span class="s1">missing_values=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">Xt = mi.fit_transform(X)</span>

    <span class="s0">assert </span><span class="s1">Xt.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">0</span>


<span class="s0">def </span><span class="s1">test_missing_indicator_sparse_no_explicit_zeros():</span>
    <span class="s2"># Check that non missing values don't become explicit zeros in the mask</span>
    <span class="s2"># generated by missing indicator when X is sparse. (#13491)</span>
    <span class="s1">X = sparse.csr_matrix([[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]])</span>

    <span class="s1">mi = MissingIndicator(features=</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s1">missing_values=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">Xt = mi.fit_transform(X)</span>

    <span class="s0">assert </span><span class="s1">Xt.getnnz() == Xt.sum()</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;imputer_constructor&quot;</span><span class="s0">, </span><span class="s1">[SimpleImputer</span><span class="s0">, </span><span class="s1">IterativeImputer])</span>
<span class="s0">def </span><span class="s1">test_imputer_without_indicator(imputer_constructor):</span>
    <span class="s1">X = np.array([[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s1">imputer = imputer_constructor()</span>
    <span class="s1">imputer.fit(X)</span>

    <span class="s0">assert </span><span class="s1">imputer.indicator_ </span><span class="s0">is None</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;arr_type&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">sparse.csc_matrix</span><span class="s0">,</span>
        <span class="s1">sparse.csr_matrix</span><span class="s0">,</span>
        <span class="s1">sparse.coo_matrix</span><span class="s0">,</span>
        <span class="s1">sparse.lil_matrix</span><span class="s0">,</span>
        <span class="s1">sparse.bsr_matrix</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_simple_imputation_add_indicator_sparse_matrix(arr_type):</span>
    <span class="s1">X_sparse = arr_type([[np.nan</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">9</span><span class="s1">]])</span>
    <span class="s1">X_true = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">3.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">5.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">2.0</span><span class="s0">, </span><span class="s5">2.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">6.0</span><span class="s0">, </span><span class="s5">3.0</span><span class="s0">, </span><span class="s5">5.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">2.0</span><span class="s0">, </span><span class="s5">9.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">imputer = SimpleImputer(missing_values=np.nan</span><span class="s0">, </span><span class="s1">add_indicator=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">X_trans = imputer.fit_transform(X_sparse)</span>

    <span class="s0">assert </span><span class="s1">sparse.issparse(X_trans)</span>
    <span class="s0">assert </span><span class="s1">X_trans.shape == X_true.shape</span>
    <span class="s1">assert_allclose(X_trans.toarray()</span><span class="s0">, </span><span class="s1">X_true)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;strategy, expected&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s4">&quot;most_frequent&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s4">&quot;missing_value&quot;</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_simple_imputation_string_list(strategy</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s1">X = [[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s1">np.nan]]</span>

    <span class="s1">X_true = np.array([[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s1">expected]]</span><span class="s0">, </span><span class="s1">dtype=object)</span>

    <span class="s1">imputer = SimpleImputer(strategy=strategy)</span>
    <span class="s1">X_trans = imputer.fit_transform(X)</span>

    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">X_true)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;order, idx_order&quot;</span><span class="s0">,</span>
    <span class="s1">[(</span><span class="s4">&quot;ascending&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;descending&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_imputation_order(order</span><span class="s0">, </span><span class="s1">idx_order):</span>
    <span class="s2"># regression test for #15393</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s5">42</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span>
    <span class="s1">X[:</span><span class="s5">50</span><span class="s0">, </span><span class="s5">1</span><span class="s1">] = np.nan</span>
    <span class="s1">X[:</span><span class="s5">30</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
    <span class="s1">X[:</span><span class="s5">20</span><span class="s0">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
    <span class="s1">X[:</span><span class="s5">10</span><span class="s0">, </span><span class="s5">4</span><span class="s1">] = np.nan</span>

    <span class="s0">with </span><span class="s1">pytest.warns(ConvergenceWarning):</span>
        <span class="s1">trs = IterativeImputer(max_iter=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">imputation_order=order</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s5">0</span><span class="s1">).fit(</span>
            <span class="s1">X</span>
        <span class="s1">)</span>
        <span class="s1">idx = [x.feat_idx </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">trs.imputation_sequence_]</span>
        <span class="s0">assert </span><span class="s1">idx == idx_order</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;missing_value&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.nan])</span>
<span class="s0">def </span><span class="s1">test_simple_imputation_inverse_transform(missing_value):</span>
    <span class="s2"># Test inverse_transform feature for np.nan</span>
    <span class="s1">X_1 = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">9</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">missing_value]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">X_2 = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">9</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">missing_value]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">X_3 = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">9</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[missing_value</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s1">missing_value]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s1">missing_value]</span><span class="s0">,</span>
            <span class="s1">[missing_value</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">8</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">X_4 = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[missing_value</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[missing_value</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">imputer = SimpleImputer(</span>
        <span class="s1">missing_values=missing_value</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">add_indicator=</span><span class="s0">True</span>
    <span class="s1">)</span>

    <span class="s1">X_1_trans = imputer.fit_transform(X_1)</span>
    <span class="s1">X_1_inv_trans = imputer.inverse_transform(X_1_trans)</span>

    <span class="s1">X_2_trans = imputer.transform(X_2)  </span><span class="s2"># test on new data</span>
    <span class="s1">X_2_inv_trans = imputer.inverse_transform(X_2_trans)</span>

    <span class="s1">assert_array_equal(X_1_inv_trans</span><span class="s0">, </span><span class="s1">X_1)</span>
    <span class="s1">assert_array_equal(X_2_inv_trans</span><span class="s0">, </span><span class="s1">X_2)</span>

    <span class="s0">for </span><span class="s1">X </span><span class="s0">in </span><span class="s1">[X_3</span><span class="s0">, </span><span class="s1">X_4]:</span>
        <span class="s1">X_trans = imputer.fit_transform(X)</span>
        <span class="s1">X_inv_trans = imputer.inverse_transform(X_trans)</span>
        <span class="s1">assert_array_equal(X_inv_trans</span><span class="s0">, </span><span class="s1">X)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;missing_value&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.nan])</span>
<span class="s0">def </span><span class="s1">test_simple_imputation_inverse_transform_exceptions(missing_value):</span>
    <span class="s1">X_1 = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">9</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s1">missing_value</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">missing_value]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">imputer = SimpleImputer(missing_values=missing_value</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s1">)</span>
    <span class="s1">X_1_trans = imputer.fit_transform(X_1)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">f&quot;Got 'add_indicator=</span><span class="s0">{</span><span class="s1">imputer.add_indicator</span><span class="s0">}</span><span class="s4">'&quot;</span>
    <span class="s1">):</span>
        <span class="s1">imputer.inverse_transform(X_1_trans)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;expected,array,dtype,extra_value,n_repeat&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s2"># array of object dtype</span>
        <span class="s1">(</span><span class="s4">&quot;extra_value&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">object</span><span class="s0">, </span><span class="s4">&quot;extra_value&quot;</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s4">&quot;most_frequent_value&quot;</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;most_frequent_value&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent_value&quot;</span><span class="s0">, </span><span class="s4">&quot;value&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">object</span><span class="s0">,</span>
            <span class="s4">&quot;extra_value&quot;</span><span class="s0">,</span>
            <span class="s5">1</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;min_value&quot;</span><span class="s0">, </span><span class="s4">&quot;min_valuevalue&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">object</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">&quot;min_value&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;min_value&quot;</span><span class="s0">, </span><span class="s4">&quot;min_value&quot;</span><span class="s0">, </span><span class="s4">&quot;value&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">object</span><span class="s0">, </span><span class="s4">&quot;z&quot;</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># array of numeric dtype</span>
        <span class="s1">(</span><span class="s5">10</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">10</span><span class="s0">, </span><span class="s1">[</span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_most_frequent(expected</span><span class="s0">, </span><span class="s1">array</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">extra_value</span><span class="s0">, </span><span class="s1">n_repeat):</span>
    <span class="s0">assert </span><span class="s1">expected == _most_frequent(</span>
        <span class="s1">np.array(array</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">, </span><span class="s1">extra_value</span><span class="s0">, </span><span class="s1">n_repeat</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;initial_strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s0">, </span><span class="s4">&quot;constant&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_iterative_imputer_keep_empty_features(initial_strategy):</span>
    <span class="s3">&quot;&quot;&quot;Check the behaviour of the iterative imputer with different initial strategy 
    and keeping empty features (i.e. features containing only missing values). 
    &quot;&quot;&quot;</span>
    <span class="s1">X = np.array([[</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]])</span>

    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">initial_strategy=initial_strategy</span><span class="s0">, </span><span class="s1">keep_empty_features=</span><span class="s0">True</span>
    <span class="s1">)</span>
    <span class="s1">X_imputed = imputer.fit_transform(X)</span>
    <span class="s1">assert_allclose(X_imputed[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">X_imputed = imputer.transform(X)</span>
    <span class="s1">assert_allclose(X_imputed[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_iterative_imputer_constant_fill_value():</span>
    <span class="s3">&quot;&quot;&quot;Check that we propagate properly the parameter `fill_value`.&quot;&quot;&quot;</span>
    <span class="s1">X = np.array([[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]])</span>

    <span class="s1">fill_value = </span><span class="s5">100</span>
    <span class="s1">imputer = IterativeImputer(</span>
        <span class="s1">missing_values=-</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">initial_strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">,</span>
        <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
        <span class="s1">max_iter=</span><span class="s5">0</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">imputer.fit_transform(X)</span>
    <span class="s1">assert_array_equal(imputer.initial_imputer_.statistics_</span><span class="s0">, </span><span class="s1">fill_value)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;keep_empty_features&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_knn_imputer_keep_empty_features(keep_empty_features):</span>
    <span class="s3">&quot;&quot;&quot;Check the behaviour of `keep_empty_features` for `KNNImputer`.&quot;&quot;&quot;</span>
    <span class="s1">X = np.array([[</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]])</span>

    <span class="s1">imputer = KNNImputer(keep_empty_features=keep_empty_features)</span>

    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;fit_transform&quot;</span><span class="s0">, </span><span class="s4">&quot;transform&quot;</span><span class="s1">]:</span>
        <span class="s1">X_imputed = getattr(imputer</span><span class="s0">, </span><span class="s1">method)(X)</span>
        <span class="s0">if </span><span class="s1">keep_empty_features:</span>
            <span class="s0">assert </span><span class="s1">X_imputed.shape == X.shape</span>
            <span class="s1">assert_array_equal(X_imputed[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">X_imputed.shape == (X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">X.shape[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_simple_impute_pd_na():</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s4">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s2"># Impute pandas array of string types.</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;feature&quot;</span><span class="s1">: pd.Series([</span><span class="s4">&quot;abc&quot;</span><span class="s0">, None, </span><span class="s4">&quot;de&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;string&quot;</span><span class="s1">)})</span>
    <span class="s1">imputer = SimpleImputer(missing_values=pd.NA</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s4">&quot;na&quot;</span><span class="s1">)</span>
    <span class="s1">_assert_array_equal_and_same_dtype(</span>
        <span class="s1">imputer.fit_transform(df)</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s4">&quot;abc&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;na&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;de&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">)</span>

    <span class="s2"># Impute pandas array of string types without any missing values.</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;feature&quot;</span><span class="s1">: pd.Series([</span><span class="s4">&quot;abc&quot;</span><span class="s0">, </span><span class="s4">&quot;de&quot;</span><span class="s0">, </span><span class="s4">&quot;fgh&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;string&quot;</span><span class="s1">)})</span>
    <span class="s1">imputer = SimpleImputer(fill_value=</span><span class="s4">&quot;ok&quot;</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s1">)</span>
    <span class="s1">_assert_array_equal_and_same_dtype(</span>
        <span class="s1">imputer.fit_transform(df)</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s4">&quot;abc&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;de&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;fgh&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">)</span>

    <span class="s2"># Impute pandas array of integer types.</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;feature&quot;</span><span class="s1">: pd.Series([</span><span class="s5">1</span><span class="s0">, None, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;Int64&quot;</span><span class="s1">)})</span>
    <span class="s1">imputer = SimpleImputer(missing_values=pd.NA</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">fill_value=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">_assert_allclose_and_same_dtype(</span>
        <span class="s1">imputer.fit_transform(df)</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s2"># Use `np.nan` also works.</span>
    <span class="s1">imputer = SimpleImputer(missing_values=np.nan</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">fill_value=-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">_assert_allclose_and_same_dtype(</span>
        <span class="s1">imputer.fit_transform(df)</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s2"># Impute pandas array of integer types with 'median' strategy.</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;feature&quot;</span><span class="s1">: pd.Series([</span><span class="s5">1</span><span class="s0">, None, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;Int64&quot;</span><span class="s1">)})</span>
    <span class="s1">imputer = SimpleImputer(missing_values=pd.NA</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;median&quot;</span><span class="s1">)</span>
    <span class="s1">_assert_allclose_and_same_dtype(</span>
        <span class="s1">imputer.fit_transform(df)</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s2"># Impute pandas array of integer types with 'mean' strategy.</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;feature&quot;</span><span class="s1">: pd.Series([</span><span class="s5">1</span><span class="s0">, None, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;Int64&quot;</span><span class="s1">)})</span>
    <span class="s1">imputer = SimpleImputer(missing_values=pd.NA</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;mean&quot;</span><span class="s1">)</span>
    <span class="s1">_assert_allclose_and_same_dtype(</span>
        <span class="s1">imputer.fit_transform(df)</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s2"># Impute pandas array of float types.</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;feature&quot;</span><span class="s1">: pd.Series([</span><span class="s5">1.0</span><span class="s0">, None, </span><span class="s5">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)})</span>
    <span class="s1">imputer = SimpleImputer(missing_values=pd.NA</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">fill_value=-</span><span class="s5">2.0</span><span class="s1">)</span>
    <span class="s1">_assert_allclose_and_same_dtype(</span>
        <span class="s1">imputer.fit_transform(df)</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s5">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s5">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3.0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s2"># Impute pandas array of float types with 'median' strategy.</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;feature&quot;</span><span class="s1">: pd.Series([</span><span class="s5">1.0</span><span class="s0">, None, </span><span class="s5">2.0</span><span class="s0">, </span><span class="s5">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)})</span>
    <span class="s1">imputer = SimpleImputer(missing_values=pd.NA</span><span class="s0">, </span><span class="s1">strategy=</span><span class="s4">&quot;median&quot;</span><span class="s1">)</span>
    <span class="s1">_assert_allclose_and_same_dtype(</span>
        <span class="s1">imputer.fit_transform(df)</span><span class="s0">,</span>
        <span class="s1">np.array([[</span><span class="s5">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3.0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;float64&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_missing_indicator_feature_names_out():</span>
    <span class="s3">&quot;&quot;&quot;Check that missing indicator return the feature names with a prefix.&quot;&quot;&quot;</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s4">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">missing_values = np.nan</span>
    <span class="s1">X = pd.DataFrame(</span>
        <span class="s1">[</span>
            <span class="s1">[missing_values</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">missing_values]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s1">missing_values</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">indicator = MissingIndicator(missing_values=missing_values).fit(X)</span>
    <span class="s1">feature_names = indicator.get_feature_names_out()</span>
    <span class="s1">expected_names = [</span><span class="s4">&quot;missingindicator_a&quot;</span><span class="s0">, </span><span class="s4">&quot;missingindicator_b&quot;</span><span class="s0">, </span><span class="s4">&quot;missingindicator_d&quot;</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(expected_names</span><span class="s0">, </span><span class="s1">feature_names)</span>


<span class="s0">def </span><span class="s1">test_imputer_lists_fit_transform():</span>
    <span class="s3">&quot;&quot;&quot;Check transform uses object dtype when fitted on an object dtype. 
 
    Non-regression test for #19572. 
    &quot;&quot;&quot;</span>

    <span class="s1">X = [[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s1">]]</span>
    <span class="s1">imp_frequent = SimpleImputer(strategy=</span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">).fit(X)</span>
    <span class="s1">X_trans = imp_frequent.transform([[np.nan</span><span class="s0">, </span><span class="s1">np.nan]])</span>
    <span class="s0">assert </span><span class="s1">X_trans.dtype == object</span>
    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">[[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">]])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype_test&quot;</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
<span class="s0">def </span><span class="s1">test_imputer_transform_preserves_numeric_dtype(dtype_test):</span>
    <span class="s3">&quot;&quot;&quot;Check transform preserves numeric dtype independent of fit dtype.&quot;&quot;&quot;</span>
    <span class="s1">X = np.asarray(</span>
        <span class="s1">[[</span><span class="s5">1.2</span><span class="s0">, </span><span class="s5">3.4</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">1.2</span><span class="s0">, </span><span class="s5">1.3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4.2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.float64</span>
    <span class="s1">)</span>
    <span class="s1">imp = SimpleImputer().fit(X)</span>

    <span class="s1">X_test = np.asarray([[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=dtype_test)</span>
    <span class="s1">X_trans = imp.transform(X_test)</span>
    <span class="s0">assert </span><span class="s1">X_trans.dtype == dtype_test</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;array_type&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;array&quot;</span><span class="s0">, </span><span class="s4">&quot;sparse&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;keep_empty_features&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_simple_imputer_constant_keep_empty_features(array_type</span><span class="s0">, </span><span class="s1">keep_empty_features):</span>
    <span class="s3">&quot;&quot;&quot;Check the behaviour of `keep_empty_features` with `strategy='constant'. 
    For backward compatibility, a column full of missing values will always be 
    fill and never dropped. 
    &quot;&quot;&quot;</span>
    <span class="s1">X = np.array([[np.nan</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]])</span>
    <span class="s1">X = _convert_container(X</span><span class="s0">, </span><span class="s1">array_type)</span>
    <span class="s1">fill_value = </span><span class="s5">10</span>
    <span class="s1">imputer = SimpleImputer(</span>
        <span class="s1">strategy=</span><span class="s4">&quot;constant&quot;</span><span class="s0">,</span>
        <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
        <span class="s1">keep_empty_features=keep_empty_features</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;fit_transform&quot;</span><span class="s0">, </span><span class="s4">&quot;transform&quot;</span><span class="s1">]:</span>
        <span class="s1">X_imputed = getattr(imputer</span><span class="s0">, </span><span class="s1">method)(X)</span>
        <span class="s0">assert </span><span class="s1">X_imputed.shape == X.shape</span>
        <span class="s1">constant_feature = (</span>
            <span class="s1">X_imputed[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">].toarray() </span><span class="s0">if </span><span class="s1">array_type == </span><span class="s4">&quot;sparse&quot; </span><span class="s0">else </span><span class="s1">X_imputed[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_array_equal(constant_feature</span><span class="s0">, </span><span class="s1">fill_value)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;array_type&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;array&quot;</span><span class="s0">, </span><span class="s4">&quot;sparse&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strategy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;keep_empty_features&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_simple_imputer_keep_empty_features(strategy</span><span class="s0">, </span><span class="s1">array_type</span><span class="s0">, </span><span class="s1">keep_empty_features):</span>
    <span class="s3">&quot;&quot;&quot;Check the behaviour of `keep_empty_features` with all strategies but 
    'constant'. 
    &quot;&quot;&quot;</span>
    <span class="s1">X = np.array([[np.nan</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]])</span>
    <span class="s1">X = _convert_container(X</span><span class="s0">, </span><span class="s1">array_type)</span>
    <span class="s1">imputer = SimpleImputer(strategy=strategy</span><span class="s0">, </span><span class="s1">keep_empty_features=keep_empty_features)</span>

    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;fit_transform&quot;</span><span class="s0">, </span><span class="s4">&quot;transform&quot;</span><span class="s1">]:</span>
        <span class="s1">X_imputed = getattr(imputer</span><span class="s0">, </span><span class="s1">method)(X)</span>
        <span class="s0">if </span><span class="s1">keep_empty_features:</span>
            <span class="s0">assert </span><span class="s1">X_imputed.shape == X.shape</span>
            <span class="s1">constant_feature = (</span>
                <span class="s1">X_imputed[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">].toarray() </span><span class="s0">if </span><span class="s1">array_type == </span><span class="s4">&quot;sparse&quot; </span><span class="s0">else </span><span class="s1">X_imputed[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">assert_array_equal(constant_feature</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">X_imputed.shape == (X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">X.shape[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">)</span>
</pre>
</body>
</html>