<html>
<head>
<title>test_masked.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_masked.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file contains a minimal set of tests for compliance with the extension 
array interface test suite, and should contain no other tests. 
The test suite for the full functionality of the array is located in 
`pandas/tests/arrays/`. 
 
The tests in this file are inherited from the BaseExtensionTests, and only 
minimal tweaks should be applied to get the tests passing (by overwriting a 
parent method). 
 
Additional tests should either be added to one of the BaseExtensionTests 
classes (if they are relevant for the extension interface for all dtypes), or 
be added to the array-specific tests in `pandas/tests/arrays/`. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas.compat </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">IS64</span><span class="s2">,</span>
    <span class="s1">is_platform_windows</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.boolean </span><span class="s2">import </span><span class="s1">BooleanDtype</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.floating </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Float32Dtype</span><span class="s2">,</span>
    <span class="s1">Float64Dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.integer </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Int8Dtype</span><span class="s2">,</span>
    <span class="s1">Int16Dtype</span><span class="s2">,</span>
    <span class="s1">Int32Dtype</span><span class="s2">,</span>
    <span class="s1">Int64Dtype</span><span class="s2">,</span>
    <span class="s1">UInt8Dtype</span><span class="s2">,</span>
    <span class="s1">UInt16Dtype</span><span class="s2">,</span>
    <span class="s1">UInt32Dtype</span><span class="s2">,</span>
    <span class="s1">UInt64Dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.tests.extension </span><span class="s2">import </span><span class="s1">base</span>

<span class="s1">is_windows_or_32bit = is_platform_windows() </span><span class="s2">or not </span><span class="s1">IS64</span>

<span class="s1">pytestmark = [</span>
    <span class="s1">pytest.mark.filterwarnings(</span>
        <span class="s3">&quot;ignore:invalid value encountered in divide:RuntimeWarning&quot;</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:Mean of empty slice:RuntimeWarning&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4"># overflow only relevant for Floating dtype cases cases</span>
    <span class="s1">pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:overflow encountered in reduce:RuntimeWarning&quot;</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">make_data():</span>
    <span class="s2">return </span><span class="s1">list(range(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">9</span><span class="s1">)) + [pd.NA] + list(range(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">98</span><span class="s1">)) + [pd.NA] + [</span><span class="s5">99</span><span class="s2">, </span><span class="s5">100</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">make_float_data():</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">list(np.arange(</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">))</span>
        <span class="s1">+ [pd.NA]</span>
        <span class="s1">+ list(np.arange(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">9.8</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">))</span>
        <span class="s1">+ [pd.NA]</span>
        <span class="s1">+ [</span><span class="s5">9.9</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">make_bool_data():</span>
    <span class="s2">return </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">] * </span><span class="s5">4 </span><span class="s1">+ [np.nan] + [</span><span class="s2">True, False</span><span class="s1">] * </span><span class="s5">44 </span><span class="s1">+ [np.nan] + [</span><span class="s2">True, False</span><span class="s1">]</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=[</span>
        <span class="s1">Int8Dtype</span><span class="s2">,</span>
        <span class="s1">Int16Dtype</span><span class="s2">,</span>
        <span class="s1">Int32Dtype</span><span class="s2">,</span>
        <span class="s1">Int64Dtype</span><span class="s2">,</span>
        <span class="s1">UInt8Dtype</span><span class="s2">,</span>
        <span class="s1">UInt16Dtype</span><span class="s2">,</span>
        <span class="s1">UInt32Dtype</span><span class="s2">,</span>
        <span class="s1">UInt64Dtype</span><span class="s2">,</span>
        <span class="s1">Float32Dtype</span><span class="s2">,</span>
        <span class="s1">Float64Dtype</span><span class="s2">,</span>
        <span class="s1">BooleanDtype</span><span class="s2">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">dtype(request):</span>
    <span class="s2">return </span><span class="s1">request.param()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data(dtype):</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s1">data = make_float_data()</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s1">data = make_bool_data()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">data = make_data()</span>
    <span class="s2">return </span><span class="s1">pd.array(data</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_twos(dtype):</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.array(np.ones(</span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">return </span><span class="s1">pd.array(np.ones(</span><span class="s5">100</span><span class="s1">) * </span><span class="s5">2</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_missing(dtype):</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.array([pd.NA</span><span class="s2">, </span><span class="s5">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.array([np.nan</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">return </span><span class="s1">pd.array([pd.NA</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_sorting(dtype):</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.array([</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.array([</span><span class="s2">True, True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">return </span><span class="s1">pd.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_missing_for_sorting(dtype):</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.array([</span><span class="s5">0.1</span><span class="s2">, </span><span class="s1">pd.NA</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pd.array([</span><span class="s2">True, </span><span class="s1">np.nan</span><span class="s2">, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">return </span><span class="s1">pd.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s1">pd.NA</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">na_cmp():</span>
    <span class="s4"># we are pd.NA</span>
    <span class="s2">return lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: x </span><span class="s2">is </span><span class="s1">pd.NA </span><span class="s2">and </span><span class="s1">y </span><span class="s2">is </span><span class="s1">pd.NA</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_grouping(dtype):</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s1">b = </span><span class="s5">0.1</span>
        <span class="s1">a = </span><span class="s5">0.0</span>
        <span class="s1">c = </span><span class="s5">0.2</span>
    <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
        <span class="s1">b = </span><span class="s2">True</span>
        <span class="s1">a = </span><span class="s2">False</span>
        <span class="s1">c = b</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">b = </span><span class="s5">1</span>
        <span class="s1">a = </span><span class="s5">0</span>
        <span class="s1">c = </span><span class="s5">2</span>

    <span class="s1">na = pd.NA</span>
    <span class="s2">return </span><span class="s1">pd.array([b</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">na</span><span class="s2">, </span><span class="s1">na</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s2">class </span><span class="s1">TestDtype(base.BaseDtypeTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestArithmeticOps(base.BaseArithmeticOpsTests):</span>
    <span class="s2">def </span><span class="s1">_get_expected_exception(self</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dtype = tm.get_dtype(obj)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s4"># passed arguments reversed</span>
            <span class="s1">dtype = tm.get_dtype(other)</span>

        <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">op_name.strip(</span><span class="s3">&quot;_&quot;</span><span class="s1">).lstrip(</span><span class="s3">&quot;r&quot;</span><span class="s1">) </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;pow&quot;</span><span class="s2">, </span><span class="s3">&quot;truediv&quot;</span><span class="s2">, </span><span class="s3">&quot;floordiv&quot;</span><span class="s1">]:</span>
                <span class="s4"># match behavior with non-masked bool dtype</span>
                <span class="s2">return </span><span class="s1">NotImplementedError</span>
            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;__sub__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rsub__&quot;</span><span class="s1">]:</span>
                <span class="s4"># exception message would include &quot;numpy boolean subtract&quot;&quot;</span>
                <span class="s2">return </span><span class="s1">TypeError</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">super()._get_expected_exception(op_name</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">_cast_pointwise_result(self</span><span class="s2">, </span><span class="s1">op_name: str</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">pointwise_result):</span>
        <span class="s1">sdtype = tm.get_dtype(obj)</span>
        <span class="s1">expected = pointwise_result</span>

        <span class="s2">if </span><span class="s1">sdtype.kind </span><span class="s2">in </span><span class="s3">&quot;iu&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;__rtruediv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__truediv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__div__&quot;</span><span class="s1">):</span>
                <span class="s1">expected = expected.fillna(np.nan).astype(</span><span class="s3">&quot;Float64&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># combine method result in 'biggest' (int64) dtype</span>
                <span class="s1">expected = expected.astype(sdtype)</span>
        <span class="s2">elif </span><span class="s1">sdtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span>
                <span class="s3">&quot;__floordiv__&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;__rfloordiv__&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;__pow__&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;__rpow__&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;__mod__&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;__rmod__&quot;</span><span class="s2">,</span>
            <span class="s1">):</span>
                <span class="s4"># combine keeps boolean type</span>
                <span class="s1">expected = expected.astype(</span><span class="s3">&quot;Int8&quot;</span><span class="s1">)</span>

            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;__truediv__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rtruediv__&quot;</span><span class="s1">):</span>
                <span class="s4"># combine with bools does not generate the correct result</span>
                <span class="s4">#  (numpy behaviour for div is to regard the bools as numeric)</span>
                <span class="s1">op = self.get_op_from_name(op_name)</span>
                <span class="s1">expected = self._combine(obj.astype(float)</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op)</span>
                <span class="s1">expected = expected.astype(</span><span class="s3">&quot;Float64&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">op_name == </span><span class="s3">&quot;__rpow__&quot;</span><span class="s1">:</span>
                <span class="s4"># for rpow, combine does not propagate NaN</span>
                <span class="s1">result = getattr(obj</span><span class="s2">, </span><span class="s1">op_name)(other)</span>
                <span class="s1">expected[result.isna()] = np.nan</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># combine method result in 'biggest' (float64) dtype</span>
            <span class="s1">expected = expected.astype(sdtype)</span>
        <span class="s2">return </span><span class="s1">expected</span>

    <span class="s1">series_scalar_exc = </span><span class="s2">None</span>
    <span class="s1">series_array_exc = </span><span class="s2">None</span>
    <span class="s1">frame_scalar_exc = </span><span class="s2">None</span>
    <span class="s1">divmod_exc = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">test_divmod_series_array(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">data_for_twos</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">if </span><span class="s1">data.dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">reason=</span><span class="s3">&quot;Inconsistency between floordiv and divmod; we raise for &quot;</span>
                <span class="s3">&quot;floordiv but not for divmod. This matches what we do for &quot;</span>
                <span class="s3">&quot;non-masked bool dtype.&quot;</span>
            <span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>
        <span class="s1">super().test_divmod_series_array(data</span><span class="s2">, </span><span class="s1">data_for_twos)</span>


<span class="s2">class </span><span class="s1">TestComparisonOps(base.BaseComparisonOpsTests):</span>
    <span class="s1">series_scalar_exc = </span><span class="s2">None</span>
    <span class="s1">series_array_exc = </span><span class="s2">None</span>
    <span class="s1">frame_scalar_exc = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_cast_pointwise_result(self</span><span class="s2">, </span><span class="s1">op_name: str</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">pointwise_result):</span>
        <span class="s2">return </span><span class="s1">pointwise_result.astype(</span><span class="s3">&quot;boolean&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestInterface(base.BaseInterfaceTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestConstructors(base.BaseConstructorsTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestReshaping(base.BaseReshapingTests):</span>
    <span class="s2">pass</span>

    <span class="s4"># for test_concat_mixed_dtypes test</span>
    <span class="s4"># concat of an Integer and Int coerces to object dtype</span>
    <span class="s4"># TODO(jreback) once integrated this would</span>


<span class="s2">class </span><span class="s1">TestGetitem(base.BaseGetitemTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestSetitem(base.BaseSetitemTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestIndex(base.BaseIndexTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestMissing(base.BaseMissingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestMethods(base.BaseMethodsTests):</span>
    <span class="s2">def </span><span class="s1">test_combine_le(self</span><span class="s2">, </span><span class="s1">data_repeated):</span>
        <span class="s4"># TODO: patching self is a bad pattern here</span>
        <span class="s1">orig_data1</span><span class="s2">, </span><span class="s1">orig_data2 = data_repeated(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">orig_data1.dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s1">self._combine_le_expected_dtype = </span><span class="s3">&quot;boolean&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># TODO: can we make this boolean?</span>
            <span class="s1">self._combine_le_expected_dtype = object</span>
        <span class="s1">super().test_combine_le(data_repeated)</span>


<span class="s2">class </span><span class="s1">TestCasting(base.BaseCastingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestGroupby(base.BaseGroupbyTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestReduce(base.BaseReduceTests):</span>
    <span class="s2">def </span><span class="s1">_supports_reduction(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">op_name: str) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;any&quot;</span><span class="s2">, </span><span class="s3">&quot;all&quot;</span><span class="s1">] </span><span class="s2">and </span><span class="s1">tm.get_dtype(obj).kind != </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.skip(reason=</span><span class="s3">&quot;Tested in tests/reductions/test_reductions.py&quot;</span><span class="s1">)</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">check_reduce(self</span><span class="s2">, </span><span class="s1">ser: pd.Series</span><span class="s2">, </span><span class="s1">op_name: str</span><span class="s2">, </span><span class="s1">skipna: bool):</span>
        <span class="s4"># overwrite to ensure pd.NA is tested instead of np.nan</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/30958</span>

        <span class="s1">cmp_dtype = </span><span class="s3">&quot;int64&quot;</span>
        <span class="s2">if </span><span class="s1">ser.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s4"># Item &quot;dtype[Any]&quot; of &quot;Union[dtype[Any], ExtensionDtype]&quot; has</span>
            <span class="s4"># no attribute &quot;numpy_dtype&quot;</span>
            <span class="s1">cmp_dtype = ser.dtype.numpy_dtype  </span><span class="s4"># type: ignore[union-attr]</span>
        <span class="s2">elif </span><span class="s1">ser.dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]:</span>
                <span class="s1">cmp_dtype = </span><span class="s3">&quot;bool&quot;</span>

        <span class="s2">if </span><span class="s1">op_name == </span><span class="s3">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s1">result = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)()</span>
            <span class="s1">expected = getattr(ser.dropna().astype(cmp_dtype)</span><span class="s2">, </span><span class="s1">op_name)()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
            <span class="s1">expected = getattr(ser.dropna().astype(cmp_dtype)</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
            <span class="s2">if not </span><span class="s1">skipna </span><span class="s2">and </span><span class="s1">ser.isna().any() </span><span class="s2">and </span><span class="s1">op_name </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;any&quot;</span><span class="s2">, </span><span class="s3">&quot;all&quot;</span><span class="s1">]:</span>
                <span class="s1">expected = pd.NA</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">_get_expected_reduction_dtype(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">op_name: str):</span>
        <span class="s2">if </span><span class="s1">tm.is_float_dtype(arr.dtype):</span>
            <span class="s1">cmp_dtype = arr.dtype.name</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;mean&quot;</span><span class="s2">, </span><span class="s3">&quot;median&quot;</span><span class="s2">, </span><span class="s3">&quot;var&quot;</span><span class="s2">, </span><span class="s3">&quot;std&quot;</span><span class="s2">, </span><span class="s3">&quot;skew&quot;</span><span class="s1">]:</span>
            <span class="s1">cmp_dtype = </span><span class="s3">&quot;Float64&quot;</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;max&quot;</span><span class="s2">, </span><span class="s3">&quot;min&quot;</span><span class="s1">]:</span>
            <span class="s1">cmp_dtype = arr.dtype.name</span>
        <span class="s2">elif </span><span class="s1">arr.dtype </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;Int64&quot;</span><span class="s2">, </span><span class="s3">&quot;UInt64&quot;</span><span class="s1">]:</span>
            <span class="s1">cmp_dtype = arr.dtype.name</span>
        <span class="s2">elif </span><span class="s1">tm.is_signed_integer_dtype(arr.dtype):</span>
            <span class="s1">cmp_dtype = </span><span class="s3">&quot;Int32&quot; </span><span class="s2">if </span><span class="s1">is_windows_or_32bit </span><span class="s2">else </span><span class="s3">&quot;Int64&quot;</span>
        <span class="s2">elif </span><span class="s1">tm.is_unsigned_integer_dtype(arr.dtype):</span>
            <span class="s1">cmp_dtype = </span><span class="s3">&quot;UInt32&quot; </span><span class="s2">if </span><span class="s1">is_windows_or_32bit </span><span class="s2">else </span><span class="s3">&quot;UInt64&quot;</span>
        <span class="s2">elif </span><span class="s1">arr.dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;mean&quot;</span><span class="s2">, </span><span class="s3">&quot;median&quot;</span><span class="s2">, </span><span class="s3">&quot;var&quot;</span><span class="s2">, </span><span class="s3">&quot;std&quot;</span><span class="s2">, </span><span class="s3">&quot;skew&quot;</span><span class="s1">]:</span>
                <span class="s1">cmp_dtype = </span><span class="s3">&quot;Float64&quot;</span>
            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]:</span>
                <span class="s1">cmp_dtype = </span><span class="s3">&quot;boolean&quot;</span>
            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;sum&quot;</span><span class="s2">, </span><span class="s3">&quot;prod&quot;</span><span class="s1">]:</span>
                <span class="s1">cmp_dtype = </span><span class="s3">&quot;Int32&quot; </span><span class="s2">if </span><span class="s1">is_windows_or_32bit </span><span class="s2">else </span><span class="s3">&quot;Int64&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;not supposed to reach this&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;not supposed to reach this&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">cmp_dtype</span>


<span class="s2">class </span><span class="s1">TestAccumulation(base.BaseAccumulateTests):</span>
    <span class="s2">def </span><span class="s1">_supports_accumulation(self</span><span class="s2">, </span><span class="s1">ser: pd.Series</span><span class="s2">, </span><span class="s1">op_name: str) -&gt; bool:</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">check_accumulate(self</span><span class="s2">, </span><span class="s1">ser: pd.Series</span><span class="s2">, </span><span class="s1">op_name: str</span><span class="s2">, </span><span class="s1">skipna: bool):</span>
        <span class="s4"># overwrite to ensure pd.NA is tested instead of np.nan</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/30958</span>
        <span class="s1">length = </span><span class="s5">64</span>
        <span class="s2">if not </span><span class="s1">IS64 </span><span class="s2">or </span><span class="s1">is_platform_windows():</span>
            <span class="s4"># Item &quot;ExtensionDtype&quot; of &quot;Union[dtype[Any], ExtensionDtype]&quot; has</span>
            <span class="s4"># no attribute &quot;itemsize&quot;</span>
            <span class="s2">if not </span><span class="s1">ser.dtype.itemsize == </span><span class="s5">8</span><span class="s1">:  </span><span class="s4"># type: ignore[union-attr]</span>
                <span class="s1">length = </span><span class="s5">32</span>

        <span class="s2">if </span><span class="s1">ser.dtype.name.startswith(</span><span class="s3">&quot;U&quot;</span><span class="s1">):</span>
            <span class="s1">expected_dtype = </span><span class="s3">f&quot;UInt</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">elif </span><span class="s1">ser.dtype.name.startswith(</span><span class="s3">&quot;I&quot;</span><span class="s1">):</span>
            <span class="s1">expected_dtype = </span><span class="s3">f&quot;Int</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">elif </span><span class="s1">ser.dtype.name.startswith(</span><span class="s3">&quot;F&quot;</span><span class="s1">):</span>
            <span class="s4"># Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;Union[dtype[Any], ExtensionDtype]&quot;, variable has type &quot;str&quot;)</span>
            <span class="s1">expected_dtype = ser.dtype  </span><span class="s4"># type: ignore[assignment]</span>
        <span class="s2">elif </span><span class="s1">ser.dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;cummin&quot;</span><span class="s2">, </span><span class="s3">&quot;cummax&quot;</span><span class="s1">):</span>
                <span class="s1">expected_dtype = </span><span class="s3">&quot;boolean&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">expected_dtype = </span><span class="s3">f&quot;Int</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s2">if </span><span class="s1">op_name == </span><span class="s3">&quot;cumsum&quot;</span><span class="s1">:</span>
            <span class="s1">result = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
            <span class="s1">expected = pd.Series(</span>
                <span class="s1">pd.array(</span>
                    <span class="s1">getattr(ser.astype(</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span><span class="s2">,</span>
                    <span class="s1">dtype=expected_dtype</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;cummax&quot;</span><span class="s2">, </span><span class="s3">&quot;cummin&quot;</span><span class="s1">]:</span>
            <span class="s1">result = getattr(ser</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
            <span class="s1">expected = pd.Series(</span>
                <span class="s1">pd.array(</span>
                    <span class="s1">getattr(ser.astype(</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span><span class="s2">,</span>
                    <span class="s1">dtype=ser.dtype</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">elif </span><span class="s1">op_name == </span><span class="s3">&quot;cumprod&quot;</span><span class="s1">:</span>
            <span class="s1">result = getattr(ser[:</span><span class="s5">12</span><span class="s1">]</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span>
            <span class="s1">expected = pd.Series(</span>
                <span class="s1">pd.array(</span>
                    <span class="s1">getattr(ser[:</span><span class="s5">12</span><span class="s1">].astype(</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">op_name)(skipna=skipna)</span><span class="s2">,</span>
                    <span class="s1">dtype=expected_dtype</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">op_name</span><span class="s2">} </span><span class="s3">not supported&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestUnaryOps(base.BaseUnaryOpsTests):</span>
    <span class="s2">def </span><span class="s1">test_invert(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">if </span><span class="s1">data.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">reason=</span><span class="s3">&quot;Looks like the base class test implicitly assumes &quot;</span>
                <span class="s3">&quot;boolean/integer dtypes&quot;</span>
            <span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>
        <span class="s1">super().test_invert(data)</span>


<span class="s2">class </span><span class="s1">TestPrinting(base.BasePrintingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestParsing(base.BaseParsingTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">Test2DCompat(base.Dim2CompatTests):</span>
    <span class="s2">pass</span>
</pre>
</body>
</html>