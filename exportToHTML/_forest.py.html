<html>
<head>
<title>_forest.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_forest.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Forest of trees-based ensemble methods. 
 
Those methods include random forests and extremely randomized trees. 
 
The module structure is the following: 
 
- The ``BaseForest`` base class implements a common ``fit`` method for all 
  the estimators in the module. The ``fit`` method of the base ``Forest`` 
  class calls the ``fit`` method of each sub-estimator on random samples 
  (with replacement, a.k.a. bootstrap) of the training set. 
 
  The init of the sub-estimator is further delegated to the 
  ``BaseEnsemble`` constructor. 
 
- The ``ForestClassifier`` and ``ForestRegressor`` base classes further 
  implement the prediction logic by computing an average of the predicted 
  outcomes of the sub-estimators. 
 
- The ``RandomForestClassifier`` and ``RandomForestRegressor`` derived 
  classes provide the user with concrete implementations of 
  the forest ensemble method using classical, deterministic 
  ``DecisionTreeClassifier`` and ``DecisionTreeRegressor`` as 
  sub-estimator implementations. 
 
- The ``ExtraTreesClassifier`` and ``ExtraTreesRegressor`` derived 
  classes provide the user with concrete implementations of the 
  forest ensemble method using the extremely randomized trees 
  ``ExtraTreeClassifier`` and ``ExtraTreeRegressor`` as 
  sub-estimator implementations. 
 
Single and multi-output problems are both handled. 
&quot;&quot;&quot;</span>

<span class="s2"># Authors: Gilles Louppe &lt;g.louppe@gmail.com&gt;</span>
<span class="s2">#          Brian Holt &lt;bdholt1@gmail.com&gt;</span>
<span class="s2">#          Joly Arnaud &lt;arnaud.v.joly@gmail.com&gt;</span>
<span class="s2">#          Fares Hedayati &lt;fares.hedayati@gmail.com&gt;</span>
<span class="s2">#</span>
<span class="s2"># License: BSD 3 clause</span>


<span class="s3">import </span><span class="s1">threading</span>
<span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABCMeta</span><span class="s3">, </span><span class="s1">abstractmethod</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s3">, </span><span class="s1">Real</span>
<span class="s3">from </span><span class="s1">warnings </span><span class="s3">import </span><span class="s1">catch_warnings</span><span class="s3">, </span><span class="s1">simplefilter</span><span class="s3">, </span><span class="s1">warn</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy.sparse </span><span class="s3">import </span><span class="s1">hstack </span><span class="s3">as </span><span class="s1">sparse_hstack</span>
<span class="s3">from </span><span class="s1">scipy.sparse </span><span class="s3">import </span><span class="s1">issparse</span>

<span class="s3">from </span><span class="s1">..base </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">ClassifierMixin</span><span class="s3">,</span>
    <span class="s1">MultiOutputMixin</span><span class="s3">,</span>
    <span class="s1">RegressorMixin</span><span class="s3">,</span>
    <span class="s1">TransformerMixin</span><span class="s3">,</span>
    <span class="s1">_fit_context</span><span class="s3">,</span>
    <span class="s1">is_classifier</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">..exceptions </span><span class="s3">import </span><span class="s1">DataConversionWarning</span>
<span class="s3">from </span><span class="s1">..metrics </span><span class="s3">import </span><span class="s1">accuracy_score</span><span class="s3">, </span><span class="s1">r2_score</span>
<span class="s3">from </span><span class="s1">..preprocessing </span><span class="s3">import </span><span class="s1">OneHotEncoder</span>
<span class="s3">from </span><span class="s1">..tree </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">BaseDecisionTree</span><span class="s3">,</span>
    <span class="s1">DecisionTreeClassifier</span><span class="s3">,</span>
    <span class="s1">DecisionTreeRegressor</span><span class="s3">,</span>
    <span class="s1">ExtraTreeClassifier</span><span class="s3">,</span>
    <span class="s1">ExtraTreeRegressor</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">..tree._tree </span><span class="s3">import </span><span class="s1">DOUBLE</span><span class="s3">, </span><span class="s1">DTYPE</span>
<span class="s3">from </span><span class="s1">..utils </span><span class="s3">import </span><span class="s1">check_random_state</span><span class="s3">, </span><span class="s1">compute_sample_weight</span>
<span class="s3">from </span><span class="s1">..utils._param_validation </span><span class="s3">import </span><span class="s1">Interval</span><span class="s3">, </span><span class="s1">RealNotInt</span><span class="s3">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s1">..utils.multiclass </span><span class="s3">import </span><span class="s1">check_classification_targets</span><span class="s3">, </span><span class="s1">type_of_target</span>
<span class="s3">from </span><span class="s1">..utils.parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s3">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s1">..utils.validation </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">_check_feature_names_in</span><span class="s3">,</span>
    <span class="s1">_check_sample_weight</span><span class="s3">,</span>
    <span class="s1">_num_samples</span><span class="s3">,</span>
    <span class="s1">check_is_fitted</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">._base </span><span class="s3">import </span><span class="s1">BaseEnsemble</span><span class="s3">, </span><span class="s1">_partition_estimators</span>

<span class="s1">__all__ = [</span>
    <span class="s4">&quot;RandomForestClassifier&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;RandomForestRegressor&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;ExtraTreesClassifier&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;ExtraTreesRegressor&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;RandomTreesEmbedding&quot;</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s1">MAX_INT = np.iinfo(np.int32).max</span>


<span class="s3">def </span><span class="s1">_get_n_samples_bootstrap(n_samples</span><span class="s3">, </span><span class="s1">max_samples):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the number of samples in a bootstrap sample. 
 
    Parameters 
    ---------- 
    n_samples : int 
        Number of samples in the dataset. 
    max_samples : int or float 
        The maximum number of samples to draw from the total available: 
            - if float, this indicates a fraction of the total and should be 
              the interval `(0.0, 1.0]`; 
            - if int, this indicates the exact number of samples; 
            - if None, this indicates the total number of samples. 
 
    Returns 
    ------- 
    n_samples_bootstrap : int 
        The total number of samples to draw for the bootstrap sample. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">max_samples </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">n_samples</span>

    <span class="s3">if </span><span class="s1">isinstance(max_samples</span><span class="s3">, </span><span class="s1">Integral):</span>
        <span class="s3">if </span><span class="s1">max_samples &gt; n_samples:</span>
            <span class="s1">msg = </span><span class="s4">&quot;`max_samples` must be &lt;= n_samples={} but got value {}&quot;</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg.format(n_samples</span><span class="s3">, </span><span class="s1">max_samples))</span>
        <span class="s3">return </span><span class="s1">max_samples</span>

    <span class="s3">if </span><span class="s1">isinstance(max_samples</span><span class="s3">, </span><span class="s1">Real):</span>
        <span class="s3">return </span><span class="s1">max(round(n_samples * max_samples)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_generate_sample_indices(random_state</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_samples_bootstrap):</span>
    <span class="s0">&quot;&quot;&quot; 
    Private function used to _parallel_build_trees function.&quot;&quot;&quot;</span>

    <span class="s1">random_instance = check_random_state(random_state)</span>
    <span class="s1">sample_indices = random_instance.randint(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_samples_bootstrap)</span>

    <span class="s3">return </span><span class="s1">sample_indices</span>


<span class="s3">def </span><span class="s1">_generate_unsampled_indices(random_state</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_samples_bootstrap):</span>
    <span class="s0">&quot;&quot;&quot; 
    Private function used to forest._set_oob_score function.&quot;&quot;&quot;</span>
    <span class="s1">sample_indices = _generate_sample_indices(</span>
        <span class="s1">random_state</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_samples_bootstrap</span>
    <span class="s1">)</span>
    <span class="s1">sample_counts = np.bincount(sample_indices</span><span class="s3">, </span><span class="s1">minlength=n_samples)</span>
    <span class="s1">unsampled_mask = sample_counts == </span><span class="s5">0</span>
    <span class="s1">indices_range = np.arange(n_samples)</span>
    <span class="s1">unsampled_indices = indices_range[unsampled_mask]</span>

    <span class="s3">return </span><span class="s1">unsampled_indices</span>


<span class="s3">def </span><span class="s1">_parallel_build_trees(</span>
    <span class="s1">tree</span><span class="s3">,</span>
    <span class="s1">bootstrap</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">sample_weight</span><span class="s3">,</span>
    <span class="s1">tree_idx</span><span class="s3">,</span>
    <span class="s1">n_trees</span><span class="s3">,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">class_weight=</span><span class="s3">None,</span>
    <span class="s1">n_samples_bootstrap=</span><span class="s3">None,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Private function used to fit a single tree in parallel.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">print(</span><span class="s4">&quot;building tree %d of %d&quot; </span><span class="s1">% (tree_idx + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_trees))</span>

    <span class="s3">if </span><span class="s1">bootstrap:</span>
        <span class="s1">n_samples = X.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">curr_sample_weight = np.ones((n_samples</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">curr_sample_weight = sample_weight.copy()</span>

        <span class="s1">indices = _generate_sample_indices(</span>
            <span class="s1">tree.random_state</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_samples_bootstrap</span>
        <span class="s1">)</span>
        <span class="s1">sample_counts = np.bincount(indices</span><span class="s3">, </span><span class="s1">minlength=n_samples)</span>
        <span class="s1">curr_sample_weight *= sample_counts</span>

        <span class="s3">if </span><span class="s1">class_weight == </span><span class="s4">&quot;subsample&quot;</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">catch_warnings():</span>
                <span class="s1">simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s3">, </span><span class="s1">DeprecationWarning)</span>
                <span class="s1">curr_sample_weight *= compute_sample_weight(</span><span class="s4">&quot;auto&quot;</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">indices=indices)</span>
        <span class="s3">elif </span><span class="s1">class_weight == </span><span class="s4">&quot;balanced_subsample&quot;</span><span class="s1">:</span>
            <span class="s1">curr_sample_weight *= compute_sample_weight(</span><span class="s4">&quot;balanced&quot;</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">indices=indices)</span>

        <span class="s1">tree.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=curr_sample_weight</span><span class="s3">, </span><span class="s1">check_input=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">tree.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight</span><span class="s3">, </span><span class="s1">check_input=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">tree</span>


<span class="s3">class </span><span class="s1">BaseForest(MultiOutputMixin</span><span class="s3">, </span><span class="s1">BaseEnsemble</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for forests of trees. 
 
    Warning: This class should not be used directly. Use derived classes 
    instead. 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s4">&quot;n_estimators&quot;</span><span class="s1">: [Interval(Integral</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;bootstrap&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;oob_score&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s3">, </span><span class="s1">callable]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s1">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;warm_start&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;max_samples&quot;</span><span class="s1">: [</span>
            <span class="s3">None,</span>
            <span class="s1">Interval(RealNotInt</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">closed=</span><span class="s4">&quot;right&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Interval(Integral</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">estimator</span><span class="s3">,</span>
        <span class="s1">n_estimators=</span><span class="s5">100</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">estimator_params=tuple()</span><span class="s3">,</span>
        <span class="s1">bootstrap=</span><span class="s3">False,</span>
        <span class="s1">oob_score=</span><span class="s3">False,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">warm_start=</span><span class="s3">False,</span>
        <span class="s1">class_weight=</span><span class="s3">None,</span>
        <span class="s1">max_samples=</span><span class="s3">None,</span>
        <span class="s1">base_estimator=</span><span class="s4">&quot;deprecated&quot;</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">estimator=estimator</span><span class="s3">,</span>
            <span class="s1">n_estimators=n_estimators</span><span class="s3">,</span>
            <span class="s1">estimator_params=estimator_params</span><span class="s3">,</span>
            <span class="s1">base_estimator=base_estimator</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">self.bootstrap = bootstrap</span>
        <span class="s1">self.oob_score = oob_score</span>
        <span class="s1">self.n_jobs = n_jobs</span>
        <span class="s1">self.random_state = random_state</span>
        <span class="s1">self.verbose = verbose</span>
        <span class="s1">self.warm_start = warm_start</span>
        <span class="s1">self.class_weight = class_weight</span>
        <span class="s1">self.max_samples = max_samples</span>

    <span class="s3">def </span><span class="s1">apply(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply trees in the forest to X, return leaf indices. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, its dtype will be converted to 
            ``dtype=np.float32``. If a sparse matrix is provided, it will be 
            converted into a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        X_leaves : ndarray of shape (n_samples, n_estimators) 
            For each datapoint x in X and for each tree in the forest, 
            return the index of the leaf x ends up in. 
        &quot;&quot;&quot;</span>
        <span class="s1">X = self._validate_X_predict(X)</span>
        <span class="s1">results = Parallel(</span>
            <span class="s1">n_jobs=self.n_jobs</span><span class="s3">,</span>
            <span class="s1">verbose=self.verbose</span><span class="s3">,</span>
            <span class="s1">prefer=</span><span class="s4">&quot;threads&quot;</span><span class="s3">,</span>
        <span class="s1">)(delayed(tree.apply)(X</span><span class="s3">, </span><span class="s1">check_input=</span><span class="s3">False</span><span class="s1">) </span><span class="s3">for </span><span class="s1">tree </span><span class="s3">in </span><span class="s1">self.estimators_)</span>

        <span class="s3">return </span><span class="s1">np.array(results).T</span>

    <span class="s3">def </span><span class="s1">decision_path(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the decision path in the forest. 
 
        .. versionadded:: 0.18 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, its dtype will be converted to 
            ``dtype=np.float32``. If a sparse matrix is provided, it will be 
            converted into a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        indicator : sparse matrix of shape (n_samples, n_nodes) 
            Return a node indicator matrix where non zero elements indicates 
            that the samples goes through the nodes. The matrix is of CSR 
            format. 
 
        n_nodes_ptr : ndarray of shape (n_estimators + 1,) 
            The columns from indicator[n_nodes_ptr[i]:n_nodes_ptr[i+1]] 
            gives the indicator value for the i-th estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">X = self._validate_X_predict(X)</span>
        <span class="s1">indicators = Parallel(</span>
            <span class="s1">n_jobs=self.n_jobs</span><span class="s3">,</span>
            <span class="s1">verbose=self.verbose</span><span class="s3">,</span>
            <span class="s1">prefer=</span><span class="s4">&quot;threads&quot;</span><span class="s3">,</span>
        <span class="s1">)(</span>
            <span class="s1">delayed(tree.decision_path)(X</span><span class="s3">, </span><span class="s1">check_input=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">tree </span><span class="s3">in </span><span class="s1">self.estimators_</span>
        <span class="s1">)</span>

        <span class="s1">n_nodes = [</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">n_nodes.extend([i.shape[</span><span class="s5">1</span><span class="s1">] </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">indicators])</span>
        <span class="s1">n_nodes_ptr = np.array(n_nodes).cumsum()</span>

        <span class="s3">return </span><span class="s1">sparse_hstack(indicators).tocsr()</span><span class="s3">, </span><span class="s1">n_nodes_ptr</span>

    <span class="s1">@_fit_context(prefer_skip_nested_validation=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Build a forest of trees from the training set (X, y). 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The training input samples. Internally, its dtype will be converted 
            to ``dtype=np.float32``. If a sparse matrix is provided, it will be 
            converted into a sparse ``csc_matrix``. 
 
        y : array-like of shape (n_samples,) or (n_samples, n_outputs) 
            The target values (class labels in classification, real numbers in 
            regression). 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If None, then samples are equally weighted. Splits 
            that would create child nodes with net zero or negative weight are 
            ignored while searching for a split in each node. In the case of 
            classification, splits are also ignored if they would result in any 
            single class carrying a negative weight in either child node. 
 
        Returns 
        ------- 
        self : object 
            Fitted estimator. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Validate or convert input data</span>
        <span class="s3">if </span><span class="s1">issparse(y):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;sparse multilabel-indicator for y is not supported.&quot;</span><span class="s1">)</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y = self._validate_data(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">multi_output=</span><span class="s3">True, </span><span class="s1">accept_sparse=</span><span class="s4">&quot;csc&quot;</span><span class="s3">, </span><span class="s1">dtype=DTYPE</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">sample_weight = _check_sample_weight(sample_weight</span><span class="s3">, </span><span class="s1">X)</span>

        <span class="s3">if </span><span class="s1">issparse(X):</span>
            <span class="s2"># Pre-sort indices to avoid that each individual tree of the</span>
            <span class="s2"># ensemble sorts the indices.</span>
            <span class="s1">X.sort_indices()</span>

        <span class="s1">y = np.atleast_1d(y)</span>
        <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">y.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">warn(</span>
                <span class="s1">(</span>
                    <span class="s4">&quot;A column-vector y was passed when a 1d array was&quot;</span>
                    <span class="s4">&quot; expected. Please change the shape of y to &quot;</span>
                    <span class="s4">&quot;(n_samples,), for example using ravel().&quot;</span>
                <span class="s1">)</span><span class="s3">,</span>
                <span class="s1">DataConversionWarning</span><span class="s3">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># reshape is necessary to preserve the data contiguity against vs</span>
            <span class="s2"># [:, np.newaxis] that does not.</span>
            <span class="s1">y = np.reshape(y</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s3">if </span><span class="s1">self.criterion == </span><span class="s4">&quot;poisson&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">np.any(y &lt; </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Some value(s) of y are negative which is &quot;</span>
                    <span class="s4">&quot;not allowed for Poisson regression.&quot;</span>
                <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">np.sum(y) &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Sum of y is not strictly positive which &quot;</span>
                    <span class="s4">&quot;is necessary for Poisson regression.&quot;</span>
                <span class="s1">)</span>

        <span class="s1">self.n_outputs_ = y.shape[</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">y</span><span class="s3">, </span><span class="s1">expanded_class_weight = self._validate_y_class_weight(y)</span>

        <span class="s3">if </span><span class="s1">getattr(y</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">, None</span><span class="s1">) != DOUBLE </span><span class="s3">or not </span><span class="s1">y.flags.contiguous:</span>
            <span class="s1">y = np.ascontiguousarray(y</span><span class="s3">, </span><span class="s1">dtype=DOUBLE)</span>

        <span class="s3">if </span><span class="s1">expanded_class_weight </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">sample_weight = sample_weight * expanded_class_weight</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">sample_weight = expanded_class_weight</span>

        <span class="s3">if not </span><span class="s1">self.bootstrap </span><span class="s3">and </span><span class="s1">self.max_samples </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;`max_sample` cannot be set if `bootstrap=False`. &quot;</span>
                <span class="s4">&quot;Either switch to `bootstrap=True` or set &quot;</span>
                <span class="s4">&quot;`max_sample=None`.&quot;</span>
            <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">self.bootstrap:</span>
            <span class="s1">n_samples_bootstrap = _get_n_samples_bootstrap(</span>
                <span class="s1">n_samples=X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">max_samples=self.max_samples</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">n_samples_bootstrap = </span><span class="s3">None</span>

        <span class="s1">self._validate_estimator()</span>

        <span class="s3">if not </span><span class="s1">self.bootstrap </span><span class="s3">and </span><span class="s1">self.oob_score:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Out of bag estimation only available if bootstrap=True&quot;</span><span class="s1">)</span>

        <span class="s1">random_state = check_random_state(self.random_state)</span>

        <span class="s3">if not </span><span class="s1">self.warm_start </span><span class="s3">or not </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;estimators_&quot;</span><span class="s1">):</span>
            <span class="s2"># Free allocated memory, if any</span>
            <span class="s1">self.estimators_ = []</span>

        <span class="s1">n_more_estimators = self.n_estimators - len(self.estimators_)</span>

        <span class="s3">if </span><span class="s1">n_more_estimators &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;n_estimators=%d must be larger or equal to &quot;</span>
                <span class="s4">&quot;len(estimators_)=%d when warm_start==True&quot;</span>
                <span class="s1">% (self.n_estimators</span><span class="s3">, </span><span class="s1">len(self.estimators_))</span>
            <span class="s1">)</span>

        <span class="s3">elif </span><span class="s1">n_more_estimators == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">warn(</span>
                <span class="s4">&quot;Warm-start fitting without increasing n_estimators does not &quot;</span>
                <span class="s4">&quot;fit new trees.&quot;</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.warm_start </span><span class="s3">and </span><span class="s1">len(self.estimators_) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2"># We draw from the random state to get the random state we</span>
                <span class="s2"># would have got if we hadn't used a warm_start.</span>
                <span class="s1">random_state.randint(MAX_INT</span><span class="s3">, </span><span class="s1">size=len(self.estimators_))</span>

            <span class="s1">trees = [</span>
                <span class="s1">self._make_estimator(append=</span><span class="s3">False, </span><span class="s1">random_state=random_state)</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n_more_estimators)</span>
            <span class="s1">]</span>

            <span class="s2"># Parallel loop: we prefer the threading backend as the Cython code</span>
            <span class="s2"># for fitting the trees is internally releasing the Python GIL</span>
            <span class="s2"># making threading more efficient than multiprocessing in</span>
            <span class="s2"># that case. However, for joblib 0.12+ we respect any</span>
            <span class="s2"># parallel_backend contexts set at a higher level,</span>
            <span class="s2"># since correctness does not rely on using threads.</span>
            <span class="s1">trees = Parallel(</span>
                <span class="s1">n_jobs=self.n_jobs</span><span class="s3">,</span>
                <span class="s1">verbose=self.verbose</span><span class="s3">,</span>
                <span class="s1">prefer=</span><span class="s4">&quot;threads&quot;</span><span class="s3">,</span>
            <span class="s1">)(</span>
                <span class="s1">delayed(_parallel_build_trees)(</span>
                    <span class="s1">t</span><span class="s3">,</span>
                    <span class="s1">self.bootstrap</span><span class="s3">,</span>
                    <span class="s1">X</span><span class="s3">,</span>
                    <span class="s1">y</span><span class="s3">,</span>
                    <span class="s1">sample_weight</span><span class="s3">,</span>
                    <span class="s1">i</span><span class="s3">,</span>
                    <span class="s1">len(trees)</span><span class="s3">,</span>
                    <span class="s1">verbose=self.verbose</span><span class="s3">,</span>
                    <span class="s1">class_weight=self.class_weight</span><span class="s3">,</span>
                    <span class="s1">n_samples_bootstrap=n_samples_bootstrap</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">t </span><span class="s3">in </span><span class="s1">enumerate(trees)</span>
            <span class="s1">)</span>

            <span class="s2"># Collect newly grown trees</span>
            <span class="s1">self.estimators_.extend(trees)</span>

        <span class="s3">if </span><span class="s1">self.oob_score </span><span class="s3">and </span><span class="s1">(</span>
            <span class="s1">n_more_estimators &gt; </span><span class="s5">0 </span><span class="s3">or not </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;oob_score_&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">y_type = type_of_target(y)</span>
            <span class="s3">if </span><span class="s1">y_type </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;multiclass-multioutput&quot;</span><span class="s3">, </span><span class="s4">&quot;unknown&quot;</span><span class="s1">):</span>
                <span class="s2"># FIXME: we could consider to support multiclass-multioutput if</span>
                <span class="s2"># we introduce or reuse a constructor parameter (e.g.</span>
                <span class="s2"># oob_score) allowing our user to pass a callable defining the</span>
                <span class="s2"># scoring strategy on OOB sample.</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;The type of target cannot be used to compute OOB &quot;</span>
                    <span class="s4">f&quot;estimates. Got </span><span class="s3">{</span><span class="s1">y_type</span><span class="s3">} </span><span class="s4">while only the following are &quot;</span>
                    <span class="s4">&quot;supported: continuous, continuous-multioutput, binary, &quot;</span>
                    <span class="s4">&quot;multiclass, multilabel-indicator.&quot;</span>
                <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">callable(self.oob_score):</span>
                <span class="s1">self._set_oob_score_and_attributes(</span>
                    <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">scoring_function=self.oob_score</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._set_oob_score_and_attributes(X</span><span class="s3">, </span><span class="s1">y)</span>

        <span class="s2"># Decapsulate classes_ attributes</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;classes_&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s1">self.n_outputs_ == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self.n_classes_ = self.n_classes_[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">self.classes_ = self.classes_[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">_set_oob_score_and_attributes(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">scoring_function=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Compute and set the OOB score and attributes. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data matrix. 
        y : ndarray of shape (n_samples, n_outputs) 
            The target matrix. 
        scoring_function : callable, default=None 
            Scoring function for OOB score. Default depends on whether 
            this is a regression (R2 score) or classification problem 
            (accuracy score). 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_compute_oob_predictions(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot;Compute and set the OOB score. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data matrix. 
        y : ndarray of shape (n_samples, n_outputs) 
            The target matrix. 
 
        Returns 
        ------- 
        oob_pred : ndarray of shape (n_samples, n_classes, n_outputs) or \ 
                (n_samples, 1, n_outputs) 
            The OOB predictions. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Prediction requires X to be in CSR format</span>
        <span class="s3">if </span><span class="s1">issparse(X):</span>
            <span class="s1">X = X.tocsr()</span>

        <span class="s1">n_samples = y.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">n_outputs = self.n_outputs_</span>
        <span class="s3">if </span><span class="s1">is_classifier(self) </span><span class="s3">and </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;n_classes_&quot;</span><span class="s1">):</span>
            <span class="s2"># n_classes_ is a ndarray at this stage</span>
            <span class="s2"># all the supported type of target will have the same number of</span>
            <span class="s2"># classes in all outputs</span>
            <span class="s1">oob_pred_shape = (n_samples</span><span class="s3">, </span><span class="s1">self.n_classes_[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">n_outputs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># for regression, n_classes_ does not exist and we create an empty</span>
            <span class="s2"># axis to be consistent with the classification case and make</span>
            <span class="s2"># the array operations compatible with the 2 settings</span>
            <span class="s1">oob_pred_shape = (n_samples</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_outputs)</span>

        <span class="s1">oob_pred = np.zeros(shape=oob_pred_shape</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">n_oob_pred = np.zeros((n_samples</span><span class="s3">, </span><span class="s1">n_outputs)</span><span class="s3">, </span><span class="s1">dtype=np.int64)</span>

        <span class="s1">n_samples_bootstrap = _get_n_samples_bootstrap(</span>
            <span class="s1">n_samples</span><span class="s3">,</span>
            <span class="s1">self.max_samples</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">self.estimators_:</span>
            <span class="s1">unsampled_indices = _generate_unsampled_indices(</span>
                <span class="s1">estimator.random_state</span><span class="s3">,</span>
                <span class="s1">n_samples</span><span class="s3">,</span>
                <span class="s1">n_samples_bootstrap</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s1">y_pred = self._get_oob_predictions(estimator</span><span class="s3">, </span><span class="s1">X[unsampled_indices</span><span class="s3">, </span><span class="s1">:])</span>
            <span class="s1">oob_pred[unsampled_indices</span><span class="s3">, </span><span class="s1">...] += y_pred</span>
            <span class="s1">n_oob_pred[unsampled_indices</span><span class="s3">, </span><span class="s1">:] += </span><span class="s5">1</span>

        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(n_outputs):</span>
            <span class="s3">if </span><span class="s1">(n_oob_pred == </span><span class="s5">0</span><span class="s1">).any():</span>
                <span class="s1">warn(</span>
                    <span class="s1">(</span>
                        <span class="s4">&quot;Some inputs do not have OOB scores. This probably means &quot;</span>
                        <span class="s4">&quot;too few trees were used to compute any reliable OOB &quot;</span>
                        <span class="s4">&quot;estimates.&quot;</span>
                    <span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">UserWarning</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s1">n_oob_pred[n_oob_pred == </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>
            <span class="s1">oob_pred[...</span><span class="s3">, </span><span class="s1">k] /= n_oob_pred[...</span><span class="s3">, </span><span class="s1">[k]]</span>

        <span class="s3">return </span><span class="s1">oob_pred</span>

    <span class="s3">def </span><span class="s1">_validate_y_class_weight(self</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s2"># Default implementation</span>
        <span class="s3">return </span><span class="s1">y</span><span class="s3">, None</span>

    <span class="s3">def </span><span class="s1">_validate_X_predict(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate X whenever one tries to predict, apply, predict_proba.&quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s1">X = self._validate_data(X</span><span class="s3">, </span><span class="s1">dtype=DTYPE</span><span class="s3">, </span><span class="s1">accept_sparse=</span><span class="s4">&quot;csr&quot;</span><span class="s3">, </span><span class="s1">reset=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">issparse(X) </span><span class="s3">and </span><span class="s1">(X.indices.dtype != np.intc </span><span class="s3">or </span><span class="s1">X.indptr.dtype != np.intc):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No support for np.int64 index based sparse matrices&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">X</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">feature_importances_(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The impurity-based feature importances. 
 
        The higher, the more important the feature. 
        The importance of a feature is computed as the (normalized) 
        total reduction of the criterion brought by that feature.  It is also 
        known as the Gini importance. 
 
        Warning: impurity-based feature importances can be misleading for 
        high cardinality features (many unique values). See 
        :func:`sklearn.inspection.permutation_importance` as an alternative. 
 
        Returns 
        ------- 
        feature_importances_ : ndarray of shape (n_features,) 
            The values of this array sum to 1, unless all trees are single node 
            trees consisting of only the root node, in which case it will be an 
            array of zeros. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>

        <span class="s1">all_importances = Parallel(n_jobs=self.n_jobs</span><span class="s3">, </span><span class="s1">prefer=</span><span class="s4">&quot;threads&quot;</span><span class="s1">)(</span>
            <span class="s1">delayed(getattr)(tree</span><span class="s3">, </span><span class="s4">&quot;feature_importances_&quot;</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">tree </span><span class="s3">in </span><span class="s1">self.estimators_</span>
            <span class="s3">if </span><span class="s1">tree.tree_.node_count &gt; </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">all_importances:</span>
            <span class="s3">return </span><span class="s1">np.zeros(self.n_features_in_</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>

        <span class="s1">all_importances = np.mean(all_importances</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s3">return </span><span class="s1">all_importances / np.sum(all_importances)</span>


<span class="s3">def </span><span class="s1">_accumulate_prediction(predict</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lock):</span>
    <span class="s0">&quot;&quot;&quot; 
    This is a utility function for joblib's Parallel. 
 
    It can't go locally in ForestClassifier or ForestRegressor, because joblib 
    complains that it cannot pickle it when placed there. 
    &quot;&quot;&quot;</span>
    <span class="s1">prediction = predict(X</span><span class="s3">, </span><span class="s1">check_input=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">with </span><span class="s1">lock:</span>
        <span class="s3">if </span><span class="s1">len(out) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">out[</span><span class="s5">0</span><span class="s1">] += prediction</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(out)):</span>
                <span class="s1">out[i] += prediction[i]</span>


<span class="s3">class </span><span class="s1">ForestClassifier(ClassifierMixin</span><span class="s3">, </span><span class="s1">BaseForest</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for forest of trees-based classifiers. 
 
    Warning: This class should not be used directly. Use derived classes 
    instead. 
    &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">estimator</span><span class="s3">,</span>
        <span class="s1">n_estimators=</span><span class="s5">100</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">estimator_params=tuple()</span><span class="s3">,</span>
        <span class="s1">bootstrap=</span><span class="s3">False,</span>
        <span class="s1">oob_score=</span><span class="s3">False,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">warm_start=</span><span class="s3">False,</span>
        <span class="s1">class_weight=</span><span class="s3">None,</span>
        <span class="s1">max_samples=</span><span class="s3">None,</span>
        <span class="s1">base_estimator=</span><span class="s4">&quot;deprecated&quot;</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">estimator=estimator</span><span class="s3">,</span>
            <span class="s1">n_estimators=n_estimators</span><span class="s3">,</span>
            <span class="s1">estimator_params=estimator_params</span><span class="s3">,</span>
            <span class="s1">bootstrap=bootstrap</span><span class="s3">,</span>
            <span class="s1">oob_score=oob_score</span><span class="s3">,</span>
            <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
            <span class="s1">verbose=verbose</span><span class="s3">,</span>
            <span class="s1">warm_start=warm_start</span><span class="s3">,</span>
            <span class="s1">class_weight=class_weight</span><span class="s3">,</span>
            <span class="s1">max_samples=max_samples</span><span class="s3">,</span>
            <span class="s1">base_estimator=base_estimator</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_get_oob_predictions(tree</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Compute the OOB predictions for an individual tree. 
 
        Parameters 
        ---------- 
        tree : DecisionTreeClassifier object 
            A single decision tree classifier. 
        X : ndarray of shape (n_samples, n_features) 
            The OOB samples. 
 
        Returns 
        ------- 
        y_pred : ndarray of shape (n_samples, n_classes, n_outputs) 
            The OOB associated predictions. 
        &quot;&quot;&quot;</span>
        <span class="s1">y_pred = tree.predict_proba(X</span><span class="s3">, </span><span class="s1">check_input=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">y_pred = np.array(y_pred</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">y_pred.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2"># binary and multiclass</span>
            <span class="s1">y_pred = y_pred[...</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Roll the first `n_outputs` axis to the last axis. We will reshape</span>
            <span class="s2"># from a shape of (n_outputs, n_samples, n_classes) to a shape of</span>
            <span class="s2"># (n_samples, n_classes, n_outputs).</span>
            <span class="s1">y_pred = np.rollaxis(y_pred</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">start=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">y_pred</span>

    <span class="s3">def </span><span class="s1">_set_oob_score_and_attributes(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">scoring_function=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Compute and set the OOB score and attributes. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data matrix. 
        y : ndarray of shape (n_samples, n_outputs) 
            The target matrix. 
        scoring_function : callable, default=None 
            Scoring function for OOB score. Defaults to `accuracy_score`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.oob_decision_function_ = super()._compute_oob_predictions(X</span><span class="s3">, </span><span class="s1">y)</span>
        <span class="s3">if </span><span class="s1">self.oob_decision_function_.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># drop the n_outputs axis if there is a single output</span>
            <span class="s1">self.oob_decision_function_ = self.oob_decision_function_.squeeze(axis=-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">scoring_function </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">scoring_function = accuracy_score</span>

        <span class="s1">self.oob_score_ = scoring_function(</span>
            <span class="s1">y</span><span class="s3">, </span><span class="s1">np.argmax(self.oob_decision_function_</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_validate_y_class_weight(self</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s1">check_classification_targets(y)</span>

        <span class="s1">y = np.copy(y)</span>
        <span class="s1">expanded_class_weight = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">self.class_weight </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">y_original = np.copy(y)</span>

        <span class="s1">self.classes_ = []</span>
        <span class="s1">self.n_classes_ = []</span>

        <span class="s1">y_store_unique_indices = np.zeros(y.shape</span><span class="s3">, </span><span class="s1">dtype=int)</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(self.n_outputs_):</span>
            <span class="s1">classes_k</span><span class="s3">, </span><span class="s1">y_store_unique_indices[:</span><span class="s3">, </span><span class="s1">k] = np.unique(</span>
                <span class="s1">y[:</span><span class="s3">, </span><span class="s1">k]</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True</span>
            <span class="s1">)</span>
            <span class="s1">self.classes_.append(classes_k)</span>
            <span class="s1">self.n_classes_.append(classes_k.shape[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">y = y_store_unique_indices</span>

        <span class="s3">if </span><span class="s1">self.class_weight </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">valid_presets = (</span><span class="s4">&quot;balanced&quot;</span><span class="s3">, </span><span class="s4">&quot;balanced_subsample&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">isinstance(self.class_weight</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s3">if </span><span class="s1">self.class_weight </span><span class="s3">not in </span><span class="s1">valid_presets:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;Valid presets for class_weight include &quot;</span>
                        <span class="s4">'&quot;balanced&quot; and &quot;balanced_subsample&quot;.'</span>
                        <span class="s4">'Given &quot;%s&quot;.'</span>
                        <span class="s1">% self.class_weight</span>
                    <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">self.warm_start:</span>
                    <span class="s1">warn(</span>
                        <span class="s4">'class_weight presets &quot;balanced&quot; or '</span>
                        <span class="s4">'&quot;balanced_subsample&quot; are '</span>
                        <span class="s4">&quot;not recommended for warm_start if the fitted data &quot;</span>
                        <span class="s4">&quot;differs from the full dataset. In order to use &quot;</span>
                        <span class="s4">'&quot;balanced&quot; weights, use compute_class_weight '</span>
                        <span class="s4">'(&quot;balanced&quot;, classes, y). In place of y you can use '</span>
                        <span class="s4">&quot;a large enough sample of the full training set &quot;</span>
                        <span class="s4">&quot;target to properly estimate the class frequency &quot;</span>
                        <span class="s4">&quot;distributions. Pass the resulting weights as the &quot;</span>
                        <span class="s4">&quot;class_weight parameter.&quot;</span>
                    <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">self.class_weight != </span><span class="s4">&quot;balanced_subsample&quot; </span><span class="s3">or not </span><span class="s1">self.bootstrap:</span>
                <span class="s3">if </span><span class="s1">self.class_weight == </span><span class="s4">&quot;balanced_subsample&quot;</span><span class="s1">:</span>
                    <span class="s1">class_weight = </span><span class="s4">&quot;balanced&quot;</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">class_weight = self.class_weight</span>
                <span class="s1">expanded_class_weight = compute_sample_weight(class_weight</span><span class="s3">, </span><span class="s1">y_original)</span>

        <span class="s3">return </span><span class="s1">y</span><span class="s3">, </span><span class="s1">expanded_class_weight</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Predict class for X. 
 
        The predicted class of an input sample is a vote by the trees in 
        the forest, weighted by their probability estimates. That is, 
        the predicted class is the one with highest mean probability 
        estimate across the trees. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, its dtype will be converted to 
            ``dtype=np.float32``. If a sparse matrix is provided, it will be 
            converted into a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        y : ndarray of shape (n_samples,) or (n_samples, n_outputs) 
            The predicted classes. 
        &quot;&quot;&quot;</span>
        <span class="s1">proba = self.predict_proba(X)</span>

        <span class="s3">if </span><span class="s1">self.n_outputs_ == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.classes_.take(np.argmax(proba</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">n_samples = proba[</span><span class="s5">0</span><span class="s1">].shape[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2"># all dtypes should be the same, so just take the first</span>
            <span class="s1">class_type = self.classes_[</span><span class="s5">0</span><span class="s1">].dtype</span>
            <span class="s1">predictions = np.empty((n_samples</span><span class="s3">, </span><span class="s1">self.n_outputs_)</span><span class="s3">, </span><span class="s1">dtype=class_type)</span>

            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(self.n_outputs_):</span>
                <span class="s1">predictions[:</span><span class="s3">, </span><span class="s1">k] = self.classes_[k].take(</span>
                    <span class="s1">np.argmax(proba[k]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span>
                <span class="s1">)</span>

            <span class="s3">return </span><span class="s1">predictions</span>

    <span class="s3">def </span><span class="s1">predict_proba(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Predict class probabilities for X. 
 
        The predicted class probabilities of an input sample are computed as 
        the mean predicted class probabilities of the trees in the forest. 
        The class probability of a single tree is the fraction of samples of 
        the same class in a leaf. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, its dtype will be converted to 
            ``dtype=np.float32``. If a sparse matrix is provided, it will be 
            converted into a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        p : ndarray of shape (n_samples, n_classes), or a list of such arrays 
            The class probabilities of the input samples. The order of the 
            classes corresponds to that in the attribute :term:`classes_`. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s2"># Check data</span>
        <span class="s1">X = self._validate_X_predict(X)</span>

        <span class="s2"># Assign chunk of trees to jobs</span>
        <span class="s1">n_jobs</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ = _partition_estimators(self.n_estimators</span><span class="s3">, </span><span class="s1">self.n_jobs)</span>

        <span class="s2"># avoid storing the output of every estimator by summing them here</span>
        <span class="s1">all_proba = [</span>
            <span class="s1">np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">j)</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">np.atleast_1d(self.n_classes_)</span>
        <span class="s1">]</span>
        <span class="s1">lock = threading.Lock()</span>
        <span class="s1">Parallel(n_jobs=n_jobs</span><span class="s3">, </span><span class="s1">verbose=self.verbose</span><span class="s3">, </span><span class="s1">require=</span><span class="s4">&quot;sharedmem&quot;</span><span class="s1">)(</span>
            <span class="s1">delayed(_accumulate_prediction)(e.predict_proba</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">all_proba</span><span class="s3">, </span><span class="s1">lock)</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.estimators_</span>
        <span class="s1">)</span>

        <span class="s3">for </span><span class="s1">proba </span><span class="s3">in </span><span class="s1">all_proba:</span>
            <span class="s1">proba /= len(self.estimators_)</span>

        <span class="s3">if </span><span class="s1">len(all_proba) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">all_proba[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">all_proba</span>

    <span class="s3">def </span><span class="s1">predict_log_proba(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Predict class log-probabilities for X. 
 
        The predicted class log-probabilities of an input sample is computed as 
        the log of the mean predicted class probabilities of the trees in the 
        forest. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, its dtype will be converted to 
            ``dtype=np.float32``. If a sparse matrix is provided, it will be 
            converted into a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        p : ndarray of shape (n_samples, n_classes), or a list of such arrays 
            The class probabilities of the input samples. The order of the 
            classes corresponds to that in the attribute :term:`classes_`. 
        &quot;&quot;&quot;</span>
        <span class="s1">proba = self.predict_proba(X)</span>

        <span class="s3">if </span><span class="s1">self.n_outputs_ == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.log(proba)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(self.n_outputs_):</span>
                <span class="s1">proba[k] = np.log(proba[k])</span>

            <span class="s3">return </span><span class="s1">proba</span>

    <span class="s3">def </span><span class="s1">_more_tags(self):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;multilabel&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>


<span class="s3">class </span><span class="s1">ForestRegressor(RegressorMixin</span><span class="s3">, </span><span class="s1">BaseForest</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for forest of trees-based regressors. 
 
    Warning: This class should not be used directly. Use derived classes 
    instead. 
    &quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">estimator</span><span class="s3">,</span>
        <span class="s1">n_estimators=</span><span class="s5">100</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">estimator_params=tuple()</span><span class="s3">,</span>
        <span class="s1">bootstrap=</span><span class="s3">False,</span>
        <span class="s1">oob_score=</span><span class="s3">False,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">warm_start=</span><span class="s3">False,</span>
        <span class="s1">max_samples=</span><span class="s3">None,</span>
        <span class="s1">base_estimator=</span><span class="s4">&quot;deprecated&quot;</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">estimator</span><span class="s3">,</span>
            <span class="s1">n_estimators=n_estimators</span><span class="s3">,</span>
            <span class="s1">estimator_params=estimator_params</span><span class="s3">,</span>
            <span class="s1">bootstrap=bootstrap</span><span class="s3">,</span>
            <span class="s1">oob_score=oob_score</span><span class="s3">,</span>
            <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
            <span class="s1">verbose=verbose</span><span class="s3">,</span>
            <span class="s1">warm_start=warm_start</span><span class="s3">,</span>
            <span class="s1">max_samples=max_samples</span><span class="s3">,</span>
            <span class="s1">base_estimator=base_estimator</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Predict regression target for X. 
 
        The predicted regression target of an input sample is computed as the 
        mean predicted regression targets of the trees in the forest. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, its dtype will be converted to 
            ``dtype=np.float32``. If a sparse matrix is provided, it will be 
            converted into a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        y : ndarray of shape (n_samples,) or (n_samples, n_outputs) 
            The predicted values. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s2"># Check data</span>
        <span class="s1">X = self._validate_X_predict(X)</span>

        <span class="s2"># Assign chunk of trees to jobs</span>
        <span class="s1">n_jobs</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ = _partition_estimators(self.n_estimators</span><span class="s3">, </span><span class="s1">self.n_jobs)</span>

        <span class="s2"># avoid storing the output of every estimator by summing them here</span>
        <span class="s3">if </span><span class="s1">self.n_outputs_ &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">y_hat = np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.n_outputs_)</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">y_hat = np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>

        <span class="s2"># Parallel loop</span>
        <span class="s1">lock = threading.Lock()</span>
        <span class="s1">Parallel(n_jobs=n_jobs</span><span class="s3">, </span><span class="s1">verbose=self.verbose</span><span class="s3">, </span><span class="s1">require=</span><span class="s4">&quot;sharedmem&quot;</span><span class="s1">)(</span>
            <span class="s1">delayed(_accumulate_prediction)(e.predict</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">[y_hat]</span><span class="s3">, </span><span class="s1">lock)</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.estimators_</span>
        <span class="s1">)</span>

        <span class="s1">y_hat /= len(self.estimators_)</span>

        <span class="s3">return </span><span class="s1">y_hat</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_get_oob_predictions(tree</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Compute the OOB predictions for an individual tree. 
 
        Parameters 
        ---------- 
        tree : DecisionTreeRegressor object 
            A single decision tree regressor. 
        X : ndarray of shape (n_samples, n_features) 
            The OOB samples. 
 
        Returns 
        ------- 
        y_pred : ndarray of shape (n_samples, 1, n_outputs) 
            The OOB associated predictions. 
        &quot;&quot;&quot;</span>
        <span class="s1">y_pred = tree.predict(X</span><span class="s3">, </span><span class="s1">check_input=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">y_pred.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># single output regression</span>
            <span class="s1">y_pred = y_pred[:</span><span class="s3">, </span><span class="s1">np.newaxis</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># multioutput regression</span>
            <span class="s1">y_pred = y_pred[:</span><span class="s3">, </span><span class="s1">np.newaxis</span><span class="s3">, </span><span class="s1">:]</span>
        <span class="s3">return </span><span class="s1">y_pred</span>

    <span class="s3">def </span><span class="s1">_set_oob_score_and_attributes(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">scoring_function=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Compute and set the OOB score and attributes. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data matrix. 
        y : ndarray of shape (n_samples, n_outputs) 
            The target matrix. 
        scoring_function : callable, default=None 
            Scoring function for OOB score. Defaults to `r2_score`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.oob_prediction_ = super()._compute_oob_predictions(X</span><span class="s3">, </span><span class="s1">y).squeeze(axis=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.oob_prediction_.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># drop the n_outputs axis if there is a single output</span>
            <span class="s1">self.oob_prediction_ = self.oob_prediction_.squeeze(axis=-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">scoring_function </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">scoring_function = r2_score</span>

        <span class="s1">self.oob_score_ = scoring_function(y</span><span class="s3">, </span><span class="s1">self.oob_prediction_)</span>

    <span class="s3">def </span><span class="s1">_compute_partial_dependence_recursion(self</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">, </span><span class="s1">target_features):</span>
        <span class="s0">&quot;&quot;&quot;Fast partial dependence computation. 
 
        Parameters 
        ---------- 
        grid : ndarray of shape (n_samples, n_target_features) 
            The grid points on which the partial dependence should be 
            evaluated. 
        target_features : ndarray of shape (n_target_features) 
            The set of target features for which the partial dependence 
            should be evaluated. 
 
        Returns 
        ------- 
        averaged_predictions : ndarray of shape (n_samples,) 
            The value of the partial dependence function on each grid point. 
        &quot;&quot;&quot;</span>
        <span class="s1">grid = np.asarray(grid</span><span class="s3">, </span><span class="s1">dtype=DTYPE</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s1">)</span>
        <span class="s1">averaged_predictions = np.zeros(</span>
            <span class="s1">shape=grid.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.float64</span><span class="s3">, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span>
        <span class="s1">)</span>

        <span class="s3">for </span><span class="s1">tree </span><span class="s3">in </span><span class="s1">self.estimators_:</span>
            <span class="s2"># Note: we don't sum in parallel because the GIL isn't released in</span>
            <span class="s2"># the fast method.</span>
            <span class="s1">tree.tree_.compute_partial_dependence(</span>
                <span class="s1">grid</span><span class="s3">, </span><span class="s1">target_features</span><span class="s3">, </span><span class="s1">averaged_predictions</span>
            <span class="s1">)</span>
        <span class="s2"># Average over the forest</span>
        <span class="s1">averaged_predictions /= len(self.estimators_)</span>

        <span class="s3">return </span><span class="s1">averaged_predictions</span>

    <span class="s3">def </span><span class="s1">_more_tags(self):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;multilabel&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>


<span class="s3">class </span><span class="s1">RandomForestClassifier(ForestClassifier):</span>
    <span class="s0">&quot;&quot;&quot; 
    A random forest classifier. 
 
    A random forest is a meta estimator that fits a number of decision tree 
    classifiers on various sub-samples of the dataset and uses averaging to 
    improve the predictive accuracy and control over-fitting. 
    The sub-sample size is controlled with the `max_samples` parameter if 
    `bootstrap=True` (default), otherwise the whole dataset is used to build 
    each tree. 
 
    For a comparison between tree-based ensemble models see the example 
    :ref:`sphx_glr_auto_examples_ensemble_plot_forest_hist_grad_boosting_comparison.py`. 
 
    Read more in the :ref:`User Guide &lt;forest&gt;`. 
 
    Parameters 
    ---------- 
    n_estimators : int, default=100 
        The number of trees in the forest. 
 
        .. versionchanged:: 0.22 
           The default value of ``n_estimators`` changed from 10 to 100 
           in 0.22. 
 
    criterion : {&quot;gini&quot;, &quot;entropy&quot;, &quot;log_loss&quot;}, default=&quot;gini&quot; 
        The function to measure the quality of a split. Supported criteria are 
        &quot;gini&quot; for the Gini impurity and &quot;log_loss&quot; and &quot;entropy&quot; both for the 
        Shannon information gain, see :ref:`tree_mathematical_formulation`. 
        Note: This parameter is tree-specific. 
 
    max_depth : int, default=None 
        The maximum depth of the tree. If None, then nodes are expanded until 
        all leaves are pure or until all leaves contain less than 
        min_samples_split samples. 
 
    min_samples_split : int or float, default=2 
        The minimum number of samples required to split an internal node: 
 
        - If int, then consider `min_samples_split` as the minimum number. 
        - If float, then `min_samples_split` is a fraction and 
          `ceil(min_samples_split * n_samples)` are the minimum 
          number of samples for each split. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_samples_leaf : int or float, default=1 
        The minimum number of samples required to be at a leaf node. 
        A split point at any depth will only be considered if it leaves at 
        least ``min_samples_leaf`` training samples in each of the left and 
        right branches.  This may have the effect of smoothing the model, 
        especially in regression. 
 
        - If int, then consider `min_samples_leaf` as the minimum number. 
        - If float, then `min_samples_leaf` is a fraction and 
          `ceil(min_samples_leaf * n_samples)` are the minimum 
          number of samples for each node. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_weight_fraction_leaf : float, default=0.0 
        The minimum weighted fraction of the sum total of weights (of all 
        the input samples) required to be at a leaf node. Samples have 
        equal weight when sample_weight is not provided. 
 
    max_features : {&quot;sqrt&quot;, &quot;log2&quot;, None}, int or float, default=&quot;sqrt&quot; 
        The number of features to consider when looking for the best split: 
 
        - If int, then consider `max_features` features at each split. 
        - If float, then `max_features` is a fraction and 
          `max(1, int(max_features * n_features_in_))` features are considered at each 
          split. 
        - If &quot;sqrt&quot;, then `max_features=sqrt(n_features)`. 
        - If &quot;log2&quot;, then `max_features=log2(n_features)`. 
        - If None, then `max_features=n_features`. 
 
        .. versionchanged:: 1.1 
            The default of `max_features` changed from `&quot;auto&quot;` to `&quot;sqrt&quot;`. 
 
        Note: the search for a split does not stop until at least one 
        valid partition of the node samples is found, even if it requires to 
        effectively inspect more than ``max_features`` features. 
 
    max_leaf_nodes : int, default=None 
        Grow trees with ``max_leaf_nodes`` in best-first fashion. 
        Best nodes are defined as relative reduction in impurity. 
        If None then unlimited number of leaf nodes. 
 
    min_impurity_decrease : float, default=0.0 
        A node will be split if this split induces a decrease of the impurity 
        greater than or equal to this value. 
 
        The weighted impurity decrease equation is the following:: 
 
            N_t / N * (impurity - N_t_R / N_t * right_impurity 
                                - N_t_L / N_t * left_impurity) 
 
        where ``N`` is the total number of samples, ``N_t`` is the number of 
        samples at the current node, ``N_t_L`` is the number of samples in the 
        left child, and ``N_t_R`` is the number of samples in the right child. 
 
        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum, 
        if ``sample_weight`` is passed. 
 
        .. versionadded:: 0.19 
 
    bootstrap : bool, default=True 
        Whether bootstrap samples are used when building trees. If False, the 
        whole dataset is used to build each tree. 
 
    oob_score : bool or callable, default=False 
        Whether to use out-of-bag samples to estimate the generalization score. 
        By default, :func:`~sklearn.metrics.accuracy_score` is used. 
        Provide a callable with signature `metric(y_true, y_pred)` to use a 
        custom metric. Only available if `bootstrap=True`. 
 
    n_jobs : int, default=None 
        The number of jobs to run in parallel. :meth:`fit`, :meth:`predict`, 
        :meth:`decision_path` and :meth:`apply` are all parallelized over the 
        trees. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` 
        context. ``-1`` means using all processors. See :term:`Glossary 
        &lt;n_jobs&gt;` for more details. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls both the randomness of the bootstrapping of the samples used 
        when building trees (if ``bootstrap=True``) and the sampling of the 
        features to consider when looking for the best split at each node 
        (if ``max_features &lt; n_features``). 
        See :term:`Glossary &lt;random_state&gt;` for details. 
 
    verbose : int, default=0 
        Controls the verbosity when fitting and predicting. 
 
    warm_start : bool, default=False 
        When set to ``True``, reuse the solution of the previous call to fit 
        and add more estimators to the ensemble, otherwise, just fit a whole 
        new forest. See :term:`Glossary &lt;warm_start&gt;` and 
        :ref:`gradient_boosting_warm_start` for details. 
 
    class_weight : {&quot;balanced&quot;, &quot;balanced_subsample&quot;}, dict or list of dicts, \ 
            default=None 
        Weights associated with classes in the form ``{class_label: weight}``. 
        If not given, all classes are supposed to have weight one. For 
        multi-output problems, a list of dicts can be provided in the same 
        order as the columns of y. 
 
        Note that for multioutput (including multilabel) weights should be 
        defined for each class of every column in its own dict. For example, 
        for four-class multilabel classification weights should be 
        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of 
        [{1:1}, {2:5}, {3:1}, {4:1}]. 
 
        The &quot;balanced&quot; mode uses the values of y to automatically adjust 
        weights inversely proportional to class frequencies in the input data 
        as ``n_samples / (n_classes * np.bincount(y))`` 
 
        The &quot;balanced_subsample&quot; mode is the same as &quot;balanced&quot; except that 
        weights are computed based on the bootstrap sample for every tree 
        grown. 
 
        For multi-output, the weights of each column of y will be multiplied. 
 
        Note that these weights will be multiplied with sample_weight (passed 
        through the fit method) if sample_weight is specified. 
 
    ccp_alpha : non-negative float, default=0.0 
        Complexity parameter used for Minimal Cost-Complexity Pruning. The 
        subtree with the largest cost complexity that is smaller than 
        ``ccp_alpha`` will be chosen. By default, no pruning is performed. See 
        :ref:`minimal_cost_complexity_pruning` for details. 
 
        .. versionadded:: 0.22 
 
    max_samples : int or float, default=None 
        If bootstrap is True, the number of samples to draw from X 
        to train each base estimator. 
 
        - If None (default), then draw `X.shape[0]` samples. 
        - If int, then draw `max_samples` samples. 
        - If float, then draw `max(round(n_samples * max_samples), 1)` samples. Thus, 
          `max_samples` should be in the interval `(0.0, 1.0]`. 
 
        .. versionadded:: 0.22 
 
    Attributes 
    ---------- 
    estimator_ : :class:`~sklearn.tree.DecisionTreeClassifier` 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. versionadded:: 1.2 
           `base_estimator_` was renamed to `estimator_`. 
 
    base_estimator_ : DecisionTreeClassifier 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. deprecated:: 1.2 
            `base_estimator_` is deprecated and will be removed in 1.4. 
            Use `estimator_` instead. 
 
    estimators_ : list of DecisionTreeClassifier 
        The collection of fitted sub-estimators. 
 
    classes_ : ndarray of shape (n_classes,) or a list of such arrays 
        The classes labels (single output problem), or a list of arrays of 
        class labels (multi-output problem). 
 
    n_classes_ : int or list 
        The number of classes (single output problem), or a list containing the 
        number of classes for each output (multi-output problem). 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    n_outputs_ : int 
        The number of outputs when ``fit`` is performed. 
 
    feature_importances_ : ndarray of shape (n_features,) 
        The impurity-based feature importances. 
        The higher, the more important the feature. 
        The importance of a feature is computed as the (normalized) 
        total reduction of the criterion brought by that feature.  It is also 
        known as the Gini importance. 
 
        Warning: impurity-based feature importances can be misleading for 
        high cardinality features (many unique values). See 
        :func:`sklearn.inspection.permutation_importance` as an alternative. 
 
    oob_score_ : float 
        Score of the training dataset obtained using an out-of-bag estimate. 
        This attribute exists only when ``oob_score`` is True. 
 
    oob_decision_function_ : ndarray of shape (n_samples, n_classes) or \ 
            (n_samples, n_classes, n_outputs) 
        Decision function computed with out-of-bag estimate on the training 
        set. If n_estimators is small it might be possible that a data point 
        was never left out during the bootstrap. In this case, 
        `oob_decision_function_` might contain NaN. This attribute exists 
        only when ``oob_score`` is True. 
 
    See Also 
    -------- 
    sklearn.tree.DecisionTreeClassifier : A decision tree classifier. 
    sklearn.ensemble.ExtraTreesClassifier : Ensemble of extremely randomized 
        tree classifiers. 
    sklearn.ensemble.HistGradientBoostingClassifier : A Histogram-based Gradient 
        Boosting Classification Tree, very fast for big datasets (n_samples &gt;= 
        10_000). 
 
    Notes 
    ----- 
    The default values for the parameters controlling the size of the trees 
    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and 
    unpruned trees which can potentially be very large on some data sets. To 
    reduce memory consumption, the complexity and size of the trees should be 
    controlled by setting those parameter values. 
 
    The features are always randomly permuted at each split. Therefore, 
    the best found split may vary, even with the same training data, 
    ``max_features=n_features`` and ``bootstrap=False``, if the improvement 
    of the criterion is identical for several splits enumerated during the 
    search of the best split. To obtain a deterministic behaviour during 
    fitting, ``random_state`` has to be fixed. 
 
    References 
    ---------- 
    .. [1] L. Breiman, &quot;Random Forests&quot;, Machine Learning, 45(1), 5-32, 2001. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier 
    &gt;&gt;&gt; from sklearn.datasets import make_classification 
    &gt;&gt;&gt; X, y = make_classification(n_samples=1000, n_features=4, 
    ...                            n_informative=2, n_redundant=0, 
    ...                            random_state=0, shuffle=False) 
    &gt;&gt;&gt; clf = RandomForestClassifier(max_depth=2, random_state=0) 
    &gt;&gt;&gt; clf.fit(X, y) 
    RandomForestClassifier(...) 
    &gt;&gt;&gt; print(clf.predict([[0, 0, 0, 0]])) 
    [1] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s1">**ForestClassifier._parameter_constraints</span><span class="s3">,</span>
        <span class="s1">**DecisionTreeClassifier._parameter_constraints</span><span class="s3">,</span>
        <span class="s4">&quot;class_weight&quot;</span><span class="s1">: [</span>
            <span class="s1">StrOptions({</span><span class="s4">&quot;balanced_subsample&quot;</span><span class="s3">, </span><span class="s4">&quot;balanced&quot;</span><span class="s1">})</span><span class="s3">,</span>
            <span class="s1">dict</span><span class="s3">,</span>
            <span class="s1">list</span><span class="s3">,</span>
            <span class="s3">None,</span>
        <span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">_parameter_constraints.pop(</span><span class="s4">&quot;splitter&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">n_estimators=</span><span class="s5">100</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">criterion=</span><span class="s4">&quot;gini&quot;</span><span class="s3">,</span>
        <span class="s1">max_depth=</span><span class="s3">None,</span>
        <span class="s1">min_samples_split=</span><span class="s5">2</span><span class="s3">,</span>
        <span class="s1">min_samples_leaf=</span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">min_weight_fraction_leaf=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_features=</span><span class="s4">&quot;sqrt&quot;</span><span class="s3">,</span>
        <span class="s1">max_leaf_nodes=</span><span class="s3">None,</span>
        <span class="s1">min_impurity_decrease=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">bootstrap=</span><span class="s3">True,</span>
        <span class="s1">oob_score=</span><span class="s3">False,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">warm_start=</span><span class="s3">False,</span>
        <span class="s1">class_weight=</span><span class="s3">None,</span>
        <span class="s1">ccp_alpha=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_samples=</span><span class="s3">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">estimator=DecisionTreeClassifier()</span><span class="s3">,</span>
            <span class="s1">n_estimators=n_estimators</span><span class="s3">,</span>
            <span class="s1">estimator_params=(</span>
                <span class="s4">&quot;criterion&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_depth&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_split&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_weight_fraction_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_features&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_leaf_nodes&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_impurity_decrease&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;random_state&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;ccp_alpha&quot;</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">bootstrap=bootstrap</span><span class="s3">,</span>
            <span class="s1">oob_score=oob_score</span><span class="s3">,</span>
            <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
            <span class="s1">verbose=verbose</span><span class="s3">,</span>
            <span class="s1">warm_start=warm_start</span><span class="s3">,</span>
            <span class="s1">class_weight=class_weight</span><span class="s3">,</span>
            <span class="s1">max_samples=max_samples</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">self.criterion = criterion</span>
        <span class="s1">self.max_depth = max_depth</span>
        <span class="s1">self.min_samples_split = min_samples_split</span>
        <span class="s1">self.min_samples_leaf = min_samples_leaf</span>
        <span class="s1">self.min_weight_fraction_leaf = min_weight_fraction_leaf</span>
        <span class="s1">self.max_features = max_features</span>
        <span class="s1">self.max_leaf_nodes = max_leaf_nodes</span>
        <span class="s1">self.min_impurity_decrease = min_impurity_decrease</span>
        <span class="s1">self.ccp_alpha = ccp_alpha</span>


<span class="s3">class </span><span class="s1">RandomForestRegressor(ForestRegressor):</span>
    <span class="s0">&quot;&quot;&quot; 
    A random forest regressor. 
 
    A random forest is a meta estimator that fits a number of classifying 
    decision trees on various sub-samples of the dataset and uses averaging 
    to improve the predictive accuracy and control over-fitting. 
    The sub-sample size is controlled with the `max_samples` parameter if 
    `bootstrap=True` (default), otherwise the whole dataset is used to build 
    each tree. 
 
    For a comparison between tree-based ensemble models see the example 
    :ref:`sphx_glr_auto_examples_ensemble_plot_forest_hist_grad_boosting_comparison.py`. 
 
    Read more in the :ref:`User Guide &lt;forest&gt;`. 
 
    Parameters 
    ---------- 
    n_estimators : int, default=100 
        The number of trees in the forest. 
 
        .. versionchanged:: 0.22 
           The default value of ``n_estimators`` changed from 10 to 100 
           in 0.22. 
 
    criterion : {&quot;squared_error&quot;, &quot;absolute_error&quot;, &quot;friedman_mse&quot;, &quot;poisson&quot;}, \ 
            default=&quot;squared_error&quot; 
        The function to measure the quality of a split. Supported criteria 
        are &quot;squared_error&quot; for the mean squared error, which is equal to 
        variance reduction as feature selection criterion and minimizes the L2 
        loss using the mean of each terminal node, &quot;friedman_mse&quot;, which uses 
        mean squared error with Friedman's improvement score for potential 
        splits, &quot;absolute_error&quot; for the mean absolute error, which minimizes 
        the L1 loss using the median of each terminal node, and &quot;poisson&quot; which 
        uses reduction in Poisson deviance to find splits. 
        Training using &quot;absolute_error&quot; is significantly slower 
        than when using &quot;squared_error&quot;. 
 
        .. versionadded:: 0.18 
           Mean Absolute Error (MAE) criterion. 
 
        .. versionadded:: 1.0 
           Poisson criterion. 
 
    max_depth : int, default=None 
        The maximum depth of the tree. If None, then nodes are expanded until 
        all leaves are pure or until all leaves contain less than 
        min_samples_split samples. 
 
    min_samples_split : int or float, default=2 
        The minimum number of samples required to split an internal node: 
 
        - If int, then consider `min_samples_split` as the minimum number. 
        - If float, then `min_samples_split` is a fraction and 
          `ceil(min_samples_split * n_samples)` are the minimum 
          number of samples for each split. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_samples_leaf : int or float, default=1 
        The minimum number of samples required to be at a leaf node. 
        A split point at any depth will only be considered if it leaves at 
        least ``min_samples_leaf`` training samples in each of the left and 
        right branches.  This may have the effect of smoothing the model, 
        especially in regression. 
 
        - If int, then consider `min_samples_leaf` as the minimum number. 
        - If float, then `min_samples_leaf` is a fraction and 
          `ceil(min_samples_leaf * n_samples)` are the minimum 
          number of samples for each node. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_weight_fraction_leaf : float, default=0.0 
        The minimum weighted fraction of the sum total of weights (of all 
        the input samples) required to be at a leaf node. Samples have 
        equal weight when sample_weight is not provided. 
 
    max_features : {&quot;sqrt&quot;, &quot;log2&quot;, None}, int or float, default=1.0 
        The number of features to consider when looking for the best split: 
 
        - If int, then consider `max_features` features at each split. 
        - If float, then `max_features` is a fraction and 
          `max(1, int(max_features * n_features_in_))` features are considered at each 
          split. 
        - If &quot;sqrt&quot;, then `max_features=sqrt(n_features)`. 
        - If &quot;log2&quot;, then `max_features=log2(n_features)`. 
        - If None or 1.0, then `max_features=n_features`. 
 
        .. note:: 
            The default of 1.0 is equivalent to bagged trees and more 
            randomness can be achieved by setting smaller values, e.g. 0.3. 
 
        .. versionchanged:: 1.1 
            The default of `max_features` changed from `&quot;auto&quot;` to 1.0. 
 
        Note: the search for a split does not stop until at least one 
        valid partition of the node samples is found, even if it requires to 
        effectively inspect more than ``max_features`` features. 
 
    max_leaf_nodes : int, default=None 
        Grow trees with ``max_leaf_nodes`` in best-first fashion. 
        Best nodes are defined as relative reduction in impurity. 
        If None then unlimited number of leaf nodes. 
 
    min_impurity_decrease : float, default=0.0 
        A node will be split if this split induces a decrease of the impurity 
        greater than or equal to this value. 
 
        The weighted impurity decrease equation is the following:: 
 
            N_t / N * (impurity - N_t_R / N_t * right_impurity 
                                - N_t_L / N_t * left_impurity) 
 
        where ``N`` is the total number of samples, ``N_t`` is the number of 
        samples at the current node, ``N_t_L`` is the number of samples in the 
        left child, and ``N_t_R`` is the number of samples in the right child. 
 
        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum, 
        if ``sample_weight`` is passed. 
 
        .. versionadded:: 0.19 
 
    bootstrap : bool, default=True 
        Whether bootstrap samples are used when building trees. If False, the 
        whole dataset is used to build each tree. 
 
    oob_score : bool or callable, default=False 
        Whether to use out-of-bag samples to estimate the generalization score. 
        By default, :func:`~sklearn.metrics.r2_score` is used. 
        Provide a callable with signature `metric(y_true, y_pred)` to use a 
        custom metric. Only available if `bootstrap=True`. 
 
    n_jobs : int, default=None 
        The number of jobs to run in parallel. :meth:`fit`, :meth:`predict`, 
        :meth:`decision_path` and :meth:`apply` are all parallelized over the 
        trees. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` 
        context. ``-1`` means using all processors. See :term:`Glossary 
        &lt;n_jobs&gt;` for more details. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls both the randomness of the bootstrapping of the samples used 
        when building trees (if ``bootstrap=True``) and the sampling of the 
        features to consider when looking for the best split at each node 
        (if ``max_features &lt; n_features``). 
        See :term:`Glossary &lt;random_state&gt;` for details. 
 
    verbose : int, default=0 
        Controls the verbosity when fitting and predicting. 
 
    warm_start : bool, default=False 
        When set to ``True``, reuse the solution of the previous call to fit 
        and add more estimators to the ensemble, otherwise, just fit a whole 
        new forest. See :term:`Glossary &lt;warm_start&gt;` and 
        :ref:`gradient_boosting_warm_start` for details. 
 
    ccp_alpha : non-negative float, default=0.0 
        Complexity parameter used for Minimal Cost-Complexity Pruning. The 
        subtree with the largest cost complexity that is smaller than 
        ``ccp_alpha`` will be chosen. By default, no pruning is performed. See 
        :ref:`minimal_cost_complexity_pruning` for details. 
 
        .. versionadded:: 0.22 
 
    max_samples : int or float, default=None 
        If bootstrap is True, the number of samples to draw from X 
        to train each base estimator. 
 
        - If None (default), then draw `X.shape[0]` samples. 
        - If int, then draw `max_samples` samples. 
        - If float, then draw `max(round(n_samples * max_samples), 1)` samples. Thus, 
          `max_samples` should be in the interval `(0.0, 1.0]`. 
 
        .. versionadded:: 0.22 
 
    Attributes 
    ---------- 
    estimator_ : :class:`~sklearn.tree.DecisionTreeRegressor` 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. versionadded:: 1.2 
           `base_estimator_` was renamed to `estimator_`. 
 
    base_estimator_ : DecisionTreeRegressor 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. deprecated:: 1.2 
            `base_estimator_` is deprecated and will be removed in 1.4. 
            Use `estimator_` instead. 
 
    estimators_ : list of DecisionTreeRegressor 
        The collection of fitted sub-estimators. 
 
    feature_importances_ : ndarray of shape (n_features,) 
        The impurity-based feature importances. 
        The higher, the more important the feature. 
        The importance of a feature is computed as the (normalized) 
        total reduction of the criterion brought by that feature.  It is also 
        known as the Gini importance. 
 
        Warning: impurity-based feature importances can be misleading for 
        high cardinality features (many unique values). See 
        :func:`sklearn.inspection.permutation_importance` as an alternative. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    n_outputs_ : int 
        The number of outputs when ``fit`` is performed. 
 
    oob_score_ : float 
        Score of the training dataset obtained using an out-of-bag estimate. 
        This attribute exists only when ``oob_score`` is True. 
 
    oob_prediction_ : ndarray of shape (n_samples,) or (n_samples, n_outputs) 
        Prediction computed with out-of-bag estimate on the training set. 
        This attribute exists only when ``oob_score`` is True. 
 
    See Also 
    -------- 
    sklearn.tree.DecisionTreeRegressor : A decision tree regressor. 
    sklearn.ensemble.ExtraTreesRegressor : Ensemble of extremely randomized 
        tree regressors. 
    sklearn.ensemble.HistGradientBoostingRegressor : A Histogram-based Gradient 
        Boosting Regression Tree, very fast for big datasets (n_samples &gt;= 
        10_000). 
 
    Notes 
    ----- 
    The default values for the parameters controlling the size of the trees 
    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and 
    unpruned trees which can potentially be very large on some data sets. To 
    reduce memory consumption, the complexity and size of the trees should be 
    controlled by setting those parameter values. 
 
    The features are always randomly permuted at each split. Therefore, 
    the best found split may vary, even with the same training data, 
    ``max_features=n_features`` and ``bootstrap=False``, if the improvement 
    of the criterion is identical for several splits enumerated during the 
    search of the best split. To obtain a deterministic behaviour during 
    fitting, ``random_state`` has to be fixed. 
 
    The default value ``max_features=1.0`` uses ``n_features`` 
    rather than ``n_features / 3``. The latter was originally suggested in 
    [1], whereas the former was more recently justified empirically in [2]. 
 
    References 
    ---------- 
    .. [1] L. Breiman, &quot;Random Forests&quot;, Machine Learning, 45(1), 5-32, 2001. 
 
    .. [2] P. Geurts, D. Ernst., and L. Wehenkel, &quot;Extremely randomized 
           trees&quot;, Machine Learning, 63(1), 3-42, 2006. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.ensemble import RandomForestRegressor 
    &gt;&gt;&gt; from sklearn.datasets import make_regression 
    &gt;&gt;&gt; X, y = make_regression(n_features=4, n_informative=2, 
    ...                        random_state=0, shuffle=False) 
    &gt;&gt;&gt; regr = RandomForestRegressor(max_depth=2, random_state=0) 
    &gt;&gt;&gt; regr.fit(X, y) 
    RandomForestRegressor(...) 
    &gt;&gt;&gt; print(regr.predict([[0, 0, 0, 0]])) 
    [-8.32987858] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s1">**ForestRegressor._parameter_constraints</span><span class="s3">,</span>
        <span class="s1">**DecisionTreeRegressor._parameter_constraints</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">_parameter_constraints.pop(</span><span class="s4">&quot;splitter&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">n_estimators=</span><span class="s5">100</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">criterion=</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">,</span>
        <span class="s1">max_depth=</span><span class="s3">None,</span>
        <span class="s1">min_samples_split=</span><span class="s5">2</span><span class="s3">,</span>
        <span class="s1">min_samples_leaf=</span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">min_weight_fraction_leaf=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_features=</span><span class="s5">1.0</span><span class="s3">,</span>
        <span class="s1">max_leaf_nodes=</span><span class="s3">None,</span>
        <span class="s1">min_impurity_decrease=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">bootstrap=</span><span class="s3">True,</span>
        <span class="s1">oob_score=</span><span class="s3">False,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">warm_start=</span><span class="s3">False,</span>
        <span class="s1">ccp_alpha=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_samples=</span><span class="s3">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">estimator=DecisionTreeRegressor()</span><span class="s3">,</span>
            <span class="s1">n_estimators=n_estimators</span><span class="s3">,</span>
            <span class="s1">estimator_params=(</span>
                <span class="s4">&quot;criterion&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_depth&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_split&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_weight_fraction_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_features&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_leaf_nodes&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_impurity_decrease&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;random_state&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;ccp_alpha&quot;</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">bootstrap=bootstrap</span><span class="s3">,</span>
            <span class="s1">oob_score=oob_score</span><span class="s3">,</span>
            <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
            <span class="s1">verbose=verbose</span><span class="s3">,</span>
            <span class="s1">warm_start=warm_start</span><span class="s3">,</span>
            <span class="s1">max_samples=max_samples</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">self.criterion = criterion</span>
        <span class="s1">self.max_depth = max_depth</span>
        <span class="s1">self.min_samples_split = min_samples_split</span>
        <span class="s1">self.min_samples_leaf = min_samples_leaf</span>
        <span class="s1">self.min_weight_fraction_leaf = min_weight_fraction_leaf</span>
        <span class="s1">self.max_features = max_features</span>
        <span class="s1">self.max_leaf_nodes = max_leaf_nodes</span>
        <span class="s1">self.min_impurity_decrease = min_impurity_decrease</span>
        <span class="s1">self.ccp_alpha = ccp_alpha</span>


<span class="s3">class </span><span class="s1">ExtraTreesClassifier(ForestClassifier):</span>
    <span class="s0">&quot;&quot;&quot; 
    An extra-trees classifier. 
 
    This class implements a meta estimator that fits a number of 
    randomized decision trees (a.k.a. extra-trees) on various sub-samples 
    of the dataset and uses averaging to improve the predictive accuracy 
    and control over-fitting. 
 
    Read more in the :ref:`User Guide &lt;forest&gt;`. 
 
    Parameters 
    ---------- 
    n_estimators : int, default=100 
        The number of trees in the forest. 
 
        .. versionchanged:: 0.22 
           The default value of ``n_estimators`` changed from 10 to 100 
           in 0.22. 
 
    criterion : {&quot;gini&quot;, &quot;entropy&quot;, &quot;log_loss&quot;}, default=&quot;gini&quot; 
        The function to measure the quality of a split. Supported criteria are 
        &quot;gini&quot; for the Gini impurity and &quot;log_loss&quot; and &quot;entropy&quot; both for the 
        Shannon information gain, see :ref:`tree_mathematical_formulation`. 
        Note: This parameter is tree-specific. 
 
    max_depth : int, default=None 
        The maximum depth of the tree. If None, then nodes are expanded until 
        all leaves are pure or until all leaves contain less than 
        min_samples_split samples. 
 
    min_samples_split : int or float, default=2 
        The minimum number of samples required to split an internal node: 
 
        - If int, then consider `min_samples_split` as the minimum number. 
        - If float, then `min_samples_split` is a fraction and 
          `ceil(min_samples_split * n_samples)` are the minimum 
          number of samples for each split. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_samples_leaf : int or float, default=1 
        The minimum number of samples required to be at a leaf node. 
        A split point at any depth will only be considered if it leaves at 
        least ``min_samples_leaf`` training samples in each of the left and 
        right branches.  This may have the effect of smoothing the model, 
        especially in regression. 
 
        - If int, then consider `min_samples_leaf` as the minimum number. 
        - If float, then `min_samples_leaf` is a fraction and 
          `ceil(min_samples_leaf * n_samples)` are the minimum 
          number of samples for each node. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_weight_fraction_leaf : float, default=0.0 
        The minimum weighted fraction of the sum total of weights (of all 
        the input samples) required to be at a leaf node. Samples have 
        equal weight when sample_weight is not provided. 
 
    max_features : {&quot;sqrt&quot;, &quot;log2&quot;, None}, int or float, default=&quot;sqrt&quot; 
        The number of features to consider when looking for the best split: 
 
        - If int, then consider `max_features` features at each split. 
        - If float, then `max_features` is a fraction and 
          `max(1, int(max_features * n_features_in_))` features are considered at each 
          split. 
        - If &quot;sqrt&quot;, then `max_features=sqrt(n_features)`. 
        - If &quot;log2&quot;, then `max_features=log2(n_features)`. 
        - If None, then `max_features=n_features`. 
 
        .. versionchanged:: 1.1 
            The default of `max_features` changed from `&quot;auto&quot;` to `&quot;sqrt&quot;`. 
 
        Note: the search for a split does not stop until at least one 
        valid partition of the node samples is found, even if it requires to 
        effectively inspect more than ``max_features`` features. 
 
    max_leaf_nodes : int, default=None 
        Grow trees with ``max_leaf_nodes`` in best-first fashion. 
        Best nodes are defined as relative reduction in impurity. 
        If None then unlimited number of leaf nodes. 
 
    min_impurity_decrease : float, default=0.0 
        A node will be split if this split induces a decrease of the impurity 
        greater than or equal to this value. 
 
        The weighted impurity decrease equation is the following:: 
 
            N_t / N * (impurity - N_t_R / N_t * right_impurity 
                                - N_t_L / N_t * left_impurity) 
 
        where ``N`` is the total number of samples, ``N_t`` is the number of 
        samples at the current node, ``N_t_L`` is the number of samples in the 
        left child, and ``N_t_R`` is the number of samples in the right child. 
 
        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum, 
        if ``sample_weight`` is passed. 
 
        .. versionadded:: 0.19 
 
    bootstrap : bool, default=False 
        Whether bootstrap samples are used when building trees. If False, the 
        whole dataset is used to build each tree. 
 
    oob_score : bool or callable, default=False 
        Whether to use out-of-bag samples to estimate the generalization score. 
        By default, :func:`~sklearn.metrics.accuracy_score` is used. 
        Provide a callable with signature `metric(y_true, y_pred)` to use a 
        custom metric. Only available if `bootstrap=True`. 
 
    n_jobs : int, default=None 
        The number of jobs to run in parallel. :meth:`fit`, :meth:`predict`, 
        :meth:`decision_path` and :meth:`apply` are all parallelized over the 
        trees. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` 
        context. ``-1`` means using all processors. See :term:`Glossary 
        &lt;n_jobs&gt;` for more details. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls 3 sources of randomness: 
 
        - the bootstrapping of the samples used when building trees 
          (if ``bootstrap=True``) 
        - the sampling of the features to consider when looking for the best 
          split at each node (if ``max_features &lt; n_features``) 
        - the draw of the splits for each of the `max_features` 
 
        See :term:`Glossary &lt;random_state&gt;` for details. 
 
    verbose : int, default=0 
        Controls the verbosity when fitting and predicting. 
 
    warm_start : bool, default=False 
        When set to ``True``, reuse the solution of the previous call to fit 
        and add more estimators to the ensemble, otherwise, just fit a whole 
        new forest. See :term:`Glossary &lt;warm_start&gt;` and 
        :ref:`gradient_boosting_warm_start` for details. 
 
    class_weight : {&quot;balanced&quot;, &quot;balanced_subsample&quot;}, dict or list of dicts, \ 
            default=None 
        Weights associated with classes in the form ``{class_label: weight}``. 
        If not given, all classes are supposed to have weight one. For 
        multi-output problems, a list of dicts can be provided in the same 
        order as the columns of y. 
 
        Note that for multioutput (including multilabel) weights should be 
        defined for each class of every column in its own dict. For example, 
        for four-class multilabel classification weights should be 
        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of 
        [{1:1}, {2:5}, {3:1}, {4:1}]. 
 
        The &quot;balanced&quot; mode uses the values of y to automatically adjust 
        weights inversely proportional to class frequencies in the input data 
        as ``n_samples / (n_classes * np.bincount(y))`` 
 
        The &quot;balanced_subsample&quot; mode is the same as &quot;balanced&quot; except that 
        weights are computed based on the bootstrap sample for every tree 
        grown. 
 
        For multi-output, the weights of each column of y will be multiplied. 
 
        Note that these weights will be multiplied with sample_weight (passed 
        through the fit method) if sample_weight is specified. 
 
    ccp_alpha : non-negative float, default=0.0 
        Complexity parameter used for Minimal Cost-Complexity Pruning. The 
        subtree with the largest cost complexity that is smaller than 
        ``ccp_alpha`` will be chosen. By default, no pruning is performed. See 
        :ref:`minimal_cost_complexity_pruning` for details. 
 
        .. versionadded:: 0.22 
 
    max_samples : int or float, default=None 
        If bootstrap is True, the number of samples to draw from X 
        to train each base estimator. 
 
        - If None (default), then draw `X.shape[0]` samples. 
        - If int, then draw `max_samples` samples. 
        - If float, then draw `max_samples * X.shape[0]` samples. Thus, 
          `max_samples` should be in the interval `(0.0, 1.0]`. 
 
        .. versionadded:: 0.22 
 
    Attributes 
    ---------- 
    estimator_ : :class:`~sklearn.tree.ExtraTreeClassifier` 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. versionadded:: 1.2 
           `base_estimator_` was renamed to `estimator_`. 
 
    base_estimator_ : ExtraTreesClassifier 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. deprecated:: 1.2 
            `base_estimator_` is deprecated and will be removed in 1.4. 
            Use `estimator_` instead. 
 
    estimators_ : list of DecisionTreeClassifier 
        The collection of fitted sub-estimators. 
 
    classes_ : ndarray of shape (n_classes,) or a list of such arrays 
        The classes labels (single output problem), or a list of arrays of 
        class labels (multi-output problem). 
 
    n_classes_ : int or list 
        The number of classes (single output problem), or a list containing the 
        number of classes for each output (multi-output problem). 
 
    feature_importances_ : ndarray of shape (n_features,) 
        The impurity-based feature importances. 
        The higher, the more important the feature. 
        The importance of a feature is computed as the (normalized) 
        total reduction of the criterion brought by that feature.  It is also 
        known as the Gini importance. 
 
        Warning: impurity-based feature importances can be misleading for 
        high cardinality features (many unique values). See 
        :func:`sklearn.inspection.permutation_importance` as an alternative. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    n_outputs_ : int 
        The number of outputs when ``fit`` is performed. 
 
    oob_score_ : float 
        Score of the training dataset obtained using an out-of-bag estimate. 
        This attribute exists only when ``oob_score`` is True. 
 
    oob_decision_function_ : ndarray of shape (n_samples, n_classes) or \ 
            (n_samples, n_classes, n_outputs) 
        Decision function computed with out-of-bag estimate on the training 
        set. If n_estimators is small it might be possible that a data point 
        was never left out during the bootstrap. In this case, 
        `oob_decision_function_` might contain NaN. This attribute exists 
        only when ``oob_score`` is True. 
 
    See Also 
    -------- 
    ExtraTreesRegressor : An extra-trees regressor with random splits. 
    RandomForestClassifier : A random forest classifier with optimal splits. 
    RandomForestRegressor : Ensemble regressor using trees with optimal splits. 
 
    Notes 
    ----- 
    The default values for the parameters controlling the size of the trees 
    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and 
    unpruned trees which can potentially be very large on some data sets. To 
    reduce memory consumption, the complexity and size of the trees should be 
    controlled by setting those parameter values. 
 
    References 
    ---------- 
    .. [1] P. Geurts, D. Ernst., and L. Wehenkel, &quot;Extremely randomized 
           trees&quot;, Machine Learning, 63(1), 3-42, 2006. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.ensemble import ExtraTreesClassifier 
    &gt;&gt;&gt; from sklearn.datasets import make_classification 
    &gt;&gt;&gt; X, y = make_classification(n_features=4, random_state=0) 
    &gt;&gt;&gt; clf = ExtraTreesClassifier(n_estimators=100, random_state=0) 
    &gt;&gt;&gt; clf.fit(X, y) 
    ExtraTreesClassifier(random_state=0) 
    &gt;&gt;&gt; clf.predict([[0, 0, 0, 0]]) 
    array([1]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s1">**ForestClassifier._parameter_constraints</span><span class="s3">,</span>
        <span class="s1">**DecisionTreeClassifier._parameter_constraints</span><span class="s3">,</span>
        <span class="s4">&quot;class_weight&quot;</span><span class="s1">: [</span>
            <span class="s1">StrOptions({</span><span class="s4">&quot;balanced_subsample&quot;</span><span class="s3">, </span><span class="s4">&quot;balanced&quot;</span><span class="s1">})</span><span class="s3">,</span>
            <span class="s1">dict</span><span class="s3">,</span>
            <span class="s1">list</span><span class="s3">,</span>
            <span class="s3">None,</span>
        <span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">_parameter_constraints.pop(</span><span class="s4">&quot;splitter&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">n_estimators=</span><span class="s5">100</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">criterion=</span><span class="s4">&quot;gini&quot;</span><span class="s3">,</span>
        <span class="s1">max_depth=</span><span class="s3">None,</span>
        <span class="s1">min_samples_split=</span><span class="s5">2</span><span class="s3">,</span>
        <span class="s1">min_samples_leaf=</span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">min_weight_fraction_leaf=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_features=</span><span class="s4">&quot;sqrt&quot;</span><span class="s3">,</span>
        <span class="s1">max_leaf_nodes=</span><span class="s3">None,</span>
        <span class="s1">min_impurity_decrease=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">bootstrap=</span><span class="s3">False,</span>
        <span class="s1">oob_score=</span><span class="s3">False,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">warm_start=</span><span class="s3">False,</span>
        <span class="s1">class_weight=</span><span class="s3">None,</span>
        <span class="s1">ccp_alpha=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_samples=</span><span class="s3">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">estimator=ExtraTreeClassifier()</span><span class="s3">,</span>
            <span class="s1">n_estimators=n_estimators</span><span class="s3">,</span>
            <span class="s1">estimator_params=(</span>
                <span class="s4">&quot;criterion&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_depth&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_split&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_weight_fraction_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_features&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_leaf_nodes&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_impurity_decrease&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;random_state&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;ccp_alpha&quot;</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">bootstrap=bootstrap</span><span class="s3">,</span>
            <span class="s1">oob_score=oob_score</span><span class="s3">,</span>
            <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
            <span class="s1">verbose=verbose</span><span class="s3">,</span>
            <span class="s1">warm_start=warm_start</span><span class="s3">,</span>
            <span class="s1">class_weight=class_weight</span><span class="s3">,</span>
            <span class="s1">max_samples=max_samples</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">self.criterion = criterion</span>
        <span class="s1">self.max_depth = max_depth</span>
        <span class="s1">self.min_samples_split = min_samples_split</span>
        <span class="s1">self.min_samples_leaf = min_samples_leaf</span>
        <span class="s1">self.min_weight_fraction_leaf = min_weight_fraction_leaf</span>
        <span class="s1">self.max_features = max_features</span>
        <span class="s1">self.max_leaf_nodes = max_leaf_nodes</span>
        <span class="s1">self.min_impurity_decrease = min_impurity_decrease</span>
        <span class="s1">self.ccp_alpha = ccp_alpha</span>


<span class="s3">class </span><span class="s1">ExtraTreesRegressor(ForestRegressor):</span>
    <span class="s0">&quot;&quot;&quot; 
    An extra-trees regressor. 
 
    This class implements a meta estimator that fits a number of 
    randomized decision trees (a.k.a. extra-trees) on various sub-samples 
    of the dataset and uses averaging to improve the predictive accuracy 
    and control over-fitting. 
 
    Read more in the :ref:`User Guide &lt;forest&gt;`. 
 
    Parameters 
    ---------- 
    n_estimators : int, default=100 
        The number of trees in the forest. 
 
        .. versionchanged:: 0.22 
           The default value of ``n_estimators`` changed from 10 to 100 
           in 0.22. 
 
    criterion : {&quot;squared_error&quot;, &quot;absolute_error&quot;, &quot;friedman_mse&quot;, &quot;poisson&quot;}, \ 
            default=&quot;squared_error&quot; 
        The function to measure the quality of a split. Supported criteria 
        are &quot;squared_error&quot; for the mean squared error, which is equal to 
        variance reduction as feature selection criterion and minimizes the L2 
        loss using the mean of each terminal node, &quot;friedman_mse&quot;, which uses 
        mean squared error with Friedman's improvement score for potential 
        splits, &quot;absolute_error&quot; for the mean absolute error, which minimizes 
        the L1 loss using the median of each terminal node, and &quot;poisson&quot; which 
        uses reduction in Poisson deviance to find splits. 
        Training using &quot;absolute_error&quot; is significantly slower 
        than when using &quot;squared_error&quot;. 
 
        .. versionadded:: 0.18 
           Mean Absolute Error (MAE) criterion. 
 
    max_depth : int, default=None 
        The maximum depth of the tree. If None, then nodes are expanded until 
        all leaves are pure or until all leaves contain less than 
        min_samples_split samples. 
 
    min_samples_split : int or float, default=2 
        The minimum number of samples required to split an internal node: 
 
        - If int, then consider `min_samples_split` as the minimum number. 
        - If float, then `min_samples_split` is a fraction and 
          `ceil(min_samples_split * n_samples)` are the minimum 
          number of samples for each split. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_samples_leaf : int or float, default=1 
        The minimum number of samples required to be at a leaf node. 
        A split point at any depth will only be considered if it leaves at 
        least ``min_samples_leaf`` training samples in each of the left and 
        right branches.  This may have the effect of smoothing the model, 
        especially in regression. 
 
        - If int, then consider `min_samples_leaf` as the minimum number. 
        - If float, then `min_samples_leaf` is a fraction and 
          `ceil(min_samples_leaf * n_samples)` are the minimum 
          number of samples for each node. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_weight_fraction_leaf : float, default=0.0 
        The minimum weighted fraction of the sum total of weights (of all 
        the input samples) required to be at a leaf node. Samples have 
        equal weight when sample_weight is not provided. 
 
    max_features : {&quot;sqrt&quot;, &quot;log2&quot;, None}, int or float, default=1.0 
        The number of features to consider when looking for the best split: 
 
        - If int, then consider `max_features` features at each split. 
        - If float, then `max_features` is a fraction and 
          `max(1, int(max_features * n_features_in_))` features are considered at each 
          split. 
        - If &quot;sqrt&quot;, then `max_features=sqrt(n_features)`. 
        - If &quot;log2&quot;, then `max_features=log2(n_features)`. 
        - If None or 1.0, then `max_features=n_features`. 
 
        .. note:: 
            The default of 1.0 is equivalent to bagged trees and more 
            randomness can be achieved by setting smaller values, e.g. 0.3. 
 
        .. versionchanged:: 1.1 
            The default of `max_features` changed from `&quot;auto&quot;` to 1.0. 
 
        Note: the search for a split does not stop until at least one 
        valid partition of the node samples is found, even if it requires to 
        effectively inspect more than ``max_features`` features. 
 
    max_leaf_nodes : int, default=None 
        Grow trees with ``max_leaf_nodes`` in best-first fashion. 
        Best nodes are defined as relative reduction in impurity. 
        If None then unlimited number of leaf nodes. 
 
    min_impurity_decrease : float, default=0.0 
        A node will be split if this split induces a decrease of the impurity 
        greater than or equal to this value. 
 
        The weighted impurity decrease equation is the following:: 
 
            N_t / N * (impurity - N_t_R / N_t * right_impurity 
                                - N_t_L / N_t * left_impurity) 
 
        where ``N`` is the total number of samples, ``N_t`` is the number of 
        samples at the current node, ``N_t_L`` is the number of samples in the 
        left child, and ``N_t_R`` is the number of samples in the right child. 
 
        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum, 
        if ``sample_weight`` is passed. 
 
        .. versionadded:: 0.19 
 
    bootstrap : bool, default=False 
        Whether bootstrap samples are used when building trees. If False, the 
        whole dataset is used to build each tree. 
 
    oob_score : bool or callable, default=False 
        Whether to use out-of-bag samples to estimate the generalization score. 
        By default, :func:`~sklearn.metrics.r2_score` is used. 
        Provide a callable with signature `metric(y_true, y_pred)` to use a 
        custom metric. Only available if `bootstrap=True`. 
 
    n_jobs : int, default=None 
        The number of jobs to run in parallel. :meth:`fit`, :meth:`predict`, 
        :meth:`decision_path` and :meth:`apply` are all parallelized over the 
        trees. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` 
        context. ``-1`` means using all processors. See :term:`Glossary 
        &lt;n_jobs&gt;` for more details. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls 3 sources of randomness: 
 
        - the bootstrapping of the samples used when building trees 
          (if ``bootstrap=True``) 
        - the sampling of the features to consider when looking for the best 
          split at each node (if ``max_features &lt; n_features``) 
        - the draw of the splits for each of the `max_features` 
 
        See :term:`Glossary &lt;random_state&gt;` for details. 
 
    verbose : int, default=0 
        Controls the verbosity when fitting and predicting. 
 
    warm_start : bool, default=False 
        When set to ``True``, reuse the solution of the previous call to fit 
        and add more estimators to the ensemble, otherwise, just fit a whole 
        new forest. See :term:`Glossary &lt;warm_start&gt;` and 
        :ref:`gradient_boosting_warm_start` for details. 
 
    ccp_alpha : non-negative float, default=0.0 
        Complexity parameter used for Minimal Cost-Complexity Pruning. The 
        subtree with the largest cost complexity that is smaller than 
        ``ccp_alpha`` will be chosen. By default, no pruning is performed. See 
        :ref:`minimal_cost_complexity_pruning` for details. 
 
        .. versionadded:: 0.22 
 
    max_samples : int or float, default=None 
        If bootstrap is True, the number of samples to draw from X 
        to train each base estimator. 
 
        - If None (default), then draw `X.shape[0]` samples. 
        - If int, then draw `max_samples` samples. 
        - If float, then draw `max_samples * X.shape[0]` samples. Thus, 
          `max_samples` should be in the interval `(0.0, 1.0]`. 
 
        .. versionadded:: 0.22 
 
    Attributes 
    ---------- 
    estimator_ : :class:`~sklearn.tree.ExtraTreeRegressor` 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. versionadded:: 1.2 
           `base_estimator_` was renamed to `estimator_`. 
 
    base_estimator_ : ExtraTreeRegressor 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. deprecated:: 1.2 
            `base_estimator_` is deprecated and will be removed in 1.4. 
            Use `estimator_` instead. 
 
    estimators_ : list of DecisionTreeRegressor 
        The collection of fitted sub-estimators. 
 
    feature_importances_ : ndarray of shape (n_features,) 
        The impurity-based feature importances. 
        The higher, the more important the feature. 
        The importance of a feature is computed as the (normalized) 
        total reduction of the criterion brought by that feature.  It is also 
        known as the Gini importance. 
 
        Warning: impurity-based feature importances can be misleading for 
        high cardinality features (many unique values). See 
        :func:`sklearn.inspection.permutation_importance` as an alternative. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    n_outputs_ : int 
        The number of outputs. 
 
    oob_score_ : float 
        Score of the training dataset obtained using an out-of-bag estimate. 
        This attribute exists only when ``oob_score`` is True. 
 
    oob_prediction_ : ndarray of shape (n_samples,) or (n_samples, n_outputs) 
        Prediction computed with out-of-bag estimate on the training set. 
        This attribute exists only when ``oob_score`` is True. 
 
    See Also 
    -------- 
    ExtraTreesClassifier : An extra-trees classifier with random splits. 
    RandomForestClassifier : A random forest classifier with optimal splits. 
    RandomForestRegressor : Ensemble regressor using trees with optimal splits. 
 
    Notes 
    ----- 
    The default values for the parameters controlling the size of the trees 
    (e.g. ``max_depth``, ``min_samples_leaf``, etc.) lead to fully grown and 
    unpruned trees which can potentially be very large on some data sets. To 
    reduce memory consumption, the complexity and size of the trees should be 
    controlled by setting those parameter values. 
 
    References 
    ---------- 
    .. [1] P. Geurts, D. Ernst., and L. Wehenkel, &quot;Extremely randomized trees&quot;, 
           Machine Learning, 63(1), 3-42, 2006. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import load_diabetes 
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split 
    &gt;&gt;&gt; from sklearn.ensemble import ExtraTreesRegressor 
    &gt;&gt;&gt; X, y = load_diabetes(return_X_y=True) 
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split( 
    ...     X, y, random_state=0) 
    &gt;&gt;&gt; reg = ExtraTreesRegressor(n_estimators=100, random_state=0).fit( 
    ...    X_train, y_train) 
    &gt;&gt;&gt; reg.score(X_test, y_test) 
    0.2727... 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s1">**ForestRegressor._parameter_constraints</span><span class="s3">,</span>
        <span class="s1">**DecisionTreeRegressor._parameter_constraints</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">_parameter_constraints.pop(</span><span class="s4">&quot;splitter&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">n_estimators=</span><span class="s5">100</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">criterion=</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">,</span>
        <span class="s1">max_depth=</span><span class="s3">None,</span>
        <span class="s1">min_samples_split=</span><span class="s5">2</span><span class="s3">,</span>
        <span class="s1">min_samples_leaf=</span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">min_weight_fraction_leaf=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_features=</span><span class="s5">1.0</span><span class="s3">,</span>
        <span class="s1">max_leaf_nodes=</span><span class="s3">None,</span>
        <span class="s1">min_impurity_decrease=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">bootstrap=</span><span class="s3">False,</span>
        <span class="s1">oob_score=</span><span class="s3">False,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">warm_start=</span><span class="s3">False,</span>
        <span class="s1">ccp_alpha=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_samples=</span><span class="s3">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">estimator=ExtraTreeRegressor()</span><span class="s3">,</span>
            <span class="s1">n_estimators=n_estimators</span><span class="s3">,</span>
            <span class="s1">estimator_params=(</span>
                <span class="s4">&quot;criterion&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_depth&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_split&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_weight_fraction_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_features&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_leaf_nodes&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_impurity_decrease&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;random_state&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;ccp_alpha&quot;</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">bootstrap=bootstrap</span><span class="s3">,</span>
            <span class="s1">oob_score=oob_score</span><span class="s3">,</span>
            <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
            <span class="s1">verbose=verbose</span><span class="s3">,</span>
            <span class="s1">warm_start=warm_start</span><span class="s3">,</span>
            <span class="s1">max_samples=max_samples</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">self.criterion = criterion</span>
        <span class="s1">self.max_depth = max_depth</span>
        <span class="s1">self.min_samples_split = min_samples_split</span>
        <span class="s1">self.min_samples_leaf = min_samples_leaf</span>
        <span class="s1">self.min_weight_fraction_leaf = min_weight_fraction_leaf</span>
        <span class="s1">self.max_features = max_features</span>
        <span class="s1">self.max_leaf_nodes = max_leaf_nodes</span>
        <span class="s1">self.min_impurity_decrease = min_impurity_decrease</span>
        <span class="s1">self.ccp_alpha = ccp_alpha</span>


<span class="s3">class </span><span class="s1">RandomTreesEmbedding(TransformerMixin</span><span class="s3">, </span><span class="s1">BaseForest):</span>
    <span class="s0">&quot;&quot;&quot; 
    An ensemble of totally random trees. 
 
    An unsupervised transformation of a dataset to a high-dimensional 
    sparse representation. A datapoint is coded according to which leaf of 
    each tree it is sorted into. Using a one-hot encoding of the leaves, 
    this leads to a binary coding with as many ones as there are trees in 
    the forest. 
 
    The dimensionality of the resulting representation is 
    ``n_out &lt;= n_estimators * max_leaf_nodes``. If ``max_leaf_nodes == None``, 
    the number of leaf nodes is at most ``n_estimators * 2 ** max_depth``. 
 
    Read more in the :ref:`User Guide &lt;random_trees_embedding&gt;`. 
 
    Parameters 
    ---------- 
    n_estimators : int, default=100 
        Number of trees in the forest. 
 
        .. versionchanged:: 0.22 
           The default value of ``n_estimators`` changed from 10 to 100 
           in 0.22. 
 
    max_depth : int, default=5 
        The maximum depth of each tree. If None, then nodes are expanded until 
        all leaves are pure or until all leaves contain less than 
        min_samples_split samples. 
 
    min_samples_split : int or float, default=2 
        The minimum number of samples required to split an internal node: 
 
        - If int, then consider `min_samples_split` as the minimum number. 
        - If float, then `min_samples_split` is a fraction and 
          `ceil(min_samples_split * n_samples)` is the minimum 
          number of samples for each split. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_samples_leaf : int or float, default=1 
        The minimum number of samples required to be at a leaf node. 
        A split point at any depth will only be considered if it leaves at 
        least ``min_samples_leaf`` training samples in each of the left and 
        right branches.  This may have the effect of smoothing the model, 
        especially in regression. 
 
        - If int, then consider `min_samples_leaf` as the minimum number. 
        - If float, then `min_samples_leaf` is a fraction and 
          `ceil(min_samples_leaf * n_samples)` is the minimum 
          number of samples for each node. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_weight_fraction_leaf : float, default=0.0 
        The minimum weighted fraction of the sum total of weights (of all 
        the input samples) required to be at a leaf node. Samples have 
        equal weight when sample_weight is not provided. 
 
    max_leaf_nodes : int, default=None 
        Grow trees with ``max_leaf_nodes`` in best-first fashion. 
        Best nodes are defined as relative reduction in impurity. 
        If None then unlimited number of leaf nodes. 
 
    min_impurity_decrease : float, default=0.0 
        A node will be split if this split induces a decrease of the impurity 
        greater than or equal to this value. 
 
        The weighted impurity decrease equation is the following:: 
 
            N_t / N * (impurity - N_t_R / N_t * right_impurity 
                                - N_t_L / N_t * left_impurity) 
 
        where ``N`` is the total number of samples, ``N_t`` is the number of 
        samples at the current node, ``N_t_L`` is the number of samples in the 
        left child, and ``N_t_R`` is the number of samples in the right child. 
 
        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum, 
        if ``sample_weight`` is passed. 
 
        .. versionadded:: 0.19 
 
    sparse_output : bool, default=True 
        Whether or not to return a sparse CSR matrix, as default behavior, 
        or to return a dense array compatible with dense pipeline operators. 
 
    n_jobs : int, default=None 
        The number of jobs to run in parallel. :meth:`fit`, :meth:`transform`, 
        :meth:`decision_path` and :meth:`apply` are all parallelized over the 
        trees. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` 
        context. ``-1`` means using all processors. See :term:`Glossary 
        &lt;n_jobs&gt;` for more details. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the generation of the random `y` used to fit the trees 
        and the draw of the splits for each feature at the trees' nodes. 
        See :term:`Glossary &lt;random_state&gt;` for details. 
 
    verbose : int, default=0 
        Controls the verbosity when fitting and predicting. 
 
    warm_start : bool, default=False 
        When set to ``True``, reuse the solution of the previous call to fit 
        and add more estimators to the ensemble, otherwise, just fit a whole 
        new forest. See :term:`Glossary &lt;warm_start&gt;` and 
        :ref:`gradient_boosting_warm_start` for details. 
 
    Attributes 
    ---------- 
    estimator_ : :class:`~sklearn.tree.ExtraTreeRegressor` instance 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. versionadded:: 1.2 
           `base_estimator_` was renamed to `estimator_`. 
 
    base_estimator_ : :class:`~sklearn.tree.ExtraTreeRegressor` instance 
        The child estimator template used to create the collection of fitted 
        sub-estimators. 
 
        .. deprecated:: 1.2 
            `base_estimator_` is deprecated and will be removed in 1.4. 
            Use `estimator_` instead. 
 
    estimators_ : list of :class:`~sklearn.tree.ExtraTreeRegressor` instances 
        The collection of fitted sub-estimators. 
 
    feature_importances_ : ndarray of shape (n_features,) 
        The feature importances (the higher, the more important the feature). 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    n_outputs_ : int 
        The number of outputs when ``fit`` is performed. 
 
    one_hot_encoder_ : OneHotEncoder instance 
        One-hot encoder used to create the sparse embedding. 
 
    See Also 
    -------- 
    ExtraTreesClassifier : An extra-trees classifier. 
    ExtraTreesRegressor : An extra-trees regressor. 
    RandomForestClassifier : A random forest classifier. 
    RandomForestRegressor : A random forest regressor. 
    sklearn.tree.ExtraTreeClassifier: An extremely randomized 
        tree classifier. 
    sklearn.tree.ExtraTreeRegressor : An extremely randomized 
        tree regressor. 
 
    References 
    ---------- 
    .. [1] P. Geurts, D. Ernst., and L. Wehenkel, &quot;Extremely randomized trees&quot;, 
           Machine Learning, 63(1), 3-42, 2006. 
    .. [2] Moosmann, F. and Triggs, B. and Jurie, F.  &quot;Fast discriminative 
           visual codebooks using randomized clustering forests&quot; 
           NIPS 2007 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.ensemble import RandomTreesEmbedding 
    &gt;&gt;&gt; X = [[0,0], [1,0], [0,1], [-1,0], [0,-1]] 
    &gt;&gt;&gt; random_trees = RandomTreesEmbedding( 
    ...    n_estimators=5, random_state=0, max_depth=1).fit(X) 
    &gt;&gt;&gt; X_sparse_embedding = random_trees.transform(X) 
    &gt;&gt;&gt; X_sparse_embedding.toarray() 
    array([[0., 1., 1., 0., 1., 0., 0., 1., 1., 0.], 
           [0., 1., 1., 0., 1., 0., 0., 1., 1., 0.], 
           [0., 1., 0., 1., 0., 1., 0., 1., 0., 1.], 
           [1., 0., 1., 0., 1., 0., 1., 0., 1., 0.], 
           [0., 1., 1., 0., 1., 0., 0., 1., 1., 0.]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s4">&quot;n_estimators&quot;</span><span class="s1">: [Interval(Integral</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;warm_start&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">**BaseDecisionTree._parameter_constraints</span><span class="s3">,</span>
        <span class="s4">&quot;sparse_output&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s3">for </span><span class="s1">param </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;max_features&quot;</span><span class="s3">, </span><span class="s4">&quot;ccp_alpha&quot;</span><span class="s3">, </span><span class="s4">&quot;splitter&quot;</span><span class="s1">):</span>
        <span class="s1">_parameter_constraints.pop(param)</span>

    <span class="s1">criterion = </span><span class="s4">&quot;squared_error&quot;</span>
    <span class="s1">max_features = </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">n_estimators=</span><span class="s5">100</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">max_depth=</span><span class="s5">5</span><span class="s3">,</span>
        <span class="s1">min_samples_split=</span><span class="s5">2</span><span class="s3">,</span>
        <span class="s1">min_samples_leaf=</span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">min_weight_fraction_leaf=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">max_leaf_nodes=</span><span class="s3">None,</span>
        <span class="s1">min_impurity_decrease=</span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s1">sparse_output=</span><span class="s3">True,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
        <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">warm_start=</span><span class="s3">False,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">estimator=ExtraTreeRegressor()</span><span class="s3">,</span>
            <span class="s1">n_estimators=n_estimators</span><span class="s3">,</span>
            <span class="s1">estimator_params=(</span>
                <span class="s4">&quot;criterion&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_depth&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_split&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_samples_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_weight_fraction_leaf&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_features&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;max_leaf_nodes&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;min_impurity_decrease&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;random_state&quot;</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">bootstrap=</span><span class="s3">False,</span>
            <span class="s1">oob_score=</span><span class="s3">False,</span>
            <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
            <span class="s1">verbose=verbose</span><span class="s3">,</span>
            <span class="s1">warm_start=warm_start</span><span class="s3">,</span>
            <span class="s1">max_samples=</span><span class="s3">None,</span>
        <span class="s1">)</span>

        <span class="s1">self.max_depth = max_depth</span>
        <span class="s1">self.min_samples_split = min_samples_split</span>
        <span class="s1">self.min_samples_leaf = min_samples_leaf</span>
        <span class="s1">self.min_weight_fraction_leaf = min_weight_fraction_leaf</span>
        <span class="s1">self.max_leaf_nodes = max_leaf_nodes</span>
        <span class="s1">self.min_impurity_decrease = min_impurity_decrease</span>
        <span class="s1">self.sparse_output = sparse_output</span>

    <span class="s3">def </span><span class="s1">_set_oob_score_and_attributes(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">scoring_function=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;OOB score not supported by tree embedding&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fit estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Use ``dtype=np.float32`` for maximum 
            efficiency. Sparse matrices are also supported, use sparse 
            ``csc_matrix`` for maximum efficiency. 
 
        y : Ignored 
            Not used, present for API consistency by convention. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If None, then samples are equally weighted. Splits 
            that would create child nodes with net zero or negative weight are 
            ignored while searching for a split in each node. In the case of 
            classification, splits are also ignored if they would result in any 
            single class carrying a negative weight in either child node. 
 
        Returns 
        ------- 
        self : object 
            Returns the instance itself. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Parameters are validated in fit_transform</span>
        <span class="s1">self.fit_transform(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@_fit_context(prefer_skip_nested_validation=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit_transform(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">sample_weight=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fit estimator and transform dataset. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Input data used to build forests. Use ``dtype=np.float32`` for 
            maximum efficiency. 
 
        y : Ignored 
            Not used, present for API consistency by convention. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If None, then samples are equally weighted. Splits 
            that would create child nodes with net zero or negative weight are 
            ignored while searching for a split in each node. In the case of 
            classification, splits are also ignored if they would result in any 
            single class carrying a negative weight in either child node. 
 
        Returns 
        ------- 
        X_transformed : sparse matrix of shape (n_samples, n_out) 
            Transformed dataset. 
        &quot;&quot;&quot;</span>
        <span class="s1">rnd = check_random_state(self.random_state)</span>
        <span class="s1">y = rnd.uniform(size=_num_samples(X))</span>
        <span class="s1">super().fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight)</span>

        <span class="s1">self.one_hot_encoder_ = OneHotEncoder(sparse_output=self.sparse_output)</span>
        <span class="s1">output = self.one_hot_encoder_.fit_transform(self.apply(X))</span>
        <span class="s1">self._n_features_out = output.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">output</span>

    <span class="s3">def </span><span class="s1">get_feature_names_out(self</span><span class="s3">, </span><span class="s1">input_features=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get output feature names for transformation. 
 
        Parameters 
        ---------- 
        input_features : array-like of str or None, default=None 
            Only used to validate feature names with the names seen in :meth:`fit`. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of str objects 
            Transformed feature names, in the format of 
            `randomtreesembedding_{tree}_{leaf}`, where `tree` is the tree used 
            to generate the leaf and `leaf` is the index of a leaf node 
            in that tree. Note that the node indexing scheme is used to 
            index both nodes with children (split nodes) and leaf nodes. 
            Only the latter can be present as output features. 
            As a consequence, there are missing indices in the output 
            feature names. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self</span><span class="s3">, </span><span class="s4">&quot;_n_features_out&quot;</span><span class="s1">)</span>
        <span class="s1">_check_feature_names_in(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">input_features=input_features</span><span class="s3">, </span><span class="s1">generate_names=</span><span class="s3">False</span>
        <span class="s1">)</span>

        <span class="s1">feature_names = [</span>
            <span class="s4">f&quot;randomtreesembedding_</span><span class="s3">{</span><span class="s1">tree</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">leaf</span><span class="s3">}</span><span class="s4">&quot;</span>
            <span class="s3">for </span><span class="s1">tree </span><span class="s3">in </span><span class="s1">range(self.n_estimators)</span>
            <span class="s3">for </span><span class="s1">leaf </span><span class="s3">in </span><span class="s1">self.one_hot_encoder_.categories_[tree]</span>
        <span class="s1">]</span>
        <span class="s3">return </span><span class="s1">np.asarray(feature_names</span><span class="s3">, </span><span class="s1">dtype=object)</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot; 
        Transform dataset. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Input data to be transformed. Use ``dtype=np.float32`` for maximum 
            efficiency. Sparse matrices are also supported, use sparse 
            ``csr_matrix`` for maximum efficiency. 
 
        Returns 
        ------- 
        X_transformed : sparse matrix of shape (n_samples, n_out) 
            Transformed dataset. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s3">return </span><span class="s1">self.one_hot_encoder_.transform(self.apply(X))</span>
</pre>
</body>
</html>