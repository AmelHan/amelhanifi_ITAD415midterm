<html>
<head>
<title>test_expm_multiply.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_expm_multiply.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Test functions for the sparse.linalg._expm_multiply module.&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">product</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_allclose</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_equal</span><span class="s2">,</span>
                           <span class="s1">suppress_warnings)</span>
<span class="s2">from </span><span class="s1">scipy.sparse </span><span class="s2">import </span><span class="s1">SparseEfficiencyWarning</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg </span><span class="s2">import </span><span class="s1">aslinearoperator</span>
<span class="s2">import </span><span class="s1">scipy.linalg</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg </span><span class="s2">import </span><span class="s1">expm </span><span class="s2">as </span><span class="s1">sp_expm</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg._expm_multiply </span><span class="s2">import </span><span class="s1">(_theta</span><span class="s2">, </span><span class="s1">_compute_p_max</span><span class="s2">,</span>
        <span class="s1">_onenormest_matrix_power</span><span class="s2">, </span><span class="s1">expm_multiply</span><span class="s2">, </span><span class="s1">_expm_multiply_simple</span><span class="s2">,</span>
        <span class="s1">_expm_multiply_interval)</span>


<span class="s1">IMPRECISE = {np.single</span><span class="s2">, </span><span class="s1">np.csingle}</span>
<span class="s1">REAL_DTYPES = {np.intc</span><span class="s2">, </span><span class="s1">np.int_</span><span class="s2">, </span><span class="s1">np.longlong</span><span class="s2">,</span>
               <span class="s1">np.single</span><span class="s2">, </span><span class="s1">np.double</span><span class="s2">, </span><span class="s1">np.longdouble}</span>
<span class="s1">COMPLEX_DTYPES = {np.csingle</span><span class="s2">, </span><span class="s1">np.cdouble</span><span class="s2">, </span><span class="s1">np.clongdouble}</span>
<span class="s3"># use sorted tuple to ensure fixed order of tests</span>
<span class="s1">DTYPES = tuple(sorted(REAL_DTYPES ^ COMPLEX_DTYPES</span><span class="s2">, </span><span class="s1">key=str))</span>


<span class="s2">def </span><span class="s1">estimated(func):</span>
    <span class="s0">&quot;&quot;&quot;If trace is estimated, it should warn. 
 
    We warn that estimation of trace might impact performance. 
    All result have to be correct nevertheless! 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">wrapped(*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">,</span>
                          <span class="s1">match=</span><span class="s4">&quot;Trace of LinearOperator not available&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwds)</span>
    <span class="s2">return </span><span class="s1">wrapped</span>


<span class="s2">def </span><span class="s1">less_than_or_close(a</span><span class="s2">, </span><span class="s1">b):</span>
    <span class="s2">return </span><span class="s1">np.allclose(a</span><span class="s2">, </span><span class="s1">b) </span><span class="s2">or </span><span class="s1">(a &lt; b)</span>


<span class="s2">class </span><span class="s1">TestExpmActionSimple:</span>
    <span class="s0">&quot;&quot;&quot; 
    These tests do not consider the case of multiple time steps in one call. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_theta_monotonicity(self):</span>
        <span class="s1">pairs = sorted(_theta.items())</span>
        <span class="s2">for </span><span class="s1">(m_a</span><span class="s2">, </span><span class="s1">theta_a)</span><span class="s2">, </span><span class="s1">(m_b</span><span class="s2">, </span><span class="s1">theta_b) </span><span class="s2">in </span><span class="s1">zip(pairs[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pairs[</span><span class="s5">1</span><span class="s1">:]):</span>
            <span class="s1">assert_(theta_a &lt; theta_b)</span>

    <span class="s2">def </span><span class="s1">test_p_max_default(self):</span>
        <span class="s1">m_max = </span><span class="s5">55</span>
        <span class="s1">expected_p_max = </span><span class="s5">8</span>
        <span class="s1">observed_p_max = _compute_p_max(m_max)</span>
        <span class="s1">assert_equal(observed_p_max</span><span class="s2">, </span><span class="s1">expected_p_max)</span>

    <span class="s2">def </span><span class="s1">test_p_max_range(self):</span>
        <span class="s2">for </span><span class="s1">m_max </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">55</span><span class="s1">+</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">p_max = _compute_p_max(m_max)</span>
            <span class="s1">assert_(p_max*(p_max - </span><span class="s5">1</span><span class="s1">) &lt;= m_max + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">p_too_big = p_max + </span><span class="s5">1</span>
            <span class="s1">assert_(p_too_big*(p_too_big - </span><span class="s5">1</span><span class="s1">) &gt; m_max + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_onenormest_matrix_power(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s5">40</span>
        <span class="s1">nsamples = </span><span class="s5">10</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nsamples):</span>
            <span class="s1">A = scipy.linalg.inv(np.random.randn(n</span><span class="s2">, </span><span class="s1">n))</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s1">):</span>
                <span class="s2">if not </span><span class="s1">p:</span>
                    <span class="s1">M = np.identity(n)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">M = np.dot(M</span><span class="s2">, </span><span class="s1">A)</span>
                <span class="s1">estimated = _onenormest_matrix_power(A</span><span class="s2">, </span><span class="s1">p)</span>
                <span class="s1">exact = np.linalg.norm(M</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">assert_(less_than_or_close(estimated</span><span class="s2">, </span><span class="s1">exact))</span>
                <span class="s1">assert_(less_than_or_close(exact</span><span class="s2">, </span><span class="s5">3</span><span class="s1">*estimated))</span>

    <span class="s2">def </span><span class="s1">test_expm_multiply(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s5">40</span>
        <span class="s1">k = </span><span class="s5">3</span>
        <span class="s1">nsamples = </span><span class="s5">10</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nsamples):</span>
            <span class="s1">A = scipy.linalg.inv(np.random.randn(n</span><span class="s2">, </span><span class="s1">n))</span>
            <span class="s1">B = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
            <span class="s1">observed = expm_multiply(A</span><span class="s2">, </span><span class="s1">B)</span>
            <span class="s1">expected = np.dot(sp_expm(A)</span><span class="s2">, </span><span class="s1">B)</span>
            <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>
            <span class="s1">observed = estimated(expm_multiply)(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B)</span>
            <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>
            <span class="s1">traceA = np.trace(A)</span>
            <span class="s1">observed = expm_multiply(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">traceA=traceA)</span>
            <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_matrix_vector_multiply(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s5">40</span>
        <span class="s1">nsamples = </span><span class="s5">10</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nsamples):</span>
            <span class="s1">A = scipy.linalg.inv(np.random.randn(n</span><span class="s2">, </span><span class="s1">n))</span>
            <span class="s1">v = np.random.randn(n)</span>
            <span class="s1">observed = expm_multiply(A</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">expected = np.dot(sp_expm(A)</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>
            <span class="s1">observed = estimated(expm_multiply)(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_scaled_expm_multiply(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s5">40</span>
        <span class="s1">k = </span><span class="s5">3</span>
        <span class="s1">nsamples = </span><span class="s5">10</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">product(range(nsamples)</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1.5</span><span class="s1">]):</span>
            <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
                <span class="s1">A = scipy.linalg.inv(np.random.randn(n</span><span class="s2">, </span><span class="s1">n))</span>
                <span class="s1">B = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
                <span class="s1">observed = _expm_multiply_simple(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">t=t)</span>
                <span class="s1">expected = np.dot(sp_expm(t*A)</span><span class="s2">, </span><span class="s1">B)</span>
                <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>
                <span class="s1">observed = estimated(_expm_multiply_simple)(</span>
                    <span class="s1">aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">t=t</span>
                <span class="s1">)</span>
                <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_scaled_expm_multiply_single_timepoint(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">t = </span><span class="s5">0.1</span>
        <span class="s1">n = </span><span class="s5">5</span>
        <span class="s1">k = </span><span class="s5">2</span>
        <span class="s1">A = np.random.randn(n</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">B = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">observed = _expm_multiply_simple(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">t=t)</span>
        <span class="s1">expected = sp_expm(t*A).dot(B)</span>
        <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">observed = estimated(_expm_multiply_simple)(</span>
            <span class="s1">aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">t=t</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_sparse_expm_multiply(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s5">40</span>
        <span class="s1">k = </span><span class="s5">3</span>
        <span class="s1">nsamples = </span><span class="s5">10</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nsamples):</span>
            <span class="s1">A = scipy.sparse.rand(n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">density=</span><span class="s5">0.05</span><span class="s1">)</span>
            <span class="s1">B = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
            <span class="s1">observed = expm_multiply(A</span><span class="s2">, </span><span class="s1">B)</span>
            <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
                <span class="s1">sup.filter(SparseEfficiencyWarning</span><span class="s2">,</span>
                           <span class="s4">&quot;splu converted its input to CSC format&quot;</span><span class="s1">)</span>
                <span class="s1">sup.filter(SparseEfficiencyWarning</span><span class="s2">,</span>
                           <span class="s4">&quot;spsolve is more efficient when sparse b is in the&quot;</span>
                           <span class="s4">&quot; CSC matrix format&quot;</span><span class="s1">)</span>
                <span class="s1">expected = sp_expm(A).dot(B)</span>
            <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>
            <span class="s1">observed = estimated(expm_multiply)(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B)</span>
            <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_complex(self):</span>
        <span class="s1">A = np.array([</span>
            <span class="s1">[</span><span class="s5">1j</span><span class="s2">, </span><span class="s5">1j</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">B = np.array([</span><span class="s5">1j</span><span class="s2">, </span><span class="s5">1j</span><span class="s1">])</span>
        <span class="s1">observed = expm_multiply(A</span><span class="s2">, </span><span class="s1">B)</span>
        <span class="s1">expected = np.array([</span>
            <span class="s5">1j </span><span class="s1">* np.exp(</span><span class="s5">1j</span><span class="s1">) + </span><span class="s5">1j </span><span class="s1">* (</span><span class="s5">1j</span><span class="s1">*np.cos(</span><span class="s5">1</span><span class="s1">) - np.sin(</span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s5">1j </span><span class="s1">* np.exp(</span><span class="s5">1j</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">observed = estimated(expm_multiply)(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B)</span>
        <span class="s1">assert_allclose(observed</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestExpmActionInterval:</span>

    <span class="s2">def </span><span class="s1">test_sparse_expm_multiply_interval(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">start = </span><span class="s5">0.1</span>
        <span class="s1">stop = </span><span class="s5">3.2</span>
        <span class="s1">n = </span><span class="s5">40</span>
        <span class="s1">k = </span><span class="s5">3</span>
        <span class="s1">endpoint = </span><span class="s2">True</span>
        <span class="s2">for </span><span class="s1">num </span><span class="s2">in </span><span class="s1">(</span><span class="s5">14</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">A = scipy.sparse.rand(n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">density=</span><span class="s5">0.05</span><span class="s1">)</span>
            <span class="s1">B = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
            <span class="s1">v = np.random.randn(n)</span>
            <span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">(B</span><span class="s2">, </span><span class="s1">v):</span>
                <span class="s1">X = expm_multiply(A</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">start=start</span><span class="s2">, </span><span class="s1">stop=stop</span><span class="s2">,</span>
                                  <span class="s1">num=num</span><span class="s2">, </span><span class="s1">endpoint=endpoint)</span>
                <span class="s1">samples = np.linspace(start=start</span><span class="s2">, </span><span class="s1">stop=stop</span><span class="s2">,</span>
                                      <span class="s1">num=num</span><span class="s2">, </span><span class="s1">endpoint=endpoint)</span>
                <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
                    <span class="s1">sup.filter(SparseEfficiencyWarning</span><span class="s2">,</span>
                               <span class="s4">&quot;splu converted its input to CSC format&quot;</span><span class="s1">)</span>
                    <span class="s1">sup.filter(SparseEfficiencyWarning</span><span class="s2">,</span>
                               <span class="s4">&quot;spsolve is more efficient when sparse b is in&quot;</span>
                               <span class="s4">&quot; the CSC matrix format&quot;</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">solution</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(X</span><span class="s2">, </span><span class="s1">samples):</span>
                        <span class="s1">assert_allclose(solution</span><span class="s2">, </span><span class="s1">sp_expm(t*A).dot(target))</span>

    <span class="s2">def </span><span class="s1">test_expm_multiply_interval_vector(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">interval = {</span><span class="s4">'start'</span><span class="s1">: </span><span class="s5">0.1</span><span class="s2">, </span><span class="s4">'stop'</span><span class="s1">: </span><span class="s5">3.2</span><span class="s2">, </span><span class="s4">'endpoint'</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
        <span class="s2">for </span><span class="s1">num</span><span class="s2">, </span><span class="s1">n </span><span class="s2">in </span><span class="s1">product([</span><span class="s5">14</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">40</span><span class="s1">]):</span>
            <span class="s1">A = scipy.linalg.inv(np.random.randn(n</span><span class="s2">, </span><span class="s1">n))</span>
            <span class="s1">v = np.random.randn(n)</span>
            <span class="s1">samples = np.linspace(num=num</span><span class="s2">, </span><span class="s1">**interval)</span>
            <span class="s1">X = expm_multiply(A</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">num=num</span><span class="s2">, </span><span class="s1">**interval)</span>
            <span class="s2">for </span><span class="s1">solution</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(X</span><span class="s2">, </span><span class="s1">samples):</span>
                <span class="s1">assert_allclose(solution</span><span class="s2">, </span><span class="s1">sp_expm(t*A).dot(v))</span>
            <span class="s3"># test for linear operator with unknown trace -&gt; estimate trace</span>
            <span class="s1">Xguess = estimated(expm_multiply)(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">v</span><span class="s2">,</span>
                                              <span class="s1">num=num</span><span class="s2">, </span><span class="s1">**interval)</span>
            <span class="s3"># test for linear operator with given trace</span>
            <span class="s1">Xgiven = expm_multiply(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">num=num</span><span class="s2">, </span><span class="s1">**interval</span><span class="s2">,</span>
                                   <span class="s1">traceA=np.trace(A))</span>
            <span class="s3"># test robustness for linear operator with wrong trace</span>
            <span class="s1">Xwrong = expm_multiply(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">num=num</span><span class="s2">, </span><span class="s1">**interval</span><span class="s2">,</span>
                                   <span class="s1">traceA=np.trace(A)*</span><span class="s5">5</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">sol_guess</span><span class="s2">, </span><span class="s1">sol_given</span><span class="s2">, </span><span class="s1">sol_wrong</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(Xguess</span><span class="s2">, </span><span class="s1">Xgiven</span><span class="s2">,</span>
                                                          <span class="s1">Xwrong</span><span class="s2">, </span><span class="s1">samples):</span>
                <span class="s1">correct = sp_expm(t*A).dot(v)</span>
                <span class="s1">assert_allclose(sol_guess</span><span class="s2">, </span><span class="s1">correct)</span>
                <span class="s1">assert_allclose(sol_given</span><span class="s2">, </span><span class="s1">correct)</span>
                <span class="s1">assert_allclose(sol_wrong</span><span class="s2">, </span><span class="s1">correct)</span>

    <span class="s2">def </span><span class="s1">test_expm_multiply_interval_matrix(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">interval = {</span><span class="s4">'start'</span><span class="s1">: </span><span class="s5">0.1</span><span class="s2">, </span><span class="s4">'stop'</span><span class="s1">: </span><span class="s5">3.2</span><span class="s2">, </span><span class="s4">'endpoint'</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
        <span class="s2">for </span><span class="s1">num</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">product([</span><span class="s5">14</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">40</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]):</span>
            <span class="s1">A = scipy.linalg.inv(np.random.randn(n</span><span class="s2">, </span><span class="s1">n))</span>
            <span class="s1">B = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
            <span class="s1">samples = np.linspace(num=num</span><span class="s2">, </span><span class="s1">**interval)</span>
            <span class="s1">X = expm_multiply(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">num=num</span><span class="s2">, </span><span class="s1">**interval)</span>
            <span class="s2">for </span><span class="s1">solution</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(X</span><span class="s2">, </span><span class="s1">samples):</span>
                <span class="s1">assert_allclose(solution</span><span class="s2">, </span><span class="s1">sp_expm(t*A).dot(B))</span>
            <span class="s1">X = estimated(expm_multiply)(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">num=num</span><span class="s2">,</span>
                                         <span class="s1">**interval)</span>
            <span class="s2">for </span><span class="s1">solution</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(X</span><span class="s2">, </span><span class="s1">samples):</span>
                <span class="s1">assert_allclose(solution</span><span class="s2">, </span><span class="s1">sp_expm(t*A).dot(B))</span>

    <span class="s2">def </span><span class="s1">test_sparse_expm_multiply_interval_dtypes(self):</span>
        <span class="s3"># Test A &amp; B int</span>
        <span class="s1">A = scipy.sparse.diags(np.arange(</span><span class="s5">5</span><span class="s1">)</span><span class="s2">,</span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">B = np.ones(</span><span class="s5">5</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">Aexpm = scipy.sparse.diags(np.exp(np.arange(</span><span class="s5">5</span><span class="s1">))</span><span class="s2">,</span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(expm_multiply(A</span><span class="s2">,</span><span class="s1">B</span><span class="s2">,</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Aexpm.dot(B))</span>

        <span class="s3"># Test A complex, B int</span>
        <span class="s1">A = scipy.sparse.diags(-</span><span class="s5">1j</span><span class="s1">*np.arange(</span><span class="s5">5</span><span class="s1">)</span><span class="s2">,</span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s2">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">B = np.ones(</span><span class="s5">5</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">Aexpm = scipy.sparse.diags(np.exp(-</span><span class="s5">1j</span><span class="s1">*np.arange(</span><span class="s5">5</span><span class="s1">))</span><span class="s2">,</span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(expm_multiply(A</span><span class="s2">,</span><span class="s1">B</span><span class="s2">,</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Aexpm.dot(B))</span>

        <span class="s3"># Test A int, B complex</span>
        <span class="s1">A = scipy.sparse.diags(np.arange(</span><span class="s5">5</span><span class="s1">)</span><span class="s2">,</span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">B = np.full(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">1j</span><span class="s2">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">Aexpm = scipy.sparse.diags(np.exp(np.arange(</span><span class="s5">5</span><span class="s1">))</span><span class="s2">,</span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(expm_multiply(A</span><span class="s2">,</span><span class="s1">B</span><span class="s2">,</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Aexpm.dot(B))</span>

    <span class="s2">def </span><span class="s1">test_expm_multiply_interval_status_0(self):</span>
        <span class="s1">self._help_test_specific_expm_interval_status(</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_expm_multiply_interval_status_1(self):</span>
        <span class="s1">self._help_test_specific_expm_interval_status(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_expm_multiply_interval_status_2(self):</span>
        <span class="s1">self._help_test_specific_expm_interval_status(</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_help_test_specific_expm_interval_status(self</span><span class="s2">, </span><span class="s1">target_status):</span>
        <span class="s1">np.random.seed(</span><span class="s5">1234</span><span class="s1">)</span>
        <span class="s1">start = </span><span class="s5">0.1</span>
        <span class="s1">stop = </span><span class="s5">3.2</span>
        <span class="s1">num = </span><span class="s5">13</span>
        <span class="s1">endpoint = </span><span class="s2">True</span>
        <span class="s1">n = </span><span class="s5">5</span>
        <span class="s1">k = </span><span class="s5">2</span>
        <span class="s1">nrepeats = </span><span class="s5">10</span>
        <span class="s1">nsuccesses = </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">num </span><span class="s2">in </span><span class="s1">[</span><span class="s5">14</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] * nrepeats:</span>
            <span class="s1">A = np.random.randn(n</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">B = np.random.randn(n</span><span class="s2">, </span><span class="s1">k)</span>
            <span class="s1">status = _expm_multiply_interval(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">,</span>
                    <span class="s1">start=start</span><span class="s2">, </span><span class="s1">stop=stop</span><span class="s2">, </span><span class="s1">num=num</span><span class="s2">, </span><span class="s1">endpoint=endpoint</span><span class="s2">,</span>
                    <span class="s1">status_only=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">status == target_status:</span>
                <span class="s1">X</span><span class="s2">, </span><span class="s1">status = _expm_multiply_interval(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">,</span>
                        <span class="s1">start=start</span><span class="s2">, </span><span class="s1">stop=stop</span><span class="s2">, </span><span class="s1">num=num</span><span class="s2">, </span><span class="s1">endpoint=endpoint</span><span class="s2">,</span>
                        <span class="s1">status_only=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">assert_equal(X.shape</span><span class="s2">, </span><span class="s1">(num</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k))</span>
                <span class="s1">samples = np.linspace(start=start</span><span class="s2">, </span><span class="s1">stop=stop</span><span class="s2">,</span>
                        <span class="s1">num=num</span><span class="s2">, </span><span class="s1">endpoint=endpoint)</span>
                <span class="s2">for </span><span class="s1">solution</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(X</span><span class="s2">, </span><span class="s1">samples):</span>
                    <span class="s1">assert_allclose(solution</span><span class="s2">, </span><span class="s1">sp_expm(t*A).dot(B))</span>
                <span class="s1">nsuccesses += </span><span class="s5">1</span>
        <span class="s2">if not </span><span class="s1">nsuccesses:</span>
            <span class="s1">msg = </span><span class="s4">'failed to find a status-' </span><span class="s1">+ str(target_status) + </span><span class="s4">' interval'</span>
            <span class="s2">raise </span><span class="s1">Exception(msg)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype_a&quot;</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype_b&quot;</span><span class="s2">, </span><span class="s1">DTYPES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;b_is_matrix&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_expm_multiply_dtype(dtype_a</span><span class="s2">, </span><span class="s1">dtype_b</span><span class="s2">, </span><span class="s1">b_is_matrix):</span>
    <span class="s0">&quot;&quot;&quot;Make sure `expm_multiply` handles all numerical dtypes correctly.&quot;&quot;&quot;</span>
    <span class="s1">assert_allclose_ = (partial(assert_allclose</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1.2e-3</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">{dtype_a</span><span class="s2">, </span><span class="s1">dtype_b} &amp; IMPRECISE </span><span class="s2">else </span><span class="s1">assert_allclose)</span>
    <span class="s1">rng = np.random.default_rng(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s3"># test data</span>
    <span class="s1">n = </span><span class="s5">7</span>
    <span class="s1">b_shape = (n</span><span class="s2">, </span><span class="s5">3</span><span class="s1">) </span><span class="s2">if </span><span class="s1">b_is_matrix </span><span class="s2">else </span><span class="s1">(n</span><span class="s2">, </span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">dtype_a </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
        <span class="s1">A = scipy.linalg.inv(rng.random([n</span><span class="s2">, </span><span class="s1">n])).astype(dtype_a)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">A = scipy.linalg.inv(</span>
            <span class="s1">rng.random([n</span><span class="s2">, </span><span class="s1">n]) + </span><span class="s5">1j</span><span class="s1">*rng.random([n</span><span class="s2">, </span><span class="s1">n])</span>
        <span class="s1">).astype(dtype_a)</span>
    <span class="s2">if </span><span class="s1">dtype_b </span><span class="s2">in </span><span class="s1">REAL_DTYPES:</span>
        <span class="s1">B = (</span><span class="s5">2</span><span class="s1">*rng.random(b_shape)).astype(dtype_b)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">B = (rng.random(b_shape) + </span><span class="s5">1j</span><span class="s1">*rng.random(b_shape)).astype(dtype_b)</span>

    <span class="s3"># single application</span>
    <span class="s1">sol_mat = expm_multiply(A</span><span class="s2">, </span><span class="s1">B)</span>
    <span class="s1">sol_op = estimated(expm_multiply)(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B)</span>
    <span class="s1">direct_sol = np.dot(sp_expm(A)</span><span class="s2">, </span><span class="s1">B)</span>
    <span class="s1">assert_allclose_(sol_mat</span><span class="s2">, </span><span class="s1">direct_sol)</span>
    <span class="s1">assert_allclose_(sol_op</span><span class="s2">, </span><span class="s1">direct_sol)</span>
    <span class="s1">sol_op = expm_multiply(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">traceA=np.trace(A))</span>
    <span class="s1">assert_allclose_(sol_op</span><span class="s2">, </span><span class="s1">direct_sol)</span>

    <span class="s3"># for time points</span>
    <span class="s1">interval = {</span><span class="s4">'start'</span><span class="s1">: </span><span class="s5">0.1</span><span class="s2">, </span><span class="s4">'stop'</span><span class="s1">: </span><span class="s5">3.2</span><span class="s2">, </span><span class="s4">'num'</span><span class="s1">: </span><span class="s5">13</span><span class="s2">, </span><span class="s4">'endpoint'</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
    <span class="s1">samples = np.linspace(**interval)</span>
    <span class="s1">X_mat = expm_multiply(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">**interval)</span>
    <span class="s1">X_op = estimated(expm_multiply)(aslinearoperator(A)</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">**interval)</span>
    <span class="s2">for </span><span class="s1">sol_mat</span><span class="s2">, </span><span class="s1">sol_op</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(X_mat</span><span class="s2">, </span><span class="s1">X_op</span><span class="s2">, </span><span class="s1">samples):</span>
        <span class="s1">direct_sol = sp_expm(t*A).dot(B)</span>
        <span class="s1">assert_allclose_(sol_mat</span><span class="s2">, </span><span class="s1">direct_sol)</span>
        <span class="s1">assert_allclose_(sol_op</span><span class="s2">, </span><span class="s1">direct_sol)</span>
</pre>
</body>
</html>