<html>
<head>
<title>overlap.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
overlap.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">Integral</span><span class="s0">, </span><span class="s1">Number</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">tlz </span><span class="s0">import </span><span class="s1">concat</span><span class="s0">, </span><span class="s1">get</span><span class="s0">, </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">tlz.curried </span><span class="s0">import </span><span class="s1">map</span>

<span class="s0">from </span><span class="s1">dask.array </span><span class="s0">import </span><span class="s1">chunk</span>
<span class="s0">from </span><span class="s1">dask.array.core </span><span class="s0">import </span><span class="s1">Array</span><span class="s0">, </span><span class="s1">concatenate</span><span class="s0">, </span><span class="s1">map_blocks</span><span class="s0">, </span><span class="s1">unify_chunks</span>
<span class="s0">from </span><span class="s1">dask.array.creation </span><span class="s0">import </span><span class="s1">empty_like</span><span class="s0">, </span><span class="s1">full_like</span>
<span class="s0">from </span><span class="s1">dask.array.numpy_compat </span><span class="s0">import </span><span class="s1">normalize_axis_tuple</span>
<span class="s0">from </span><span class="s1">dask.base </span><span class="s0">import </span><span class="s1">tokenize</span>
<span class="s0">from </span><span class="s1">dask.highlevelgraph </span><span class="s0">import </span><span class="s1">HighLevelGraph</span>
<span class="s0">from </span><span class="s1">dask.layers </span><span class="s0">import </span><span class="s1">ArrayOverlapLayer</span>
<span class="s0">from </span><span class="s1">dask.utils </span><span class="s0">import </span><span class="s1">derived_from</span>


<span class="s0">def </span><span class="s1">_overlap_internal_chunks(original_chunks</span><span class="s0">, </span><span class="s1">axes):</span>
    <span class="s2">&quot;&quot;&quot;Get new chunks for array with overlap.&quot;&quot;&quot;</span>
    <span class="s1">chunks = []</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">bds </span><span class="s0">in </span><span class="s1">enumerate(original_chunks):</span>
        <span class="s1">depth = axes.get(i</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">isinstance(depth</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">left_depth = depth[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">right_depth = depth[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">left_depth = depth</span>
            <span class="s1">right_depth = depth</span>

        <span class="s0">if </span><span class="s1">len(bds) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">chunks.append(bds)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">left = [bds[</span><span class="s3">0</span><span class="s1">] + right_depth]</span>
            <span class="s1">right = [bds[-</span><span class="s3">1</span><span class="s1">] + left_depth]</span>
            <span class="s1">mid = []</span>
            <span class="s0">for </span><span class="s1">bd </span><span class="s0">in </span><span class="s1">bds[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]:</span>
                <span class="s1">mid.append(bd + left_depth + right_depth)</span>
            <span class="s1">chunks.append(left + mid + right)</span>
    <span class="s0">return </span><span class="s1">chunks</span>


<span class="s0">def </span><span class="s1">overlap_internal(x</span><span class="s0">, </span><span class="s1">axes):</span>
    <span class="s2">&quot;&quot;&quot;Share boundaries between neighboring blocks 
 
    Parameters 
    ---------- 
 
    x: da.Array 
        A dask array 
    axes: dict 
        The size of the shared boundary per axis 
 
    The axes input informs how many cells to overlap between neighboring blocks 
    {0: 2, 2: 5} means share two cells in 0 axis, 5 cells in 2 axis 
    &quot;&quot;&quot;</span>
    <span class="s1">token = tokenize(x</span><span class="s0">, </span><span class="s1">axes)</span>
    <span class="s1">name = </span><span class="s4">&quot;overlap-&quot; </span><span class="s1">+ token</span>

    <span class="s1">graph = ArrayOverlapLayer(</span>
        <span class="s1">name=x.name</span><span class="s0">,</span>
        <span class="s1">axes=axes</span><span class="s0">,</span>
        <span class="s1">chunks=x.chunks</span><span class="s0">,</span>
        <span class="s1">numblocks=x.numblocks</span><span class="s0">,</span>
        <span class="s1">token=token</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">dependencies=[x])</span>
    <span class="s1">chunks = _overlap_internal_chunks(x.chunks</span><span class="s0">, </span><span class="s1">axes)</span>

    <span class="s0">return </span><span class="s1">Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">meta=x)</span>


<span class="s0">def </span><span class="s1">trim_overlap(x</span><span class="s0">, </span><span class="s1">depth</span><span class="s0">, </span><span class="s1">boundary=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Trim sides from each block. 
 
    This couples well with the ``map_overlap`` operation which may leave 
    excess data on each block. 
 
    See also 
    -------- 
    dask.array.overlap.map_overlap 
 
    &quot;&quot;&quot;</span>

    <span class="s5"># parameter to be passed to trim_internal</span>
    <span class="s1">axes = coerce_depth(x.ndim</span><span class="s0">, </span><span class="s1">depth)</span>
    <span class="s0">return </span><span class="s1">trim_internal(x</span><span class="s0">, </span><span class="s1">axes=axes</span><span class="s0">, </span><span class="s1">boundary=boundary)</span>


<span class="s0">def </span><span class="s1">trim_internal(x</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">boundary=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Trim sides from each block 
 
    This couples well with the overlap operation, which may leave excess data on 
    each block 
 
    See also 
    -------- 
    dask.array.chunk.trim 
    dask.array.map_blocks 
    &quot;&quot;&quot;</span>
    <span class="s1">boundary = coerce_boundary(x.ndim</span><span class="s0">, </span><span class="s1">boundary)</span>

    <span class="s1">olist = []</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">bd </span><span class="s0">in </span><span class="s1">enumerate(x.chunks):</span>
        <span class="s1">bdy = boundary.get(i</span><span class="s0">, </span><span class="s4">&quot;none&quot;</span><span class="s1">)</span>
        <span class="s1">overlap = axes.get(i</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">ilist = []</span>
        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">d </span><span class="s0">in </span><span class="s1">enumerate(bd):</span>
            <span class="s0">if </span><span class="s1">bdy != </span><span class="s4">&quot;none&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(overlap</span><span class="s0">, </span><span class="s1">tuple):</span>
                    <span class="s1">d = d - sum(overlap)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">d = d - overlap * </span><span class="s3">2</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(overlap</span><span class="s0">, </span><span class="s1">tuple):</span>
                    <span class="s1">d = d - overlap[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">j != </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">d</span>
                    <span class="s1">d = d - overlap[</span><span class="s3">1</span><span class="s1">] </span><span class="s0">if </span><span class="s1">j != len(bd) - </span><span class="s3">1 </span><span class="s0">else </span><span class="s1">d</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">d = d - overlap </span><span class="s0">if </span><span class="s1">j != </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">d</span>
                    <span class="s1">d = d - overlap </span><span class="s0">if </span><span class="s1">j != len(bd) - </span><span class="s3">1 </span><span class="s0">else </span><span class="s1">d</span>

            <span class="s1">ilist.append(d)</span>
        <span class="s1">olist.append(tuple(ilist))</span>
    <span class="s1">chunks = tuple(olist)</span>

    <span class="s0">return </span><span class="s1">map_blocks(</span>
        <span class="s1">partial(_trim</span><span class="s0">, </span><span class="s1">axes=axes</span><span class="s0">, </span><span class="s1">boundary=boundary)</span><span class="s0">,</span>
        <span class="s1">x</span><span class="s0">,</span>
        <span class="s1">chunks=chunks</span><span class="s0">,</span>
        <span class="s1">dtype=x.dtype</span><span class="s0">,</span>
        <span class="s1">meta=x._meta</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_trim(x</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">boundary</span><span class="s0">, </span><span class="s1">block_info):</span>
    <span class="s2">&quot;&quot;&quot;Similar to dask.array.chunk.trim but requires one to specificy the 
    boundary condition. 
 
    ``axes``, and ``boundary`` are assumed to have been coerced. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">axes = [axes.get(i</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(x.ndim)]</span>
    <span class="s1">axes_front = (ax[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">isinstance(ax</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">else </span><span class="s1">ax </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axes)</span>
    <span class="s1">axes_back = (</span>
        <span class="s1">-ax[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">isinstance(ax</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">ax[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">else </span><span class="s1">-ax</span>
        <span class="s0">if </span><span class="s1">isinstance(ax</span><span class="s0">, </span><span class="s1">Integral) </span><span class="s0">and </span><span class="s1">ax</span>
        <span class="s0">else None</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axes</span>
    <span class="s1">)</span>

    <span class="s1">trim_front = (</span>
        <span class="s3">0 </span><span class="s0">if </span><span class="s1">(chunk_location == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">boundary.get(i</span><span class="s0">, </span><span class="s4">&quot;none&quot;</span><span class="s1">) == </span><span class="s4">&quot;none&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">ax</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(chunk_location</span><span class="s0">, </span><span class="s1">ax) </span><span class="s0">in </span><span class="s1">enumerate(</span>
            <span class="s1">zip(block_info[</span><span class="s3">0</span><span class="s1">][</span><span class="s4">&quot;chunk-location&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes_front)</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">trim_back = (</span>
        <span class="s0">None</span>
        <span class="s0">if </span><span class="s1">(chunk_location == chunks - </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">boundary.get(i</span><span class="s0">, </span><span class="s4">&quot;none&quot;</span><span class="s1">) == </span><span class="s4">&quot;none&quot;</span><span class="s1">)</span>
        <span class="s0">else </span><span class="s1">ax</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(chunks</span><span class="s0">, </span><span class="s1">chunk_location</span><span class="s0">, </span><span class="s1">ax) </span><span class="s0">in </span><span class="s1">enumerate(</span>
            <span class="s1">zip(block_info[</span><span class="s3">0</span><span class="s1">][</span><span class="s4">&quot;num-chunks&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">block_info[</span><span class="s3">0</span><span class="s1">][</span><span class="s4">&quot;chunk-location&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes_back)</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">ind = tuple(slice(front</span><span class="s0">, </span><span class="s1">back) </span><span class="s0">for </span><span class="s1">front</span><span class="s0">, </span><span class="s1">back </span><span class="s0">in </span><span class="s1">zip(trim_front</span><span class="s0">, </span><span class="s1">trim_back))</span>
    <span class="s0">return </span><span class="s1">x[ind]</span>


<span class="s0">def </span><span class="s1">periodic(x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">depth):</span>
    <span class="s2">&quot;&quot;&quot;Copy a slice of an array around to its other side 
 
    Useful to create periodic boundary conditions for overlap 
    &quot;&quot;&quot;</span>

    <span class="s1">left = (</span>
        <span class="s1">(slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis</span>
        <span class="s1">+ (slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">depth)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">+ (slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * (x.ndim - axis - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">right = (</span>
        <span class="s1">(slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis</span>
        <span class="s1">+ (slice(-depth</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">+ (slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * (x.ndim - axis - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">l = x[left]</span>
    <span class="s1">r = x[right]</span>

    <span class="s1">l</span><span class="s0">, </span><span class="s1">r = _remove_overlap_boundaries(l</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">depth)</span>

    <span class="s0">return </span><span class="s1">concatenate([r</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">l]</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s0">def </span><span class="s1">reflect(x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">depth):</span>
    <span class="s2">&quot;&quot;&quot;Reflect boundaries of array on the same side 
 
    This is the converse of ``periodic`` 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">depth == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">left = (</span>
            <span class="s1">(slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis</span>
            <span class="s1">+ (slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">+ (slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * (x.ndim - axis - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">left = (</span>
            <span class="s1">(slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis</span>
            <span class="s1">+ (slice(depth - </span><span class="s3">1</span><span class="s0">, None, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">+ (slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * (x.ndim - axis - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">right = (</span>
        <span class="s1">(slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis</span>
        <span class="s1">+ (slice(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-depth - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">+ (slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * (x.ndim - axis - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">l = x[left]</span>
    <span class="s1">r = x[right]</span>

    <span class="s1">l</span><span class="s0">, </span><span class="s1">r = _remove_overlap_boundaries(l</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">depth)</span>

    <span class="s0">return </span><span class="s1">concatenate([l</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">r]</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s0">def </span><span class="s1">nearest(x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">depth):</span>
    <span class="s2">&quot;&quot;&quot;Each reflect each boundary value outwards 
 
    This mimics what the skimage.filters.gaussian_filter(... mode=&quot;nearest&quot;) 
    does. 
    &quot;&quot;&quot;</span>
    <span class="s1">left = (</span>
        <span class="s1">(slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis</span>
        <span class="s1">+ (slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">+ (slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * (x.ndim - axis - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">right = (</span>
        <span class="s1">(slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis</span>
        <span class="s1">+ (slice(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">+ (slice(</span><span class="s0">None, None, None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * (x.ndim - axis - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s1">l = concatenate([x[left]] * depth</span><span class="s0">, </span><span class="s1">axis=axis)</span>
    <span class="s1">r = concatenate([x[right]] * depth</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s1">l</span><span class="s0">, </span><span class="s1">r = _remove_overlap_boundaries(l</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">depth)</span>

    <span class="s0">return </span><span class="s1">concatenate([l</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">r]</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s0">def </span><span class="s1">constant(x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">depth</span><span class="s0">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Add constant slice to either side of array&quot;&quot;&quot;</span>
    <span class="s1">chunks = list(x.chunks)</span>
    <span class="s1">chunks[axis] = (depth</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">c = full_like(</span>
        <span class="s1">x</span><span class="s0">,</span>
        <span class="s1">value</span><span class="s0">,</span>
        <span class="s1">shape=tuple(map(sum</span><span class="s0">, </span><span class="s1">chunks))</span><span class="s0">,</span>
        <span class="s1">chunks=tuple(chunks)</span><span class="s0">,</span>
        <span class="s1">dtype=x.dtype</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">concatenate([c</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">c]</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s0">def </span><span class="s1">_remove_overlap_boundaries(l</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">depth):</span>
    <span class="s1">lchunks = list(l.chunks)</span>
    <span class="s1">lchunks[axis] = (depth</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">rchunks = list(r.chunks)</span>
    <span class="s1">rchunks[axis] = (depth</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">l = l.rechunk(tuple(lchunks))</span>
    <span class="s1">r = r.rechunk(tuple(rchunks))</span>
    <span class="s0">return </span><span class="s1">l</span><span class="s0">, </span><span class="s1">r</span>


<span class="s0">def </span><span class="s1">boundaries(x</span><span class="s0">, </span><span class="s1">depth=</span><span class="s0">None, </span><span class="s1">kind=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Add boundary conditions to an array before overlaping 
 
    See Also 
    -------- 
    periodic 
    constant 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance(kind</span><span class="s0">, </span><span class="s1">dict):</span>
        <span class="s1">kind = {i: kind </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(x.ndim)}</span>
    <span class="s0">if not </span><span class="s1">isinstance(depth</span><span class="s0">, </span><span class="s1">dict):</span>
        <span class="s1">depth = {i: depth </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(x.ndim)}</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(x.ndim):</span>
        <span class="s1">d = depth.get(i</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">d == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">continue</span>

        <span class="s1">this_kind = kind.get(i</span><span class="s0">, </span><span class="s4">&quot;none&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">this_kind == </span><span class="s4">&quot;none&quot;</span><span class="s1">:</span>
            <span class="s0">continue</span>
        <span class="s0">elif </span><span class="s1">this_kind == </span><span class="s4">&quot;periodic&quot;</span><span class="s1">:</span>
            <span class="s1">x = periodic(x</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s0">elif </span><span class="s1">this_kind == </span><span class="s4">&quot;reflect&quot;</span><span class="s1">:</span>
            <span class="s1">x = reflect(x</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s0">elif </span><span class="s1">this_kind == </span><span class="s4">&quot;nearest&quot;</span><span class="s1">:</span>
            <span class="s1">x = nearest(x</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s0">elif </span><span class="s1">i </span><span class="s0">in </span><span class="s1">kind:</span>
            <span class="s1">x = constant(x</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">kind[i])</span>

    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">ensure_minimum_chunksize(size</span><span class="s0">, </span><span class="s1">chunks):</span>
    <span class="s2">&quot;&quot;&quot;Determine new chunks to ensure that every chunk &gt;= size 
 
    Parameters 
    ---------- 
    size: int 
        The maximum size of any chunk. 
    chunks: tuple 
        Chunks along one axis, e.g. ``(3, 3, 2)`` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; ensure_minimum_chunksize(10, (20, 20, 1)) 
    (20, 11, 10) 
    &gt;&gt;&gt; ensure_minimum_chunksize(3, (1, 1, 3)) 
    (5,) 
 
    See Also 
    -------- 
    overlap 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">size &lt;= min(chunks):</span>
        <span class="s0">return </span><span class="s1">chunks</span>

    <span class="s5"># add too-small chunks to chunks before them</span>
    <span class="s1">output = []</span>
    <span class="s1">new = </span><span class="s3">0</span>
    <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">chunks:</span>
        <span class="s0">if </span><span class="s1">c &lt; size:</span>
            <span class="s0">if </span><span class="s1">new &gt; size + (size - c):</span>
                <span class="s1">output.append(new - (size - c))</span>
                <span class="s1">new = size</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">new += c</span>
        <span class="s0">if </span><span class="s1">new &gt;= size:</span>
            <span class="s1">output.append(new)</span>
            <span class="s1">new = </span><span class="s3">0</span>
        <span class="s0">if </span><span class="s1">c &gt;= size:</span>
            <span class="s1">new += c</span>
    <span class="s0">if </span><span class="s1">new &gt;= size:</span>
        <span class="s1">output.append(new)</span>
    <span class="s0">elif </span><span class="s1">len(output) &gt;= </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">output[-</span><span class="s3">1</span><span class="s1">] += new</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">f&quot;The overlapping depth </span><span class="s0">{</span><span class="s1">size</span><span class="s0">} </span><span class="s4">is larger than your &quot; f&quot;array </span><span class="s0">{</span><span class="s1">sum(chunks)</span><span class="s0">}</span><span class="s4">.&quot;</span>
        <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">tuple(output)</span>


<span class="s0">def </span><span class="s1">overlap(x</span><span class="s0">, </span><span class="s1">depth</span><span class="s0">, </span><span class="s1">boundary</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">allow_rechunk=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Share boundaries between neighboring blocks 
 
    Parameters 
    ---------- 
 
    x: da.Array 
        A dask array 
    depth: dict 
        The size of the shared boundary per axis 
    boundary: dict 
        The boundary condition on each axis. Options are 'reflect', 'periodic', 
        'nearest', 'none', or an array value.  Such a value will fill the 
        boundary with that value. 
    allow_rechunk: bool, keyword only 
        Allows rechunking, otherwise chunk sizes need to match and core 
        dimensions are to consist only of one chunk. 
 
    The depth input informs how many cells to overlap between neighboring 
    blocks ``{0: 2, 2: 5}`` means share two cells in 0 axis, 5 cells in 2 axis. 
    Axes missing from this input will not be overlapped. 
 
    Any axis containing chunks smaller than depth will be rechunked if 
    possible, provided the keyword ``allow_rechunk`` is True (recommended). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import dask.array as da 
 
    &gt;&gt;&gt; x = np.arange(64).reshape((8, 8)) 
    &gt;&gt;&gt; d = da.from_array(x, chunks=(4, 4)) 
    &gt;&gt;&gt; d.chunks 
    ((4, 4), (4, 4)) 
 
    &gt;&gt;&gt; g = da.overlap.overlap(d, depth={0: 2, 1: 1}, 
    ...                       boundary={0: 100, 1: 'reflect'}) 
    &gt;&gt;&gt; g.chunks 
    ((8, 8), (6, 6)) 
 
    &gt;&gt;&gt; np.array(g) 
    array([[100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], 
           [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], 
           [  0,   0,   1,   2,   3,   4,   3,   4,   5,   6,   7,   7], 
           [  8,   8,   9,  10,  11,  12,  11,  12,  13,  14,  15,  15], 
           [ 16,  16,  17,  18,  19,  20,  19,  20,  21,  22,  23,  23], 
           [ 24,  24,  25,  26,  27,  28,  27,  28,  29,  30,  31,  31], 
           [ 32,  32,  33,  34,  35,  36,  35,  36,  37,  38,  39,  39], 
           [ 40,  40,  41,  42,  43,  44,  43,  44,  45,  46,  47,  47], 
           [ 16,  16,  17,  18,  19,  20,  19,  20,  21,  22,  23,  23], 
           [ 24,  24,  25,  26,  27,  28,  27,  28,  29,  30,  31,  31], 
           [ 32,  32,  33,  34,  35,  36,  35,  36,  37,  38,  39,  39], 
           [ 40,  40,  41,  42,  43,  44,  43,  44,  45,  46,  47,  47], 
           [ 48,  48,  49,  50,  51,  52,  51,  52,  53,  54,  55,  55], 
           [ 56,  56,  57,  58,  59,  60,  59,  60,  61,  62,  63,  63], 
           [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], 
           [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">depth2 = coerce_depth(x.ndim</span><span class="s0">, </span><span class="s1">depth)</span>
    <span class="s1">boundary2 = coerce_boundary(x.ndim</span><span class="s0">, </span><span class="s1">boundary)</span>

    <span class="s1">depths = [max(d) </span><span class="s0">if </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">else </span><span class="s1">d </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">depth2.values()]</span>
    <span class="s0">if </span><span class="s1">allow_rechunk:</span>
        <span class="s5"># rechunk if new chunks are needed to fit depth in every chunk</span>
        <span class="s1">new_chunks = tuple(</span>
            <span class="s1">ensure_minimum_chunksize(size</span><span class="s0">, </span><span class="s1">c) </span><span class="s0">for </span><span class="s1">size</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(depths</span><span class="s0">, </span><span class="s1">x.chunks)</span>
        <span class="s1">)</span>
        <span class="s1">x1 = x.rechunk(new_chunks)  </span><span class="s5"># this is a no-op if x.chunks == new_chunks</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">original_chunks_too_small = any([min(c) &lt; d </span><span class="s0">for </span><span class="s1">d</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(depths</span><span class="s0">, </span><span class="s1">x.chunks)])</span>
        <span class="s0">if </span><span class="s1">original_chunks_too_small:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Overlap depth is larger than smallest chunksize.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;Please set allow_rechunk=True to rechunk automatically.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;Overlap depths required: </span><span class="s0">{</span><span class="s1">depths</span><span class="s0">}\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;Input chunks: </span><span class="s0">{</span><span class="s1">x.chunks</span><span class="s0">}\n</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
        <span class="s1">x1 = x</span>

    <span class="s1">x2 = boundaries(x1</span><span class="s0">, </span><span class="s1">depth2</span><span class="s0">, </span><span class="s1">boundary2)</span>
    <span class="s1">x3 = overlap_internal(x2</span><span class="s0">, </span><span class="s1">depth2)</span>
    <span class="s1">trim = {</span>
        <span class="s1">k: v * </span><span class="s3">2 </span><span class="s0">if </span><span class="s1">boundary2.get(k</span><span class="s0">, </span><span class="s4">&quot;none&quot;</span><span class="s1">) != </span><span class="s4">&quot;none&quot; </span><span class="s0">else </span><span class="s3">0 </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">depth2.items()</span>
    <span class="s1">}</span>
    <span class="s1">x4 = chunk.trim(x3</span><span class="s0">, </span><span class="s1">trim)</span>
    <span class="s0">return </span><span class="s1">x4</span>


<span class="s0">def </span><span class="s1">add_dummy_padding(x</span><span class="s0">, </span><span class="s1">depth</span><span class="s0">, </span><span class="s1">boundary):</span>
    <span class="s2">&quot;&quot;&quot; 
    Pads an array which has 'none' as the boundary type. 
    Used to simplify trimming arrays which use 'none'. 
 
    &gt;&gt;&gt; import dask.array as da 
    &gt;&gt;&gt; x = da.arange(6, chunks=3) 
    &gt;&gt;&gt; add_dummy_padding(x, {0: 1}, {0: 'none'}).compute()  # doctest: +NORMALIZE_WHITESPACE 
    array([..., 0, 1, 2, 3, 4, 5, ...]) 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">boundary.items():</span>
        <span class="s1">d = depth.get(k</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">v == </span><span class="s4">&quot;none&quot; </span><span class="s0">and </span><span class="s1">d &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">empty_shape = list(x.shape)</span>
            <span class="s1">empty_shape[k] = d</span>

            <span class="s1">empty_chunks = list(x.chunks)</span>
            <span class="s1">empty_chunks[k] = (d</span><span class="s0">,</span><span class="s1">)</span>

            <span class="s1">empty = empty_like(</span>
                <span class="s1">getattr(x</span><span class="s0">, </span><span class="s4">&quot;_meta&quot;</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">,</span>
                <span class="s1">shape=empty_shape</span><span class="s0">,</span>
                <span class="s1">chunks=empty_chunks</span><span class="s0">,</span>
                <span class="s1">dtype=x.dtype</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">out_chunks = list(x.chunks)</span>
            <span class="s1">ax_chunks = list(out_chunks[k])</span>
            <span class="s1">ax_chunks[</span><span class="s3">0</span><span class="s1">] += d</span>
            <span class="s1">ax_chunks[-</span><span class="s3">1</span><span class="s1">] += d</span>
            <span class="s1">out_chunks[k] = tuple(ax_chunks)</span>

            <span class="s1">x = concatenate([empty</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">empty]</span><span class="s0">, </span><span class="s1">axis=k)</span>
            <span class="s1">x = x.rechunk(out_chunks)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">map_overlap(</span>
    <span class="s1">func</span><span class="s0">,</span>
    <span class="s1">*args</span><span class="s0">,</span>
    <span class="s1">depth=</span><span class="s0">None,</span>
    <span class="s1">boundary=</span><span class="s0">None,</span>
    <span class="s1">trim=</span><span class="s0">True,</span>
    <span class="s1">align_arrays=</span><span class="s0">True,</span>
    <span class="s1">allow_rechunk=</span><span class="s0">True,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Map a function over blocks of arrays with some overlap 
 
    We share neighboring zones between blocks of the array, map a 
    function, and then trim away the neighboring strips. If depth is 
    larger than any chunk along a particular axis, then the array is 
    rechunked. 
 
    Note that this function will attempt to automatically determine the output 
    array type before computing it, please refer to the ``meta`` keyword argument 
    in ``map_blocks`` if you expect that the function will not succeed when 
    operating on 0-d arrays. 
 
    Parameters 
    ---------- 
    func: function 
        The function to apply to each extended block. 
        If multiple arrays are provided, then the function should expect to 
        receive chunks of each array in the same order. 
    args : dask arrays 
    depth: int, tuple, dict or list, keyword only 
        The number of elements that each block should share with its neighbors 
        If a tuple or dict then this can be different per axis. 
        If a list then each element of that list must be an int, tuple or dict 
        defining depth for the corresponding array in `args`. 
        Asymmetric depths may be specified using a dict value of (-/+) tuples. 
        Note that asymmetric depths are currently only supported when 
        ``boundary`` is 'none'. 
        The default value is 0. 
    boundary: str, tuple, dict or list, keyword only 
        How to handle the boundaries. 
        Values include 'reflect', 'periodic', 'nearest', 'none', 
        or any constant value like 0 or np.nan. 
        If a list then each element must be a str, tuple or dict defining the 
        boundary for the corresponding array in `args`. 
        The default value is 'reflect'. 
    trim: bool, keyword only 
        Whether or not to trim ``depth`` elements from each block after 
        calling the map function. 
        Set this to False if your mapping function already does this for you 
    align_arrays: bool, keyword only 
        Whether or not to align chunks along equally sized dimensions when 
        multiple arrays are provided.  This allows for larger chunks in some 
        arrays to be broken into smaller ones that match chunk sizes in other 
        arrays such that they are compatible for block function mapping. If 
        this is false, then an error will be thrown if arrays do not already 
        have the same number of blocks in each dimension. 
    allow_rechunk: bool, keyword only 
        Allows rechunking, otherwise chunk sizes need to match and core 
        dimensions are to consist only of one chunk. 
    **kwargs: 
        Other keyword arguments valid in ``map_blocks`` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import dask.array as da 
 
    &gt;&gt;&gt; x = np.array([1, 1, 2, 3, 3, 3, 2, 1, 1]) 
    &gt;&gt;&gt; x = da.from_array(x, chunks=5) 
    &gt;&gt;&gt; def derivative(x): 
    ...     return x - np.roll(x, 1) 
 
    &gt;&gt;&gt; y = x.map_overlap(derivative, depth=1, boundary=0) 
    &gt;&gt;&gt; y.compute() 
    array([ 1,  0,  1,  1,  0,  0, -1, -1,  0]) 
 
    &gt;&gt;&gt; x = np.arange(16).reshape((4, 4)) 
    &gt;&gt;&gt; d = da.from_array(x, chunks=(2, 2)) 
    &gt;&gt;&gt; d.map_overlap(lambda x: x + x.size, depth=1, boundary='reflect').compute() 
    array([[16, 17, 18, 19], 
           [20, 21, 22, 23], 
           [24, 25, 26, 27], 
           [28, 29, 30, 31]]) 
 
    &gt;&gt;&gt; func = lambda x: x + x.size 
    &gt;&gt;&gt; depth = {0: 1, 1: 1} 
    &gt;&gt;&gt; boundary = {0: 'reflect', 1: 'none'} 
    &gt;&gt;&gt; d.map_overlap(func, depth, boundary).compute()  # doctest: +NORMALIZE_WHITESPACE 
    array([[12,  13,  14,  15], 
           [16,  17,  18,  19], 
           [20,  21,  22,  23], 
           [24,  25,  26,  27]]) 
 
    The ``da.map_overlap`` function can also accept multiple arrays. 
 
    &gt;&gt;&gt; func = lambda x, y: x + y 
    &gt;&gt;&gt; x = da.arange(8).reshape(2, 4).rechunk((1, 2)) 
    &gt;&gt;&gt; y = da.arange(4).rechunk(2) 
    &gt;&gt;&gt; da.map_overlap(func, x, y, depth=1, boundary='reflect').compute() # doctest: +NORMALIZE_WHITESPACE 
    array([[ 0,  2,  4,  6], 
           [ 4,  6,  8,  10]]) 
 
    When multiple arrays are given, they do not need to have the 
    same number of dimensions but they must broadcast together. 
    Arrays are aligned block by block (just as in ``da.map_blocks``) 
    so the blocks must have a common chunk size.  This common chunking 
    is determined automatically as long as ``align_arrays`` is True. 
 
    &gt;&gt;&gt; x = da.arange(8, chunks=4) 
    &gt;&gt;&gt; y = da.arange(8, chunks=2) 
    &gt;&gt;&gt; r = da.map_overlap(func, x, y, depth=1, boundary='reflect', align_arrays=True) 
    &gt;&gt;&gt; len(r.to_delayed()) 
    4 
 
    &gt;&gt;&gt; da.map_overlap(func, x, y, depth=1, boundary='reflect', align_arrays=False).compute() 
    Traceback (most recent call last): 
        ... 
    ValueError: Shapes do not align {'.0': {2, 4}} 
 
    Note also that this function is equivalent to ``map_blocks`` 
    by default.  A non-zero ``depth`` must be defined for any 
    overlap to appear in the arrays provided to ``func``. 
 
    &gt;&gt;&gt; func = lambda x: x.sum() 
    &gt;&gt;&gt; x = da.ones(10, dtype='int') 
    &gt;&gt;&gt; block_args = dict(chunks=(), drop_axis=0) 
    &gt;&gt;&gt; da.map_blocks(func, x, **block_args).compute() 
    10 
    &gt;&gt;&gt; da.map_overlap(func, x, **block_args, boundary='reflect').compute() 
    10 
    &gt;&gt;&gt; da.map_overlap(func, x, **block_args, depth=1, boundary='reflect').compute() 
    12 
 
    For functions that may not handle 0-d arrays, it's also possible to specify 
    ``meta`` with an empty array matching the type of the expected result. In 
    the example below, ``func`` will result in an ``IndexError`` when computing 
    ``meta``: 
 
    &gt;&gt;&gt; x = np.arange(16).reshape((4, 4)) 
    &gt;&gt;&gt; d = da.from_array(x, chunks=(2, 2)) 
    &gt;&gt;&gt; y = d.map_overlap(lambda x: x + x[2], depth=1, boundary='reflect', meta=np.array(())) 
    &gt;&gt;&gt; y 
    dask.array&lt;_trim, shape=(4, 4), dtype=float64, chunksize=(2, 2), chunktype=numpy.ndarray&gt; 
    &gt;&gt;&gt; y.compute() 
    array([[ 4,  6,  8, 10], 
           [ 8, 10, 12, 14], 
           [20, 22, 24, 26], 
           [24, 26, 28, 30]]) 
 
    Similarly, it's possible to specify a non-NumPy array to ``meta``: 
 
    &gt;&gt;&gt; import cupy  # doctest: +SKIP 
    &gt;&gt;&gt; x = cupy.arange(16).reshape((4, 4))  # doctest: +SKIP 
    &gt;&gt;&gt; d = da.from_array(x, chunks=(2, 2))  # doctest: +SKIP 
    &gt;&gt;&gt; y = d.map_overlap(lambda x: x + x[2], depth=1, boundary='reflect', meta=cupy.array(()))  # doctest: +SKIP 
    &gt;&gt;&gt; y  # doctest: +SKIP 
    dask.array&lt;_trim, shape=(4, 4), dtype=float64, chunksize=(2, 2), chunktype=cupy.ndarray&gt; 
    &gt;&gt;&gt; y.compute()  # doctest: +SKIP 
    array([[ 4,  6,  8, 10], 
           [ 8, 10, 12, 14], 
           [20, 22, 24, 26], 
           [24, 26, 28, 30]]) 
    &quot;&quot;&quot;</span>
    <span class="s5"># Look for invocation using deprecated single-array signature</span>
    <span class="s5"># map_overlap(x, func, depth, boundary=None, trim=True, **kwargs)</span>
    <span class="s0">if </span><span class="s1">isinstance(func</span><span class="s0">, </span><span class="s1">Array) </span><span class="s0">and </span><span class="s1">callable(args[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;The use of map_overlap(array, func, **kwargs) is deprecated since dask 2.17.0 &quot;</span>
            <span class="s4">&quot;and will be an error in a future release. To silence this warning, use the syntax &quot;</span>
            <span class="s4">&quot;map_overlap(func, array0,[ array1, ...,] **kwargs) instead.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">sig = [</span><span class="s4">&quot;func&quot;</span><span class="s0">, </span><span class="s4">&quot;depth&quot;</span><span class="s0">, </span><span class="s4">&quot;boundary&quot;</span><span class="s0">, </span><span class="s4">&quot;trim&quot;</span><span class="s1">]</span>
        <span class="s1">depth = get(sig.index(</span><span class="s4">&quot;depth&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">depth)</span>
        <span class="s1">boundary = get(sig.index(</span><span class="s4">&quot;boundary&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">boundary)</span>
        <span class="s1">trim = get(sig.index(</span><span class="s4">&quot;trim&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">trim)</span>
        <span class="s1">func</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[func]</span>

    <span class="s0">if not </span><span class="s1">callable(func):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s4">&quot;First argument must be callable function, not {}</span><span class="s0">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;Usage:   da.map_overlap(function, x)</span><span class="s0">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;   or:   da.map_overlap(function, x, y, z)&quot;</span><span class="s1">.format(type(func).__name__)</span>
        <span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">all(isinstance(x</span><span class="s0">, </span><span class="s1">Array) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s4">&quot;All variadic arguments must be arrays, not {}</span><span class="s0">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;Usage:   da.map_overlap(function, x)</span><span class="s0">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;   or:   da.map_overlap(function, x, y, z)&quot;</span><span class="s1">.format(</span>
                <span class="s1">[type(x).__name__ </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args]</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s5"># Coerce depth and boundary arguments to lists of individual</span>
    <span class="s5"># specifications for each array argument</span>
    <span class="s0">def </span><span class="s1">coerce(xs</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">fn):</span>
        <span class="s0">if not </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">arg = [arg] * len(xs)</span>
        <span class="s0">return </span><span class="s1">[fn(x.ndim</span><span class="s0">, </span><span class="s1">a) </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">a </span><span class="s0">in </span><span class="s1">zip(xs</span><span class="s0">, </span><span class="s1">arg)]</span>

    <span class="s1">depth = coerce(args</span><span class="s0">, </span><span class="s1">depth</span><span class="s0">, </span><span class="s1">coerce_depth)</span>
    <span class="s1">boundary = coerce(args</span><span class="s0">, </span><span class="s1">boundary</span><span class="s0">, </span><span class="s1">coerce_boundary)</span>

    <span class="s5"># Align chunks in each array to a common size</span>
    <span class="s0">if </span><span class="s1">align_arrays:</span>
        <span class="s5"># Reverse unification order to allow block broadcasting</span>
        <span class="s1">inds = [list(reversed(range(x.ndim))) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args]</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">args = unify_chunks(*list(concat(zip(args</span><span class="s0">, </span><span class="s1">inds)))</span><span class="s0">, </span><span class="s1">warn=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s5"># Escape to map_blocks if depth is zero (a more efficient computation)</span>
    <span class="s0">if </span><span class="s1">all([all(depth_val == </span><span class="s3">0 </span><span class="s0">for </span><span class="s1">depth_val </span><span class="s0">in </span><span class="s1">d.values()) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">depth]):</span>
        <span class="s0">return </span><span class="s1">map_blocks(func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate(args):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(x.ndim):</span>
            <span class="s0">if </span><span class="s1">isinstance(depth[i][j]</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">boundary[i][j] != </span><span class="s4">&quot;none&quot;</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s4">&quot;Asymmetric overlap is currently only implemented &quot;</span>
                    <span class="s4">&quot;for boundary='none', however boundary for dimension &quot;</span>
                    <span class="s4">&quot;{} in array argument {} is {}&quot;</span><span class="s1">.format(j</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">boundary[i][j])</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">assert_int_chunksize(xs):</span>
        <span class="s0">assert </span><span class="s1">all(type(c) </span><span class="s0">is </span><span class="s1">int </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">xs </span><span class="s0">for </span><span class="s1">cc </span><span class="s0">in </span><span class="s1">x.chunks </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">cc)</span>

    <span class="s1">assert_int_chunksize(args)</span>
    <span class="s0">if not </span><span class="s1">trim </span><span class="s0">and </span><span class="s4">&quot;chunks&quot; </span><span class="s0">not in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs[</span><span class="s4">&quot;chunks&quot;</span><span class="s1">] = args[</span><span class="s3">0</span><span class="s1">].chunks</span>
    <span class="s1">args = [</span>
        <span class="s1">overlap(x</span><span class="s0">, </span><span class="s1">depth=d</span><span class="s0">, </span><span class="s1">boundary=b</span><span class="s0">, </span><span class="s1">allow_rechunk=allow_rechunk)</span>
        <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">zip(args</span><span class="s0">, </span><span class="s1">depth</span><span class="s0">, </span><span class="s1">boundary)</span>
    <span class="s1">]</span>
    <span class="s1">assert_int_chunksize(args)</span>
    <span class="s1">x = map_blocks(func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">assert_int_chunksize([x])</span>
    <span class="s0">if </span><span class="s1">trim:</span>
        <span class="s5"># Find index of array argument with maximum rank and break ties by choosing first provided</span>
        <span class="s1">i = sorted(enumerate(args)</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">v: (v[</span><span class="s3">1</span><span class="s1">].ndim</span><span class="s0">, </span><span class="s1">-v[</span><span class="s3">0</span><span class="s1">]))[-</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s5"># Trim using depth/boundary setting for array of highest rank</span>
        <span class="s1">depth = depth[i]</span>
        <span class="s1">boundary = boundary[i]</span>
        <span class="s5"># remove any dropped axes from depth and boundary variables</span>
        <span class="s1">drop_axis = kwargs.pop(</span><span class="s4">&quot;drop_axis&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">drop_axis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(drop_axis</span><span class="s0">, </span><span class="s1">Number):</span>
                <span class="s1">drop_axis = [drop_axis]</span>

            <span class="s5"># convert negative drop_axis to equivalent positive value</span>
            <span class="s1">ndim_out = max(a.ndim </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args </span><span class="s0">if </span><span class="s1">isinstance(a</span><span class="s0">, </span><span class="s1">Array))</span>
            <span class="s1">drop_axis = [d % ndim_out </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">drop_axis]</span>

            <span class="s1">kept_axes = tuple(ax </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(args[i].ndim) </span><span class="s0">if </span><span class="s1">ax </span><span class="s0">not in </span><span class="s1">drop_axis)</span>
            <span class="s5"># note that keys are relabeled to match values in range(x.ndim)</span>
            <span class="s1">depth = {n: depth[ax] </span><span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(kept_axes)}</span>
            <span class="s1">boundary = {n: boundary[ax] </span><span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(kept_axes)}</span>
        <span class="s0">return </span><span class="s1">trim_internal(x</span><span class="s0">, </span><span class="s1">depth</span><span class="s0">, </span><span class="s1">boundary)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">coerce_depth(ndim</span><span class="s0">, </span><span class="s1">depth):</span>
    <span class="s1">default = </span><span class="s3">0</span>
    <span class="s0">if </span><span class="s1">depth </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">depth = default</span>
    <span class="s0">if </span><span class="s1">isinstance(depth</span><span class="s0">, </span><span class="s1">Integral):</span>
        <span class="s1">depth = (depth</span><span class="s0">,</span><span class="s1">) * ndim</span>
    <span class="s0">if </span><span class="s1">isinstance(depth</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">depth = dict(zip(range(ndim)</span><span class="s0">, </span><span class="s1">depth))</span>
    <span class="s0">if </span><span class="s1">isinstance(depth</span><span class="s0">, </span><span class="s1">dict):</span>
        <span class="s1">depth = {ax: depth.get(ax</span><span class="s0">, </span><span class="s1">default) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(ndim)}</span>
    <span class="s0">return </span><span class="s1">coerce_depth_type(ndim</span><span class="s0">, </span><span class="s1">depth)</span>


<span class="s0">def </span><span class="s1">coerce_depth_type(ndim</span><span class="s0">, </span><span class="s1">depth):</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(ndim):</span>
        <span class="s0">if </span><span class="s1">isinstance(depth[i]</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">depth[i] = tuple(int(d) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">depth[i])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">depth[i] = int(depth[i])</span>
    <span class="s0">return </span><span class="s1">depth</span>


<span class="s0">def </span><span class="s1">coerce_boundary(ndim</span><span class="s0">, </span><span class="s1">boundary):</span>
    <span class="s1">default = </span><span class="s4">&quot;none&quot;</span>
    <span class="s0">if </span><span class="s1">boundary </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">boundary = default</span>
    <span class="s0">if not </span><span class="s1">isinstance(boundary</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">dict)):</span>
        <span class="s1">boundary = (boundary</span><span class="s0">,</span><span class="s1">) * ndim</span>
    <span class="s0">if </span><span class="s1">isinstance(boundary</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">boundary = dict(zip(range(ndim)</span><span class="s0">, </span><span class="s1">boundary))</span>
    <span class="s0">if </span><span class="s1">isinstance(boundary</span><span class="s0">, </span><span class="s1">dict):</span>
        <span class="s1">boundary = {ax: boundary.get(ax</span><span class="s0">, </span><span class="s1">default) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(ndim)}</span>
    <span class="s0">return </span><span class="s1">boundary</span>


<span class="s1">@derived_from(np.lib.stride_tricks)</span>
<span class="s0">def </span><span class="s1">sliding_window_view(x</span><span class="s0">, </span><span class="s1">window_shape</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">window_shape = tuple(window_shape) </span><span class="s0">if </span><span class="s1">np.iterable(window_shape) </span><span class="s0">else </span><span class="s1">(window_shape</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">window_shape_array = np.array(window_shape)</span>
    <span class="s0">if </span><span class="s1">np.any(window_shape_array &lt;= </span><span class="s3">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`window_shape` must contain values &gt; 0&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">axis = tuple(range(x.ndim))</span>
        <span class="s0">if </span><span class="s1">len(window_shape) != len(axis):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Since axis is `None`, must provide &quot;</span>
                <span class="s4">f&quot;window_shape for all dimensions of `x`; &quot;</span>
                <span class="s4">f&quot;got </span><span class="s0">{</span><span class="s1">len(window_shape)</span><span class="s0">} </span><span class="s4">window_shape elements &quot;</span>
                <span class="s4">f&quot;and `x.ndim` is </span><span class="s0">{</span><span class="s1">x.ndim</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">axis = normalize_axis_tuple(axis</span><span class="s0">, </span><span class="s1">x.ndim</span><span class="s0">, </span><span class="s1">allow_duplicate=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(window_shape) != len(axis):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Must provide matching length window_shape and &quot;</span>
                <span class="s4">f&quot;axis; got </span><span class="s0">{</span><span class="s1">len(window_shape)</span><span class="s0">} </span><span class="s4">window_shape &quot;</span>
                <span class="s4">f&quot;elements and </span><span class="s0">{</span><span class="s1">len(axis)</span><span class="s0">} </span><span class="s4">axes elements.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">depths = [</span><span class="s3">0</span><span class="s1">] * x.ndim</span>
    <span class="s0">for </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">window </span><span class="s0">in </span><span class="s1">zip(axis</span><span class="s0">, </span><span class="s1">window_shape):</span>
        <span class="s1">depths[ax] += window - </span><span class="s3">1</span>

    <span class="s5"># Ensure that each chunk is big enough to leave at least a size-1 chunk</span>
    <span class="s5"># after windowing (this is only really necessary for the last chunk).</span>
    <span class="s1">safe_chunks = tuple(</span>
        <span class="s1">ensure_minimum_chunksize(d + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">c) </span><span class="s0">for </span><span class="s1">d</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(depths</span><span class="s0">, </span><span class="s1">x.chunks)</span>
    <span class="s1">)</span>
    <span class="s1">x = x.rechunk(safe_chunks)</span>

    <span class="s5"># result.shape = x_shape_trimmed + window_shape,</span>
    <span class="s5"># where x_shape_trimmed is x.shape with every entry</span>
    <span class="s5"># reduced by one less than the corresponding window size.</span>
    <span class="s5"># trim chunks to match x_shape_trimmed</span>
    <span class="s1">newchunks = tuple(c[:-</span><span class="s3">1</span><span class="s1">] + (c[-</span><span class="s3">1</span><span class="s1">] - d</span><span class="s0">,</span><span class="s1">) </span><span class="s0">for </span><span class="s1">d</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(depths</span><span class="s0">, </span><span class="s1">x.chunks)) + tuple(</span>
        <span class="s1">(window</span><span class="s0">,</span><span class="s1">) </span><span class="s0">for </span><span class="s1">window </span><span class="s0">in </span><span class="s1">window_shape</span>
    <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">map_overlap(</span>
        <span class="s1">np.lib.stride_tricks.sliding_window_view</span><span class="s0">,</span>
        <span class="s1">x</span><span class="s0">,</span>
        <span class="s1">depth=tuple((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">d) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">depths)</span><span class="s0">,  </span><span class="s5"># Overlap on +ve side only</span>
        <span class="s1">boundary=</span><span class="s4">&quot;none&quot;</span><span class="s0">,</span>
        <span class="s1">meta=x._meta</span><span class="s0">,</span>
        <span class="s1">new_axis=range(x.ndim</span><span class="s0">, </span><span class="s1">x.ndim + len(axis))</span><span class="s0">,</span>
        <span class="s1">chunks=newchunks</span><span class="s0">,</span>
        <span class="s1">trim=</span><span class="s0">False,</span>
        <span class="s1">align_arrays=</span><span class="s0">False,</span>
        <span class="s1">window_shape=window_shape</span><span class="s0">,</span>
        <span class="s1">axis=axis</span><span class="s0">,</span>
    <span class="s1">)</span>
</pre>
</body>
</html>