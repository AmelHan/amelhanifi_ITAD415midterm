<html>
<head>
<title>test_cdflib.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_cdflib.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test cdflib functions versus mpmath, if available. 
 
The following functions still need tests: 
 
- ncfdtr 
- ncfdtri 
- ncfdtridfn 
- ncfdtridfd 
- ncfdtrinc 
- nbdtrik 
- nbdtrin 
- nrdtrimn 
- nrdtrisd 
- pdtrik 
- nctdtr 
- nctdtrit 
- nctdtridf 
- nctdtrinc 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">itertools</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">import </span><span class="s1">scipy.special </span><span class="s2">as </span><span class="s1">sp</span>
<span class="s2">from </span><span class="s1">scipy.special._testutils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">MissingModule</span><span class="s2">, </span><span class="s1">check_version</span><span class="s2">, </span><span class="s1">FuncData)</span>
<span class="s2">from </span><span class="s1">scipy.special._mptestutils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Arg</span><span class="s2">, </span><span class="s1">IntArg</span><span class="s2">, </span><span class="s1">get_args</span><span class="s2">, </span><span class="s1">mpf2float</span><span class="s2">, </span><span class="s1">assert_mpmath_equal)</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">mpmath</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">mpmath = MissingModule(</span><span class="s3">'mpmath'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">ProbArg:</span>
    <span class="s0">&quot;&quot;&quot;Generate a set of probabilities on [0, 1].&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s4"># Include the endpoints for compatibility with Arg et. al.</span>
        <span class="s1">self.a = </span><span class="s5">0</span>
        <span class="s1">self.b = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">values(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s0">&quot;&quot;&quot;Return an array containing approximatively n numbers.&quot;&quot;&quot;</span>
        <span class="s1">m = max(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">n//</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">v1 = np.logspace(-</span><span class="s5">30</span><span class="s2">, </span><span class="s1">np.log10(</span><span class="s5">0.3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">v2 = np.linspace(</span><span class="s5">0.3</span><span class="s2">, </span><span class="s5">0.7</span><span class="s2">, </span><span class="s1">m + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">endpoint=</span><span class="s2">False</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">v3 = </span><span class="s5">1 </span><span class="s1">- np.logspace(np.log10(</span><span class="s5">0.3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s5">15</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s1">v = np.r_[v1</span><span class="s2">, </span><span class="s1">v2</span><span class="s2">, </span><span class="s1">v3]</span>
        <span class="s2">return </span><span class="s1">np.unique(v)</span>


<span class="s2">class </span><span class="s1">EndpointFilter:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol):</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.b = b</span>
        <span class="s1">self.rtol = rtol</span>
        <span class="s1">self.atol = atol</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">mask1 = np.abs(x - self.a) &lt; self.rtol*np.abs(self.a) + self.atol</span>
        <span class="s1">mask2 = np.abs(x - self.b) &lt; self.rtol*np.abs(self.b) + self.atol</span>
        <span class="s2">return </span><span class="s1">np.where(mask1 | mask2</span><span class="s2">, False, True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">_CDFData:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">spfunc</span><span class="s2">, </span><span class="s1">mpfunc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">argspec</span><span class="s2">, </span><span class="s1">spfunc_first=</span><span class="s2">True,</span>
                 <span class="s1">dps=</span><span class="s5">20</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">5000</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s2">None, </span><span class="s1">atol=</span><span class="s2">None,</span>
                 <span class="s1">endpt_rtol=</span><span class="s2">None, </span><span class="s1">endpt_atol=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.spfunc = spfunc</span>
        <span class="s1">self.mpfunc = mpfunc</span>
        <span class="s1">self.index = index</span>
        <span class="s1">self.argspec = argspec</span>
        <span class="s1">self.spfunc_first = spfunc_first</span>
        <span class="s1">self.dps = dps</span>
        <span class="s1">self.n = n</span>
        <span class="s1">self.rtol = rtol</span>
        <span class="s1">self.atol = atol</span>

        <span class="s2">if not </span><span class="s1">isinstance(argspec</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">self.endpt_rtol = </span><span class="s2">None</span>
            <span class="s1">self.endpt_atol = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">endpt_rtol </span><span class="s2">is not None or </span><span class="s1">endpt_atol </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(endpt_rtol</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s1">self.endpt_rtol = endpt_rtol</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.endpt_rtol = [endpt_rtol]*len(self.argspec)</span>
            <span class="s2">if </span><span class="s1">isinstance(endpt_atol</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s1">self.endpt_atol = endpt_atol</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.endpt_atol = [endpt_atol]*len(self.argspec)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.endpt_rtol = </span><span class="s2">None</span>
            <span class="s1">self.endpt_atol = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">idmap(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">if </span><span class="s1">self.spfunc_first:</span>
            <span class="s1">res = self.spfunc(*args)</span>
            <span class="s2">if </span><span class="s1">np.isnan(res):</span>
                <span class="s2">return </span><span class="s1">np.nan</span>
            <span class="s1">args = list(args)</span>
            <span class="s1">args[self.index] = res</span>
            <span class="s2">with </span><span class="s1">mpmath.workdps(self.dps):</span>
                <span class="s1">res = self.mpfunc(*tuple(args))</span>
                <span class="s4"># Imaginary parts are spurious</span>
                <span class="s1">res = mpf2float(res.real)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">mpmath.workdps(self.dps):</span>
                <span class="s1">res = self.mpfunc(*args)</span>
                <span class="s1">res = mpf2float(res.real)</span>
            <span class="s1">args = list(args)</span>
            <span class="s1">args[self.index] = res</span>
            <span class="s1">res = self.spfunc(*tuple(args))</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">get_param_filter(self):</span>
        <span class="s2">if </span><span class="s1">self.endpt_rtol </span><span class="s2">is None and </span><span class="s1">self.endpt_atol </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s1">filters = []</span>
        <span class="s2">for </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">zip(self.endpt_rtol</span><span class="s2">, </span><span class="s1">self.endpt_atol</span><span class="s2">, </span><span class="s1">self.argspec):</span>
            <span class="s2">if </span><span class="s1">rtol </span><span class="s2">is None and </span><span class="s1">atol </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">filters.append(</span><span class="s2">None</span><span class="s1">)</span>
                <span class="s2">continue</span>
            <span class="s2">elif </span><span class="s1">rtol </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">rtol = </span><span class="s5">0.0</span>
            <span class="s2">elif </span><span class="s1">atol </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">atol = </span><span class="s5">0.0</span>

            <span class="s1">filters.append(EndpointFilter(spec.a</span><span class="s2">, </span><span class="s1">spec.b</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol))</span>
        <span class="s2">return </span><span class="s1">filters</span>

    <span class="s2">def </span><span class="s1">check(self):</span>
        <span class="s4"># Generate values for the arguments</span>
        <span class="s1">args = get_args(self.argspec</span><span class="s2">, </span><span class="s1">self.n)</span>
        <span class="s1">param_filter = self.get_param_filter()</span>
        <span class="s1">param_columns = tuple(range(args.shape[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">result_columns = args.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">args = np.hstack((args</span><span class="s2">, </span><span class="s1">args[:</span><span class="s2">,</span><span class="s1">self.index].reshape(args.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s1">FuncData(self.idmap</span><span class="s2">, </span><span class="s1">args</span><span class="s2">,</span>
                 <span class="s1">param_columns=param_columns</span><span class="s2">, </span><span class="s1">result_columns=result_columns</span><span class="s2">,</span>
                 <span class="s1">rtol=self.rtol</span><span class="s2">, </span><span class="s1">atol=self.atol</span><span class="s2">, </span><span class="s1">vectorized=</span><span class="s2">False,</span>
                 <span class="s1">param_filter=param_filter).check()</span>


<span class="s2">def </span><span class="s1">_assert_inverts(*a</span><span class="s2">, </span><span class="s1">**kw):</span>
    <span class="s1">d = _CDFData(*a</span><span class="s2">, </span><span class="s1">**kw)</span>
    <span class="s1">d.check()</span>


<span class="s2">def </span><span class="s1">_binomial_cdf(k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p):</span>
    <span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p = mpmath.mpf(k)</span><span class="s2">, </span><span class="s1">mpmath.mpf(n)</span><span class="s2">, </span><span class="s1">mpmath.mpf(p)</span>
    <span class="s2">if </span><span class="s1">k &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">mpmath.mpf(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">k &gt;= n:</span>
        <span class="s2">return </span><span class="s1">mpmath.mpf(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">onemp = mpmath.fsub(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">mpmath.betainc(n - k</span><span class="s2">, </span><span class="s1">k + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">x2=onemp</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_f_cdf(dfn</span><span class="s2">, </span><span class="s1">dfd</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s2">if </span><span class="s1">x &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">mpmath.mpf(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">dfn</span><span class="s2">, </span><span class="s1">dfd</span><span class="s2">, </span><span class="s1">x = mpmath.mpf(dfn)</span><span class="s2">, </span><span class="s1">mpmath.mpf(dfd)</span><span class="s2">, </span><span class="s1">mpmath.mpf(x)</span>
    <span class="s1">ub = dfn*x/(dfn*x + dfd)</span>
    <span class="s1">res = mpmath.betainc(dfn/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">dfd/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">x2=ub</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">_student_t_cdf(df</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">dps=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">dps </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">dps = mpmath.mp.dps</span>
    <span class="s2">with </span><span class="s1">mpmath.workdps(dps):</span>
        <span class="s1">df</span><span class="s2">, </span><span class="s1">t = mpmath.mpf(df)</span><span class="s2">, </span><span class="s1">mpmath.mpf(t)</span>
        <span class="s1">fac = mpmath.hyp2f1(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">*(df + </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1.5</span><span class="s2">, </span><span class="s1">-t**</span><span class="s5">2</span><span class="s1">/df)</span>
        <span class="s1">fac *= t*mpmath.gamma(</span><span class="s5">0.5</span><span class="s1">*(df + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">fac /= mpmath.sqrt(mpmath.pi*df)*mpmath.gamma(</span><span class="s5">0.5</span><span class="s1">*df)</span>
        <span class="s2">return </span><span class="s5">0.5 </span><span class="s1">+ fac</span>


<span class="s2">def </span><span class="s1">_noncentral_chi_pdf(t</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">nc):</span>
    <span class="s1">res = mpmath.besseli(df/</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">mpmath.sqrt(nc*t))</span>
    <span class="s1">res *= mpmath.exp(-(t + nc)/</span><span class="s5">2</span><span class="s1">)*(t/nc)**(df/</span><span class="s5">4 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">/</span><span class="s5">2</span><span class="s1">)/</span><span class="s5">2</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">_noncentral_chi_cdf(x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">nc</span><span class="s2">, </span><span class="s1">dps=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">dps </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">dps = mpmath.mp.dps</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">nc = mpmath.mpf(x)</span><span class="s2">, </span><span class="s1">mpmath.mpf(df)</span><span class="s2">, </span><span class="s1">mpmath.mpf(nc)</span>
    <span class="s2">with </span><span class="s1">mpmath.workdps(dps):</span>
        <span class="s1">res = mpmath.quad(</span><span class="s2">lambda </span><span class="s1">t: _noncentral_chi_pdf(t</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">nc)</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">x])</span>
        <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">_tukey_lmbda_quantile(p</span><span class="s2">, </span><span class="s1">lmbda):</span>
    <span class="s4"># For lmbda != 0</span>
    <span class="s2">return </span><span class="s1">(p**lmbda - (</span><span class="s5">1 </span><span class="s1">- p)**lmbda)/lmbda</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s1">@check_version(mpmath</span><span class="s2">, </span><span class="s3">'0.19'</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">TestCDFlib:</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_bdtrik(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.bdtrik</span><span class="s2">,</span>
            <span class="s1">_binomial_cdf</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">[ProbArg()</span><span class="s2">, </span><span class="s1">IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1000</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ProbArg()]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bdtrin(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.bdtrin</span><span class="s2">,</span>
            <span class="s1">_binomial_cdf</span><span class="s2">,</span>
            <span class="s5">1</span><span class="s2">, </span><span class="s1">[IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1000</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ProbArg()</span><span class="s2">, </span><span class="s1">ProbArg()]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s2">, </span><span class="s1">endpt_atol=[</span><span class="s2">None, None, </span><span class="s5">1e-6</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_btdtria(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.btdtria</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: mpmath.betainc(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x2=x</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">[ProbArg()</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e2</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False, </span><span class="s1">inclusive_b=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_btdtrib(self):</span>
        <span class="s4"># Use small values of a or mpmath doesn't converge</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.btdtrib</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: mpmath.betainc(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x2=x</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">1</span><span class="s2">, </span><span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e2</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ProbArg()</span><span class="s2">,</span>
             <span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False, </span><span class="s1">inclusive_b=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s2">, </span><span class="s1">endpt_atol=[</span><span class="s2">None, </span><span class="s5">1e-18</span><span class="s2">, </span><span class="s5">1e-15</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_fdtridfd(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.fdtridfd</span><span class="s2">,</span>
            <span class="s1">_f_cdf</span><span class="s2">,</span>
            <span class="s5">1</span><span class="s2">, </span><span class="s1">[IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ProbArg()</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gdtria(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.gdtria</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: mpmath.gammainc(b</span><span class="s2">, </span><span class="s1">b=a*x</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">[ProbArg()</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e3</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e4</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s2">,</span>
            <span class="s1">endpt_atol=[</span><span class="s2">None, </span><span class="s5">1e-7</span><span class="s2">, </span><span class="s5">1e-10</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_gdtrib(self):</span>
        <span class="s4"># Use small values of a and x or mpmath doesn't converge</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.gdtrib</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: mpmath.gammainc(b</span><span class="s2">, </span><span class="s1">b=a*x</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">1</span><span class="s2">, </span><span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e2</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ProbArg()</span><span class="s2">,</span>
                <span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e3</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gdtrix(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.gdtrix</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x: mpmath.gammainc(b</span><span class="s2">, </span><span class="s1">b=a*x</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">2</span><span class="s2">, </span><span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e3</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1e3</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">ProbArg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s2">,</span>
            <span class="s1">endpt_atol=[</span><span class="s2">None, </span><span class="s5">1e-7</span><span class="s2">, </span><span class="s5">1e-10</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_stdtr(self):</span>
        <span class="s4"># Ideally the left endpoint for Arg() should be 0.</span>
        <span class="s1">assert_mpmath_equal(</span>
            <span class="s1">sp.stdtr</span><span class="s2">,</span>
            <span class="s1">_student_t_cdf</span><span class="s2">,</span>
            <span class="s1">[IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">1e-10</span><span class="s2">, </span><span class="s1">np.inf)]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_stdtridf(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.stdtridf</span><span class="s2">,</span>
            <span class="s1">_student_t_cdf</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">[ProbArg()</span><span class="s2">, </span><span class="s1">Arg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_stdtrit(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.stdtrit</span><span class="s2">,</span>
            <span class="s1">_student_t_cdf</span><span class="s2">,</span>
            <span class="s5">1</span><span class="s2">, </span><span class="s1">[IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ProbArg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s2">,</span>
            <span class="s1">endpt_atol=[</span><span class="s2">None, </span><span class="s5">1e-10</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_chdtriv(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.chdtriv</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">v</span><span class="s2">, </span><span class="s1">x: mpmath.gammainc(v/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">b=x/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">regularized=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">[ProbArg()</span><span class="s2">, </span><span class="s1">IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_chndtridf(self):</span>
        <span class="s4"># Use a larger atol since mpmath is doing numerical integration</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.chndtridf</span><span class="s2">,</span>
            <span class="s1">_noncentral_chi_cdf</span><span class="s2">,</span>
            <span class="s5">1</span><span class="s2">, </span><span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ProbArg()</span><span class="s2">,</span>
                <span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">n=</span><span class="s5">1000</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-15</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_chndtrinc(self):</span>
        <span class="s4"># Use a larger atol since mpmath is doing numerical integration</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.chndtrinc</span><span class="s2">,</span>
            <span class="s1">_noncentral_chi_cdf</span><span class="s2">,</span>
            <span class="s5">2</span><span class="s2">, </span><span class="s1">[Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ProbArg()]</span><span class="s2">,</span>
            <span class="s1">n=</span><span class="s5">1000</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_chndtrix(self):</span>
        <span class="s4"># Use a larger atol since mpmath is doing numerical integration</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.chndtrix</span><span class="s2">,</span>
            <span class="s1">_noncentral_chi_cdf</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">[ProbArg()</span><span class="s2">, </span><span class="s1">IntArg(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">n=</span><span class="s5">1000</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-15</span><span class="s2">,</span>
            <span class="s1">endpt_atol=[</span><span class="s5">1e-6</span><span class="s2">, None, None</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_tklmbda_zero_shape(self):</span>
        <span class="s4"># When lmbda = 0 the CDF has a simple closed form</span>
        <span class="s1">one = mpmath.mpf(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_mpmath_equal(</span>
            <span class="s2">lambda </span><span class="s1">x: sp.tklmbda(x</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">x: one/(mpmath.exp(-x) + one)</span><span class="s2">,</span>
            <span class="s1">[Arg()]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_tklmbda_neg_shape(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.tklmbda</span><span class="s2">,</span>
            <span class="s1">_tukey_lmbda_quantile</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">[ProbArg()</span><span class="s2">, </span><span class="s1">Arg(-</span><span class="s5">25</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">inclusive_b=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">spfunc_first=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s2">,</span>
            <span class="s1">endpt_atol=[</span><span class="s5">1e-9</span><span class="s2">, </span><span class="s5">1e-5</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.xfail(run=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_tklmbda_pos_shape(self):</span>
        <span class="s1">_assert_inverts(</span>
            <span class="s1">sp.tklmbda</span><span class="s2">,</span>
            <span class="s1">_tukey_lmbda_quantile</span><span class="s2">,</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">[ProbArg()</span><span class="s2">, </span><span class="s1">Arg(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s2">, </span><span class="s1">inclusive_a=</span><span class="s2">False</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">spfunc_first=</span><span class="s2">False, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s4"># The values of lmdba are chosen so that 1/lmbda is exact.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'lmbda'</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">8.0</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_tklmbda_lmbda1(self</span><span class="s2">, </span><span class="s1">lmbda):</span>
        <span class="s1">bound = </span><span class="s5">1</span><span class="s1">/lmbda</span>
        <span class="s1">assert_equal(sp.tklmbda([-bound</span><span class="s2">, </span><span class="s1">bound]</span><span class="s2">, </span><span class="s1">lmbda)</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_nonfinite():</span>
    <span class="s1">funcs = [</span>
        <span class="s1">(</span><span class="s3">&quot;btdtria&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;btdtrib&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;bdtrik&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;bdtrin&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;chdtriv&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;chndtr&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;chndtrix&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;chndtridf&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;chndtrinc&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;fdtridfd&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;ncfdtr&quot;</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;ncfdtri&quot;</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;ncfdtridfn&quot;</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;ncfdtridfd&quot;</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;ncfdtrinc&quot;</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;gdtrix&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;gdtrib&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;gdtria&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;nbdtrik&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;nbdtrin&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;nrdtrimn&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;nrdtrisd&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;pdtrik&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;stdtr&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;stdtrit&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;stdtridf&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;nctdtr&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;nctdtrit&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;nctdtridf&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;nctdtrinc&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;tklmbda&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s1">np.random.seed(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">func</span><span class="s2">, </span><span class="s1">numargs </span><span class="s2">in </span><span class="s1">funcs:</span>
        <span class="s1">func = getattr(sp</span><span class="s2">, </span><span class="s1">func)</span>

        <span class="s1">args_choices = [(float(x)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">-np.inf) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in</span>
                        <span class="s1">np.random.rand(numargs)]</span>

        <span class="s2">for </span><span class="s1">args </span><span class="s2">in </span><span class="s1">itertools.product(*args_choices):</span>
            <span class="s1">res = func(*args)</span>

            <span class="s2">if </span><span class="s1">any(np.isnan(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args):</span>
                <span class="s4"># Nan inputs should result to nan output</span>
                <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># All other inputs should return something (but not</span>
                <span class="s4"># raise exceptions or cause hangs)</span>
                <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">test_chndtrix_gh2158():</span>
    <span class="s4"># test that gh-2158 is resolved; previously this blew up</span>
    <span class="s1">res = sp.chndtrix(</span><span class="s5">0.999999</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s5">20.</span><span class="s1">)+</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s4"># Generated in R</span>
    <span class="s4"># options(digits=16)</span>
    <span class="s4"># ncp &lt;- seq(0, 19) + 1e-6</span>
    <span class="s4"># print(qchisq(0.999999, df = 2, ncp = ncp))</span>
    <span class="s1">res_exp = [</span><span class="s5">27.63103493142305</span><span class="s2">, </span><span class="s5">35.25728589950540</span><span class="s2">, </span><span class="s5">39.97396073236288</span><span class="s2">,</span>
               <span class="s5">43.88033702110538</span><span class="s2">, </span><span class="s5">47.35206403482798</span><span class="s2">, </span><span class="s5">50.54112500166103</span><span class="s2">,</span>
               <span class="s5">53.52720257322766</span><span class="s2">, </span><span class="s5">56.35830042867810</span><span class="s2">, </span><span class="s5">59.06600769498512</span><span class="s2">,</span>
               <span class="s5">61.67243118946381</span><span class="s2">, </span><span class="s5">64.19376191277179</span><span class="s2">, </span><span class="s5">66.64228141346548</span><span class="s2">,</span>
               <span class="s5">69.02756927200180</span><span class="s2">, </span><span class="s5">71.35726934749408</span><span class="s2">, </span><span class="s5">73.63759723904816</span><span class="s2">,</span>
               <span class="s5">75.87368842650227</span><span class="s2">, </span><span class="s5">78.06984431185720</span><span class="s2">, </span><span class="s5">80.22971052389806</span><span class="s2">,</span>
               <span class="s5">82.35640899964173</span><span class="s2">, </span><span class="s5">84.45263768373256</span><span class="s1">]</span>
    <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">res_exp)</span>
</pre>
</body>
</html>