<html>
<head>
<title>test_numdiff.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_numdiff.py</font>
</center></td></tr></table>
<pre><span class="s0">'''Testing numerical differentiation 
 
Still some problems, with API (args tuple versus *args) 
finite difference Hessian has some problems that I did not look at yet 
 
Should Hessian also work per observation, if fun returns 2d 
 
'''</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_almost_equal</span>

<span class="s2">import </span><span class="s1">statsmodels.api </span><span class="s2">as </span><span class="s1">sm</span>
<span class="s2">from </span><span class="s1">statsmodels.tools </span><span class="s2">import </span><span class="s1">numdiff</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.numdiff </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">approx_fprime</span><span class="s2">,</span>
    <span class="s1">approx_fprime_cs</span><span class="s2">,</span>
    <span class="s1">approx_hess_cs</span><span class="s2">,</span>
    <span class="s1">_approx_fprime_scalar</span><span class="s2">,</span>
    <span class="s1">_approx_fprime_cs_scalar</span>
<span class="s1">)</span>

<span class="s1">DEC3 = </span><span class="s3">3</span>
<span class="s1">DEC4 = </span><span class="s3">4</span>
<span class="s1">DEC5 = </span><span class="s3">5</span>
<span class="s1">DEC6 = </span><span class="s3">6</span>
<span class="s1">DEC8 = </span><span class="s3">8</span>
<span class="s1">DEC13 = </span><span class="s3">13</span>
<span class="s1">DEC14 = </span><span class="s3">14</span>

<span class="s2">def </span><span class="s1">maxabs(x</span><span class="s2">,</span><span class="s1">y):</span>
    <span class="s2">return </span><span class="s1">np.abs(x-y).max()</span>

<span class="s2">def </span><span class="s1">fun(beta</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s2">return </span><span class="s1">np.dot(x</span><span class="s2">, </span><span class="s1">beta).sum(</span><span class="s3">0</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">fun1(beta</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s4">#print(beta.shape, x.shape)</span>
    <span class="s1">xb = np.dot(x</span><span class="s2">, </span><span class="s1">beta)</span>
    <span class="s2">return </span><span class="s1">(y-xb)**</span><span class="s3">2 </span><span class="s4">#(xb-xb.mean(0))**2</span>

<span class="s2">def </span><span class="s1">fun2(beta</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s4">#print(beta.shape, x.shape)</span>
    <span class="s2">return </span><span class="s1">fun1(beta</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x).sum(</span><span class="s3">0</span><span class="s1">)</span>


<span class="s4">#ravel() added because of MNLogit 2d params</span>
<span class="s2">class </span><span class="s1">CheckGradLoglikeMixin:</span>
    <span class="s2">def </span><span class="s1">test_score(self):</span>
        <span class="s2">for </span><span class="s1">test_params </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s1">sc = self.mod.score(test_params)</span>
            <span class="s1">scfd = numdiff.approx_fprime(test_params.ravel()</span><span class="s2">,</span>
                                                      <span class="s1">self.mod.loglike)</span>
            <span class="s1">assert_almost_equal(sc</span><span class="s2">, </span><span class="s1">scfd</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">1</span><span class="s1">)</span>

            <span class="s1">sccs = numdiff.approx_fprime_cs(test_params.ravel()</span><span class="s2">,</span>
                                                      <span class="s1">self.mod.loglike)</span>
            <span class="s1">assert_almost_equal(sc</span><span class="s2">, </span><span class="s1">sccs</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_hess(self):</span>
        <span class="s2">for </span><span class="s1">test_params </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s1">he = self.mod.hessian(test_params)</span>
            <span class="s1">hefd = numdiff.approx_fprime_cs(test_params</span><span class="s2">, </span><span class="s1">self.mod.score)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=DEC8)</span>

            <span class="s4">#NOTE: notice the accuracy below</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">7</span><span class="s1">)</span>
            <span class="s1">hefd = numdiff.approx_fprime(test_params</span><span class="s2">, </span><span class="s1">self.mod.score</span><span class="s2">,</span>
                                         <span class="s1">centered=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">assert_allclose(he</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">1e-9</span><span class="s1">)</span>
            <span class="s1">hefd = numdiff.approx_fprime(test_params</span><span class="s2">, </span><span class="s1">self.mod.score</span><span class="s2">,</span>
                                         <span class="s1">centered=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>

            <span class="s1">hescs = numdiff.approx_fprime_cs(test_params.ravel()</span><span class="s2">,</span>
                                                        <span class="s1">self.mod.score)</span>
            <span class="s1">assert_allclose(he</span><span class="s2">, </span><span class="s1">hescs</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">1e-13</span><span class="s1">)</span>

            <span class="s1">hecs = numdiff.approx_hess_cs(test_params.ravel()</span><span class="s2">,</span>
                                                        <span class="s1">self.mod.loglike)</span>
            <span class="s1">assert_allclose(he</span><span class="s2">, </span><span class="s1">hecs</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">1e-9</span><span class="s1">)</span>

            <span class="s4">#NOTE: Look at the lack of precision - default epsilon not always</span>
            <span class="s4">#best</span>
            <span class="s1">grad = self.mod.score(test_params)</span>
            <span class="s1">hecs</span><span class="s2">, </span><span class="s1">gradcs = numdiff.approx_hess1(test_params</span><span class="s2">, </span><span class="s1">self.mod.loglike</span><span class="s2">,</span>
                                              <span class="s3">1e-6</span><span class="s2">, </span><span class="s1">return_grad=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hecs</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(grad</span><span class="s2">, </span><span class="s1">gradcs</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">hecs</span><span class="s2">, </span><span class="s1">gradcs = numdiff.approx_hess2(test_params</span><span class="s2">, </span><span class="s1">self.mod.loglike</span><span class="s2">,</span>
                                <span class="s3">1e-4</span><span class="s2">, </span><span class="s1">return_grad=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hecs</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(grad</span><span class="s2">, </span><span class="s1">gradcs</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">hecs = numdiff.approx_hess3(test_params</span><span class="s2">, </span><span class="s1">self.mod.loglike</span><span class="s2">, </span><span class="s3">1e-5</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hecs</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestGradMNLogit(CheckGradLoglikeMixin):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s4">#from .results.results_discrete import Anes</span>
        <span class="s1">data = sm.datasets.anes96.load()</span>
        <span class="s1">data.exog = np.asarray(data.exog)</span>
        <span class="s1">data.endog = np.asarray(data.endog)</span>
        <span class="s1">exog = data.exog</span>
        <span class="s1">exog = sm.add_constant(exog</span><span class="s2">, </span><span class="s1">prepend=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">cls.mod = sm.MNLogit(data.endog</span><span class="s2">, </span><span class="s1">exog)</span>

        <span class="s4">#def loglikeflat(cls, params):</span>
            <span class="s4">#reshapes flattened params</span>
        <span class="s4">#    return cls.loglike(params.reshape(6,6))</span>
        <span class="s4">#cls.mod.loglike = loglikeflat  #need instance method</span>
        <span class="s4">#cls.params = [np.ones((6,6)).ravel()]</span>
        <span class="s1">res = cls.mod.fit(disp=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">cls.params = [res.params.ravel(</span><span class="s5">'F'</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">test_hess(self):</span>
        <span class="s4">#NOTE: I had to overwrite this to lessen the tolerance</span>
        <span class="s2">for </span><span class="s1">test_params </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s1">he = self.mod.hessian(test_params)</span>
            <span class="s1">hefd = numdiff.approx_fprime_cs(test_params</span><span class="s2">, </span><span class="s1">self.mod.score)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=DEC8)</span>

            <span class="s4">#NOTE: notice the accuracy below and the epsilon changes</span>
            <span class="s4"># this does not work well for score -&gt; hessian with non-cs step</span>
            <span class="s4"># it's a little better around the optimum</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">7</span><span class="s1">)</span>
            <span class="s1">hefd = numdiff.approx_fprime(test_params</span><span class="s2">, </span><span class="s1">self.mod.score</span><span class="s2">,</span>
                                         <span class="s1">centered=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">hefd = numdiff.approx_fprime(test_params</span><span class="s2">, </span><span class="s1">self.mod.score</span><span class="s2">, </span><span class="s3">1e-9</span><span class="s2">,</span>
                                         <span class="s1">centered=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">2</span><span class="s1">)</span>

            <span class="s1">hescs = numdiff.approx_fprime_cs(test_params</span><span class="s2">, </span><span class="s1">self.mod.score)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hescs</span><span class="s2">, </span><span class="s1">decimal=DEC8)</span>

            <span class="s1">hecs = numdiff.approx_hess_cs(test_params</span><span class="s2">, </span><span class="s1">self.mod.loglike)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hecs</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">5</span><span class="s1">)</span>
            <span class="s4">#NOTE: these just do not work well</span>
            <span class="s4">#hecs = numdiff.approx_hess1(test_params, self.mod.loglike, 1e-3)</span>
            <span class="s4">#assert_almost_equal(he, hecs, decimal=1)</span>
            <span class="s4">#hecs = numdiff.approx_hess2(test_params, self.mod.loglike, 1e-4)</span>
            <span class="s4">#assert_almost_equal(he, hecs, decimal=0)</span>
            <span class="s1">hecs = numdiff.approx_hess3(test_params</span><span class="s2">, </span><span class="s1">self.mod.loglike</span><span class="s2">, </span><span class="s3">1e-4</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(he</span><span class="s2">, </span><span class="s1">hecs</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">0</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">TestGradLogit(CheckGradLoglikeMixin):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sm.datasets.spector.load()</span>
        <span class="s1">data.exog = sm.add_constant(data.exog</span><span class="s2">, </span><span class="s1">prepend=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s4">#mod = sm.Probit(data.endog, data.exog)</span>
        <span class="s1">cls.mod = sm.Logit(data.endog</span><span class="s2">, </span><span class="s1">data.exog)</span>
        <span class="s4">#res = mod.fit(method=&quot;newton&quot;)</span>
        <span class="s1">cls.params = [np.array([</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0.25</span><span class="s2">,</span><span class="s3">1.4</span><span class="s2">,</span><span class="s1">-</span><span class="s3">7</span><span class="s1">])]</span>
        <span class="s4">##loglike = mod.loglike</span>
        <span class="s4">##score = mod.score</span>
        <span class="s4">##hess = mod.hessian</span>


<span class="s2">class </span><span class="s1">CheckDerivativeMixin:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">nobs = </span><span class="s3">200</span>
        <span class="s4">#x = np.arange(nobs*3).reshape(nobs,-1)</span>
        <span class="s1">np.random.seed(</span><span class="s3">187678</span><span class="s1">)</span>
        <span class="s1">x = np.random.randn(nobs</span><span class="s2">,</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s1">xk = np.array([</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">xk = np.array([</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s1">])</span>
        <span class="s4">#xk = np.zeros(3)</span>
        <span class="s1">beta = xk</span>
        <span class="s1">y = np.dot(x</span><span class="s2">, </span><span class="s1">beta) + </span><span class="s3">0.1</span><span class="s1">*np.random.randn(nobs)</span>
        <span class="s1">xkols = np.dot(np.linalg.pinv(x)</span><span class="s2">,</span><span class="s1">y)</span>

        <span class="s1">cls.x = x</span>
        <span class="s1">cls.y = y</span>
        <span class="s1">cls.params = [np.array([</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s1">])</span><span class="s2">, </span><span class="s1">xkols]</span>
        <span class="s1">cls.init()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">init(cls):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_grad_fun1_fd(self):</span>
        <span class="s2">for </span><span class="s1">test_params </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s4">#gtrue = self.x.sum(0)</span>
            <span class="s1">gtrue = self.gradtrue(test_params)</span>
            <span class="s1">fun = self.fun()</span>
            <span class="s1">epsilon = </span><span class="s3">1e-6</span>
            <span class="s1">gfd = numdiff.approx_fprime(test_params</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">epsilon=epsilon</span><span class="s2">,</span>
                                         <span class="s1">args=self.args)</span>
            <span class="s1">gfd += numdiff.approx_fprime(test_params</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">epsilon=-epsilon</span><span class="s2">,</span>
                                          <span class="s1">args=self.args)</span>
            <span class="s1">gfd /= </span><span class="s3">2.</span>
            <span class="s1">assert_almost_equal(gtrue</span><span class="s2">, </span><span class="s1">gfd</span><span class="s2">, </span><span class="s1">decimal=DEC6)</span>

    <span class="s2">def </span><span class="s1">test_grad_fun1_fdc(self):</span>
        <span class="s2">for </span><span class="s1">test_params </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s4">#gtrue = self.x.sum(0)</span>
            <span class="s1">gtrue = self.gradtrue(test_params)</span>
            <span class="s1">fun = self.fun()</span>

            <span class="s4"># default epsilon of 1e-6 is not precise enough here</span>
            <span class="s1">gfd = numdiff.approx_fprime(test_params</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">epsilon=</span><span class="s3">1e-8</span><span class="s2">,</span>
                                         <span class="s1">args=self.args</span><span class="s2">, </span><span class="s1">centered=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(gtrue</span><span class="s2">, </span><span class="s1">gfd</span><span class="s2">, </span><span class="s1">decimal=DEC5)</span>

    <span class="s2">def </span><span class="s1">test_grad_fun1_cs(self):</span>
        <span class="s2">for </span><span class="s1">test_params </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s4">#gtrue = self.x.sum(0)</span>
            <span class="s1">gtrue = self.gradtrue(test_params)</span>
            <span class="s1">fun = self.fun()</span>

            <span class="s1">gcs = numdiff.approx_fprime_cs(test_params</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">args=self.args)</span>
            <span class="s1">assert_almost_equal(gtrue</span><span class="s2">, </span><span class="s1">gcs</span><span class="s2">, </span><span class="s1">decimal=DEC13)</span>

    <span class="s2">def </span><span class="s1">test_hess_fun1_fd(self):</span>
        <span class="s2">for </span><span class="s1">test_params </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s4">#hetrue = 0</span>
            <span class="s1">hetrue = self.hesstrue(test_params)</span>
            <span class="s2">if </span><span class="s1">hetrue </span><span class="s2">is not None</span><span class="s1">: </span><span class="s4">#Hessian does not work for 2d return of fun</span>
                <span class="s1">fun = self.fun()</span>
                <span class="s4">#default works, epsilon 1e-6 or 1e-8 is not precise enough</span>
                <span class="s1">hefd = numdiff.approx_hess1(test_params</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s4">#epsilon=1e-8,</span>
                                             <span class="s4"># TODO: should be kwds</span>
                                             <span class="s1">args=self.args)</span>
                <span class="s1">assert_almost_equal(hetrue</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=DEC3)</span>
                <span class="s4">#TODO: I reduced precision to DEC3 from DEC4 because of</span>
                <span class="s4">#    TestDerivativeFun</span>
                <span class="s1">hefd = numdiff.approx_hess2(test_params</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s4">#epsilon=1e-8,</span>
                                             <span class="s4"># TODO: should be kwds</span>
                                             <span class="s1">args=self.args)</span>
                <span class="s1">assert_almost_equal(hetrue</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=DEC3)</span>
                <span class="s1">hefd = numdiff.approx_hess3(test_params</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s4">#epsilon=1e-8,</span>
                                             <span class="s4"># TODO: should be kwds</span>
                                             <span class="s1">args=self.args)</span>
                <span class="s1">assert_almost_equal(hetrue</span><span class="s2">, </span><span class="s1">hefd</span><span class="s2">, </span><span class="s1">decimal=DEC3)</span>

    <span class="s2">def </span><span class="s1">test_hess_fun1_cs(self):</span>
        <span class="s2">for </span><span class="s1">test_params </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s4">#hetrue = 0</span>
            <span class="s1">hetrue = self.hesstrue(test_params)</span>
            <span class="s2">if </span><span class="s1">hetrue </span><span class="s2">is not None</span><span class="s1">: </span><span class="s4">#Hessian does not work for 2d return of fun</span>
                <span class="s1">fun = self.fun()</span>
                <span class="s1">hecs = numdiff.approx_hess_cs(test_params</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">args=self.args)</span>
                <span class="s1">assert_almost_equal(hetrue</span><span class="s2">, </span><span class="s1">hecs</span><span class="s2">, </span><span class="s1">decimal=DEC6)</span>


<span class="s2">class </span><span class="s1">TestDerivativeFun(CheckDerivativeMixin):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestDerivativeFun</span><span class="s2">,</span><span class="s1">cls).setup_class()</span>
        <span class="s1">xkols = np.dot(np.linalg.pinv(cls.x)</span><span class="s2">, </span><span class="s1">cls.y)</span>
        <span class="s1">cls.params = [np.array([</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s1">])</span><span class="s2">, </span><span class="s1">xkols]</span>
        <span class="s1">cls.args = (cls.x</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">fun(self):</span>
        <span class="s2">return </span><span class="s1">fun</span>
    <span class="s2">def </span><span class="s1">gradtrue(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s2">return </span><span class="s1">self.x.sum(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">hesstrue(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s2">return </span><span class="s1">np.zeros((</span><span class="s3">3</span><span class="s2">,</span><span class="s3">3</span><span class="s1">))   </span><span class="s4">#make it (3,3), because test fails with scalar 0</span>
        <span class="s4">#why is precision only DEC3</span>

<span class="s2">class </span><span class="s1">TestDerivativeFun2(CheckDerivativeMixin):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestDerivativeFun2</span><span class="s2">,</span><span class="s1">cls).setup_class()</span>
        <span class="s1">xkols = np.dot(np.linalg.pinv(cls.x)</span><span class="s2">, </span><span class="s1">cls.y)</span>
        <span class="s1">cls.params = [np.array([</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s1">])</span><span class="s2">, </span><span class="s1">xkols]</span>
        <span class="s1">cls.args = (cls.y</span><span class="s2">, </span><span class="s1">cls.x)</span>

    <span class="s2">def </span><span class="s1">fun(self):</span>
        <span class="s2">return </span><span class="s1">fun2</span>

    <span class="s2">def </span><span class="s1">gradtrue(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">x = self.y</span><span class="s2">, </span><span class="s1">self.x</span>
        <span class="s2">return </span><span class="s1">(-x*</span><span class="s3">2</span><span class="s1">*(y-np.dot(x</span><span class="s2">, </span><span class="s1">params))[:</span><span class="s2">,None</span><span class="s1">]).sum(</span><span class="s3">0</span><span class="s1">)</span>
                <span class="s4">#2*(y-np.dot(x, params)).sum(0)</span>

    <span class="s2">def </span><span class="s1">hesstrue(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s1">x = self.x</span>
        <span class="s2">return </span><span class="s3">2</span><span class="s1">*np.dot(x.T</span><span class="s2">, </span><span class="s1">x)</span>

<span class="s2">class </span><span class="s1">TestDerivativeFun1(CheckDerivativeMixin):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestDerivativeFun1</span><span class="s2">, </span><span class="s1">cls).setup_class()</span>
        <span class="s1">xkols = np.dot(np.linalg.pinv(cls.x)</span><span class="s2">, </span><span class="s1">cls.y)</span>
        <span class="s1">cls.params = [np.array([</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s1">])</span><span class="s2">, </span><span class="s1">xkols]</span>
        <span class="s1">cls.args = (cls.y</span><span class="s2">, </span><span class="s1">cls.x)</span>

    <span class="s2">def </span><span class="s1">fun(self):</span>
        <span class="s2">return </span><span class="s1">fun1</span>
    <span class="s2">def </span><span class="s1">gradtrue(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">x = self.y</span><span class="s2">, </span><span class="s1">self.x</span>
        <span class="s2">return </span><span class="s1">(-x*</span><span class="s3">2</span><span class="s1">*(y-np.dot(x</span><span class="s2">, </span><span class="s1">params))[:</span><span class="s2">,None</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">hesstrue(self</span><span class="s2">, </span><span class="s1">params):</span>
        <span class="s2">return None</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">x = self.y</span><span class="s2">, </span><span class="s1">self.x</span>
        <span class="s2">return </span><span class="s1">(-x*</span><span class="s3">2</span><span class="s1">*(y-np.dot(x</span><span class="s2">, </span><span class="s1">params))[:</span><span class="s2">,None</span><span class="s1">])  </span><span class="s4">#TODO: check shape</span>


<span class="s2">def </span><span class="s1">test_dtypes():</span>
    <span class="s2">def </span><span class="s1">f(x):</span>
        <span class="s2">return </span><span class="s3">2</span><span class="s1">*x</span>

    <span class="s1">desired = np.array([[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(approx_fprime(np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_allclose(approx_fprime(np.array([</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">2.</span><span class="s1">])</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">assert_allclose(approx_fprime(np.array([</span><span class="s3">1.</span><span class="s1">+</span><span class="s3">0j</span><span class="s2">, </span><span class="s3">2.</span><span class="s1">+</span><span class="s3">0j</span><span class="s1">])</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_vectorized():</span>
    <span class="s2">def </span><span class="s1">f(x):</span>
        <span class="s2">return </span><span class="s3">2</span><span class="s1">*x</span>

    <span class="s1">desired = np.array([</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s4"># vectorized parameter, column vector</span>
    <span class="s1">p = np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]]).T</span>
    <span class="s1">assert_allclose(_approx_fprime_scalar(p</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">, </span><span class="s1">desired[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">1e-8</span><span class="s1">)</span>
    <span class="s1">assert_allclose(_approx_fprime_scalar(p.squeeze()</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">,</span>
                    <span class="s1">desired</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">1e-8</span><span class="s1">)</span>
    <span class="s1">assert_allclose(_approx_fprime_cs_scalar(p</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">, </span><span class="s1">desired[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">rtol=</span><span class="s3">1e-8</span><span class="s1">)</span>
    <span class="s1">assert_allclose(_approx_fprime_cs_scalar(p.squeeze()</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">,</span>
                    <span class="s1">desired</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s4"># check 2-d row, see #7680</span>
    <span class="s4"># not allowed/implemented for approx_fprime, raises broadcast ValueError</span>
    <span class="s4"># assert_allclose(approx_fprime(p.T, f), desired, rtol=1e-8)</span>
    <span class="s4"># similar as used in MarkovSwitching unit test</span>
    <span class="s1">assert_allclose(approx_fprime_cs(p.T</span><span class="s2">, </span><span class="s1">f).squeeze()</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">1e-8</span><span class="s1">)</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s5">'__main__'</span><span class="s1">:  </span><span class="s4"># FIXME: turn into tests or move/remove</span>

    <span class="s1">epsilon = </span><span class="s3">1e-6</span>
    <span class="s1">nobs = </span><span class="s3">200</span>
    <span class="s1">x = np.arange(nobs*</span><span class="s3">3</span><span class="s1">).reshape(nobs</span><span class="s2">,</span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">x = np.random.randn(nobs</span><span class="s2">,</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s1">xk = np.array([</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">xk = np.array([</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s2">,</span><span class="s3">1.</span><span class="s1">])</span>
    <span class="s4">#xk = np.zeros(3)</span>
    <span class="s1">beta = xk</span>
    <span class="s1">y = np.dot(x</span><span class="s2">, </span><span class="s1">beta) + </span><span class="s3">0.1</span><span class="s1">*np.random.randn(nobs)</span>
    <span class="s1">xkols = np.dot(np.linalg.pinv(x)</span><span class="s2">,</span><span class="s1">y)</span>

    <span class="s1">print(approx_fprime((</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">)</span><span class="s2">,</span><span class="s1">fun</span><span class="s2">,</span><span class="s1">epsilon</span><span class="s2">,</span><span class="s1">x))</span>
    <span class="s1">gradtrue = x.sum(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">print(x.sum(</span><span class="s3">0</span><span class="s1">))</span>
    <span class="s1">gradcs = approx_fprime_cs((</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">h=</span><span class="s3">1.0e-20</span><span class="s1">)</span>
    <span class="s1">print(gradcs</span><span class="s2">, </span><span class="s1">maxabs(gradcs</span><span class="s2">, </span><span class="s1">gradtrue))</span>
    <span class="s1">print(approx_hess_cs((</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">h=</span><span class="s3">1.0e-20</span><span class="s1">))  </span><span class="s4">#this is correctly zero</span>

    <span class="s1">print(approx_hess_cs((</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fun2</span><span class="s2">, </span><span class="s1">(y</span><span class="s2">,</span><span class="s1">x)</span><span class="s2">, </span><span class="s1">h=</span><span class="s3">1.0e-20</span><span class="s1">)-</span><span class="s3">2</span><span class="s1">*np.dot(x.T</span><span class="s2">, </span><span class="s1">x))</span>
    <span class="s1">print(numdiff.approx_hess(xk</span><span class="s2">,</span><span class="s1">fun2</span><span class="s2">,</span><span class="s3">1e-3</span><span class="s2">, </span><span class="s1">(y</span><span class="s2">,</span><span class="s1">x))[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">2</span><span class="s1">*np.dot(x.T</span><span class="s2">, </span><span class="s1">x))</span>

    <span class="s1">gt = (-x*</span><span class="s3">2</span><span class="s1">*(y-np.dot(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">]))[:</span><span class="s2">,None</span><span class="s1">])</span>
    <span class="s1">g = approx_fprime_cs((</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fun1</span><span class="s2">, </span><span class="s1">(y</span><span class="s2">,</span><span class="s1">x)</span><span class="s2">, </span><span class="s1">h=</span><span class="s3">1.0e-20</span><span class="s1">)</span><span class="s4">#.T   #this should not be transposed</span>
    <span class="s1">gd = numdiff.approx_fprime((</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2</span><span class="s2">,</span><span class="s3">3</span><span class="s1">)</span><span class="s2">,</span><span class="s1">fun1</span><span class="s2">,</span><span class="s1">epsilon</span><span class="s2">,</span><span class="s1">(y</span><span class="s2">,</span><span class="s1">x))</span>
    <span class="s1">print(maxabs(g</span><span class="s2">, </span><span class="s1">gt))</span>
    <span class="s1">print(maxabs(gd</span><span class="s2">, </span><span class="s1">gt))</span>

    <span class="s1">data = sm.datasets.spector.load()</span>
    <span class="s1">data.exog = sm.add_constant(data.exog</span><span class="s2">, </span><span class="s1">prepend=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s4">#mod = sm.Probit(data.endog, data.exog)</span>
    <span class="s1">mod = sm.Logit(data.endog</span><span class="s2">, </span><span class="s1">data.exog)</span>
    <span class="s4">#res = mod.fit(method=&quot;newton&quot;)</span>
    <span class="s1">test_params = [</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0.25</span><span class="s2">,</span><span class="s3">1.4</span><span class="s2">,</span><span class="s1">-</span><span class="s3">7</span><span class="s1">]</span>
    <span class="s1">loglike = mod.loglike</span>
    <span class="s1">score = mod.score</span>
    <span class="s1">hess = mod.hessian</span>

    <span class="s4">#cs does not work for Probit because special.ndtr does not support complex</span>
    <span class="s4">#maybe calculating ndtr for real and imag parts separately, if we need it</span>
    <span class="s4">#and if it still works in this case</span>
    <span class="s1">print(</span><span class="s5">'sm'</span><span class="s2">, </span><span class="s1">score(test_params))</span>
    <span class="s1">print(</span><span class="s5">'fd'</span><span class="s2">, </span><span class="s1">numdiff.approx_fprime(test_params</span><span class="s2">,</span><span class="s1">loglike</span><span class="s2">,</span><span class="s1">epsilon))</span>
    <span class="s1">print(</span><span class="s5">'cs'</span><span class="s2">, </span><span class="s1">numdiff.approx_fprime_cs(test_params</span><span class="s2">,</span><span class="s1">loglike))</span>
    <span class="s1">print(</span><span class="s5">'sm'</span><span class="s2">, </span><span class="s1">hess(test_params))</span>
    <span class="s1">print(</span><span class="s5">'fd'</span><span class="s2">, </span><span class="s1">numdiff.approx_fprime(test_params</span><span class="s2">,</span><span class="s1">score</span><span class="s2">,</span><span class="s1">epsilon))</span>
    <span class="s1">print(</span><span class="s5">'cs'</span><span class="s2">, </span><span class="s1">numdiff.approx_fprime_cs(test_params</span><span class="s2">, </span><span class="s1">score))</span>

    <span class="s1">hesscs = numdiff.approx_hess_cs(test_params</span><span class="s2">, </span><span class="s1">loglike)</span>
    <span class="s1">print(</span><span class="s5">'cs'</span><span class="s2">, </span><span class="s1">hesscs)</span>
    <span class="s1">print(maxabs(hess(test_params)</span><span class="s2">, </span><span class="s1">hesscs))</span>

    <span class="s1">data = sm.datasets.anes96.load()</span>
    <span class="s1">exog = data.exog</span>
    <span class="s1">exog = sm.add_constant(exog</span><span class="s2">, </span><span class="s1">prepend=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">res1 = sm.MNLogit(data.endog</span><span class="s2">, </span><span class="s1">exog).fit(method=</span><span class="s5">&quot;newton&quot;</span><span class="s2">, </span><span class="s1">disp=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">datap = sm.datasets.randhie.load()</span>
    <span class="s1">nobs = len(datap.endog)</span>
    <span class="s1">exogp = sm.add_constant(datap.exog.view(float).reshape(nobs</span><span class="s2">,</span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">prepend=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">modp = sm.Poisson(datap.endog</span><span class="s2">, </span><span class="s1">exogp)</span>
    <span class="s1">resp = modp.fit(method=</span><span class="s5">'newton'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s3">0</span><span class="s1">)</span>
</pre>
</body>
</html>