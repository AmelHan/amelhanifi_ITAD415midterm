<html>
<head>
<title>_fitpack_impl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_fitpack_impl.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
fitpack (dierckx in netlib) --- A Python-C wrapper to FITPACK (by P. Dierckx). 
        FITPACK is a collection of FORTRAN programs for curve and surface 
        fitting with splines and tensor product splines. 
 
See 
 https://web.archive.org/web/20010524124604/http://www.cs.kuleuven.ac.be:80/cwis/research/nalag/research/topics/fitpack.html 
or 
 http://www.netlib.org/dierckx/ 
 
Copyright 2002 Pearu Peterson all rights reserved, 
Pearu Peterson &lt;pearu@cens.ioc.ee&gt; 
Permission to use, modify, and distribute this software is given under the 
terms of the SciPy (BSD style) license. See LICENSE.txt that came with 
this distribution for specifics. 
 
NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK. 
 
TODO: Make interfaces to the following fitpack functions: 
    For univariate splines: cocosp, concon, fourco, insert 
    For bivariate splines: profil, regrid, parsur, surev 
&quot;&quot;&quot;</span>

<span class="s1">__all__ = [</span><span class="s2">'splrep'</span><span class="s3">, </span><span class="s2">'splprep'</span><span class="s3">, </span><span class="s2">'splev'</span><span class="s3">, </span><span class="s2">'splint'</span><span class="s3">, </span><span class="s2">'sproot'</span><span class="s3">, </span><span class="s2">'spalde'</span><span class="s3">,</span>
           <span class="s2">'bisplrep'</span><span class="s3">, </span><span class="s2">'bisplev'</span><span class="s3">, </span><span class="s2">'insert'</span><span class="s3">, </span><span class="s2">'splder'</span><span class="s3">, </span><span class="s2">'splantider'</span><span class="s1">]</span>

<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_fitpack</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">(atleast_1d</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">ones</span><span class="s3">, </span><span class="s1">zeros</span><span class="s3">, </span><span class="s1">sqrt</span><span class="s3">, </span><span class="s1">ravel</span><span class="s3">, </span><span class="s1">transpose</span><span class="s3">,</span>
                   <span class="s1">empty</span><span class="s3">, </span><span class="s1">iinfo</span><span class="s3">, </span><span class="s1">asarray)</span>

<span class="s4"># Try to replace _fitpack interface with</span>
<span class="s4">#  f2py-generated version</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">dfitpack</span>


<span class="s1">dfitpack_int = dfitpack.types.intvar.dtype</span>


<span class="s3">def </span><span class="s1">_int_overflow(x</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Cast the value to an dfitpack_int and raise an OverflowError if the value 
    cannot fit. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">x &gt; iinfo(dfitpack_int).max:</span>
        <span class="s3">if </span><span class="s1">msg </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">f'</span><span class="s3">{</span><span class="s1">x</span><span class="s3">!r} </span><span class="s2">cannot fit into an </span><span class="s3">{</span><span class="s1">dfitpack_int</span><span class="s3">!r}</span><span class="s2">'</span>
        <span class="s3">raise </span><span class="s1">OverflowError(msg)</span>
    <span class="s3">return </span><span class="s1">dfitpack_int.type(x)</span>


<span class="s1">_iermess = {</span>
    <span class="s5">0</span><span class="s1">: [</span><span class="s2">&quot;The spline has a residual sum of squares fp such that &quot;</span>
        <span class="s2">&quot;abs(fp-s)/s&lt;=0.001&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">1</span><span class="s1">: [</span><span class="s2">&quot;The spline is an interpolating spline (fp=0)&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">2</span><span class="s1">: [</span><span class="s2">&quot;The spline is weighted least-squares polynomial of degree k.</span><span class="s3">\n</span><span class="s2">&quot;</span>
         <span class="s2">&quot;fp gives the upper bound fp0 for the smoothing factor s&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s5">1</span><span class="s1">: [</span><span class="s2">&quot;The required storage space exceeds the available storage space.</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Probable causes: data (x,y) size is too small or smoothing parameter&quot;</span>
        <span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">s is too small (fp&gt;s).&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">2</span><span class="s1">: [</span><span class="s2">&quot;A theoretically impossible result when finding a smoothing spline</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;with fp = s. Probable cause: s too small. (abs(fp-s)/s&gt;0.001)&quot;</span><span class="s3">,</span>
        <span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">3</span><span class="s1">: [</span><span class="s2">&quot;The maximal number of iterations (20) allowed for finding smoothing</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;spline with fp=s has been reached. Probable cause: s too small.</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;(abs(fp-s)/s&gt;0.001)&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">10</span><span class="s1">: [</span><span class="s2">&quot;Error on input data&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s2">'unknown'</span><span class="s1">: [</span><span class="s2">&quot;An error occurred&quot;</span><span class="s3">, </span><span class="s1">TypeError]</span>
<span class="s1">}</span>

<span class="s1">_iermess2 = {</span>
    <span class="s5">0</span><span class="s1">: [</span><span class="s2">&quot;The spline has a residual sum of squares fp such that &quot;</span>
        <span class="s2">&quot;abs(fp-s)/s&lt;=0.001&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">1</span><span class="s1">: [</span><span class="s2">&quot;The spline is an interpolating spline (fp=0)&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">2</span><span class="s1">: [</span><span class="s2">&quot;The spline is weighted least-squares polynomial of degree kx and ky.&quot;</span>
         <span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">fp gives the upper bound fp0 for the smoothing factor s&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">-</span><span class="s5">3</span><span class="s1">: [</span><span class="s2">&quot;Warning. The coefficients of the spline have been computed as the</span><span class="s3">\n</span><span class="s2">&quot;</span>
         <span class="s2">&quot;minimal norm least-squares solution of a rank deficient system.&quot;</span><span class="s3">,</span>
         <span class="s3">None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s5">1</span><span class="s1">: [</span><span class="s2">&quot;The required storage space exceeds the available storage space.</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Probable causes: nxest or nyest too small or s is too small. (fp&gt;s)&quot;</span><span class="s3">,</span>
        <span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">2</span><span class="s1">: [</span><span class="s2">&quot;A theoretically impossible result when finding a smoothing spline</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;with fp = s. Probable causes: s too small or badly chosen eps.</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;(abs(fp-s)/s&gt;0.001)&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">3</span><span class="s1">: [</span><span class="s2">&quot;The maximal number of iterations (20) allowed for finding smoothing</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;spline with fp=s has been reached. Probable cause: s too small.</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;(abs(fp-s)/s&gt;0.001)&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">4</span><span class="s1">: [</span><span class="s2">&quot;No more knots can be added because the number of B-spline</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;coefficients already exceeds the number of data points m.</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Probable causes: either s or m too small. (fp&gt;s)&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">5</span><span class="s1">: [</span><span class="s2">&quot;No more knots can be added because the additional knot would</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;coincide with an old one. Probable cause: s too small or too large</span><span class="s3">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;a weight to an inaccurate data point. (fp&gt;s)&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">10</span><span class="s1">: [</span><span class="s2">&quot;Error on input data&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s5">11</span><span class="s1">: [</span><span class="s2">&quot;rwrk2 too small, i.e., there is not enough workspace for computing</span><span class="s3">\n</span><span class="s2">&quot;</span>
         <span class="s2">&quot;the minimal least-squares solution of a rank deficient system of</span><span class="s3">\n</span><span class="s2">&quot;</span>
         <span class="s2">&quot;linear equations.&quot;</span><span class="s3">, </span><span class="s1">ValueError]</span><span class="s3">,</span>
    <span class="s2">'unknown'</span><span class="s1">: [</span><span class="s2">&quot;An error occurred&quot;</span><span class="s3">, </span><span class="s1">TypeError]</span>
<span class="s1">}</span>

<span class="s1">_parcur_cache = {</span><span class="s2">'t'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">, </span><span class="s2">'wrk'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">,</span>
                 <span class="s2">'iwrk'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">dfitpack_int)</span><span class="s3">, </span><span class="s2">'u'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">,</span>
                 <span class="s2">'ub'</span><span class="s1">: </span><span class="s5">0</span><span class="s3">, </span><span class="s2">'ue'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>


<span class="s3">def </span><span class="s1">splprep(x</span><span class="s3">, </span><span class="s1">w=</span><span class="s3">None, </span><span class="s1">u=</span><span class="s3">None, </span><span class="s1">ub=</span><span class="s3">None, </span><span class="s1">ue=</span><span class="s3">None, </span><span class="s1">k=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">task=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">s=</span><span class="s3">None, </span><span class="s1">t=</span><span class="s3">None,</span>
            <span class="s1">full_output=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nest=</span><span class="s3">None, </span><span class="s1">per=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">quiet=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s4"># see the docstring of `_fitpack_py/splprep`</span>
    <span class="s3">if </span><span class="s1">task &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">_parcur_cache = {</span><span class="s2">'t'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">, </span><span class="s2">'wrk'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">,</span>
                         <span class="s2">'iwrk'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">dfitpack_int)</span><span class="s3">, </span><span class="s2">'u'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">,</span>
                         <span class="s2">'ub'</span><span class="s1">: </span><span class="s5">0</span><span class="s3">, </span><span class="s2">'ue'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>
    <span class="s1">x = atleast_1d(x)</span>
    <span class="s1">idim</span><span class="s3">, </span><span class="s1">m = x.shape</span>
    <span class="s3">if </span><span class="s1">per:</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(idim):</span>
            <span class="s3">if </span><span class="s1">x[i][</span><span class="s5">0</span><span class="s1">] != x[i][-</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s3">if not </span><span class="s1">quiet:</span>
                    <span class="s1">warnings.warn(RuntimeWarning(</span><span class="s2">'Setting x[%d][%d]=x[%d][0]' </span><span class="s1">%</span>
                                                 <span class="s1">(i</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">i)))</span>
                <span class="s1">x[i][-</span><span class="s5">1</span><span class="s1">] = x[i][</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">if not </span><span class="s5">0 </span><span class="s1">&lt; idim &lt; </span><span class="s5">11</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'0 &lt; idim &lt; 11 must hold'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">w </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">w = ones(m</span><span class="s3">, </span><span class="s1">float)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">w = atleast_1d(w)</span>
    <span class="s1">ipar = (u </span><span class="s3">is not None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">ipar:</span>
        <span class="s1">_parcur_cache[</span><span class="s2">'u'</span><span class="s1">] = u</span>
        <span class="s3">if </span><span class="s1">ub </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">_parcur_cache[</span><span class="s2">'ub'</span><span class="s1">] = u[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_parcur_cache[</span><span class="s2">'ub'</span><span class="s1">] = ub</span>
        <span class="s3">if </span><span class="s1">ue </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">_parcur_cache[</span><span class="s2">'ue'</span><span class="s1">] = u[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_parcur_cache[</span><span class="s2">'ue'</span><span class="s1">] = ue</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">_parcur_cache[</span><span class="s2">'u'</span><span class="s1">] = zeros(m</span><span class="s3">, </span><span class="s1">float)</span>
    <span class="s3">if not </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">&lt;= k &lt;= </span><span class="s5">5</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'1 &lt;= k= %d &lt;=5 must hold' </span><span class="s1">% k)</span>
    <span class="s3">if not </span><span class="s1">(-</span><span class="s5">1 </span><span class="s1">&lt;= task &lt;= </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'task must be -1, 0 or 1'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">len(w) == m) </span><span class="s3">or </span><span class="s1">(ipar == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">len(u) == m)):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'Mismatch of input dimensions'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">s </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">s = m - sqrt(</span><span class="s5">2</span><span class="s1">*m)</span>
    <span class="s3">if </span><span class="s1">t </span><span class="s3">is None and </span><span class="s1">task == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'Knots must be given for task=-1'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">t </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">_parcur_cache[</span><span class="s2">'t'</span><span class="s1">] = atleast_1d(t)</span>
    <span class="s1">n = len(_parcur_cache[</span><span class="s2">'t'</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">task == -</span><span class="s5">1 </span><span class="s3">and </span><span class="s1">n &lt; </span><span class="s5">2</span><span class="s1">*k + </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'There must be at least 2*k+2 knots for task=-1'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">m &lt;= k:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'m &gt; k must hold'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">nest </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">nest = m + </span><span class="s5">2</span><span class="s1">*k</span>

    <span class="s3">if </span><span class="s1">(task &gt;= </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">s == </span><span class="s5">0</span><span class="s1">) </span><span class="s3">or </span><span class="s1">(nest &lt; </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">per:</span>
            <span class="s1">nest = m + </span><span class="s5">2</span><span class="s1">*k</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">nest = m + k + </span><span class="s5">1</span>
    <span class="s1">nest = max(nest</span><span class="s3">, </span><span class="s5">2</span><span class="s1">*k + </span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">u = _parcur_cache[</span><span class="s2">'u'</span><span class="s1">]</span>
    <span class="s1">ub = _parcur_cache[</span><span class="s2">'ub'</span><span class="s1">]</span>
    <span class="s1">ue = _parcur_cache[</span><span class="s2">'ue'</span><span class="s1">]</span>
    <span class="s1">t = _parcur_cache[</span><span class="s2">'t'</span><span class="s1">]</span>
    <span class="s1">wrk = _parcur_cache[</span><span class="s2">'wrk'</span><span class="s1">]</span>
    <span class="s1">iwrk = _parcur_cache[</span><span class="s2">'iwrk'</span><span class="s1">]</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">o = _fitpack._parcur(ravel(transpose(x))</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">u</span><span class="s3">, </span><span class="s1">ub</span><span class="s3">, </span><span class="s1">ue</span><span class="s3">, </span><span class="s1">k</span><span class="s3">,</span>
                               <span class="s1">task</span><span class="s3">, </span><span class="s1">ipar</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">nest</span><span class="s3">, </span><span class="s1">wrk</span><span class="s3">, </span><span class="s1">iwrk</span><span class="s3">, </span><span class="s1">per)</span>
    <span class="s1">_parcur_cache[</span><span class="s2">'u'</span><span class="s1">] = o[</span><span class="s2">'u'</span><span class="s1">]</span>
    <span class="s1">_parcur_cache[</span><span class="s2">'ub'</span><span class="s1">] = o[</span><span class="s2">'ub'</span><span class="s1">]</span>
    <span class="s1">_parcur_cache[</span><span class="s2">'ue'</span><span class="s1">] = o[</span><span class="s2">'ue'</span><span class="s1">]</span>
    <span class="s1">_parcur_cache[</span><span class="s2">'t'</span><span class="s1">] = t</span>
    <span class="s1">_parcur_cache[</span><span class="s2">'wrk'</span><span class="s1">] = o[</span><span class="s2">'wrk'</span><span class="s1">]</span>
    <span class="s1">_parcur_cache[</span><span class="s2">'iwrk'</span><span class="s1">] = o[</span><span class="s2">'iwrk'</span><span class="s1">]</span>
    <span class="s1">ier = o[</span><span class="s2">'ier'</span><span class="s1">]</span>
    <span class="s1">fp = o[</span><span class="s2">'fp'</span><span class="s1">]</span>
    <span class="s1">n = len(t)</span>
    <span class="s1">u = o[</span><span class="s2">'u'</span><span class="s1">]</span>
    <span class="s1">c.shape = idim</span><span class="s3">, </span><span class="s1">n - k - </span><span class="s5">1</span>
    <span class="s1">tcku = [t</span><span class="s3">, </span><span class="s1">list(c)</span><span class="s3">, </span><span class="s1">k]</span><span class="s3">, </span><span class="s1">u</span>
    <span class="s3">if </span><span class="s1">ier &lt;= </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">quiet:</span>
        <span class="s1">warnings.warn(RuntimeWarning(_iermess[ier][</span><span class="s5">0</span><span class="s1">] +</span>
                                     <span class="s2">&quot;</span><span class="s3">\t</span><span class="s2">k=%d n=%d m=%d fp=%f s=%f&quot; </span><span class="s1">%</span>
                                     <span class="s1">(k</span><span class="s3">, </span><span class="s1">len(t)</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">s)))</span>
    <span class="s3">if </span><span class="s1">ier &gt; </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">full_output:</span>
        <span class="s3">if </span><span class="s1">ier </span><span class="s3">in </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]:</span>
            <span class="s1">warnings.warn(RuntimeWarning(_iermess[ier][</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">_iermess[ier][</span><span class="s5">1</span><span class="s1">](_iermess[ier][</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">_iermess[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">1</span><span class="s1">](_iermess[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]) </span><span class="s3">from </span><span class="s1">e</span>
    <span class="s3">if </span><span class="s1">full_output:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">tcku</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier</span><span class="s3">, </span><span class="s1">_iermess[ier][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">return </span><span class="s1">tcku</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier</span><span class="s3">, </span><span class="s1">_iermess[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">tcku</span>


<span class="s1">_curfit_cache = {</span><span class="s2">'t'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">, </span><span class="s2">'wrk'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">,</span>
                 <span class="s2">'iwrk'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">dfitpack_int)}</span>


<span class="s3">def </span><span class="s1">splrep(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w=</span><span class="s3">None, </span><span class="s1">xb=</span><span class="s3">None, </span><span class="s1">xe=</span><span class="s3">None, </span><span class="s1">k=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">task=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">s=</span><span class="s3">None, </span><span class="s1">t=</span><span class="s3">None,</span>
           <span class="s1">full_output=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">per=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">quiet=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s4"># see the docstring of `_fitpack_py/splrep`</span>
    <span class="s3">if </span><span class="s1">task &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">_curfit_cache = {}</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">y = map(atleast_1d</span><span class="s3">, </span><span class="s1">[x</span><span class="s3">, </span><span class="s1">y])</span>
    <span class="s1">m = len(x)</span>
    <span class="s3">if </span><span class="s1">w </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">w = ones(m</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s3">if </span><span class="s1">s </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s5">0.0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">w = atleast_1d(w)</span>
        <span class="s3">if </span><span class="s1">s </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">s = m - sqrt(</span><span class="s5">2</span><span class="s1">*m)</span>
    <span class="s3">if not </span><span class="s1">len(w) == m:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'len(w)=%d is not equal to m=%d' </span><span class="s1">% (len(w)</span><span class="s3">, </span><span class="s1">m))</span>
    <span class="s3">if </span><span class="s1">(m != len(y)) </span><span class="s3">or </span><span class="s1">(m != len(w)):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'Lengths of the first three arguments (x,y,w) must '</span>
                        <span class="s2">'be equal'</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">&lt;= k &lt;= </span><span class="s5">5</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'Given degree of the spline (k=%d) is not supported. '</span>
                        <span class="s2">'(1&lt;=k&lt;=5)' </span><span class="s1">% k)</span>
    <span class="s3">if </span><span class="s1">m &lt;= k:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'m &gt; k must hold'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">xb </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">xb = x[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">xe </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">xe = x[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">if not </span><span class="s1">(-</span><span class="s5">1 </span><span class="s1">&lt;= task &lt;= </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'task must be -1, 0 or 1'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">t </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">task = -</span><span class="s5">1</span>
    <span class="s3">if </span><span class="s1">task == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">t </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'Knots must be given for task=-1'</span><span class="s1">)</span>
        <span class="s1">numknots = len(t)</span>
        <span class="s1">_curfit_cache[</span><span class="s2">'t'</span><span class="s1">] = empty((numknots + </span><span class="s5">2</span><span class="s1">*k + </span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s1">_curfit_cache[</span><span class="s2">'t'</span><span class="s1">][k+</span><span class="s5">1</span><span class="s1">:-k-</span><span class="s5">1</span><span class="s1">] = t</span>
        <span class="s1">nest = len(_curfit_cache[</span><span class="s2">'t'</span><span class="s1">])</span>
    <span class="s3">elif </span><span class="s1">task == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">per:</span>
            <span class="s1">nest = max(m + </span><span class="s5">2</span><span class="s1">*k</span><span class="s3">, </span><span class="s5">2</span><span class="s1">*k + </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">nest = max(m + k + </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">*k + </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">t = empty((nest</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s1">_curfit_cache[</span><span class="s2">'t'</span><span class="s1">] = t</span>
    <span class="s3">if </span><span class="s1">task &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">per:</span>
            <span class="s1">_curfit_cache[</span><span class="s2">'wrk'</span><span class="s1">] = empty((m*(k + </span><span class="s5">1</span><span class="s1">) + nest*(</span><span class="s5">8 </span><span class="s1">+ </span><span class="s5">5</span><span class="s1">*k)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_curfit_cache[</span><span class="s2">'wrk'</span><span class="s1">] = empty((m*(k + </span><span class="s5">1</span><span class="s1">) + nest*(</span><span class="s5">7 </span><span class="s1">+ </span><span class="s5">3</span><span class="s1">*k)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s1">_curfit_cache[</span><span class="s2">'iwrk'</span><span class="s1">] = empty((nest</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dfitpack_int)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">t = _curfit_cache[</span><span class="s2">'t'</span><span class="s1">]</span>
        <span class="s1">wrk = _curfit_cache[</span><span class="s2">'wrk'</span><span class="s1">]</span>
        <span class="s1">iwrk = _curfit_cache[</span><span class="s2">'iwrk'</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;must call with task=1 only after&quot;</span>
                        <span class="s2">&quot; call with task=0,-1&quot;</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
    <span class="s3">if not </span><span class="s1">per:</span>
        <span class="s1">n</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier = dfitpack.curfit(task</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">wrk</span><span class="s3">, </span><span class="s1">iwrk</span><span class="s3">,</span>
                                        <span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">s)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier = dfitpack.percur(task</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">wrk</span><span class="s3">, </span><span class="s1">iwrk</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">s)</span>
    <span class="s1">tck = (t[:n]</span><span class="s3">, </span><span class="s1">c[:n]</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s3">if </span><span class="s1">ier &lt;= </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">quiet:</span>
        <span class="s1">_mess = (_iermess[ier][</span><span class="s5">0</span><span class="s1">] + </span><span class="s2">&quot;</span><span class="s3">\t</span><span class="s2">k=%d n=%d m=%d fp=%f s=%f&quot; </span><span class="s1">%</span>
                 <span class="s1">(k</span><span class="s3">, </span><span class="s1">len(t)</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">s))</span>
        <span class="s1">warnings.warn(RuntimeWarning(_mess))</span>
    <span class="s3">if </span><span class="s1">ier &gt; </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">full_output:</span>
        <span class="s3">if </span><span class="s1">ier </span><span class="s3">in </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]:</span>
            <span class="s1">warnings.warn(RuntimeWarning(_iermess[ier][</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">_iermess[ier][</span><span class="s5">1</span><span class="s1">](_iermess[ier][</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">_iermess[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">1</span><span class="s1">](_iermess[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]) </span><span class="s3">from </span><span class="s1">e</span>
    <span class="s3">if </span><span class="s1">full_output:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier</span><span class="s3">, </span><span class="s1">_iermess[ier][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">return </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier</span><span class="s3">, </span><span class="s1">_iermess[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">tck</span>


<span class="s3">def </span><span class="s1">splev(x</span><span class="s3">, </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">der=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ext=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s4"># see the docstring of `_fitpack_py/splev`</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k = tck</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">c[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">parametric = </span><span class="s3">True</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s1">parametric = </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">parametric:</span>
        <span class="s3">return </span><span class="s1">list(map(</span><span class="s3">lambda </span><span class="s1">c</span><span class="s3">, </span><span class="s1">x=x</span><span class="s3">, </span><span class="s1">t=t</span><span class="s3">, </span><span class="s1">k=k</span><span class="s3">, </span><span class="s1">der=der:</span>
                        <span class="s1">splev(x</span><span class="s3">, </span><span class="s1">[t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k]</span><span class="s3">, </span><span class="s1">der</span><span class="s3">, </span><span class="s1">ext)</span><span class="s3">, </span><span class="s1">c))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= der &lt;= k):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;0&lt;=der=%d&lt;=k=%d must hold&quot; </span><span class="s1">% (der</span><span class="s3">, </span><span class="s1">k))</span>
        <span class="s3">if </span><span class="s1">ext </span><span class="s3">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;ext = %s not in (0, 1, 2, 3) &quot; </span><span class="s1">% ext)</span>

        <span class="s1">x = asarray(x)</span>
        <span class="s1">shape = x.shape</span>
        <span class="s1">x = atleast_1d(x).ravel()</span>
        <span class="s3">if </span><span class="s1">der == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">y</span><span class="s3">, </span><span class="s1">ier = dfitpack.splev(t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">ext)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">y</span><span class="s3">, </span><span class="s1">ier = dfitpack.splder(t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">der</span><span class="s3">, </span><span class="s1">ext)</span>

        <span class="s3">if </span><span class="s1">ier == </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid input data&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">ier == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Found x value not in the domain&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">ier:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;An error occurred&quot;</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">y.reshape(shape)</span>


<span class="s3">def </span><span class="s1">splint(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s4"># see the docstring of `_fitpack_py/splint`</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k = tck</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">c[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">parametric = </span><span class="s3">True</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s1">parametric = </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">parametric:</span>
        <span class="s3">return </span><span class="s1">list(map(</span><span class="s3">lambda </span><span class="s1">c</span><span class="s3">, </span><span class="s1">a=a</span><span class="s3">, </span><span class="s1">b=b</span><span class="s3">, </span><span class="s1">t=t</span><span class="s3">, </span><span class="s1">k=k:</span>
                        <span class="s1">splint(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">[t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k])</span><span class="s3">, </span><span class="s1">c))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">aint</span><span class="s3">, </span><span class="s1">wrk = dfitpack.splint(t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s3">if </span><span class="s1">full_output:</span>
            <span class="s3">return </span><span class="s1">aint</span><span class="s3">, </span><span class="s1">wrk</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">aint</span>


<span class="s3">def </span><span class="s1">sproot(tck</span><span class="s3">, </span><span class="s1">mest=</span><span class="s5">10</span><span class="s1">):</span>
    <span class="s4"># see the docstring of `_fitpack_py/sproot`</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k = tck</span>
    <span class="s3">if </span><span class="s1">k != </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;sproot works only for cubic (k=3) splines&quot;</span><span class="s1">)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">c[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">parametric = </span><span class="s3">True</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s1">parametric = </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">parametric:</span>
        <span class="s3">return </span><span class="s1">list(map(</span><span class="s3">lambda </span><span class="s1">c</span><span class="s3">, </span><span class="s1">t=t</span><span class="s3">, </span><span class="s1">k=k</span><span class="s3">, </span><span class="s1">mest=mest:</span>
                        <span class="s1">sproot([t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k]</span><span class="s3">, </span><span class="s1">mest)</span><span class="s3">, </span><span class="s1">c))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">len(t) &lt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;The number of knots %d&gt;=8&quot; </span><span class="s1">% len(t))</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">ier = dfitpack.sproot(t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">mest)</span>
        <span class="s3">if </span><span class="s1">ier == </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Invalid input data. &quot;</span>
                            <span class="s2">&quot;t1&lt;=..&lt;=t4&lt;t5&lt;..&lt;tn-3&lt;=..&lt;=tn must hold.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">ier == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">z[:m]</span>
        <span class="s3">if </span><span class="s1">ier == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">warnings.warn(RuntimeWarning(</span><span class="s2">&quot;The number of zeros exceeds mest&quot;</span><span class="s1">))</span>
            <span class="s3">return </span><span class="s1">z[:m]</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Unknown error&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">spalde(x</span><span class="s3">, </span><span class="s1">tck):</span>
    <span class="s4"># see the docstring of `_fitpack_py/spalde`</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k = tck</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">c[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">parametric = </span><span class="s3">True</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s1">parametric = </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">parametric:</span>
        <span class="s3">return </span><span class="s1">list(map(</span><span class="s3">lambda </span><span class="s1">c</span><span class="s3">, </span><span class="s1">x=x</span><span class="s3">, </span><span class="s1">t=t</span><span class="s3">, </span><span class="s1">k=k:</span>
                        <span class="s1">spalde(x</span><span class="s3">, </span><span class="s1">[t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k])</span><span class="s3">, </span><span class="s1">c))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">x = atleast_1d(x)</span>
        <span class="s3">if </span><span class="s1">len(x) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">list(map(</span><span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">tck=tck: spalde(x</span><span class="s3">, </span><span class="s1">tck)</span><span class="s3">, </span><span class="s1">x))</span>
        <span class="s1">d</span><span class="s3">, </span><span class="s1">ier = dfitpack.spalde(t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">x[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">ier == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">d</span>
        <span class="s3">if </span><span class="s1">ier == </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Invalid input data. t(k)&lt;=x&lt;=t(n-k+1) must hold.&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Unknown error&quot;</span><span class="s1">)</span>

<span class="s4"># def _curfit(x,y,w=None,xb=None,xe=None,k=3,task=0,s=None,t=None,</span>
<span class="s4">#           full_output=0,nest=None,per=0,quiet=1):</span>


<span class="s1">_surfit_cache = {</span><span class="s2">'tx'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">, </span><span class="s2">'ty'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">,</span>
                 <span class="s2">'wrk'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">, </span><span class="s2">'iwrk'</span><span class="s1">: array([]</span><span class="s3">, </span><span class="s1">dfitpack_int)}</span>


<span class="s3">def </span><span class="s1">bisplrep(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w=</span><span class="s3">None, </span><span class="s1">xb=</span><span class="s3">None, </span><span class="s1">xe=</span><span class="s3">None, </span><span class="s1">yb=</span><span class="s3">None, </span><span class="s1">ye=</span><span class="s3">None,</span>
             <span class="s1">kx=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">ky=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">task=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">s=</span><span class="s3">None, </span><span class="s1">eps=</span><span class="s5">1e-16</span><span class="s3">, </span><span class="s1">tx=</span><span class="s3">None, </span><span class="s1">ty=</span><span class="s3">None,</span>
             <span class="s1">full_output=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nxest=</span><span class="s3">None, </span><span class="s1">nyest=</span><span class="s3">None, </span><span class="s1">quiet=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find a bivariate B-spline representation of a surface. 
 
    Given a set of data points (x[i], y[i], z[i]) representing a surface 
    z=f(x,y), compute a B-spline representation of the surface. Based on 
    the routine SURFIT from FITPACK. 
 
    Parameters 
    ---------- 
    x, y, z : ndarray 
        Rank-1 arrays of data points. 
    w : ndarray, optional 
        Rank-1 array of weights. By default ``w=np.ones(len(x))``. 
    xb, xe : float, optional 
        End points of approximation interval in `x`. 
        By default ``xb = x.min(), xe=x.max()``. 
    yb, ye : float, optional 
        End points of approximation interval in `y`. 
        By default ``yb=y.min(), ye = y.max()``. 
    kx, ky : int, optional 
        The degrees of the spline (1 &lt;= kx, ky &lt;= 5). 
        Third order (kx=ky=3) is recommended. 
    task : int, optional 
        If task=0, find knots in x and y and coefficients for a given 
        smoothing factor, s. 
        If task=1, find knots and coefficients for another value of the 
        smoothing factor, s.  bisplrep must have been previously called 
        with task=0 or task=1. 
        If task=-1, find coefficients for a given set of knots tx, ty. 
    s : float, optional 
        A non-negative smoothing factor. If weights correspond 
        to the inverse of the standard-deviation of the errors in z, 
        then a good s-value should be found in the range 
        ``(m-sqrt(2*m),m+sqrt(2*m))`` where m=len(x). 
    eps : float, optional 
        A threshold for determining the effective rank of an 
        over-determined linear system of equations (0 &lt; eps &lt; 1). 
        `eps` is not likely to need changing. 
    tx, ty : ndarray, optional 
        Rank-1 arrays of the knots of the spline for task=-1 
    full_output : int, optional 
        Non-zero to return optional outputs. 
    nxest, nyest : int, optional 
        Over-estimates of the total number of knots. If None then 
        ``nxest = max(kx+sqrt(m/2),2*kx+3)``, 
        ``nyest = max(ky+sqrt(m/2),2*ky+3)``. 
    quiet : int, optional 
        Non-zero to suppress printing of messages. 
 
    Returns 
    ------- 
    tck : array_like 
        A list [tx, ty, c, kx, ky] containing the knots (tx, ty) and 
        coefficients (c) of the bivariate B-spline representation of the 
        surface along with the degree of the spline. 
    fp : ndarray 
        The weighted sum of squared residuals of the spline approximation. 
    ier : int 
        An integer flag about splrep success. Success is indicated if 
        ier&lt;=0. If ier in [1,2,3] an error occurred but was not raised. 
        Otherwise an error is raised. 
    msg : str 
        A message corresponding to the integer flag, ier. 
 
    See Also 
    -------- 
    splprep, splrep, splint, sproot, splev 
    UnivariateSpline, BivariateSpline 
 
    Notes 
    ----- 
    See `bisplev` to evaluate the value of the B-spline given its tck 
    representation. 
 
    If the input data is such that input dimensions have incommensurate 
    units and differ by many orders of magnitude, the interpolant may have 
    numerical artifacts. Consider rescaling the data before interpolation. 
 
    References 
    ---------- 
    .. [1] Dierckx P.:An algorithm for surface fitting with spline functions 
       Ima J. Numer. Anal. 1 (1981) 267-283. 
    .. [2] Dierckx P.:An algorithm for surface fitting with spline functions 
       report tw50, Dept. Computer Science,K.U.Leuven, 1980. 
    .. [3] Dierckx P.:Curve and surface fitting with splines, Monographs on 
       Numerical Analysis, Oxford University Press, 1993. 
 
    Examples 
    -------- 
    Examples are given :ref:`in the tutorial &lt;tutorial-interpolate_2d_spline&gt;`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z = map(ravel</span><span class="s3">, </span><span class="s1">[x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z])  </span><span class="s4"># ensure 1-d arrays.</span>
    <span class="s1">m = len(x)</span>
    <span class="s3">if not </span><span class="s1">(m == len(y) == len(z)):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'len(x)==len(y)==len(z) must hold.'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">w </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">w = ones(m</span><span class="s3">, </span><span class="s1">float)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">w = atleast_1d(w)</span>
    <span class="s3">if not </span><span class="s1">len(w) == m:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'len(w)=%d is not equal to m=%d' </span><span class="s1">% (len(w)</span><span class="s3">, </span><span class="s1">m))</span>
    <span class="s3">if </span><span class="s1">xb </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">xb = x.min()</span>
    <span class="s3">if </span><span class="s1">xe </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">xe = x.max()</span>
    <span class="s3">if </span><span class="s1">yb </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">yb = y.min()</span>
    <span class="s3">if </span><span class="s1">ye </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">ye = y.max()</span>
    <span class="s3">if not </span><span class="s1">(-</span><span class="s5">1 </span><span class="s1">&lt;= task &lt;= </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'task must be -1, 0 or 1'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">s </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">s = m - sqrt(</span><span class="s5">2</span><span class="s1">*m)</span>
    <span class="s3">if </span><span class="s1">tx </span><span class="s3">is None and </span><span class="s1">task == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'Knots_x must be given for task=-1'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">tx </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">_surfit_cache[</span><span class="s2">'tx'</span><span class="s1">] = atleast_1d(tx)</span>
    <span class="s1">nx = len(_surfit_cache[</span><span class="s2">'tx'</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">ty </span><span class="s3">is None and </span><span class="s1">task == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'Knots_y must be given for task=-1'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">ty </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">_surfit_cache[</span><span class="s2">'ty'</span><span class="s1">] = atleast_1d(ty)</span>
    <span class="s1">ny = len(_surfit_cache[</span><span class="s2">'ty'</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">task == -</span><span class="s5">1 </span><span class="s3">and </span><span class="s1">nx &lt; </span><span class="s5">2</span><span class="s1">*kx+</span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'There must be at least 2*kx+2 knots_x for task=-1'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">task == -</span><span class="s5">1 </span><span class="s3">and </span><span class="s1">ny &lt; </span><span class="s5">2</span><span class="s1">*ky+</span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'There must be at least 2*ky+2 knots_x for task=-1'</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">((</span><span class="s5">1 </span><span class="s1">&lt;= kx &lt;= </span><span class="s5">5</span><span class="s1">) </span><span class="s3">and </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">&lt;= ky &lt;= </span><span class="s5">5</span><span class="s1">)):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'Given degree of the spline (kx,ky=%d,%d) is not '</span>
                        <span class="s2">'supported. (1&lt;=k&lt;=5)' </span><span class="s1">% (kx</span><span class="s3">, </span><span class="s1">ky))</span>
    <span class="s3">if </span><span class="s1">m &lt; (kx + </span><span class="s5">1</span><span class="s1">)*(ky + </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'m &gt;= (kx+1)(ky+1) must hold'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">nxest </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">nxest = int(kx + sqrt(m/</span><span class="s5">2</span><span class="s1">))</span>
    <span class="s3">if </span><span class="s1">nyest </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">nyest = int(ky + sqrt(m/</span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">nxest</span><span class="s3">, </span><span class="s1">nyest = max(nxest</span><span class="s3">, </span><span class="s5">2</span><span class="s1">*kx + </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">max(nyest</span><span class="s3">, </span><span class="s5">2</span><span class="s1">*ky + </span><span class="s5">3</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">task &gt;= </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">s == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">nxest = int(kx + sqrt(</span><span class="s5">3</span><span class="s1">*m))</span>
        <span class="s1">nyest = int(ky + sqrt(</span><span class="s5">3</span><span class="s1">*m))</span>
    <span class="s3">if </span><span class="s1">task == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">_surfit_cache[</span><span class="s2">'tx'</span><span class="s1">] = atleast_1d(tx)</span>
        <span class="s1">_surfit_cache[</span><span class="s2">'ty'</span><span class="s1">] = atleast_1d(ty)</span>
    <span class="s1">tx</span><span class="s3">, </span><span class="s1">ty = _surfit_cache[</span><span class="s2">'tx'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_surfit_cache[</span><span class="s2">'ty'</span><span class="s1">]</span>
    <span class="s1">wrk = _surfit_cache[</span><span class="s2">'wrk'</span><span class="s1">]</span>
    <span class="s1">u = nxest - kx - </span><span class="s5">1</span>
    <span class="s1">v = nyest - ky - </span><span class="s5">1</span>
    <span class="s1">km = max(kx</span><span class="s3">, </span><span class="s1">ky) + </span><span class="s5">1</span>
    <span class="s1">ne = max(nxest</span><span class="s3">, </span><span class="s1">nyest)</span>
    <span class="s1">bx</span><span class="s3">, </span><span class="s1">by = kx*v + ky + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">ky*u + kx + </span><span class="s5">1</span>
    <span class="s1">b1</span><span class="s3">, </span><span class="s1">b2 = bx</span><span class="s3">, </span><span class="s1">bx + v - ky</span>
    <span class="s3">if </span><span class="s1">bx &gt; by:</span>
        <span class="s1">b1</span><span class="s3">, </span><span class="s1">b2 = by</span><span class="s3">, </span><span class="s1">by + u - kx</span>
    <span class="s1">msg = </span><span class="s2">&quot;Too many data points to interpolate&quot;</span>
    <span class="s1">lwrk1 = _int_overflow(u*v*(</span><span class="s5">2 </span><span class="s1">+ b1 + b2) +</span>
                          <span class="s5">2</span><span class="s1">*(u + v + km*(m + ne) + ne - kx - ky) + b2 + </span><span class="s5">1</span><span class="s3">,</span>
                          <span class="s1">msg=msg)</span>
    <span class="s1">lwrk2 = _int_overflow(u*v*(b2 + </span><span class="s5">1</span><span class="s1">) + b2</span><span class="s3">, </span><span class="s1">msg=msg)</span>
    <span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">o = _fitpack._surfit(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">, </span><span class="s1">ye</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">,</span>
                                    <span class="s1">task</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">, </span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">nxest</span><span class="s3">, </span><span class="s1">nyest</span><span class="s3">,</span>
                                    <span class="s1">wrk</span><span class="s3">, </span><span class="s1">lwrk1</span><span class="s3">, </span><span class="s1">lwrk2)</span>
    <span class="s1">_curfit_cache[</span><span class="s2">'tx'</span><span class="s1">] = tx</span>
    <span class="s1">_curfit_cache[</span><span class="s2">'ty'</span><span class="s1">] = ty</span>
    <span class="s1">_curfit_cache[</span><span class="s2">'wrk'</span><span class="s1">] = o[</span><span class="s2">'wrk'</span><span class="s1">]</span>
    <span class="s1">ier</span><span class="s3">, </span><span class="s1">fp = o[</span><span class="s2">'ier'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">o[</span><span class="s2">'fp'</span><span class="s1">]</span>
    <span class="s1">tck = [tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky]</span>

    <span class="s1">ierm = min(</span><span class="s5">11</span><span class="s3">, </span><span class="s1">max(-</span><span class="s5">3</span><span class="s3">, </span><span class="s1">ier))</span>
    <span class="s3">if </span><span class="s1">ierm &lt;= </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">quiet:</span>
        <span class="s1">_mess = (_iermess2[ierm][</span><span class="s5">0</span><span class="s1">] +</span>
                 <span class="s2">&quot;</span><span class="s3">\t</span><span class="s2">kx,ky=%d,%d nx,ny=%d,%d m=%d fp=%f s=%f&quot; </span><span class="s1">%</span>
                 <span class="s1">(kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">len(tx)</span><span class="s3">, </span><span class="s1">len(ty)</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">s))</span>
        <span class="s1">warnings.warn(RuntimeWarning(_mess))</span>
    <span class="s3">if </span><span class="s1">ierm &gt; </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">full_output:</span>
        <span class="s3">if </span><span class="s1">ier </span><span class="s3">in </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">]:</span>
            <span class="s1">_mess = (</span><span class="s2">&quot;</span><span class="s3">\n\t</span><span class="s2">kx,ky=%d,%d nx,ny=%d,%d m=%d fp=%f s=%f&quot; </span><span class="s1">%</span>
                     <span class="s1">(kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">len(tx)</span><span class="s3">, </span><span class="s1">len(ty)</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">s))</span>
            <span class="s1">warnings.warn(RuntimeWarning(_iermess2[ierm][</span><span class="s5">0</span><span class="s1">] + _mess))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">_iermess2[ierm][</span><span class="s5">1</span><span class="s1">](_iermess2[ierm][</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">_iermess2[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">1</span><span class="s1">](_iermess2[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]) </span><span class="s3">from </span><span class="s1">e</span>
    <span class="s3">if </span><span class="s1">full_output:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier</span><span class="s3">, </span><span class="s1">_iermess2[ierm][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">return </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier</span><span class="s3">, </span><span class="s1">_iermess2[</span><span class="s2">'unknown'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">tck</span>


<span class="s3">def </span><span class="s1">bisplev(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">dx=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dy=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a bivariate B-spline and its derivatives. 
 
    Return a rank-2 array of spline function values (or spline derivative 
    values) at points given by the cross-product of the rank-1 arrays `x` and 
    `y`.  In special cases, return an array or just a float if either `x` or 
    `y` or both are floats.  Based on BISPEV and PARDER from FITPACK. 
 
    Parameters 
    ---------- 
    x, y : ndarray 
        Rank-1 arrays specifying the domain over which to evaluate the 
        spline or its derivative. 
    tck : tuple 
        A sequence of length 5 returned by `bisplrep` containing the knot 
        locations, the coefficients, and the degree of the spline: 
        [tx, ty, c, kx, ky]. 
    dx, dy : int, optional 
        The orders of the partial derivatives in `x` and `y` respectively. 
 
    Returns 
    ------- 
    vals : ndarray 
        The B-spline or its derivative evaluated over the set formed by 
        the cross-product of `x` and `y`. 
 
    See Also 
    -------- 
    splprep, splrep, splint, sproot, splev 
    UnivariateSpline, BivariateSpline 
 
    Notes 
    ----- 
        See `bisplrep` to generate the `tck` representation. 
 
    References 
    ---------- 
    .. [1] Dierckx P. : An algorithm for surface fitting 
       with spline functions 
       Ima J. Numer. Anal. 1 (1981) 267-283. 
    .. [2] Dierckx P. : An algorithm for surface fitting 
       with spline functions 
       report tw50, Dept. Computer Science,K.U.Leuven, 1980. 
    .. [3] Dierckx P. : Curve and surface fitting with splines, 
       Monographs on Numerical Analysis, Oxford University Press, 1993. 
 
    Examples 
    -------- 
    Examples are given :ref:`in the tutorial &lt;tutorial-interpolate_2d_spline&gt;`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky = tck</span>
    <span class="s3">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= dx &lt; kx):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;0 &lt;= dx = %d &lt; kx = %d must hold&quot; </span><span class="s1">% (dx</span><span class="s3">, </span><span class="s1">kx))</span>
    <span class="s3">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= dy &lt; ky):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;0 &lt;= dy = %d &lt; ky = %d must hold&quot; </span><span class="s1">% (dy</span><span class="s3">, </span><span class="s1">ky))</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">y = map(atleast_1d</span><span class="s3">, </span><span class="s1">[x</span><span class="s3">, </span><span class="s1">y])</span>
    <span class="s3">if </span><span class="s1">(len(x.shape) != </span><span class="s5">1</span><span class="s1">) </span><span class="s3">or </span><span class="s1">(len(y.shape) != </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;First two entries should be rank-1 arrays.&quot;</span><span class="s1">)</span>
    <span class="s1">z</span><span class="s3">, </span><span class="s1">ier = _fitpack._bispev(tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy)</span>
    <span class="s3">if </span><span class="s1">ier == </span><span class="s5">10</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid input data&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">ier:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;An error occurred&quot;</span><span class="s1">)</span>
    <span class="s1">z.shape = len(x)</span><span class="s3">, </span><span class="s1">len(y)</span>
    <span class="s3">if </span><span class="s1">len(z) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">z</span>
    <span class="s3">if </span><span class="s1">len(z[</span><span class="s5">0</span><span class="s1">]) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">z[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">z[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">dblint(xa</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">, </span><span class="s1">ya</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">, </span><span class="s1">tck):</span>
    <span class="s0">&quot;&quot;&quot;Evaluate the integral of a spline over area [xa,xb] x [ya,yb]. 
 
    Parameters 
    ---------- 
    xa, xb : float 
        The end-points of the x integration interval. 
    ya, yb : float 
        The end-points of the y integration interval. 
    tck : list [tx, ty, c, kx, ky] 
        A sequence of length 5 returned by bisplrep containing the knot 
        locations tx, ty, the coefficients c, and the degrees kx, ky 
        of the spline. 
 
    Returns 
    ------- 
    integ : float 
        The value of the resulting integral. 
    &quot;&quot;&quot;</span>
    <span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky = tck</span>
    <span class="s3">return </span><span class="s1">dfitpack.dblint(tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">xa</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">, </span><span class="s1">ya</span><span class="s3">, </span><span class="s1">yb)</span>


<span class="s3">def </span><span class="s1">insert(x</span><span class="s3">, </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">m=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">per=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s4"># see the docstring of `_fitpack_py/insert`</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k = tck</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">c[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">parametric = </span><span class="s3">True</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s1">parametric = </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">parametric:</span>
        <span class="s1">cc = []</span>
        <span class="s3">for </span><span class="s1">c_vals </span><span class="s3">in </span><span class="s1">c:</span>
            <span class="s1">tt</span><span class="s3">, </span><span class="s1">cc_val</span><span class="s3">, </span><span class="s1">kk = insert(x</span><span class="s3">, </span><span class="s1">[t</span><span class="s3">, </span><span class="s1">c_vals</span><span class="s3">, </span><span class="s1">k]</span><span class="s3">, </span><span class="s1">m)</span>
            <span class="s1">cc.append(cc_val)</span>
        <span class="s3">return </span><span class="s1">(tt</span><span class="s3">, </span><span class="s1">cc</span><span class="s3">, </span><span class="s1">kk)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">tt</span><span class="s3">, </span><span class="s1">cc</span><span class="s3">, </span><span class="s1">ier = _fitpack._insert(per</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">m)</span>
        <span class="s3">if </span><span class="s1">ier == </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid input data&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">ier:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;An error occurred&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">(tt</span><span class="s3">, </span><span class="s1">cc</span><span class="s3">, </span><span class="s1">k)</span>


<span class="s3">def </span><span class="s1">splder(tck</span><span class="s3">, </span><span class="s1">n=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s4"># see the docstring of `_fitpack_py/splder`</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">splantider(tck</span><span class="s3">, </span><span class="s1">-n)</span>

    <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k = tck</span>

    <span class="s3">if </span><span class="s1">n &gt; k:</span>
        <span class="s3">raise </span><span class="s1">ValueError((</span><span class="s2">&quot;Order of derivative (n = {!r}) must be &lt;= &quot;</span>
                          <span class="s2">&quot;order of spline (k = {!r})&quot;</span><span class="s1">).format(n</span><span class="s3">, </span><span class="s1">tck[</span><span class="s5">2</span><span class="s1">]))</span>

    <span class="s4"># Extra axes for the trailing dims of the `c` array:</span>
    <span class="s1">sh = (slice(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span><span class="s1">) + ((</span><span class="s3">None,</span><span class="s1">)*len(c.shape[</span><span class="s5">1</span><span class="s1">:]))</span>

    <span class="s3">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s3">, </span><span class="s1">divide=</span><span class="s2">'raise'</span><span class="s1">):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(n):</span>
                <span class="s4"># See e.g. Schumaker, Spline Functions: Basic Theory, Chapter 5</span>

                <span class="s4"># Compute the denominator in the differentiation formula.</span>
                <span class="s4"># (and append traling dims, if necessary)</span>
                <span class="s1">dt = t[k+</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">] - t[</span><span class="s5">1</span><span class="s1">:-k-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">dt = dt[sh]</span>
                <span class="s4"># Compute the new coefficients</span>
                <span class="s1">c = (c[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">-k] - c[:-</span><span class="s5">2</span><span class="s1">-k]) * k / dt</span>
                <span class="s4"># Pad coefficient array to same size as knots (FITPACK</span>
                <span class="s4"># convention)</span>
                <span class="s1">c = np.r_[c</span><span class="s3">, </span><span class="s1">np.zeros((k</span><span class="s3">,</span><span class="s1">) + c.shape[</span><span class="s5">1</span><span class="s1">:])]</span>
                <span class="s4"># Adjust knots</span>
                <span class="s1">t = t[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">k -= </span><span class="s5">1</span>
        <span class="s3">except </span><span class="s1">FloatingPointError </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">raise </span><span class="s1">ValueError((</span><span class="s2">&quot;The spline has internal repeated knots &quot;</span>
                              <span class="s2">&quot;and is not differentiable %d times&quot;</span><span class="s1">) % n) </span><span class="s3">from </span><span class="s1">e</span>

    <span class="s3">return </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span>


<span class="s3">def </span><span class="s1">splantider(tck</span><span class="s3">, </span><span class="s1">n=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s4"># see the docstring of `_fitpack_py/splantider`</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">splder(tck</span><span class="s3">, </span><span class="s1">-n)</span>

    <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k = tck</span>

    <span class="s4"># Extra axes for the trailing dims of the `c` array:</span>
    <span class="s1">sh = (slice(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span><span class="s1">) + (</span><span class="s3">None,</span><span class="s1">)*len(c.shape[</span><span class="s5">1</span><span class="s1">:])</span>

    <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(n):</span>
        <span class="s4"># This is the inverse set of operations to splder.</span>

        <span class="s4"># Compute the multiplier in the antiderivative formula.</span>
        <span class="s1">dt = t[k+</span><span class="s5">1</span><span class="s1">:] - t[:-k-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">dt = dt[sh]</span>
        <span class="s4"># Compute the new coefficients</span>
        <span class="s1">c = np.cumsum(c[:-k-</span><span class="s5">1</span><span class="s1">] * dt</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">) / (k + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">c = np.r_[np.zeros((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">) + c.shape[</span><span class="s5">1</span><span class="s1">:])</span><span class="s3">,</span>
                  <span class="s1">c</span><span class="s3">,</span>
                  <span class="s1">[c[-</span><span class="s5">1</span><span class="s1">]] * (k+</span><span class="s5">2</span><span class="s1">)]</span>
        <span class="s4"># New knots</span>
        <span class="s1">t = np.r_[t[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">t[-</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s1">k += </span><span class="s5">1</span>

    <span class="s3">return </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span>
</pre>
</body>
</html>