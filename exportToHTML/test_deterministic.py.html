<html>
<head>
<title>test_deterministic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_deterministic.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s0">import </span><span class="s1">PD_LT_1_0_0</span><span class="s0">, </span><span class="s1">is_int_index</span>
<span class="s0">from </span><span class="s1">statsmodels.compat.pytest </span><span class="s0">import </span><span class="s1">pytest_warns</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Hashable</span><span class="s0">, </span><span class="s1">Tuple</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">statsmodels.tsa.deterministic </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">CalendarFourier</span><span class="s0">,</span>
    <span class="s1">CalendarSeasonality</span><span class="s0">,</span>
    <span class="s1">CalendarTimeTrend</span><span class="s0">,</span>
    <span class="s1">DeterministicProcess</span><span class="s0">,</span>
    <span class="s1">DeterministicTerm</span><span class="s0">,</span>
    <span class="s1">Fourier</span><span class="s0">,</span>
    <span class="s1">Seasonality</span><span class="s0">,</span>
    <span class="s1">TimeTrend</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s1">@pytest.fixture(scope=</span><span class="s2">&quot;module&quot;</span><span class="s0">, </span><span class="s1">params=[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">time_index(request):</span>
    <span class="s1">idx = pd.date_range(</span><span class="s2">&quot;2000-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">833</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">request.param:</span>
        <span class="s0">return </span><span class="s1">idx.to_period(</span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">idx</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">scope=</span><span class="s2">&quot;module&quot;</span><span class="s0">, </span><span class="s1">params=[</span><span class="s2">&quot;range&quot;</span><span class="s0">, </span><span class="s2">&quot;period&quot;</span><span class="s0">, </span><span class="s2">&quot;datetime&quot;</span><span class="s0">, </span><span class="s2">&quot;fib&quot;</span><span class="s0">, </span><span class="s2">&quot;int64&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">index(request):</span>
    <span class="s1">param = request.param</span>
    <span class="s0">if </span><span class="s1">param </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;period&quot;</span><span class="s0">, </span><span class="s2">&quot;datetime&quot;</span><span class="s1">):</span>
        <span class="s1">idx = pd.date_range(</span><span class="s2">&quot;2000-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">137</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">param == </span><span class="s2">&quot;period&quot;</span><span class="s1">:</span>
            <span class="s1">idx = idx.to_period(</span><span class="s2">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">param == </span><span class="s2">&quot;range&quot;</span><span class="s1">:</span>
        <span class="s1">idx = pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">123</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">param == </span><span class="s2">&quot;int64&quot;</span><span class="s1">:</span>
        <span class="s1">idx = pd.Index(np.arange(</span><span class="s3">123</span><span class="s1">))</span>
    <span class="s0">elif </span><span class="s1">param == </span><span class="s2">&quot;fib&quot;</span><span class="s1">:</span>
        <span class="s1">fib = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">113</span><span class="s1">):</span>
            <span class="s1">fib.append(fib[-</span><span class="s3">2</span><span class="s1">] + fib[-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">idx = pd.Index(fib)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>
    <span class="s0">return </span><span class="s1">idx</span>


<span class="s1">@pytest.fixture(scope=</span><span class="s2">&quot;module&quot;</span><span class="s0">, </span><span class="s1">params=[</span><span class="s0">None, </span><span class="s2">&quot;period&quot;</span><span class="s0">, False, </span><span class="s2">&quot;list&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">forecast_index(request):</span>
    <span class="s1">idx = pd.date_range(</span><span class="s2">&quot;2000-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">400</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">request.param </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return None</span>
    <span class="s0">elif </span><span class="s1">request.param == </span><span class="s2">&quot;period&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">idx.to_period(</span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">request.param == </span><span class="s2">&quot;list&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">list(idx)</span>
    <span class="s0">return </span><span class="s1">idx</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s0">def </span><span class="s1">test_time_trend_smoke(index</span><span class="s0">, </span><span class="s1">forecast_index):</span>
    <span class="s1">tt = TimeTrend(</span><span class="s0">True, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">tt.in_sample(index)</span>
    <span class="s1">steps = </span><span class="s3">83 </span><span class="s0">if </span><span class="s1">forecast_index </span><span class="s0">is None else </span><span class="s1">len(forecast_index)</span>
    <span class="s1">warn = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">is_int_index(index)</span>
        <span class="s0">and </span><span class="s1">np.any(np.diff(index) != </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">or </span><span class="s1">(</span>
            <span class="s1">type(index) </span><span class="s0">is </span><span class="s1">pd.Index</span>
            <span class="s0">and </span><span class="s1">max(index) &gt; </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">63</span>
            <span class="s0">and </span><span class="s1">forecast_index </span><span class="s0">is None</span>
        <span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s1">warn = UserWarning</span>
    <span class="s0">with </span><span class="s1">pytest_warns(warn):</span>
        <span class="s1">tt.out_of_sample(steps</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">forecast_index)</span>
    <span class="s1">str(tt)</span>
    <span class="s1">hash(tt)</span>
    <span class="s0">assert </span><span class="s1">isinstance(tt.order</span><span class="s0">, </span><span class="s1">int)</span>
    <span class="s0">assert </span><span class="s1">isinstance(tt._constant</span><span class="s0">, </span><span class="s1">bool)</span>
    <span class="s0">assert </span><span class="s1">TimeTrend.from_string(</span><span class="s2">&quot;ctt&quot;</span><span class="s1">) == tt</span>
    <span class="s0">assert </span><span class="s1">TimeTrend.from_string(</span><span class="s2">&quot;ct&quot;</span><span class="s1">) != tt</span>
    <span class="s0">assert </span><span class="s1">TimeTrend.from_string(</span><span class="s2">&quot;t&quot;</span><span class="s1">) != tt</span>
    <span class="s0">assert </span><span class="s1">TimeTrend.from_string(</span><span class="s2">&quot;n&quot;</span><span class="s1">) != tt</span>
    <span class="s0">assert </span><span class="s1">Seasonality(</span><span class="s3">12</span><span class="s1">) != tt</span>
    <span class="s1">tt0 = TimeTrend(</span><span class="s0">False, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">tt0.in_sample(index)</span>
    <span class="s1">str(tt0)</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s0">def </span><span class="s1">test_seasonality_smoke(index</span><span class="s0">, </span><span class="s1">forecast_index):</span>
    <span class="s1">s = Seasonality(</span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">s.in_sample(index)</span>
    <span class="s1">steps = </span><span class="s3">83 </span><span class="s0">if </span><span class="s1">forecast_index </span><span class="s0">is None else </span><span class="s1">len(forecast_index)</span>
    <span class="s1">warn = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">is_int_index(index)</span>
        <span class="s0">and </span><span class="s1">np.any(np.diff(index) != </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">or </span><span class="s1">(</span>
            <span class="s1">type(index) </span><span class="s0">is </span><span class="s1">pd.Index</span>
            <span class="s0">and </span><span class="s1">max(index) &gt; </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">63</span>
            <span class="s0">and </span><span class="s1">forecast_index </span><span class="s0">is None</span>
        <span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s1">warn = UserWarning</span>
    <span class="s0">with </span><span class="s1">pytest_warns(warn):</span>
        <span class="s1">s.out_of_sample(steps</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">forecast_index)</span>
    <span class="s0">assert </span><span class="s1">isinstance(s.period</span><span class="s0">, </span><span class="s1">int)</span>
    <span class="s1">str(s)</span>
    <span class="s1">hash(s)</span>
    <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex)) </span><span class="s0">and </span><span class="s1">index.freq:</span>
        <span class="s1">s = Seasonality.from_index(index)</span>
        <span class="s1">s.in_sample(index)</span>
        <span class="s1">s.out_of_sample(steps</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">forecast_index)</span>
        <span class="s1">Seasonality.from_index(list(index))</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s0">def </span><span class="s1">test_fourier_smoke(index</span><span class="s0">, </span><span class="s1">forecast_index):</span>
    <span class="s1">f = Fourier(</span><span class="s3">12</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">f.in_sample(index)</span>
    <span class="s1">steps = </span><span class="s3">83 </span><span class="s0">if </span><span class="s1">forecast_index </span><span class="s0">is None else </span><span class="s1">len(forecast_index)</span>
    <span class="s1">warn = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">is_int_index(index)</span>
        <span class="s0">and </span><span class="s1">np.any(np.diff(index) != </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">or </span><span class="s1">(</span>
            <span class="s1">type(index) </span><span class="s0">is </span><span class="s1">pd.Index</span>
            <span class="s0">and </span><span class="s1">max(index) &gt; </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">63</span>
            <span class="s0">and </span><span class="s1">forecast_index </span><span class="s0">is None</span>
        <span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s1">warn = UserWarning</span>
    <span class="s0">with </span><span class="s1">pytest_warns(warn):</span>
        <span class="s1">f.out_of_sample(steps</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">forecast_index)</span>
    <span class="s0">assert </span><span class="s1">isinstance(f.period</span><span class="s0">, </span><span class="s1">float)</span>
    <span class="s0">assert </span><span class="s1">isinstance(f.order</span><span class="s0">, </span><span class="s1">int)</span>
    <span class="s1">str(f)</span>
    <span class="s1">hash(f)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;2 \* order must be &lt;= period&quot;</span><span class="s1">):</span>
        <span class="s1">Fourier(</span><span class="s3">12</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s0">def </span><span class="s1">test_calendar_time_trend_smoke(time_index</span><span class="s0">, </span><span class="s1">forecast_index):</span>
    <span class="s1">ct = CalendarTimeTrend(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">ct.in_sample(time_index)</span>
    <span class="s1">steps = </span><span class="s3">83 </span><span class="s0">if </span><span class="s1">forecast_index </span><span class="s0">is None else </span><span class="s1">len(forecast_index)</span>
    <span class="s1">ct.out_of_sample(steps</span><span class="s0">, </span><span class="s1">time_index</span><span class="s0">, </span><span class="s1">forecast_index)</span>
    <span class="s1">str(ct)</span>
    <span class="s1">hash(ct)</span>
    <span class="s0">assert </span><span class="s1">isinstance(ct.order</span><span class="s0">, </span><span class="s1">int)</span>
    <span class="s0">assert </span><span class="s1">isinstance(ct.constant</span><span class="s0">, </span><span class="s1">bool)</span>
    <span class="s0">assert </span><span class="s1">isinstance(ct.freq</span><span class="s0">, </span><span class="s1">str)</span>
    <span class="s0">assert </span><span class="s1">ct.base_period </span><span class="s0">is None</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s0">def </span><span class="s1">test_calendar_fourier_smoke(time_index</span><span class="s0">, </span><span class="s1">forecast_index):</span>
    <span class="s1">cf = CalendarFourier(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">cf.in_sample(time_index)</span>
    <span class="s1">steps = </span><span class="s3">83 </span><span class="s0">if </span><span class="s1">forecast_index </span><span class="s0">is None else </span><span class="s1">len(forecast_index)</span>
    <span class="s1">cf.out_of_sample(steps</span><span class="s0">, </span><span class="s1">time_index</span><span class="s0">, </span><span class="s1">forecast_index)</span>
    <span class="s0">assert </span><span class="s1">isinstance(cf.order</span><span class="s0">, </span><span class="s1">int)</span>
    <span class="s0">assert </span><span class="s1">isinstance(cf.freq</span><span class="s0">, </span><span class="s1">str)</span>
    <span class="s1">str(cf)</span>
    <span class="s1">repr(cf)</span>
    <span class="s1">hash(cf)</span>


<span class="s1">params = CalendarSeasonality._supported</span>
<span class="s1">cs_params = [(k</span><span class="s0">, </span><span class="s1">k2) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">params.items() </span><span class="s0">for </span><span class="s1">k2 </span><span class="s0">in </span><span class="s1">v.keys()]</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;freq_period&quot;</span><span class="s0">, </span><span class="s1">cs_params)</span>
<span class="s0">def </span><span class="s1">test_calendar_seasonality(time_index</span><span class="s0">, </span><span class="s1">forecast_index</span><span class="s0">, </span><span class="s1">freq_period):</span>
    <span class="s1">freq</span><span class="s0">, </span><span class="s1">period = freq_period</span>
    <span class="s1">cs = CalendarSeasonality(period</span><span class="s0">, </span><span class="s1">freq)</span>
    <span class="s1">cs.in_sample(time_index)</span>
    <span class="s1">steps = </span><span class="s3">83 </span><span class="s0">if </span><span class="s1">forecast_index </span><span class="s0">is None else </span><span class="s1">len(forecast_index)</span>
    <span class="s1">cs.out_of_sample(steps</span><span class="s0">, </span><span class="s1">time_index</span><span class="s0">, </span><span class="s1">forecast_index)</span>
    <span class="s0">assert </span><span class="s1">isinstance(cs.period</span><span class="s0">, </span><span class="s1">str)</span>
    <span class="s0">assert </span><span class="s1">isinstance(cs.freq</span><span class="s0">, </span><span class="s1">str)</span>
    <span class="s1">str(cs)</span>
    <span class="s1">repr(cs)</span>
    <span class="s1">hash(cs)</span>
    <span class="s1">cs2 = CalendarSeasonality(period</span><span class="s0">, </span><span class="s1">freq)</span>
    <span class="s0">assert </span><span class="s1">cs == cs2</span>


<span class="s0">def </span><span class="s1">test_forbidden_index():</span>
    <span class="s1">index = pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">ct = CalendarTimeTrend(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;CalendarTimeTrend terms can only&quot;</span><span class="s1">):</span>
        <span class="s1">ct.in_sample(index)</span>


<span class="s0">def </span><span class="s1">test_calendar_time_trend_base(time_index):</span>
    <span class="s1">ct = CalendarTimeTrend(</span><span class="s2">&quot;M&quot;</span><span class="s0">, True, </span><span class="s1">order=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">base_period=</span><span class="s2">&quot;1960-1-1&quot;</span><span class="s1">)</span>
    <span class="s1">ct2 = CalendarTimeTrend(</span><span class="s2">&quot;M&quot;</span><span class="s0">, True, </span><span class="s1">order=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">ct != ct2</span>
    <span class="s1">str(ct)</span>
    <span class="s1">str(ct2)</span>
    <span class="s0">assert </span><span class="s1">ct.base_period </span><span class="s0">is not None</span>
    <span class="s0">assert </span><span class="s1">ct2.base_period </span><span class="s0">is None</span>


<span class="s0">def </span><span class="s1">test_invalid_freq_period(time_index):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The combination of freq=&quot;</span><span class="s1">):</span>
        <span class="s1">CalendarSeasonality(</span><span class="s2">&quot;H&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
    <span class="s1">cs = CalendarSeasonality(</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;W&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;freq is B but index contains&quot;</span><span class="s1">):</span>
        <span class="s1">cs.in_sample(pd.date_range(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_check_index_type():</span>
    <span class="s1">ct = CalendarTimeTrend(</span><span class="s2">&quot;A&quot;</span><span class="s0">, True, </span><span class="s1">order=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">idx = pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;CalendarTimeTrend terms can only&quot;</span><span class="s1">):</span>
        <span class="s1">ct._check_index_type(idx</span><span class="s0">, </span><span class="s1">pd.DatetimeIndex)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;CalendarTimeTrend terms can only&quot;</span><span class="s1">):</span>
        <span class="s1">ct._check_index_type(idx</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;CalendarTimeTrend terms can only&quot;</span><span class="s1">):</span>
        <span class="s1">ct._check_index_type(idx</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex))</span>
    <span class="s1">idx = pd.Index([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">13</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;CalendarTimeTrend terms can only&quot;</span><span class="s1">):</span>
        <span class="s1">types = (pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex</span><span class="s0">, </span><span class="s1">pd.RangeIndex)</span>
        <span class="s1">ct._check_index_type(idx</span><span class="s0">, </span><span class="s1">types)</span>


<span class="s0">def </span><span class="s1">test_unknown_freq():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;freq is not understood by pandas&quot;</span><span class="s1">):</span>
        <span class="s1">CalendarTimeTrend(</span><span class="s2">&quot;unknown&quot;</span><span class="s0">, True, </span><span class="s1">order=</span><span class="s3">3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_invalid_formcast_index(index):</span>
    <span class="s1">tt = TimeTrend(order=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The number of values in forecast_&quot;</span><span class="s1">):</span>
        <span class="s1">tt.out_of_sample(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">pd.RangeIndex(</span><span class="s3">11</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_seasonal_from_index_err():</span>
    <span class="s1">index = pd.Index([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">12</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">Seasonality.from_index(index)</span>
    <span class="s1">index = pd.date_range(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s1">)[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]]</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">Seasonality.from_index(index)</span>


<span class="s0">def </span><span class="s1">test_time_trend(index):</span>
    <span class="s1">tt = TimeTrend(constant=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">const = tt.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">const.shape == (index.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.all(const == </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">pd.testing.assert_index_equal(const.index</span><span class="s0">, </span><span class="s1">index)</span>
    <span class="s1">warn = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">(is_int_index(index) </span><span class="s0">and </span><span class="s1">np.any(np.diff(index) != </span><span class="s3">1</span><span class="s1">)) </span><span class="s0">or </span><span class="s1">(</span>
        <span class="s1">type(index) </span><span class="s0">is </span><span class="s1">pd.Index </span><span class="s0">and </span><span class="s1">max(index) &gt; </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">63</span>
    <span class="s1">):</span>
        <span class="s1">warn = UserWarning</span>
    <span class="s0">with </span><span class="s1">pytest_warns(warn):</span>
        <span class="s1">const_fcast = tt.out_of_sample(</span><span class="s3">23</span><span class="s0">, </span><span class="s1">index)</span>
    <span class="s0">assert </span><span class="s1">np.all(const_fcast == </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">tt = TimeTrend(constant=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">empty = tt.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">empty.shape == (index.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">tt = TimeTrend(constant=</span><span class="s0">False, </span><span class="s1">order=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">t2 = tt.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">t2.shape == (index.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(t2.columns) == [</span><span class="s2">&quot;trend&quot;</span><span class="s0">, </span><span class="s2">&quot;trend_squared&quot;</span><span class="s1">]</span>

    <span class="s1">tt = TimeTrend(constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">final = tt.in_sample(index)</span>
    <span class="s1">expected = pd.concat([const</span><span class="s0">, </span><span class="s1">t2]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">pd.testing.assert_frame_equal(final</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">tt = TimeTrend(constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">short = tt.in_sample(index[:-</span><span class="s3">50</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest_warns(warn):</span>
        <span class="s1">remainder = tt.out_of_sample(</span><span class="s3">50</span><span class="s0">, </span><span class="s1">index[:-</span><span class="s3">50</span><span class="s1">])</span>
    <span class="s1">direct = tt.out_of_sample(</span>
        <span class="s1">steps=</span><span class="s3">50</span><span class="s0">, </span><span class="s1">index=index[:-</span><span class="s3">50</span><span class="s1">]</span><span class="s0">, </span><span class="s1">forecast_index=index[-</span><span class="s3">50</span><span class="s1">:]</span>
    <span class="s1">)</span>
    <span class="s1">combined = pd.concat([short</span><span class="s0">, </span><span class="s1">remainder]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.RangeIndex)):</span>
        <span class="s1">pd.testing.assert_frame_equal(combined</span><span class="s0">, </span><span class="s1">final)</span>
    <span class="s1">combined = pd.concat([short</span><span class="s0">, </span><span class="s1">direct]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">pd.testing.assert_frame_equal(combined</span><span class="s0">, </span><span class="s1">final</span><span class="s0">, </span><span class="s1">check_index_type=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_seasonality(index):</span>
    <span class="s1">s = Seasonality(period=</span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">exog = s.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">s.is_dummy</span>
    <span class="s0">assert </span><span class="s1">exog.shape == (index.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">pd.testing.assert_index_equal(exog.index</span><span class="s0">, </span><span class="s1">index)</span>
    <span class="s0">assert </span><span class="s1">np.all(exog.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(exog.columns) == [</span><span class="s2">f&quot;s(</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">,12)&quot; </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">13</span><span class="s1">)]</span>
    <span class="s1">expected = np.zeros((index.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">12</span><span class="s1">))</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">12</span><span class="s1">):</span>
        <span class="s1">expected[i::</span><span class="s3">12</span><span class="s0">, </span><span class="s1">i] = </span><span class="s3">1.0</span>
    <span class="s1">np.testing.assert_equal(expected</span><span class="s0">, </span><span class="s1">np.asarray(exog))</span>

    <span class="s1">warn = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">(is_int_index(index) </span><span class="s0">and </span><span class="s1">np.any(np.diff(index) != </span><span class="s3">1</span><span class="s1">)) </span><span class="s0">or </span><span class="s1">(</span>
        <span class="s1">type(index) </span><span class="s0">is </span><span class="s1">pd.Index </span><span class="s0">and </span><span class="s1">max(index) &gt; </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">63</span>
    <span class="s1">):</span>
        <span class="s1">warn = UserWarning</span>
    <span class="s0">with </span><span class="s1">pytest_warns(warn):</span>
        <span class="s1">fcast = s.out_of_sample(steps=</span><span class="s3">12</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s0">assert </span><span class="s1">fcast.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">len(index) % </span><span class="s3">12</span><span class="s1">] == </span><span class="s3">1.0</span>
    <span class="s0">assert </span><span class="s1">np.all(fcast.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">s = Seasonality(period=</span><span class="s3">7</span><span class="s0">, </span><span class="s1">initial_period=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">exog = s.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">exog.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">] == </span><span class="s3">1.0</span>
    <span class="s0">assert </span><span class="s1">exog.iloc[</span><span class="s3">0</span><span class="s1">].sum() == </span><span class="s3">1.0</span>
    <span class="s0">assert </span><span class="s1">s.initial_period == </span><span class="s3">3</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;initial_period must be in&quot;</span><span class="s1">):</span>
        <span class="s1">Seasonality(period=</span><span class="s3">12</span><span class="s0">, </span><span class="s1">initial_period=-</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;period must be &gt;= 2&quot;</span><span class="s1">):</span>
        <span class="s1">Seasonality(period=</span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_seasonality_time_index(time_index):</span>
    <span class="s1">tt = Seasonality.from_index(time_index)</span>
    <span class="s0">assert </span><span class="s1">tt.period == </span><span class="s3">5</span>

    <span class="s1">fcast = tt.out_of_sample(steps=</span><span class="s3">12</span><span class="s0">, </span><span class="s1">index=time_index)</span>
    <span class="s1">new_idx = DeterministicTerm._extend_index(time_index</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">pd.testing.assert_index_equal(fcast.index</span><span class="s0">, </span><span class="s1">new_idx)</span>


<span class="s0">def </span><span class="s1">test_fourier(index):</span>
    <span class="s1">f = Fourier(period=</span><span class="s3">12</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">terms = f.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">f.order == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">terms.shape == (index.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* f.order)</span>
    <span class="s1">loc = np.arange(index.shape[</span><span class="s3">0</span><span class="s1">]) / </span><span class="s3">12</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">enumerate(terms):</span>
        <span class="s1">j = i // </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">1</span>
        <span class="s1">fn = np.cos </span><span class="s0">if </span><span class="s1">(i % </span><span class="s3">2</span><span class="s1">) </span><span class="s0">else </span><span class="s1">np.sin</span>
        <span class="s1">expected = fn(</span><span class="s3">2 </span><span class="s1">* np.pi * j * loc)</span>
        <span class="s1">np.testing.assert_allclose(terms[col]</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>
    <span class="s1">cols = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2 </span><span class="s1">* f.order):</span>
        <span class="s1">fn = </span><span class="s2">&quot;cos&quot; </span><span class="s0">if </span><span class="s1">(i % </span><span class="s3">2</span><span class="s1">) </span><span class="s0">else </span><span class="s2">&quot;sin&quot;</span>
        <span class="s1">cols.append(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">fn</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">(i // </span><span class="s3">2</span><span class="s1">) + </span><span class="s3">1</span><span class="s0">}</span><span class="s2">,12)&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(terms.columns) == cols</span>


<span class="s1">@pytest.mark.skipif(PD_LT_1_0_0</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;bug in old pandas&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_index_like():</span>
    <span class="s1">idx = np.empty((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;index must be a pandas&quot;</span><span class="s1">):</span>
        <span class="s1">DeterministicTerm._index_like(idx)</span>


<span class="s0">def </span><span class="s1">test_calendar_fourier(reset_randomstate):</span>
    <span class="s1">inc = np.abs(np.random.standard_normal(</span><span class="s3">1000</span><span class="s1">))</span>
    <span class="s1">inc = np.cumsum(inc)</span>
    <span class="s1">inc = </span><span class="s3">10 </span><span class="s1">* inc / inc[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">offset = (</span><span class="s3">24 </span><span class="s1">* </span><span class="s3">3600 </span><span class="s1">* inc).astype(np.int64)</span>
    <span class="s1">base = pd.Timestamp(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s1">)</span>
    <span class="s1">index = [base + pd.Timedelta(val</span><span class="s0">, </span><span class="s1">unit=</span><span class="s2">&quot;s&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">offset]</span>
    <span class="s1">index = pd.Index(index)</span>

    <span class="s1">cf = CalendarFourier(</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">cf.order == </span><span class="s3">2</span>
    <span class="s1">terms = cf.in_sample(index)</span>
    <span class="s1">cols = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2 </span><span class="s1">* cf.order):</span>
        <span class="s1">fn = </span><span class="s2">&quot;cos&quot; </span><span class="s0">if </span><span class="s1">(i % </span><span class="s3">2</span><span class="s1">) </span><span class="s0">else </span><span class="s2">&quot;sin&quot;</span>
        <span class="s1">cols.append(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">fn</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">(i // </span><span class="s3">2</span><span class="s1">) + </span><span class="s3">1</span><span class="s0">}</span><span class="s2">,freq=D)&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(terms.columns) == cols</span>

    <span class="s1">inc = offset / (</span><span class="s3">24 </span><span class="s1">* </span><span class="s3">3600</span><span class="s1">)</span>
    <span class="s1">loc = </span><span class="s3">2 </span><span class="s1">* np.pi * (inc - np.floor(inc))</span>
    <span class="s1">expected = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">):</span>
        <span class="s1">scale = i // </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">1</span>
        <span class="s1">fn = np.cos </span><span class="s0">if </span><span class="s1">(i % </span><span class="s3">2</span><span class="s1">) </span><span class="s0">else </span><span class="s1">np.sin</span>
        <span class="s1">expected.append(fn(scale * loc))</span>
    <span class="s1">expected = np.column_stack(expected)</span>
    <span class="s1">np.testing.assert_allclose(expected</span><span class="s0">, </span><span class="s1">terms.values)</span>


<span class="s0">def </span><span class="s1">test_calendar_time_trend(reset_randomstate):</span>
    <span class="s1">inc = np.abs(np.random.standard_normal(</span><span class="s3">1000</span><span class="s1">))</span>
    <span class="s1">inc = np.cumsum(inc)</span>
    <span class="s1">inc = </span><span class="s3">10 </span><span class="s1">* inc / inc[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">offset = (</span><span class="s3">24 </span><span class="s1">* </span><span class="s3">3600 </span><span class="s1">* inc).astype(np.int64)</span>
    <span class="s1">base = pd.Timestamp(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s1">)</span>
    <span class="s1">index = [base + pd.Timedelta(val</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">offset]</span>
    <span class="s1">index = pd.Index(index)</span>

    <span class="s1">ctt = CalendarTimeTrend(</span><span class="s2">&quot;D&quot;</span><span class="s0">, True, </span><span class="s1">order=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">base_period=base)</span>
    <span class="s0">assert </span><span class="s1">ctt.order == </span><span class="s3">3</span>
    <span class="s1">terms = ctt.in_sample(index)</span>
    <span class="s1">cols = [</span><span class="s2">&quot;const&quot;</span><span class="s0">, </span><span class="s2">&quot;trend&quot;</span><span class="s0">, </span><span class="s2">&quot;trend_squared&quot;</span><span class="s0">, </span><span class="s2">&quot;trend_cubed&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">list(terms.columns) == cols</span>

    <span class="s1">inc = </span><span class="s3">1 </span><span class="s1">+ offset / (</span><span class="s3">24 </span><span class="s1">* </span><span class="s3">3600</span><span class="s1">)</span>
    <span class="s1">expected = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">):</span>
        <span class="s1">expected.append(inc ** i)</span>
    <span class="s1">expected = np.column_stack(expected)</span>
    <span class="s1">np.testing.assert_allclose(expected</span><span class="s0">, </span><span class="s1">terms.values)</span>

    <span class="s1">ctt = CalendarTimeTrend(</span><span class="s2">&quot;D&quot;</span><span class="s0">, True, </span><span class="s1">order=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">base_period=base)</span>
    <span class="s1">ctt2 = CalendarTimeTrend.from_string(</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s1">trend=</span><span class="s2">&quot;ctt&quot;</span><span class="s0">, </span><span class="s1">base_period=base)</span>
    <span class="s1">pd.testing.assert_frame_equal(ctt.in_sample(index)</span><span class="s0">, </span><span class="s1">ctt2.in_sample(index))</span>

    <span class="s1">ct = CalendarTimeTrend(</span><span class="s2">&quot;D&quot;</span><span class="s0">, True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">base_period=base)</span>
    <span class="s1">ct2 = CalendarTimeTrend.from_string(</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s1">trend=</span><span class="s2">&quot;ct&quot;</span><span class="s0">, </span><span class="s1">base_period=base)</span>
    <span class="s1">pd.testing.assert_frame_equal(ct.in_sample(index)</span><span class="s0">, </span><span class="s1">ct2.in_sample(index))</span>

    <span class="s1">ctttt = CalendarTimeTrend(</span><span class="s2">&quot;D&quot;</span><span class="s0">, True, </span><span class="s1">order=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">base_period=base)</span>
    <span class="s0">assert </span><span class="s1">ctttt.order == </span><span class="s3">4</span>
    <span class="s1">terms = ctttt.in_sample(index)</span>
    <span class="s1">cols = [</span><span class="s2">&quot;const&quot;</span><span class="s0">, </span><span class="s2">&quot;trend&quot;</span><span class="s0">, </span><span class="s2">&quot;trend_squared&quot;</span><span class="s0">, </span><span class="s2">&quot;trend_cubed&quot;</span><span class="s0">, </span><span class="s2">&quot;trend**4&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">list(terms.columns) == cols</span>


<span class="s0">def </span><span class="s1">test_calendar_seasonal_period_w():</span>
    <span class="s1">period = </span><span class="s2">&quot;W&quot;</span>
    <span class="s1">index = pd.date_range(</span><span class="s2">&quot;2000-01-03&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;H&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">600</span><span class="s1">)</span>
    <span class="s1">cs = CalendarSeasonality(</span><span class="s2">&quot;H&quot;</span><span class="s0">, </span><span class="s1">period=period)</span>
    <span class="s1">terms = cs.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">np.all(terms.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s0">assert </span><span class="s1">terms.iloc[i</span><span class="s0">, </span><span class="s1">i % </span><span class="s3">168</span><span class="s1">] == </span><span class="s3">1.0</span>

    <span class="s1">index = pd.date_range(</span><span class="s2">&quot;2000-01-03&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">600</span><span class="s1">)</span>
    <span class="s1">cs = CalendarSeasonality(</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">period=period)</span>
    <span class="s1">terms = cs.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">np.all(terms.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s0">assert </span><span class="s1">terms.iloc[i</span><span class="s0">, </span><span class="s1">i % </span><span class="s3">5</span><span class="s1">] == </span><span class="s3">1.0</span>

    <span class="s1">index = pd.date_range(</span><span class="s2">&quot;2000-01-03&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">600</span><span class="s1">)</span>
    <span class="s1">cs = CalendarSeasonality(</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s1">period=period)</span>
    <span class="s1">terms = cs.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">np.all(terms.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s0">assert </span><span class="s1">terms.iloc[i</span><span class="s0">, </span><span class="s1">i % </span><span class="s3">7</span><span class="s1">] == </span><span class="s3">1.0</span>


<span class="s0">def </span><span class="s1">test_calendar_seasonal_period_d():</span>
    <span class="s1">period = </span><span class="s2">&quot;D&quot;</span>
    <span class="s1">index = pd.date_range(</span><span class="s2">&quot;2000-01-03&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;H&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">600</span><span class="s1">)</span>
    <span class="s1">cs = CalendarSeasonality(</span><span class="s2">&quot;H&quot;</span><span class="s0">, </span><span class="s1">period=period)</span>
    <span class="s1">terms = cs.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">np.all(terms.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s0">assert </span><span class="s1">terms.iloc[i</span><span class="s0">, </span><span class="s1">i % </span><span class="s3">24</span><span class="s1">] == </span><span class="s3">1.0</span>


<span class="s0">def </span><span class="s1">test_calendar_seasonal_period_q():</span>
    <span class="s1">period = </span><span class="s2">&quot;Q&quot;</span>
    <span class="s1">index = pd.date_range(</span><span class="s2">&quot;2000-01-01&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">600</span><span class="s1">)</span>
    <span class="s1">cs = CalendarSeasonality(</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">period=period)</span>
    <span class="s1">terms = cs.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">np.all(terms.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s0">assert </span><span class="s1">terms.iloc[i</span><span class="s0">, </span><span class="s1">i % </span><span class="s3">3</span><span class="s1">] == </span><span class="s3">1.0</span>


<span class="s0">def </span><span class="s1">test_calendar_seasonal_period_a():</span>
    <span class="s1">period = </span><span class="s2">&quot;A&quot;</span>
    <span class="s1">index = pd.date_range(</span><span class="s2">&quot;2000-01-01&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">600</span><span class="s1">)</span>
    <span class="s1">cs = CalendarSeasonality(</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">period=period)</span>
    <span class="s1">terms = cs.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">np.all(terms.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s0">assert </span><span class="s1">terms.iloc[i</span><span class="s0">, </span><span class="s1">i % </span><span class="s3">12</span><span class="s1">] == </span><span class="s3">1.0</span>

    <span class="s1">cs = CalendarSeasonality(</span><span class="s2">&quot;Q&quot;</span><span class="s0">, </span><span class="s1">period=period)</span>
    <span class="s1">terms = cs.in_sample(index)</span>
    <span class="s0">assert </span><span class="s1">np.all(terms.sum(</span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s0">assert </span><span class="s1">terms.iloc[i</span><span class="s0">, </span><span class="s1">(i % </span><span class="s3">12</span><span class="s1">) // </span><span class="s3">3</span><span class="s1">] == </span><span class="s3">1.0</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;order&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;seasonal&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;fourier&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;period&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">10</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;drop&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_deterministic_process(</span>
    <span class="s1">time_index</span><span class="s0">, </span><span class="s1">constant</span><span class="s0">, </span><span class="s1">order</span><span class="s0">, </span><span class="s1">seasonal</span><span class="s0">, </span><span class="s1">fourier</span><span class="s0">, </span><span class="s1">period</span><span class="s0">, </span><span class="s1">drop</span>
<span class="s1">):</span>
    <span class="s0">if </span><span class="s1">seasonal </span><span class="s0">and </span><span class="s1">fourier:</span>
        <span class="s0">return</span>
    <span class="s1">dp = DeterministicProcess(</span>
        <span class="s1">time_index</span><span class="s0">,</span>
        <span class="s1">constant=constant</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">seasonal=seasonal</span><span class="s0">,</span>
        <span class="s1">fourier=fourier</span><span class="s0">,</span>
        <span class="s1">period=period</span><span class="s0">,</span>
        <span class="s1">drop=drop</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">terms = dp.in_sample()</span>
    <span class="s1">pd.testing.assert_index_equal(terms.index</span><span class="s0">, </span><span class="s1">time_index)</span>
    <span class="s1">terms = dp.out_of_sample(</span><span class="s3">23</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(terms</span><span class="s0">, </span><span class="s1">pd.DataFrame)</span>


<span class="s0">def </span><span class="s1">test_deterministic_process_errors(time_index):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;seasonal and fourier&quot;</span><span class="s1">):</span>
        <span class="s1">DeterministicProcess(time_index</span><span class="s0">, </span><span class="s1">seasonal=</span><span class="s0">True, </span><span class="s1">fourier=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">period=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;All additional terms&quot;</span><span class="s1">):</span>
        <span class="s1">DeterministicProcess(time_index</span><span class="s0">, </span><span class="s1">seasonal=</span><span class="s0">True, </span><span class="s1">additional_terms=[</span><span class="s3">1</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_range_error():</span>
    <span class="s1">idx = pd.Index([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">13</span><span class="s1">])</span>
    <span class="s1">dp = DeterministicProcess(</span>
        <span class="s1">idx</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">seasonal=</span><span class="s0">True, </span><span class="s1">period=</span><span class="s3">2</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The index in the deterministic&quot;</span><span class="s1">):</span>
        <span class="s1">dp.range(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_range_index_basic():</span>
    <span class="s1">idx = pd.date_range(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">120</span><span class="s1">)</span>
    <span class="s1">dp = DeterministicProcess(idx</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">seasonal=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s2">&quot;2001-1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;2008-1-1&quot;</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s2">&quot;2001-1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;2015-1-1&quot;</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s2">&quot;2013-1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;2008-1-1&quot;</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">130</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">dp.range(</span><span class="s2">&quot;1990-1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;2010-1-1&quot;</span><span class="s1">)</span>

    <span class="s1">idx = pd.period_range(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">120</span><span class="s1">)</span>
    <span class="s1">dp = DeterministicProcess(idx</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">seasonal=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s2">&quot;2001-1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;2008-1-1&quot;</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s2">&quot;2001-1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;2015-1-1&quot;</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s2">&quot;2013-1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;2008-1-1&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;start must be non-negative&quot;</span><span class="s1">):</span>
        <span class="s1">dp.range(-</span><span class="s3">7</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span>

    <span class="s1">dp.range(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">130</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span>

    <span class="s1">idx = pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">120</span><span class="s1">)</span>
    <span class="s1">dp = DeterministicProcess(</span>
        <span class="s1">idx</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">seasonal=</span><span class="s0">True, </span><span class="s1">period=</span><span class="s3">12</span>
    <span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">120</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span>
    <span class="s1">dp.range(</span><span class="s3">130</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">dp.range(-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_range_casting():</span>
    <span class="s1">idx = np.arange(</span><span class="s3">120</span><span class="s1">).astype(np.int64)</span>
    <span class="s1">dp = DeterministicProcess(</span>
        <span class="s1">idx</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">seasonal=</span><span class="s0">True, </span><span class="s1">period=</span><span class="s3">12</span>
    <span class="s1">)</span>
    <span class="s1">idx = pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">120</span><span class="s1">)</span>
    <span class="s1">dp2 = DeterministicProcess(</span>
        <span class="s1">idx</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">seasonal=</span><span class="s0">True, </span><span class="s1">period=</span><span class="s3">12</span>
    <span class="s1">)</span>
    <span class="s1">pd.testing.assert_frame_equal(dp.in_sample()</span><span class="s0">, </span><span class="s1">dp2.in_sample())</span>
    <span class="s1">pd.testing.assert_frame_equal(dp.range(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dp2.range(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">150</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_non_unit_range():</span>
    <span class="s1">idx = pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">700</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
    <span class="s1">dp = DeterministicProcess(idx</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The step of the index is not 1&quot;</span><span class="s1">):</span>
        <span class="s1">dp.range(</span><span class="s3">11</span><span class="s0">, </span><span class="s3">900</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_additional_terms(time_index):</span>
    <span class="s1">add_terms = [TimeTrend(</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s1">)]</span>
    <span class="s1">dp = DeterministicProcess(time_index</span><span class="s0">, </span><span class="s1">additional_terms=add_terms)</span>
    <span class="s1">dp2 = DeterministicProcess(time_index</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">pd.testing.assert_frame_equal(dp.in_sample()</span><span class="s0">, </span><span class="s1">dp2.in_sample())</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;One or more terms in additional_terms&quot;</span>
    <span class="s1">):</span>
        <span class="s1">DeterministicProcess(</span>
            <span class="s1">time_index</span><span class="s0">, </span><span class="s1">additional_terms=add_terms + add_terms</span>
        <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;One or more terms in additional_terms&quot;</span>
    <span class="s1">):</span>
        <span class="s1">DeterministicProcess(</span>
            <span class="s1">time_index</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">additional_terms=add_terms</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_drop_two_consants(time_index):</span>
    <span class="s1">tt = TimeTrend(constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">dp = DeterministicProcess(</span>
        <span class="s1">time_index</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">additional_terms=[tt]</span><span class="s0">, </span><span class="s1">drop=</span><span class="s0">True</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dp.in_sample().shape[</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">2</span>
    <span class="s1">dp2 = DeterministicProcess(time_index</span><span class="s0">, </span><span class="s1">additional_terms=[tt]</span><span class="s0">, </span><span class="s1">drop=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">pd.testing.assert_frame_equal(dp.in_sample()</span><span class="s0">, </span><span class="s1">dp2.in_sample())</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;index&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.Index(np.arange(</span><span class="s3">200</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">pd.date_range(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">200</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.period_range(</span><span class="s2">&quot;2000-1-1&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">200</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_determintic_term_equiv(index):</span>
    <span class="s1">base = DeterministicProcess(pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">dp = DeterministicProcess(index</span><span class="s0">, </span><span class="s1">constant=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_array_equal(base.in_sample()</span><span class="s0">, </span><span class="s1">dp.in_sample())</span>
    <span class="s1">np.testing.assert_array_equal(base.out_of_sample(</span><span class="s3">37</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dp.out_of_sample(</span><span class="s3">37</span><span class="s1">))</span>
    <span class="s1">np.testing.assert_array_equal(base.range(</span><span class="s3">200</span><span class="s0">, </span><span class="s3">237</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dp.range(</span><span class="s3">200</span><span class="s0">, </span><span class="s3">237</span><span class="s1">))</span>
    <span class="s1">np.testing.assert_array_equal(base.range(</span><span class="s3">50</span><span class="s0">, </span><span class="s3">150</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dp.range(</span><span class="s3">50</span><span class="s0">, </span><span class="s3">150</span><span class="s1">))</span>
    <span class="s1">np.testing.assert_array_equal(base.range(</span><span class="s3">50</span><span class="s0">, </span><span class="s3">250</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dp.range(</span><span class="s3">50</span><span class="s0">, </span><span class="s3">250</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">DummyTerm(DeterministicTerm):</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_eq_attr(self) -&gt; Tuple[Hashable</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s2">&quot;Dummy&quot;</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;Dummy&quot;</span>

    <span class="s1">columns = [</span>
        <span class="s2">&quot;const1&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;const2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;trend1&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;trend2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;normal1&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;normal2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;dummy1_1&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;dummy1_2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;always_drop1&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;always_drop2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;dummy2_1&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;dummy2_2&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">in_sample(self</span><span class="s0">, </span><span class="s1">index: pd.Index) -&gt; pd.DataFrame:</span>
        <span class="s1">nobs = index.shape[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">terms = np.empty((index.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">12</span><span class="s1">))</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">i == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">value = </span><span class="s3">1</span>
            <span class="s0">elif </span><span class="s1">i == </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s1">value = np.arange(nobs)</span>
            <span class="s0">elif </span><span class="s1">i == </span><span class="s3">4</span><span class="s1">:</span>
                <span class="s1">value = np.random.standard_normal(nobs)</span>
            <span class="s0">elif </span><span class="s1">i == </span><span class="s3">6</span><span class="s1">:</span>
                <span class="s1">value = np.zeros(nobs)</span>
                <span class="s1">value[::</span><span class="s3">2</span><span class="s1">] = </span><span class="s3">1</span>
            <span class="s0">elif </span><span class="s1">i == </span><span class="s3">8</span><span class="s1">:</span>
                <span class="s1">value = </span><span class="s3">0</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s4"># elif i == 8:</span>
                <span class="s1">value = np.zeros(nobs)</span>
                <span class="s1">value[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">2</span><span class="s1">] = </span><span class="s3">1</span>
            <span class="s1">terms[:</span><span class="s0">, </span><span class="s1">i] = terms[:</span><span class="s0">, </span><span class="s1">i + </span><span class="s3">1</span><span class="s1">] = value</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">columns=self.columns</span><span class="s0">, </span><span class="s1">index=index)</span>

    <span class="s0">def </span><span class="s1">out_of_sample(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">steps: int</span><span class="s0">,</span>
        <span class="s1">index: pd.Index</span><span class="s0">,</span>
        <span class="s1">forecast_index: pd.Index = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s1">fcast_index = self._extend_index(index</span><span class="s0">, </span><span class="s1">steps</span><span class="s0">, </span><span class="s1">forecast_index)</span>
        <span class="s1">terms = np.random.standard_normal((steps</span><span class="s0">, </span><span class="s3">12</span><span class="s1">))</span>

        <span class="s0">return </span><span class="s1">pd.DataFrame(terms</span><span class="s0">, </span><span class="s1">columns=self.columns</span><span class="s0">, </span><span class="s1">index=fcast_index)</span>


<span class="s0">def </span><span class="s1">test_drop():</span>
    <span class="s1">index = pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span>
    <span class="s1">dummy = DummyTerm()</span>
    <span class="s1">str(dummy)</span>
    <span class="s0">assert </span><span class="s1">dummy != TimeTrend()</span>
    <span class="s1">dp = DeterministicProcess(index</span><span class="s0">, </span><span class="s1">additional_terms=[dummy]</span><span class="s0">, </span><span class="s1">drop=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">in_samp = dp.in_sample()</span>
    <span class="s0">assert </span><span class="s1">in_samp.shape == (</span><span class="s3">200</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">oos = dp.out_of_sample(</span><span class="s3">37</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">oos.shape == (</span><span class="s3">37</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(oos.columns) == list(in_samp.columns)</span>
    <span class="s1">valid = (</span><span class="s2">&quot;const&quot;</span><span class="s0">, </span><span class="s2">&quot;trend&quot;</span><span class="s0">, </span><span class="s2">&quot;dummy&quot;</span><span class="s0">, </span><span class="s2">&quot;normal&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">valid_col </span><span class="s0">in </span><span class="s1">valid:</span>
        <span class="s0">assert </span><span class="s1">sum([</span><span class="s3">1 </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">oos </span><span class="s0">if </span><span class="s1">valid_col </span><span class="s0">in </span><span class="s1">col]) == </span><span class="s3">1</span>
</pre>
</body>
</html>