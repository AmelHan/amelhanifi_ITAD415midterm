<html>
<head>
<title>multioutput.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
multioutput.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This module implements multioutput regression and classification. 
 
The estimators provided in this module are meta-estimators: they require 
a base estimator to be provided in their constructor. The meta-estimator 
extends single output estimators to multioutput estimators. 
&quot;&quot;&quot;</span>

<span class="s2"># Author: Tim Head &lt;betatim@gmail.com&gt;</span>
<span class="s2"># Author: Hugo Bowne-Anderson &lt;hugobowne@gmail.com&gt;</span>
<span class="s2"># Author: Chris Rivera &lt;chris.richard.rivera@gmail.com&gt;</span>
<span class="s2"># Author: Michael Williamson</span>
<span class="s2"># Author: James Ashton Nichols &lt;james.ashton.nichols@gmail.com&gt;</span>
<span class="s2">#</span>
<span class="s2"># License: BSD 3 clause</span>


<span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABCMeta</span><span class="s3">, </span><span class="s1">abstractmethod</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">scipy.sparse </span><span class="s3">as </span><span class="s1">sp</span>

<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">BaseEstimator</span><span class="s3">,</span>
    <span class="s1">ClassifierMixin</span><span class="s3">,</span>
    <span class="s1">MetaEstimatorMixin</span><span class="s3">,</span>
    <span class="s1">RegressorMixin</span><span class="s3">,</span>
    <span class="s1">_fit_context</span><span class="s3">,</span>
    <span class="s1">clone</span><span class="s3">,</span>
    <span class="s1">is_classifier</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">.model_selection </span><span class="s3">import </span><span class="s1">cross_val_predict</span>
<span class="s3">from </span><span class="s1">.utils </span><span class="s3">import </span><span class="s1">Bunch</span><span class="s3">, </span><span class="s1">_print_elapsed_time</span><span class="s3">, </span><span class="s1">check_random_state</span>
<span class="s3">from </span><span class="s1">.utils._param_validation </span><span class="s3">import </span><span class="s1">HasMethods</span><span class="s3">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s1">.utils.metadata_routing </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">MetadataRouter</span><span class="s3">,</span>
    <span class="s1">MethodMapping</span><span class="s3">,</span>
    <span class="s1">_routing_enabled</span><span class="s3">,</span>
    <span class="s1">process_routing</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">.utils.metaestimators </span><span class="s3">import </span><span class="s1">available_if</span>
<span class="s3">from </span><span class="s1">.utils.multiclass </span><span class="s3">import </span><span class="s1">check_classification_targets</span>
<span class="s3">from </span><span class="s1">.utils.parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s3">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s1">.utils.validation </span><span class="s3">import </span><span class="s1">_check_fit_params</span><span class="s3">, </span><span class="s1">check_is_fitted</span><span class="s3">, </span><span class="s1">has_fit_parameter</span>

<span class="s1">__all__ = [</span>
    <span class="s4">&quot;MultiOutputRegressor&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;MultiOutputClassifier&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;ClassifierChain&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;RegressorChain&quot;</span><span class="s3">,</span>
<span class="s1">]</span>


<span class="s3">def </span><span class="s1">_fit_estimator(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">**fit_params):</span>
    <span class="s1">estimator = clone(estimator)</span>
    <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">estimator.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight</span><span class="s3">, </span><span class="s1">**fit_params)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">estimator.fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**fit_params)</span>
    <span class="s3">return </span><span class="s1">estimator</span>


<span class="s3">def </span><span class="s1">_partial_fit_estimator(</span>
    <span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classes=</span><span class="s3">None, </span><span class="s1">partial_fit_params=</span><span class="s3">None, </span><span class="s1">first_time=</span><span class="s3">True</span>
<span class="s1">):</span>
    <span class="s1">partial_fit_params = {} </span><span class="s3">if </span><span class="s1">partial_fit_params </span><span class="s3">is None else </span><span class="s1">partial_fit_params</span>
    <span class="s3">if </span><span class="s1">first_time:</span>
        <span class="s1">estimator = clone(estimator)</span>

    <span class="s3">if </span><span class="s1">classes </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">estimator.partial_fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classes=classes</span><span class="s3">, </span><span class="s1">**partial_fit_params)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">estimator.partial_fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">**partial_fit_params)</span>
    <span class="s3">return </span><span class="s1">estimator</span>


<span class="s3">def </span><span class="s1">_available_if_estimator_has(attr):</span>
    <span class="s0">&quot;&quot;&quot;Return a function to check if the sub-estimator(s) has(have) `attr`. 
 
    Helper for Chain implementations. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_check(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;estimators_&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">all(hasattr(est</span><span class="s3">, </span><span class="s1">attr) </span><span class="s3">for </span><span class="s1">est </span><span class="s3">in </span><span class="s1">self.estimators_)</span>

        <span class="s3">if </span><span class="s1">hasattr(self.estimator</span><span class="s3">, </span><span class="s1">attr):</span>
            <span class="s3">return True</span>

        <span class="s3">return False</span>

    <span class="s3">return </span><span class="s1">available_if(_check)</span>


<span class="s3">class </span><span class="s1">_MultiOutputEstimator(MetaEstimatorMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s4">&quot;estimator&quot;</span><span class="s1">: [HasMethods([</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s1">])]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">n_jobs=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.estimator = estimator</span>
        <span class="s1">self.n_jobs = n_jobs</span>

    <span class="s1">@_available_if_estimator_has(</span><span class="s4">&quot;partial_fit&quot;</span><span class="s1">)</span>
    <span class="s1">@_fit_context(</span>
        <span class="s2"># MultiOutput*.estimator is not validated yet</span>
        <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">partial_fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classes=</span><span class="s3">None, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">**partial_fit_params):</span>
        <span class="s0">&quot;&quot;&quot;Incrementally fit a separate model for each class output. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        y : {array-like, sparse matrix} of shape (n_samples, n_outputs) 
            Multi-output targets. 
 
        classes : list of ndarray of shape (n_outputs,), default=None 
            Each array is unique classes for one output in str/int. 
            Can be obtained via 
            ``[np.unique(y[:, i]) for i in range(y.shape[1])]``, where `y` 
            is the target matrix of the entire dataset. 
            This argument is required for the first call to partial_fit 
            and can be omitted in the subsequent calls. 
            Note that `y` doesn't need to contain all labels in `classes`. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If `None`, then samples are equally weighted. 
            Only supported if the underlying regressor supports sample 
            weights. 
 
        **partial_fit_params : dict of str -&gt; object 
            Parameters passed to the ``estimator.partial_fit`` method of each 
            sub-estimator. 
 
            Only available if `enable_metadata_routing=True`. See the 
            :ref:`User Guide &lt;metadata_routing&gt;`. 
 
            .. versionadded:: 1.3 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">partial_fit_params </span><span class="s3">and not </span><span class="s1">_routing_enabled():</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;partial_fit_params is only supported if enable_metadata_routing=True.&quot;</span>
                <span class="s4">&quot; See the User Guide for more information.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">first_time = </span><span class="s3">not </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;estimators_&quot;</span><span class="s1">)</span>

        <span class="s1">y = self._validate_data(X=</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">, </span><span class="s1">y=y</span><span class="s3">, </span><span class="s1">multi_output=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;y must have at least two dimensions for &quot;</span>
                <span class="s4">&quot;multi-output regression but has only one.&quot;</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">_routing_enabled():</span>
            <span class="s1">routed_params = process_routing(</span>
                <span class="s1">obj=self</span><span class="s3">,</span>
                <span class="s1">method=</span><span class="s4">&quot;partial_fit&quot;</span><span class="s3">,</span>
                <span class="s1">other_params=partial_fit_params</span><span class="s3">,</span>
                <span class="s1">sample_weight=sample_weight</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None and not </span><span class="s1">has_fit_parameter(</span>
                <span class="s1">self.estimator</span><span class="s3">, </span><span class="s4">&quot;sample_weight&quot;</span>
            <span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Underlying estimator does not support sample weights.&quot;</span>
                <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">routed_params = Bunch(</span>
                    <span class="s1">estimator=Bunch(partial_fit=Bunch(sample_weight=sample_weight))</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">routed_params = Bunch(estimator=Bunch(partial_fit=Bunch()))</span>

        <span class="s1">self.estimators_ = Parallel(n_jobs=self.n_jobs)(</span>
            <span class="s1">delayed(_partial_fit_estimator)(</span>
                <span class="s1">self.estimators_[i] </span><span class="s3">if not </span><span class="s1">first_time </span><span class="s3">else </span><span class="s1">self.estimator</span><span class="s3">,</span>
                <span class="s1">X</span><span class="s3">,</span>
                <span class="s1">y[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">,</span>
                <span class="s1">classes[i] </span><span class="s3">if </span><span class="s1">classes </span><span class="s3">is not None else None,</span>
                <span class="s1">partial_fit_params=routed_params.estimator.partial_fit</span><span class="s3">,</span>
                <span class="s1">first_time=first_time</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(y.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">first_time </span><span class="s3">and </span><span class="s1">hasattr(self.estimators_[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;n_features_in_&quot;</span><span class="s1">):</span>
            <span class="s1">self.n_features_in_ = self.estimators_[</span><span class="s5">0</span><span class="s1">].n_features_in_</span>
        <span class="s3">if </span><span class="s1">first_time </span><span class="s3">and </span><span class="s1">hasattr(self.estimators_[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;feature_names_in_&quot;</span><span class="s1">):</span>
            <span class="s1">self.feature_names_in_ = self.estimators_[</span><span class="s5">0</span><span class="s1">].feature_names_in_</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@_fit_context(</span>
        <span class="s2"># MultiOutput*.estimator is not validated yet</span>
        <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">**fit_params):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model to data, separately for each output variable. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        y : {array-like, sparse matrix} of shape (n_samples, n_outputs) 
            Multi-output targets. An indicator matrix turns on multilabel 
            estimation. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If `None`, then samples are equally weighted. 
            Only supported if the underlying regressor supports sample 
            weights. 
 
        **fit_params : dict of string -&gt; object 
            Parameters passed to the ``estimator.fit`` method of each step. 
 
            .. versionadded:: 0.23 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">hasattr(self.estimator</span><span class="s3">, </span><span class="s4">&quot;fit&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The base estimator should implement a fit method&quot;</span><span class="s1">)</span>

        <span class="s1">y = self._validate_data(X=</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">, </span><span class="s1">y=y</span><span class="s3">, </span><span class="s1">multi_output=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">is_classifier(self):</span>
            <span class="s1">check_classification_targets(y)</span>

        <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;y must have at least two dimensions for &quot;</span>
                <span class="s4">&quot;multi-output regression but has only one.&quot;</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">_routing_enabled():</span>
            <span class="s1">routed_params = process_routing(</span>
                <span class="s1">obj=self</span><span class="s3">,</span>
                <span class="s1">method=</span><span class="s4">&quot;fit&quot;</span><span class="s3">,</span>
                <span class="s1">other_params=fit_params</span><span class="s3">,</span>
                <span class="s1">sample_weight=sample_weight</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None and not </span><span class="s1">has_fit_parameter(</span>
                <span class="s1">self.estimator</span><span class="s3">, </span><span class="s4">&quot;sample_weight&quot;</span>
            <span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Underlying estimator does not support sample weights.&quot;</span>
                <span class="s1">)</span>

            <span class="s1">fit_params_validated = _check_fit_params(X</span><span class="s3">, </span><span class="s1">fit_params)</span>
            <span class="s1">routed_params = Bunch(estimator=Bunch(fit=fit_params_validated))</span>
            <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">routed_params.estimator.fit[</span><span class="s4">&quot;sample_weight&quot;</span><span class="s1">] = sample_weight</span>

        <span class="s1">self.estimators_ = Parallel(n_jobs=self.n_jobs)(</span>
            <span class="s1">delayed(_fit_estimator)(</span>
                <span class="s1">self.estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">, </span><span class="s1">**routed_params.estimator.fit</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(y.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">hasattr(self.estimators_[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;n_features_in_&quot;</span><span class="s1">):</span>
            <span class="s1">self.n_features_in_ = self.estimators_[</span><span class="s5">0</span><span class="s1">].n_features_in_</span>
        <span class="s3">if </span><span class="s1">hasattr(self.estimators_[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;feature_names_in_&quot;</span><span class="s1">):</span>
            <span class="s1">self.feature_names_in_ = self.estimators_[</span><span class="s5">0</span><span class="s1">].feature_names_in_</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Predict multi-output variable using model for each target variable. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        Returns 
        ------- 
        y : {array-like, sparse matrix} of shape (n_samples, n_outputs) 
            Multi-output targets predicted across multiple predictors. 
            Note: Separate models are generated for each predictor. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s3">if not </span><span class="s1">hasattr(self.estimators_[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The base estimator should implement a predict method&quot;</span><span class="s1">)</span>

        <span class="s1">y = Parallel(n_jobs=self.n_jobs)(</span>
            <span class="s1">delayed(e.predict)(X) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self.estimators_</span>
        <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">np.asarray(y).T</span>

    <span class="s3">def </span><span class="s1">_more_tags(self):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing(self):</span>
        <span class="s0">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.3 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s1">router = MetadataRouter(owner=self.__class__.__name__).add(</span>
            <span class="s1">estimator=self.estimator</span><span class="s3">,</span>
            <span class="s1">method_mapping=MethodMapping()</span>
            <span class="s1">.add(callee=</span><span class="s4">&quot;partial_fit&quot;</span><span class="s3">, </span><span class="s1">caller=</span><span class="s4">&quot;partial_fit&quot;</span><span class="s1">)</span>
            <span class="s1">.add(callee=</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">caller=</span><span class="s4">&quot;fit&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">router</span>


<span class="s3">class </span><span class="s1">MultiOutputRegressor(RegressorMixin</span><span class="s3">, </span><span class="s1">_MultiOutputEstimator):</span>
    <span class="s0">&quot;&quot;&quot;Multi target regression. 
 
    This strategy consists of fitting one regressor per target. This is a 
    simple strategy for extending regressors that do not natively support 
    multi-target regression. 
 
    .. versionadded:: 0.18 
 
    Parameters 
    ---------- 
    estimator : estimator object 
        An estimator object implementing :term:`fit` and :term:`predict`. 
 
    n_jobs : int or None, optional (default=None) 
        The number of jobs to run in parallel. 
        :meth:`fit`, :meth:`predict` and :meth:`partial_fit` (if supported 
        by the passed estimator) will be parallelized for each target. 
 
        When individual estimators are fast to train or predict, 
        using ``n_jobs &gt; 1`` can result in slower performance due 
        to the parallelism overhead. 
 
        ``None`` means `1` unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all available processes / threads. 
        See :term:`Glossary &lt;n_jobs&gt;` for more details. 
 
        .. versionchanged:: 0.20 
            `n_jobs` default changed from `1` to `None`. 
 
    Attributes 
    ---------- 
    estimators_ : list of ``n_output`` estimators 
        Estimators used for predictions. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying `estimator` exposes such an attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Only defined if the 
        underlying estimators expose such an attribute when fit. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    RegressorChain : A multi-label model that arranges regressions into a 
        chain. 
    MultiOutputClassifier : Classifies each output independently rather than 
        chaining. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.datasets import load_linnerud 
    &gt;&gt;&gt; from sklearn.multioutput import MultiOutputRegressor 
    &gt;&gt;&gt; from sklearn.linear_model import Ridge 
    &gt;&gt;&gt; X, y = load_linnerud(return_X_y=True) 
    &gt;&gt;&gt; regr = MultiOutputRegressor(Ridge(random_state=123)).fit(X, y) 
    &gt;&gt;&gt; regr.predict(X[[0]]) 
    array([[176..., 35..., 57...]]) 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">n_jobs=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(estimator</span><span class="s3">, </span><span class="s1">n_jobs=n_jobs)</span>

    <span class="s1">@_available_if_estimator_has(</span><span class="s4">&quot;partial_fit&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">partial_fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">**partial_fit_params):</span>
        <span class="s0">&quot;&quot;&quot;Incrementally fit the model to data, for each output variable. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        y : {array-like, sparse matrix} of shape (n_samples, n_outputs) 
            Multi-output targets. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If `None`, then samples are equally weighted. 
            Only supported if the underlying regressor supports sample 
            weights. 
 
        **partial_fit_params : dict of str -&gt; object 
            Parameters passed to the ``estimator.partial_fit`` method of each 
            sub-estimator. 
 
            Only available if `enable_metadata_routing=True`. See the 
            :ref:`User Guide &lt;metadata_routing&gt;`. 
 
            .. versionadded:: 1.3 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().partial_fit(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight</span><span class="s3">, </span><span class="s1">**partial_fit_params)</span>


<span class="s3">class </span><span class="s1">MultiOutputClassifier(ClassifierMixin</span><span class="s3">, </span><span class="s1">_MultiOutputEstimator):</span>
    <span class="s0">&quot;&quot;&quot;Multi target classification. 
 
    This strategy consists of fitting one classifier per target. This is a 
    simple strategy for extending classifiers that do not natively support 
    multi-target classification. 
 
    Parameters 
    ---------- 
    estimator : estimator object 
        An estimator object implementing :term:`fit` and :term:`predict`. 
        A :term:`predict_proba` method will be exposed only if `estimator` implements 
        it. 
 
    n_jobs : int or None, optional (default=None) 
        The number of jobs to run in parallel. 
        :meth:`fit`, :meth:`predict` and :meth:`partial_fit` (if supported 
        by the passed estimator) will be parallelized for each target. 
 
        When individual estimators are fast to train or predict, 
        using ``n_jobs &gt; 1`` can result in slower performance due 
        to the parallelism overhead. 
 
        ``None`` means `1` unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all available processes / threads. 
        See :term:`Glossary &lt;n_jobs&gt;` for more details. 
 
        .. versionchanged:: 0.20 
            `n_jobs` default changed from `1` to `None`. 
 
    Attributes 
    ---------- 
    classes_ : ndarray of shape (n_classes,) 
        Class labels. 
 
    estimators_ : list of ``n_output`` estimators 
        Estimators used for predictions. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying `estimator` exposes such an attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Only defined if the 
        underlying estimators expose such an attribute when fit. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    ClassifierChain : A multi-label model that arranges binary classifiers 
        into a chain. 
    MultiOutputRegressor : Fits one regressor per target variable. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.datasets import make_multilabel_classification 
    &gt;&gt;&gt; from sklearn.multioutput import MultiOutputClassifier 
    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression 
    &gt;&gt;&gt; X, y = make_multilabel_classification(n_classes=3, random_state=0) 
    &gt;&gt;&gt; clf = MultiOutputClassifier(LogisticRegression()).fit(X, y) 
    &gt;&gt;&gt; clf.predict(X[-2:]) 
    array([[1, 1, 1], 
           [1, 0, 1]]) 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">n_jobs=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(estimator</span><span class="s3">, </span><span class="s1">n_jobs=n_jobs)</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">sample_weight=</span><span class="s3">None, </span><span class="s1">**fit_params):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model to data matrix X and targets Y. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        Y : array-like of shape (n_samples, n_classes) 
            The target values. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If `None`, then samples are equally weighted. 
            Only supported if the underlying classifier supports sample 
            weights. 
 
        **fit_params : dict of string -&gt; object 
            Parameters passed to the ``estimator.fit`` method of each step. 
 
            .. versionadded:: 0.23 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().fit(X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">sample_weight=sample_weight</span><span class="s3">, </span><span class="s1">**fit_params)</span>
        <span class="s1">self.classes_ = [estimator.classes_ </span><span class="s3">for </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">self.estimators_]</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_check_predict_proba(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;estimators_&quot;</span><span class="s1">):</span>
            <span class="s2"># raise an AttributeError if `predict_proba` does not exist for</span>
            <span class="s2"># each estimator</span>
            <span class="s1">[getattr(est</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s1">) </span><span class="s3">for </span><span class="s1">est </span><span class="s3">in </span><span class="s1">self.estimators_]</span>
            <span class="s3">return True</span>
        <span class="s2"># raise an AttributeError if `predict_proba` does not exist for the</span>
        <span class="s2"># unfitted estimator</span>
        <span class="s1">getattr(self.estimator</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s1">)</span>
        <span class="s3">return True</span>

    <span class="s1">@available_if(_check_predict_proba)</span>
    <span class="s3">def </span><span class="s1">predict_proba(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Return prediction probabilities for each class of each output. 
 
        This method will raise a ``ValueError`` if any of the 
        estimators do not have ``predict_proba``. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The input data. 
 
        Returns 
        ------- 
        p : array of shape (n_samples, n_classes), or a list of n_outputs \ 
                such arrays if n_outputs &gt; 1. 
            The class probabilities of the input samples. The order of the 
            classes corresponds to that in the attribute :term:`classes_`. 
 
            .. versionchanged:: 0.19 
                This function now returns a list of arrays where the length of 
                the list is ``n_outputs``, and each array is (``n_samples``, 
                ``n_classes``) for that particular output. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s1">results = [estimator.predict_proba(X) </span><span class="s3">for </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">self.estimators_]</span>
        <span class="s3">return </span><span class="s1">results</span>

    <span class="s3">def </span><span class="s1">score(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot;Return the mean accuracy on the given test data and labels. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Test samples. 
 
        y : array-like of shape (n_samples, n_outputs) 
            True values for X. 
 
        Returns 
        ------- 
        scores : float 
            Mean accuracy of predicted target versus true target. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s1">n_outputs_ = len(self.estimators_)</span>
        <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;y must have at least two dimensions for &quot;</span>
                <span class="s4">&quot;multi target classification but has only one&quot;</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">y.shape[</span><span class="s5">1</span><span class="s1">] != n_outputs_:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The number of outputs of Y for fit {0} and&quot;</span>
                <span class="s4">&quot; score {1} should be same&quot;</span><span class="s1">.format(n_outputs_</span><span class="s3">, </span><span class="s1">y.shape[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">)</span>
        <span class="s1">y_pred = self.predict(X)</span>
        <span class="s3">return </span><span class="s1">np.mean(np.all(y == y_pred</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">_more_tags(self):</span>
        <span class="s2"># FIXME</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;_skip_test&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>


<span class="s3">def </span><span class="s1">_available_if_base_estimator_has(attr):</span>
    <span class="s0">&quot;&quot;&quot;Return a function to check if `base_estimator` or `estimators_` has `attr`. 
 
    Helper for Chain implementations. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_check(self):</span>
        <span class="s3">return </span><span class="s1">hasattr(self.base_estimator</span><span class="s3">, </span><span class="s1">attr) </span><span class="s3">or </span><span class="s1">all(</span>
            <span class="s1">hasattr(est</span><span class="s3">, </span><span class="s1">attr) </span><span class="s3">for </span><span class="s1">est </span><span class="s3">in </span><span class="s1">self.estimators_</span>
        <span class="s1">)</span>

    <span class="s3">return </span><span class="s1">available_if(_check)</span>


<span class="s3">class </span><span class="s1">_BaseChain(BaseEstimator</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s4">&quot;base_estimator&quot;</span><span class="s1">: [HasMethods([</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s1">])]</span><span class="s3">,</span>
        <span class="s4">&quot;order&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, </span><span class="s1">StrOptions({</span><span class="s4">&quot;random&quot;</span><span class="s1">})</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;cv&quot;</span><span class="s1">: [</span><span class="s4">&quot;cv_object&quot;</span><span class="s3">, </span><span class="s1">StrOptions({</span><span class="s4">&quot;prefit&quot;</span><span class="s1">})]</span><span class="s3">,</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s1">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">base_estimator</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None, </span><span class="s1">cv=</span><span class="s3">None, </span><span class="s1">random_state=</span><span class="s3">None, </span><span class="s1">verbose=</span><span class="s3">False</span>
    <span class="s1">):</span>
        <span class="s1">self.base_estimator = base_estimator</span>
        <span class="s1">self.order = order</span>
        <span class="s1">self.cv = cv</span>
        <span class="s1">self.random_state = random_state</span>
        <span class="s1">self.verbose = verbose</span>

    <span class="s3">def </span><span class="s1">_log_message(self</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">estimator_idx</span><span class="s3">, </span><span class="s1">n_estimators</span><span class="s3">, </span><span class="s1">processing_msg):</span>
        <span class="s3">if not </span><span class="s1">self.verbose:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s4">f&quot;(</span><span class="s3">{</span><span class="s1">estimator_idx</span><span class="s3">} </span><span class="s4">of </span><span class="s3">{</span><span class="s1">n_estimators</span><span class="s3">}</span><span class="s4">) </span><span class="s3">{</span><span class="s1">processing_msg</span><span class="s3">}</span><span class="s4">&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">**fit_params):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model to data matrix X and targets Y. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        Y : array-like of shape (n_samples, n_classes) 
            The target values. 
 
        **fit_params : dict of string -&gt; object 
            Parameters passed to the `fit` method of each step. 
 
            .. versionadded:: 0.23 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">Y = self._validate_data(X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">multi_output=</span><span class="s3">True, </span><span class="s1">accept_sparse=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">random_state = check_random_state(self.random_state)</span>
        <span class="s1">self.order_ = self.order</span>
        <span class="s3">if </span><span class="s1">isinstance(self.order_</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s1">self.order_ = np.array(self.order_)</span>

        <span class="s3">if </span><span class="s1">self.order_ </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.order_ = np.array(range(Y.shape[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s3">elif </span><span class="s1">isinstance(self.order_</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">if </span><span class="s1">self.order_ == </span><span class="s4">&quot;random&quot;</span><span class="s1">:</span>
                <span class="s1">self.order_ = random_state.permutation(Y.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s3">elif </span><span class="s1">sorted(self.order_) != list(range(Y.shape[</span><span class="s5">1</span><span class="s1">])):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid order&quot;</span><span class="s1">)</span>

        <span class="s1">self.estimators_ = [clone(self.base_estimator) </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(Y.shape[</span><span class="s5">1</span><span class="s1">])]</span>

        <span class="s3">if </span><span class="s1">self.cv </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">Y_pred_chain = Y[:</span><span class="s3">, </span><span class="s1">self.order_]</span>
            <span class="s3">if </span><span class="s1">sp.issparse(X):</span>
                <span class="s1">X_aug = sp.hstack((X</span><span class="s3">, </span><span class="s1">Y_pred_chain)</span><span class="s3">, </span><span class="s1">format=</span><span class="s4">&quot;lil&quot;</span><span class="s1">)</span>
                <span class="s1">X_aug = X_aug.tocsr()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">X_aug = np.hstack((X</span><span class="s3">, </span><span class="s1">Y_pred_chain))</span>

        <span class="s3">elif </span><span class="s1">sp.issparse(X):</span>
            <span class="s1">Y_pred_chain = sp.lil_matrix((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">Y.shape[</span><span class="s5">1</span><span class="s1">]))</span>
            <span class="s1">X_aug = sp.hstack((X</span><span class="s3">, </span><span class="s1">Y_pred_chain)</span><span class="s3">, </span><span class="s1">format=</span><span class="s4">&quot;lil&quot;</span><span class="s1">)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">Y_pred_chain = np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">Y.shape[</span><span class="s5">1</span><span class="s1">]))</span>
            <span class="s1">X_aug = np.hstack((X</span><span class="s3">, </span><span class="s1">Y_pred_chain))</span>

        <span class="s3">del </span><span class="s1">Y_pred_chain</span>

        <span class="s3">if </span><span class="s1">_routing_enabled():</span>
            <span class="s1">routed_params = process_routing(</span>
                <span class="s1">obj=self</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">other_params=fit_params</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">routed_params = Bunch(estimator=Bunch(fit=fit_params))</span>

        <span class="s3">for </span><span class="s1">chain_idx</span><span class="s3">, </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">enumerate(self.estimators_):</span>
            <span class="s1">message = self._log_message(</span>
                <span class="s1">estimator_idx=chain_idx + </span><span class="s5">1</span><span class="s3">,</span>
                <span class="s1">n_estimators=len(self.estimators_)</span><span class="s3">,</span>
                <span class="s1">processing_msg=</span><span class="s4">f&quot;Processing order </span><span class="s3">{</span><span class="s1">self.order_[chain_idx]</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">y = Y[:</span><span class="s3">, </span><span class="s1">self.order_[chain_idx]]</span>
            <span class="s3">with </span><span class="s1">_print_elapsed_time(</span><span class="s4">&quot;Chain&quot;</span><span class="s3">, </span><span class="s1">message):</span>
                <span class="s1">estimator.fit(</span>
                    <span class="s1">X_aug[:</span><span class="s3">, </span><span class="s1">: (X.shape[</span><span class="s5">1</span><span class="s1">] + chain_idx)]</span><span class="s3">,</span>
                    <span class="s1">y</span><span class="s3">,</span>
                    <span class="s1">**routed_params.estimator.fit</span><span class="s3">,</span>
                <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">self.cv </span><span class="s3">is not None and </span><span class="s1">chain_idx &lt; len(self.estimators_) - </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">col_idx = X.shape[</span><span class="s5">1</span><span class="s1">] + chain_idx</span>
                <span class="s1">cv_result = cross_val_predict(</span>
                    <span class="s1">self.base_estimator</span><span class="s3">, </span><span class="s1">X_aug[:</span><span class="s3">, </span><span class="s1">:col_idx]</span><span class="s3">, </span><span class="s1">y=y</span><span class="s3">, </span><span class="s1">cv=self.cv</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">sp.issparse(X_aug):</span>
                    <span class="s1">X_aug[:</span><span class="s3">, </span><span class="s1">col_idx] = np.expand_dims(cv_result</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">X_aug[:</span><span class="s3">, </span><span class="s1">col_idx] = cv_result</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Predict on the data matrix X using the ClassifierChain model. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        Returns 
        ------- 
        Y_pred : array-like of shape (n_samples, n_classes) 
            The predicted values. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted(self)</span>
        <span class="s1">X = self._validate_data(X</span><span class="s3">, </span><span class="s1">accept_sparse=</span><span class="s3">True, </span><span class="s1">reset=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">Y_pred_chain = np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">len(self.estimators_)))</span>
        <span class="s3">for </span><span class="s1">chain_idx</span><span class="s3">, </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">enumerate(self.estimators_):</span>
            <span class="s1">previous_predictions = Y_pred_chain[:</span><span class="s3">, </span><span class="s1">:chain_idx]</span>
            <span class="s3">if </span><span class="s1">sp.issparse(X):</span>
                <span class="s3">if </span><span class="s1">chain_idx == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">X_aug = X</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">X_aug = sp.hstack((X</span><span class="s3">, </span><span class="s1">previous_predictions))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">X_aug = np.hstack((X</span><span class="s3">, </span><span class="s1">previous_predictions))</span>
            <span class="s1">Y_pred_chain[:</span><span class="s3">, </span><span class="s1">chain_idx] = estimator.predict(X_aug)</span>

        <span class="s1">inv_order = np.empty_like(self.order_)</span>
        <span class="s1">inv_order[self.order_] = np.arange(len(self.order_))</span>
        <span class="s1">Y_pred = Y_pred_chain[:</span><span class="s3">, </span><span class="s1">inv_order]</span>

        <span class="s3">return </span><span class="s1">Y_pred</span>


<span class="s3">class </span><span class="s1">ClassifierChain(MetaEstimatorMixin</span><span class="s3">, </span><span class="s1">ClassifierMixin</span><span class="s3">, </span><span class="s1">_BaseChain):</span>
    <span class="s0">&quot;&quot;&quot;A multi-label model that arranges binary classifiers into a chain. 
 
    Each model makes a prediction in the order specified by the chain using 
    all of the available features provided to the model plus the predictions 
    of models that are earlier in the chain. 
 
    For an example of how to use ``ClassifierChain`` and benefit from its 
    ensemble, see 
    :ref:`ClassifierChain on a yeast dataset 
    &lt;sphx_glr_auto_examples_multioutput_plot_classifier_chain_yeast.py&gt;` example. 
 
    Read more in the :ref:`User Guide &lt;classifierchain&gt;`. 
 
    .. versionadded:: 0.19 
 
    Parameters 
    ---------- 
    base_estimator : estimator 
        The base estimator from which the classifier chain is built. 
 
    order : array-like of shape (n_outputs,) or 'random', default=None 
        If `None`, the order will be determined by the order of columns in 
        the label matrix Y.:: 
 
            order = [0, 1, 2, ..., Y.shape[1] - 1] 
 
        The order of the chain can be explicitly set by providing a list of 
        integers. For example, for a chain of length 5.:: 
 
            order = [1, 3, 2, 4, 0] 
 
        means that the first model in the chain will make predictions for 
        column 1 in the Y matrix, the second model will make predictions 
        for column 3, etc. 
 
        If order is `random` a random ordering will be used. 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines whether to use cross validated predictions or true 
        labels for the results of previous estimators in the chain. 
        Possible inputs for cv are: 
 
        - None, to use true labels when fitting, 
        - integer, to specify the number of folds in a (Stratified)KFold, 
        - :term:`CV splitter`, 
        - An iterable yielding (train, test) splits as arrays of indices. 
 
    random_state : int, RandomState instance or None, optional (default=None) 
        If ``order='random'``, determines random number generation for the 
        chain order. 
        In addition, it controls the random seed given at each `base_estimator` 
        at each chaining iteration. Thus, it is only used when `base_estimator` 
        exposes a `random_state`. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    verbose : bool, default=False 
        If True, chain progress is output as each model is completed. 
 
        .. versionadded:: 1.2 
 
    Attributes 
    ---------- 
    classes_ : list 
        A list of arrays of length ``len(estimators_)`` containing the 
        class labels for each estimator in the chain. 
 
    estimators_ : list 
        A list of clones of base_estimator. 
 
    order_ : list 
        The order of labels in the classifier chain. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying `base_estimator` exposes such an attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    RegressorChain : Equivalent for regression. 
    MultiOutputClassifier : Classifies each output independently rather than 
        chaining. 
 
    References 
    ---------- 
    Jesse Read, Bernhard Pfahringer, Geoff Holmes, Eibe Frank, &quot;Classifier 
    Chains for Multi-label Classification&quot;, 2009. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import make_multilabel_classification 
    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression 
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split 
    &gt;&gt;&gt; from sklearn.multioutput import ClassifierChain 
    &gt;&gt;&gt; X, Y = make_multilabel_classification( 
    ...    n_samples=12, n_classes=3, random_state=0 
    ... ) 
    &gt;&gt;&gt; X_train, X_test, Y_train, Y_test = train_test_split( 
    ...    X, Y, random_state=0 
    ... ) 
    &gt;&gt;&gt; base_lr = LogisticRegression(solver='lbfgs', random_state=0) 
    &gt;&gt;&gt; chain = ClassifierChain(base_lr, order='random', random_state=0) 
    &gt;&gt;&gt; chain.fit(X_train, Y_train).predict(X_test) 
    array([[1., 1., 0.], 
           [1., 0., 0.], 
           [0., 1., 0.]]) 
    &gt;&gt;&gt; chain.predict_proba(X_test) 
    array([[0.8387..., 0.9431..., 0.4576...], 
           [0.8878..., 0.3684..., 0.2640...], 
           [0.0321..., 0.9935..., 0.0625...]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">@_fit_context(</span>
        <span class="s2"># ClassifierChain.base_estimator is not validated yet</span>
        <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">**fit_params):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model to data matrix X and targets Y. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        Y : array-like of shape (n_samples, n_classes) 
            The target values. 
 
        **fit_params : dict of string -&gt; object 
            Parameters passed to the `fit` method of each step. 
 
            Only available if `enable_metadata_routing=True`. See the 
            :ref:`User Guide &lt;metadata_routing&gt;`. 
 
            .. versionadded:: 1.3 
 
        Returns 
        ------- 
        self : object 
            Class instance. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">fit_params </span><span class="s3">and not </span><span class="s1">_routing_enabled():</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;fit_params is only supported if enable_metadata_routing=True. &quot;</span>
                <span class="s4">&quot;See the User Guide for more information.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">super().fit(X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">**fit_params)</span>
        <span class="s1">self.classes_ = [</span>
            <span class="s1">estimator.classes_ </span><span class="s3">for </span><span class="s1">chain_idx</span><span class="s3">, </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">enumerate(self.estimators_)</span>
        <span class="s1">]</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@_available_if_base_estimator_has(</span><span class="s4">&quot;predict_proba&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">predict_proba(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Predict probability estimates. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        Returns 
        ------- 
        Y_prob : array-like of shape (n_samples, n_classes) 
            The predicted probabilities. 
        &quot;&quot;&quot;</span>
        <span class="s1">X = self._validate_data(X</span><span class="s3">, </span><span class="s1">accept_sparse=</span><span class="s3">True, </span><span class="s1">reset=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">Y_prob_chain = np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">len(self.estimators_)))</span>
        <span class="s1">Y_pred_chain = np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">len(self.estimators_)))</span>
        <span class="s3">for </span><span class="s1">chain_idx</span><span class="s3">, </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">enumerate(self.estimators_):</span>
            <span class="s1">previous_predictions = Y_pred_chain[:</span><span class="s3">, </span><span class="s1">:chain_idx]</span>
            <span class="s3">if </span><span class="s1">sp.issparse(X):</span>
                <span class="s1">X_aug = sp.hstack((X</span><span class="s3">, </span><span class="s1">previous_predictions))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">X_aug = np.hstack((X</span><span class="s3">, </span><span class="s1">previous_predictions))</span>
            <span class="s1">Y_prob_chain[:</span><span class="s3">, </span><span class="s1">chain_idx] = estimator.predict_proba(X_aug)[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">Y_pred_chain[:</span><span class="s3">, </span><span class="s1">chain_idx] = estimator.predict(X_aug)</span>
        <span class="s1">inv_order = np.empty_like(self.order_)</span>
        <span class="s1">inv_order[self.order_] = np.arange(len(self.order_))</span>
        <span class="s1">Y_prob = Y_prob_chain[:</span><span class="s3">, </span><span class="s1">inv_order]</span>

        <span class="s3">return </span><span class="s1">Y_prob</span>

    <span class="s1">@_available_if_base_estimator_has(</span><span class="s4">&quot;decision_function&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">decision_function(self</span><span class="s3">, </span><span class="s1">X):</span>
        <span class="s0">&quot;&quot;&quot;Evaluate the decision_function of the models in the chain. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The input data. 
 
        Returns 
        ------- 
        Y_decision : array-like of shape (n_samples, n_classes) 
            Returns the decision function of the sample for each model 
            in the chain. 
        &quot;&quot;&quot;</span>
        <span class="s1">X = self._validate_data(X</span><span class="s3">, </span><span class="s1">accept_sparse=</span><span class="s3">True, </span><span class="s1">reset=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">Y_decision_chain = np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">len(self.estimators_)))</span>
        <span class="s1">Y_pred_chain = np.zeros((X.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">len(self.estimators_)))</span>
        <span class="s3">for </span><span class="s1">chain_idx</span><span class="s3">, </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">enumerate(self.estimators_):</span>
            <span class="s1">previous_predictions = Y_pred_chain[:</span><span class="s3">, </span><span class="s1">:chain_idx]</span>
            <span class="s3">if </span><span class="s1">sp.issparse(X):</span>
                <span class="s1">X_aug = sp.hstack((X</span><span class="s3">, </span><span class="s1">previous_predictions))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">X_aug = np.hstack((X</span><span class="s3">, </span><span class="s1">previous_predictions))</span>
            <span class="s1">Y_decision_chain[:</span><span class="s3">, </span><span class="s1">chain_idx] = estimator.decision_function(X_aug)</span>
            <span class="s1">Y_pred_chain[:</span><span class="s3">, </span><span class="s1">chain_idx] = estimator.predict(X_aug)</span>

        <span class="s1">inv_order = np.empty_like(self.order_)</span>
        <span class="s1">inv_order[self.order_] = np.arange(len(self.order_))</span>
        <span class="s1">Y_decision = Y_decision_chain[:</span><span class="s3">, </span><span class="s1">inv_order]</span>

        <span class="s3">return </span><span class="s1">Y_decision</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing(self):</span>
        <span class="s0">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.3 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s1">router = MetadataRouter(owner=self.__class__.__name__).add(</span>
            <span class="s1">estimator=self.base_estimator</span><span class="s3">,</span>
            <span class="s1">method_mapping=MethodMapping().add(callee=</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">caller=</span><span class="s4">&quot;fit&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">router</span>

    <span class="s3">def </span><span class="s1">_more_tags(self):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;_skip_test&quot;</span><span class="s1">: </span><span class="s3">True, </span><span class="s4">&quot;multioutput_only&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>


<span class="s3">class </span><span class="s1">RegressorChain(MetaEstimatorMixin</span><span class="s3">, </span><span class="s1">RegressorMixin</span><span class="s3">, </span><span class="s1">_BaseChain):</span>
    <span class="s0">&quot;&quot;&quot;A multi-label model that arranges regressions into a chain. 
 
    Each model makes a prediction in the order specified by the chain using 
    all of the available features provided to the model plus the predictions 
    of models that are earlier in the chain. 
 
    Read more in the :ref:`User Guide &lt;regressorchain&gt;`. 
 
    .. versionadded:: 0.20 
 
    Parameters 
    ---------- 
    base_estimator : estimator 
        The base estimator from which the regressor chain is built. 
 
    order : array-like of shape (n_outputs,) or 'random', default=None 
        If `None`, the order will be determined by the order of columns in 
        the label matrix Y.:: 
 
            order = [0, 1, 2, ..., Y.shape[1] - 1] 
 
        The order of the chain can be explicitly set by providing a list of 
        integers. For example, for a chain of length 5.:: 
 
            order = [1, 3, 2, 4, 0] 
 
        means that the first model in the chain will make predictions for 
        column 1 in the Y matrix, the second model will make predictions 
        for column 3, etc. 
 
        If order is 'random' a random ordering will be used. 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines whether to use cross validated predictions or true 
        labels for the results of previous estimators in the chain. 
        Possible inputs for cv are: 
 
        - None, to use true labels when fitting, 
        - integer, to specify the number of folds in a (Stratified)KFold, 
        - :term:`CV splitter`, 
        - An iterable yielding (train, test) splits as arrays of indices. 
 
    random_state : int, RandomState instance or None, optional (default=None) 
        If ``order='random'``, determines random number generation for the 
        chain order. 
        In addition, it controls the random seed given at each `base_estimator` 
        at each chaining iteration. Thus, it is only used when `base_estimator` 
        exposes a `random_state`. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    verbose : bool, default=False 
        If True, chain progress is output as each model is completed. 
 
        .. versionadded:: 1.2 
 
    Attributes 
    ---------- 
    estimators_ : list 
        A list of clones of base_estimator. 
 
    order_ : list 
        The order of labels in the classifier chain. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying `base_estimator` exposes such an attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    ClassifierChain : Equivalent for classification. 
    MultiOutputRegressor : Learns each output independently rather than 
        chaining. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.multioutput import RegressorChain 
    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression 
    &gt;&gt;&gt; logreg = LogisticRegression(solver='lbfgs',multi_class='multinomial') 
    &gt;&gt;&gt; X, Y = [[1, 0], [0, 1], [1, 1]], [[0, 2], [1, 1], [2, 0]] 
    &gt;&gt;&gt; chain = RegressorChain(base_estimator=logreg, order=[0, 1]).fit(X, Y) 
    &gt;&gt;&gt; chain.predict(X) 
    array([[0., 2.], 
           [1., 1.], 
           [2., 0.]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">@_fit_context(</span>
        <span class="s2"># RegressorChain.base_estimator is not validated yet</span>
        <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">**fit_params):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model to data matrix X and targets Y. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input data. 
 
        Y : array-like of shape (n_samples, n_classes) 
            The target values. 
 
        **fit_params : dict of string -&gt; object 
            Parameters passed to the `fit` method at each step 
            of the regressor chain. 
 
            .. versionadded:: 0.23 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().fit(X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">**fit_params)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing(self):</span>
        <span class="s0">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.3 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s1">router = MetadataRouter(owner=self.__class__.__name__).add(</span>
            <span class="s1">estimator=self.base_estimator</span><span class="s3">,</span>
            <span class="s1">method_mapping=MethodMapping().add(callee=</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s1">caller=</span><span class="s4">&quot;fit&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">router</span>

    <span class="s3">def </span><span class="s1">_more_tags(self):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>
</pre>
</body>
</html>