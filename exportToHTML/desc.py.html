<html>
<head>
<title>desc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
desc.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is part of Patsy</span>
<span class="s0"># Copyright (C) 2011-2012 Nathaniel Smith &lt;njs@pobox.com&gt;</span>
<span class="s0"># See file LICENSE.txt for license information.</span>

<span class="s0"># This file defines the ModelDesc class, which describes a model at a high</span>
<span class="s0"># level, as a list of interactions of factors. It also has the code to convert</span>
<span class="s0"># a formula parse tree (from patsy.parse_formula) into a ModelDesc.</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function</span>

<span class="s2">import </span><span class="s1">six</span>
<span class="s2">from </span><span class="s1">patsy </span><span class="s2">import </span><span class="s1">PatsyError</span>
<span class="s2">from </span><span class="s1">patsy.parse_formula </span><span class="s2">import </span><span class="s1">ParseNode</span><span class="s2">, </span><span class="s1">Token</span><span class="s2">, </span><span class="s1">parse_formula</span>
<span class="s2">from </span><span class="s1">patsy.eval </span><span class="s2">import </span><span class="s1">EvalEnvironment</span><span class="s2">, </span><span class="s1">EvalFactor</span>
<span class="s2">from </span><span class="s1">patsy.util </span><span class="s2">import </span><span class="s1">uniqueify_list</span>
<span class="s2">from </span><span class="s1">patsy.util </span><span class="s2">import </span><span class="s1">repr_pretty_delegate</span><span class="s2">, </span><span class="s1">repr_pretty_impl</span>
<span class="s2">from </span><span class="s1">patsy.util </span><span class="s2">import </span><span class="s1">no_pickling</span><span class="s2">, </span><span class="s1">assert_no_pickling</span>

<span class="s0"># These are made available in the patsy.* namespace</span>
<span class="s1">__all__ = [</span><span class="s3">&quot;Term&quot;</span><span class="s2">, </span><span class="s3">&quot;ModelDesc&quot;</span><span class="s2">, </span><span class="s3">&quot;INTERCEPT&quot;</span><span class="s1">]</span>

<span class="s0"># One might think it would make more sense for 'factors' to be a set, rather</span>
<span class="s0"># than a tuple-with-guaranteed-unique-entries-that-compares-like-a-set. The</span>
<span class="s0"># reason we do it this way is that it preserves the order that the user typed</span>
<span class="s0"># and is expecting, which then ends up producing nicer names in our final</span>
<span class="s0"># output, nicer column ordering, etc. (A similar comment applies to the</span>
<span class="s0"># ordering of terms in ModelDesc objects as a whole.)</span>
<span class="s2">class </span><span class="s1">Term(object):</span>
    <span class="s4">&quot;&quot;&quot;The interaction between a collection of factor objects. 
 
    This is one of the basic types used in representing formulas, and 
    corresponds to an expression like ``&quot;a:b:c&quot;`` in a formula string. 
    For details, see :ref:`formulas` and :ref:`expert-model-specification`. 
 
    Terms are hashable and compare by value. 
 
    Attributes: 
     
    .. attribute:: factors 
 
       A tuple of factor objects. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">factors):</span>
        <span class="s1">self.factors = tuple(uniqueify_list(factors))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">(isinstance(other</span><span class="s2">, </span><span class="s1">Term)</span>
                <span class="s2">and </span><span class="s1">frozenset(other.factors) == frozenset(self.factors))</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((Term</span><span class="s2">, </span><span class="s1">frozenset(self.factors)))</span>

    <span class="s1">__repr__ = repr_pretty_delegate</span>
    <span class="s2">def </span><span class="s1">_repr_pretty_(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">cycle):</span>
        <span class="s2">assert not </span><span class="s1">cycle</span>
        <span class="s1">repr_pretty_impl(p</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">[list(self.factors)])</span>

    <span class="s2">def </span><span class="s1">name(self):</span>
        <span class="s4">&quot;&quot;&quot;Return a human-readable name for this term.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.factors:</span>
            <span class="s2">return </span><span class="s3">&quot;:&quot;</span><span class="s1">.join([f.name() </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.factors])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;Intercept&quot;</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s1">INTERCEPT = Term([])</span>

<span class="s2">class </span><span class="s1">_MockFactor(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">self._name = name</span>

    <span class="s2">def </span><span class="s1">name(self):</span>
        <span class="s2">return </span><span class="s1">self._name</span>

<span class="s2">def </span><span class="s1">test_Term():</span>
    <span class="s2">assert </span><span class="s1">Term([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]).factors == (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">Term([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]) == Term([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">hash(Term([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])) == hash(Term([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
    <span class="s1">f1 = _MockFactor(</span><span class="s3">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">f2 = _MockFactor(</span><span class="s3">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">Term([f1</span><span class="s2">, </span><span class="s1">f2]).name() == </span><span class="s3">&quot;a:b&quot;</span>
    <span class="s2">assert </span><span class="s1">Term([f2</span><span class="s2">, </span><span class="s1">f1]).name() == </span><span class="s3">&quot;b:a&quot;</span>
    <span class="s2">assert </span><span class="s1">Term([]).name() == </span><span class="s3">&quot;Intercept&quot;</span>

    <span class="s1">assert_no_pickling(Term([]))</span>

<span class="s2">class </span><span class="s1">ModelDesc(object):</span>
    <span class="s4">&quot;&quot;&quot;A simple container representing the termlists parsed from a formula. 
 
    This is a simple container object which has exactly the same 
    representational power as a formula string, but is a Python object 
    instead. You can construct one by hand, and pass it to functions like 
    :func:`dmatrix` or :func:`incr_dbuilder` that are expecting a formula 
    string, but without having to do any messy string manipulation. For 
    details see :ref:`expert-model-specification`. 
 
    Attributes: 
 
    .. attribute:: lhs_termlist 
                   rhs_termlist 
 
       Two termlists representing the left- and right-hand sides of a 
       formula, suitable for passing to :func:`design_matrix_builders`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">lhs_termlist</span><span class="s2">, </span><span class="s1">rhs_termlist):</span>
        <span class="s1">self.lhs_termlist = uniqueify_list(lhs_termlist)</span>
        <span class="s1">self.rhs_termlist = uniqueify_list(rhs_termlist)</span>

    <span class="s1">__repr__ = repr_pretty_delegate</span>
    <span class="s2">def </span><span class="s1">_repr_pretty_(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">cycle):</span>
        <span class="s2">assert not </span><span class="s1">cycle</span>
        <span class="s2">return </span><span class="s1">repr_pretty_impl(p</span><span class="s2">, </span><span class="s1">self</span><span class="s2">,</span>
                                <span class="s1">[]</span><span class="s2">,</span>
                                <span class="s1">[(</span><span class="s3">&quot;lhs_termlist&quot;</span><span class="s2">, </span><span class="s1">self.lhs_termlist)</span><span class="s2">,</span>
                                 <span class="s1">(</span><span class="s3">&quot;rhs_termlist&quot;</span><span class="s2">, </span><span class="s1">self.rhs_termlist)])</span>

    <span class="s2">def </span><span class="s1">describe(self):</span>
        <span class="s4">&quot;&quot;&quot;Returns a human-readable representation of this :class:`ModelDesc` 
        in pseudo-formula notation. 
 
        .. warning:: There is no guarantee that the strings returned by this 
           function can be parsed as formulas. They are best-effort 
           descriptions intended for human users. However, if this ModelDesc 
           was created by parsing a formula, then it should work in 
           practice. If you *really* have to. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">term_code(term):</span>
            <span class="s2">if </span><span class="s1">term == INTERCEPT:</span>
                <span class="s2">return </span><span class="s3">&quot;1&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">term.name()</span>
        <span class="s1">result = </span><span class="s3">&quot; + &quot;</span><span class="s1">.join([term_code(term) </span><span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">self.lhs_termlist])</span>
        <span class="s2">if </span><span class="s1">result:</span>
            <span class="s1">result += </span><span class="s3">&quot; ~ &quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result += </span><span class="s3">&quot;~ &quot;</span>
        <span class="s2">if </span><span class="s1">self.rhs_termlist == [INTERCEPT]:</span>
            <span class="s1">result += term_code(INTERCEPT)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">term_names = []</span>
            <span class="s2">if </span><span class="s1">INTERCEPT </span><span class="s2">not in </span><span class="s1">self.rhs_termlist:</span>
                <span class="s1">term_names.append(</span><span class="s3">&quot;0&quot;</span><span class="s1">)</span>
            <span class="s1">term_names += [term_code(term) </span><span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">self.rhs_termlist</span>
                           <span class="s2">if </span><span class="s1">term != INTERCEPT]</span>
            <span class="s1">result += </span><span class="s3">&quot; + &quot;</span><span class="s1">.join(term_names)</span>
        <span class="s2">return </span><span class="s1">result</span>
            
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_formula(cls</span><span class="s2">, </span><span class="s1">tree_or_string):</span>
        <span class="s4">&quot;&quot;&quot;Construct a :class:`ModelDesc` from a formula string. 
 
        :arg tree_or_string: A formula string. (Or an unevaluated formula 
          parse tree, but the API for generating those isn't public yet. Shh, 
          it can be our secret.) 
        :returns: A new :class:`ModelDesc`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(tree_or_string</span><span class="s2">, </span><span class="s1">ParseNode):</span>
            <span class="s1">tree = tree_or_string</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tree = parse_formula(tree_or_string)</span>
        <span class="s1">value = Evaluator().eval(tree</span><span class="s2">, </span><span class="s1">require_evalexpr=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">cls)</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s2">def </span><span class="s1">test_ModelDesc():</span>
    <span class="s1">f1 = _MockFactor(</span><span class="s3">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">f2 = _MockFactor(</span><span class="s3">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">m = ModelDesc([INTERCEPT</span><span class="s2">, </span><span class="s1">Term([f1])]</span><span class="s2">, </span><span class="s1">[Term([f1])</span><span class="s2">, </span><span class="s1">Term([f1</span><span class="s2">, </span><span class="s1">f2])])</span>
    <span class="s2">assert </span><span class="s1">m.lhs_termlist == [INTERCEPT</span><span class="s2">, </span><span class="s1">Term([f1])]</span>
    <span class="s2">assert </span><span class="s1">m.rhs_termlist == [Term([f1])</span><span class="s2">, </span><span class="s1">Term([f1</span><span class="s2">, </span><span class="s1">f2])]</span>
    <span class="s1">print(m.describe())</span>
    <span class="s2">assert </span><span class="s1">m.describe() == </span><span class="s3">&quot;1 + a ~ 0 + a + a:b&quot;</span>

    <span class="s1">assert_no_pickling(m)</span>

    <span class="s2">assert </span><span class="s1">ModelDesc([]</span><span class="s2">, </span><span class="s1">[]).describe() == </span><span class="s3">&quot;~ 0&quot;</span>
    <span class="s2">assert </span><span class="s1">ModelDesc([INTERCEPT]</span><span class="s2">, </span><span class="s1">[]).describe() == </span><span class="s3">&quot;1 ~ 0&quot;</span>
    <span class="s2">assert </span><span class="s1">ModelDesc([INTERCEPT]</span><span class="s2">, </span><span class="s1">[INTERCEPT]).describe() == </span><span class="s3">&quot;1 ~ 1&quot;</span>
    <span class="s2">assert </span><span class="s1">(ModelDesc([INTERCEPT]</span><span class="s2">, </span><span class="s1">[INTERCEPT</span><span class="s2">, </span><span class="s1">Term([f2])]).describe()</span>
            <span class="s1">== </span><span class="s3">&quot;1 ~ b&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">test_ModelDesc_from_formula():</span>
    <span class="s2">for </span><span class="s1">input </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;y ~ x&quot;</span><span class="s2">, </span><span class="s1">parse_formula(</span><span class="s3">&quot;y ~ x&quot;</span><span class="s1">)):</span>
        <span class="s1">md = ModelDesc.from_formula(input)</span>
        <span class="s2">assert </span><span class="s1">md.lhs_termlist == [Term([EvalFactor(</span><span class="s3">&quot;y&quot;</span><span class="s1">)])</span><span class="s2">,</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">md.rhs_termlist == [INTERCEPT</span><span class="s2">, </span><span class="s1">Term([EvalFactor(</span><span class="s3">&quot;x&quot;</span><span class="s1">)])]</span>

<span class="s2">class </span><span class="s1">IntermediateExpr(object):</span>
    <span class="s4">&quot;This class holds an intermediate result while we're evaluating a tree.&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">intercept</span><span class="s2">, </span><span class="s1">intercept_origin</span><span class="s2">, </span><span class="s1">intercept_removed</span><span class="s2">, </span><span class="s1">terms):</span>
        <span class="s1">self.intercept = intercept</span>
        <span class="s1">self.intercept_origin = intercept_origin</span>
        <span class="s1">self.intercept_removed =intercept_removed</span>
        <span class="s1">self.terms = tuple(uniqueify_list(terms))</span>
        <span class="s2">if </span><span class="s1">self.intercept:</span>
            <span class="s2">assert </span><span class="s1">self.intercept_origin</span>
        <span class="s2">assert not </span><span class="s1">(self.intercept </span><span class="s2">and </span><span class="s1">self.intercept_removed)</span>

    <span class="s1">__repr__ = repr_pretty_delegate</span>
    <span class="s2">def </span><span class="s1">_pretty_repr_(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">cycle): </span><span class="s0"># pragma: no cover</span>
        <span class="s2">assert not </span><span class="s1">cycle</span>
        <span class="s2">return </span><span class="s1">repr_pretty_impl(p</span><span class="s2">, </span><span class="s1">self</span><span class="s2">,</span>
                                <span class="s1">[self.intercept</span><span class="s2">, </span><span class="s1">self.intercept_origin</span><span class="s2">,</span>
                                 <span class="s1">self.intercept_removed</span><span class="s2">, </span><span class="s1">self.terms])</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s2">def </span><span class="s1">_maybe_add_intercept(doit</span><span class="s2">, </span><span class="s1">terms):</span>
    <span class="s2">if </span><span class="s1">doit:</span>
        <span class="s2">return </span><span class="s1">(INTERCEPT</span><span class="s2">,</span><span class="s1">) + terms</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">terms</span>

<span class="s2">def </span><span class="s1">_eval_any_tilde(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s1">exprs = [evaluator.eval(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">tree.args]    </span>
    <span class="s2">if </span><span class="s1">len(exprs) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># Formula was like: &quot;~ foo&quot;</span>
        <span class="s0"># We pretend that instead it was like: &quot;0 ~ foo&quot;</span>
        <span class="s1">exprs.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, True, </span><span class="s1">[]))</span>
    <span class="s2">assert </span><span class="s1">len(exprs) == </span><span class="s5">2</span>
    <span class="s0"># Note that only the RHS gets an implicit intercept:</span>
    <span class="s2">return </span><span class="s1">ModelDesc(_maybe_add_intercept(exprs[</span><span class="s5">0</span><span class="s1">].intercept</span><span class="s2">, </span><span class="s1">exprs[</span><span class="s5">0</span><span class="s1">].terms)</span><span class="s2">,</span>
                     <span class="s1">_maybe_add_intercept(</span><span class="s2">not </span><span class="s1">exprs[</span><span class="s5">1</span><span class="s1">].intercept_removed</span><span class="s2">,</span>
                                          <span class="s1">exprs[</span><span class="s5">1</span><span class="s1">].terms))</span>

<span class="s2">def </span><span class="s1">_eval_binary_plus(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s1">left_expr = evaluator.eval(tree.args[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">tree.args[</span><span class="s5">1</span><span class="s1">].type == </span><span class="s3">&quot;ZERO&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, True, </span><span class="s1">left_expr.terms)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">right_expr = evaluator.eval(tree.args[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">right_expr.intercept:</span>
            <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">True, </span><span class="s1">right_expr.intercept_origin</span><span class="s2">, False,</span>
                                    <span class="s1">left_expr.terms + right_expr.terms)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">IntermediateExpr(left_expr.intercept</span><span class="s2">,</span>
                                    <span class="s1">left_expr.intercept_origin</span><span class="s2">,</span>
                                    <span class="s1">left_expr.intercept_removed</span><span class="s2">,</span>
                                    <span class="s1">left_expr.terms + right_expr.terms)</span>
    

<span class="s2">def </span><span class="s1">_eval_binary_minus(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s1">left_expr = evaluator.eval(tree.args[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">tree.args[</span><span class="s5">1</span><span class="s1">].type == </span><span class="s3">&quot;ZERO&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">True, </span><span class="s1">tree.args[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, False,</span>
                                <span class="s1">left_expr.terms)</span>
    <span class="s2">elif </span><span class="s1">tree.args[</span><span class="s5">1</span><span class="s1">].type == </span><span class="s3">&quot;ONE&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, True, </span><span class="s1">left_expr.terms)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">right_expr = evaluator.eval(tree.args[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">terms = [term </span><span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">left_expr.terms</span>
                 <span class="s2">if </span><span class="s1">term </span><span class="s2">not in </span><span class="s1">right_expr.terms]</span>
        <span class="s2">if </span><span class="s1">right_expr.intercept:</span>
            <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, True, </span><span class="s1">terms)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">IntermediateExpr(left_expr.intercept</span><span class="s2">,</span>
                                    <span class="s1">left_expr.intercept_origin</span><span class="s2">,</span>
                                    <span class="s1">left_expr.intercept_removed</span><span class="s2">,</span>
                                    <span class="s1">terms)</span>

<span class="s2">def </span><span class="s1">_check_interactable(expr):</span>
    <span class="s2">if </span><span class="s1">expr.intercept:</span>
        <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;intercept term cannot interact with &quot;</span>
                            <span class="s3">&quot;anything else&quot;</span><span class="s2">, </span><span class="s1">expr.intercept_origin)</span>

<span class="s2">def </span><span class="s1">_interaction(left_expr</span><span class="s2">, </span><span class="s1">right_expr):</span>
    <span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">(left_expr</span><span class="s2">, </span><span class="s1">right_expr):</span>
        <span class="s1">_check_interactable(expr)</span>
    <span class="s1">terms = []</span>
    <span class="s2">for </span><span class="s1">l_term </span><span class="s2">in </span><span class="s1">left_expr.terms:</span>
        <span class="s2">for </span><span class="s1">r_term </span><span class="s2">in </span><span class="s1">right_expr.terms:</span>
            <span class="s1">terms.append(Term(l_term.factors + r_term.factors))</span>
    <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, False, </span><span class="s1">terms)</span>

<span class="s2">def </span><span class="s1">_eval_binary_prod(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s1">exprs = [evaluator.eval(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">tree.args]</span>
    <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, False,</span>
                            <span class="s1">exprs[</span><span class="s5">0</span><span class="s1">].terms</span>
                            <span class="s1">+ exprs[</span><span class="s5">1</span><span class="s1">].terms</span>
                            <span class="s1">+ _interaction(*exprs).terms)</span>

<span class="s0"># Division (nesting) is right-ward distributive:</span>
<span class="s0">#   a / (b + c) -&gt; a/b + a/c -&gt; a + a:b + a:c</span>
<span class="s0"># But left-ward, in S/R it has a quirky behavior:</span>
<span class="s0">#   (a + b)/c -&gt; a + b + a:b:c</span>
<span class="s0"># This is because it's meaningless for a factor to be &quot;nested&quot; under two</span>
<span class="s0"># different factors. (This is documented in Chambers and Hastie (page 30) as a</span>
<span class="s0"># &quot;Slightly more subtle...&quot; rule, with no further elaboration. Hopefully we</span>
<span class="s0"># will do better.)</span>
<span class="s2">def </span><span class="s1">_eval_binary_div(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s1">left_expr = evaluator.eval(tree.args[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">right_expr = evaluator.eval(tree.args[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">terms = list(left_expr.terms)</span>
    <span class="s1">_check_interactable(left_expr)</span>
    <span class="s0"># Build a single giant combined term for everything on the left:</span>
    <span class="s1">left_factors = []</span>
    <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">left_expr.terms:</span>
        <span class="s1">left_factors += list(term.factors)</span>
    <span class="s1">left_combined_expr = IntermediateExpr(</span><span class="s2">False, None, False,</span>
                                          <span class="s1">[Term(left_factors)])</span>
    <span class="s0"># Then interact it with everything on the right:</span>
    <span class="s1">terms += list(_interaction(left_combined_expr</span><span class="s2">, </span><span class="s1">right_expr).terms)</span>
    <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, False, </span><span class="s1">terms)</span>

<span class="s2">def </span><span class="s1">_eval_binary_interact(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s1">exprs = [evaluator.eval(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">tree.args]</span>
    <span class="s2">return </span><span class="s1">_interaction(*exprs)</span>

<span class="s2">def </span><span class="s1">_eval_binary_power(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s1">left_expr = evaluator.eval(tree.args[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">_check_interactable(left_expr)</span>
    <span class="s1">power = -</span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">tree.args[</span><span class="s5">1</span><span class="s1">].type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;ONE&quot;</span><span class="s2">, </span><span class="s3">&quot;NUMBER&quot;</span><span class="s1">):</span>
        <span class="s1">expr = tree.args[</span><span class="s5">1</span><span class="s1">].token.extra</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">power = int(expr)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">pass</span>
    <span class="s2">if </span><span class="s1">power &lt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;'**' requires a positive integer&quot;</span><span class="s2">, </span><span class="s1">tree.args[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">all_terms = left_expr.terms</span>
    <span class="s1">big_expr = left_expr</span>
    <span class="s0"># Small optimization: (a + b)**100 is just the same as (a + b)**2.</span>
    <span class="s1">power = min(len(left_expr.terms)</span><span class="s2">, </span><span class="s1">power)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">power):</span>
        <span class="s1">big_expr = _interaction(left_expr</span><span class="s2">, </span><span class="s1">big_expr)</span>
        <span class="s1">all_terms = all_terms + big_expr.terms</span>
    <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, False, </span><span class="s1">all_terms)</span>

<span class="s2">def </span><span class="s1">_eval_unary_plus(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s2">return </span><span class="s1">evaluator.eval(tree.args[</span><span class="s5">0</span><span class="s1">])</span>

<span class="s2">def </span><span class="s1">_eval_unary_minus(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s2">if </span><span class="s1">tree.args[</span><span class="s5">0</span><span class="s1">].type == </span><span class="s3">&quot;ZERO&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">True, </span><span class="s1">tree.origin</span><span class="s2">, False, </span><span class="s1">[])</span>
    <span class="s2">elif </span><span class="s1">tree.args[</span><span class="s5">0</span><span class="s1">].type == </span><span class="s3">&quot;ONE&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, True, </span><span class="s1">[])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;Unary minus can only be applied to 1 or 0&quot;</span><span class="s2">, </span><span class="s1">tree)</span>

<span class="s2">def </span><span class="s1">_eval_zero(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, True, </span><span class="s1">[])</span>
    
<span class="s2">def </span><span class="s1">_eval_one(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">True, </span><span class="s1">tree.origin</span><span class="s2">, False, </span><span class="s1">[])</span>

<span class="s2">def </span><span class="s1">_eval_number(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;numbers besides '0' and '1' are &quot;</span>
                        <span class="s3">&quot;only allowed with **&quot;</span><span class="s2">, </span><span class="s1">tree)</span>

<span class="s2">def </span><span class="s1">_eval_python_expr(evaluator</span><span class="s2">, </span><span class="s1">tree):</span>
    <span class="s1">factor = EvalFactor(tree.token.extra</span><span class="s2">, </span><span class="s1">origin=tree.origin)</span>
    <span class="s2">return </span><span class="s1">IntermediateExpr(</span><span class="s2">False, None, False, </span><span class="s1">[Term([factor])])</span>

<span class="s2">class </span><span class="s1">Evaluator(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._evaluators = {}</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;~&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">_eval_any_tilde)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;~&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">_eval_any_tilde)</span>

        <span class="s1">self.add_op(</span><span class="s3">&quot;+&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">_eval_binary_plus)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">_eval_binary_minus)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;*&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">_eval_binary_prod)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;/&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">_eval_binary_div)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;:&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">_eval_binary_interact)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;**&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">_eval_binary_power)</span>

        <span class="s1">self.add_op(</span><span class="s3">&quot;+&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">_eval_unary_plus)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">_eval_unary_minus)</span>

        <span class="s1">self.add_op(</span><span class="s3">&quot;ZERO&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">_eval_zero)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;ONE&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">_eval_one)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;NUMBER&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">_eval_number)</span>
        <span class="s1">self.add_op(</span><span class="s3">&quot;PYTHON_EXPR&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">_eval_python_expr)</span>

        <span class="s0"># Not used by Patsy -- provided for the convenience of eventual</span>
        <span class="s0"># user-defined operators.</span>
        <span class="s1">self.stash = {}</span>

    <span class="s0"># This should not be considered a public API yet (to use for actually</span>
    <span class="s0"># adding new operator semantics) because I wrote in some of the relevant</span>
    <span class="s0"># code sort of speculatively, but it isn't actually tested.</span>
    <span class="s2">def </span><span class="s1">add_op(self</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">arity</span><span class="s2">, </span><span class="s1">evaluator):</span>
        <span class="s1">self._evaluators[op</span><span class="s2">, </span><span class="s1">arity] = evaluator</span>

    <span class="s2">def </span><span class="s1">eval(self</span><span class="s2">, </span><span class="s1">tree</span><span class="s2">, </span><span class="s1">require_evalexpr=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">result = </span><span class="s2">None</span>
        <span class="s2">assert </span><span class="s1">isinstance(tree</span><span class="s2">, </span><span class="s1">ParseNode)</span>
        <span class="s1">key = (tree.type</span><span class="s2">, </span><span class="s1">len(tree.args))</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">self._evaluators:</span>
            <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;I don't know how to evaluate this &quot;</span>
                                <span class="s3">&quot;'%s' operator&quot; </span><span class="s1">% (tree.type</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">tree.token)</span>
        <span class="s1">result = self._evaluators[key](self</span><span class="s2">, </span><span class="s1">tree)</span>
        <span class="s2">if </span><span class="s1">require_evalexpr </span><span class="s2">and not </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">IntermediateExpr):</span>
            <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">ModelDesc):</span>
                <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;~ can only be used once, and &quot;</span>
                                    <span class="s3">&quot;only at the top level&quot;</span><span class="s2">,</span>
                                    <span class="s1">tree)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">PatsyError(</span><span class="s3">&quot;custom operator returned an &quot;</span>
                                    <span class="s3">&quot;object that I don't know how to &quot;</span>
                                    <span class="s3">&quot;handle&quot;</span><span class="s2">, </span><span class="s1">tree)</span>
        <span class="s2">return </span><span class="s1">result</span>

<span class="s0">#############</span>

<span class="s1">_eval_tests = {</span>
    <span class="s3">&quot;&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot; &quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot; </span><span class="s2">\n </span><span class="s3">&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>

    <span class="s3">&quot;1&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;0&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;- 1&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;- 0&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;+ 1&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;+ 0&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;0 + 1&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;1 + 0&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;1 - 0&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;0 - 1&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>
    
    <span class="s3">&quot;1 + a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;0 + a&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;a - 1&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;a - 0&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;1 - a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>

    <span class="s3">&quot;a + b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;(a + b)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;a + ((((b))))&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;a + ((((+b))))&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;a + ((((b - a))))&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>

    <span class="s3">&quot;a + a + a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>

    <span class="s3">&quot;a + (b - a)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>

    <span class="s3">&quot;a + np.log(a, base=10)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;np.log(a, base=10)&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s0"># Note different spacing:</span>
    <span class="s3">&quot;a + np.log(a, base=10) - np . log(a , base = 10)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>
    
    <span class="s3">&quot;a + (I(b) + c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;I(b)&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;a + I(b + c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;I(b + c)&quot;</span><span class="s1">])</span><span class="s2">,</span>

    <span class="s3">&quot;a:b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a:b:a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a:(b + c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;(a + b):c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a:(b - c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;c + a:c + a:(b - c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;(a - b):c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;b + b:c + (a - b):c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>

    <span class="s3">&quot;a:b - a:b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;a:b - b:a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>

    <span class="s3">&quot;1 - (a + b)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;a + b - (a + b)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>

    <span class="s3">&quot;a * b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a * b * a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a * (b + c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;(a + b) * c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a * (b - c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;c + a:c + a * (b - c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;(a - b) * c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;b + b:c + (a - b) * c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>

    <span class="s3">&quot;a/b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;(a + b)/c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;b + b:c + (a - b)/c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a/(b + c)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>

    <span class="s3">&quot;a ** 2&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;(a + b + c + d) ** 2&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s2">,</span>
                                    <span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;(a + b + c + d) ** 3&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s2">,</span>
                                    <span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)])</span><span class="s2">,</span>

    <span class="s3">&quot;a + +a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>

    <span class="s3">&quot;~ a + b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;~ a*b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;~ a*b + 0&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;~ -1&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>

    <span class="s3">&quot;0 ~ a + b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;1 ~ a + b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[]</span><span class="s2">, True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;y ~ a + b&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[</span><span class="s3">&quot;y&quot;</span><span class="s1">]</span><span class="s2">, True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;0 + y ~ a + b&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[</span><span class="s3">&quot;y&quot;</span><span class="s1">]</span><span class="s2">, True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;0 + y * z ~ a + b&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[</span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s3">&quot;z&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s3">&quot;z&quot;</span><span class="s1">)]</span><span class="s2">, True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;-1 ~ 1&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[]</span><span class="s2">, True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;1 + y ~ a + b&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;y&quot;</span><span class="s1">]</span><span class="s2">, True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span><span class="s2">,</span>

    <span class="s0"># Check precedence:</span>
    <span class="s3">&quot;a + b * c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a * b + c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;a * b - a&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a + b / c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a / b + c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;a*b:c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>
    <span class="s3">&quot;a:b*c&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)])</span><span class="s2">,</span>

    <span class="s0"># Intercept handling:</span>
    <span class="s3">&quot;~ 1 + 1 + 0 + 1&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;~ 0 + 1 + 0&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;~ 0 - 1 - 1 + 0 + 1&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;~ 1 - 1&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>
    <span class="s3">&quot;~ 0 + a + 1&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s3">&quot;~ 1 + (a + 0)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">, </span><span class="s0"># This is correct, but perhaps surprising!</span>
    <span class="s3">&quot;~ 0 + (a + 1)&quot;</span><span class="s1">: (</span><span class="s2">True, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">, </span><span class="s0"># Also correct!</span>
    <span class="s3">&quot;~ 1 - (a + 1)&quot;</span><span class="s1">: (</span><span class="s2">False, </span><span class="s1">[])</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s0"># &lt;&gt; mark off where the error should be reported:</span>
<span class="s1">_eval_error_tests = [</span>
    <span class="s3">&quot;a &lt;+&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + &lt;(&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;b + &lt;(-a)&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;a:&lt;1&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;(a + &lt;1&gt;)*b&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;a + &lt;2&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + &lt;1.0&gt;&quot;</span><span class="s2">,</span>
    <span class="s0"># eh, catching this is a hassle, we'll just leave the user some rope if</span>
    <span class="s0"># they really want it:</span>
    <span class="s0">#&quot;a + &lt;0x1&gt;&quot;,</span>

    <span class="s3">&quot;a ** &lt;b&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a ** &lt;(1 + 1)&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a ** &lt;1.5&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;a + b &lt;# asdf&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;&lt;)&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + &lt;)&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;&lt;*&gt; a&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + &lt;*&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;a + &lt;foo[bar&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + &lt;foo{bar&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + &lt;foo(bar&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;a + &lt;[bar&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + &lt;{bar&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;a + &lt;{bar[]&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;a + foo&lt;]&gt;bar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + foo[]&lt;]&gt;bar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + foo{}&lt;}&gt;bar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + foo&lt;)&gt;bar&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;a + b&lt;)&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;(a) &lt;.&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;&lt;(&gt;a + b&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;&lt;y ~ a&gt; ~ b&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;y ~ &lt;(a ~ b)&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;&lt;~ a&gt; ~ b&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;~ &lt;(a ~ b)&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;1 + &lt;-(a + b)&gt;&quot;</span><span class="s2">,</span>

    <span class="s3">&quot;&lt;- a&gt;&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;a + &lt;-a**2&gt;&quot;</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s2">def </span><span class="s1">_assert_terms_match(terms</span><span class="s2">, </span><span class="s1">expected_intercept</span><span class="s2">, </span><span class="s1">expecteds): </span><span class="s0"># pragma: no cover</span>
    <span class="s2">if </span><span class="s1">expected_intercept:</span>
        <span class="s1">expecteds = [()] + expecteds</span>
    <span class="s2">assert </span><span class="s1">len(terms) == len(expecteds)</span>
    <span class="s2">for </span><span class="s1">term</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">zip(terms</span><span class="s2">, </span><span class="s1">expecteds):</span>
        <span class="s2">if </span><span class="s1">isinstance(term</span><span class="s2">, </span><span class="s1">Term):</span>
            <span class="s2">if </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">expected = (expected</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">term.factors == tuple([EvalFactor(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">expected])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">term == expected</span>

<span class="s2">def </span><span class="s1">_do_eval_formula_tests(tests): </span><span class="s0"># pragma: no cover</span>
    <span class="s2">for </span><span class="s1">code</span><span class="s2">, </span><span class="s1">result </span><span class="s2">in </span><span class="s1">six.iteritems(tests):</span>
        <span class="s2">if </span><span class="s1">len(result) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">result = (</span><span class="s2">False, </span><span class="s1">[]) + result</span>
        <span class="s1">model_desc = ModelDesc.from_formula(code)</span>
        <span class="s1">print(repr(code))</span>
        <span class="s1">print(result)</span>
        <span class="s1">print(model_desc)</span>
        <span class="s1">lhs_intercept</span><span class="s2">, </span><span class="s1">lhs_termlist</span><span class="s2">, </span><span class="s1">rhs_intercept</span><span class="s2">, </span><span class="s1">rhs_termlist = result</span>
        <span class="s1">_assert_terms_match(model_desc.lhs_termlist</span><span class="s2">,</span>
                            <span class="s1">lhs_intercept</span><span class="s2">, </span><span class="s1">lhs_termlist)</span>
        <span class="s1">_assert_terms_match(model_desc.rhs_termlist</span><span class="s2">,</span>
                            <span class="s1">rhs_intercept</span><span class="s2">, </span><span class="s1">rhs_termlist)</span>

<span class="s2">def </span><span class="s1">test_eval_formula():</span>
    <span class="s1">_do_eval_formula_tests(_eval_tests)</span>

<span class="s2">def </span><span class="s1">test_eval_formula_error_reporting():</span>
    <span class="s2">from </span><span class="s1">patsy.parse_formula </span><span class="s2">import </span><span class="s1">_parsing_error_test</span>
    <span class="s1">parse_fn = </span><span class="s2">lambda </span><span class="s1">formula: ModelDesc.from_formula(formula)</span>
    <span class="s1">_parsing_error_test(parse_fn</span><span class="s2">, </span><span class="s1">_eval_error_tests)</span>

<span class="s2">def </span><span class="s1">test_formula_factor_origin():</span>
    <span class="s2">from </span><span class="s1">patsy.origin </span><span class="s2">import </span><span class="s1">Origin</span>
    <span class="s1">desc = ModelDesc.from_formula(</span><span class="s3">&quot;a + b&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">(desc.rhs_termlist[</span><span class="s5">1</span><span class="s1">].factors[</span><span class="s5">0</span><span class="s1">].origin</span>
            <span class="s1">== Origin(</span><span class="s3">&quot;a + b&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">(desc.rhs_termlist[</span><span class="s5">2</span><span class="s1">].factors[</span><span class="s5">0</span><span class="s1">].origin</span>
            <span class="s1">== Origin(</span><span class="s3">&quot;a + b&quot;</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>
    
</pre>
</body>
</html>