<html>
<head>
<title>test_integrate.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_integrate.py</font>
</center></td></tr></table>
<pre><span class="s0"># Authors: Nils Wagner, Ed Schofield, Pauli Virtanen, John Travers</span>
<span class="s2">&quot;&quot;&quot; 
Tests for numerical integration. 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">(arange</span><span class="s3">, </span><span class="s1">zeros</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">dot</span><span class="s3">, </span><span class="s1">sqrt</span><span class="s3">, </span><span class="s1">cos</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">eye</span><span class="s3">, </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">exp</span><span class="s3">,</span>
                   <span class="s1">allclose)</span>

<span class="s3">from </span><span class="s1">numpy.testing </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s3">, </span><span class="s1">assert_array_almost_equal</span><span class="s3">,</span>
    <span class="s1">assert_allclose</span><span class="s3">, </span><span class="s1">assert_array_equal</span><span class="s3">, </span><span class="s1">assert_equal</span><span class="s3">, </span><span class="s1">assert_warns)</span>
<span class="s3">from </span><span class="s1">pytest </span><span class="s3">import </span><span class="s1">raises </span><span class="s3">as </span><span class="s1">assert_raises</span>
<span class="s3">from </span><span class="s1">scipy.integrate </span><span class="s3">import </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">ode</span><span class="s3">, </span><span class="s1">complex_ode</span>

<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># Test ODE integrators</span>
<span class="s0">#------------------------------------------------------------------------------</span>


<span class="s3">class </span><span class="s1">TestOdeint:</span>
    <span class="s0"># Check integrate.odeint</span>

    <span class="s3">def </span><span class="s1">_do_problem(self</span><span class="s3">, </span><span class="s1">problem):</span>
        <span class="s1">t = arange(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">problem.stop_t</span><span class="s3">, </span><span class="s4">0.05</span><span class="s1">)</span>

        <span class="s0"># Basic case</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">infodict = odeint(problem.f</span><span class="s3">, </span><span class="s1">problem.z0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">assert_(problem.verify(z</span><span class="s3">, </span><span class="s1">t))</span>

        <span class="s0"># Use tfirst=True</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">infodict = odeint(</span><span class="s3">lambda </span><span class="s1">t</span><span class="s3">, </span><span class="s1">y: problem.f(y</span><span class="s3">, </span><span class="s1">t)</span><span class="s3">, </span><span class="s1">problem.z0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">,</span>
                             <span class="s1">full_output=</span><span class="s3">True, </span><span class="s1">tfirst=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">assert_(problem.verify(z</span><span class="s3">, </span><span class="s1">t))</span>

        <span class="s3">if </span><span class="s1">hasattr(problem</span><span class="s3">, </span><span class="s5">'jac'</span><span class="s1">):</span>
            <span class="s0"># Use Dfun</span>
            <span class="s1">z</span><span class="s3">, </span><span class="s1">infodict = odeint(problem.f</span><span class="s3">, </span><span class="s1">problem.z0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">Dfun=problem.jac</span><span class="s3">,</span>
                                 <span class="s1">full_output=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">assert_(problem.verify(z</span><span class="s3">, </span><span class="s1">t))</span>

            <span class="s0"># Use Dfun and tfirst=True</span>
            <span class="s1">z</span><span class="s3">, </span><span class="s1">infodict = odeint(</span><span class="s3">lambda </span><span class="s1">t</span><span class="s3">, </span><span class="s1">y: problem.f(y</span><span class="s3">, </span><span class="s1">t)</span><span class="s3">, </span><span class="s1">problem.z0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">,</span>
                                 <span class="s1">Dfun=</span><span class="s3">lambda </span><span class="s1">t</span><span class="s3">, </span><span class="s1">y: problem.jac(y</span><span class="s3">, </span><span class="s1">t)</span><span class="s3">,</span>
                                 <span class="s1">full_output=</span><span class="s3">True, </span><span class="s1">tfirst=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">assert_(problem.verify(z</span><span class="s3">, </span><span class="s1">t))</span>

    <span class="s3">def </span><span class="s1">test_odeint(self):</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if </span><span class="s1">problem.cmplx:</span>
                <span class="s3">continue</span>
            <span class="s1">self._do_problem(problem)</span>


<span class="s3">class </span><span class="s1">TestODEClass:</span>

    <span class="s1">ode_class = </span><span class="s3">None   </span><span class="s0"># Set in subclass.</span>

    <span class="s3">def </span><span class="s1">_do_problem(self</span><span class="s3">, </span><span class="s1">problem</span><span class="s3">, </span><span class="s1">integrator</span><span class="s3">, </span><span class="s1">method=</span><span class="s5">'adams'</span><span class="s1">):</span>

        <span class="s0"># ode has callback arguments in different order than odeint</span>
        <span class="s3">def </span><span class="s1">f(t</span><span class="s3">, </span><span class="s1">z):</span>
            <span class="s3">return </span><span class="s1">problem.f(z</span><span class="s3">, </span><span class="s1">t)</span>
        <span class="s1">jac = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">hasattr(problem</span><span class="s3">, </span><span class="s5">'jac'</span><span class="s1">):</span>
            <span class="s3">def </span><span class="s1">jac(t</span><span class="s3">, </span><span class="s1">z):</span>
                <span class="s3">return </span><span class="s1">problem.jac(z</span><span class="s3">, </span><span class="s1">t)</span>

        <span class="s1">integrator_params = {}</span>
        <span class="s3">if </span><span class="s1">problem.lband </span><span class="s3">is not None or </span><span class="s1">problem.uband </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">integrator_params[</span><span class="s5">'uband'</span><span class="s1">] = problem.uband</span>
            <span class="s1">integrator_params[</span><span class="s5">'lband'</span><span class="s1">] = problem.lband</span>

        <span class="s1">ig = self.ode_class(f</span><span class="s3">, </span><span class="s1">jac)</span>
        <span class="s1">ig.set_integrator(integrator</span><span class="s3">,</span>
                          <span class="s1">atol=problem.atol/</span><span class="s4">10</span><span class="s3">,</span>
                          <span class="s1">rtol=problem.rtol/</span><span class="s4">10</span><span class="s3">,</span>
                          <span class="s1">method=method</span><span class="s3">,</span>
                          <span class="s1">**integrator_params)</span>

        <span class="s1">ig.set_initial_value(problem.z0</span><span class="s3">, </span><span class="s1">t=</span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">z = ig.integrate(problem.stop_t)</span>

        <span class="s1">assert_array_equal(z</span><span class="s3">, </span><span class="s1">ig.y)</span>
        <span class="s1">assert_(ig.successful()</span><span class="s3">, </span><span class="s1">(problem</span><span class="s3">, </span><span class="s1">method))</span>
        <span class="s1">assert_(ig.get_return_code() &gt; </span><span class="s4">0</span><span class="s3">, </span><span class="s1">(problem</span><span class="s3">, </span><span class="s1">method))</span>
        <span class="s1">assert_(problem.verify(array([z])</span><span class="s3">, </span><span class="s1">problem.stop_t)</span><span class="s3">, </span><span class="s1">(problem</span><span class="s3">, </span><span class="s1">method))</span>


<span class="s3">class </span><span class="s1">TestOde(TestODEClass):</span>

    <span class="s1">ode_class = ode</span>

    <span class="s3">def </span><span class="s1">test_vode(self):</span>
        <span class="s0"># Check the vode solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if </span><span class="s1">problem.cmplx:</span>
                <span class="s3">continue</span>
            <span class="s3">if not </span><span class="s1">problem.stiff:</span>
                <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'vode'</span><span class="s3">, </span><span class="s5">'adams'</span><span class="s1">)</span>
            <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'vode'</span><span class="s3">, </span><span class="s5">'bdf'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_zvode(self):</span>
        <span class="s0"># Check the zvode solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if not </span><span class="s1">problem.stiff:</span>
                <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'zvode'</span><span class="s3">, </span><span class="s5">'adams'</span><span class="s1">)</span>
            <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'zvode'</span><span class="s3">, </span><span class="s5">'bdf'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_lsoda(self):</span>
        <span class="s0"># Check the lsoda solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if </span><span class="s1">problem.cmplx:</span>
                <span class="s3">continue</span>
            <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'lsoda'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_dopri5(self):</span>
        <span class="s0"># Check the dopri5 solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if </span><span class="s1">problem.cmplx:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">problem.stiff:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">hasattr(problem</span><span class="s3">, </span><span class="s5">'jac'</span><span class="s1">):</span>
                <span class="s3">continue</span>
            <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'dopri5'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_dop853(self):</span>
        <span class="s0"># Check the dop853 solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if </span><span class="s1">problem.cmplx:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">problem.stiff:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">hasattr(problem</span><span class="s3">, </span><span class="s5">'jac'</span><span class="s1">):</span>
                <span class="s3">continue</span>
            <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_concurrent_fail(self):</span>
        <span class="s3">for </span><span class="s1">sol </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'vode'</span><span class="s3">, </span><span class="s5">'zvode'</span><span class="s3">, </span><span class="s5">'lsoda'</span><span class="s1">):</span>
            <span class="s3">def </span><span class="s1">f(t</span><span class="s3">, </span><span class="s1">y):</span>
                <span class="s3">return </span><span class="s4">1.0</span>

            <span class="s1">r = ode(f).set_integrator(sol)</span>
            <span class="s1">r.set_initial_value(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

            <span class="s1">r2 = ode(f).set_integrator(sol)</span>
            <span class="s1">r2.set_initial_value(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

            <span class="s1">r.integrate(r.t + </span><span class="s4">0.1</span><span class="s1">)</span>
            <span class="s1">r2.integrate(r2.t + </span><span class="s4">0.1</span><span class="s1">)</span>

            <span class="s1">assert_raises(RuntimeError</span><span class="s3">, </span><span class="s1">r.integrate</span><span class="s3">, </span><span class="s1">r.t + </span><span class="s4">0.1</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_concurrent_ok(self):</span>
        <span class="s3">def </span><span class="s1">f(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">return </span><span class="s4">1.0</span>

        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s3">for </span><span class="s1">sol </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'vode'</span><span class="s3">, </span><span class="s5">'zvode'</span><span class="s3">, </span><span class="s5">'lsoda'</span><span class="s3">, </span><span class="s5">'dopri5'</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">):</span>
                <span class="s1">r = ode(f).set_integrator(sol)</span>
                <span class="s1">r.set_initial_value(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

                <span class="s1">r2 = ode(f).set_integrator(sol)</span>
                <span class="s1">r2.set_initial_value(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

                <span class="s1">r.integrate(r.t + </span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s1">r2.integrate(r2.t + </span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s1">r2.integrate(r2.t + </span><span class="s4">0.1</span><span class="s1">)</span>

                <span class="s1">assert_allclose(r.y</span><span class="s3">, </span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s1">assert_allclose(r2.y</span><span class="s3">, </span><span class="s4">0.2</span><span class="s1">)</span>

            <span class="s3">for </span><span class="s1">sol </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'dopri5'</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">):</span>
                <span class="s1">r = ode(f).set_integrator(sol)</span>
                <span class="s1">r.set_initial_value(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

                <span class="s1">r2 = ode(f).set_integrator(sol)</span>
                <span class="s1">r2.set_initial_value(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

                <span class="s1">r.integrate(r.t + </span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s1">r.integrate(r.t + </span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s1">r2.integrate(r2.t + </span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s1">r.integrate(r.t + </span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s1">r2.integrate(r2.t + </span><span class="s4">0.1</span><span class="s1">)</span>

                <span class="s1">assert_allclose(r.y</span><span class="s3">, </span><span class="s4">0.3</span><span class="s1">)</span>
                <span class="s1">assert_allclose(r2.y</span><span class="s3">, </span><span class="s4">0.2</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestComplexOde(TestODEClass):</span>

    <span class="s1">ode_class = complex_ode</span>

    <span class="s3">def </span><span class="s1">test_vode(self):</span>
        <span class="s0"># Check the vode solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if not </span><span class="s1">problem.stiff:</span>
                <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'vode'</span><span class="s3">, </span><span class="s5">'adams'</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'vode'</span><span class="s3">, </span><span class="s5">'bdf'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_lsoda(self):</span>
        <span class="s0"># Check the lsoda solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'lsoda'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_dopri5(self):</span>
        <span class="s0"># Check the dopri5 solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if </span><span class="s1">problem.stiff:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">hasattr(problem</span><span class="s3">, </span><span class="s5">'jac'</span><span class="s1">):</span>
                <span class="s3">continue</span>
            <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'dopri5'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_dop853(self):</span>
        <span class="s0"># Check the dop853 solver</span>
        <span class="s3">for </span><span class="s1">problem_cls </span><span class="s3">in </span><span class="s1">PROBLEMS:</span>
            <span class="s1">problem = problem_cls()</span>
            <span class="s3">if </span><span class="s1">problem.stiff:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">hasattr(problem</span><span class="s3">, </span><span class="s5">'jac'</span><span class="s1">):</span>
                <span class="s3">continue</span>
            <span class="s1">self._do_problem(problem</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestSolout:</span>
    <span class="s0"># Check integrate.ode correctly handles solout for dopri5 and dop853</span>
    <span class="s3">def </span><span class="s1">_run_solout_test(self</span><span class="s3">, </span><span class="s1">integrator):</span>
        <span class="s0"># Check correct usage of solout</span>
        <span class="s1">ts = []</span>
        <span class="s1">ys = []</span>
        <span class="s1">t0 = </span><span class="s4">0.0</span>
        <span class="s1">tend = </span><span class="s4">10.0</span>
        <span class="s1">y0 = [</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span>

        <span class="s3">def </span><span class="s1">solout(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s1">ts.append(t)</span>
            <span class="s1">ys.append(y.copy())</span>

        <span class="s3">def </span><span class="s1">rhs(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">return </span><span class="s1">[y[</span><span class="s4">0</span><span class="s1">] + y[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-y[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">ig = ode(rhs).set_integrator(integrator)</span>
        <span class="s1">ig.set_solout(solout)</span>
        <span class="s1">ig.set_initial_value(y0</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">ret = ig.integrate(tend)</span>
        <span class="s1">assert_array_equal(ys[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">y0)</span>
        <span class="s1">assert_array_equal(ys[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ret)</span>
        <span class="s1">assert_equal(ts[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">assert_equal(ts[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tend)</span>

    <span class="s3">def </span><span class="s1">test_solout(self):</span>
        <span class="s3">for </span><span class="s1">integrator </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'dopri5'</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">):</span>
            <span class="s1">self._run_solout_test(integrator)</span>

    <span class="s3">def </span><span class="s1">_run_solout_after_initial_test(self</span><span class="s3">, </span><span class="s1">integrator):</span>
        <span class="s0"># Check if solout works even if it is set after the initial value.</span>
        <span class="s1">ts = []</span>
        <span class="s1">ys = []</span>
        <span class="s1">t0 = </span><span class="s4">0.0</span>
        <span class="s1">tend = </span><span class="s4">10.0</span>
        <span class="s1">y0 = [</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span>

        <span class="s3">def </span><span class="s1">solout(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s1">ts.append(t)</span>
            <span class="s1">ys.append(y.copy())</span>

        <span class="s3">def </span><span class="s1">rhs(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">return </span><span class="s1">[y[</span><span class="s4">0</span><span class="s1">] + y[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-y[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">ig = ode(rhs).set_integrator(integrator)</span>
        <span class="s1">ig.set_initial_value(y0</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">ig.set_solout(solout)</span>
        <span class="s1">ret = ig.integrate(tend)</span>
        <span class="s1">assert_array_equal(ys[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">y0)</span>
        <span class="s1">assert_array_equal(ys[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ret)</span>
        <span class="s1">assert_equal(ts[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">assert_equal(ts[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tend)</span>

    <span class="s3">def </span><span class="s1">test_solout_after_initial(self):</span>
        <span class="s3">for </span><span class="s1">integrator </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'dopri5'</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">):</span>
            <span class="s1">self._run_solout_after_initial_test(integrator)</span>

    <span class="s3">def </span><span class="s1">_run_solout_break_test(self</span><span class="s3">, </span><span class="s1">integrator):</span>
        <span class="s0"># Check correct usage of stopping via solout</span>
        <span class="s1">ts = []</span>
        <span class="s1">ys = []</span>
        <span class="s1">t0 = </span><span class="s4">0.0</span>
        <span class="s1">tend = </span><span class="s4">10.0</span>
        <span class="s1">y0 = [</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]</span>

        <span class="s3">def </span><span class="s1">solout(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s1">ts.append(t)</span>
            <span class="s1">ys.append(y.copy())</span>
            <span class="s3">if </span><span class="s1">t &gt; tend/</span><span class="s4">2.0</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span>

        <span class="s3">def </span><span class="s1">rhs(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">return </span><span class="s1">[y[</span><span class="s4">0</span><span class="s1">] + y[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-y[</span><span class="s4">1</span><span class="s1">]**</span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">ig = ode(rhs).set_integrator(integrator)</span>
        <span class="s1">ig.set_solout(solout)</span>
        <span class="s1">ig.set_initial_value(y0</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">ret = ig.integrate(tend)</span>
        <span class="s1">assert_array_equal(ys[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">y0)</span>
        <span class="s1">assert_array_equal(ys[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ret)</span>
        <span class="s1">assert_equal(ts[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">assert_(ts[-</span><span class="s4">1</span><span class="s1">] &gt; tend/</span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">assert_(ts[-</span><span class="s4">1</span><span class="s1">] &lt; tend)</span>

    <span class="s3">def </span><span class="s1">test_solout_break(self):</span>
        <span class="s3">for </span><span class="s1">integrator </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'dopri5'</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">):</span>
            <span class="s1">self._run_solout_break_test(integrator)</span>


<span class="s3">class </span><span class="s1">TestComplexSolout:</span>
    <span class="s0"># Check integrate.ode correctly handles solout for dopri5 and dop853</span>
    <span class="s3">def </span><span class="s1">_run_solout_test(self</span><span class="s3">, </span><span class="s1">integrator):</span>
        <span class="s0"># Check correct usage of solout</span>
        <span class="s1">ts = []</span>
        <span class="s1">ys = []</span>
        <span class="s1">t0 = </span><span class="s4">0.0</span>
        <span class="s1">tend = </span><span class="s4">20.0</span>
        <span class="s1">y0 = [</span><span class="s4">0.0</span><span class="s1">]</span>

        <span class="s3">def </span><span class="s1">solout(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s1">ts.append(t)</span>
            <span class="s1">ys.append(y.copy())</span>

        <span class="s3">def </span><span class="s1">rhs(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">return </span><span class="s1">[</span><span class="s4">1.0</span><span class="s1">/(t - </span><span class="s4">10.0 </span><span class="s1">- </span><span class="s4">1j</span><span class="s1">)]</span>

        <span class="s1">ig = complex_ode(rhs).set_integrator(integrator)</span>
        <span class="s1">ig.set_solout(solout)</span>
        <span class="s1">ig.set_initial_value(y0</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">ret = ig.integrate(tend)</span>
        <span class="s1">assert_array_equal(ys[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">y0)</span>
        <span class="s1">assert_array_equal(ys[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ret)</span>
        <span class="s1">assert_equal(ts[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">assert_equal(ts[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tend)</span>

    <span class="s3">def </span><span class="s1">test_solout(self):</span>
        <span class="s3">for </span><span class="s1">integrator </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'dopri5'</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">):</span>
            <span class="s1">self._run_solout_test(integrator)</span>

    <span class="s3">def </span><span class="s1">_run_solout_break_test(self</span><span class="s3">, </span><span class="s1">integrator):</span>
        <span class="s0"># Check correct usage of stopping via solout</span>
        <span class="s1">ts = []</span>
        <span class="s1">ys = []</span>
        <span class="s1">t0 = </span><span class="s4">0.0</span>
        <span class="s1">tend = </span><span class="s4">20.0</span>
        <span class="s1">y0 = [</span><span class="s4">0.0</span><span class="s1">]</span>

        <span class="s3">def </span><span class="s1">solout(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s1">ts.append(t)</span>
            <span class="s1">ys.append(y.copy())</span>
            <span class="s3">if </span><span class="s1">t &gt; tend/</span><span class="s4">2.0</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span>

        <span class="s3">def </span><span class="s1">rhs(t</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s3">return </span><span class="s1">[</span><span class="s4">1.0</span><span class="s1">/(t - </span><span class="s4">10.0 </span><span class="s1">- </span><span class="s4">1j</span><span class="s1">)]</span>

        <span class="s1">ig = complex_ode(rhs).set_integrator(integrator)</span>
        <span class="s1">ig.set_solout(solout)</span>
        <span class="s1">ig.set_initial_value(y0</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">ret = ig.integrate(tend)</span>
        <span class="s1">assert_array_equal(ys[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">y0)</span>
        <span class="s1">assert_array_equal(ys[-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ret)</span>
        <span class="s1">assert_equal(ts[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t0)</span>
        <span class="s1">assert_(ts[-</span><span class="s4">1</span><span class="s1">] &gt; tend/</span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">assert_(ts[-</span><span class="s4">1</span><span class="s1">] &lt; tend)</span>

    <span class="s3">def </span><span class="s1">test_solout_break(self):</span>
        <span class="s3">for </span><span class="s1">integrator </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'dopri5'</span><span class="s3">, </span><span class="s5">'dop853'</span><span class="s1">):</span>
            <span class="s1">self._run_solout_break_test(integrator)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># Test problems</span>
<span class="s0">#------------------------------------------------------------------------------</span>


<span class="s3">class </span><span class="s1">ODE:</span>
    <span class="s2">&quot;&quot;&quot; 
    ODE problem 
    &quot;&quot;&quot;</span>
    <span class="s1">stiff = </span><span class="s3">False</span>
    <span class="s1">cmplx = </span><span class="s3">False</span>
    <span class="s1">stop_t = </span><span class="s4">1</span>
    <span class="s1">z0 = []</span>

    <span class="s1">lband = </span><span class="s3">None</span>
    <span class="s1">uband = </span><span class="s3">None</span>

    <span class="s1">atol = </span><span class="s4">1e-6</span>
    <span class="s1">rtol = </span><span class="s4">1e-5</span>


<span class="s3">class </span><span class="s1">SimpleOscillator(ODE):</span>
    <span class="s2">r&quot;&quot;&quot; 
    Free vibration of a simple oscillator:: 
        m \ddot{u} + k u = 0, u(0) = u_0 \dot{u}(0) \dot{u}_0 
    Solution:: 
        u(t) = u_0*cos(sqrt(k/m)*t)+\dot{u}_0*sin(sqrt(k/m)*t)/sqrt(k/m) 
    &quot;&quot;&quot;</span>
    <span class="s1">stop_t = </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">0.09</span>
    <span class="s1">z0 = array([</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0.1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">float)</span>

    <span class="s1">k = </span><span class="s4">4.0</span>
    <span class="s1">m = </span><span class="s4">1.0</span>

    <span class="s3">def </span><span class="s1">f(self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">tmp = zeros((</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s1">tmp[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">] = </span><span class="s4">1.0</span>
        <span class="s1">tmp[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">] = -self.k / self.m</span>
        <span class="s3">return </span><span class="s1">dot(tmp</span><span class="s3">, </span><span class="s1">z)</span>

    <span class="s3">def </span><span class="s1">verify(self</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">omega = sqrt(self.k / self.m)</span>
        <span class="s1">u = self.z0[</span><span class="s4">0</span><span class="s1">]*cos(omega*t) + self.z0[</span><span class="s4">1</span><span class="s1">]*sin(omega*t)/omega</span>
        <span class="s3">return </span><span class="s1">allclose(u</span><span class="s3">, </span><span class="s1">zs[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">atol=self.atol</span><span class="s3">, </span><span class="s1">rtol=self.rtol)</span>


<span class="s3">class </span><span class="s1">ComplexExp(ODE):</span>
    <span class="s2">r&quot;&quot;&quot;The equation :lm:`\dot u = i u`&quot;&quot;&quot;</span>
    <span class="s1">stop_t = </span><span class="s4">1.23</span><span class="s1">*pi</span>
    <span class="s1">z0 = exp([</span><span class="s4">1j</span><span class="s3">, </span><span class="s4">2j</span><span class="s3">, </span><span class="s4">3j</span><span class="s3">, </span><span class="s4">4j</span><span class="s3">, </span><span class="s4">5j</span><span class="s1">])</span>
    <span class="s1">cmplx = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">f(self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s4">1j</span><span class="s1">*z</span>

    <span class="s3">def </span><span class="s1">jac(self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s4">1j</span><span class="s1">*eye(</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">verify(self</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">u = self.z0 * exp(</span><span class="s4">1j</span><span class="s1">*t)</span>
        <span class="s3">return </span><span class="s1">allclose(u</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">atol=self.atol</span><span class="s3">, </span><span class="s1">rtol=self.rtol)</span>


<span class="s3">class </span><span class="s1">Pi(ODE):</span>
    <span class="s2">r&quot;&quot;&quot;Integrate 1/(t + 1j) from t=-10 to t=10&quot;&quot;&quot;</span>
    <span class="s1">stop_t = </span><span class="s4">20</span>
    <span class="s1">z0 = [</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">cmplx = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">f(self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">array([</span><span class="s4">1.</span><span class="s1">/(t - </span><span class="s4">10 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">verify(self</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">u = -</span><span class="s4">2j </span><span class="s1">* np.arctan(</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">allclose(u</span><span class="s3">, </span><span class="s1">zs[-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">:]</span><span class="s3">, </span><span class="s1">atol=self.atol</span><span class="s3">, </span><span class="s1">rtol=self.rtol)</span>


<span class="s3">class </span><span class="s1">CoupledDecay(ODE):</span>
    <span class="s2">r&quot;&quot;&quot; 
    3 coupled decays suited for banded treatment 
    (banded mode makes it necessary when N&gt;&gt;3) 
    &quot;&quot;&quot;</span>

    <span class="s1">stiff = </span><span class="s3">True</span>
    <span class="s1">stop_t = </span><span class="s4">0.5</span>
    <span class="s1">z0 = [</span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">7.0</span><span class="s3">, </span><span class="s4">13.0</span><span class="s1">]</span>
    <span class="s1">lband = </span><span class="s4">1</span>
    <span class="s1">uband = </span><span class="s4">0</span>

    <span class="s1">lmbd = [</span><span class="s4">0.17</span><span class="s3">, </span><span class="s4">0.23</span><span class="s3">, </span><span class="s4">0.29</span><span class="s1">]  </span><span class="s0"># fictitious decay constants</span>

    <span class="s3">def </span><span class="s1">f(self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">lmbd = self.lmbd</span>
        <span class="s3">return </span><span class="s1">np.array([-lmbd[</span><span class="s4">0</span><span class="s1">]*z[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
                         <span class="s1">-lmbd[</span><span class="s4">1</span><span class="s1">]*z[</span><span class="s4">1</span><span class="s1">] + lmbd[</span><span class="s4">0</span><span class="s1">]*z[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
                         <span class="s1">-lmbd[</span><span class="s4">2</span><span class="s1">]*z[</span><span class="s4">2</span><span class="s1">] + lmbd[</span><span class="s4">1</span><span class="s1">]*z[</span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s3">def </span><span class="s1">jac(self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s0"># The full Jacobian is</span>
        <span class="s0">#</span>
        <span class="s0">#    [-lmbd[0]      0         0   ]</span>
        <span class="s0">#    [ lmbd[0]  -lmbd[1]      0   ]</span>
        <span class="s0">#    [    0      lmbd[1]  -lmbd[2]]</span>
        <span class="s0">#</span>
        <span class="s0"># The lower and upper bandwidths are lband=1 and uband=0, resp.</span>
        <span class="s0"># The representation of this array in packed format is</span>
        <span class="s0">#</span>
        <span class="s0">#    [-lmbd[0]  -lmbd[1]  -lmbd[2]]</span>
        <span class="s0">#    [ lmbd[0]   lmbd[1]      0   ]</span>

        <span class="s1">lmbd = self.lmbd</span>
        <span class="s1">j = np.zeros((self.lband + self.uband + </span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">order=</span><span class="s5">'F'</span><span class="s1">)</span>

        <span class="s3">def </span><span class="s1">set_j(ri</span><span class="s3">, </span><span class="s1">ci</span><span class="s3">, </span><span class="s1">val):</span>
            <span class="s1">j[self.uband + ri - ci</span><span class="s3">, </span><span class="s1">ci] = val</span>
        <span class="s1">set_j(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">-lmbd[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">set_j(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">lmbd[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">set_j(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">-lmbd[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">set_j(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">lmbd[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">set_j(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">-lmbd[</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s3">return </span><span class="s1">j</span>

    <span class="s3">def </span><span class="s1">verify(self</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s0"># Formulae derived by hand</span>
        <span class="s1">lmbd = np.array(self.lmbd)</span>
        <span class="s1">d10 = lmbd[</span><span class="s4">1</span><span class="s1">] - lmbd[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">d21 = lmbd[</span><span class="s4">2</span><span class="s1">] - lmbd[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">d20 = lmbd[</span><span class="s4">2</span><span class="s1">] - lmbd[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">e0 = np.exp(-lmbd[</span><span class="s4">0</span><span class="s1">] * t)</span>
        <span class="s1">e1 = np.exp(-lmbd[</span><span class="s4">1</span><span class="s1">] * t)</span>
        <span class="s1">e2 = np.exp(-lmbd[</span><span class="s4">2</span><span class="s1">] * t)</span>
        <span class="s1">u = np.vstack((</span>
            <span class="s1">self.z0[</span><span class="s4">0</span><span class="s1">] * e0</span><span class="s3">,</span>
            <span class="s1">self.z0[</span><span class="s4">1</span><span class="s1">] * e1 + self.z0[</span><span class="s4">0</span><span class="s1">] * lmbd[</span><span class="s4">0</span><span class="s1">] / d10 * (e0 - e1)</span><span class="s3">,</span>
            <span class="s1">self.z0[</span><span class="s4">2</span><span class="s1">] * e2 + self.z0[</span><span class="s4">1</span><span class="s1">] * lmbd[</span><span class="s4">1</span><span class="s1">] / d21 * (e1 - e2) +</span>
            <span class="s1">lmbd[</span><span class="s4">1</span><span class="s1">] * lmbd[</span><span class="s4">0</span><span class="s1">] * self.z0[</span><span class="s4">0</span><span class="s1">] / d10 *</span>
            <span class="s1">(</span><span class="s4">1 </span><span class="s1">/ d20 * (e0 - e2) - </span><span class="s4">1 </span><span class="s1">/ d21 * (e1 - e2)))).transpose()</span>
        <span class="s3">return </span><span class="s1">allclose(u</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">atol=self.atol</span><span class="s3">, </span><span class="s1">rtol=self.rtol)</span>


<span class="s1">PROBLEMS = [SimpleOscillator</span><span class="s3">, </span><span class="s1">ComplexExp</span><span class="s3">, </span><span class="s1">Pi</span><span class="s3">, </span><span class="s1">CoupledDecay]</span>

<span class="s0">#------------------------------------------------------------------------------</span>


<span class="s3">def </span><span class="s1">f(t</span><span class="s3">, </span><span class="s1">x):</span>
    <span class="s1">dxdt = [x[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-x[</span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s3">return </span><span class="s1">dxdt</span>


<span class="s3">def </span><span class="s1">jac(t</span><span class="s3">, </span><span class="s1">x):</span>
    <span class="s1">j = array([[</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s3">,</span>
               <span class="s1">[-</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">]])</span>
    <span class="s3">return </span><span class="s1">j</span>


<span class="s3">def </span><span class="s1">f1(t</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">omega):</span>
    <span class="s1">dxdt = [omega*x[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-omega*x[</span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s3">return </span><span class="s1">dxdt</span>


<span class="s3">def </span><span class="s1">jac1(t</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">omega):</span>
    <span class="s1">j = array([[</span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">omega]</span><span class="s3">,</span>
               <span class="s1">[-omega</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">]])</span>
    <span class="s3">return </span><span class="s1">j</span>


<span class="s3">def </span><span class="s1">f2(t</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">omega1</span><span class="s3">, </span><span class="s1">omega2):</span>
    <span class="s1">dxdt = [omega1*x[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-omega2*x[</span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s3">return </span><span class="s1">dxdt</span>


<span class="s3">def </span><span class="s1">jac2(t</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">omega1</span><span class="s3">, </span><span class="s1">omega2):</span>
    <span class="s1">j = array([[</span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">omega1]</span><span class="s3">,</span>
               <span class="s1">[-omega2</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">]])</span>
    <span class="s3">return </span><span class="s1">j</span>


<span class="s3">def </span><span class="s1">fv(t</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">omega):</span>
    <span class="s1">dxdt = [omega[</span><span class="s4">0</span><span class="s1">]*x[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-omega[</span><span class="s4">1</span><span class="s1">]*x[</span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s3">return </span><span class="s1">dxdt</span>


<span class="s3">def </span><span class="s1">jacv(t</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">omega):</span>
    <span class="s1">j = array([[</span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">omega[</span><span class="s4">0</span><span class="s1">]]</span><span class="s3">,</span>
               <span class="s1">[-omega[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">]])</span>
    <span class="s3">return </span><span class="s1">j</span>


<span class="s3">class </span><span class="s1">ODECheckParameterUse:</span>
    <span class="s2">&quot;&quot;&quot;Call an ode-class solver with several cases of parameter use.&quot;&quot;&quot;</span>

    <span class="s0"># solver_name must be set before tests can be run with this class.</span>

    <span class="s0"># Set these in subclasses.</span>
    <span class="s1">solver_name = </span><span class="s5">''</span>
    <span class="s1">solver_uses_jac = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">_get_solver(self</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">jac):</span>
        <span class="s1">solver = ode(f</span><span class="s3">, </span><span class="s1">jac)</span>
        <span class="s3">if </span><span class="s1">self.solver_uses_jac:</span>
            <span class="s1">solver.set_integrator(self.solver_name</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-9</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s3">,</span>
                                  <span class="s1">with_jacobian=self.solver_uses_jac)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># XXX Shouldn't set_integrator *always* accept the keyword arg</span>
            <span class="s0"># 'with_jacobian', and perhaps raise an exception if it is set</span>
            <span class="s0"># to True if the solver can't actually use it?</span>
            <span class="s1">solver.set_integrator(self.solver_name</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-9</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">solver</span>

    <span class="s3">def </span><span class="s1">_check_solver(self</span><span class="s3">, </span><span class="s1">solver):</span>
        <span class="s1">ic = [</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">]</span>
        <span class="s1">solver.set_initial_value(ic</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">solver.integrate(pi)</span>
        <span class="s1">assert_array_almost_equal(solver.y</span><span class="s3">, </span><span class="s1">[-</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_no_params(self):</span>
        <span class="s1">solver = self._get_solver(f</span><span class="s3">, </span><span class="s1">jac)</span>
        <span class="s1">self._check_solver(solver)</span>

    <span class="s3">def </span><span class="s1">test_one_scalar_param(self):</span>
        <span class="s1">solver = self._get_solver(f1</span><span class="s3">, </span><span class="s1">jac1)</span>
        <span class="s1">omega = </span><span class="s4">1.0</span>
        <span class="s1">solver.set_f_params(omega)</span>
        <span class="s3">if </span><span class="s1">self.solver_uses_jac:</span>
            <span class="s1">solver.set_jac_params(omega)</span>
        <span class="s1">self._check_solver(solver)</span>

    <span class="s3">def </span><span class="s1">test_two_scalar_params(self):</span>
        <span class="s1">solver = self._get_solver(f2</span><span class="s3">, </span><span class="s1">jac2)</span>
        <span class="s1">omega1 = </span><span class="s4">1.0</span>
        <span class="s1">omega2 = </span><span class="s4">1.0</span>
        <span class="s1">solver.set_f_params(omega1</span><span class="s3">, </span><span class="s1">omega2)</span>
        <span class="s3">if </span><span class="s1">self.solver_uses_jac:</span>
            <span class="s1">solver.set_jac_params(omega1</span><span class="s3">, </span><span class="s1">omega2)</span>
        <span class="s1">self._check_solver(solver)</span>

    <span class="s3">def </span><span class="s1">test_vector_param(self):</span>
        <span class="s1">solver = self._get_solver(fv</span><span class="s3">, </span><span class="s1">jacv)</span>
        <span class="s1">omega = [</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s1">]</span>
        <span class="s1">solver.set_f_params(omega)</span>
        <span class="s3">if </span><span class="s1">self.solver_uses_jac:</span>
            <span class="s1">solver.set_jac_params(omega)</span>
        <span class="s1">self._check_solver(solver)</span>

    <span class="s3">def </span><span class="s1">test_warns_on_failure(self):</span>
        <span class="s0"># Set nsteps small to ensure failure</span>
        <span class="s1">solver = self._get_solver(f</span><span class="s3">, </span><span class="s1">jac)</span>
        <span class="s1">solver.set_integrator(self.solver_name</span><span class="s3">, </span><span class="s1">nsteps=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">ic = [</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">]</span>
        <span class="s1">solver.set_initial_value(ic</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_warns(UserWarning</span><span class="s3">, </span><span class="s1">solver.integrate</span><span class="s3">, </span><span class="s1">pi)</span>


<span class="s3">class </span><span class="s1">TestDOPRI5CheckParameterUse(ODECheckParameterUse):</span>
    <span class="s1">solver_name = </span><span class="s5">'dopri5'</span>
    <span class="s1">solver_uses_jac = </span><span class="s3">False</span>


<span class="s3">class </span><span class="s1">TestDOP853CheckParameterUse(ODECheckParameterUse):</span>
    <span class="s1">solver_name = </span><span class="s5">'dop853'</span>
    <span class="s1">solver_uses_jac = </span><span class="s3">False</span>


<span class="s3">class </span><span class="s1">TestVODECheckParameterUse(ODECheckParameterUse):</span>
    <span class="s1">solver_name = </span><span class="s5">'vode'</span>
    <span class="s1">solver_uses_jac = </span><span class="s3">True</span>


<span class="s3">class </span><span class="s1">TestZVODECheckParameterUse(ODECheckParameterUse):</span>
    <span class="s1">solver_name = </span><span class="s5">'zvode'</span>
    <span class="s1">solver_uses_jac = </span><span class="s3">True</span>


<span class="s3">class </span><span class="s1">TestLSODACheckParameterUse(ODECheckParameterUse):</span>
    <span class="s1">solver_name = </span><span class="s5">'lsoda'</span>
    <span class="s1">solver_uses_jac = </span><span class="s3">True</span>


<span class="s3">def </span><span class="s1">test_odeint_trivial_time():</span>
    <span class="s0"># Test that odeint succeeds when given a single time point</span>
    <span class="s0"># and full_output=True.  This is a regression test for gh-4282.</span>
    <span class="s1">y0 = </span><span class="s4">1</span>
    <span class="s1">t = [</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">y</span><span class="s3">, </span><span class="s1">info = odeint(</span><span class="s3">lambda </span><span class="s1">y</span><span class="s3">, </span><span class="s1">t: -y</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(y</span><span class="s3">, </span><span class="s1">np.array([[y0]]))</span>


<span class="s3">def </span><span class="s1">test_odeint_banded_jacobian():</span>
    <span class="s0"># Test the use of the `Dfun`, `ml` and `mu` options of odeint.</span>

    <span class="s3">def </span><span class="s1">func(y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c):</span>
        <span class="s3">return </span><span class="s1">c.dot(y)</span>

    <span class="s3">def </span><span class="s1">jac(y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c):</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">jac_transpose(y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c):</span>
        <span class="s3">return </span><span class="s1">c.T.copy(order=</span><span class="s5">'C'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">bjac_rows(y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c):</span>
        <span class="s1">jac = np.row_stack((np.r_[</span><span class="s4">0</span><span class="s3">, </span><span class="s1">np.diag(c</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s3">,</span>
                            <span class="s1">np.diag(c)</span><span class="s3">,</span>
                            <span class="s1">np.r_[np.diag(c</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
                            <span class="s1">np.r_[np.diag(c</span><span class="s3">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">)</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s3">return </span><span class="s1">jac</span>

    <span class="s3">def </span><span class="s1">bjac_cols(y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c):</span>
        <span class="s3">return </span><span class="s1">bjac_rows(y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c).T.copy(order=</span><span class="s5">'C'</span><span class="s1">)</span>

    <span class="s1">c = array([[-</span><span class="s4">205</span><span class="s3">, </span><span class="s4">0.01</span><span class="s3">, </span><span class="s4">0.00</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s3">,</span>
               <span class="s1">[</span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">2.50</span><span class="s3">, </span><span class="s4">0.02</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s3">,</span>
               <span class="s1">[</span><span class="s4">1e-3</span><span class="s3">, </span><span class="s4">0.01</span><span class="s3">, </span><span class="s1">-</span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">0.01</span><span class="s1">]</span><span class="s3">,</span>
               <span class="s1">[</span><span class="s4">0.00</span><span class="s3">, </span><span class="s4">0.00</span><span class="s3">, </span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1.0</span><span class="s1">]])</span>

    <span class="s1">y0 = np.ones(</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">t = np.array([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s4">100</span><span class="s1">])</span>

    <span class="s0"># Use the full Jacobian.</span>
    <span class="s1">sol1</span><span class="s3">, </span><span class="s1">info1 = odeint(func</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">args=(c</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s3">True,</span>
                         <span class="s1">atol=</span><span class="s4">1e-13</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s3">, </span><span class="s1">mxstep=</span><span class="s4">10000</span><span class="s3">,</span>
                         <span class="s1">Dfun=jac)</span>

    <span class="s0"># Use the transposed full Jacobian, with col_deriv=True.</span>
    <span class="s1">sol2</span><span class="s3">, </span><span class="s1">info2 = odeint(func</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">args=(c</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s3">True,</span>
                         <span class="s1">atol=</span><span class="s4">1e-13</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s3">, </span><span class="s1">mxstep=</span><span class="s4">10000</span><span class="s3">,</span>
                         <span class="s1">Dfun=jac_transpose</span><span class="s3">, </span><span class="s1">col_deriv=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s0"># Use the banded Jacobian.</span>
    <span class="s1">sol3</span><span class="s3">, </span><span class="s1">info3 = odeint(func</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">args=(c</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s3">True,</span>
                         <span class="s1">atol=</span><span class="s4">1e-13</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s3">, </span><span class="s1">mxstep=</span><span class="s4">10000</span><span class="s3">,</span>
                         <span class="s1">Dfun=bjac_rows</span><span class="s3">, </span><span class="s1">ml=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">mu=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0"># Use the transposed banded Jacobian, with col_deriv=True.</span>
    <span class="s1">sol4</span><span class="s3">, </span><span class="s1">info4 = odeint(func</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">args=(c</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">full_output=</span><span class="s3">True,</span>
                         <span class="s1">atol=</span><span class="s4">1e-13</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s3">, </span><span class="s1">mxstep=</span><span class="s4">10000</span><span class="s3">,</span>
                         <span class="s1">Dfun=bjac_cols</span><span class="s3">, </span><span class="s1">ml=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">mu=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">col_deriv=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s1">assert_allclose(sol1</span><span class="s3">, </span><span class="s1">sol2</span><span class="s3">, </span><span class="s1">err_msg=</span><span class="s5">&quot;sol1 != sol2&quot;</span><span class="s1">)</span>
    <span class="s1">assert_allclose(sol1</span><span class="s3">, </span><span class="s1">sol3</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">err_msg=</span><span class="s5">&quot;sol1 != sol3&quot;</span><span class="s1">)</span>
    <span class="s1">assert_allclose(sol3</span><span class="s3">, </span><span class="s1">sol4</span><span class="s3">, </span><span class="s1">err_msg=</span><span class="s5">&quot;sol3 != sol4&quot;</span><span class="s1">)</span>

    <span class="s0"># Verify that the number of jacobian evaluations was the same for the</span>
    <span class="s0"># calls of odeint with a full jacobian and with a banded jacobian. This is</span>
    <span class="s0"># a regression test--there was a bug in the handling of banded jacobians</span>
    <span class="s0"># that resulted in an incorrect jacobian matrix being passed to the LSODA</span>
    <span class="s0"># code.  That would cause errors or excessive jacobian evaluations.</span>
    <span class="s1">assert_array_equal(info1[</span><span class="s5">'nje'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">info2[</span><span class="s5">'nje'</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(info3[</span><span class="s5">'nje'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">info4[</span><span class="s5">'nje'</span><span class="s1">])</span>

    <span class="s0"># Test the use of tfirst</span>
    <span class="s1">sol1ty</span><span class="s3">, </span><span class="s1">info1ty = odeint(</span><span class="s3">lambda </span><span class="s1">t</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">c: func(y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c)</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">args=(c</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                             <span class="s1">full_output=</span><span class="s3">True, </span><span class="s1">atol=</span><span class="s4">1e-13</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s3">,</span>
                             <span class="s1">mxstep=</span><span class="s4">10000</span><span class="s3">,</span>
                             <span class="s1">Dfun=</span><span class="s3">lambda </span><span class="s1">t</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">c: jac(y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c)</span><span class="s3">, </span><span class="s1">tfirst=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s0"># The code should execute the exact same sequence of floating point</span>
    <span class="s0"># calculations, so these should be exactly equal. We'll be safe and use</span>
    <span class="s0"># a small tolerance.</span>
    <span class="s1">assert_allclose(sol1</span><span class="s3">, </span><span class="s1">sol1ty</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">err_msg=</span><span class="s5">&quot;sol1 != sol1ty&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_odeint_errors():</span>
    <span class="s3">def </span><span class="s1">sys1d(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">-</span><span class="s4">100</span><span class="s1">*x</span>

    <span class="s3">def </span><span class="s1">bad1(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">0</span>

    <span class="s3">def </span><span class="s1">bad2(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s5">&quot;foo&quot;</span>

    <span class="s3">def </span><span class="s1">bad_jac1(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">0</span>

    <span class="s3">def </span><span class="s1">bad_jac2(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">[[</span><span class="s5">&quot;foo&quot;</span><span class="s1">]]</span>

    <span class="s3">def </span><span class="s1">sys2d(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">[-</span><span class="s4">100</span><span class="s1">*x[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">*x[</span><span class="s4">1</span><span class="s1">]]</span>

    <span class="s3">def </span><span class="s1">sys2d_bad_jac(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">[[</span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]]</span>

    <span class="s1">assert_raises(ZeroDivisionError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">bad1</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">bad2</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">assert_raises(ZeroDivisionError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">sys1d</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">Dfun=bad_jac1)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">sys1d</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">Dfun=bad_jac2)</span>

    <span class="s1">assert_raises(ZeroDivisionError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">sys2d</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">,</span>
                  <span class="s1">Dfun=sys2d_bad_jac)</span>


<span class="s3">def </span><span class="s1">test_odeint_bad_shapes():</span>
    <span class="s0"># Tests of some errors that can occur with odeint.</span>

    <span class="s3">def </span><span class="s1">badrhs(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">sys1(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">-</span><span class="s4">100</span><span class="s1">*x</span>

    <span class="s3">def </span><span class="s1">badjac(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">[[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]]</span>

    <span class="s0"># y0 must be at most 1-d.</span>
    <span class="s1">bad_y0 = [[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">sys1</span><span class="s3">, </span><span class="s1">bad_y0</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">])</span>

    <span class="s0"># t must be at most 1-d.</span>
    <span class="s1">bad_t = [[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s1">]]</span>
    <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">sys1</span><span class="s3">, </span><span class="s1">[</span><span class="s4">10.0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">bad_t)</span>

    <span class="s0"># y0 is 10, but badrhs(x, t) returns [1, -1].</span>
    <span class="s1">assert_raises(RuntimeError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">badrhs</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">])</span>

    <span class="s0"># shape of array returned by badjac(x, t) is not correct.</span>
    <span class="s1">assert_raises(RuntimeError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">sys1</span><span class="s3">, </span><span class="s1">[</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">Dfun=badjac)</span>


<span class="s3">def </span><span class="s1">test_repeated_t_values():</span>
    <span class="s2">&quot;&quot;&quot;Regression test for gh-8217.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">func(x</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s3">return </span><span class="s1">-</span><span class="s4">0.25</span><span class="s1">*x</span>

    <span class="s1">t = np.zeros(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">sol = odeint(func</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t)</span>
    <span class="s1">assert_array_equal(sol</span><span class="s3">, </span><span class="s1">np.ones((len(t)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)))</span>

    <span class="s1">tau = </span><span class="s4">4</span><span class="s1">*np.log(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">t = [</span><span class="s4">0</span><span class="s1">]*</span><span class="s4">9 </span><span class="s1">+ [tau</span><span class="s3">, </span><span class="s4">2</span><span class="s1">*tau</span><span class="s3">, </span><span class="s4">2</span><span class="s1">*tau</span><span class="s3">, </span><span class="s4">3</span><span class="s1">*tau]</span>
    <span class="s1">sol = odeint(func</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
    <span class="s1">expected_sol = np.array([[</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">]]*</span><span class="s4">9 </span><span class="s1">+</span>
                            <span class="s1">[[</span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s3">,</span>
                             <span class="s1">[</span><span class="s4">0.25</span><span class="s3">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s3">,</span>
                             <span class="s1">[</span><span class="s4">0.25</span><span class="s3">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s3">,</span>
                             <span class="s1">[</span><span class="s4">0.125</span><span class="s3">, </span><span class="s4">0.25</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(sol</span><span class="s3">, </span><span class="s1">expected_sol)</span>

    <span class="s0"># Edge case: empty t sequence.</span>
    <span class="s1">sol = odeint(func</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[])</span>
    <span class="s1">assert_array_equal(sol</span><span class="s3">, </span><span class="s1">np.array([]</span><span class="s3">, </span><span class="s1">dtype=np.float64).reshape((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)))</span>

    <span class="s0"># t values are not monotonic.</span>
    <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">odeint</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s1">])</span>
</pre>
</body>
</html>