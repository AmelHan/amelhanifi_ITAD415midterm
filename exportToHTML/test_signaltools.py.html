<html>
<head>
<title>test_signaltools.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_signaltools.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>

<span class="s0">from </span><span class="s1">concurrent.futures </span><span class="s0">import </span><span class="s1">ThreadPoolExecutor</span><span class="s0">, </span><span class="s1">as_completed</span>
<span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">product</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">gcd</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_equal</span><span class="s0">,</span>
    <span class="s1">assert_almost_equal</span><span class="s0">, </span><span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal</span><span class="s0">,</span>
    <span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_array_less</span><span class="s0">,</span>
    <span class="s1">suppress_warnings)</span>
<span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">array</span><span class="s0">, </span><span class="s1">arange</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">scipy.fft </span><span class="s0">import </span><span class="s1">fft</span>
<span class="s0">from </span><span class="s1">scipy.ndimage </span><span class="s0">import </span><span class="s1">correlate1d</span>
<span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">fmin</span><span class="s0">, </span><span class="s1">linear_sum_assignment</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">signal</span>
<span class="s0">from </span><span class="s1">scipy.signal </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">correlate</span><span class="s0">, </span><span class="s1">correlate2d</span><span class="s0">, </span><span class="s1">correlation_lags</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">convolve2d</span><span class="s0">,</span>
    <span class="s1">fftconvolve</span><span class="s0">, </span><span class="s1">oaconvolve</span><span class="s0">, </span><span class="s1">choose_conv_method</span><span class="s0">,</span>
    <span class="s1">hilbert</span><span class="s0">, </span><span class="s1">hilbert2</span><span class="s0">, </span><span class="s1">lfilter</span><span class="s0">, </span><span class="s1">lfilter_zi</span><span class="s0">, </span><span class="s1">filtfilt</span><span class="s0">, </span><span class="s1">butter</span><span class="s0">, </span><span class="s1">zpk2tf</span><span class="s0">, </span><span class="s1">zpk2sos</span><span class="s0">,</span>
    <span class="s1">invres</span><span class="s0">, </span><span class="s1">invresz</span><span class="s0">, </span><span class="s1">vectorstrength</span><span class="s0">, </span><span class="s1">lfiltic</span><span class="s0">, </span><span class="s1">tf2sos</span><span class="s0">, </span><span class="s1">sosfilt</span><span class="s0">, </span><span class="s1">sosfiltfilt</span><span class="s0">,</span>
    <span class="s1">sosfilt_zi</span><span class="s0">, </span><span class="s1">tf2zpk</span><span class="s0">, </span><span class="s1">BadCoefficients</span><span class="s0">, </span><span class="s1">detrend</span><span class="s0">, </span><span class="s1">unique_roots</span><span class="s0">, </span><span class="s1">residue</span><span class="s0">,</span>
    <span class="s1">residuez)</span>
<span class="s0">from </span><span class="s1">scipy.signal.windows </span><span class="s0">import </span><span class="s1">hann</span>
<span class="s0">from </span><span class="s1">scipy.signal._signaltools </span><span class="s0">import </span><span class="s1">(_filtfilt_gust</span><span class="s0">, </span><span class="s1">_compute_factors</span><span class="s0">,</span>
                                      <span class="s1">_group_poles)</span>
<span class="s0">from </span><span class="s1">scipy.signal._upfirdn </span><span class="s0">import </span><span class="s1">_upfirdn_modes</span>
<span class="s0">from </span><span class="s1">scipy._lib </span><span class="s0">import </span><span class="s1">_testutils</span>


<span class="s0">class </span><span class="s1">_TestConvolve:</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">a = [</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">c = convolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">22</span><span class="s0">, </span><span class="s2">28</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_same(self):</span>
        <span class="s1">a = [</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span>
        <span class="s1">c = convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">&quot;same&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">array([</span><span class="s2">10</span><span class="s0">, </span><span class="s2">22</span><span class="s0">, </span><span class="s2">34</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_same_eq(self):</span>
        <span class="s1">a = [</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">c = convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">&quot;same&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">array([</span><span class="s2">10</span><span class="s0">, </span><span class="s2">22</span><span class="s0">, </span><span class="s2">22</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_complex(self):</span>
        <span class="s1">x = array([</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s1">y = array([</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s1">z = convolve(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_array_equal(z</span><span class="s0">, </span><span class="s1">array([</span><span class="s2">2j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">6j</span><span class="s0">, </span><span class="s2">5 </span><span class="s1">+ </span><span class="s2">8j</span><span class="s0">, </span><span class="s2">5 </span><span class="s1">+ </span><span class="s2">5j</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_zero_rank(self):</span>
        <span class="s1">a = </span><span class="s2">1289</span>
        <span class="s1">b = </span><span class="s2">4567</span>
        <span class="s1">c = convolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">a * b)</span>

    <span class="s0">def </span><span class="s1">test_broadcastable(self):</span>
        <span class="s1">a = np.arange(</span><span class="s2">27</span><span class="s1">).reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">b = np.arange(</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">):</span>
            <span class="s1">b_shape = [</span><span class="s2">1</span><span class="s1">]*</span><span class="s2">3</span>
            <span class="s1">b_shape[i] = </span><span class="s2">3</span>
            <span class="s1">x = convolve(a</span><span class="s0">, </span><span class="s1">b.reshape(b_shape)</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>
            <span class="s1">y = convolve(a</span><span class="s0">, </span><span class="s1">b.reshape(b_shape)</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
            <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_single_element(self):</span>
        <span class="s1">a = array([</span><span class="s2">4967</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3920</span><span class="s1">])</span>
        <span class="s1">c = convolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">a * b)</span>

    <span class="s0">def </span><span class="s1">test_2d_arrays(self):</span>
        <span class="s1">a = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">b = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]]</span>
        <span class="s1">c = convolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">d = array([[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s2">62</span><span class="s0">, </span><span class="s2">58</span><span class="s0">, </span><span class="s2">38</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">12</span><span class="s0">, </span><span class="s2">31</span><span class="s0">, </span><span class="s2">58</span><span class="s0">, </span><span class="s2">49</span><span class="s0">, </span><span class="s2">30</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">def </span><span class="s1">test_input_swapping(self):</span>
        <span class="s1">small = arange(</span><span class="s2">8</span><span class="s1">).reshape(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">big = </span><span class="s2">1j </span><span class="s1">* arange(</span><span class="s2">27</span><span class="s1">).reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">big += arange(</span><span class="s2">27</span><span class="s1">)[::-</span><span class="s2">1</span><span class="s1">].reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>

        <span class="s1">out_array = array(</span>
            <span class="s1">[[[</span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s0">, </span><span class="s2">26 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s0">, </span><span class="s2">25 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">24 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">52 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s0">, </span><span class="s2">151 </span><span class="s1">+ </span><span class="s2">5j</span><span class="s0">, </span><span class="s2">145 </span><span class="s1">+ </span><span class="s2">11j</span><span class="s0">, </span><span class="s2">93 </span><span class="s1">+ </span><span class="s2">11j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">46 </span><span class="s1">+ </span><span class="s2">6j</span><span class="s0">, </span><span class="s2">133 </span><span class="s1">+ </span><span class="s2">23j</span><span class="s0">, </span><span class="s2">127 </span><span class="s1">+ </span><span class="s2">29j</span><span class="s0">, </span><span class="s2">81 </span><span class="s1">+ </span><span class="s2">23j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">40 </span><span class="s1">+ </span><span class="s2">12j</span><span class="s0">, </span><span class="s2">98 </span><span class="s1">+ </span><span class="s2">32j</span><span class="s0">, </span><span class="s2">93 </span><span class="s1">+ </span><span class="s2">37j</span><span class="s0">, </span><span class="s2">54 </span><span class="s1">+ </span><span class="s2">24j</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s2">104 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s0">, </span><span class="s2">247 </span><span class="s1">+ </span><span class="s2">13j</span><span class="s0">, </span><span class="s2">237 </span><span class="s1">+ </span><span class="s2">23j</span><span class="s0">, </span><span class="s2">135 </span><span class="s1">+ </span><span class="s2">21j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">282 </span><span class="s1">+ </span><span class="s2">30j</span><span class="s0">, </span><span class="s2">632 </span><span class="s1">+ </span><span class="s2">96j</span><span class="s0">, </span><span class="s2">604 </span><span class="s1">+ </span><span class="s2">124j</span><span class="s0">, </span><span class="s2">330 </span><span class="s1">+ </span><span class="s2">86j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">246 </span><span class="s1">+ </span><span class="s2">66j</span><span class="s0">, </span><span class="s2">548 </span><span class="s1">+ </span><span class="s2">180j</span><span class="s0">, </span><span class="s2">520 </span><span class="s1">+ </span><span class="s2">208j</span><span class="s0">, </span><span class="s2">282 </span><span class="s1">+ </span><span class="s2">134j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">142 </span><span class="s1">+ </span><span class="s2">66j</span><span class="s0">, </span><span class="s2">307 </span><span class="s1">+ </span><span class="s2">161j</span><span class="s0">, </span><span class="s2">289 </span><span class="s1">+ </span><span class="s2">179j</span><span class="s0">, </span><span class="s2">153 </span><span class="s1">+ </span><span class="s2">107j</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s2">68 </span><span class="s1">+ </span><span class="s2">36j</span><span class="s0">, </span><span class="s2">157 </span><span class="s1">+ </span><span class="s2">103j</span><span class="s0">, </span><span class="s2">147 </span><span class="s1">+ </span><span class="s2">113j</span><span class="s0">, </span><span class="s2">81 </span><span class="s1">+ </span><span class="s2">75j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">174 </span><span class="s1">+ </span><span class="s2">138j</span><span class="s0">, </span><span class="s2">380 </span><span class="s1">+ </span><span class="s2">348j</span><span class="s0">, </span><span class="s2">352 </span><span class="s1">+ </span><span class="s2">376j</span><span class="s0">, </span><span class="s2">186 </span><span class="s1">+ </span><span class="s2">230j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">138 </span><span class="s1">+ </span><span class="s2">174j</span><span class="s0">, </span><span class="s2">296 </span><span class="s1">+ </span><span class="s2">432j</span><span class="s0">, </span><span class="s2">268 </span><span class="s1">+ </span><span class="s2">460j</span><span class="s0">, </span><span class="s2">138 </span><span class="s1">+ </span><span class="s2">278j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">70 </span><span class="s1">+ </span><span class="s2">138j</span><span class="s0">, </span><span class="s2">145 </span><span class="s1">+ </span><span class="s2">323j</span><span class="s0">, </span><span class="s2">127 </span><span class="s1">+ </span><span class="s2">341j</span><span class="s0">, </span><span class="s2">63 </span><span class="s1">+ </span><span class="s2">197j</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s2">32 </span><span class="s1">+ </span><span class="s2">72j</span><span class="s0">, </span><span class="s2">68 </span><span class="s1">+ </span><span class="s2">166j</span><span class="s0">, </span><span class="s2">59 </span><span class="s1">+ </span><span class="s2">175j</span><span class="s0">, </span><span class="s2">30 </span><span class="s1">+ </span><span class="s2">100j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">68 </span><span class="s1">+ </span><span class="s2">192j</span><span class="s0">, </span><span class="s2">139 </span><span class="s1">+ </span><span class="s2">433j</span><span class="s0">, </span><span class="s2">117 </span><span class="s1">+ </span><span class="s2">455j</span><span class="s0">, </span><span class="s2">57 </span><span class="s1">+ </span><span class="s2">255j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">38 </span><span class="s1">+ </span><span class="s2">222j</span><span class="s0">, </span><span class="s2">73 </span><span class="s1">+ </span><span class="s2">499j</span><span class="s0">, </span><span class="s2">51 </span><span class="s1">+ </span><span class="s2">521j</span><span class="s0">, </span><span class="s2">21 </span><span class="s1">+ </span><span class="s2">291j</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s2">12 </span><span class="s1">+ </span><span class="s2">144j</span><span class="s0">, </span><span class="s2">20 </span><span class="s1">+ </span><span class="s2">318j</span><span class="s0">, </span><span class="s2">7 </span><span class="s1">+ </span><span class="s2">331j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">182j</span><span class="s1">]]])</span>

        <span class="s1">assert_array_equal(convolve(small</span><span class="s0">, </span><span class="s1">big</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out_array)</span>
        <span class="s1">assert_array_equal(convolve(big</span><span class="s0">, </span><span class="s1">small</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out_array)</span>
        <span class="s1">assert_array_equal(convolve(small</span><span class="s0">, </span><span class="s1">big</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">out_array[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(convolve(big</span><span class="s0">, </span><span class="s1">small</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">out_array[</span><span class="s2">0</span><span class="s1">:</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">:</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">:</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(convolve(small</span><span class="s0">, </span><span class="s1">big</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">out_array[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(convolve(big</span><span class="s0">, </span><span class="s1">small</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">out_array[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_invalid_params(self):</span>
        <span class="s1">a = [</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'spam'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'eggs'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'ham'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'bacon'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'bacon'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestConvolve(_TestConvolve):</span>

    <span class="s0">def </span><span class="s1">test_valid_mode2(self):</span>
        <span class="s4"># See gh-5897</span>
        <span class="s1">a = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">expected = [</span><span class="s2">70</span><span class="s0">, </span><span class="s2">78</span><span class="s0">, </span><span class="s2">73</span><span class="s0">, </span><span class="s2">65</span><span class="s1">]</span>

        <span class="s1">out = convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">out = convolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">a = [</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">5j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">3j</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s1">]</span>
        <span class="s1">expected = [</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">3j</span><span class="s0">, </span><span class="s2">8 </span><span class="s1">- </span><span class="s2">10j</span><span class="s1">]</span>

        <span class="s1">out = convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">out = convolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_same_mode(self):</span>
        <span class="s1">a = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">c = convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span>
        <span class="s1">d = array([</span><span class="s2">57</span><span class="s0">, </span><span class="s2">61</span><span class="s0">, </span><span class="s2">63</span><span class="s0">, </span><span class="s2">57</span><span class="s0">, </span><span class="s2">45</span><span class="s0">, </span><span class="s2">36</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">def </span><span class="s1">test_invalid_shapes(self):</span>
        <span class="s4"># By &quot;invalid,&quot; we mean that no one</span>
        <span class="s4"># array has dimensions that are all at</span>
        <span class="s4"># least as large as the corresponding</span>
        <span class="s4"># dimensions of the other array. This</span>
        <span class="s4"># setup should throw a ValueError.</span>
        <span class="s1">a = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s1">).reshape((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(-</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0</span><span class="s1">).reshape((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">*(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">**{</span><span class="s3">'mode'</span><span class="s1">: </span><span class="s3">'valid'</span><span class="s1">})</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">*(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">**{</span><span class="s3">'mode'</span><span class="s1">: </span><span class="s3">'valid'</span><span class="s1">})</span>

    <span class="s0">def </span><span class="s1">test_convolve_method(self</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">100</span><span class="s1">):</span>
        <span class="s1">types = sum([t </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">np.sctypes.items()]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">types = {np.dtype(t).name </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types}</span>

        <span class="s4"># These types include 'bool' and all precisions (int8, float32, etc)</span>
        <span class="s4"># The removed types throw errors in correlate or fftconvolve</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'complex256'</span><span class="s0">, </span><span class="s3">'complex192'</span><span class="s0">, </span><span class="s3">'float128'</span><span class="s0">, </span><span class="s3">'float96'</span><span class="s0">,</span>
                      <span class="s3">'str'</span><span class="s0">, </span><span class="s3">'void'</span><span class="s0">, </span><span class="s3">'bytes'</span><span class="s0">, </span><span class="s3">'object'</span><span class="s0">, </span><span class="s3">'unicode'</span><span class="s0">, </span><span class="s3">'string'</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">types:</span>
                <span class="s1">types.remove(dtype)</span>

        <span class="s1">args = [(t1</span><span class="s0">, </span><span class="s1">t2</span><span class="s0">, </span><span class="s1">mode) </span><span class="s0">for </span><span class="s1">t1 </span><span class="s0">in </span><span class="s1">types </span><span class="s0">for </span><span class="s1">t2 </span><span class="s0">in </span><span class="s1">types</span>
                               <span class="s0">for </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'valid'</span><span class="s0">, </span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">]]</span>

        <span class="s4"># These are random arrays, which means test is much stronger than</span>
        <span class="s4"># convolving testing by convolving two np.ones arrays</span>
        <span class="s1">np.random.seed(</span><span class="s2">42</span><span class="s1">)</span>
        <span class="s1">array_types = {</span><span class="s3">'i'</span><span class="s1">: np.random.choice([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">size=n)</span><span class="s0">,</span>
                       <span class="s3">'f'</span><span class="s1">: np.random.randn(n)}</span>
        <span class="s1">array_types[</span><span class="s3">'b'</span><span class="s1">] = array_types[</span><span class="s3">'u'</span><span class="s1">] = array_types[</span><span class="s3">'i'</span><span class="s1">]</span>
        <span class="s1">array_types[</span><span class="s3">'c'</span><span class="s1">] = array_types[</span><span class="s3">'f'</span><span class="s1">] + </span><span class="s2">0.5j</span><span class="s1">*array_types[</span><span class="s3">'f'</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">t1</span><span class="s0">, </span><span class="s1">t2</span><span class="s0">, </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">args:</span>
            <span class="s1">x1 = array_types[np.dtype(t1).kind].astype(t1)</span>
            <span class="s1">x2 = array_types[np.dtype(t2).kind].astype(t2)</span>

            <span class="s1">results = {key: convolve(x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">method=key</span><span class="s0">, </span><span class="s1">mode=mode)</span>
                       <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'fft'</span><span class="s0">, </span><span class="s3">'direct'</span><span class="s1">]}</span>

            <span class="s1">assert_equal(results[</span><span class="s3">'fft'</span><span class="s1">].dtype</span><span class="s0">, </span><span class="s1">results[</span><span class="s3">'direct'</span><span class="s1">].dtype)</span>

            <span class="s0">if </span><span class="s3">'bool' </span><span class="s0">in </span><span class="s1">t1 </span><span class="s0">and </span><span class="s3">'bool' </span><span class="s0">in </span><span class="s1">t2:</span>
                <span class="s1">assert_equal(choose_conv_method(x1</span><span class="s0">, </span><span class="s1">x2)</span><span class="s0">, </span><span class="s3">'direct'</span><span class="s1">)</span>
                <span class="s0">continue</span>

            <span class="s4"># Found by experiment. Found approx smallest value for (rtol, atol)</span>
            <span class="s4"># threshold to have tests pass.</span>
            <span class="s0">if </span><span class="s1">any([t </span><span class="s0">in </span><span class="s1">{</span><span class="s3">'complex64'</span><span class="s0">, </span><span class="s3">'float32'</span><span class="s1">} </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[t1</span><span class="s0">, </span><span class="s1">t2]]):</span>
                <span class="s1">kwargs = {</span><span class="s3">'rtol'</span><span class="s1">: </span><span class="s2">1.0e-4</span><span class="s0">, </span><span class="s3">'atol'</span><span class="s1">: </span><span class="s2">1e-6</span><span class="s1">}</span>
            <span class="s0">elif </span><span class="s3">'float16' </span><span class="s0">in </span><span class="s1">[t1</span><span class="s0">, </span><span class="s1">t2]:</span>
                <span class="s4"># atol is default for np.allclose</span>
                <span class="s1">kwargs = {</span><span class="s3">'rtol'</span><span class="s1">: </span><span class="s2">1e-3</span><span class="s0">, </span><span class="s3">'atol'</span><span class="s1">: </span><span class="s2">1e-3</span><span class="s1">}</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># defaults for np.allclose (different from assert_allclose)</span>
                <span class="s1">kwargs = {</span><span class="s3">'rtol'</span><span class="s1">: </span><span class="s2">1e-5</span><span class="s0">, </span><span class="s3">'atol'</span><span class="s1">: </span><span class="s2">1e-8</span><span class="s1">}</span>

            <span class="s1">assert_allclose(results[</span><span class="s3">'fft'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results[</span><span class="s3">'direct'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_convolve_method_large_input(self):</span>
        <span class="s4"># This is really a test that convolving two large integers goes to the</span>
        <span class="s4"># direct method even if they're in the fft method.</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">51</span><span class="s0">, </span><span class="s2">52</span><span class="s0">, </span><span class="s2">53</span><span class="s0">, </span><span class="s2">54</span><span class="s0">, </span><span class="s2">60</span><span class="s0">, </span><span class="s2">62</span><span class="s1">]:</span>
            <span class="s1">z = np.array([</span><span class="s2">2</span><span class="s1">**n]</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
            <span class="s1">fft = convolve(z</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
            <span class="s1">direct = convolve(z</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>

            <span class="s4"># this is the case when integer precision gets to us</span>
            <span class="s4"># issue #6076 has more detail, hopefully more tests after resolved</span>
            <span class="s0">if </span><span class="s1">n &lt; </span><span class="s2">50</span><span class="s1">:</span>
                <span class="s1">assert_equal(fft</span><span class="s0">, </span><span class="s1">direct)</span>
                <span class="s1">assert_equal(fft</span><span class="s0">, </span><span class="s2">2</span><span class="s1">**(</span><span class="s2">2</span><span class="s1">*n))</span>
                <span class="s1">assert_equal(direct</span><span class="s0">, </span><span class="s2">2</span><span class="s1">**(</span><span class="s2">2</span><span class="s1">*n))</span>

    <span class="s0">def </span><span class="s1">test_mismatched_dims(self):</span>
        <span class="s4"># Input arrays should have the same number of dimensions</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">_TestConvolve2d:</span>

    <span class="s0">def </span><span class="s1">test_2d_arrays(self):</span>
        <span class="s1">a = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">b = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]]</span>
        <span class="s1">d = array([[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s2">62</span><span class="s0">, </span><span class="s2">58</span><span class="s0">, </span><span class="s2">38</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">12</span><span class="s0">, </span><span class="s2">31</span><span class="s0">, </span><span class="s2">58</span><span class="s0">, </span><span class="s2">49</span><span class="s0">, </span><span class="s2">30</span><span class="s1">]])</span>
        <span class="s1">e = convolve2d(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_equal(e</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">def </span><span class="s1">test_valid_mode(self):</span>
        <span class="s1">e = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]]</span>
        <span class="s1">f = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">h = array([[</span><span class="s2">62</span><span class="s0">, </span><span class="s2">80</span><span class="s0">, </span><span class="s2">98</span><span class="s0">, </span><span class="s2">116</span><span class="s0">, </span><span class="s2">134</span><span class="s1">]])</span>

        <span class="s1">g = convolve2d(e</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(g</span><span class="s0">, </span><span class="s1">h)</span>

        <span class="s4"># See gh-5897</span>
        <span class="s1">g = convolve2d(f</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(g</span><span class="s0">, </span><span class="s1">h)</span>

    <span class="s0">def </span><span class="s1">test_valid_mode_complx(self):</span>
        <span class="s1">e = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]]</span>
        <span class="s1">f = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=complex) + </span><span class="s2">1j</span>
        <span class="s1">h = array([[</span><span class="s2">62.</span><span class="s1">+</span><span class="s2">24.j</span><span class="s0">, </span><span class="s2">80.</span><span class="s1">+</span><span class="s2">30.j</span><span class="s0">, </span><span class="s2">98.</span><span class="s1">+</span><span class="s2">36.j</span><span class="s0">, </span><span class="s2">116.</span><span class="s1">+</span><span class="s2">42.j</span><span class="s0">, </span><span class="s2">134.</span><span class="s1">+</span><span class="s2">48.j</span><span class="s1">]])</span>

        <span class="s1">g = convolve2d(e</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(g</span><span class="s0">, </span><span class="s1">h)</span>

        <span class="s4"># See gh-5897</span>
        <span class="s1">g = convolve2d(f</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(g</span><span class="s0">, </span><span class="s1">h)</span>

    <span class="s0">def </span><span class="s1">test_fillvalue(self):</span>
        <span class="s1">a = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">b = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]]</span>
        <span class="s1">fillval = </span><span class="s2">1</span>
        <span class="s1">c = convolve2d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'fill'</span><span class="s0">, </span><span class="s1">fillval)</span>
        <span class="s1">d = array([[</span><span class="s2">24</span><span class="s0">, </span><span class="s2">26</span><span class="s0">, </span><span class="s2">31</span><span class="s0">, </span><span class="s2">34</span><span class="s0">, </span><span class="s2">32</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">28</span><span class="s0">, </span><span class="s2">40</span><span class="s0">, </span><span class="s2">62</span><span class="s0">, </span><span class="s2">64</span><span class="s0">, </span><span class="s2">52</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">32</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">67</span><span class="s0">, </span><span class="s2">62</span><span class="s0">, </span><span class="s2">48</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">def </span><span class="s1">test_fillvalue_errors(self):</span>
        <span class="s1">msg = </span><span class="s3">&quot;could not cast `fillvalue` directly to the output &quot;</span>
        <span class="s0">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(np.ComplexWarning</span><span class="s0">, </span><span class="s3">&quot;Casting complex values&quot;</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">convolve2d([[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">fillvalue=</span><span class="s2">1j</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s3">&quot;`fillvalue` must be scalar or an array with &quot;</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">convolve2d([[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">fillvalue=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_fillvalue_empty(self):</span>
        <span class="s4"># Check that fillvalue being empty raises an error:</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve2d</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
                      <span class="s1">fillvalue=[])</span>

    <span class="s0">def </span><span class="s1">test_wrap_boundary(self):</span>
        <span class="s1">a = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">b = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]]</span>
        <span class="s1">c = convolve2d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'wrap'</span><span class="s1">)</span>
        <span class="s1">d = array([[</span><span class="s2">80</span><span class="s0">, </span><span class="s2">80</span><span class="s0">, </span><span class="s2">74</span><span class="s0">, </span><span class="s2">80</span><span class="s0">, </span><span class="s2">80</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">68</span><span class="s0">, </span><span class="s2">68</span><span class="s0">, </span><span class="s2">62</span><span class="s0">, </span><span class="s2">68</span><span class="s0">, </span><span class="s2">68</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">80</span><span class="s0">, </span><span class="s2">80</span><span class="s0">, </span><span class="s2">74</span><span class="s0">, </span><span class="s2">80</span><span class="s0">, </span><span class="s2">80</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">def </span><span class="s1">test_sym_boundary(self):</span>
        <span class="s1">a = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">b = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]]</span>
        <span class="s1">c = convolve2d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'symm'</span><span class="s1">)</span>
        <span class="s1">d = array([[</span><span class="s2">34</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s2">44</span><span class="s0">, </span><span class="s2">62</span><span class="s0">, </span><span class="s2">66</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">52</span><span class="s0">, </span><span class="s2">48</span><span class="s0">, </span><span class="s2">62</span><span class="s0">, </span><span class="s2">80</span><span class="s0">, </span><span class="s2">84</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">82</span><span class="s0">, </span><span class="s2">78</span><span class="s0">, </span><span class="s2">92</span><span class="s0">, </span><span class="s2">110</span><span class="s0">, </span><span class="s2">114</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'func'</span><span class="s0">, </span><span class="s1">[convolve2d</span><span class="s0">, </span><span class="s1">correlate2d])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'boundary, expected'</span><span class="s0">,</span>
                             <span class="s1">[(</span><span class="s3">'symm'</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">37.0</span><span class="s0">, </span><span class="s2">42.0</span><span class="s0">, </span><span class="s2">44.0</span><span class="s0">, </span><span class="s2">45.0</span><span class="s1">]])</span><span class="s0">,</span>
                              <span class="s1">(</span><span class="s3">'wrap'</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">43.0</span><span class="s0">, </span><span class="s2">44.0</span><span class="s0">, </span><span class="s2">42.0</span><span class="s0">, </span><span class="s2">39.0</span><span class="s1">]])])</span>
    <span class="s0">def </span><span class="s1">test_same_with_boundary(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">boundary</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s4"># Test boundary='symm' and boundary='wrap' with a &quot;long&quot; kernel.</span>
        <span class="s4"># The size of the kernel requires that the values in the &quot;image&quot;</span>
        <span class="s4"># be extended more than once to handle the requested boundary method.</span>
        <span class="s4"># This is a regression test for gh-8684 and gh-8814.</span>
        <span class="s1">image = np.array([[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">4.0</span><span class="s1">]])</span>
        <span class="s1">kernel = np.ones((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">21</span><span class="s1">))</span>
        <span class="s1">result = func(image</span><span class="s0">, </span><span class="s1">kernel</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">boundary=boundary)</span>
        <span class="s4"># The expected results were calculated &quot;by hand&quot;.  Because the</span>
        <span class="s4"># kernel is all ones, the same result is expected for convolve2d</span>
        <span class="s4"># and correlate2d.</span>
        <span class="s1">assert_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_boundary_extension_same(self):</span>
        <span class="s4"># Regression test for gh-12686.</span>
        <span class="s4"># Use ndimage.convolve with appropriate arguments to create the</span>
        <span class="s4"># expected result.</span>
        <span class="s0">import </span><span class="s1">scipy.ndimage </span><span class="s0">as </span><span class="s1">ndi</span>
        <span class="s1">a = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">*</span><span class="s2">3</span><span class="s1">+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=float).reshape(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">b = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">*</span><span class="s2">10</span><span class="s1">+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=float).reshape(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">c = convolve2d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">boundary=</span><span class="s3">'wrap'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">ndi.convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'wrap'</span><span class="s0">, </span><span class="s1">origin=(-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)))</span>

    <span class="s0">def </span><span class="s1">test_boundary_extension_full(self):</span>
        <span class="s4"># Regression test for gh-12686.</span>
        <span class="s4"># Use ndimage.convolve with appropriate arguments to create the</span>
        <span class="s4"># expected result.</span>
        <span class="s0">import </span><span class="s1">scipy.ndimage </span><span class="s0">as </span><span class="s1">ndi</span>
        <span class="s1">a = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">*</span><span class="s2">3</span><span class="s1">+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=float).reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">b = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">*</span><span class="s2">6</span><span class="s1">+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=float).reshape(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">c = convolve2d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">boundary=</span><span class="s3">'wrap'</span><span class="s1">)</span>
        <span class="s1">apad = np.pad(a</span><span class="s0">, </span><span class="s1">((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span><span class="s0">, </span><span class="s3">'wrap'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">ndi.convolve(apad</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'wrap'</span><span class="s1">)[:-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_invalid_shapes(self):</span>
        <span class="s4"># By &quot;invalid,&quot; we mean that no one</span>
        <span class="s4"># array has dimensions that are all at</span>
        <span class="s4"># least as large as the corresponding</span>
        <span class="s4"># dimensions of the other array. This</span>
        <span class="s4"># setup should throw a ValueError.</span>
        <span class="s1">a = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s1">).reshape((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(-</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0</span><span class="s1">).reshape((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve2d</span><span class="s0">, </span><span class="s1">*(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">**{</span><span class="s3">'mode'</span><span class="s1">: </span><span class="s3">'valid'</span><span class="s1">})</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve2d</span><span class="s0">, </span><span class="s1">*(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">**{</span><span class="s3">'mode'</span><span class="s1">: </span><span class="s3">'valid'</span><span class="s1">})</span>


<span class="s0">class </span><span class="s1">TestConvolve2d(_TestConvolve2d):</span>

    <span class="s0">def </span><span class="s1">test_same_mode(self):</span>
        <span class="s1">e = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">f = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]]</span>
        <span class="s1">g = convolve2d(e</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span>
        <span class="s1">h = array([[</span><span class="s2">22</span><span class="s0">, </span><span class="s2">28</span><span class="s0">, </span><span class="s2">34</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">80</span><span class="s0">, </span><span class="s2">98</span><span class="s0">, </span><span class="s2">116</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(g</span><span class="s0">, </span><span class="s1">h)</span>

    <span class="s0">def </span><span class="s1">test_valid_mode2(self):</span>
        <span class="s4"># See gh-5897</span>
        <span class="s1">e = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">f = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]]</span>
        <span class="s1">expected = [[</span><span class="s2">62</span><span class="s0">, </span><span class="s2">80</span><span class="s0">, </span><span class="s2">98</span><span class="s0">, </span><span class="s2">116</span><span class="s0">, </span><span class="s2">134</span><span class="s1">]]</span>

        <span class="s1">out = convolve2d(e</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">out = convolve2d(f</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">e = [[</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">3j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">4 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s1">]]</span>
        <span class="s1">f = [[</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">4 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4 </span><span class="s1">- </span><span class="s2">0j</span><span class="s0">, </span><span class="s2">5 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">6 </span><span class="s1">- </span><span class="s2">3j</span><span class="s1">]]</span>
        <span class="s1">expected = [[</span><span class="s2">27 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">46. </span><span class="s1">+ </span><span class="s2">2j</span><span class="s1">]]</span>

        <span class="s1">out = convolve2d(e</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># See gh-5897</span>
        <span class="s1">out = convolve2d(f</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_consistency_convolve_funcs(self):</span>
        <span class="s4"># Compare np.convolve, signal.convolve, signal.convolve2d</span>
        <span class="s1">a = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s2">3.2</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">]:</span>
            <span class="s1">assert_almost_equal(np.convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode)</span><span class="s0">,</span>
                                <span class="s1">signal.convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode))</span>
            <span class="s1">assert_almost_equal(np.squeeze(</span>
                <span class="s1">signal.convolve2d([a]</span><span class="s0">, </span><span class="s1">[b]</span><span class="s0">, </span><span class="s1">mode=mode))</span><span class="s0">,</span>
                <span class="s1">signal.convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode))</span>

    <span class="s0">def </span><span class="s1">test_invalid_dims(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve2d</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve2d</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">convolve2d</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">3</span><span class="s1">]]]</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">4</span><span class="s1">]]])</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.xfail_on_32bit(</span><span class="s3">&quot;Can't create large array for test&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_large_array(self):</span>
        <span class="s4"># Test indexing doesn't overflow an int (gh-10761)</span>
        <span class="s1">n = </span><span class="s2">2</span><span class="s1">**</span><span class="s2">31 </span><span class="s1">// (</span><span class="s2">1000 </span><span class="s1">* np.int64().itemsize)</span>
        <span class="s1">_testutils.check_free_memory(</span><span class="s2">2 </span><span class="s1">* n * </span><span class="s2">1001 </span><span class="s1">* np.int64().itemsize / </span><span class="s2">1e6</span><span class="s1">)</span>

        <span class="s4"># Create a chequered pattern of 1s and 0s</span>
        <span class="s1">a = np.zeros(</span><span class="s2">1001 </span><span class="s1">* n</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s1">a[::</span><span class="s2">2</span><span class="s1">] = </span><span class="s2">1</span>
        <span class="s1">a = np.lib.stride_tricks.as_strided(a</span><span class="s0">, </span><span class="s1">shape=(n</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">strides=(</span><span class="s2">8008</span><span class="s0">, </span><span class="s2">8</span><span class="s1">))</span>

        <span class="s1">count = signal.convolve2d(a</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">fails = np.where(count &gt; </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">fails[</span><span class="s2">0</span><span class="s1">].size == </span><span class="s2">0</span>


<span class="s0">class </span><span class="s1">TestFFTConvolve:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">''</span><span class="s0">, None, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_real(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">9.</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes=axes)</span>

        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_real_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">9.</span><span class="s1">])</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">''</span><span class="s0">, None, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_complex(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">3j</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">8j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">20j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">24j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">18j</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_complex_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">3j</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">8j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">20j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">24j</span><span class="s0">, </span><span class="s2">0 </span><span class="s1">+ </span><span class="s2">18j</span><span class="s1">])</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">''</span><span class="s0">,</span>
                                      <span class="s0">None,</span>
                                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_2d_real_same(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]])</span>
        <span class="s1">expected = array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s2">26</span><span class="s0">, </span><span class="s2">56</span><span class="s0">, </span><span class="s2">54</span><span class="s0">, </span><span class="s2">36</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[</span><span class="s2">16</span><span class="s0">, </span><span class="s2">40</span><span class="s0">, </span><span class="s2">73</span><span class="s0">, </span><span class="s2">60</span><span class="s0">, </span><span class="s2">36</span><span class="s1">]])</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_2d_real_same_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]])</span>
        <span class="s1">expected = array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s2">26</span><span class="s0">, </span><span class="s2">56</span><span class="s0">, </span><span class="s2">54</span><span class="s0">, </span><span class="s2">36</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[</span><span class="s2">16</span><span class="s0">, </span><span class="s2">40</span><span class="s0">, </span><span class="s2">73</span><span class="s0">, </span><span class="s2">60</span><span class="s0">, </span><span class="s2">36</span><span class="s1">]])</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">''</span><span class="s0">,</span>
                                      <span class="s0">None,</span>
                                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_2d_complex_same(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([[</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">4j</span><span class="s0">, </span><span class="s2">5 </span><span class="s1">+ </span><span class="s2">6j</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">4 </span><span class="s1">+ </span><span class="s2">3j</span><span class="s0">, </span><span class="s2">6 </span><span class="s1">+ </span><span class="s2">5j</span><span class="s1">]])</span>
        <span class="s1">expected = array([</span>
            <span class="s1">[-</span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">4j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10 </span><span class="s1">+ </span><span class="s2">20j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">21 </span><span class="s1">+ </span><span class="s2">56j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">18 </span><span class="s1">+ </span><span class="s2">76j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">11 </span><span class="s1">+ </span><span class="s2">60j</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">10j</span><span class="s0">, </span><span class="s2">44j</span><span class="s0">, </span><span class="s2">118j</span><span class="s0">, </span><span class="s2">156j</span><span class="s0">, </span><span class="s2">122j</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">4j</span><span class="s0">, </span><span class="s2">10 </span><span class="s1">+ </span><span class="s2">20j</span><span class="s0">, </span><span class="s2">21 </span><span class="s1">+ </span><span class="s2">56j</span><span class="s0">, </span><span class="s2">18 </span><span class="s1">+ </span><span class="s2">76j</span><span class="s0">, </span><span class="s2">11 </span><span class="s1">+ </span><span class="s2">60j</span><span class="s1">]</span>
            <span class="s1">])</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes=axes)</span>

        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_2d_complex_same_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([[</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">4j</span><span class="s0">, </span><span class="s2">5 </span><span class="s1">+ </span><span class="s2">6j</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">4 </span><span class="s1">+ </span><span class="s2">3j</span><span class="s0">, </span><span class="s2">6 </span><span class="s1">+ </span><span class="s2">5j</span><span class="s1">]])</span>
        <span class="s1">expected = array([</span>
            <span class="s1">[-</span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">4j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10 </span><span class="s1">+ </span><span class="s2">20j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">21 </span><span class="s1">+ </span><span class="s2">56j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">18 </span><span class="s1">+ </span><span class="s2">76j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">11 </span><span class="s1">+ </span><span class="s2">60j</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">10j</span><span class="s0">, </span><span class="s2">44j</span><span class="s0">, </span><span class="s2">118j</span><span class="s0">, </span><span class="s2">156j</span><span class="s0">, </span><span class="s2">122j</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">4j</span><span class="s0">, </span><span class="s2">10 </span><span class="s1">+ </span><span class="s2">20j</span><span class="s0">, </span><span class="s2">21 </span><span class="s1">+ </span><span class="s2">56j</span><span class="s0">, </span><span class="s2">18 </span><span class="s1">+ </span><span class="s2">76j</span><span class="s0">, </span><span class="s2">11 </span><span class="s1">+ </span><span class="s2">60j</span><span class="s1">]</span>
            <span class="s1">])</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">''</span><span class="s0">, None, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_real_same_mode(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected_1 = array([</span><span class="s2">35.</span><span class="s0">, </span><span class="s2">41.</span><span class="s0">, </span><span class="s2">47.</span><span class="s1">])</span>
        <span class="s1">expected_2 = array([</span><span class="s2">9.</span><span class="s0">, </span><span class="s2">20.</span><span class="s0">, </span><span class="s2">25.</span><span class="s0">, </span><span class="s2">35.</span><span class="s0">, </span><span class="s2">41.</span><span class="s0">, </span><span class="s2">47.</span><span class="s0">, </span><span class="s2">39.</span><span class="s0">, </span><span class="s2">28.</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected_1)</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected_2)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_real_same_mode_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected_1 = array([</span><span class="s2">35.</span><span class="s0">, </span><span class="s2">41.</span><span class="s0">, </span><span class="s2">47.</span><span class="s1">])</span>
        <span class="s1">expected_2 = array([</span><span class="s2">9.</span><span class="s0">, </span><span class="s2">20.</span><span class="s0">, </span><span class="s2">25.</span><span class="s0">, </span><span class="s2">35.</span><span class="s0">, </span><span class="s2">41.</span><span class="s0">, </span><span class="s2">47.</span><span class="s0">, </span><span class="s2">39.</span><span class="s0">, </span><span class="s2">28.</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">])</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = np.tile(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected_1 = np.tile(expected_1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected_2 = np.tile(expected_2</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected_1)</span>

        <span class="s1">out = fftconvolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected_2)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">''</span><span class="s0">, None, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_valid_mode_real(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s4"># See gh-5897</span>
        <span class="s1">a = array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">24.</span><span class="s0">, </span><span class="s2">31.</span><span class="s0">, </span><span class="s2">41.</span><span class="s0">, </span><span class="s2">43.</span><span class="s0">, </span><span class="s2">49.</span><span class="s0">, </span><span class="s2">25.</span><span class="s0">, </span><span class="s2">12.</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_valid_mode_real_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s4"># See gh-5897</span>
        <span class="s1">a = array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">24.</span><span class="s0">, </span><span class="s2">31.</span><span class="s0">, </span><span class="s2">41.</span><span class="s0">, </span><span class="s2">43.</span><span class="s0">, </span><span class="s2">49.</span><span class="s0">, </span><span class="s2">25.</span><span class="s0">, </span><span class="s2">12.</span><span class="s1">])</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = np.tile(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">''</span><span class="s0">, None, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_valid_mode_complex(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([</span><span class="s2">3 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">7j</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">- </span><span class="s2">3j</span><span class="s0">, </span><span class="s2">5 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s0">, </span><span class="s2">6 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">8 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">45. </span><span class="s1">+ </span><span class="s2">12.j</span><span class="s0">, </span><span class="s2">30. </span><span class="s1">+ </span><span class="s2">23.j</span><span class="s0">, </span><span class="s2">48 </span><span class="s1">+ </span><span class="s2">32.j</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_valid_mode_complex_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a = array([</span><span class="s2">3 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">7j</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">- </span><span class="s2">3j</span><span class="s0">, </span><span class="s2">5 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s0">, </span><span class="s2">6 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">8 </span><span class="s1">+ </span><span class="s2">0j</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">45. </span><span class="s1">+ </span><span class="s2">12.j</span><span class="s0">, </span><span class="s2">30. </span><span class="s1">+ </span><span class="s2">23.j</span><span class="s0">, </span><span class="s2">48 </span><span class="s1">+ </span><span class="s2">32.j</span><span class="s1">])</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = np.tile(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">out = fftconvolve(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_valid_mode_ignore_nonaxes(self):</span>
        <span class="s4"># See gh-5897</span>
        <span class="s1">a = array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = array([</span><span class="s2">24.</span><span class="s0">, </span><span class="s2">31.</span><span class="s0">, </span><span class="s2">41.</span><span class="s0">, </span><span class="s2">43.</span><span class="s0">, </span><span class="s2">49.</span><span class="s0">, </span><span class="s2">25.</span><span class="s0">, </span><span class="s2">12.</span><span class="s1">])</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = np.tile(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s1">axes=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_empty(self):</span>
        <span class="s4"># Regression test for #1745: crashes with 0-length input.</span>
        <span class="s1">assert_(fftconvolve([]</span><span class="s0">, </span><span class="s1">[]).size == </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_(fftconvolve([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]).size == </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_(fftconvolve([]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s1">]).size == </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_rank(self):</span>
        <span class="s1">a = array(</span><span class="s2">4967</span><span class="s1">)</span>
        <span class="s1">b = array(</span><span class="s2">3920</span><span class="s1">)</span>
        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">a * b)</span>

    <span class="s0">def </span><span class="s1">test_single_element(self):</span>
        <span class="s1">a = array([</span><span class="s2">4967</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3920</span><span class="s1">])</span>
        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">a * b)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">''</span><span class="s0">, None, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_random_data(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">np.random.seed(</span><span class="s2">1234</span><span class="s1">)</span>
        <span class="s1">a = np.random.rand(</span><span class="s2">1233</span><span class="s1">) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(</span><span class="s2">1233</span><span class="s1">)</span>
        <span class="s1">b = np.random.rand(</span><span class="s2">1321</span><span class="s1">) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(</span><span class="s2">1321</span><span class="s1">)</span>
        <span class="s1">expected = np.convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">axes == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_(np.allclose(out</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_random_data_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">np.random.seed(</span><span class="s2">1234</span><span class="s1">)</span>
        <span class="s1">a = np.random.rand(</span><span class="s2">1233</span><span class="s1">) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(</span><span class="s2">1233</span><span class="s1">)</span>
        <span class="s1">b = np.random.rand(</span><span class="s2">1321</span><span class="s1">) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(</span><span class="s2">1321</span><span class="s1">)</span>
        <span class="s1">expected = np.convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>

        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = np.tile(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_(np.allclose(out</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_random_data_multidim_axes(self</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">a_shape</span><span class="s0">, </span><span class="s1">b_shape = (</span><span class="s2">123</span><span class="s0">, </span><span class="s2">22</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">132</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)</span>
        <span class="s1">np.random.seed(</span><span class="s2">1234</span><span class="s1">)</span>
        <span class="s1">a = np.random.rand(*a_shape) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(*a_shape)</span>
        <span class="s1">b = np.random.rand(*b_shape) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(*b_shape)</span>
        <span class="s1">expected = convolve2d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>

        <span class="s1">a = a[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, None, None, None</span><span class="s1">]</span>
        <span class="s1">b = b[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, None, None, None</span><span class="s1">]</span>
        <span class="s1">expected = expected[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, None, None, None</span><span class="s1">]</span>

        <span class="s1">a = np.moveaxis(a.swapaxes(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">b = np.moveaxis(b.swapaxes(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">expected = np.moveaxis(expected.swapaxes(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>

        <span class="s4"># use 1 for dimension 2 in a and 3 in b to test broadcasting</span>
        <span class="s1">a = np.tile(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = np.tile(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">expected = np.tile(expected</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">axes=axes)</span>
        <span class="s1">assert_allclose(out</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-10</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">'n'</span><span class="s0">,</span>
        <span class="s1">list(range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)) +</span>
        <span class="s1">list(range(</span><span class="s2">1000</span><span class="s0">, </span><span class="s2">1500</span><span class="s1">)) +</span>
        <span class="s1">np.random.RandomState(</span><span class="s2">1234</span><span class="s1">).randint(</span><span class="s2">1001</span><span class="s0">, </span><span class="s2">10000</span><span class="s0">, </span><span class="s2">5</span><span class="s1">).tolist())</span>
    <span class="s0">def </span><span class="s1">test_many_sizes(self</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s1">a = np.random.rand(n) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(n)</span>
        <span class="s1">b = np.random.rand(n) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(n)</span>
        <span class="s1">expected = np.convolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(out</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-10</span><span class="s1">)</span>

        <span class="s1">out = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_allclose(out</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_fft_nan(self):</span>
        <span class="s1">n = </span><span class="s2">1000</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s2">43876432987</span><span class="s1">)</span>
        <span class="s1">sig_nan = rng.standard_normal(n)</span>

        <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.inf]:</span>
            <span class="s1">sig_nan[</span><span class="s2">100</span><span class="s1">] = val</span>
            <span class="s1">coeffs = signal.firwin(</span><span class="s2">200</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">)</span>

            <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Use of fft convolution&quot;</span><span class="s1">):</span>
                <span class="s1">signal.convolve(sig_nan</span><span class="s0">, </span><span class="s1">coeffs</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">fftconvolve_err(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s3">'Fell back to fftconvolve'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">gen_oa_shapes(sizes):</span>
    <span class="s0">return </span><span class="s1">[(a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">product(sizes</span><span class="s0">, </span><span class="s1">repeat=</span><span class="s2">2</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">abs(a - b) &gt; </span><span class="s2">3</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">gen_oa_shapes_2d(sizes):</span>
    <span class="s1">shapes0 = gen_oa_shapes(sizes)</span>
    <span class="s1">shapes1 = gen_oa_shapes(sizes)</span>
    <span class="s1">shapes = [ishapes0+ishapes1 </span><span class="s0">for </span><span class="s1">ishapes0</span><span class="s0">, </span><span class="s1">ishapes1 </span><span class="s0">in</span>
              <span class="s1">zip(shapes0</span><span class="s0">, </span><span class="s1">shapes1)]</span>

    <span class="s1">modes = [</span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">[ishapes+(imode</span><span class="s0">,</span><span class="s1">) </span><span class="s0">for </span><span class="s1">ishapes</span><span class="s0">, </span><span class="s1">imode </span><span class="s0">in </span><span class="s1">product(shapes</span><span class="s0">, </span><span class="s1">modes)</span>
            <span class="s0">if </span><span class="s1">imode != </span><span class="s3">'valid' </span><span class="s0">or</span>
            <span class="s1">(ishapes[</span><span class="s2">0</span><span class="s1">] &gt; ishapes[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">and </span><span class="s1">ishapes[</span><span class="s2">2</span><span class="s1">] &gt; ishapes[</span><span class="s2">3</span><span class="s1">]) </span><span class="s0">or</span>
            <span class="s1">(ishapes[</span><span class="s2">0</span><span class="s1">] &lt; ishapes[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">and </span><span class="s1">ishapes[</span><span class="s2">2</span><span class="s1">] &lt; ishapes[</span><span class="s2">3</span><span class="s1">])]</span>


<span class="s0">def </span><span class="s1">gen_oa_shapes_eq(sizes):</span>
    <span class="s0">return </span><span class="s1">[(a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">product(sizes</span><span class="s0">, </span><span class="s1">repeat=</span><span class="s2">2</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">a &gt;= b]</span>


<span class="s0">class </span><span class="s1">TestOAConvolve:</span>
    <span class="s1">@pytest.mark.slow()</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_a_0, shape_b_0'</span><span class="s0">,</span>
                             <span class="s1">gen_oa_shapes_eq(list(range(</span><span class="s2">100</span><span class="s1">)) +</span>
                                              <span class="s1">list(range(</span><span class="s2">100</span><span class="s0">, </span><span class="s2">1000</span><span class="s0">, </span><span class="s2">23</span><span class="s1">)))</span>
                             <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_real_manylens(self</span><span class="s0">, </span><span class="s1">shape_a_0</span><span class="s0">, </span><span class="s1">shape_b_0):</span>
        <span class="s1">a = np.random.rand(shape_a_0)</span>
        <span class="s1">b = np.random.rand(shape_b_0)</span>

        <span class="s1">expected = fftconvolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">out = oaconvolve(a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_a_0, shape_b_0'</span><span class="s0">,</span>
                             <span class="s1">gen_oa_shapes([</span><span class="s2">50</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'is_complex'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'mode'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_1d_noaxes(self</span><span class="s0">, </span><span class="s1">shape_a_0</span><span class="s0">, </span><span class="s1">shape_b_0</span><span class="s0">,</span>
                       <span class="s1">is_complex</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s1">a = np.random.rand(shape_a_0)</span>
        <span class="s1">b = np.random.rand(shape_b_0)</span>
        <span class="s0">if </span><span class="s1">is_complex:</span>
            <span class="s1">a = a + </span><span class="s2">1j</span><span class="s1">*np.random.rand(shape_a_0)</span>
            <span class="s1">b = b + </span><span class="s2">1j</span><span class="s1">*np.random.rand(shape_b_0)</span>

        <span class="s1">expected = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode)</span>

        <span class="s1">monkeypatch.setattr(signal._signaltools</span><span class="s0">, </span><span class="s3">'fftconvolve'</span><span class="s0">,</span>
                            <span class="s1">fftconvolve_err)</span>
        <span class="s1">out = oaconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode)</span>

        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_a_0, shape_b_0'</span><span class="s0">,</span>
                             <span class="s1">gen_oa_shapes([</span><span class="s2">50</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_a_extra'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_b_extra'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'is_complex'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'mode'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_1d_axes(self</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">shape_a_0</span><span class="s0">, </span><span class="s1">shape_b_0</span><span class="s0">,</span>
                     <span class="s1">shape_a_extra</span><span class="s0">, </span><span class="s1">shape_b_extra</span><span class="s0">,</span>
                     <span class="s1">is_complex</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s1">ax_a = [shape_a_extra]*</span><span class="s2">2</span>
        <span class="s1">ax_b = [shape_b_extra]*</span><span class="s2">2</span>
        <span class="s1">ax_a[axes] = shape_a_0</span>
        <span class="s1">ax_b[axes] = shape_b_0</span>

        <span class="s1">a = np.random.rand(*ax_a)</span>
        <span class="s1">b = np.random.rand(*ax_b)</span>
        <span class="s0">if </span><span class="s1">is_complex:</span>
            <span class="s1">a = a + </span><span class="s2">1j</span><span class="s1">*np.random.rand(*ax_a)</span>
            <span class="s1">b = b + </span><span class="s2">1j</span><span class="s1">*np.random.rand(*ax_b)</span>

        <span class="s1">expected = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode</span><span class="s0">, </span><span class="s1">axes=axes)</span>

        <span class="s1">monkeypatch.setattr(signal._signaltools</span><span class="s0">, </span><span class="s3">'fftconvolve'</span><span class="s0">,</span>
                            <span class="s1">fftconvolve_err)</span>
        <span class="s1">out = oaconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode</span><span class="s0">, </span><span class="s1">axes=axes)</span>

        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_a_0, shape_b_0, '</span>
                             <span class="s3">'shape_a_1, shape_b_1, mode'</span><span class="s0">,</span>
                             <span class="s1">gen_oa_shapes_2d([</span><span class="s2">50</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'is_complex'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_2d_noaxes(self</span><span class="s0">, </span><span class="s1">shape_a_0</span><span class="s0">, </span><span class="s1">shape_b_0</span><span class="s0">,</span>
                       <span class="s1">shape_a_1</span><span class="s0">, </span><span class="s1">shape_b_1</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">,</span>
                       <span class="s1">is_complex</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s1">a = np.random.rand(shape_a_0</span><span class="s0">, </span><span class="s1">shape_a_1)</span>
        <span class="s1">b = np.random.rand(shape_b_0</span><span class="s0">, </span><span class="s1">shape_b_1)</span>
        <span class="s0">if </span><span class="s1">is_complex:</span>
            <span class="s1">a = a + </span><span class="s2">1j</span><span class="s1">*np.random.rand(shape_a_0</span><span class="s0">, </span><span class="s1">shape_a_1)</span>
            <span class="s1">b = b + </span><span class="s2">1j</span><span class="s1">*np.random.rand(shape_b_0</span><span class="s0">, </span><span class="s1">shape_b_1)</span>

        <span class="s1">expected = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode)</span>

        <span class="s1">monkeypatch.setattr(signal._signaltools</span><span class="s0">, </span><span class="s3">'fftconvolve'</span><span class="s0">,</span>
                            <span class="s1">fftconvolve_err)</span>
        <span class="s1">out = oaconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode)</span>

        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_a_0, shape_b_0, '</span>
                             <span class="s3">'shape_a_1, shape_b_1, mode'</span><span class="s0">,</span>
                             <span class="s1">gen_oa_shapes_2d([</span><span class="s2">50</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_a_extra'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'shape_b_extra'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'is_complex'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_2d_axes(self</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">shape_a_0</span><span class="s0">, </span><span class="s1">shape_b_0</span><span class="s0">,</span>
                     <span class="s1">shape_a_1</span><span class="s0">, </span><span class="s1">shape_b_1</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">,</span>
                     <span class="s1">shape_a_extra</span><span class="s0">, </span><span class="s1">shape_b_extra</span><span class="s0">,</span>
                     <span class="s1">is_complex</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s1">ax_a = [shape_a_extra]*</span><span class="s2">3</span>
        <span class="s1">ax_b = [shape_b_extra]*</span><span class="s2">3</span>
        <span class="s1">ax_a[axes[</span><span class="s2">0</span><span class="s1">]] = shape_a_0</span>
        <span class="s1">ax_b[axes[</span><span class="s2">0</span><span class="s1">]] = shape_b_0</span>
        <span class="s1">ax_a[axes[</span><span class="s2">1</span><span class="s1">]] = shape_a_1</span>
        <span class="s1">ax_b[axes[</span><span class="s2">1</span><span class="s1">]] = shape_b_1</span>

        <span class="s1">a = np.random.rand(*ax_a)</span>
        <span class="s1">b = np.random.rand(*ax_b)</span>
        <span class="s0">if </span><span class="s1">is_complex:</span>
            <span class="s1">a = a + </span><span class="s2">1j</span><span class="s1">*np.random.rand(*ax_a)</span>
            <span class="s1">b = b + </span><span class="s2">1j</span><span class="s1">*np.random.rand(*ax_b)</span>

        <span class="s1">expected = fftconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode</span><span class="s0">, </span><span class="s1">axes=axes)</span>

        <span class="s1">monkeypatch.setattr(signal._signaltools</span><span class="s0">, </span><span class="s3">'fftconvolve'</span><span class="s0">,</span>
                            <span class="s1">fftconvolve_err)</span>
        <span class="s1">out = oaconvolve(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode</span><span class="s0">, </span><span class="s1">axes=axes)</span>

        <span class="s1">assert_array_almost_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_empty(self):</span>
        <span class="s4"># Regression test for #1745: crashes with 0-length input.</span>
        <span class="s1">assert_(oaconvolve([]</span><span class="s0">, </span><span class="s1">[]).size == </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_(oaconvolve([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]).size == </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_(oaconvolve([]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s1">]).size == </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_rank(self):</span>
        <span class="s1">a = array(</span><span class="s2">4967</span><span class="s1">)</span>
        <span class="s1">b = array(</span><span class="s2">3920</span><span class="s1">)</span>
        <span class="s1">out = oaconvolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">a * b)</span>

    <span class="s0">def </span><span class="s1">test_single_element(self):</span>
        <span class="s1">a = array([</span><span class="s2">4967</span><span class="s1">])</span>
        <span class="s1">b = array([</span><span class="s2">3920</span><span class="s1">])</span>
        <span class="s1">out = oaconvolve(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">a * b)</span>


<span class="s0">class </span><span class="s1">TestAllFreqConvolves:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'convapproach'</span><span class="s0">,</span>
                             <span class="s1">[fftconvolve</span><span class="s0">, </span><span class="s1">oaconvolve])</span>
    <span class="s0">def </span><span class="s1">test_invalid_shapes(self</span><span class="s0">, </span><span class="s1">convapproach):</span>
        <span class="s1">a = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s1">).reshape((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(-</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0</span><span class="s1">).reshape((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;For 'valid' mode, one must be at least &quot;</span>
                           <span class="s3">&quot;as large as the other in every dimension&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'valid'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'convapproach'</span><span class="s0">,</span>
                             <span class="s1">[fftconvolve</span><span class="s0">, </span><span class="s1">oaconvolve])</span>
    <span class="s0">def </span><span class="s1">test_invalid_shapes_axes(self</span><span class="s0">, </span><span class="s1">convapproach):</span>
        <span class="s1">a = np.zeros([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = np.zeros([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">r&quot;incompatible shapes for in1 and in2:&quot;</span>
                           <span class="s3">r&quot; \(5L?, 6L?, 2L?, 1L?\) and&quot;</span>
                           <span class="s3">r&quot; \(5L?, 6L?, 3L?, 1L?\)&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'a,b'</span><span class="s0">,</span>
                             <span class="s1">[([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">])</span><span class="s0">,</span>
                              <span class="s1">([</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">2</span><span class="s1">]])])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'convapproach'</span><span class="s0">,</span>
                             <span class="s1">[fftconvolve</span><span class="s0">, </span><span class="s1">oaconvolve])</span>
    <span class="s0">def </span><span class="s1">test_mismatched_dims(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">convapproach):</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;in1 and in2 should have the same&quot;</span>
                           <span class="s3">&quot; dimensionality&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'convapproach'</span><span class="s0">,</span>
                             <span class="s1">[fftconvolve</span><span class="s0">, </span><span class="s1">oaconvolve])</span>
    <span class="s0">def </span><span class="s1">test_invalid_flags(self</span><span class="s0">, </span><span class="s1">convapproach):</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;acceptable mode flags are 'valid',&quot;</span>
                           <span class="s3">&quot; 'same', or 'full'&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'chips'</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;when provided, axes cannot be empty&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=[])</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;axes must be a scalar or &quot;</span>
                           <span class="s3">&quot;iterable of integers&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]])</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;axes must be a scalar or &quot;</span>
                           <span class="s3">&quot;iterable of integers&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">2.</span><span class="s0">, </span><span class="s2">3.</span><span class="s0">, </span><span class="s2">4.</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;axes exceeds dimensionality of input&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;axes exceeds dimensionality of input&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s2">2</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;all axes must be unique&quot;</span><span class="s1">):</span>
            <span class="s1">convapproach([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s0">, </span><span class="s1">[np.longfloat</span><span class="s0">, </span><span class="s1">np.longcomplex])</span>
    <span class="s0">def </span><span class="s1">test_longdtype_input(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.random.random((</span><span class="s2">27</span><span class="s0">, </span><span class="s2">27</span><span class="s1">)).astype(dtype)</span>
        <span class="s1">y = np.random.random((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)).astype(dtype)</span>
        <span class="s0">if </span><span class="s1">np.iscomplexobj(dtype()):</span>
            <span class="s1">x += </span><span class="s2">.1j</span>
            <span class="s1">y -= </span><span class="s2">.1j</span>

        <span class="s1">res = fftconvolve(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">convolve(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">res.dtype == dtype</span>


<span class="s0">class </span><span class="s1">TestMedFilt:</span>

    <span class="s1">IN = [[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">92</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">27</span><span class="s0">, </span><span class="s2">65</span><span class="s0">, </span><span class="s2">46</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">72</span><span class="s0">, </span><span class="s2">77</span><span class="s0">, </span><span class="s2">68</span><span class="s0">, </span><span class="s2">66</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">19</span><span class="s0">, </span><span class="s2">64</span><span class="s0">, </span><span class="s2">77</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">42</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">29</span><span class="s0">, </span><span class="s2">95</span><span class="s0">, </span><span class="s2">35</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">34</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">66</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">70</span><span class="s0">, </span><span class="s2">97</span><span class="s0">, </span><span class="s2">28</span><span class="s0">, </span><span class="s2">68</span><span class="s0">, </span><span class="s2">78</span><span class="s0">, </span><span class="s2">77</span><span class="s0">, </span><span class="s2">61</span><span class="s0">, </span><span class="s2">58</span><span class="s0">, </span><span class="s2">71</span><span class="s0">, </span><span class="s2">42</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">64</span><span class="s0">, </span><span class="s2">53</span><span class="s0">, </span><span class="s2">44</span><span class="s0">, </span><span class="s2">29</span><span class="s0">, </span><span class="s2">68</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">19</span><span class="s0">, </span><span class="s2">68</span><span class="s0">, </span><span class="s2">24</span><span class="s0">, </span><span class="s2">84</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">33</span><span class="s0">, </span><span class="s2">53</span><span class="s0">, </span><span class="s2">67</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">78</span><span class="s0">, </span><span class="s2">74</span><span class="s0">, </span><span class="s2">55</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">83</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">70</span><span class="s0">, </span><span class="s2">60</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">24</span><span class="s0">, </span><span class="s2">43</span><span class="s0">, </span><span class="s2">61</span><span class="s0">, </span><span class="s2">26</span><span class="s1">]</span><span class="s0">,</span>
          <span class="s1">[</span><span class="s2">32</span><span class="s0">, </span><span class="s2">61</span><span class="s0">, </span><span class="s2">88</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">39</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">92</span><span class="s0">, </span><span class="s2">64</span><span class="s0">, </span><span class="s2">45</span><span class="s0">, </span><span class="s2">61</span><span class="s1">]]</span>

    <span class="s1">OUT = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">42</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">27</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">42</span><span class="s0">, </span><span class="s2">19</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">29</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">34</span><span class="s0">, </span><span class="s2">34</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">35</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">42</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">64</span><span class="s0">, </span><span class="s2">42</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">55</span><span class="s0">, </span><span class="s2">64</span><span class="s0">, </span><span class="s2">35</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">33</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">43</span><span class="s0">, </span><span class="s2">55</span><span class="s0">, </span><span class="s2">26</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">32</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">45</span><span class="s0">, </span><span class="s2">55</span><span class="s0">, </span><span class="s2">26</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">47</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">46</span><span class="s0">, </span><span class="s2">43</span><span class="s0">, </span><span class="s2">45</span><span class="s0">, </span><span class="s2">21</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">33</span><span class="s0">, </span><span class="s2">39</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">43</span><span class="s0">, </span><span class="s2">43</span><span class="s0">, </span><span class="s2">43</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">19</span><span class="s0">, </span><span class="s2">19</span><span class="s0">, </span><span class="s2">24</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span>

    <span class="s1">KERNEL_SIZE = [</span><span class="s2">7</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">d = signal.medfilt(self.IN</span><span class="s0">, </span><span class="s1">self.KERNEL_SIZE)</span>
        <span class="s1">e = signal.medfilt2d(np.array(self.IN</span><span class="s0">, </span><span class="s1">float)</span><span class="s0">, </span><span class="s1">self.KERNEL_SIZE)</span>
        <span class="s1">assert_array_equal(d</span><span class="s0">, </span><span class="s1">self.OUT)</span>
        <span class="s1">assert_array_equal(d</span><span class="s0">, </span><span class="s1">e)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s0">, </span><span class="s1">[np.ubyte</span><span class="s0">, </span><span class="s1">np.byte</span><span class="s0">, </span><span class="s1">np.ushort</span><span class="s0">, </span><span class="s1">np.short</span><span class="s0">,</span>
                                       <span class="s1">np.uint</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">np.ulonglong</span><span class="s0">, </span><span class="s1">np.ulonglong</span><span class="s0">,</span>
                                       <span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_types(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s4"># volume input and output types match</span>
        <span class="s1">in_typed = np.array(self.IN</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(signal.medfilt(in_typed).dtype</span><span class="s0">, </span><span class="s1">dtype)</span>
        <span class="s1">assert_equal(signal.medfilt2d(in_typed).dtype</span><span class="s0">, </span><span class="s1">dtype)</span>

    <span class="s0">def </span><span class="s1">test_types_deprecated(self):</span>
        <span class="s1">dtype = np.longdouble</span>
        <span class="s1">in_typed = np.array(self.IN</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">msg = </span><span class="s3">&quot;Using medfilt with arrays of dtype&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.deprecated_call(match=msg):</span>
            <span class="s1">assert_equal(signal.medfilt(in_typed).dtype</span><span class="s0">, </span><span class="s1">dtype)</span>
        <span class="s0">with </span><span class="s1">pytest.deprecated_call(match=msg):</span>
            <span class="s1">assert_equal(signal.medfilt2d(in_typed).dtype</span><span class="s0">, </span><span class="s1">dtype)</span>


    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s0">, </span><span class="s1">[np.bool_</span><span class="s0">, </span><span class="s1">np.cfloat</span><span class="s0">, </span><span class="s1">np.cdouble</span><span class="s0">,</span>
                                       <span class="s1">np.clongdouble</span><span class="s0">, </span><span class="s1">np.float16</span><span class="s0">,</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_invalid_dtypes(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">in_typed = np.array(self.IN</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;not supported&quot;</span><span class="s1">):</span>
            <span class="s1">signal.medfilt(in_typed)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;not supported&quot;</span><span class="s1">):</span>
            <span class="s1">signal.medfilt2d(in_typed)</span>

    <span class="s0">def </span><span class="s1">test_none(self):</span>
        <span class="s4"># gh-1651, trac #1124. Ensure this does not segfault.</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning):</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">signal.medfilt</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s4"># Expand on this test to avoid a regression with possible contiguous</span>
        <span class="s4"># numpy arrays that have odd strides. The stride value below gets</span>
        <span class="s4"># us into wrong memory if used (but it does not need to be used)</span>
        <span class="s1">dummy = np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">a = dummy[</span><span class="s2">5</span><span class="s1">:</span><span class="s2">6</span><span class="s1">]</span>
        <span class="s1">a.strides = </span><span class="s2">16</span>
        <span class="s1">assert_(signal.medfilt(a</span><span class="s0">, </span><span class="s2">1</span><span class="s1">) == </span><span class="s2">5.</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_refcounting(self):</span>
        <span class="s4"># Check a refcounting-related crash</span>
        <span class="s1">a = Decimal(</span><span class="s2">123</span><span class="s1">)</span>
        <span class="s1">x = np.array([a</span><span class="s0">, </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s0">if </span><span class="s1">hasattr(sys</span><span class="s0">, </span><span class="s3">'getrefcount'</span><span class="s1">):</span>
            <span class="s1">n = </span><span class="s2">2 </span><span class="s1">* sys.getrefcount(a)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">n = </span><span class="s2">10</span>
        <span class="s4"># Shouldn't segfault:</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(n):</span>
                <span class="s1">signal.medfilt(x)</span>
        <span class="s0">if </span><span class="s1">hasattr(sys</span><span class="s0">, </span><span class="s3">'getrefcount'</span><span class="s1">):</span>
            <span class="s1">assert_(sys.getrefcount(a) &lt; n)</span>
        <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">[a</span><span class="s0">, </span><span class="s1">a])</span>

    <span class="s0">def </span><span class="s1">test_object(self</span><span class="s0">,</span><span class="s1">):</span>
        <span class="s1">msg = </span><span class="s3">&quot;Using medfilt with arrays of dtype&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.deprecated_call(match=msg):</span>
            <span class="s1">in_object = np.array(self.IN</span><span class="s0">, </span><span class="s1">dtype=object)</span>
            <span class="s1">out_object = np.array(self.OUT</span><span class="s0">, </span><span class="s1">dtype=object)</span>
            <span class="s1">assert_array_equal(signal.medfilt(in_object</span><span class="s0">, </span><span class="s1">self.KERNEL_SIZE)</span><span class="s0">,</span>
                               <span class="s1">out_object)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[np.ubyte</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_medfilt2d_parallel(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">in_typed = np.array(self.IN</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">expected = np.array(self.OUT</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

        <span class="s4"># This is used to simplify the indexing calculations.</span>
        <span class="s0">assert </span><span class="s1">in_typed.shape == expected.shape</span>

        <span class="s4"># We'll do the calculation in four chunks. M1 and N1 are the dimensions</span>
        <span class="s4"># of the first output chunk. We have to extend the input by half the</span>
        <span class="s4"># kernel size to be able to calculate the full output chunk.</span>
        <span class="s1">M1 = expected.shape[</span><span class="s2">0</span><span class="s1">] // </span><span class="s2">2</span>
        <span class="s1">N1 = expected.shape[</span><span class="s2">1</span><span class="s1">] // </span><span class="s2">2</span>
        <span class="s1">offM = self.KERNEL_SIZE[</span><span class="s2">0</span><span class="s1">] // </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1</span>
        <span class="s1">offN = self.KERNEL_SIZE[</span><span class="s2">1</span><span class="s1">] // </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1</span>

        <span class="s0">def </span><span class="s1">apply(chunk):</span>
            <span class="s4"># in = slice of in_typed to use.</span>
            <span class="s4"># sel = slice of output to crop it to the correct region.</span>
            <span class="s4"># out = slice of output array to store in.</span>
            <span class="s1">M</span><span class="s0">, </span><span class="s1">N = chunk</span>
            <span class="s0">if </span><span class="s1">M == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">Min = slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">M1 + offM)</span>
                <span class="s1">Msel = slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-offM)</span>
                <span class="s1">Mout = slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">M1)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">Min = slice(M1 - offM</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">Msel = slice(offM</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">Mout = slice(M1</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">N == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">Nin = slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">N1 + offN)</span>
                <span class="s1">Nsel = slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-offN)</span>
                <span class="s1">Nout = slice(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">N1)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">Nin = slice(N1 - offN</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">Nsel = slice(offN</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">Nout = slice(N1</span><span class="s0">, None</span><span class="s1">)</span>

            <span class="s4"># Do the calculation, but do not write to the output in the threads.</span>
            <span class="s1">chunk_data = in_typed[Min</span><span class="s0">, </span><span class="s1">Nin]</span>
            <span class="s1">med = signal.medfilt2d(chunk_data</span><span class="s0">, </span><span class="s1">self.KERNEL_SIZE)</span>
            <span class="s0">return </span><span class="s1">med[Msel</span><span class="s0">, </span><span class="s1">Nsel]</span><span class="s0">, </span><span class="s1">Mout</span><span class="s0">, </span><span class="s1">Nout</span>

        <span class="s4"># Give each chunk to a different thread.</span>
        <span class="s1">output = np.zeros_like(expected)</span>
        <span class="s0">with </span><span class="s1">ThreadPoolExecutor(max_workers=</span><span class="s2">4</span><span class="s1">) </span><span class="s0">as </span><span class="s1">pool:</span>
            <span class="s1">chunks = {(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)}</span>
            <span class="s1">futures = {pool.submit(apply</span><span class="s0">, </span><span class="s1">chunk) </span><span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">chunks}</span>

            <span class="s4"># Store each result in the output as it arrives.</span>
            <span class="s0">for </span><span class="s1">future </span><span class="s0">in </span><span class="s1">as_completed(futures):</span>
                <span class="s1">data</span><span class="s0">, </span><span class="s1">Mslice</span><span class="s0">, </span><span class="s1">Nslice = future.result()</span>
                <span class="s1">output[Mslice</span><span class="s0">, </span><span class="s1">Nslice] = data</span>

        <span class="s1">assert_array_equal(output</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestWiener:</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">g = array([[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]]</span><span class="s0">, </span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s1">h = array([[</span><span class="s2">2.16374269</span><span class="s0">, </span><span class="s2">3.2222222222</span><span class="s0">, </span><span class="s2">2.8888888889</span><span class="s0">, </span><span class="s2">1.6666666667</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">2.666666667</span><span class="s0">, </span><span class="s2">4.33333333333</span><span class="s0">, </span><span class="s2">4.44444444444</span><span class="s0">, </span><span class="s2">2.8888888888</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">2.222222222</span><span class="s0">, </span><span class="s2">4.4444444444</span><span class="s0">, </span><span class="s2">5.4444444444</span><span class="s0">, </span><span class="s2">4.801066874837</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">[</span><span class="s2">1.33333333333</span><span class="s0">, </span><span class="s2">3.92735042735</span><span class="s0">, </span><span class="s2">6.0712560386</span><span class="s0">, </span><span class="s2">5.0404040404</span><span class="s1">]])</span>
        <span class="s1">assert_array_almost_equal(signal.wiener(g)</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(signal.wiener(g</span><span class="s0">, </span><span class="s1">mysize=</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">6</span><span class="s1">)</span>


<span class="s1">padtype_options = [</span><span class="s3">&quot;mean&quot;</span><span class="s0">, </span><span class="s3">&quot;median&quot;</span><span class="s0">, </span><span class="s3">&quot;minimum&quot;</span><span class="s0">, </span><span class="s3">&quot;maximum&quot;</span><span class="s0">, </span><span class="s3">&quot;line&quot;</span><span class="s1">]</span>
<span class="s1">padtype_options += _upfirdn_modes</span>


<span class="s0">class </span><span class="s1">TestResample:</span>
    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s4"># Some basic tests</span>

        <span class="s4"># Regression test for issue #3603.</span>
        <span class="s4"># window.shape must equal to sig.shape[0]</span>
        <span class="s1">sig = np.arange(</span><span class="s2">128</span><span class="s1">)</span>
        <span class="s1">num = </span><span class="s2">256</span>
        <span class="s1">win = signal.get_window((</span><span class="s3">'kaiser'</span><span class="s0">, </span><span class="s2">8.0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">160</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">signal.resample</span><span class="s0">, </span><span class="s1">sig</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">window=win)</span>

        <span class="s4"># Other degenerate conditions</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">signal.resample_poly</span><span class="s0">, </span><span class="s1">sig</span><span class="s0">, </span><span class="s3">'yo'</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">signal.resample_poly</span><span class="s0">, </span><span class="s1">sig</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">signal.resample_poly</span><span class="s0">, </span><span class="s1">sig</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">padtype=</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">signal.resample_poly</span><span class="s0">, </span><span class="s1">sig</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">,</span>
                      <span class="s1">padtype=</span><span class="s3">'mean'</span><span class="s0">, </span><span class="s1">cval=</span><span class="s2">10</span><span class="s1">)</span>

        <span class="s4"># test for issue #6505 - should not modify window.shape when axis ≠ 0</span>
        <span class="s1">sig2 = np.tile(np.arange(</span><span class="s2">160</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">signal.resample(sig2</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">window=win)</span>
        <span class="s1">assert_(win.shape == (</span><span class="s2">160</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'window'</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, </span><span class="s3">'hamming'</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'N'</span><span class="s0">, </span><span class="s1">(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">19</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'num'</span><span class="s0">, </span><span class="s1">(</span><span class="s2">100</span><span class="s0">, </span><span class="s2">101</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_rfft(self</span><span class="s0">, </span><span class="s1">N</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">window):</span>
        <span class="s4"># Make sure the speed up using rfft gives the same result as the normal</span>
        <span class="s4"># way using fft</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">N</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">y = np.cos(-x**</span><span class="s2">2</span><span class="s1">/</span><span class="s2">6.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(signal.resample(y</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">window=window)</span><span class="s0">,</span>
                        <span class="s1">signal.resample(y + </span><span class="s2">0j</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">window=window).real)</span>

        <span class="s1">y = np.array([np.cos(-x**</span><span class="s2">2</span><span class="s1">/</span><span class="s2">6.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.sin(-x**</span><span class="s2">2</span><span class="s1">/</span><span class="s2">6.0</span><span class="s1">)])</span>
        <span class="s1">y_complex = y + </span><span class="s2">0j</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">signal.resample(y</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">window=window)</span><span class="s0">,</span>
            <span class="s1">signal.resample(y_complex</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">window=window).real</span><span class="s0">,</span>
            <span class="s1">atol=</span><span class="s2">1e-9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_input_domain(self):</span>
        <span class="s4"># Test if both input domain modes produce the same results.</span>
        <span class="s1">tsig = np.arange(</span><span class="s2">256</span><span class="s1">) + </span><span class="s2">0j</span>
        <span class="s1">fsig = fft(tsig)</span>
        <span class="s1">num = </span><span class="s2">256</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">signal.resample(fsig</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">domain=</span><span class="s3">'freq'</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">signal.resample(tsig</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">domain=</span><span class="s3">'time'</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">atol=</span><span class="s2">1e-9</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'nx'</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">8</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'ny'</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">8</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'float'</span><span class="s0">, </span><span class="s3">'complex'</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_dc(self</span><span class="s0">, </span><span class="s1">nx</span><span class="s0">, </span><span class="s1">ny</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([</span><span class="s2">1</span><span class="s1">] * nx</span><span class="s0">, </span><span class="s1">dtype)</span>
        <span class="s1">y = signal.resample(x</span><span class="s0">, </span><span class="s1">ny)</span>
        <span class="s1">assert_allclose(y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">] * ny)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'padtype'</span><span class="s0">, </span><span class="s1">padtype_options)</span>
    <span class="s0">def </span><span class="s1">test_mutable_window(self</span><span class="s0">, </span><span class="s1">padtype):</span>
        <span class="s4"># Test that a mutable window is not modified</span>
        <span class="s1">impulse = np.zeros(</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">window = np.random.RandomState(</span><span class="s2">0</span><span class="s1">).randn(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">window_orig = window.copy()</span>
        <span class="s1">signal.resample_poly(impulse</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">window=window</span><span class="s0">, </span><span class="s1">padtype=padtype)</span>
        <span class="s1">assert_array_equal(window</span><span class="s0">, </span><span class="s1">window_orig)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'padtype'</span><span class="s0">, </span><span class="s1">padtype_options)</span>
    <span class="s0">def </span><span class="s1">test_output_float32(self</span><span class="s0">, </span><span class="s1">padtype):</span>
        <span class="s4"># Test that float32 inputs yield a float32 output</span>
        <span class="s1">x = np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">h = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">y = signal.resample_poly(x</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">window=h</span><span class="s0">, </span><span class="s1">padtype=padtype)</span>
        <span class="s0">assert </span><span class="s1">y.dtype == np.float32</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'padtype'</span><span class="s0">, </span><span class="s1">padtype_options)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_output_match_dtype(self</span><span class="s0">, </span><span class="s1">padtype</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s4"># Test that the dtype of x is preserved per issue #14733</span>
        <span class="s1">x = np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">y = signal.resample_poly(x</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">padtype=padtype)</span>
        <span class="s0">assert </span><span class="s1">y.dtype == x.dtype</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;method, ext, padtype&quot;</span><span class="s0">,</span>
        <span class="s1">[(</span><span class="s3">&quot;fft&quot;</span><span class="s0">, False, None</span><span class="s1">)]</span>
        <span class="s1">+ list(</span>
            <span class="s1">product(</span>
                <span class="s1">[</span><span class="s3">&quot;polyphase&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">padtype_options</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_resample_methods(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">ext</span><span class="s0">, </span><span class="s1">padtype):</span>
        <span class="s4"># Test resampling of sinusoids and random noise (1-sec)</span>
        <span class="s1">rate = </span><span class="s2">100</span>
        <span class="s1">rates_to = [</span><span class="s2">49</span><span class="s0">, </span><span class="s2">50</span><span class="s0">, </span><span class="s2">51</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">101</span><span class="s0">, </span><span class="s2">199</span><span class="s0">, </span><span class="s2">200</span><span class="s0">, </span><span class="s2">201</span><span class="s1">]</span>

        <span class="s4"># Sinusoids, windowed to avoid edge artifacts</span>
        <span class="s1">t = np.arange(rate) / float(rate)</span>
        <span class="s1">freqs = np.array((</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">10.</span><span class="s0">, </span><span class="s2">40.</span><span class="s1">))[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
        <span class="s1">x = np.sin(</span><span class="s2">2 </span><span class="s1">* np.pi * freqs * t) * hann(rate)</span>

        <span class="s0">for </span><span class="s1">rate_to </span><span class="s0">in </span><span class="s1">rates_to:</span>
            <span class="s1">t_to = np.arange(rate_to) / float(rate_to)</span>
            <span class="s1">y_tos = np.sin(</span><span class="s2">2 </span><span class="s1">* np.pi * freqs * t_to) * hann(rate_to)</span>
            <span class="s0">if </span><span class="s1">method == </span><span class="s3">'fft'</span><span class="s1">:</span>
                <span class="s1">y_resamps = signal.resample(x</span><span class="s0">, </span><span class="s1">rate_to</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">ext </span><span class="s0">and </span><span class="s1">rate_to != rate:</span>
                    <span class="s4"># Match default window design</span>
                    <span class="s1">g = gcd(rate_to</span><span class="s0">, </span><span class="s1">rate)</span>
                    <span class="s1">up = rate_to // g</span>
                    <span class="s1">down = rate // g</span>
                    <span class="s1">max_rate = max(up</span><span class="s0">, </span><span class="s1">down)</span>
                    <span class="s1">f_c = </span><span class="s2">1. </span><span class="s1">/ max_rate</span>
                    <span class="s1">half_len = </span><span class="s2">10 </span><span class="s1">* max_rate</span>
                    <span class="s1">window = signal.firwin(</span><span class="s2">2 </span><span class="s1">* half_len + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">f_c</span><span class="s0">,</span>
                                           <span class="s1">window=(</span><span class="s3">'kaiser'</span><span class="s0">, </span><span class="s2">5.0</span><span class="s1">))</span>
                    <span class="s1">polyargs = {</span><span class="s3">'window'</span><span class="s1">: window</span><span class="s0">, </span><span class="s3">'padtype'</span><span class="s1">: padtype}</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">polyargs = {</span><span class="s3">'padtype'</span><span class="s1">: padtype}</span>

                <span class="s1">y_resamps = signal.resample_poly(x</span><span class="s0">, </span><span class="s1">rate_to</span><span class="s0">, </span><span class="s1">rate</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s0">,</span>
                                                 <span class="s1">**polyargs)</span>

            <span class="s0">for </span><span class="s1">y_to</span><span class="s0">, </span><span class="s1">y_resamp</span><span class="s0">, </span><span class="s1">freq </span><span class="s0">in </span><span class="s1">zip(y_tos</span><span class="s0">, </span><span class="s1">y_resamps</span><span class="s0">, </span><span class="s1">freqs):</span>
                <span class="s0">if </span><span class="s1">freq &gt;= </span><span class="s2">0.5 </span><span class="s1">* rate_to:</span>
                    <span class="s1">y_to.fill(</span><span class="s2">0.</span><span class="s1">)  </span><span class="s4"># mostly low-passed away</span>
                    <span class="s0">if </span><span class="s1">padtype </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'minimum'</span><span class="s0">, </span><span class="s3">'maximum'</span><span class="s1">]:</span>
                        <span class="s1">assert_allclose(y_resamp</span><span class="s0">, </span><span class="s1">y_to</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">3e-1</span><span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">assert_allclose(y_resamp</span><span class="s0">, </span><span class="s1">y_to</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-3</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">assert_array_equal(y_to.shape</span><span class="s0">, </span><span class="s1">y_resamp.shape)</span>
                    <span class="s1">corr = np.corrcoef(y_to</span><span class="s0">, </span><span class="s1">y_resamp)[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
                    <span class="s1">assert_(corr &gt; </span><span class="s2">0.99</span><span class="s0">, </span><span class="s1">msg=(corr</span><span class="s0">, </span><span class="s1">rate</span><span class="s0">, </span><span class="s1">rate_to))</span>

        <span class="s4"># Random data</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">x = hann(rate) * np.cumsum(rng.randn(rate))  </span><span class="s4"># low-pass, wind</span>
        <span class="s0">for </span><span class="s1">rate_to </span><span class="s0">in </span><span class="s1">rates_to:</span>
            <span class="s4"># random data</span>
            <span class="s1">t_to = np.arange(rate_to) / float(rate_to)</span>
            <span class="s1">y_to = np.interp(t_to</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s0">if </span><span class="s1">method == </span><span class="s3">'fft'</span><span class="s1">:</span>
                <span class="s1">y_resamp = signal.resample(x</span><span class="s0">, </span><span class="s1">rate_to)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">y_resamp = signal.resample_poly(x</span><span class="s0">, </span><span class="s1">rate_to</span><span class="s0">, </span><span class="s1">rate</span><span class="s0">,</span>
                                                <span class="s1">padtype=padtype)</span>
            <span class="s1">assert_array_equal(y_to.shape</span><span class="s0">, </span><span class="s1">y_resamp.shape)</span>
            <span class="s1">corr = np.corrcoef(y_to</span><span class="s0">, </span><span class="s1">y_resamp)[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">assert_(corr &gt; </span><span class="s2">0.99</span><span class="s0">, </span><span class="s1">msg=corr)</span>

        <span class="s4"># More tests of fft method (Master 0.18.1 fails these)</span>
        <span class="s0">if </span><span class="s1">method == </span><span class="s3">'fft'</span><span class="s1">:</span>
            <span class="s1">x1 = np.array([</span><span class="s2">1.</span><span class="s1">+</span><span class="s2">0.j</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">+</span><span class="s2">0.j</span><span class="s1">])</span>
            <span class="s1">y1_test = signal.resample(x1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
            <span class="s4"># upsampling a complex array</span>
            <span class="s1">y1_true = np.array([</span><span class="s2">1.</span><span class="s1">+</span><span class="s2">0.j</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">+</span><span class="s2">0.j</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">+</span><span class="s2">0.j</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">+</span><span class="s2">0.j</span><span class="s1">])</span>
            <span class="s1">assert_allclose(y1_test</span><span class="s0">, </span><span class="s1">y1_true</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-12</span><span class="s1">)</span>
            <span class="s1">x2 = np.array([</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
            <span class="s1">y2_test = signal.resample(x2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)  </span><span class="s4"># downsampling a real array</span>
            <span class="s1">y2_true = np.array([</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">])</span>
            <span class="s1">assert_allclose(y2_test</span><span class="s0">, </span><span class="s1">y2_true</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_poly_vs_filtfilt(self):</span>
        <span class="s4"># Check that up=1.0 gives same answer as filtfilt + slicing</span>
        <span class="s1">random_state = np.random.RandomState(</span><span class="s2">17</span><span class="s1">)</span>
        <span class="s1">try_types = (int</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.complex64</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">complex)</span>
        <span class="s1">size = </span><span class="s2">10000</span>
        <span class="s1">down_factors = [</span><span class="s2">2</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">79</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">try_types:</span>
            <span class="s1">x = random_state.randn(size).astype(dtype)</span>
            <span class="s0">if </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">(np.complex64</span><span class="s0">, </span><span class="s1">np.complex128):</span>
                <span class="s1">x += </span><span class="s2">1j </span><span class="s1">* random_state.randn(size)</span>

            <span class="s4"># resample_poly assumes zeros outside of signl, whereas filtfilt</span>
            <span class="s4"># can only constant-pad. Make them equivalent:</span>
            <span class="s1">x[</span><span class="s2">0</span><span class="s1">] = </span><span class="s2">0</span>
            <span class="s1">x[-</span><span class="s2">1</span><span class="s1">] = </span><span class="s2">0</span>

            <span class="s0">for </span><span class="s1">down </span><span class="s0">in </span><span class="s1">down_factors:</span>
                <span class="s1">h = signal.firwin(</span><span class="s2">31</span><span class="s0">, </span><span class="s2">1. </span><span class="s1">/ down</span><span class="s0">, </span><span class="s1">window=</span><span class="s3">'hamming'</span><span class="s1">)</span>
                <span class="s1">yf = filtfilt(h</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">padtype=</span><span class="s3">'constant'</span><span class="s1">)[::down]</span>

                <span class="s4"># Need to pass convolved version of filter to resample_poly,</span>
                <span class="s4"># since filtfilt does forward and backward, but resample_poly</span>
                <span class="s4"># only goes forward</span>
                <span class="s1">hc = convolve(h</span><span class="s0">, </span><span class="s1">h[::-</span><span class="s2">1</span><span class="s1">])</span>
                <span class="s1">y = signal.resample_poly(x</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">down</span><span class="s0">, </span><span class="s1">window=hc)</span>
                <span class="s1">assert_allclose(yf</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-7</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_correlate1d(self):</span>
        <span class="s0">for </span><span class="s1">down </span><span class="s0">in </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]:</span>
            <span class="s0">for </span><span class="s1">nx </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">40</span><span class="s0">, </span><span class="s1">down):</span>
                <span class="s0">for </span><span class="s1">nweights </span><span class="s0">in </span><span class="s1">(</span><span class="s2">32</span><span class="s0">, </span><span class="s2">33</span><span class="s1">):</span>
                    <span class="s1">x = np.random.random((nx</span><span class="s0">,</span><span class="s1">))</span>
                    <span class="s1">weights = np.random.random((nweights</span><span class="s0">,</span><span class="s1">))</span>
                    <span class="s1">y_g = correlate1d(x</span><span class="s0">, </span><span class="s1">weights[::-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'constant'</span><span class="s1">)</span>
                    <span class="s1">y_s = signal.resample_poly(</span>
                        <span class="s1">x</span><span class="s0">, </span><span class="s1">up=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">down=down</span><span class="s0">, </span><span class="s1">window=weights)</span>
                    <span class="s1">assert_allclose(y_g[::down]</span><span class="s0">, </span><span class="s1">y_s)</span>


<span class="s0">class </span><span class="s1">TestCSpline1DEval:</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">y = array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">])</span>
        <span class="s1">x = arange(len(y))</span>
        <span class="s1">dx = x[</span><span class="s2">1</span><span class="s1">] - x[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">cj = signal.cspline1d(y)</span>

        <span class="s1">x2 = arange(len(y) * </span><span class="s2">10.0</span><span class="s1">) / </span><span class="s2">10.0</span>
        <span class="s1">y2 = signal.cspline1d_eval(cj</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">dx=dx</span><span class="s0">, </span><span class="s1">x0=x[</span><span class="s2">0</span><span class="s1">])</span>

        <span class="s4"># make sure interpolated values are on knot points</span>
        <span class="s1">assert_array_almost_equal(y2[::</span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_complex(self):</span>
        <span class="s4">#  create some smoothly varying complex signal to interpolate</span>
        <span class="s1">x = np.arange(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">y = np.zeros(x.shape</span><span class="s0">, </span><span class="s1">dtype=np.complex64)</span>
        <span class="s1">T = </span><span class="s2">10.0</span>
        <span class="s1">f = </span><span class="s2">1.0 </span><span class="s1">/ T</span>
        <span class="s1">y = np.exp(</span><span class="s2">2.0J </span><span class="s1">* np.pi * f * x)</span>

        <span class="s4"># get the cspline transform</span>
        <span class="s1">cy = signal.cspline1d(y)</span>

        <span class="s4"># determine new test x value and interpolate</span>
        <span class="s1">xnew = np.array([</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">ynew = signal.cspline1d_eval(cy</span><span class="s0">, </span><span class="s1">xnew)</span>

        <span class="s1">assert_equal(ynew.dtype</span><span class="s0">, </span><span class="s1">y.dtype)</span>

<span class="s0">class </span><span class="s1">TestOrderFilt:</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">assert_array_equal(signal.order_filter([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">_TestLinearFilter:</span>

    <span class="s0">def </span><span class="s1">generate(self</span><span class="s0">, </span><span class="s1">shape):</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.prod(shape) - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">np.prod(shape)).reshape(shape)</span>
        <span class="s0">return </span><span class="s1">self.convert_dtype(x)</span>

    <span class="s0">def </span><span class="s1">convert_dtype(self</span><span class="s0">, </span><span class="s1">arr):</span>
        <span class="s0">if </span><span class="s1">self.dtype == np.dtype(</span><span class="s3">'O'</span><span class="s1">):</span>
            <span class="s1">arr = np.asarray(arr)</span>
            <span class="s1">out = np.empty(arr.shape</span><span class="s0">, </span><span class="s1">self.dtype)</span>
            <span class="s1">iter = np.nditer([arr</span><span class="s0">, </span><span class="s1">out]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'refs_ok'</span><span class="s0">,</span><span class="s3">'zerosize_ok'</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">[[</span><span class="s3">'readonly'</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s3">'writeonly'</span><span class="s1">]])</span>
            <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">iter:</span>
                <span class="s1">y[...] = self.type(x[()])</span>
            <span class="s0">return </span><span class="s1">out</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.array(arr</span><span class="s0">, </span><span class="s1">self.dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rank_1_IIR(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">6</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">y_r = self.convert_dtype([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">10.</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">y_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_1_FIR(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">6</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">y_r = self.convert_dtype([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9.</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">y_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_1_IIR_init_cond(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">6</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">zi = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">y_r = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">21</span><span class="s1">])</span>
        <span class="s1">zf_r = self.convert_dtype([</span><span class="s2">13</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10</span><span class="s1">])</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>
        <span class="s1">assert_array_almost_equal(zf</span><span class="s0">, </span><span class="s1">zf_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_1_FIR_init_cond(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">6</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">zi = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">y_r = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">12.</span><span class="s1">])</span>
        <span class="s1">zf_r = self.convert_dtype([</span><span class="s2">9</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>
        <span class="s1">assert_array_almost_equal(zf</span><span class="s0">, </span><span class="s1">zf_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_2_IIR_axis_0(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">y_r2_a0 = self.convert_dtype([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">y = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y_r2_a0</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_rank_2_IIR_axis_1(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">y_r2_a1 = self.convert_dtype([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">12</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s2">18</span><span class="s0">, </span><span class="s1">-</span><span class="s2">16</span><span class="s0">, </span><span class="s2">18</span><span class="s1">]])</span>
        <span class="s1">y = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y_r2_a1</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_rank_2_IIR_axis_0_init_cond(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">zi = self.convert_dtype(np.ones((</span><span class="s2">4</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)))</span>

        <span class="s1">y_r2_a0_1 = self.convert_dtype([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">13</span><span class="s0">, </span><span class="s1">-</span><span class="s2">11</span><span class="s0">, </span><span class="s2">13</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s2">19</span><span class="s0">, </span><span class="s1">-</span><span class="s2">17</span><span class="s0">, </span><span class="s2">19</span><span class="s1">]])</span>
        <span class="s1">zf_r = self.convert_dtype([-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">17</span><span class="s0">, </span><span class="s1">-</span><span class="s2">29</span><span class="s0">, </span><span class="s1">-</span><span class="s2">41</span><span class="s1">])[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">assert_array_almost_equal(y_r2_a0_1</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_array_almost_equal(zf</span><span class="s0">, </span><span class="s1">zf_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_2_IIR_axis_1_init_cond(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">,</span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">zi = self.convert_dtype(np.ones((</span><span class="s2">1</span><span class="s0">,</span><span class="s2">3</span><span class="s1">)))</span>

        <span class="s1">y_r2_a0_0 = self.convert_dtype([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">zf_r = self.convert_dtype([[-</span><span class="s2">23</span><span class="s0">, </span><span class="s1">-</span><span class="s2">23</span><span class="s0">, </span><span class="s1">-</span><span class="s2">23</span><span class="s1">]])</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">assert_array_almost_equal(y_r2_a0_0</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_array_almost_equal(zf</span><span class="s0">, </span><span class="s1">zf_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_3_IIR(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>

        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">range(x.ndim):</span>
            <span class="s1">y = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis)</span>
            <span class="s1">y_r = np.apply_along_axis(</span><span class="s0">lambda </span><span class="s1">w: lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_3_IIR_init_cond(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>

        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">range(x.ndim):</span>
            <span class="s1">zi_shape = list(x.shape)</span>
            <span class="s1">zi_shape[axis] = </span><span class="s2">1</span>
            <span class="s1">zi = self.convert_dtype(np.ones(zi_shape))</span>
            <span class="s1">zi1 = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
            <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">zi)</span>
            <span class="s0">def </span><span class="s1">lf0(w):</span>
                <span class="s0">return </span><span class="s1">lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">zi=zi1)[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s0">def </span><span class="s1">lf1(w):</span>
                <span class="s0">return </span><span class="s1">lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">zi=zi1)[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">y_r = np.apply_along_axis(lf0</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">zf_r = np.apply_along_axis(lf1</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>
            <span class="s1">assert_array_almost_equal(zf</span><span class="s0">, </span><span class="s1">zf_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_3_FIR(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">range(x.ndim):</span>
            <span class="s1">y = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis)</span>
            <span class="s1">y_r = np.apply_along_axis(</span><span class="s0">lambda </span><span class="s1">w: lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>

    <span class="s0">def </span><span class="s1">test_rank_3_FIR_init_cond(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">range(x.ndim):</span>
            <span class="s1">zi_shape = list(x.shape)</span>
            <span class="s1">zi_shape[axis] = </span><span class="s2">2</span>
            <span class="s1">zi = self.convert_dtype(np.ones(zi_shape))</span>
            <span class="s1">zi1 = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
            <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">zi)</span>
            <span class="s0">def </span><span class="s1">lf0(w):</span>
                <span class="s0">return </span><span class="s1">lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">zi=zi1)[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s0">def </span><span class="s1">lf1(w):</span>
                <span class="s0">return </span><span class="s1">lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">zi=zi1)[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">y_r = np.apply_along_axis(lf0</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">zf_r = np.apply_along_axis(lf1</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>
            <span class="s1">assert_array_almost_equal(zf</span><span class="s0">, </span><span class="s1">zf_r)</span>

    <span class="s0">def </span><span class="s1">test_zi_pseudobroadcast(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">20</span><span class="s1">))</span>
        <span class="s1">b</span><span class="s0">,</span><span class="s1">a = signal.butter(</span><span class="s2">8</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">output=</span><span class="s3">'ba'</span><span class="s1">)</span>
        <span class="s1">b = self.convert_dtype(b)</span>
        <span class="s1">a = self.convert_dtype(a)</span>
        <span class="s1">zi_size = b.shape[</span><span class="s2">0</span><span class="s1">] - </span><span class="s2">1</span>

        <span class="s4"># lfilter requires x.ndim == zi.ndim exactly.  However, zi can have</span>
        <span class="s4"># length 1 dimensions.</span>
        <span class="s1">zi_full = self.convert_dtype(np.ones((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s1">zi_size)))</span>
        <span class="s1">zi_sing = self.convert_dtype(np.ones((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">zi_size)))</span>

        <span class="s1">y_full</span><span class="s0">, </span><span class="s1">zf_full = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi_full)</span>
        <span class="s1">y_sing</span><span class="s0">, </span><span class="s1">zf_sing = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi_sing)</span>

        <span class="s1">assert_array_almost_equal(y_sing</span><span class="s0">, </span><span class="s1">y_full)</span>
        <span class="s1">assert_array_almost_equal(zf_full</span><span class="s0">, </span><span class="s1">zf_sing)</span>

        <span class="s4"># lfilter does not prepend ones</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">lfilter</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">np.ones(zi_size))</span>

    <span class="s0">def </span><span class="s1">test_scalar_a(self):</span>
        <span class="s4"># a can be a scalar.</span>
        <span class="s1">x = self.generate(</span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">y_r = self.convert_dtype([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">y = lfilter(b</span><span class="s0">, </span><span class="s1">a[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>

    <span class="s0">def </span><span class="s1">test_zi_some_singleton_dims(self):</span>
        <span class="s4"># lfilter doesn't really broadcast (no prepending of 1's).  But does</span>
        <span class="s4"># do singleton expansion if x and zi have the same ndim.  This was</span>
        <span class="s4"># broken only if a subset of the axes were singletons (gh-4681).</span>
        <span class="s1">x = self.convert_dtype(np.zeros((</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'l'</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype(np.ones(</span><span class="s2">5</span><span class="s0">, </span><span class="s3">'l'</span><span class="s1">))</span>
        <span class="s1">a = self.convert_dtype(np.array([</span><span class="s2">1</span><span class="s0">,</span><span class="s2">0</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]))</span>
        <span class="s1">zi = np.ones((</span><span class="s2">3</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'l'</span><span class="s1">)</span>
        <span class="s1">zi[</span><span class="s2">1</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">:] *= </span><span class="s2">2</span>
        <span class="s1">zi[</span><span class="s2">2</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">:] *= </span><span class="s2">3</span>
        <span class="s1">zi = self.convert_dtype(zi)</span>

        <span class="s1">zf_expected = self.convert_dtype(np.zeros((</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'l'</span><span class="s1">))</span>
        <span class="s1">y_expected = np.zeros((</span><span class="s2">3</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'l'</span><span class="s1">)</span>
        <span class="s1">y_expected[:</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">:</span><span class="s2">4</span><span class="s1">] = [[[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">3</span><span class="s1">]]]</span>
        <span class="s1">y_expected = self.convert_dtype(y_expected)</span>

        <span class="s4"># IIR</span>
        <span class="s1">y_iir</span><span class="s0">, </span><span class="s1">zf_iir = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">zi)</span>
        <span class="s1">assert_array_almost_equal(y_iir</span><span class="s0">, </span><span class="s1">y_expected)</span>
        <span class="s1">assert_array_almost_equal(zf_iir</span><span class="s0">, </span><span class="s1">zf_expected)</span>

        <span class="s4"># FIR</span>
        <span class="s1">y_fir</span><span class="s0">, </span><span class="s1">zf_fir = lfilter(b</span><span class="s0">, </span><span class="s1">a[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">zi)</span>
        <span class="s1">assert_array_almost_equal(y_fir</span><span class="s0">, </span><span class="s1">y_expected)</span>
        <span class="s1">assert_array_almost_equal(zf_fir</span><span class="s0">, </span><span class="s1">zf_expected)</span>

    <span class="s0">def </span><span class="s1">base_bad_size_zi(self</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">zi):</span>
        <span class="s1">b = self.convert_dtype(b)</span>
        <span class="s1">a = self.convert_dtype(a)</span>
        <span class="s1">x = self.convert_dtype(x)</span>
        <span class="s1">zi = self.convert_dtype(zi)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">lfilter</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">zi)</span>

    <span class="s0">def </span><span class="s1">test_bad_size_zi(self):</span>
        <span class="s4"># rank 1</span>
        <span class="s1">x1 = np.arange(</span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

        <span class="s4"># rank 2</span>
        <span class="s1">x2 = np.arange(</span><span class="s2">12</span><span class="s1">).reshape((</span><span class="s2">4</span><span class="s0">,</span><span class="s2">3</span><span class="s1">))</span>
        <span class="s4"># for axis=0 zi.shape should == (max(len(a),len(b))-1, 3)</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>

        <span class="s4"># for each of these there are 5 cases tested (in this order):</span>
        <span class="s4"># 1. not deep enough, right # elements</span>
        <span class="s4"># 2. too deep, right # elements</span>
        <span class="s4"># 3. right depth, right # elements, transposed</span>
        <span class="s4"># 4. right depth, too few elements</span>
        <span class="s4"># 5. right depth, too many elements</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]])</span>

        <span class="s4"># for axis=1 zi.shape should == (4, max(len(a),len(b))-1)</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">3</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s1">]])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s1">]])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">3</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s1">]])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s1">]])</span>

        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]])</span>
        <span class="s1">self.base_bad_size_zi([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]</span><span class="s0">,</span><span class="s1">[</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_empty_zi(self):</span>
        <span class="s4"># Regression test for #880: empty array for zi crashes.</span>
        <span class="s1">x = self.generate((</span><span class="s2">5</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">zi = self.convert_dtype([])</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_equal(zf.dtype</span><span class="s0">, </span><span class="s1">self.dtype)</span>
        <span class="s1">assert_equal(zf.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_lfiltic_bad_zi(self):</span>
        <span class="s4"># Regression test for #3699: bad initial conditions</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s4"># &quot;y&quot; sets the datatype of zi, so it truncates if int</span>
        <span class="s1">zi = lfiltic(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">zi_1 = lfiltic(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">zi_2 = lfiltic(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(zi</span><span class="s0">, </span><span class="s1">zi_1)</span>
        <span class="s1">assert_array_equal(zi</span><span class="s0">, </span><span class="s1">zi_2)</span>

    <span class="s0">def </span><span class="s1">test_short_x_FIR(self):</span>
        <span class="s4"># regression test for #5116</span>
        <span class="s4"># x shorter than b, with non None zi fails</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">zi = self.convert_dtype([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">])</span>
        <span class="s1">x = self.convert_dtype([</span><span class="s2">72</span><span class="s1">])</span>
        <span class="s1">ye = self.convert_dtype([</span><span class="s2">74</span><span class="s1">])</span>
        <span class="s1">zfe = self.convert_dtype([</span><span class="s2">7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">72</span><span class="s1">])</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">ye)</span>
        <span class="s1">assert_array_almost_equal(zf</span><span class="s0">, </span><span class="s1">zfe)</span>

    <span class="s0">def </span><span class="s1">test_short_x_IIR(self):</span>
        <span class="s4"># regression test for #5116</span>
        <span class="s4"># x shorter than b, with non None zi fails</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">zi = self.convert_dtype([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">])</span>
        <span class="s1">x = self.convert_dtype([</span><span class="s2">72</span><span class="s1">])</span>
        <span class="s1">ye = self.convert_dtype([</span><span class="s2">74</span><span class="s1">])</span>
        <span class="s1">zfe = self.convert_dtype([-</span><span class="s2">67</span><span class="s0">, </span><span class="s1">-</span><span class="s2">72</span><span class="s1">])</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">ye)</span>
        <span class="s1">assert_array_almost_equal(zf</span><span class="s0">, </span><span class="s1">zfe)</span>

    <span class="s0">def </span><span class="s1">test_do_not_modify_a_b_IIR(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">6</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b0 = b.copy()</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">a0 = a.copy()</span>
        <span class="s1">y_r = self.convert_dtype([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">10.</span><span class="s1">])</span>
        <span class="s1">y_f = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_array_almost_equal(y_f</span><span class="s0">, </span><span class="s1">y_r)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">b0)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">a0)</span>

    <span class="s0">def </span><span class="s1">test_do_not_modify_a_b_FIR(self):</span>
        <span class="s1">x = self.generate((</span><span class="s2">6</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">b = self.convert_dtype([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">b0 = b.copy()</span>
        <span class="s1">a = self.convert_dtype([</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">a0 = a.copy()</span>
        <span class="s1">y_r = self.convert_dtype([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4.</span><span class="s1">])</span>
        <span class="s1">y_f = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_array_almost_equal(y_f</span><span class="s0">, </span><span class="s1">y_r)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">b0)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">a0)</span>


<span class="s0">class </span><span class="s1">TestLinearFilterFloat32(_TestLinearFilter):</span>
    <span class="s1">dtype = np.dtype(</span><span class="s3">'f'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestLinearFilterFloat64(_TestLinearFilter):</span>
    <span class="s1">dtype = np.dtype(</span><span class="s3">'d'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestLinearFilterFloatExtended(_TestLinearFilter):</span>
    <span class="s1">dtype = np.dtype(</span><span class="s3">'g'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestLinearFilterComplex64(_TestLinearFilter):</span>
    <span class="s1">dtype = np.dtype(</span><span class="s3">'F'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestLinearFilterComplex128(_TestLinearFilter):</span>
    <span class="s1">dtype = np.dtype(</span><span class="s3">'D'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestLinearFilterComplexExtended(_TestLinearFilter):</span>
    <span class="s1">dtype = np.dtype(</span><span class="s3">'G'</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestLinearFilterDecimal(_TestLinearFilter):</span>
    <span class="s1">dtype = np.dtype(</span><span class="s3">'O'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">type(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">Decimal(str(x))</span>


<span class="s0">class </span><span class="s1">TestLinearFilterObject(_TestLinearFilter):</span>
    <span class="s1">dtype = np.dtype(</span><span class="s3">'O'</span><span class="s1">)</span>
    <span class="s1">type = float</span>


<span class="s0">def </span><span class="s1">test_lfilter_bad_object():</span>
    <span class="s4"># lfilter: object arrays with non-numeric objects raise TypeError.</span>
    <span class="s4"># Regression test for ticket #1452.</span>
    <span class="s0">if </span><span class="s1">hasattr(sys</span><span class="s0">, </span><span class="s3">'abiflags'</span><span class="s1">) </span><span class="s0">and </span><span class="s3">'d' </span><span class="s0">in </span><span class="s1">sys.abiflags:</span>
        <span class="s1">pytest.skip(</span><span class="s3">'test is flaky when run with python3-dbg'</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">lfilter</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, None, </span><span class="s2">2.0</span><span class="s1">])</span>
    <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">lfilter</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">])</span>
    <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">lfilter</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_lfilter_notimplemented_input():</span>
    <span class="s4"># Should not crash, gh-7991</span>
    <span class="s1">assert_raises(NotImplementedError</span><span class="s0">, </span><span class="s1">lfilter</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dt'</span><span class="s0">, </span><span class="s1">[np.ubyte</span><span class="s0">, </span><span class="s1">np.byte</span><span class="s0">, </span><span class="s1">np.ushort</span><span class="s0">, </span><span class="s1">np.short</span><span class="s0">,</span>
                                <span class="s1">np.uint</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">np.ulonglong</span><span class="s0">, </span><span class="s1">np.ulonglong</span><span class="s0">,</span>
                                <span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.longdouble</span><span class="s0">,</span>
                                <span class="s1">Decimal])</span>
<span class="s0">class </span><span class="s1">TestCorrelateReal:</span>
    <span class="s0">def </span><span class="s1">_setup_rank1(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">).astype(dt)</span>
        <span class="s1">b = np.linspace(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">).astype(dt)</span>

        <span class="s1">y_r = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]).astype(dt)</span>
        <span class="s0">return </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r</span>

    <span class="s0">def </span><span class="s1">equal_tolerance(self</span><span class="s0">, </span><span class="s1">res_dt):</span>
        <span class="s4"># default value of keyword</span>
        <span class="s1">decimal = </span><span class="s2">6</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">dt_info = np.finfo(res_dt)</span>
            <span class="s0">if </span><span class="s1">hasattr(dt_info</span><span class="s0">, </span><span class="s3">'resolution'</span><span class="s1">):</span>
                <span class="s1">decimal = int(-</span><span class="s2">0.5</span><span class="s1">*np.log10(dt_info.resolution))</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">decimal</span>

    <span class="s0">def </span><span class="s1">equal_tolerance_fft(self</span><span class="s0">, </span><span class="s1">res_dt):</span>
        <span class="s4"># FFT implementations convert longdouble arguments down to</span>
        <span class="s4"># double so don't expect better precision, see gh-9520</span>
        <span class="s0">if </span><span class="s1">res_dt == np.longdouble:</span>
            <span class="s0">return </span><span class="s1">self.equal_tolerance(np.double)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.equal_tolerance(res_dt)</span>

    <span class="s0">def </span><span class="s1">test_method(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s0">if </span><span class="s1">dt == Decimal:</span>
            <span class="s1">method = choose_conv_method([Decimal(</span><span class="s2">4</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[Decimal(</span><span class="s2">3</span><span class="s1">)])</span>
            <span class="s1">assert_equal(method</span><span class="s0">, </span><span class="s3">'direct'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank3(dt)</span>
            <span class="s1">y_fft = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
            <span class="s1">y_direct = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>

            <span class="s1">assert_array_almost_equal(y_r</span><span class="s0">, </span><span class="s1">y_fft</span><span class="s0">, </span><span class="s1">decimal=self.equal_tolerance_fft(y_fft.dtype))</span>
            <span class="s1">assert_array_almost_equal(y_r</span><span class="s0">, </span><span class="s1">y_direct</span><span class="s0">, </span><span class="s1">decimal=self.equal_tolerance(y_direct.dtype))</span>
            <span class="s1">assert_equal(y_fft.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s1">assert_equal(y_direct.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_rank1_valid(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank1(dt)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

        <span class="s4"># See gh-5897</span>
        <span class="s1">y = correlate(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">][::-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_rank1_same(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank1(dt)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r[:-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_rank1_full(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank1(dt)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">_setup_rank3(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">39</span><span class="s0">, </span><span class="s2">40</span><span class="s1">).reshape((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">).astype(</span>
            <span class="s1">dt)</span>
        <span class="s1">b = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">24</span><span class="s1">).reshape((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">).astype(</span>
            <span class="s1">dt)</span>

        <span class="s1">y_r = array([[[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">184.</span><span class="s0">, </span><span class="s2">504.</span><span class="s0">, </span><span class="s2">912.</span><span class="s0">, </span><span class="s2">1360.</span><span class="s0">, </span><span class="s2">888.</span><span class="s0">, </span><span class="s2">472.</span><span class="s0">, </span><span class="s2">160.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">46.</span><span class="s0">, </span><span class="s2">432.</span><span class="s0">, </span><span class="s2">1062.</span><span class="s0">, </span><span class="s2">1840.</span><span class="s0">, </span><span class="s2">2672.</span><span class="s0">, </span><span class="s2">1698.</span><span class="s0">, </span><span class="s2">864.</span><span class="s0">, </span><span class="s2">266.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">134.</span><span class="s0">, </span><span class="s2">736.</span><span class="s0">, </span><span class="s2">1662.</span><span class="s0">, </span><span class="s2">2768.</span><span class="s0">, </span><span class="s2">3920.</span><span class="s0">, </span><span class="s2">2418.</span><span class="s0">, </span><span class="s2">1168.</span><span class="s0">, </span><span class="s2">314.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">260.</span><span class="s0">, </span><span class="s2">952.</span><span class="s0">, </span><span class="s2">1932.</span><span class="s0">, </span><span class="s2">3056.</span><span class="s0">, </span><span class="s2">4208.</span><span class="s0">, </span><span class="s2">2580.</span><span class="s0">, </span><span class="s2">1240.</span><span class="s0">, </span><span class="s2">332.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">202.</span><span class="s0">, </span><span class="s2">664.</span><span class="s0">, </span><span class="s2">1290.</span><span class="s0">, </span><span class="s2">1984.</span><span class="s0">, </span><span class="s2">2688.</span><span class="s0">, </span><span class="s2">1590.</span><span class="s0">, </span><span class="s2">712.</span><span class="s0">, </span><span class="s2">150.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">114.</span><span class="s0">, </span><span class="s2">344.</span><span class="s0">, </span><span class="s2">642.</span><span class="s0">, </span><span class="s2">960.</span><span class="s0">, </span><span class="s2">1280.</span><span class="s0">, </span><span class="s2">726.</span><span class="s0">, </span><span class="s2">296.</span><span class="s0">, </span><span class="s2">38.</span><span class="s1">]]</span><span class="s0">,</span>

                     <span class="s1">[[</span><span class="s2">23.</span><span class="s0">, </span><span class="s2">400.</span><span class="s0">, </span><span class="s2">1035.</span><span class="s0">, </span><span class="s2">1832.</span><span class="s0">, </span><span class="s2">2696.</span><span class="s0">, </span><span class="s2">1737.</span><span class="s0">, </span><span class="s2">904.</span><span class="s0">, </span><span class="s2">293.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">134.</span><span class="s0">, </span><span class="s2">920.</span><span class="s0">, </span><span class="s2">2166.</span><span class="s0">, </span><span class="s2">3680.</span><span class="s0">, </span><span class="s2">5280.</span><span class="s0">, </span><span class="s2">3306.</span><span class="s0">, </span><span class="s2">1640.</span><span class="s0">, </span><span class="s2">474.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">325.</span><span class="s0">, </span><span class="s2">1544.</span><span class="s0">, </span><span class="s2">3369.</span><span class="s0">, </span><span class="s2">5512.</span><span class="s0">, </span><span class="s2">7720.</span><span class="s0">, </span><span class="s2">4683.</span><span class="s0">, </span><span class="s2">2192.</span><span class="s0">, </span><span class="s2">535.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">571.</span><span class="s0">, </span><span class="s2">1964.</span><span class="s0">, </span><span class="s2">3891.</span><span class="s0">, </span><span class="s2">6064.</span><span class="s0">, </span><span class="s2">8272.</span><span class="s0">, </span><span class="s2">4989.</span><span class="s0">, </span><span class="s2">2324.</span><span class="s0">, </span><span class="s2">565.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">434.</span><span class="s0">, </span><span class="s2">1360.</span><span class="s0">, </span><span class="s2">2586.</span><span class="s0">, </span><span class="s2">3920.</span><span class="s0">, </span><span class="s2">5264.</span><span class="s0">, </span><span class="s2">3054.</span><span class="s0">, </span><span class="s2">1312.</span><span class="s0">, </span><span class="s2">230.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">241.</span><span class="s0">, </span><span class="s2">700.</span><span class="s0">, </span><span class="s2">1281.</span><span class="s0">, </span><span class="s2">1888.</span><span class="s0">, </span><span class="s2">2496.</span><span class="s0">, </span><span class="s2">1383.</span><span class="s0">, </span><span class="s2">532.</span><span class="s0">, </span><span class="s2">39.</span><span class="s1">]]</span><span class="s0">,</span>

                     <span class="s1">[[</span><span class="s2">22.</span><span class="s0">, </span><span class="s2">214.</span><span class="s0">, </span><span class="s2">528.</span><span class="s0">, </span><span class="s2">916.</span><span class="s0">, </span><span class="s2">1332.</span><span class="s0">, </span><span class="s2">846.</span><span class="s0">, </span><span class="s2">430.</span><span class="s0">, </span><span class="s2">132.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">86.</span><span class="s0">, </span><span class="s2">484.</span><span class="s0">, </span><span class="s2">1098.</span><span class="s0">, </span><span class="s2">1832.</span><span class="s0">, </span><span class="s2">2600.</span><span class="s0">, </span><span class="s2">1602.</span><span class="s0">, </span><span class="s2">772.</span><span class="s0">, </span><span class="s2">206.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">188.</span><span class="s0">, </span><span class="s2">802.</span><span class="s0">, </span><span class="s2">1698.</span><span class="s0">, </span><span class="s2">2732.</span><span class="s0">, </span><span class="s2">3788.</span><span class="s0">, </span><span class="s2">2256.</span><span class="s0">, </span><span class="s2">1018.</span><span class="s0">, </span><span class="s2">218.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">308.</span><span class="s0">, </span><span class="s2">1006.</span><span class="s0">, </span><span class="s2">1950.</span><span class="s0">, </span><span class="s2">2996.</span><span class="s0">, </span><span class="s2">4052.</span><span class="s0">, </span><span class="s2">2400.</span><span class="s0">, </span><span class="s2">1078.</span><span class="s0">, </span><span class="s2">230.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">230.</span><span class="s0">, </span><span class="s2">692.</span><span class="s0">, </span><span class="s2">1290.</span><span class="s0">, </span><span class="s2">1928.</span><span class="s0">, </span><span class="s2">2568.</span><span class="s0">, </span><span class="s2">1458.</span><span class="s0">, </span><span class="s2">596.</span><span class="s0">, </span><span class="s2">78.</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">126.</span><span class="s0">, </span><span class="s2">354.</span><span class="s0">, </span><span class="s2">636.</span><span class="s0">, </span><span class="s2">924.</span><span class="s0">, </span><span class="s2">1212.</span><span class="s0">, </span><span class="s2">654.</span><span class="s0">, </span><span class="s2">234.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]]]</span><span class="s0">,</span>
                    <span class="s1">dtype=dt)</span>

        <span class="s0">return </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r</span>

    <span class="s0">def </span><span class="s1">test_rank3_valid(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank3(dt)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">&quot;valid&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">:</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">:</span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

        <span class="s4"># See gh-5897</span>
        <span class="s1">y = correlate(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">&quot;valid&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">:</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">:</span><span class="s2">5</span><span class="s1">][::-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">::-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">::-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_rank3_same(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank3(dt)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">&quot;same&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r[</span><span class="s2">0</span><span class="s1">:-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:-</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_rank3_all(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank3(dt)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>


<span class="s0">class </span><span class="s1">TestCorrelate:</span>
    <span class="s4"># Tests that don't depend on dtype</span>

    <span class="s0">def </span><span class="s1">test_invalid_shapes(self):</span>
        <span class="s4"># By &quot;invalid,&quot; we mean that no one</span>
        <span class="s4"># array has dimensions that are all at</span>
        <span class="s4"># least as large as the corresponding</span>
        <span class="s4"># dimensions of the other array. This</span>
        <span class="s4"># setup should throw a ValueError.</span>
        <span class="s1">a = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s1">).reshape((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(-</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0</span><span class="s1">).reshape((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">*(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">**{</span><span class="s3">'mode'</span><span class="s1">: </span><span class="s3">'valid'</span><span class="s1">})</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">*(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">**{</span><span class="s3">'mode'</span><span class="s1">: </span><span class="s3">'valid'</span><span class="s1">})</span>

    <span class="s0">def </span><span class="s1">test_invalid_params(self):</span>
        <span class="s1">a = [</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'spam'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'eggs'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'ham'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'full'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'bacon'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'same'</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'bacon'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_mismatched_dims(self):</span>
        <span class="s4"># Input arrays should have the same number of dimensions</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'direct'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">'fft'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">correlate</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_numpy_fastpath(self):</span>
        <span class="s1">a = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">assert_allclose(correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'same'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s2">23</span><span class="s1">])</span>

        <span class="s1">a = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span>
        <span class="s1">assert_allclose(correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'same'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">17</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">23</span><span class="s1">])</span>
        <span class="s1">assert_allclose(correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'full'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s2">23</span><span class="s0">, </span><span class="s2">12</span><span class="s1">])</span>
        <span class="s1">assert_allclose(correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">'valid'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">32</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;mode&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;valid&quot;</span><span class="s0">, </span><span class="s3">&quot;same&quot;</span><span class="s0">, </span><span class="s3">&quot;full&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;behind&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;input_size&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">100</span><span class="s0">, </span><span class="s2">101</span><span class="s0">, </span><span class="s2">1000</span><span class="s0">, </span><span class="s2">1001</span><span class="s0">, </span><span class="s2">10000</span><span class="s0">, </span><span class="s2">10001</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_correlation_lags(mode</span><span class="s0">, </span><span class="s1">behind</span><span class="s0">, </span><span class="s1">input_size):</span>
    <span class="s4"># generate random data</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">in1 = rng.standard_normal(input_size)</span>
    <span class="s1">offset = int(input_size/</span><span class="s2">10</span><span class="s1">)</span>
    <span class="s4"># generate offset version of array to correlate with</span>
    <span class="s0">if </span><span class="s1">behind:</span>
        <span class="s4"># y is behind x</span>
        <span class="s1">in2 = np.concatenate([rng.standard_normal(offset)</span><span class="s0">, </span><span class="s1">in1])</span>
        <span class="s1">expected = -offset</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s4"># y is ahead of x</span>
        <span class="s1">in2 = in1[offset:]</span>
        <span class="s1">expected = offset</span>
    <span class="s4"># cross correlate, returning lag information</span>
    <span class="s1">correlation = correlate(in1</span><span class="s0">, </span><span class="s1">in2</span><span class="s0">, </span><span class="s1">mode=mode)</span>
    <span class="s1">lags = correlation_lags(in1.size</span><span class="s0">, </span><span class="s1">in2.size</span><span class="s0">, </span><span class="s1">mode=mode)</span>
    <span class="s4"># identify the peak</span>
    <span class="s1">lag_index = np.argmax(correlation)</span>
    <span class="s4"># Check as expected</span>
    <span class="s1">assert_equal(lags[lag_index]</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s4"># Correlation and lags shape should match</span>
    <span class="s1">assert_equal(lags.shape</span><span class="s0">, </span><span class="s1">correlation.shape)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dt'</span><span class="s0">, </span><span class="s1">[np.csingle</span><span class="s0">, </span><span class="s1">np.cdouble</span><span class="s0">, </span><span class="s1">np.clongdouble])</span>
<span class="s0">class </span><span class="s1">TestCorrelateComplex:</span>
    <span class="s4"># The decimal precision to be used for comparing results.</span>
    <span class="s4"># This value will be passed as the 'decimal' keyword argument of</span>
    <span class="s4"># assert_array_almost_equal().</span>
    <span class="s4"># Since correlate may chose to use FFT method which converts</span>
    <span class="s4"># longdoubles to doubles internally don't expect better precision</span>
    <span class="s4"># for longdouble than for double (see gh-9520).</span>

    <span class="s0">def </span><span class="s1">decimal(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s0">if </span><span class="s1">dt == np.clongdouble:</span>
            <span class="s1">dt = np.cdouble</span>
        <span class="s0">return </span><span class="s1">int(</span><span class="s2">2 </span><span class="s1">* np.finfo(dt).precision / </span><span class="s2">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_setup_rank1(self</span><span class="s0">, </span><span class="s1">dt</span><span class="s0">, </span><span class="s1">mode):</span>
        <span class="s1">np.random.seed(</span><span class="s2">9</span><span class="s1">)</span>
        <span class="s1">a = np.random.randn(</span><span class="s2">10</span><span class="s1">).astype(dt)</span>
        <span class="s1">a += </span><span class="s2">1j </span><span class="s1">* np.random.randn(</span><span class="s2">10</span><span class="s1">).astype(dt)</span>
        <span class="s1">b = np.random.randn(</span><span class="s2">8</span><span class="s1">).astype(dt)</span>
        <span class="s1">b += </span><span class="s2">1j </span><span class="s1">* np.random.randn(</span><span class="s2">8</span><span class="s1">).astype(dt)</span>

        <span class="s1">y_r = (correlate(a.real</span><span class="s0">, </span><span class="s1">b.real</span><span class="s0">, </span><span class="s1">mode=mode) +</span>
               <span class="s1">correlate(a.imag</span><span class="s0">, </span><span class="s1">b.imag</span><span class="s0">, </span><span class="s1">mode=mode)).astype(dt)</span>
        <span class="s1">y_r += </span><span class="s2">1j </span><span class="s1">* (-correlate(a.real</span><span class="s0">, </span><span class="s1">b.imag</span><span class="s0">, </span><span class="s1">mode=mode) +</span>
                     <span class="s1">correlate(a.imag</span><span class="s0">, </span><span class="s1">b.real</span><span class="s0">, </span><span class="s1">mode=mode))</span>
        <span class="s0">return </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r</span>

    <span class="s0">def </span><span class="s1">test_rank1_valid(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank1(dt</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r</span><span class="s0">, </span><span class="s1">decimal=self.decimal(dt))</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

        <span class="s4"># See gh-5897</span>
        <span class="s1">y = correlate(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r[::-</span><span class="s2">1</span><span class="s1">].conj()</span><span class="s0">, </span><span class="s1">decimal=self.decimal(dt))</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_rank1_same(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank1(dt</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r</span><span class="s0">, </span><span class="s1">decimal=self.decimal(dt))</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_rank1_full(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">y_r = self._setup_rank1(dt</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>
        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r</span><span class="s0">, </span><span class="s1">decimal=self.decimal(dt))</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_swap_full(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">d = np.array([</span><span class="s2">0.</span><span class="s1">+</span><span class="s2">0.j</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">+</span><span class="s2">1.j</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">+</span><span class="s2">2.j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">k = np.array([</span><span class="s2">1.</span><span class="s1">+</span><span class="s2">3.j</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">+</span><span class="s2">4.j</span><span class="s0">, </span><span class="s2">3.</span><span class="s1">+</span><span class="s2">5.j</span><span class="s0">, </span><span class="s2">4.</span><span class="s1">+</span><span class="s2">6.j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">y = correlate(d</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">assert_equal(y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.</span><span class="s1">+</span><span class="s2">0.j</span><span class="s0">, </span><span class="s2">10.</span><span class="s1">-</span><span class="s2">2.j</span><span class="s0">, </span><span class="s2">28.</span><span class="s1">-</span><span class="s2">6.j</span><span class="s0">, </span><span class="s2">22.</span><span class="s1">-</span><span class="s2">6.j</span><span class="s0">, </span><span class="s2">16.</span><span class="s1">-</span><span class="s2">6.j</span><span class="s0">, </span><span class="s2">8.</span><span class="s1">-</span><span class="s2">4.j</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_swap_same(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">d = [</span><span class="s2">0.</span><span class="s1">+</span><span class="s2">0.j</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">+</span><span class="s2">1.j</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">+</span><span class="s2">2.j</span><span class="s1">]</span>
        <span class="s1">k = [</span><span class="s2">1.</span><span class="s1">+</span><span class="s2">3.j</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">+</span><span class="s2">4.j</span><span class="s0">, </span><span class="s2">3.</span><span class="s1">+</span><span class="s2">5.j</span><span class="s0">, </span><span class="s2">4.</span><span class="s1">+</span><span class="s2">6.j</span><span class="s1">]</span>
        <span class="s1">y = correlate(d</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">&quot;same&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10.</span><span class="s1">-</span><span class="s2">2.j</span><span class="s0">, </span><span class="s2">28.</span><span class="s1">-</span><span class="s2">6.j</span><span class="s0">, </span><span class="s2">22.</span><span class="s1">-</span><span class="s2">6.j</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_rank3(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a = np.random.randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">6</span><span class="s1">).astype(dt)</span>
        <span class="s1">a += </span><span class="s2">1j </span><span class="s1">* np.random.randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">6</span><span class="s1">).astype(dt)</span>
        <span class="s1">b = np.random.randn(</span><span class="s2">8</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">).astype(dt)</span>
        <span class="s1">b += </span><span class="s2">1j </span><span class="s1">* np.random.randn(</span><span class="s2">8</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">).astype(dt)</span>

        <span class="s1">y_r = (correlate(a.real</span><span class="s0">, </span><span class="s1">b.real)</span>
               <span class="s1">+ correlate(a.imag</span><span class="s0">, </span><span class="s1">b.imag)).astype(dt)</span>
        <span class="s1">y_r += </span><span class="s2">1j </span><span class="s1">* (-correlate(a.real</span><span class="s0">, </span><span class="s1">b.imag) + correlate(a.imag</span><span class="s0">, </span><span class="s1">b.real))</span>

        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r</span><span class="s0">, </span><span class="s1">decimal=self.decimal(dt) - </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

    <span class="s0">def </span><span class="s1">test_rank0(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">a = np.array(np.random.randn()).astype(dt)</span>
        <span class="s1">a += </span><span class="s2">1j </span><span class="s1">* np.array(np.random.randn()).astype(dt)</span>
        <span class="s1">b = np.array(np.random.randn()).astype(dt)</span>
        <span class="s1">b += </span><span class="s2">1j </span><span class="s1">* np.array(np.random.randn()).astype(dt)</span>

        <span class="s1">y_r = (correlate(a.real</span><span class="s0">, </span><span class="s1">b.real)</span>
               <span class="s1">+ correlate(a.imag</span><span class="s0">, </span><span class="s1">b.imag)).astype(dt)</span>
        <span class="s1">y_r += </span><span class="s2">1j </span><span class="s1">* np.array(-correlate(a.real</span><span class="s0">, </span><span class="s1">b.imag) +</span>
                             <span class="s1">correlate(a.imag</span><span class="s0">, </span><span class="s1">b.real))</span>

        <span class="s1">y = correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r</span><span class="s0">, </span><span class="s1">decimal=self.decimal(dt) - </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>

        <span class="s1">assert_equal(correlate([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s1">correlate(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2j</span><span class="s1">))</span>
        <span class="s1">assert_equal(correlate([</span><span class="s2">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3j</span><span class="s1">])</span><span class="s0">, </span><span class="s1">correlate(</span><span class="s2">2j</span><span class="s0">, </span><span class="s2">3j</span><span class="s1">))</span>
        <span class="s1">assert_equal(correlate([</span><span class="s2">3j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s1">])</span><span class="s0">, </span><span class="s1">correlate(</span><span class="s2">3j</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestCorrelate2d:</span>

    <span class="s0">def </span><span class="s1">test_consistency_correlate_funcs(self):</span>
        <span class="s4"># Compare np.correlate, signal.correlate, signal.correlate2d</span>
        <span class="s1">a = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s2">3.2</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'full'</span><span class="s0">, </span><span class="s3">'valid'</span><span class="s0">, </span><span class="s3">'same'</span><span class="s1">]:</span>
            <span class="s1">assert_almost_equal(np.correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode)</span><span class="s0">,</span>
                                <span class="s1">signal.correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode))</span>
            <span class="s1">assert_almost_equal(np.squeeze(signal.correlate2d([a]</span><span class="s0">, </span><span class="s1">[b]</span><span class="s0">,</span>
                                                              <span class="s1">mode=mode))</span><span class="s0">,</span>
                                <span class="s1">signal.correlate(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">mode=mode))</span>

            <span class="s4"># See gh-5897</span>
            <span class="s0">if </span><span class="s1">mode == </span><span class="s3">'valid'</span><span class="s1">:</span>
                <span class="s1">assert_almost_equal(np.correlate(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">mode=mode)</span><span class="s0">,</span>
                                    <span class="s1">signal.correlate(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">mode=mode))</span>
                <span class="s1">assert_almost_equal(np.squeeze(signal.correlate2d([b]</span><span class="s0">, </span><span class="s1">[a]</span><span class="s0">,</span>
                                                                  <span class="s1">mode=mode))</span><span class="s0">,</span>
                                    <span class="s1">signal.correlate(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">mode=mode))</span>

    <span class="s0">def </span><span class="s1">test_invalid_shapes(self):</span>
        <span class="s4"># By &quot;invalid,&quot; we mean that no one</span>
        <span class="s4"># array has dimensions that are all at</span>
        <span class="s4"># least as large as the corresponding</span>
        <span class="s4"># dimensions of the other array. This</span>
        <span class="s4"># setup should throw a ValueError.</span>
        <span class="s1">a = np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s1">).reshape((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(-</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0</span><span class="s1">).reshape((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">signal.correlate2d</span><span class="s0">, </span><span class="s1">*(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">**{</span><span class="s3">'mode'</span><span class="s1">: </span><span class="s3">'valid'</span><span class="s1">})</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">signal.correlate2d</span><span class="s0">, </span><span class="s1">*(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">**{</span><span class="s3">'mode'</span><span class="s1">: </span><span class="s3">'valid'</span><span class="s1">})</span>

    <span class="s0">def </span><span class="s1">test_complex_input(self):</span>
        <span class="s1">assert_equal(signal.correlate2d([[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">2j</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2j</span><span class="s1">)</span>
        <span class="s1">assert_equal(signal.correlate2d([[</span><span class="s2">2j</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">3j</span><span class="s1">]])</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">assert_equal(signal.correlate2d([[</span><span class="s2">3j</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">4</span><span class="s1">]])</span><span class="s0">, </span><span class="s2">12j</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestLFilterZI:</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">a = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">zi_expected = np.array([</span><span class="s2">5.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">zi = lfilter_zi(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_array_almost_equal(zi</span><span class="s0">, </span><span class="s1">zi_expected)</span>

    <span class="s0">def </span><span class="s1">test_scale_invariance(self):</span>
        <span class="s4"># Regression test.  There was a bug in which b was not correctly</span>
        <span class="s4"># rescaled when a[0] was nonzero.</span>
        <span class="s1">b = np.array([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">a = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">8</span><span class="s1">])</span>
        <span class="s1">zi1 = lfilter_zi(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">zi2 = lfilter_zi(</span><span class="s2">2</span><span class="s1">*b</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*a)</span>
        <span class="s1">assert_allclose(zi2</span><span class="s0">, </span><span class="s1">zi1</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-12</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_types(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">b = np.zeros((</span><span class="s2">8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">a = np.array([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.real(signal.lfilter_zi(b</span><span class="s0">, </span><span class="s1">a)).dtype</span><span class="s0">, </span><span class="s1">dtype)</span>


<span class="s0">class </span><span class="s1">TestFiltFilt:</span>
    <span class="s1">filtfilt_kind = </span><span class="s3">'tf'</span>

    <span class="s0">def </span><span class="s1">filtfilt(self</span><span class="s0">, </span><span class="s1">zpk</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">padtype=</span><span class="s3">'odd'</span><span class="s0">, </span><span class="s1">padlen=</span><span class="s0">None,</span>
                 <span class="s1">method=</span><span class="s3">'pad'</span><span class="s0">, </span><span class="s1">irlen=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">self.filtfilt_kind == </span><span class="s3">'tf'</span><span class="s1">:</span>
            <span class="s1">b</span><span class="s0">, </span><span class="s1">a = zpk2tf(*zpk)</span>
            <span class="s0">return </span><span class="s1">filtfilt(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">padtype</span><span class="s0">, </span><span class="s1">padlen</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">irlen)</span>
        <span class="s0">elif </span><span class="s1">self.filtfilt_kind == </span><span class="s3">'sos'</span><span class="s1">:</span>
            <span class="s1">sos = zpk2sos(*zpk)</span>
            <span class="s0">return </span><span class="s1">sosfiltfilt(sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">padtype</span><span class="s0">, </span><span class="s1">padlen)</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">zpk = tf2zpk([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">out = self.filtfilt(zpk</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">12</span><span class="s1">))</span>
        <span class="s1">assert_allclose(out</span><span class="s0">, </span><span class="s1">arange(</span><span class="s2">12</span><span class="s1">)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">5.28e-11</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sine(self):</span>
        <span class="s1">rate = </span><span class="s2">2000</span>
        <span class="s1">t = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">rate + </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s4"># A signal with low frequency and a high frequency.</span>
        <span class="s1">xlow = np.sin(</span><span class="s2">5 </span><span class="s1">* </span><span class="s2">2 </span><span class="s1">* np.pi * t)</span>
        <span class="s1">xhigh = np.sin(</span><span class="s2">250 </span><span class="s1">* </span><span class="s2">2 </span><span class="s1">* np.pi * t)</span>
        <span class="s1">x = xlow + xhigh</span>

        <span class="s1">zpk = butter(</span><span class="s2">8</span><span class="s0">, </span><span class="s2">0.125</span><span class="s0">, </span><span class="s1">output=</span><span class="s3">'zpk'</span><span class="s1">)</span>
        <span class="s4"># r is the magnitude of the largest pole.</span>
        <span class="s1">r = np.abs(zpk[</span><span class="s2">1</span><span class="s1">]).max()</span>
        <span class="s1">eps = </span><span class="s2">1e-5</span>
        <span class="s4"># n estimates the number of steps for the</span>
        <span class="s4"># transient to decay by a factor of eps.</span>
        <span class="s1">n = int(np.ceil(np.log(eps) / np.log(r)))</span>

        <span class="s4"># High order lowpass filter...</span>
        <span class="s1">y = self.filtfilt(zpk</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">padlen=n)</span>
        <span class="s4"># Result should be just xlow.</span>
        <span class="s1">err = np.abs(y - xlow).max()</span>
        <span class="s1">assert_(err &lt; </span><span class="s2">1e-4</span><span class="s1">)</span>

        <span class="s4"># A 2D case.</span>
        <span class="s1">x2d = np.vstack([xlow</span><span class="s0">, </span><span class="s1">xlow + xhigh])</span>
        <span class="s1">y2d = self.filtfilt(zpk</span><span class="s0">, </span><span class="s1">x2d</span><span class="s0">, </span><span class="s1">padlen=n</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(y2d.shape</span><span class="s0">, </span><span class="s1">x2d.shape)</span>
        <span class="s1">err = np.abs(y2d - xlow).max()</span>
        <span class="s1">assert_(err &lt; </span><span class="s2">1e-4</span><span class="s1">)</span>

        <span class="s4"># Use the previous result to check the use of the axis keyword.</span>
        <span class="s4"># (Regression test for ticket #1620)</span>
        <span class="s1">y2dt = self.filtfilt(zpk</span><span class="s0">, </span><span class="s1">x2d.T</span><span class="s0">, </span><span class="s1">padlen=n</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(y2d</span><span class="s0">, </span><span class="s1">y2dt.T)</span>

    <span class="s0">def </span><span class="s1">test_axis(self):</span>
        <span class="s4"># Test the 'axis' keyword on a 3D array.</span>
        <span class="s1">x = np.arange(</span><span class="s2">10.0 </span><span class="s1">* </span><span class="s2">11.0 </span><span class="s1">* </span><span class="s2">12.0</span><span class="s1">).reshape(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">12</span><span class="s1">)</span>
        <span class="s1">zpk = butter(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0.125</span><span class="s0">, </span><span class="s1">output=</span><span class="s3">'zpk'</span><span class="s1">)</span>
        <span class="s1">y0 = self.filtfilt(zpk</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">padlen=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">y1 = self.filtfilt(zpk</span><span class="s0">, </span><span class="s1">np.swapaxes(x</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">padlen=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(y0</span><span class="s0">, </span><span class="s1">np.swapaxes(y1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">y2 = self.filtfilt(zpk</span><span class="s0">, </span><span class="s1">np.swapaxes(x</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">padlen=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(y0</span><span class="s0">, </span><span class="s1">np.swapaxes(y2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_acoeff(self):</span>
        <span class="s0">if </span><span class="s1">self.filtfilt_kind != </span><span class="s3">'tf'</span><span class="s1">:</span>
            <span class="s0">return  </span><span class="s4"># only necessary for TF</span>
        <span class="s4"># test for 'a' coefficient as single number</span>
        <span class="s1">out = signal.filtfilt([</span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.5</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">10</span><span class="s1">))</span>
        <span class="s1">assert_allclose(out</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-14</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-14</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_gust_simple(self):</span>
        <span class="s0">if </span><span class="s1">self.filtfilt_kind != </span><span class="s3">'tf'</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s3">'gust only implemented for TF systems'</span><span class="s1">)</span>
        <span class="s4"># The input array has length 2.  The exact solution for this case</span>
        <span class="s4"># was computed &quot;by hand&quot;.</span>
        <span class="s1">x = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">b = np.array([</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">a = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">z1</span><span class="s0">, </span><span class="s1">z2 = _filtfilt_gust(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_allclose([z1[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">z2[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">,</span>
                        <span class="s1">[</span><span class="s2">0.3</span><span class="s1">*x[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">0.2</span><span class="s1">*x[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">*x[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">0.3</span><span class="s1">*x[</span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(y</span><span class="s0">, </span><span class="s1">[z1[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">0.25</span><span class="s1">*z2[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">0.25</span><span class="s1">*x[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">0.125</span><span class="s1">*x[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s2">0.25</span><span class="s1">*z1[</span><span class="s2">0</span><span class="s1">] + z2[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">0.125</span><span class="s1">*x[</span><span class="s2">0</span><span class="s1">] + </span><span class="s2">0.25</span><span class="s1">*x[</span><span class="s2">1</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_gust_scalars(self):</span>
        <span class="s0">if </span><span class="s1">self.filtfilt_kind != </span><span class="s3">'tf'</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s3">'gust only implemented for TF systems'</span><span class="s1">)</span>
        <span class="s4"># The filter coefficients are both scalars, so the filter simply</span>
        <span class="s4"># multiplies its input by b/a.  When it is used in filtfilt, the</span>
        <span class="s4"># factor is (b/a)**2.</span>
        <span class="s1">x = np.arange(</span><span class="s2">12</span><span class="s1">)</span>
        <span class="s1">b = </span><span class="s2">3.0</span>
        <span class="s1">a = </span><span class="s2">2.0</span>
        <span class="s1">y = filtfilt(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">&quot;gust&quot;</span><span class="s1">)</span>
        <span class="s1">expected = (b/a)**</span><span class="s2">2 </span><span class="s1">* x</span>
        <span class="s1">assert_allclose(y</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestSOSFiltFilt(TestFiltFilt):</span>
    <span class="s1">filtfilt_kind = </span><span class="s3">'sos'</span>

    <span class="s0">def </span><span class="s1">test_equivalence(self):</span>
        <span class="s5">&quot;&quot;&quot;Test equivalence between sosfiltfilt and filtfilt&quot;&quot;&quot;</span>
        <span class="s1">x = np.random.RandomState(</span><span class="s2">0</span><span class="s1">).randn(</span><span class="s2">1000</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">order </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">):</span>
            <span class="s1">zpk = signal.butter(order</span><span class="s0">, </span><span class="s2">0.35</span><span class="s0">, </span><span class="s1">output=</span><span class="s3">'zpk'</span><span class="s1">)</span>
            <span class="s1">b</span><span class="s0">, </span><span class="s1">a = zpk2tf(*zpk)</span>
            <span class="s1">sos = zpk2sos(*zpk)</span>
            <span class="s1">y = filtfilt(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">y_sos = sosfiltfilt(sos</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">assert_allclose(y</span><span class="s0">, </span><span class="s1">y_sos</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-12</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s3">'order=%s' </span><span class="s1">% order)</span>


<span class="s0">def </span><span class="s1">filtfilt_gust_opt(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x):</span>
    <span class="s5">&quot;&quot;&quot; 
    An alternative implementation of filtfilt with Gustafsson edges. 
 
    This function computes the same result as 
    `scipy.signal._signaltools._filtfilt_gust`, but only 1-d arrays 
    are accepted.  The problem is solved using `fmin` from `scipy.optimize`. 
    `_filtfilt_gust` is significanly faster than this implementation. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">filtfilt_gust_opt_func(ics</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s5">&quot;&quot;&quot;Objective function used in filtfilt_gust_opt.&quot;&quot;&quot;</span>
        <span class="s1">m = max(len(a)</span><span class="s0">, </span><span class="s1">len(b)) - </span><span class="s2">1</span>
        <span class="s1">z0f = ics[:m]</span>
        <span class="s1">z0b = ics[m:]</span>
        <span class="s1">y_f = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=z0f)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">y_fb = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">y_f[::-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">zi=z0b)[</span><span class="s2">0</span><span class="s1">][::-</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s1">y_b = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x[::-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">zi=z0b)[</span><span class="s2">0</span><span class="s1">][::-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">y_bf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">y_b</span><span class="s0">, </span><span class="s1">zi=z0f)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">value = np.sum((y_fb - y_bf)**</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">value</span>

    <span class="s1">m = max(len(a)</span><span class="s0">, </span><span class="s1">len(b)) - </span><span class="s2">1</span>
    <span class="s1">zi = lfilter_zi(b</span><span class="s0">, </span><span class="s1">a)</span>
    <span class="s1">ics = np.concatenate((x[:m].mean()*zi</span><span class="s0">, </span><span class="s1">x[-m:].mean()*zi))</span>
    <span class="s1">result = fmin(filtfilt_gust_opt_func</span><span class="s0">, </span><span class="s1">ics</span><span class="s0">, </span><span class="s1">args=(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">,</span>
                  <span class="s1">xtol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">ftol=</span><span class="s2">1e-12</span><span class="s0">,</span>
                  <span class="s1">maxfun=</span><span class="s2">10000</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">10000</span><span class="s0">,</span>
                  <span class="s1">full_output=</span><span class="s0">True, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">opt</span><span class="s0">, </span><span class="s1">fopt</span><span class="s0">, </span><span class="s1">niter</span><span class="s0">, </span><span class="s1">funcalls</span><span class="s0">, </span><span class="s1">warnflag = result</span>
    <span class="s0">if </span><span class="s1">warnflag &gt; </span><span class="s2">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;minimization failed in filtfilt_gust_opt: &quot;</span>
                           <span class="s3">&quot;warnflag=%d&quot; </span><span class="s1">% warnflag)</span>
    <span class="s1">z0f = opt[:m]</span>
    <span class="s1">z0b = opt[m:]</span>

    <span class="s4"># Apply the forward-backward filter using the computed initial</span>
    <span class="s4"># conditions.</span>
    <span class="s1">y_b = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x[::-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">zi=z0b)[</span><span class="s2">0</span><span class="s1">][::-</span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">y = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">y_b</span><span class="s0">, </span><span class="s1">zi=z0f)[</span><span class="s2">0</span><span class="s1">]</span>

    <span class="s0">return </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z0f</span><span class="s0">, </span><span class="s1">z0b</span>


<span class="s0">def </span><span class="s1">check_filtfilt_gust(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">irlen=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4"># Generate x, the data to be filtered.</span>
    <span class="s1">np.random.seed(</span><span class="s2">123</span><span class="s1">)</span>
    <span class="s1">x = np.random.randn(*shape)</span>

    <span class="s4"># Apply filtfilt to x. This is the main calculation to be checked.</span>
    <span class="s1">y = filtfilt(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">method=</span><span class="s3">&quot;gust&quot;</span><span class="s0">, </span><span class="s1">irlen=irlen)</span>

    <span class="s4"># Also call the private function so we can test the ICs.</span>
    <span class="s1">yg</span><span class="s0">, </span><span class="s1">zg1</span><span class="s0">, </span><span class="s1">zg2 = _filtfilt_gust(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">irlen=irlen)</span>

    <span class="s4"># filtfilt_gust_opt is an independent implementation that gives the</span>
    <span class="s4"># expected result, but it only handles 1-D arrays, so use some looping</span>
    <span class="s4"># and reshaping shenanigans to create the expected output arrays.</span>
    <span class="s1">xx = np.swapaxes(x</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">out_shape = xx.shape[:-</span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">yo = np.empty_like(xx)</span>
    <span class="s1">m = max(len(a)</span><span class="s0">, </span><span class="s1">len(b)) - </span><span class="s2">1</span>
    <span class="s1">zo1 = np.empty(out_shape + (m</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">zo2 = np.empty(out_shape + (m</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s0">for </span><span class="s1">indx </span><span class="s0">in </span><span class="s1">product(*[range(d) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">out_shape]):</span>
        <span class="s1">yo[indx]</span><span class="s0">, </span><span class="s1">zo1[indx]</span><span class="s0">, </span><span class="s1">zo2[indx] = filtfilt_gust_opt(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">xx[indx])</span>
    <span class="s1">yo = np.swapaxes(yo</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s1">zo1 = np.swapaxes(zo1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s1">zo2 = np.swapaxes(zo2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s1">assert_allclose(y</span><span class="s0">, </span><span class="s1">yo</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-9</span><span class="s1">)</span>
    <span class="s1">assert_allclose(yg</span><span class="s0">, </span><span class="s1">yo</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-9</span><span class="s1">)</span>
    <span class="s1">assert_allclose(zg1</span><span class="s0">, </span><span class="s1">zo1</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-9</span><span class="s1">)</span>
    <span class="s1">assert_allclose(zg2</span><span class="s0">, </span><span class="s1">zo2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-9</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_choose_conv_method():</span>
    <span class="s0">for </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'valid'</span><span class="s0">, </span><span class="s3">'same'</span><span class="s0">, </span><span class="s3">'full'</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">ndim </span><span class="s0">in </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]:</span>
            <span class="s1">n</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">true_method = </span><span class="s2">8</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s3">'direct'</span>
            <span class="s1">x = np.random.randn(*((n</span><span class="s0">,</span><span class="s1">) * ndim))</span>
            <span class="s1">h = np.random.randn(*((k</span><span class="s0">,</span><span class="s1">) * ndim))</span>

            <span class="s1">method = choose_conv_method(x</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">mode=mode)</span>
            <span class="s1">assert_equal(method</span><span class="s0">, </span><span class="s1">true_method)</span>

            <span class="s1">method_try</span><span class="s0">, </span><span class="s1">times = choose_conv_method(x</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">mode=mode</span><span class="s0">, </span><span class="s1">measure=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">assert_(method_try </span><span class="s0">in </span><span class="s1">{</span><span class="s3">'fft'</span><span class="s0">, </span><span class="s3">'direct'</span><span class="s1">})</span>
            <span class="s1">assert_(type(times) </span><span class="s0">is </span><span class="s1">dict)</span>
            <span class="s1">assert_(</span><span class="s3">'fft' </span><span class="s0">in </span><span class="s1">times.keys() </span><span class="s0">and </span><span class="s3">'direct' </span><span class="s0">in </span><span class="s1">times.keys())</span>

        <span class="s1">n = </span><span class="s2">10</span>
        <span class="s0">for </span><span class="s1">not_fft_conv_supp </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;complex256&quot;</span><span class="s0">, </span><span class="s3">&quot;complex192&quot;</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">hasattr(np</span><span class="s0">, </span><span class="s1">not_fft_conv_supp):</span>
                <span class="s1">x = np.ones(n</span><span class="s0">, </span><span class="s1">dtype=not_fft_conv_supp)</span>
                <span class="s1">h = x.copy()</span>
                <span class="s1">assert_equal(choose_conv_method(x</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">mode=mode)</span><span class="s0">, </span><span class="s3">'direct'</span><span class="s1">)</span>

        <span class="s1">x = np.array([</span><span class="s2">2</span><span class="s1">**</span><span class="s2">51</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s1">h = x.copy()</span>
        <span class="s1">assert_equal(choose_conv_method(x</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">mode=mode)</span><span class="s0">, </span><span class="s3">'direct'</span><span class="s1">)</span>

        <span class="s1">x = [Decimal(</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">2</span><span class="s1">)]</span>
        <span class="s1">h = [Decimal(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">4</span><span class="s1">)]</span>
        <span class="s1">assert_equal(choose_conv_method(x</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">mode=mode)</span><span class="s0">, </span><span class="s3">'direct'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_filtfilt_gust():</span>
    <span class="s4"># Design a filter.</span>
    <span class="s1">z</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = signal.ellip(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0.01</span><span class="s0">, </span><span class="s2">120</span><span class="s0">, </span><span class="s2">0.0875</span><span class="s0">, </span><span class="s1">output=</span><span class="s3">'zpk'</span><span class="s1">)</span>

    <span class="s4"># Find the approximate impulse response length of the filter.</span>
    <span class="s1">eps = </span><span class="s2">1e-10</span>
    <span class="s1">r = np.max(np.abs(p))</span>
    <span class="s1">approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r)))</span>

    <span class="s1">np.random.seed(</span><span class="s2">123</span><span class="s1">)</span>

    <span class="s1">b</span><span class="s0">, </span><span class="s1">a = zpk2tf(z</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k)</span>
    <span class="s0">for </span><span class="s1">irlen </span><span class="s0">in </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">approx_impulse_len]:</span>
        <span class="s1">signal_len = </span><span class="s2">5 </span><span class="s1">* approx_impulse_len</span>

        <span class="s4"># 1-d test case</span>
        <span class="s1">check_filtfilt_gust(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">(signal_len</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">irlen)</span>

        <span class="s4"># 3-d test case; test each axis.</span>
        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">):</span>
            <span class="s1">shape = [</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span>
            <span class="s1">shape[axis] = signal_len</span>
            <span class="s1">check_filtfilt_gust(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">irlen)</span>

    <span class="s4"># Test case with length less than 2*approx_impulse_len.</span>
    <span class="s4"># In this case, `filtfilt_gust` should behave the same as if</span>
    <span class="s4"># `irlen=None` was given.</span>
    <span class="s1">length = </span><span class="s2">2</span><span class="s1">*approx_impulse_len - </span><span class="s2">50</span>
    <span class="s1">check_filtfilt_gust(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">(length</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">approx_impulse_len)</span>


<span class="s0">class </span><span class="s1">TestDecimate:</span>
    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s1">x = np.arange(</span><span class="s2">12</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">signal.decimate</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">q=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">signal.decimate</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">q=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">0.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_basic_IIR(self):</span>
        <span class="s1">x = np.arange(</span><span class="s2">12</span><span class="s1">)</span>
        <span class="s1">y = signal.decimate(x</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">ftype=</span><span class="s3">'iir'</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">False</span><span class="s1">).round()</span>
        <span class="s1">assert_array_equal(y</span><span class="s0">, </span><span class="s1">x[::</span><span class="s2">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_basic_FIR(self):</span>
        <span class="s1">x = np.arange(</span><span class="s2">12</span><span class="s1">)</span>
        <span class="s1">y = signal.decimate(x</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">n=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">ftype=</span><span class="s3">'fir'</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">False</span><span class="s1">).round()</span>
        <span class="s1">assert_array_equal(y</span><span class="s0">, </span><span class="s1">x[::</span><span class="s2">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_shape(self):</span>
        <span class="s4"># Regression test for ticket #1480.</span>
        <span class="s1">z = np.zeros((</span><span class="s2">30</span><span class="s0">, </span><span class="s2">30</span><span class="s1">))</span>
        <span class="s1">d0 = signal.decimate(z</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_equal(d0.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s2">15</span><span class="s0">, </span><span class="s2">30</span><span class="s1">))</span>
        <span class="s1">d1 = signal.decimate(z</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_equal(d1.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s2">30</span><span class="s0">, </span><span class="s2">15</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_phaseshift_FIR(self):</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(BadCoefficients</span><span class="s0">, </span><span class="s3">&quot;Badly conditioned filter&quot;</span><span class="s1">)</span>
            <span class="s1">self._test_phaseshift(method=</span><span class="s3">'fir'</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_phase_FIR(self):</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(BadCoefficients</span><span class="s0">, </span><span class="s3">&quot;Badly conditioned filter&quot;</span><span class="s1">)</span>
            <span class="s1">self._test_phaseshift(method=</span><span class="s3">'fir'</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_phaseshift_IIR(self):</span>
        <span class="s1">self._test_phaseshift(method=</span><span class="s3">'iir'</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_phase_IIR(self):</span>
        <span class="s1">self._test_phaseshift(method=</span><span class="s3">'iir'</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_test_phaseshift(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">zero_phase):</span>
        <span class="s1">rate = </span><span class="s2">120</span>
        <span class="s1">rates_to = [</span><span class="s2">15</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s2">40</span><span class="s1">]  </span><span class="s4"># q = 8, 6, 4, 3</span>

        <span class="s1">t_tot = int(</span><span class="s2">100</span><span class="s1">)  </span><span class="s4"># Need to let antialiasing filters settle</span>
        <span class="s1">t = np.arange(rate*t_tot+</span><span class="s2">1</span><span class="s1">) / float(rate)</span>

        <span class="s4"># Sinusoids at 0.8*nyquist, windowed to avoid edge artifacts</span>
        <span class="s1">freqs = np.array(rates_to) * </span><span class="s2">0.8 </span><span class="s1">/ </span><span class="s2">2</span>
        <span class="s1">d = (np.exp(</span><span class="s2">1j </span><span class="s1">* </span><span class="s2">2 </span><span class="s1">* np.pi * freqs[:</span><span class="s0">, </span><span class="s1">np.newaxis] * t)</span>
             <span class="s1">* signal.windows.tukey(t.size</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">rate_to </span><span class="s0">in </span><span class="s1">rates_to:</span>
            <span class="s1">q = rate // rate_to</span>
            <span class="s1">t_to = np.arange(rate_to*t_tot+</span><span class="s2">1</span><span class="s1">) / float(rate_to)</span>
            <span class="s1">d_tos = (np.exp(</span><span class="s2">1j </span><span class="s1">* </span><span class="s2">2 </span><span class="s1">* np.pi * freqs[:</span><span class="s0">, </span><span class="s1">np.newaxis] * t_to)</span>
                     <span class="s1">* signal.windows.tukey(t_to.size</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">))</span>

            <span class="s4"># Set up downsampling filters, match v0.17 defaults</span>
            <span class="s0">if </span><span class="s1">method == </span><span class="s3">'fir'</span><span class="s1">:</span>
                <span class="s1">n = </span><span class="s2">30</span>
                <span class="s1">system = signal.dlti(signal.firwin(n + </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1. </span><span class="s1">/ q</span><span class="s0">,</span>
                                                   <span class="s1">window=</span><span class="s3">'hamming'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">method == </span><span class="s3">'iir'</span><span class="s1">:</span>
                <span class="s1">n = </span><span class="s2">8</span>
                <span class="s1">wc = </span><span class="s2">0.8</span><span class="s1">*np.pi/q</span>
                <span class="s1">system = signal.dlti(*signal.cheby1(n</span><span class="s0">, </span><span class="s2">0.05</span><span class="s0">, </span><span class="s1">wc/np.pi))</span>

            <span class="s4"># Calculate expected phase response, as unit complex vector</span>
            <span class="s0">if </span><span class="s1">zero_phase </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s1">_</span><span class="s0">, </span><span class="s1">h_resps = signal.freqz(system.num</span><span class="s0">, </span><span class="s1">system.den</span><span class="s0">,</span>
                                          <span class="s1">freqs/rate*</span><span class="s2">2</span><span class="s1">*np.pi)</span>
                <span class="s1">h_resps /= np.abs(h_resps)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">h_resps = np.ones_like(freqs)</span>

            <span class="s1">y_resamps = signal.decimate(d.real</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">ftype=system</span><span class="s0">,</span>
                                        <span class="s1">zero_phase=zero_phase)</span>

            <span class="s4"># Get phase from complex inner product, like CSD</span>
            <span class="s1">h_resamps = np.sum(d_tos.conj() * y_resamps</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">h_resamps /= np.abs(h_resamps)</span>
            <span class="s1">subnyq = freqs &lt; </span><span class="s2">0.5</span><span class="s1">*rate_to</span>

            <span class="s4"># Complex vectors should be aligned, only compare below nyquist</span>
            <span class="s1">assert_allclose(np.angle(h_resps.conj()*h_resamps)[subnyq]</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,</span>
                            <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_auto_n(self):</span>
        <span class="s4"># Test that our value of n is a reasonable choice (depends on</span>
        <span class="s4"># the downsampling factor)</span>
        <span class="s1">sfreq = </span><span class="s2">100.</span>
        <span class="s1">n = </span><span class="s2">1000</span>
        <span class="s1">t = np.arange(n) / sfreq</span>
        <span class="s4"># will alias for decimations (&gt;= 15)</span>
        <span class="s1">x = np.sqrt(</span><span class="s2">2. </span><span class="s1">/ n) * np.sin(</span><span class="s2">2 </span><span class="s1">* np.pi * (sfreq / </span><span class="s2">30.</span><span class="s1">) * t)</span>
        <span class="s1">assert_allclose(np.linalg.norm(x)</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-3</span><span class="s1">)</span>
        <span class="s1">x_out = signal.decimate(x</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s1">ftype=</span><span class="s3">'fir'</span><span class="s1">)</span>
        <span class="s1">assert_array_less(np.linalg.norm(x_out)</span><span class="s0">, </span><span class="s2">0.01</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_long_float32(self):</span>
        <span class="s4"># regression: gh-15072.  With 32-bit float and either lfilter</span>
        <span class="s4"># or filtfilt, this is numerically unstable</span>
        <span class="s1">x = signal.decimate(np.ones(</span><span class="s2">10_000</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">any(np.isnan(x))</span>

    <span class="s0">def </span><span class="s1">test_float16_upcast(self):</span>
        <span class="s4"># float16 must be upcast to float64</span>
        <span class="s1">x = signal.decimate(np.ones(</span><span class="s2">100</span><span class="s0">, </span><span class="s1">dtype=np.float16)</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">x.dtype.type == np.float64</span>

    <span class="s0">def </span><span class="s1">test_complex_iir_dlti(self):</span>
        <span class="s4"># regression: gh-17845</span>
        <span class="s4"># centre frequency for filter [Hz]</span>
        <span class="s1">fcentre = </span><span class="s2">50</span>
        <span class="s4"># filter passband width [Hz]</span>
        <span class="s1">fwidth = </span><span class="s2">5</span>
        <span class="s4"># sample rate [Hz]</span>
        <span class="s1">fs = </span><span class="s2">1e3</span>

        <span class="s1">z</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = signal.butter(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*np.pi*fwidth/</span><span class="s2">2</span><span class="s0">, </span><span class="s1">output=</span><span class="s3">'zpk'</span><span class="s0">, </span><span class="s1">fs=fs)</span>
        <span class="s1">z = z.astype(complex) * np.exp(</span><span class="s2">2j </span><span class="s1">* np.pi * fcentre/fs)</span>
        <span class="s1">p = p.astype(complex) * np.exp(</span><span class="s2">2j </span><span class="s1">* np.pi * fcentre/fs)</span>
        <span class="s1">system = signal.dlti(z</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">t = np.arange(</span><span class="s2">200</span><span class="s1">) / fs</span>

        <span class="s4"># input</span>
        <span class="s1">u = (np.exp(</span><span class="s2">2j </span><span class="s1">* np.pi * fcentre * t)</span>
             <span class="s1">+ </span><span class="s2">0.5 </span><span class="s1">* np.exp(-</span><span class="s2">2j </span><span class="s1">* np.pi * fcentre * t))</span>

        <span class="s1">ynzp = signal.decimate(u</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">ftype=system</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">ynzpref = signal.lfilter(*signal.zpk2tf(z</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">,</span>
                                 <span class="s1">u)[::</span><span class="s2">2</span><span class="s1">]</span>

        <span class="s1">assert_equal(ynzp</span><span class="s0">, </span><span class="s1">ynzpref)</span>

        <span class="s1">yzp = signal.decimate(u</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">ftype=system</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">yzpref = signal.filtfilt(*signal.zpk2tf(z</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">,</span>
                                 <span class="s1">u)[::</span><span class="s2">2</span><span class="s1">]</span>

        <span class="s1">assert_allclose(yzp</span><span class="s0">, </span><span class="s1">yzpref</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-13</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_complex_fir_dlti(self):</span>
        <span class="s4"># centre frequency for filter [Hz]</span>
        <span class="s1">fcentre = </span><span class="s2">50</span>
        <span class="s4"># filter passband width [Hz]</span>
        <span class="s1">fwidth = </span><span class="s2">5</span>
        <span class="s4"># sample rate [Hz]</span>
        <span class="s1">fs = </span><span class="s2">1e3</span>
        <span class="s1">numtaps = </span><span class="s2">20</span>

        <span class="s4"># FIR filter about 0Hz</span>
        <span class="s1">bbase = signal.firwin(numtaps</span><span class="s0">, </span><span class="s1">fwidth/</span><span class="s2">2</span><span class="s0">, </span><span class="s1">fs=fs)</span>

        <span class="s4"># rotate these to desired frequency</span>
        <span class="s1">zbase = np.roots(bbase)</span>
        <span class="s1">zrot = zbase * np.exp(</span><span class="s2">2j </span><span class="s1">* np.pi * fcentre/fs)</span>
        <span class="s4"># FIR filter about 50Hz, maintaining passband gain of 0dB</span>
        <span class="s1">bz = bbase[</span><span class="s2">0</span><span class="s1">] * np.poly(zrot)</span>

        <span class="s1">system = signal.dlti(bz</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

        <span class="s1">t = np.arange(</span><span class="s2">200</span><span class="s1">) / fs</span>

        <span class="s4"># input</span>
        <span class="s1">u = (np.exp(</span><span class="s2">2j </span><span class="s1">* np.pi * fcentre * t)</span>
             <span class="s1">+ </span><span class="s2">0.5 </span><span class="s1">* np.exp(-</span><span class="s2">2j </span><span class="s1">* np.pi * fcentre * t))</span>

        <span class="s1">ynzp = signal.decimate(u</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">ftype=system</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">ynzpref = signal.upfirdn(bz</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">up=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">down=</span><span class="s2">2</span><span class="s1">)[:</span><span class="s2">100</span><span class="s1">]</span>

        <span class="s1">assert_equal(ynzp</span><span class="s0">, </span><span class="s1">ynzpref)</span>

        <span class="s1">yzp = signal.decimate(u</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">ftype=system</span><span class="s0">, </span><span class="s1">zero_phase=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">yzpref = signal.resample_poly(u</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">window=bz)</span>

        <span class="s1">assert_equal(yzp</span><span class="s0">, </span><span class="s1">yzpref)</span>


<span class="s0">class </span><span class="s1">TestHilbert:</span>

    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s1">x = np.array([</span><span class="s2">1.0 </span><span class="s1">+ </span><span class="s2">0.0j</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">hilbert</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">x = np.arange(</span><span class="s2">8.0</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">hilbert</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">N=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_hilbert_theoretical(self):</span>
        <span class="s4"># test cases by Ariel Rokem</span>
        <span class="s1">decimal = </span><span class="s2">14</span>

        <span class="s1">pi = np.pi</span>
        <span class="s1">t = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* pi</span><span class="s0">, </span><span class="s1">pi / </span><span class="s2">256</span><span class="s1">)</span>
        <span class="s1">a0 = np.sin(t)</span>
        <span class="s1">a1 = np.cos(t)</span>
        <span class="s1">a2 = np.sin(</span><span class="s2">2 </span><span class="s1">* t)</span>
        <span class="s1">a3 = np.cos(</span><span class="s2">2 </span><span class="s1">* t)</span>
        <span class="s1">a = np.vstack([a0</span><span class="s0">, </span><span class="s1">a1</span><span class="s0">, </span><span class="s1">a2</span><span class="s0">, </span><span class="s1">a3])</span>

        <span class="s1">h = hilbert(a)</span>
        <span class="s1">h_abs = np.abs(h)</span>
        <span class="s1">h_angle = np.angle(h)</span>
        <span class="s1">h_real = np.real(h)</span>

        <span class="s4"># The real part should be equal to the original signals:</span>
        <span class="s1">assert_almost_equal(h_real</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">decimal)</span>
        <span class="s4"># The absolute value should be one everywhere, for this input:</span>
        <span class="s1">assert_almost_equal(h_abs</span><span class="s0">, </span><span class="s1">np.ones(a.shape)</span><span class="s0">, </span><span class="s1">decimal)</span>
        <span class="s4"># For the 'slow' sine - the phase should go from -pi/2 to pi/2 in</span>
        <span class="s4"># the first 256 bins:</span>
        <span class="s1">assert_almost_equal(h_angle[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">:</span><span class="s2">256</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">np.arange(-pi / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">pi / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">pi / </span><span class="s2">256</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">decimal)</span>
        <span class="s4"># For the 'slow' cosine - the phase should go from 0 to pi in the</span>
        <span class="s4"># same interval:</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">h_angle[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:</span><span class="s2">256</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, </span><span class="s1">pi / </span><span class="s2">256</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal)</span>
        <span class="s4"># The 'fast' sine should make this phase transition in half the time:</span>
        <span class="s1">assert_almost_equal(h_angle[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">:</span><span class="s2">128</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">np.arange(-pi / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">pi / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">pi / </span><span class="s2">128</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">decimal)</span>
        <span class="s4"># Ditto for the 'fast' cosine:</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">h_angle[</span><span class="s2">3</span><span class="s0">, </span><span class="s1">:</span><span class="s2">128</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, </span><span class="s1">pi / </span><span class="s2">128</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal)</span>

        <span class="s4"># The imaginary part of hilbert(cos(t)) = sin(t) Wikipedia</span>
        <span class="s1">assert_almost_equal(h[</span><span class="s2">1</span><span class="s1">].imag</span><span class="s0">, </span><span class="s1">a0</span><span class="s0">, </span><span class="s1">decimal)</span>

    <span class="s0">def </span><span class="s1">test_hilbert_axisN(self):</span>
        <span class="s4"># tests for axis and N arguments</span>
        <span class="s1">a = np.arange(</span><span class="s2">18</span><span class="s1">).reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
        <span class="s4"># test axis</span>
        <span class="s1">aa = hilbert(a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(hilbert(a.T</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">aa.T)</span>
        <span class="s4"># test 1d</span>
        <span class="s1">assert_almost_equal(hilbert(a[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">aa[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">14</span><span class="s1">)</span>

        <span class="s4"># test N</span>
        <span class="s1">aan = hilbert(a</span><span class="s0">, </span><span class="s1">N=</span><span class="s2">20</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(aan.shape</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">20</span><span class="s1">])</span>
        <span class="s1">assert_equal(hilbert(a.T</span><span class="s0">, </span><span class="s1">N=</span><span class="s2">20</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">).shape</span><span class="s0">, </span><span class="s1">[</span><span class="s2">20</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s4"># the next test is just a regression test,</span>
        <span class="s4"># no idea whether numbers make sense</span>
        <span class="s1">a0hilb = np.array([</span><span class="s2">0.000000000000000e+00 </span><span class="s1">- </span><span class="s2">1.72015830311905j</span><span class="s0">,</span>
                           <span class="s2">1.000000000000000e+00 </span><span class="s1">- </span><span class="s2">2.047794505137069j</span><span class="s0">,</span>
                           <span class="s2">1.999999999999999e+00 </span><span class="s1">- </span><span class="s2">2.244055555687583j</span><span class="s0">,</span>
                           <span class="s2">3.000000000000000e+00 </span><span class="s1">- </span><span class="s2">1.262750302935009j</span><span class="s0">,</span>
                           <span class="s2">4.000000000000000e+00 </span><span class="s1">- </span><span class="s2">1.066489252384493j</span><span class="s0">,</span>
                           <span class="s2">5.000000000000000e+00 </span><span class="s1">+ </span><span class="s2">2.918022706971047j</span><span class="s0">,</span>
                           <span class="s2">8.881784197001253e-17 </span><span class="s1">+ </span><span class="s2">3.845658908989067j</span><span class="s0">,</span>
                          <span class="s1">-</span><span class="s2">9.444121133484362e-17 </span><span class="s1">+ </span><span class="s2">0.985044202202061j</span><span class="s0">,</span>
                          <span class="s1">-</span><span class="s2">1.776356839400251e-16 </span><span class="s1">+ </span><span class="s2">1.332257797702019j</span><span class="s0">,</span>
                          <span class="s1">-</span><span class="s2">3.996802888650564e-16 </span><span class="s1">+ </span><span class="s2">0.501905089898885j</span><span class="s0">,</span>
                           <span class="s2">1.332267629550188e-16 </span><span class="s1">+ </span><span class="s2">0.668696078880782j</span><span class="s0">,</span>
                          <span class="s1">-</span><span class="s2">1.192678053963799e-16 </span><span class="s1">+ </span><span class="s2">0.235487067862679j</span><span class="s0">,</span>
                          <span class="s1">-</span><span class="s2">1.776356839400251e-16 </span><span class="s1">+ </span><span class="s2">0.286439612812121j</span><span class="s0">,</span>
                           <span class="s2">3.108624468950438e-16 </span><span class="s1">+ </span><span class="s2">0.031676888064907j</span><span class="s0">,</span>
                           <span class="s2">1.332267629550188e-16 </span><span class="s1">- </span><span class="s2">0.019275656884536j</span><span class="s0">,</span>
                          <span class="s1">-</span><span class="s2">2.360035624836702e-16 </span><span class="s1">- </span><span class="s2">0.1652588660287j</span><span class="s0">,</span>
                           <span class="s2">0.000000000000000e+00 </span><span class="s1">- </span><span class="s2">0.332049855010597j</span><span class="s0">,</span>
                           <span class="s2">3.552713678800501e-16 </span><span class="s1">- </span><span class="s2">0.403810179797771j</span><span class="s0">,</span>
                           <span class="s2">8.881784197001253e-17 </span><span class="s1">- </span><span class="s2">0.751023775297729j</span><span class="s0">,</span>
                           <span class="s2">9.444121133484362e-17 </span><span class="s1">- </span><span class="s2">0.79252210110103j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(aan[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a0hilb</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s3">'N regression'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_hilbert_types(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">in_typed = np.zeros(</span><span class="s2">8</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.real(signal.hilbert(in_typed)).dtype</span><span class="s0">, </span><span class="s1">dtype)</span>


<span class="s0">class </span><span class="s1">TestHilbert2:</span>

    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s4"># x must be real.</span>
        <span class="s1">x = np.array([[</span><span class="s2">1.0 </span><span class="s1">+ </span><span class="s2">0.0j</span><span class="s1">]])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">hilbert2</span><span class="s0">, </span><span class="s1">x)</span>

        <span class="s4"># x must be rank 2.</span>
        <span class="s1">x = np.arange(</span><span class="s2">24</span><span class="s1">).reshape(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">hilbert2</span><span class="s0">, </span><span class="s1">x)</span>

        <span class="s4"># Bad value for N.</span>
        <span class="s1">x = np.arange(</span><span class="s2">16</span><span class="s1">).reshape(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">hilbert2</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">N=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">hilbert2</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">N=(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">hilbert2</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">N=(</span><span class="s2">2</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dtype'</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_hilbert2_types(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">in_typed = np.zeros((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.real(signal.hilbert2(in_typed)).dtype</span><span class="s0">, </span><span class="s1">dtype)</span>


<span class="s0">class </span><span class="s1">TestPartialFractionExpansion:</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">r_true</span><span class="s0">, </span><span class="s1">p_true</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">7</span><span class="s1">):</span>
        <span class="s1">r_true = np.asarray(r_true)</span>
        <span class="s1">p_true = np.asarray(p_true)</span>

        <span class="s1">distance = np.hypot(abs(p[:</span><span class="s0">, None</span><span class="s1">] - p_true)</span><span class="s0">,</span>
                            <span class="s1">abs(r[:</span><span class="s0">, None</span><span class="s1">] - r_true))</span>

        <span class="s1">rows</span><span class="s0">, </span><span class="s1">cols = linear_sum_assignment(distance)</span>
        <span class="s1">assert_almost_equal(p[rows]</span><span class="s0">, </span><span class="s1">p_true[cols]</span><span class="s0">, </span><span class="s1">decimal=decimal)</span>
        <span class="s1">assert_almost_equal(r[rows]</span><span class="s0">, </span><span class="s1">r_true[cols]</span><span class="s0">, </span><span class="s1">decimal=decimal)</span>

    <span class="s0">def </span><span class="s1">test_compute_factors(self):</span>
        <span class="s1">factors</span><span class="s0">, </span><span class="s1">poly = _compute_factors([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(len(factors)</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(poly</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>

        <span class="s1">factors</span><span class="s0">, </span><span class="s1">poly = _compute_factors([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                         <span class="s1">include_powers=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(factors)</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(factors[</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(poly</span><span class="s0">, </span><span class="s1">np.poly([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_group_poles(self):</span>
        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = _group_poles(</span>
            <span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.001</span><span class="s0">, </span><span class="s2">1.003</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.003</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0.1</span><span class="s0">, </span><span class="s3">'min'</span><span class="s1">)</span>
        <span class="s1">assert_equal(unique</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">])</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_residue_general(self):</span>
        <span class="s4"># Test are taken from issue #4464, note that poles in scipy are</span>
        <span class="s4"># in increasing by absolute value order, opposite to MATLAB.</span>
        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.3320</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.6653</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.4167</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.4093</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.1644</span><span class="s0">, </span><span class="s2">1.5737</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.2500</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">4</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s1">-</span><span class="s2">12</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.4</span><span class="s0">, </span><span class="s2">1.98</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.406</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(</span>
            <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">18.125 </span><span class="s1">- </span><span class="s2">13.125j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">18.125 </span><span class="s1">+ </span><span class="s2">13.125j</span><span class="s0">, </span><span class="s2">36.25</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">0.5 </span><span class="s1">- </span><span class="s2">0.2j</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">+ </span><span class="s2">0.2j</span><span class="s0">, </span><span class="s2">0.7</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">0.88</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.396</span><span class="s0">, </span><span class="s2">1.348</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.14</span><span class="s0">, </span><span class="s2">0.048</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.8</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.25</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.25</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.5j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1j</span><span class="s0">, </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">13</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">7</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">11</span><span class="s0">, </span><span class="s2">69</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">23</span><span class="s1">])</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">3.5j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">3.5j</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_residue_leading_zeros(self):</span>
        <span class="s4"># Leading zeros in numerator or denominator must not affect the answer.</span>
        <span class="s1">r0</span><span class="s0">, </span><span class="s1">p0</span><span class="s0">, </span><span class="s1">k0 = residue([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">r1</span><span class="s0">, </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">k1 = residue([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">r2</span><span class="s0">, </span><span class="s1">p2</span><span class="s0">, </span><span class="s1">k2 = residue([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">r3</span><span class="s0">, </span><span class="s1">p3</span><span class="s0">, </span><span class="s1">k3 = residue([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r0</span><span class="s0">, </span><span class="s1">r1)</span>
        <span class="s1">assert_almost_equal(r0</span><span class="s0">, </span><span class="s1">r2)</span>
        <span class="s1">assert_almost_equal(r0</span><span class="s0">, </span><span class="s1">r3)</span>
        <span class="s1">assert_almost_equal(p0</span><span class="s0">, </span><span class="s1">p1)</span>
        <span class="s1">assert_almost_equal(p0</span><span class="s0">, </span><span class="s1">p2)</span>
        <span class="s1">assert_almost_equal(p0</span><span class="s0">, </span><span class="s1">p3)</span>
        <span class="s1">assert_almost_equal(k0</span><span class="s0">, </span><span class="s1">k1)</span>
        <span class="s1">assert_almost_equal(k0</span><span class="s0">, </span><span class="s1">k2)</span>
        <span class="s1">assert_almost_equal(k0</span><span class="s0">, </span><span class="s1">k3)</span>

    <span class="s0">def </span><span class="s1">test_resiude_degenerate(self):</span>
        <span class="s4"># Several tests for zero numerator and denominator.</span>
        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residue(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(r.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(p.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Denominator `a` is zero.&quot;</span><span class="s1">):</span>
            <span class="s1">residue(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_residuez_general(self):</span>
        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-(</span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s1">+</span><span class="s2">2.5j</span><span class="s0">, </span><span class="s2">7.5</span><span class="s1">+</span><span class="s2">7.5j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.5</span><span class="s1">-</span><span class="s2">12j</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s2">1j</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2j</span><span class="s1">])</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.3561</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">,</span>
                                    <span class="s1">[-</span><span class="s2">0.9041 </span><span class="s1">- </span><span class="s2">5.9928j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.9041 </span><span class="s1">+ </span><span class="s2">5.9928j</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s2">0.5 </span><span class="s1">+ </span><span class="s2">0.3257j</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- </span><span class="s2">0.3257j</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">decimal=</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.8082</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">4</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.5</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">18</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">18</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s2">0.36</span><span class="s0">, </span><span class="s2">0.24</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">/</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.polymul([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">/</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">/</span><span class="s2">4</span><span class="s1">]))</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">10</span><span class="s1">/</span><span class="s2">3</span><span class="s0">, </span><span class="s2">16</span><span class="s1">/</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.25</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">.125</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">9</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">6</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">8</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">24</span><span class="s0">, </span><span class="s2">15</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(k</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">self.assert_rp_almost_equal(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s2">0.2618 </span><span class="s1">+ </span><span class="s2">0.1902j</span><span class="s0">, </span><span class="s2">0.2618 </span><span class="s1">- </span><span class="s2">0.1902j</span><span class="s0">,</span>
                                     <span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.0382 </span><span class="s1">- </span><span class="s2">0.1176j</span><span class="s0">, </span><span class="s2">0.0382 </span><span class="s1">+ </span><span class="s2">0.1176j</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">[-</span><span class="s2">0.8090 </span><span class="s1">+ </span><span class="s2">0.5878j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.8090 </span><span class="s1">- </span><span class="s2">0.5878j</span><span class="s0">,</span>
                                     <span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.3090 </span><span class="s1">+ </span><span class="s2">0.9511j</span><span class="s0">, </span><span class="s2">0.3090 </span><span class="s1">- </span><span class="s2">0.9511j</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">decimal=</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_residuez_trailing_zeros(self):</span>
        <span class="s4"># Trailing zeros in numerator or denominator must not affect the</span>
        <span class="s4"># answer.</span>
        <span class="s1">r0</span><span class="s0">, </span><span class="s1">p0</span><span class="s0">, </span><span class="s1">k0 = residuez([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">r1</span><span class="s0">, </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">k1 = residuez([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">r2</span><span class="s0">, </span><span class="s1">p2</span><span class="s0">, </span><span class="s1">k2 = residuez([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">r3</span><span class="s0">, </span><span class="s1">p3</span><span class="s0">, </span><span class="s1">k3 = residuez([</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r0</span><span class="s0">, </span><span class="s1">r1)</span>
        <span class="s1">assert_almost_equal(r0</span><span class="s0">, </span><span class="s1">r2)</span>
        <span class="s1">assert_almost_equal(r0</span><span class="s0">, </span><span class="s1">r3)</span>
        <span class="s1">assert_almost_equal(p0</span><span class="s0">, </span><span class="s1">p1)</span>
        <span class="s1">assert_almost_equal(p0</span><span class="s0">, </span><span class="s1">p2)</span>
        <span class="s1">assert_almost_equal(p0</span><span class="s0">, </span><span class="s1">p3)</span>
        <span class="s1">assert_almost_equal(k0</span><span class="s0">, </span><span class="s1">k1)</span>
        <span class="s1">assert_almost_equal(k0</span><span class="s0">, </span><span class="s1">k2)</span>
        <span class="s1">assert_almost_equal(k0</span><span class="s0">, </span><span class="s1">k3)</span>

    <span class="s0">def </span><span class="s1">test_residuez_degenerate(self):</span>
        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(p</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">])</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k = residuez(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(r.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(p.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(k.size</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Denominator `a` is zero.&quot;</span><span class="s1">):</span>
            <span class="s1">residuez(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;First coefficient of determinant `a` must &quot;</span>
                                 <span class="s3">&quot;be non-zero.&quot;</span><span class="s1">):</span>
            <span class="s1">residuez(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_inverse_unique_roots_different_rtypes(self):</span>
        <span class="s4"># This test was inspired by github issue 2496.</span>
        <span class="s1">r = [</span><span class="s2">3 </span><span class="s1">/ </span><span class="s2">10</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">/ </span><span class="s2">6</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2 </span><span class="s1">/ </span><span class="s2">15</span><span class="s1">]</span>
        <span class="s1">p = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">k = []</span>
        <span class="s1">b_expected = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">a_expected = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>

        <span class="s4"># With the default tolerance, the rtype does not matter</span>
        <span class="s4"># for this example.</span>
        <span class="s0">for </span><span class="s1">rtype </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'avg'</span><span class="s0">, </span><span class="s3">'mean'</span><span class="s0">, </span><span class="s3">'min'</span><span class="s0">, </span><span class="s3">'minimum'</span><span class="s0">, </span><span class="s3">'max'</span><span class="s0">, </span><span class="s3">'maximum'</span><span class="s1">):</span>
            <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invres(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">rtype=rtype)</span>
            <span class="s1">assert_allclose(b</span><span class="s0">, </span><span class="s1">b_expected)</span>
            <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">a_expected)</span>

            <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">rtype=rtype)</span>
            <span class="s1">assert_allclose(b</span><span class="s0">, </span><span class="s1">b_expected)</span>
            <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">a_expected)</span>

    <span class="s0">def </span><span class="s1">test_inverse_repeated_roots_different_rtypes(self):</span>
        <span class="s1">r = [</span><span class="s2">3 </span><span class="s1">/ </span><span class="s2">20</span><span class="s0">, </span><span class="s1">-</span><span class="s2">7 </span><span class="s1">/ </span><span class="s2">36</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">/ </span><span class="s2">6</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">/ </span><span class="s2">45</span><span class="s1">]</span>
        <span class="s1">p = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">k = []</span>
        <span class="s1">b_expected = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">b_expected_z = [-</span><span class="s2">1</span><span class="s1">/</span><span class="s2">6</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">/</span><span class="s2">3</span><span class="s0">, </span><span class="s2">11</span><span class="s1">/</span><span class="s2">6</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">a_expected = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">24</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">rtype </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'avg'</span><span class="s0">, </span><span class="s3">'mean'</span><span class="s0">, </span><span class="s3">'min'</span><span class="s0">, </span><span class="s3">'minimum'</span><span class="s0">, </span><span class="s3">'max'</span><span class="s0">, </span><span class="s3">'maximum'</span><span class="s1">):</span>
            <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invres(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">rtype=rtype)</span>
            <span class="s1">assert_allclose(b</span><span class="s0">, </span><span class="s1">b_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-14</span><span class="s1">)</span>
            <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">a_expected)</span>

            <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">rtype=rtype)</span>
            <span class="s1">assert_allclose(b</span><span class="s0">, </span><span class="s1">b_expected_z</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-14</span><span class="s1">)</span>
            <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">a_expected)</span>

    <span class="s0">def </span><span class="s1">test_inverse_bad_rtype(self):</span>
        <span class="s1">r = [</span><span class="s2">3 </span><span class="s1">/ </span><span class="s2">20</span><span class="s0">, </span><span class="s1">-</span><span class="s2">7 </span><span class="s1">/ </span><span class="s2">36</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">/ </span><span class="s2">6</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">/ </span><span class="s2">45</span><span class="s1">]</span>
        <span class="s1">p = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">k = []</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;`rtype` must be one of&quot;</span><span class="s1">):</span>
            <span class="s1">invres(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">rtype=</span><span class="s3">'median'</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;`rtype` must be one of&quot;</span><span class="s1">):</span>
            <span class="s1">invresz(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">rtype=</span><span class="s3">'median'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_invresz_one_coefficient_bug(self):</span>
        <span class="s4"># Regression test for issue in gh-4646.</span>
        <span class="s1">r = [</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">p = [</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">k = [</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz(r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s1">assert_allclose(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_invres(self):</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invres([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invres([</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- </span><span class="s2">3j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.5j</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.5 </span><span class="s1">- </span><span class="s2">4j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">8.5 </span><span class="s1">+ </span><span class="s2">0.25j</span><span class="s0">, </span><span class="s2">3.5 </span><span class="s1">+ </span><span class="s2">3.25j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1.5j</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- </span><span class="s2">0.5j</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invres([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">- </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- </span><span class="s2">3j</span><span class="s0">, </span><span class="s2">10</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invres([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">28 </span><span class="s1">+ </span><span class="s2">16j</span><span class="s0">, </span><span class="s2">40 </span><span class="s1">- </span><span class="s2">62j</span><span class="s0">, </span><span class="s2">100 </span><span class="s1">+ </span><span class="s2">24j</span><span class="s0">,</span>
                                <span class="s1">-</span><span class="s2">292 </span><span class="s1">+ </span><span class="s2">219j</span><span class="s0">, </span><span class="s2">192 </span><span class="s1">- </span><span class="s2">268j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">12 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">53 </span><span class="s1">- </span><span class="s2">20j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">96 </span><span class="s1">+ </span><span class="s2">68j</span><span class="s0">, </span><span class="s2">27 </span><span class="s1">- </span><span class="s2">72j</span><span class="s0">,</span>
                                <span class="s2">108 </span><span class="s1">- </span><span class="s2">54j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">81 </span><span class="s1">+ </span><span class="s2">108j</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invres([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_invresz(self):</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz([</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- </span><span class="s2">3j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.5j</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.5 </span><span class="s1">- </span><span class="s2">4j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">8.5 </span><span class="s1">+ </span><span class="s2">0.25j</span><span class="s0">, </span><span class="s2">3.5 </span><span class="s1">+ </span><span class="s2">3.25j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1.5j</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- </span><span class="s2">0.5j</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">- </span><span class="s2">2j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1 </span><span class="s1">- </span><span class="s2">3j</span><span class="s0">, </span><span class="s2">12</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">3 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">- </span><span class="s2">1j</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s1">-</span><span class="s2">50 </span><span class="s1">+ </span><span class="s2">11j</span><span class="s0">, </span><span class="s2">100 </span><span class="s1">- </span><span class="s2">72j</span><span class="s0">, </span><span class="s2">80 </span><span class="s1">+ </span><span class="s2">58j</span><span class="s0">,</span>
                                <span class="s1">-</span><span class="s2">354 </span><span class="s1">+ </span><span class="s2">228j</span><span class="s0">, </span><span class="s2">234 </span><span class="s1">- </span><span class="s2">297j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">12 </span><span class="s1">+ </span><span class="s2">2j</span><span class="s0">, </span><span class="s2">53 </span><span class="s1">- </span><span class="s2">20j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">96 </span><span class="s1">+ </span><span class="s2">68j</span><span class="s0">, </span><span class="s2">27 </span><span class="s1">- </span><span class="s2">72j</span><span class="s0">,</span>
                                <span class="s2">108 </span><span class="s1">- </span><span class="s2">54j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">81 </span><span class="s1">+ </span><span class="s2">108j</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1j</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_inverse_scalar_arguments(self):</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invres(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = invresz(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestVectorstrength:</span>

    <span class="s0">def </span><span class="s1">test_single_1dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">.5</span><span class="s1">])</span>
        <span class="s1">period = </span><span class="s2">5.</span>
        <span class="s1">targ_strength = </span><span class="s2">1.</span>
        <span class="s1">targ_phase = </span><span class="s2">.1</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi * targ_phase)</span>

    <span class="s0">def </span><span class="s1">test_single_2dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">.5</span><span class="s1">])</span>
        <span class="s1">period = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5.</span><span class="s1">]</span>
        <span class="s1">targ_strength = [</span><span class="s2">1.</span><span class="s1">] * </span><span class="s2">3</span>
        <span class="s1">targ_phase = np.array([</span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.1</span><span class="s1">])</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi * targ_phase)</span>

    <span class="s0">def </span><span class="s1">test_equal_1dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s1">])</span>
        <span class="s1">period = </span><span class="s2">2</span>
        <span class="s1">targ_strength = </span><span class="s2">1.</span>
        <span class="s1">targ_phase = </span><span class="s2">.125</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi * targ_phase)</span>

    <span class="s0">def </span><span class="s1">test_equal_2dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.25</span><span class="s1">])</span>
        <span class="s1">period = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">]</span>
        <span class="s1">targ_strength = [</span><span class="s2">1.</span><span class="s1">] * </span><span class="s2">2</span>
        <span class="s1">targ_phase = np.array([</span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.125</span><span class="s1">])</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi * targ_phase)</span>

    <span class="s0">def </span><span class="s1">test_spaced_1dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">.1</span><span class="s0">, </span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">4.1</span><span class="s0">, </span><span class="s2">10.1</span><span class="s1">])</span>
        <span class="s1">period = </span><span class="s2">1</span>
        <span class="s1">targ_strength = </span><span class="s2">1.</span>
        <span class="s1">targ_phase = </span><span class="s2">.1</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi * targ_phase)</span>

    <span class="s0">def </span><span class="s1">test_spaced_2dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">.1</span><span class="s0">, </span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">4.1</span><span class="s0">, </span><span class="s2">10.1</span><span class="s1">])</span>
        <span class="s1">period = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">.5</span><span class="s1">]</span>
        <span class="s1">targ_strength = [</span><span class="s2">1.</span><span class="s1">] * </span><span class="s2">2</span>
        <span class="s1">targ_phase = np.array([</span><span class="s2">.1</span><span class="s0">, </span><span class="s2">.2</span><span class="s1">])</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi * targ_phase)</span>

    <span class="s0">def </span><span class="s1">test_partial_1dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.75</span><span class="s1">])</span>
        <span class="s1">period = </span><span class="s2">1</span>
        <span class="s1">targ_strength = </span><span class="s2">1. </span><span class="s1">/ </span><span class="s2">3.</span>
        <span class="s1">targ_phase = </span><span class="s2">.5</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi * targ_phase)</span>

    <span class="s0">def </span><span class="s1">test_partial_2dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.75</span><span class="s1">])</span>
        <span class="s1">period = [</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]</span>
        <span class="s1">targ_strength = [</span><span class="s2">1. </span><span class="s1">/ </span><span class="s2">3.</span><span class="s1">] * </span><span class="s2">4</span>
        <span class="s1">targ_phase = np.array([</span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.5</span><span class="s1">])</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s0">, </span><span class="s2">2 </span><span class="s1">* np.pi * targ_phase)</span>

    <span class="s0">def </span><span class="s1">test_opposite_1dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.75</span><span class="s1">])</span>
        <span class="s1">period = </span><span class="s2">1.</span>
        <span class="s1">targ_strength = </span><span class="s2">0</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>

    <span class="s0">def </span><span class="s1">test_opposite_2dperiod(self):</span>
        <span class="s1">events = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">.25</span><span class="s0">, </span><span class="s2">.5</span><span class="s0">, </span><span class="s2">.75</span><span class="s1">])</span>
        <span class="s1">period = [</span><span class="s2">1.</span><span class="s1">] * </span><span class="s2">10</span>
        <span class="s1">targ_strength = [</span><span class="s2">0.</span><span class="s1">] * </span><span class="s2">10</span>

        <span class="s1">strength</span><span class="s0">, </span><span class="s1">phase = vectorstrength(events</span><span class="s0">, </span><span class="s1">period)</span>

        <span class="s1">assert_equal(strength.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(phase.ndim</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(strength</span><span class="s0">, </span><span class="s1">targ_strength)</span>

    <span class="s0">def </span><span class="s1">test_2d_events_ValueError(self):</span>
        <span class="s1">events = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">period = </span><span class="s2">1.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">vectorstrength</span><span class="s0">, </span><span class="s1">events</span><span class="s0">, </span><span class="s1">period)</span>

    <span class="s0">def </span><span class="s1">test_2d_period_ValueError(self):</span>
        <span class="s1">events = </span><span class="s2">1.</span>
        <span class="s1">period = np.array([[</span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">vectorstrength</span><span class="s0">, </span><span class="s1">events</span><span class="s0">, </span><span class="s1">period)</span>

    <span class="s0">def </span><span class="s1">test_zero_period_ValueError(self):</span>
        <span class="s1">events = </span><span class="s2">1.</span>
        <span class="s1">period = </span><span class="s2">0</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">vectorstrength</span><span class="s0">, </span><span class="s1">events</span><span class="s0">, </span><span class="s1">period)</span>

    <span class="s0">def </span><span class="s1">test_negative_period_ValueError(self):</span>
        <span class="s1">events = </span><span class="s2">1.</span>
        <span class="s1">period = -</span><span class="s2">1</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">vectorstrength</span><span class="s0">, </span><span class="s1">events</span><span class="s0">, </span><span class="s1">period)</span>


<span class="s0">def </span><span class="s1">cast_tf2sos(b</span><span class="s0">, </span><span class="s1">a):</span>
    <span class="s5">&quot;&quot;&quot;Convert TF2SOS, casting to complex128 and back to the original dtype.&quot;&quot;&quot;</span>
    <span class="s4"># tf2sos does not support all of the dtypes that we want to check, e.g.:</span>
    <span class="s4">#</span>
    <span class="s4">#     TypeError: array type complex256 is unsupported in linalg</span>
    <span class="s4">#</span>
    <span class="s4"># so let's cast, convert, and cast back -- should be fine for the</span>
    <span class="s4"># systems and precisions we are testing.</span>
    <span class="s1">dtype = np.asarray(b).dtype</span>
    <span class="s1">b = np.array(b</span><span class="s0">, </span><span class="s1">np.complex128)</span>
    <span class="s1">a = np.array(a</span><span class="s0">, </span><span class="s1">np.complex128)</span>
    <span class="s0">return </span><span class="s1">tf2sos(b</span><span class="s0">, </span><span class="s1">a).astype(dtype)</span>


<span class="s0">def </span><span class="s1">assert_allclose_cast(actual</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-7</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Wrap assert_allclose while casting object arrays.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">actual.dtype.kind == </span><span class="s3">'O'</span><span class="s1">:</span>
        <span class="s1">dtype = np.array(actual.flat[</span><span class="s2">0</span><span class="s1">]).dtype</span>
        <span class="s1">actual</span><span class="s0">, </span><span class="s1">desired = actual.astype(dtype)</span><span class="s0">, </span><span class="s1">desired.astype(dtype)</span>
    <span class="s1">assert_allclose(actual</span><span class="s0">, </span><span class="s1">desired</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'func'</span><span class="s0">, </span><span class="s1">(sosfilt</span><span class="s0">, </span><span class="s1">lfilter))</span>
<span class="s0">def </span><span class="s1">test_nonnumeric_dtypes(func):</span>
    <span class="s1">x = [Decimal(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">3</span><span class="s1">)]</span>
    <span class="s1">b = [Decimal(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">3</span><span class="s1">)]</span>
    <span class="s1">a = [Decimal(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Decimal(</span><span class="s2">3</span><span class="s1">)]</span>
    <span class="s1">x = np.array(x)</span>
    <span class="s0">assert </span><span class="s1">x.dtype.kind == </span><span class="s3">'O'</span>
    <span class="s1">desired = lfilter(np.array(b</span><span class="s0">, </span><span class="s1">float)</span><span class="s0">, </span><span class="s1">np.array(a</span><span class="s0">, </span><span class="s1">float)</span><span class="s0">, </span><span class="s1">x.astype(float))</span>
    <span class="s0">if </span><span class="s1">func </span><span class="s0">is </span><span class="s1">sosfilt:</span>
        <span class="s1">actual = sosfilt([b + a]</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">actual = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s0">assert </span><span class="s1">all(isinstance(x</span><span class="s0">, </span><span class="s1">Decimal) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">actual)</span>
    <span class="s1">assert_allclose(actual.astype(float)</span><span class="s0">, </span><span class="s1">desired.astype(float))</span>
    <span class="s4"># Degenerate cases</span>
    <span class="s0">if </span><span class="s1">func </span><span class="s0">is </span><span class="s1">lfilter:</span>
        <span class="s1">args = [</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">args = [tf2sos(</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">)]</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'must be at least 1-D'</span><span class="s1">):</span>
        <span class="s1">func(*args</span><span class="s0">, </span><span class="s1">x=</span><span class="s2">1.</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dt'</span><span class="s0">, </span><span class="s3">'fdgFDGO'</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TestSOSFilt:</span>

    <span class="s4"># The test_rank* tests are pulled from _TestLinearFilter</span>
    <span class="s0">def </span><span class="s1">test_rank1(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">).astype(dt)</span>
        <span class="s1">b = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]).astype(dt)</span>
        <span class="s1">a = np.array([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s1">]).astype(dt)</span>

        <span class="s4"># Test simple IIR</span>
        <span class="s1">y_r = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">10.</span><span class="s1">]).astype(dt)</span>
        <span class="s1">sos = cast_tf2sos(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s0">assert </span><span class="s1">sos.dtype.char == dt</span>
        <span class="s1">assert_array_almost_equal(sosfilt(cast_tf2sos(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">y_r)</span>

        <span class="s4"># Test simple FIR</span>
        <span class="s1">b = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]).astype(dt)</span>
        <span class="s4"># NOTE: This was changed (rel. to TestLinear...) to add a pole @zero:</span>
        <span class="s1">a = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]).astype(dt)</span>
        <span class="s1">y_r = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9.</span><span class="s1">]).astype(dt)</span>
        <span class="s1">assert_array_almost_equal(sosfilt(cast_tf2sos(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">y_r)</span>

        <span class="s1">b = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">a = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">x = np.ones(</span><span class="s2">8</span><span class="s1">)</span>
        <span class="s1">sos = np.concatenate((b</span><span class="s0">, </span><span class="s1">a))</span>
        <span class="s1">sos.shape = (</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">y = sosfilt(sos</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_allclose(y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_rank2(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">shape = (</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.prod(shape) - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">np.prod(shape)).reshape(shape)</span>
        <span class="s1">x = x.astype(dt)</span>

        <span class="s1">b = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]).astype(dt)</span>
        <span class="s1">a = np.array([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]).astype(dt)</span>

        <span class="s1">y_r2_a0 = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
                           <span class="s1">dtype=dt)</span>

        <span class="s1">y_r2_a1 = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">12</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s2">18</span><span class="s0">, </span><span class="s1">-</span><span class="s2">16</span><span class="s0">, </span><span class="s2">18</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>

        <span class="s1">y = sosfilt(cast_tf2sos(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y_r2_a0</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">y = sosfilt(cast_tf2sos(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(y_r2_a1</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_rank3(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">shape = (</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.prod(shape) - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">np.prod(shape)).reshape(shape)</span>

        <span class="s1">b = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]).astype(dt)</span>
        <span class="s1">a = np.array([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]).astype(dt)</span>

        <span class="s4"># Test last axis</span>
        <span class="s1">y = sosfilt(cast_tf2sos(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s2">0</span><span class="s1">]):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s2">1</span><span class="s1">]):</span>
                <span class="s1">assert_array_almost_equal(y[i</span><span class="s0">, </span><span class="s1">j]</span><span class="s0">, </span><span class="s1">lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x[i</span><span class="s0">, </span><span class="s1">j]))</span>

    <span class="s0">def </span><span class="s1">test_initial_conditions(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">b1</span><span class="s0">, </span><span class="s1">a1 = signal.butter(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s3">'low'</span><span class="s1">)</span>
        <span class="s1">b2</span><span class="s0">, </span><span class="s1">a2 = signal.butter(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s3">'low'</span><span class="s1">)</span>
        <span class="s1">b3</span><span class="s0">, </span><span class="s1">a3 = signal.butter(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s3">'low'</span><span class="s1">)</span>
        <span class="s1">b = np.convolve(np.convolve(b1</span><span class="s0">, </span><span class="s1">b2)</span><span class="s0">, </span><span class="s1">b3)</span>
        <span class="s1">a = np.convolve(np.convolve(a1</span><span class="s0">, </span><span class="s1">a2)</span><span class="s0">, </span><span class="s1">a3)</span>
        <span class="s1">sos = np.array((np.r_[b1</span><span class="s0">, </span><span class="s1">a1]</span><span class="s0">, </span><span class="s1">np.r_[b2</span><span class="s0">, </span><span class="s1">a2]</span><span class="s0">, </span><span class="s1">np.r_[b3</span><span class="s0">, </span><span class="s1">a3]))</span>

        <span class="s1">x = np.random.rand(</span><span class="s2">50</span><span class="s1">).astype(dt)</span>

        <span class="s4"># Stopping filtering and continuing</span>
        <span class="s1">y_true</span><span class="s0">, </span><span class="s1">zi = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x[:</span><span class="s2">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">zi=np.zeros(</span><span class="s2">6</span><span class="s1">))</span>
        <span class="s1">y_true = np.r_[y_true</span><span class="s0">, </span><span class="s1">lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x[</span><span class="s2">20</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">zi=zi)[</span><span class="s2">0</span><span class="s1">]]</span>
        <span class="s1">assert_allclose_cast(y_true</span><span class="s0">, </span><span class="s1">lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x))</span>

        <span class="s1">y_sos</span><span class="s0">, </span><span class="s1">zi = sosfilt(sos</span><span class="s0">, </span><span class="s1">x[:</span><span class="s2">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">zi=np.zeros((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)))</span>
        <span class="s1">y_sos = np.r_[y_sos</span><span class="s0">, </span><span class="s1">sosfilt(sos</span><span class="s0">, </span><span class="s1">x[</span><span class="s2">20</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">zi=zi)[</span><span class="s2">0</span><span class="s1">]]</span>
        <span class="s1">assert_allclose_cast(y_true</span><span class="s0">, </span><span class="s1">y_sos)</span>

        <span class="s4"># Use a step function</span>
        <span class="s1">zi = sosfilt_zi(sos)</span>
        <span class="s1">x = np.ones(</span><span class="s2">8</span><span class="s0">, </span><span class="s1">dt)</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = sosfilt(sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi)</span>

        <span class="s1">assert_allclose_cast(y</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">8</span><span class="s1">))</span>
        <span class="s1">assert_allclose_cast(zf</span><span class="s0">, </span><span class="s1">zi)</span>

        <span class="s4"># Initial condition shape matching</span>
        <span class="s1">x.shape = (</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">) + x.shape  </span><span class="s4"># 3D</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">sosfilt</span><span class="s0">, </span><span class="s1">sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">zi_nd = zi.copy()</span>
        <span class="s1">zi_nd.shape = (zi.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">zi.shape[-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">sosfilt</span><span class="s0">, </span><span class="s1">sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">,</span>
                      <span class="s1">zi=zi_nd[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = sosfilt(sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi_nd)</span>
        <span class="s1">assert_allclose_cast(y[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">8</span><span class="s1">))</span>
        <span class="s1">assert_allclose_cast(zf[:</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">zi)</span>

    <span class="s0">def </span><span class="s1">test_initial_conditions_3d_axis1(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s4"># Test the use of zi when sosfilt is applied to axis 1 of a 3-d input.</span>

        <span class="s4"># Input array is x.</span>
        <span class="s1">x = np.random.RandomState(</span><span class="s2">159</span><span class="s1">).randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s1">size=(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">x = x.astype(dt)</span>

        <span class="s4"># Design a filter in ZPK format and convert to SOS</span>
        <span class="s1">zpk = signal.butter(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0.35</span><span class="s0">, </span><span class="s1">output=</span><span class="s3">'zpk'</span><span class="s1">)</span>
        <span class="s1">sos = zpk2sos(*zpk)</span>
        <span class="s1">nsections = sos.shape[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s4"># Filter along this axis.</span>
        <span class="s1">axis = </span><span class="s2">1</span>

        <span class="s4"># Initial conditions, all zeros.</span>
        <span class="s1">shp = list(x.shape)</span>
        <span class="s1">shp[axis] = </span><span class="s2">2</span>
        <span class="s1">shp = [nsections] + shp</span>
        <span class="s1">z0 = np.zeros(shp)</span>

        <span class="s4"># Apply the filter to x.</span>
        <span class="s1">yf</span><span class="s0">, </span><span class="s1">zf = sosfilt(sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">zi=z0)</span>

        <span class="s4"># Apply the filter to x in two stages.</span>
        <span class="s1">y1</span><span class="s0">, </span><span class="s1">z1 = sosfilt(sos</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">, </span><span class="s1">:</span><span class="s2">5</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">zi=z0)</span>
        <span class="s1">y2</span><span class="s0">, </span><span class="s1">z2 = sosfilt(sos</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">, </span><span class="s2">5</span><span class="s1">:</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">zi=z1)</span>

        <span class="s4"># y should equal yf, and z2 should equal zf.</span>
        <span class="s1">y = np.concatenate((y1</span><span class="s0">, </span><span class="s1">y2)</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">assert_allclose_cast(y</span><span class="s0">, </span><span class="s1">yf</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-13</span><span class="s1">)</span>
        <span class="s1">assert_allclose_cast(z2</span><span class="s0">, </span><span class="s1">zf</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s4"># let's try the &quot;step&quot; initial condition</span>
        <span class="s1">zi = sosfilt_zi(sos)</span>
        <span class="s1">zi.shape = [nsections</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">zi = zi * x[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">:</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span>
        <span class="s1">y = sosfilt(sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">zi=zi)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s4"># check it against the TF form</span>
        <span class="s1">b</span><span class="s0">, </span><span class="s1">a = zpk2tf(*zpk)</span>
        <span class="s1">zi = lfilter_zi(b</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">zi.shape = [</span><span class="s2">1</span><span class="s0">, </span><span class="s1">zi.size</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">zi = zi * x[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">:</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span>
        <span class="s1">y_tf = lfilter(b</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">zi=zi)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">assert_allclose_cast(y</span><span class="s0">, </span><span class="s1">y_tf</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-13</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_bad_zi_shape(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s4"># The shape of zi is checked before using any values in the</span>
        <span class="s4"># arguments, so np.empty is fine for creating the arguments.</span>
        <span class="s1">x = np.empty((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dt)</span>
        <span class="s1">sos = np.zeros((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">))</span>
        <span class="s1">zi = np.empty((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))  </span><span class="s4"># Correct shape is (4, 3, 2, 3)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'should be all ones'</span><span class="s1">):</span>
            <span class="s1">sosfilt(sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">sos[:</span><span class="s0">, </span><span class="s2">3</span><span class="s1">] = </span><span class="s2">1.</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'Invalid zi shape'</span><span class="s1">):</span>
            <span class="s1">sosfilt(sos</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">zi=zi</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sosfilt_zi(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">sos = signal.butter(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">output=</span><span class="s3">'sos'</span><span class="s1">)</span>
        <span class="s1">zi = sosfilt_zi(sos)</span>

        <span class="s1">y</span><span class="s0">, </span><span class="s1">zf = sosfilt(sos</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">40</span><span class="s0">, </span><span class="s1">dt)</span><span class="s0">, </span><span class="s1">zi=zi)</span>
        <span class="s1">assert_allclose_cast(zf</span><span class="s0">, </span><span class="s1">zi</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s4"># Expected steady state value of the step response of this filter:</span>
        <span class="s1">ss = np.prod(sos[:</span><span class="s0">, </span><span class="s1">:</span><span class="s2">3</span><span class="s1">].sum(axis=-</span><span class="s2">1</span><span class="s1">) / sos[:</span><span class="s0">, </span><span class="s2">3</span><span class="s1">:].sum(axis=-</span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">assert_allclose_cast(y</span><span class="s0">, </span><span class="s1">ss</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>

        <span class="s4"># zi as array-like</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">zf = sosfilt(sos</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">40</span><span class="s0">, </span><span class="s1">dt)</span><span class="s0">, </span><span class="s1">zi=zi.tolist())</span>
        <span class="s1">assert_allclose_cast(zf</span><span class="s0">, </span><span class="s1">zi</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-13</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestDeconvolve:</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s4"># From docstring example</span>
        <span class="s1">original = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">impulse_response = [</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">recorded = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">recovered</span><span class="s0">, </span><span class="s1">remainder = signal.deconvolve(recorded</span><span class="s0">, </span><span class="s1">impulse_response)</span>
        <span class="s1">assert_allclose(recovered</span><span class="s0">, </span><span class="s1">original)</span>

    <span class="s0">def </span><span class="s1">test_n_dimensional_signal(self):</span>
        <span class="s1">recorded = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span>
        <span class="s1">impulse_response = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;signal must be 1-D.&quot;</span><span class="s1">):</span>
            <span class="s1">quotient</span><span class="s0">, </span><span class="s1">remainder = signal.deconvolve(recorded</span><span class="s0">, </span><span class="s1">impulse_response)</span>

    <span class="s0">def </span><span class="s1">test_n_dimensional_divisor(self):</span>
        <span class="s1">recorded = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">impulse_response = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;divisor must be 1-D.&quot;</span><span class="s1">):</span>
            <span class="s1">quotient</span><span class="s0">, </span><span class="s1">remainder = signal.deconvolve(recorded</span><span class="s0">, </span><span class="s1">impulse_response)</span>


<span class="s0">class </span><span class="s1">TestDetrend:</span>

    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">detrended = detrend(array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">detrended_exact = array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(detrended</span><span class="s0">, </span><span class="s1">detrended_exact)</span>

    <span class="s0">def </span><span class="s1">test_copy(self):</span>
        <span class="s1">x = array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1.2</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.6</span><span class="s0">, </span><span class="s2">2.4</span><span class="s1">])</span>
        <span class="s1">copy_array = detrend(x</span><span class="s0">, </span><span class="s1">overwrite_data=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">inplace = detrend(x</span><span class="s0">, </span><span class="s1">overwrite_data=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(copy_array</span><span class="s0">, </span><span class="s1">inplace)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'kind'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'linear'</span><span class="s0">, </span><span class="s3">'constant'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axis'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_axis(self</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">kind):</span>
        <span class="s1">data = np.arange(</span><span class="s2">5</span><span class="s1">*</span><span class="s2">6</span><span class="s1">*</span><span class="s2">7</span><span class="s1">).reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span>
        <span class="s1">detrended = detrend(data</span><span class="s0">, </span><span class="s1">type=kind</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">assert </span><span class="s1">detrended.shape == data.shape</span>

    <span class="s0">def </span><span class="s1">test_bp(self):</span>
        <span class="s1">data = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">] + [</span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10</span><span class="s1">]</span>
        <span class="s1">detrended = detrend(data</span><span class="s0">, </span><span class="s1">type=</span><span class="s3">'linear'</span><span class="s0">, </span><span class="s1">bp=</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(detrended</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-14</span><span class="s1">)</span>

        <span class="s4"># repeat with ndim &gt; 1 and axis</span>
        <span class="s1">data = np.asarray(data)[</span><span class="s0">None, </span><span class="s1">:</span><span class="s0">, None</span><span class="s1">]</span>

        <span class="s1">detrended = detrend(data</span><span class="s0">, </span><span class="s1">type=</span><span class="s3">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">bp=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(detrended</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-14</span><span class="s1">)</span>

        <span class="s4"># breakpoint index &gt; shape[axis]: raises</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">detrend(data</span><span class="s0">, </span><span class="s1">type=</span><span class="s3">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">bp=</span><span class="s2">3</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'bp'</span><span class="s0">, </span><span class="s1">[np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_detrend_array_bp(self</span><span class="s0">, </span><span class="s1">bp):</span>
        <span class="s4"># regression test for https://github.com/scipy/scipy/issues/18675</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s2">12345</span><span class="s1">)</span>
        <span class="s1">x = rng.rand(</span><span class="s2">10</span><span class="s1">)</span>
       <span class="s4"># bp = np.array([0, 2])</span>

        <span class="s1">res = detrend(x</span><span class="s0">, </span><span class="s1">bp=bp)</span>
        <span class="s1">res_scipy_191 = np.array([-</span><span class="s2">4.44089210e-16</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.22044605e-16</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s2">1.11128506e-01</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.69470553e-01</span><span class="s0">,  </span><span class="s2">1.14710683e-01</span><span class="s0">,  </span><span class="s2">6.35468419e-02</span><span class="s0">,</span>
            <span class="s2">3.53533144e-01</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.67877935e-02</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.00417675e-02</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.94362049e-01</span><span class="s1">])</span>

        <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">res_scipy_191</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-14</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestUniqueRoots:</span>
    <span class="s0">def </span><span class="s1">test_real_no_repeat(self):</span>
        <span class="s1">p = [-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">1.2</span><span class="s0">, </span><span class="s2">10.0</span><span class="s1">]</span>
        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">np.ones(len(p)))</span>

    <span class="s0">def </span><span class="s1">test_real_repeat(self):</span>
        <span class="s1">p = [-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.95</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.89</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.8</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.05</span><span class="s1">]</span>

        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p</span><span class="s0">, </span><span class="s1">tol=</span><span class="s2">1e-1</span><span class="s0">, </span><span class="s1">rtype=</span><span class="s3">'min'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.89</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p</span><span class="s0">, </span><span class="s1">tol=</span><span class="s2">1e-1</span><span class="s0">, </span><span class="s1">rtype=</span><span class="s3">'max'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.95</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.8</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.05</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p</span><span class="s0">, </span><span class="s1">tol=</span><span class="s2">1e-1</span><span class="s0">, </span><span class="s1">rtype=</span><span class="s3">'avg'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.975</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.845</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.025</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_complex_no_repeat(self):</span>
        <span class="s1">p = [-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0j</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">+ </span><span class="s2">0.5j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0 </span><span class="s1">- </span><span class="s2">1.0j</span><span class="s0">, </span><span class="s2">3.0 </span><span class="s1">+ </span><span class="s2">2.0j</span><span class="s1">]</span>
        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">np.ones(len(p)))</span>

    <span class="s0">def </span><span class="s1">test_complex_repeat(self):</span>
        <span class="s1">p = [-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0 </span><span class="s1">+ </span><span class="s2">0.05j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.95 </span><span class="s1">+ </span><span class="s2">0.15j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.90 </span><span class="s1">+ </span><span class="s2">0.15j</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">,</span>
             <span class="s2">0.5 </span><span class="s1">+ </span><span class="s2">0.5j</span><span class="s0">, </span><span class="s2">0.45 </span><span class="s1">+ </span><span class="s2">0.55j</span><span class="s1">]</span>

        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p</span><span class="s0">, </span><span class="s1">tol=</span><span class="s2">1e-1</span><span class="s0">, </span><span class="s1">rtype=</span><span class="s3">'min'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.95 </span><span class="s1">+ </span><span class="s2">0.15j</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.45 </span><span class="s1">+ </span><span class="s2">0.55j</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p</span><span class="s0">, </span><span class="s1">tol=</span><span class="s2">1e-1</span><span class="s0">, </span><span class="s1">rtype=</span><span class="s3">'max'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">,</span>
                            <span class="s1">[-</span><span class="s2">1.0 </span><span class="s1">+ </span><span class="s2">0.05j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.90 </span><span class="s1">+ </span><span class="s2">0.15j</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">+ </span><span class="s2">0.5j</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p</span><span class="s0">, </span><span class="s1">tol=</span><span class="s2">1e-1</span><span class="s0">, </span><span class="s1">rtype=</span><span class="s3">'avg'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">unique</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1.0 </span><span class="s1">+ </span><span class="s2">0.025j</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.925 </span><span class="s1">+ </span><span class="s2">0.15j</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.475 </span><span class="s1">+ </span><span class="s2">0.525j</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_gh_4915(self):</span>
        <span class="s1">p = np.roots(np.convolve(np.ones(</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">5</span><span class="s1">)))</span>
        <span class="s1">true_roots = [-(-</span><span class="s2">1</span><span class="s1">)**(</span><span class="s2">1</span><span class="s1">/</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">1</span><span class="s1">)**(</span><span class="s2">4</span><span class="s1">/</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-(-</span><span class="s2">1</span><span class="s1">)**(</span><span class="s2">3</span><span class="s1">/</span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s2">1</span><span class="s1">)**(</span><span class="s2">2</span><span class="s1">/</span><span class="s2">5</span><span class="s1">)]</span>

        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p)</span>
        <span class="s1">unique = np.sort(unique)</span>

        <span class="s1">assert_almost_equal(np.sort(unique)</span><span class="s0">, </span><span class="s1">true_roots</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">7</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_complex_roots_extra(self):</span>
        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0j</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">+ </span><span class="s2">2e-9</span><span class="s0">, </span><span class="s2">1e-9 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tol=</span><span class="s2">0.1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1e-9 </span><span class="s1">+ </span><span class="s2">1.0j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_single_unique_root(self):</span>
        <span class="s1">p = np.random.rand(</span><span class="s2">100</span><span class="s1">) + </span><span class="s2">1j </span><span class="s1">* np.random.rand(</span><span class="s2">100</span><span class="s1">)</span>
        <span class="s1">unique</span><span class="s0">, </span><span class="s1">multiplicity = unique_roots(p</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(unique</span><span class="s0">, </span><span class="s1">[np.min(p)]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">assert_equal(multiplicity</span><span class="s0">, </span><span class="s1">[</span><span class="s2">100</span><span class="s1">])</span>
</pre>
</body>
</html>