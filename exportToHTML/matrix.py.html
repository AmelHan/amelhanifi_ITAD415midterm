<html>
<head>
<title>matrix.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
matrix.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Functions to visualize matrices of data.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib.collections </span><span class="s2">import </span><span class="s1">LineCollection</span>
<span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">gridspec</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">scipy.cluster </span><span class="s2">import </span><span class="s1">hierarchy</span>
    <span class="s1">_no_scipy = </span><span class="s2">False</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">_no_scipy = </span><span class="s2">True</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">cm</span>
<span class="s2">from </span><span class="s1">.axisgrid </span><span class="s2">import </span><span class="s1">Grid</span>
<span class="s2">from </span><span class="s1">._compat </span><span class="s2">import </span><span class="s1">get_colormap</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">despine</span><span class="s2">,</span>
    <span class="s1">axis_ticklabels_overlap</span><span class="s2">,</span>
    <span class="s1">relative_luminance</span><span class="s2">,</span>
    <span class="s1">to_utf8</span><span class="s2">,</span>
    <span class="s1">_draw_figure</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s1">__all__ = [</span><span class="s3">&quot;heatmap&quot;</span><span class="s2">, </span><span class="s3">&quot;clustermap&quot;</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_index_to_label(index):</span>
    <span class="s0">&quot;&quot;&quot;Convert a pandas index or multiindex to an axis label.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">pd.MultiIndex):</span>
        <span class="s2">return </span><span class="s3">&quot;-&quot;</span><span class="s1">.join(map(to_utf8</span><span class="s2">, </span><span class="s1">index.names))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">index.name</span>


<span class="s2">def </span><span class="s1">_index_to_ticklabels(index):</span>
    <span class="s0">&quot;&quot;&quot;Convert a pandas index or multiindex into ticklabels.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">pd.MultiIndex):</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;-&quot;</span><span class="s1">.join(map(to_utf8</span><span class="s2">, </span><span class="s1">i)) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">index.values]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">index.values</span>


<span class="s2">def </span><span class="s1">_convert_colors(colors):</span>
    <span class="s0">&quot;&quot;&quot;Convert either a list of colors or nested lists of colors to RGB.&quot;&quot;&quot;</span>
    <span class="s1">to_rgb = mpl.colors.to_rgb</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">to_rgb(colors[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s5"># If this works, there is only one level of colors</span>
        <span class="s2">return </span><span class="s1">list(map(to_rgb</span><span class="s2">, </span><span class="s1">colors))</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s5"># If we get here, we have nested lists</span>
        <span class="s2">return </span><span class="s1">[list(map(to_rgb</span><span class="s2">, </span><span class="s1">color_list)) </span><span class="s2">for </span><span class="s1">color_list </span><span class="s2">in </span><span class="s1">colors]</span>


<span class="s2">def </span><span class="s1">_matrix_mask(data</span><span class="s2">, </span><span class="s1">mask):</span>
    <span class="s0">&quot;&quot;&quot;Ensure that data and mask are compatible and add missing values. 
 
    Values will be plotted for cells where ``mask`` is ``False``. 
 
    ``data`` is expected to be a DataFrame; ``mask`` can be an array or 
    a DataFrame. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mask </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">mask = np.zeros(data.shape</span><span class="s2">, </span><span class="s1">bool)</span>

    <span class="s2">if </span><span class="s1">isinstance(mask</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s5"># For array masks, ensure that shape matches data then convert</span>
        <span class="s2">if </span><span class="s1">mask.shape != data.shape:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Mask must have the same shape as data.&quot;</span><span class="s1">)</span>

        <span class="s1">mask = pd.DataFrame(mask</span><span class="s2">,</span>
                            <span class="s1">index=data.index</span><span class="s2">,</span>
                            <span class="s1">columns=data.columns</span><span class="s2">,</span>
                            <span class="s1">dtype=bool)</span>

    <span class="s2">elif </span><span class="s1">isinstance(mask</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
        <span class="s5"># For DataFrame masks, ensure that semantic labels match data</span>
        <span class="s2">if not </span><span class="s1">mask.index.equals(data.index) \</span>
           <span class="s2">and </span><span class="s1">mask.columns.equals(data.columns):</span>
            <span class="s1">err = </span><span class="s3">&quot;Mask must have the same index and columns as data.&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(err)</span>

    <span class="s5"># Add any cells with missing data to the mask</span>
    <span class="s5"># This works around an issue where `plt.pcolormesh` doesn't represent</span>
    <span class="s5"># missing data properly</span>
    <span class="s1">mask = mask | pd.isnull(data)</span>

    <span class="s2">return </span><span class="s1">mask</span>


<span class="s2">class </span><span class="s1">_HeatMapper:</span>
    <span class="s0">&quot;&quot;&quot;Draw a heatmap plot of a matrix with nice labels and colormaps.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">cmap</span><span class="s2">, </span><span class="s1">center</span><span class="s2">, </span><span class="s1">robust</span><span class="s2">, </span><span class="s1">annot</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">,</span>
                 <span class="s1">annot_kws</span><span class="s2">, </span><span class="s1">cbar</span><span class="s2">, </span><span class="s1">cbar_kws</span><span class="s2">,</span>
                 <span class="s1">xticklabels=</span><span class="s2">True, </span><span class="s1">yticklabels=</span><span class="s2">True, </span><span class="s1">mask=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize the plotting object.&quot;&quot;&quot;</span>
        <span class="s5"># We always want to have a DataFrame with semantic information</span>
        <span class="s5"># and an ndarray to pass to matplotlib</span>
        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
            <span class="s1">plot_data = data.values</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">plot_data = np.asarray(data)</span>
            <span class="s1">data = pd.DataFrame(plot_data)</span>

        <span class="s5"># Validate the mask and convert to DataFrame</span>
        <span class="s1">mask = _matrix_mask(data</span><span class="s2">, </span><span class="s1">mask)</span>

        <span class="s1">plot_data = np.ma.masked_where(np.asarray(mask)</span><span class="s2">, </span><span class="s1">plot_data)</span>

        <span class="s5"># Get good names for the rows and columns</span>
        <span class="s1">xtickevery = </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">isinstance(xticklabels</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">xtickevery = xticklabels</span>
            <span class="s1">xticklabels = _index_to_ticklabels(data.columns)</span>
        <span class="s2">elif </span><span class="s1">xticklabels </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">xticklabels = _index_to_ticklabels(data.columns)</span>
        <span class="s2">elif </span><span class="s1">xticklabels </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s1">xticklabels = []</span>

        <span class="s1">ytickevery = </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">isinstance(yticklabels</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">ytickevery = yticklabels</span>
            <span class="s1">yticklabels = _index_to_ticklabels(data.index)</span>
        <span class="s2">elif </span><span class="s1">yticklabels </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">yticklabels = _index_to_ticklabels(data.index)</span>
        <span class="s2">elif </span><span class="s1">yticklabels </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s1">yticklabels = []</span>

        <span class="s2">if not </span><span class="s1">len(xticklabels):</span>
            <span class="s1">self.xticks = []</span>
            <span class="s1">self.xticklabels = []</span>
        <span class="s2">elif </span><span class="s1">isinstance(xticklabels</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">xticklabels == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">self.xticks = </span><span class="s3">&quot;auto&quot;</span>
            <span class="s1">self.xticklabels = _index_to_ticklabels(data.columns)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.xticks</span><span class="s2">, </span><span class="s1">self.xticklabels = self._skip_ticks(xticklabels</span><span class="s2">,</span>
                                                             <span class="s1">xtickevery)</span>

        <span class="s2">if not </span><span class="s1">len(yticklabels):</span>
            <span class="s1">self.yticks = []</span>
            <span class="s1">self.yticklabels = []</span>
        <span class="s2">elif </span><span class="s1">isinstance(yticklabels</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">yticklabels == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">self.yticks = </span><span class="s3">&quot;auto&quot;</span>
            <span class="s1">self.yticklabels = _index_to_ticklabels(data.index)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.yticks</span><span class="s2">, </span><span class="s1">self.yticklabels = self._skip_ticks(yticklabels</span><span class="s2">,</span>
                                                             <span class="s1">ytickevery)</span>

        <span class="s5"># Get good names for the axis labels</span>
        <span class="s1">xlabel = _index_to_label(data.columns)</span>
        <span class="s1">ylabel = _index_to_label(data.index)</span>
        <span class="s1">self.xlabel = xlabel </span><span class="s2">if </span><span class="s1">xlabel </span><span class="s2">is not None else </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self.ylabel = ylabel </span><span class="s2">if </span><span class="s1">ylabel </span><span class="s2">is not None else </span><span class="s3">&quot;&quot;</span>

        <span class="s5"># Determine good default values for the colormapping</span>
        <span class="s1">self._determine_cmap_params(plot_data</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">,</span>
                                    <span class="s1">cmap</span><span class="s2">, </span><span class="s1">center</span><span class="s2">, </span><span class="s1">robust)</span>

        <span class="s5"># Sort out the annotations</span>
        <span class="s2">if </span><span class="s1">annot </span><span class="s2">is None or </span><span class="s1">annot </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s1">annot = </span><span class="s2">False</span>
            <span class="s1">annot_data = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(annot</span><span class="s2">, </span><span class="s1">bool):</span>
                <span class="s1">annot_data = plot_data</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">annot_data = np.asarray(annot)</span>
                <span class="s2">if </span><span class="s1">annot_data.shape != plot_data.shape:</span>
                    <span class="s1">err = </span><span class="s3">&quot;`data` and `annot` must have same shape.&quot;</span>
                    <span class="s2">raise </span><span class="s1">ValueError(err)</span>
            <span class="s1">annot = </span><span class="s2">True</span>

        <span class="s5"># Save other attributes to the object</span>
        <span class="s1">self.data = data</span>
        <span class="s1">self.plot_data = plot_data</span>

        <span class="s1">self.annot = annot</span>
        <span class="s1">self.annot_data = annot_data</span>

        <span class="s1">self.fmt = fmt</span>
        <span class="s1">self.annot_kws = {} </span><span class="s2">if </span><span class="s1">annot_kws </span><span class="s2">is None else </span><span class="s1">annot_kws.copy()</span>
        <span class="s1">self.cbar = cbar</span>
        <span class="s1">self.cbar_kws = {} </span><span class="s2">if </span><span class="s1">cbar_kws </span><span class="s2">is None else </span><span class="s1">cbar_kws.copy()</span>

    <span class="s2">def </span><span class="s1">_determine_cmap_params(self</span><span class="s2">, </span><span class="s1">plot_data</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">,</span>
                               <span class="s1">cmap</span><span class="s2">, </span><span class="s1">center</span><span class="s2">, </span><span class="s1">robust):</span>
        <span class="s0">&quot;&quot;&quot;Use some heuristics to set good defaults for colorbar and range.&quot;&quot;&quot;</span>

        <span class="s5"># plot_data is a np.ma.array instance</span>
        <span class="s1">calc_data = plot_data.astype(float).filled(np.nan)</span>
        <span class="s2">if </span><span class="s1">vmin </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">robust:</span>
                <span class="s1">vmin = np.nanpercentile(calc_data</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">vmin = np.nanmin(calc_data)</span>
        <span class="s2">if </span><span class="s1">vmax </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">robust:</span>
                <span class="s1">vmax = np.nanpercentile(calc_data</span><span class="s2">, </span><span class="s4">98</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">vmax = np.nanmax(calc_data)</span>
        <span class="s1">self.vmin</span><span class="s2">, </span><span class="s1">self.vmax = vmin</span><span class="s2">, </span><span class="s1">vmax</span>

        <span class="s5"># Choose default colormaps if not provided</span>
        <span class="s2">if </span><span class="s1">cmap </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">center </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.cmap = cm.rocket</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.cmap = cm.icefire</span>
        <span class="s2">elif </span><span class="s1">isinstance(cmap</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">self.cmap = get_colormap(cmap)</span>
        <span class="s2">elif </span><span class="s1">isinstance(cmap</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">self.cmap = mpl.colors.ListedColormap(cmap)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.cmap = cmap</span>

        <span class="s5"># Recenter a divergent colormap</span>
        <span class="s2">if </span><span class="s1">center </span><span class="s2">is not None</span><span class="s1">:</span>

            <span class="s5"># Copy bad values</span>
            <span class="s5"># in mpl&lt;3.2 only masked values are honored with &quot;bad&quot; color spec</span>
            <span class="s5"># (see https://github.com/matplotlib/matplotlib/pull/14257)</span>
            <span class="s1">bad = self.cmap(np.ma.masked_invalid([np.nan]))[</span><span class="s4">0</span><span class="s1">]</span>

            <span class="s5"># under/over values are set for sure when cmap extremes</span>
            <span class="s5"># do not map to the same color as +-inf</span>
            <span class="s1">under = self.cmap(-np.inf)</span>
            <span class="s1">over = self.cmap(np.inf)</span>
            <span class="s1">under_set = under != self.cmap(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">over_set = over != self.cmap(self.cmap.N - </span><span class="s4">1</span><span class="s1">)</span>

            <span class="s1">vrange = max(vmax - center</span><span class="s2">, </span><span class="s1">center - vmin)</span>
            <span class="s1">normlize = mpl.colors.Normalize(center - vrange</span><span class="s2">, </span><span class="s1">center + vrange)</span>
            <span class="s1">cmin</span><span class="s2">, </span><span class="s1">cmax = normlize([vmin</span><span class="s2">, </span><span class="s1">vmax])</span>
            <span class="s1">cc = np.linspace(cmin</span><span class="s2">, </span><span class="s1">cmax</span><span class="s2">, </span><span class="s4">256</span><span class="s1">)</span>
            <span class="s1">self.cmap = mpl.colors.ListedColormap(self.cmap(cc))</span>
            <span class="s1">self.cmap.set_bad(bad)</span>
            <span class="s2">if </span><span class="s1">under_set:</span>
                <span class="s1">self.cmap.set_under(under)</span>
            <span class="s2">if </span><span class="s1">over_set:</span>
                <span class="s1">self.cmap.set_over(over)</span>

    <span class="s2">def </span><span class="s1">_annotate_heatmap(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">mesh):</span>
        <span class="s0">&quot;&quot;&quot;Add textual labels with the value in each cell.&quot;&quot;&quot;</span>
        <span class="s1">mesh.update_scalarmappable()</span>
        <span class="s1">height</span><span class="s2">, </span><span class="s1">width = self.annot_data.shape</span>
        <span class="s1">xpos</span><span class="s2">, </span><span class="s1">ypos = np.meshgrid(np.arange(width) + </span><span class="s4">.5</span><span class="s2">, </span><span class="s1">np.arange(height) + </span><span class="s4">.5</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">zip(xpos.flat</span><span class="s2">, </span><span class="s1">ypos.flat</span><span class="s2">,</span>
                                       <span class="s1">mesh.get_array().flat</span><span class="s2">, </span><span class="s1">mesh.get_facecolors()</span><span class="s2">,</span>
                                       <span class="s1">self.annot_data.flat):</span>
            <span class="s2">if </span><span class="s1">m </span><span class="s2">is not </span><span class="s1">np.ma.masked:</span>
                <span class="s1">lum = relative_luminance(color)</span>
                <span class="s1">text_color = </span><span class="s3">&quot;.15&quot; </span><span class="s2">if </span><span class="s1">lum &gt; </span><span class="s4">.408 </span><span class="s2">else </span><span class="s3">&quot;w&quot;</span>
                <span class="s1">annotation = (</span><span class="s3">&quot;{:&quot; </span><span class="s1">+ self.fmt + </span><span class="s3">&quot;}&quot;</span><span class="s1">).format(val)</span>
                <span class="s1">text_kwargs = dict(color=text_color</span><span class="s2">, </span><span class="s1">ha=</span><span class="s3">&quot;center&quot;</span><span class="s2">, </span><span class="s1">va=</span><span class="s3">&quot;center&quot;</span><span class="s1">)</span>
                <span class="s1">text_kwargs.update(self.annot_kws)</span>
                <span class="s1">ax.text(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">**text_kwargs)</span>

    <span class="s2">def </span><span class="s1">_skip_ticks(self</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">tickevery):</span>
        <span class="s0">&quot;&quot;&quot;Return ticks and labels at evenly spaced intervals.&quot;&quot;&quot;</span>
        <span class="s1">n = len(labels)</span>
        <span class="s2">if </span><span class="s1">tickevery == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">ticks</span><span class="s2">, </span><span class="s1">labels = []</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s2">elif </span><span class="s1">tickevery == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">ticks</span><span class="s2">, </span><span class="s1">labels = np.arange(n) + </span><span class="s4">.5</span><span class="s2">, </span><span class="s1">labels</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">step = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">tickevery</span>
            <span class="s1">ticks = np.arange(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">step) + </span><span class="s4">.5</span>
            <span class="s1">labels = labels[start:end:step]</span>
        <span class="s2">return </span><span class="s1">ticks</span><span class="s2">, </span><span class="s1">labels</span>

    <span class="s2">def </span><span class="s1">_auto_ticks(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s0">&quot;&quot;&quot;Determine ticks and ticklabels that minimize overlap.&quot;&quot;&quot;</span>
        <span class="s1">transform = ax.figure.dpi_scale_trans.inverted()</span>
        <span class="s1">bbox = ax.get_window_extent().transformed(transform)</span>
        <span class="s1">size = [bbox.width</span><span class="s2">, </span><span class="s1">bbox.height][axis]</span>
        <span class="s1">axis = [ax.xaxis</span><span class="s2">, </span><span class="s1">ax.yaxis][axis]</span>
        <span class="s1">tick</span><span class="s2">, </span><span class="s1">= axis.set_ticks([</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">fontsize = tick.label1.get_size()</span>
        <span class="s1">max_ticks = int(size // (fontsize / </span><span class="s4">72</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">max_ticks &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s1">tick_every = len(labels) // max_ticks + </span><span class="s4">1</span>
        <span class="s1">tick_every = </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">tick_every == </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">tick_every</span>
        <span class="s1">ticks</span><span class="s2">, </span><span class="s1">labels = self._skip_ticks(labels</span><span class="s2">, </span><span class="s1">tick_every)</span>
        <span class="s2">return </span><span class="s1">ticks</span><span class="s2">, </span><span class="s1">labels</span>

    <span class="s2">def </span><span class="s1">plot(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">cax</span><span class="s2">, </span><span class="s1">kws):</span>
        <span class="s0">&quot;&quot;&quot;Draw the heatmap on the provided Axes.&quot;&quot;&quot;</span>
        <span class="s5"># Remove all the Axes spines</span>
        <span class="s1">despine(ax=ax</span><span class="s2">, </span><span class="s1">left=</span><span class="s2">True, </span><span class="s1">bottom=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s5"># setting vmin/vmax in addition to norm is deprecated</span>
        <span class="s5"># so avoid setting if norm is set</span>
        <span class="s2">if </span><span class="s1">kws.get(</span><span class="s3">&quot;norm&quot;</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">kws.setdefault(</span><span class="s3">&quot;vmin&quot;</span><span class="s2">, </span><span class="s1">self.vmin)</span>
            <span class="s1">kws.setdefault(</span><span class="s3">&quot;vmax&quot;</span><span class="s2">, </span><span class="s1">self.vmax)</span>

        <span class="s5"># Draw the heatmap</span>
        <span class="s1">mesh = ax.pcolormesh(self.plot_data</span><span class="s2">, </span><span class="s1">cmap=self.cmap</span><span class="s2">, </span><span class="s1">**kws)</span>

        <span class="s5"># Set the axis limits</span>
        <span class="s1">ax.set(xlim=(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">self.data.shape[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">ylim=(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">self.data.shape[</span><span class="s4">0</span><span class="s1">]))</span>

        <span class="s5"># Invert the y axis to show the plot in matrix form</span>
        <span class="s1">ax.invert_yaxis()</span>

        <span class="s5"># Possibly add a colorbar</span>
        <span class="s2">if </span><span class="s1">self.cbar:</span>
            <span class="s1">cb = ax.figure.colorbar(mesh</span><span class="s2">, </span><span class="s1">cax</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">**self.cbar_kws)</span>
            <span class="s1">cb.outline.set_linewidth(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s5"># If rasterized is passed to pcolormesh, also rasterize the</span>
            <span class="s5"># colorbar to avoid white lines on the PDF rendering</span>
            <span class="s2">if </span><span class="s1">kws.get(</span><span class="s3">'rasterized'</span><span class="s2">, False</span><span class="s1">):</span>
                <span class="s1">cb.solids.set_rasterized(</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s5"># Add row and column labels</span>
        <span class="s2">if </span><span class="s1">isinstance(self.xticks</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">self.xticks == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">xticks</span><span class="s2">, </span><span class="s1">xticklabels = self._auto_ticks(ax</span><span class="s2">, </span><span class="s1">self.xticklabels</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xticks</span><span class="s2">, </span><span class="s1">xticklabels = self.xticks</span><span class="s2">, </span><span class="s1">self.xticklabels</span>

        <span class="s2">if </span><span class="s1">isinstance(self.yticks</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">self.yticks == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">yticks</span><span class="s2">, </span><span class="s1">yticklabels = self._auto_ticks(ax</span><span class="s2">, </span><span class="s1">self.yticklabels</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">yticks</span><span class="s2">, </span><span class="s1">yticklabels = self.yticks</span><span class="s2">, </span><span class="s1">self.yticklabels</span>

        <span class="s1">ax.set(xticks=xticks</span><span class="s2">, </span><span class="s1">yticks=yticks)</span>
        <span class="s1">xtl = ax.set_xticklabels(xticklabels)</span>
        <span class="s1">ytl = ax.set_yticklabels(yticklabels</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s3">&quot;vertical&quot;</span><span class="s1">)</span>
        <span class="s1">plt.setp(ytl</span><span class="s2">, </span><span class="s1">va=</span><span class="s3">&quot;center&quot;</span><span class="s1">)  </span><span class="s5"># GH2484</span>

        <span class="s5"># Possibly rotate them if they overlap</span>
        <span class="s1">_draw_figure(ax.figure)</span>

        <span class="s2">if </span><span class="s1">axis_ticklabels_overlap(xtl):</span>
            <span class="s1">plt.setp(xtl</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s3">&quot;vertical&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">axis_ticklabels_overlap(ytl):</span>
            <span class="s1">plt.setp(ytl</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s3">&quot;horizontal&quot;</span><span class="s1">)</span>

        <span class="s5"># Add the axis labels</span>
        <span class="s1">ax.set(xlabel=self.xlabel</span><span class="s2">, </span><span class="s1">ylabel=self.ylabel)</span>

        <span class="s5"># Annotate the cells with the formatted values</span>
        <span class="s2">if </span><span class="s1">self.annot:</span>
            <span class="s1">self._annotate_heatmap(ax</span><span class="s2">, </span><span class="s1">mesh)</span>


<span class="s2">def </span><span class="s1">heatmap(</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
    <span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">cmap=</span><span class="s2">None, </span><span class="s1">center=</span><span class="s2">None, </span><span class="s1">robust=</span><span class="s2">False,</span>
    <span class="s1">annot=</span><span class="s2">None, </span><span class="s1">fmt=</span><span class="s3">&quot;.2g&quot;</span><span class="s2">, </span><span class="s1">annot_kws=</span><span class="s2">None,</span>
    <span class="s1">linewidths=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">linecolor=</span><span class="s3">&quot;white&quot;</span><span class="s2">,</span>
    <span class="s1">cbar=</span><span class="s2">True, </span><span class="s1">cbar_kws=</span><span class="s2">None, </span><span class="s1">cbar_ax=</span><span class="s2">None,</span>
    <span class="s1">square=</span><span class="s2">False, </span><span class="s1">xticklabels=</span><span class="s3">&quot;auto&quot;</span><span class="s2">, </span><span class="s1">yticklabels=</span><span class="s3">&quot;auto&quot;</span><span class="s2">,</span>
    <span class="s1">mask=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Plot rectangular data as a color-encoded matrix. 
 
    This is an Axes-level function and will draw the heatmap into the 
    currently-active Axes if none is provided to the ``ax`` argument.  Part of 
    this Axes space will be taken and used to plot a colormap, unless ``cbar`` 
    is False or a separate Axes is provided to ``cbar_ax``. 
 
    Parameters 
    ---------- 
    data : rectangular dataset 
        2D dataset that can be coerced into an ndarray. If a Pandas DataFrame 
        is provided, the index/column information will be used to label the 
        columns and rows. 
    vmin, vmax : floats, optional 
        Values to anchor the colormap, otherwise they are inferred from the 
        data and other keyword arguments. 
    cmap : matplotlib colormap name or object, or list of colors, optional 
        The mapping from data values to color space. If not provided, the 
        default will depend on whether ``center`` is set. 
    center : float, optional 
        The value at which to center the colormap when plotting divergent data. 
        Using this parameter will change the default ``cmap`` if none is 
        specified. 
    robust : bool, optional 
        If True and ``vmin`` or ``vmax`` are absent, the colormap range is 
        computed with robust quantiles instead of the extreme values. 
    annot : bool or rectangular dataset, optional 
        If True, write the data value in each cell. If an array-like with the 
        same shape as ``data``, then use this to annotate the heatmap instead 
        of the data. Note that DataFrames will match on position, not index. 
    fmt : str, optional 
        String formatting code to use when adding annotations. 
    annot_kws : dict of key, value mappings, optional 
        Keyword arguments for :meth:`matplotlib.axes.Axes.text` when ``annot`` 
        is True. 
    linewidths : float, optional 
        Width of the lines that will divide each cell. 
    linecolor : color, optional 
        Color of the lines that will divide each cell. 
    cbar : bool, optional 
        Whether to draw a colorbar. 
    cbar_kws : dict of key, value mappings, optional 
        Keyword arguments for :meth:`matplotlib.figure.Figure.colorbar`. 
    cbar_ax : matplotlib Axes, optional 
        Axes in which to draw the colorbar, otherwise take space from the 
        main Axes. 
    square : bool, optional 
        If True, set the Axes aspect to &quot;equal&quot; so each cell will be 
        square-shaped. 
    xticklabels, yticklabels : &quot;auto&quot;, bool, list-like, or int, optional 
        If True, plot the column names of the dataframe. If False, don't plot 
        the column names. If list-like, plot these alternate labels as the 
        xticklabels. If an integer, use the column names but plot only every 
        n label. If &quot;auto&quot;, try to densely plot non-overlapping labels. 
    mask : bool array or DataFrame, optional 
        If passed, data will not be shown in cells where ``mask`` is True. 
        Cells with missing values are automatically masked. 
    ax : matplotlib Axes, optional 
        Axes in which to draw the plot, otherwise use the currently-active 
        Axes. 
    kwargs : other keyword arguments 
        All other keyword arguments are passed to 
        :meth:`matplotlib.axes.Axes.pcolormesh`. 
 
    Returns 
    ------- 
    ax : matplotlib Axes 
        Axes object with the heatmap. 
 
    See Also 
    -------- 
    clustermap : Plot a matrix using hierarchical clustering to arrange the 
                 rows and columns. 
 
    Examples 
    -------- 
 
    .. include:: ../docstrings/heatmap.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Initialize the plotter object</span>
    <span class="s1">plotter = _HeatMapper(data</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">cmap</span><span class="s2">, </span><span class="s1">center</span><span class="s2">, </span><span class="s1">robust</span><span class="s2">, </span><span class="s1">annot</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">,</span>
                          <span class="s1">annot_kws</span><span class="s2">, </span><span class="s1">cbar</span><span class="s2">, </span><span class="s1">cbar_kws</span><span class="s2">, </span><span class="s1">xticklabels</span><span class="s2">,</span>
                          <span class="s1">yticklabels</span><span class="s2">, </span><span class="s1">mask)</span>

    <span class="s5"># Add the pcolormesh kwargs here</span>
    <span class="s1">kwargs[</span><span class="s3">&quot;linewidths&quot;</span><span class="s1">] = linewidths</span>
    <span class="s1">kwargs[</span><span class="s3">&quot;edgecolor&quot;</span><span class="s1">] = linecolor</span>

    <span class="s5"># Draw the plot and return the Axes</span>
    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>
    <span class="s2">if </span><span class="s1">square:</span>
        <span class="s1">ax.set_aspect(</span><span class="s3">&quot;equal&quot;</span><span class="s1">)</span>
    <span class="s1">plotter.plot(ax</span><span class="s2">, </span><span class="s1">cbar_ax</span><span class="s2">, </span><span class="s1">kwargs)</span>
    <span class="s2">return </span><span class="s1">ax</span>


<span class="s2">class </span><span class="s1">_DendrogramPlotter:</span>
    <span class="s0">&quot;&quot;&quot;Object for drawing tree of similarities between data rows/columns&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">linkage</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">rotate):</span>
        <span class="s0">&quot;&quot;&quot;Plot a dendrogram of the relationships between the columns of data 
 
        Parameters 
        ---------- 
        data : pandas.DataFrame 
            Rectangular data 
        &quot;&quot;&quot;</span>
        <span class="s1">self.axis = axis</span>
        <span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">data = data.T</span>

        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
            <span class="s1">array = data.values</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">array = np.asarray(data)</span>
            <span class="s1">data = pd.DataFrame(array)</span>

        <span class="s1">self.array = array</span>
        <span class="s1">self.data = data</span>

        <span class="s1">self.shape = self.data.shape</span>
        <span class="s1">self.metric = metric</span>
        <span class="s1">self.method = method</span>
        <span class="s1">self.axis = axis</span>
        <span class="s1">self.label = label</span>
        <span class="s1">self.rotate = rotate</span>

        <span class="s2">if </span><span class="s1">linkage </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.linkage = self.calculated_linkage</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.linkage = linkage</span>
        <span class="s1">self.dendrogram = self.calculate_dendrogram()</span>

        <span class="s5"># Dendrogram ends are always at multiples of 5, who knows why</span>
        <span class="s1">ticks = </span><span class="s4">10 </span><span class="s1">* np.arange(self.data.shape[</span><span class="s4">0</span><span class="s1">]) + </span><span class="s4">5</span>

        <span class="s2">if </span><span class="s1">self.label:</span>
            <span class="s1">ticklabels = _index_to_ticklabels(self.data.index)</span>
            <span class="s1">ticklabels = [ticklabels[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.reordered_ind]</span>
            <span class="s2">if </span><span class="s1">self.rotate:</span>
                <span class="s1">self.xticks = []</span>
                <span class="s1">self.yticks = ticks</span>
                <span class="s1">self.xticklabels = []</span>

                <span class="s1">self.yticklabels = ticklabels</span>
                <span class="s1">self.ylabel = _index_to_label(self.data.index)</span>
                <span class="s1">self.xlabel = </span><span class="s3">''</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.xticks = ticks</span>
                <span class="s1">self.yticks = []</span>
                <span class="s1">self.xticklabels = ticklabels</span>
                <span class="s1">self.yticklabels = []</span>
                <span class="s1">self.ylabel = </span><span class="s3">''</span>
                <span class="s1">self.xlabel = _index_to_label(self.data.index)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.xticks</span><span class="s2">, </span><span class="s1">self.yticks = []</span><span class="s2">, </span><span class="s1">[]</span>
            <span class="s1">self.yticklabels</span><span class="s2">, </span><span class="s1">self.xticklabels = []</span><span class="s2">, </span><span class="s1">[]</span>
            <span class="s1">self.xlabel</span><span class="s2">, </span><span class="s1">self.ylabel = </span><span class="s3">''</span><span class="s2">, </span><span class="s3">''</span>

        <span class="s1">self.dependent_coord = self.dendrogram[</span><span class="s3">'dcoord'</span><span class="s1">]</span>
        <span class="s1">self.independent_coord = self.dendrogram[</span><span class="s3">'icoord'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_calculate_linkage_scipy(self):</span>
        <span class="s1">linkage = hierarchy.linkage(self.array</span><span class="s2">, </span><span class="s1">method=self.method</span><span class="s2">,</span>
                                    <span class="s1">metric=self.metric)</span>
        <span class="s2">return </span><span class="s1">linkage</span>

    <span class="s2">def </span><span class="s1">_calculate_linkage_fastcluster(self):</span>
        <span class="s2">import </span><span class="s1">fastcluster</span>
        <span class="s5"># Fastcluster has a memory-saving vectorized version, but only</span>
        <span class="s5"># with certain linkage methods, and mostly with euclidean metric</span>
        <span class="s5"># vector_methods = ('single', 'centroid', 'median', 'ward')</span>
        <span class="s1">euclidean_methods = (</span><span class="s3">'centroid'</span><span class="s2">, </span><span class="s3">'median'</span><span class="s2">, </span><span class="s3">'ward'</span><span class="s1">)</span>
        <span class="s1">euclidean = self.metric == </span><span class="s3">'euclidean' </span><span class="s2">and </span><span class="s1">self.method </span><span class="s2">in </span><span class="s1">\</span>
            <span class="s1">euclidean_methods</span>
        <span class="s2">if </span><span class="s1">euclidean </span><span class="s2">or </span><span class="s1">self.method == </span><span class="s3">'single'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">fastcluster.linkage_vector(self.array</span><span class="s2">,</span>
                                              <span class="s1">method=self.method</span><span class="s2">,</span>
                                              <span class="s1">metric=self.metric)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">linkage = fastcluster.linkage(self.array</span><span class="s2">, </span><span class="s1">method=self.method</span><span class="s2">,</span>
                                          <span class="s1">metric=self.metric)</span>
            <span class="s2">return </span><span class="s1">linkage</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">calculated_linkage(self):</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._calculate_linkage_fastcluster()</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">if </span><span class="s1">np.prod(self.shape) &gt;= </span><span class="s4">10000</span><span class="s1">:</span>
                <span class="s1">msg = (</span><span class="s3">&quot;Clustering large matrix with scipy. Installing &quot;</span>
                       <span class="s3">&quot;`fastcluster` may give better performance.&quot;</span><span class="s1">)</span>
                <span class="s1">warnings.warn(msg)</span>

        <span class="s2">return </span><span class="s1">self._calculate_linkage_scipy()</span>

    <span class="s2">def </span><span class="s1">calculate_dendrogram(self):</span>
        <span class="s0">&quot;&quot;&quot;Calculates a dendrogram based on the linkage matrix 
 
        Made a separate function, not a property because don't want to 
        recalculate the dendrogram every time it is accessed. 
 
        Returns 
        ------- 
        dendrogram : dict 
            Dendrogram dictionary as returned by scipy.cluster.hierarchy 
            .dendrogram. The important key-value pairing is 
            &quot;reordered_ind&quot; which indicates the re-ordering of the matrix 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">hierarchy.dendrogram(self.linkage</span><span class="s2">, </span><span class="s1">no_plot=</span><span class="s2">True,</span>
                                    <span class="s1">color_threshold=-np.inf)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reordered_ind(self):</span>
        <span class="s0">&quot;&quot;&quot;Indices of the matrix, reordered by the dendrogram&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.dendrogram[</span><span class="s3">'leaves'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">plot(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">tree_kws):</span>
        <span class="s0">&quot;&quot;&quot;Plots a dendrogram of the similarities between data on the axes 
 
        Parameters 
        ---------- 
        ax : matplotlib.axes.Axes 
            Axes object upon which the dendrogram is plotted 
 
        &quot;&quot;&quot;</span>
        <span class="s1">tree_kws = {} </span><span class="s2">if </span><span class="s1">tree_kws </span><span class="s2">is None else </span><span class="s1">tree_kws.copy()</span>
        <span class="s1">tree_kws.setdefault(</span><span class="s3">&quot;linewidths&quot;</span><span class="s2">, </span><span class="s4">.5</span><span class="s1">)</span>
        <span class="s1">tree_kws.setdefault(</span><span class="s3">&quot;colors&quot;</span><span class="s2">, </span><span class="s1">tree_kws.pop(</span><span class="s3">&quot;color&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.2</span><span class="s1">)))</span>

        <span class="s2">if </span><span class="s1">self.rotate </span><span class="s2">and </span><span class="s1">self.axis == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">coords = zip(self.dependent_coord</span><span class="s2">, </span><span class="s1">self.independent_coord)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">coords = zip(self.independent_coord</span><span class="s2">, </span><span class="s1">self.dependent_coord)</span>
        <span class="s1">lines = LineCollection([list(zip(x</span><span class="s2">, </span><span class="s1">y)) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">coords]</span><span class="s2">,</span>
                               <span class="s1">**tree_kws)</span>

        <span class="s1">ax.add_collection(lines)</span>
        <span class="s1">number_of_leaves = len(self.reordered_ind)</span>
        <span class="s1">max_dependent_coord = max(map(max</span><span class="s2">, </span><span class="s1">self.dependent_coord))</span>

        <span class="s2">if </span><span class="s1">self.rotate:</span>
            <span class="s1">ax.yaxis.set_ticks_position(</span><span class="s3">'right'</span><span class="s1">)</span>

            <span class="s5"># Constants 10 and 1.05 come from</span>
            <span class="s5"># `scipy.cluster.hierarchy._plot_dendrogram`</span>
            <span class="s1">ax.set_ylim(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">number_of_leaves * </span><span class="s4">10</span><span class="s1">)</span>
            <span class="s1">ax.set_xlim(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">max_dependent_coord * </span><span class="s4">1.05</span><span class="s1">)</span>

            <span class="s1">ax.invert_xaxis()</span>
            <span class="s1">ax.invert_yaxis()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Constants 10 and 1.05 come from</span>
            <span class="s5"># `scipy.cluster.hierarchy._plot_dendrogram`</span>
            <span class="s1">ax.set_xlim(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">number_of_leaves * </span><span class="s4">10</span><span class="s1">)</span>
            <span class="s1">ax.set_ylim(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">max_dependent_coord * </span><span class="s4">1.05</span><span class="s1">)</span>

        <span class="s1">despine(ax=ax</span><span class="s2">, </span><span class="s1">bottom=</span><span class="s2">True, </span><span class="s1">left=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">ax.set(xticks=self.xticks</span><span class="s2">, </span><span class="s1">yticks=self.yticks</span><span class="s2">,</span>
               <span class="s1">xlabel=self.xlabel</span><span class="s2">, </span><span class="s1">ylabel=self.ylabel)</span>
        <span class="s1">xtl = ax.set_xticklabels(self.xticklabels)</span>
        <span class="s1">ytl = ax.set_yticklabels(self.yticklabels</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s3">'vertical'</span><span class="s1">)</span>

        <span class="s5"># Force a draw of the plot to avoid matplotlib window error</span>
        <span class="s1">_draw_figure(ax.figure)</span>

        <span class="s2">if </span><span class="s1">len(ytl) &gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">axis_ticklabels_overlap(ytl):</span>
            <span class="s1">plt.setp(ytl</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s3">&quot;horizontal&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(xtl) &gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">axis_ticklabels_overlap(xtl):</span>
            <span class="s1">plt.setp(xtl</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s3">&quot;vertical&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">dendrogram(</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
    <span class="s1">linkage=</span><span class="s2">None, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">label=</span><span class="s2">True, </span><span class="s1">metric=</span><span class="s3">'euclidean'</span><span class="s2">,</span>
    <span class="s1">method=</span><span class="s3">'average'</span><span class="s2">, </span><span class="s1">rotate=</span><span class="s2">False, </span><span class="s1">tree_kws=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Draw a tree diagram of relationships within a matrix 
 
    Parameters 
    ---------- 
    data : pandas.DataFrame 
        Rectangular data 
    linkage : numpy.array, optional 
        Linkage matrix 
    axis : int, optional 
        Which axis to use to calculate linkage. 0 is rows, 1 is columns. 
    label : bool, optional 
        If True, label the dendrogram at leaves with column or row names 
    metric : str, optional 
        Distance metric. Anything valid for scipy.spatial.distance.pdist 
    method : str, optional 
        Linkage method to use. Anything valid for 
        scipy.cluster.hierarchy.linkage 
    rotate : bool, optional 
        When plotting the matrix, whether to rotate it 90 degrees 
        counter-clockwise, so the leaves face right 
    tree_kws : dict, optional 
        Keyword arguments for the ``matplotlib.collections.LineCollection`` 
        that is used for plotting the lines of the dendrogram tree. 
    ax : matplotlib axis, optional 
        Axis to plot on, otherwise uses current axis 
 
    Returns 
    ------- 
    dendrogramplotter : _DendrogramPlotter 
        A Dendrogram plotter object. 
 
    Notes 
    ----- 
    Access the reordered dendrogram indices with 
    dendrogramplotter.reordered_ind 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_no_scipy:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;dendrogram requires scipy to be installed&quot;</span><span class="s1">)</span>

    <span class="s1">plotter = _DendrogramPlotter(data</span><span class="s2">, </span><span class="s1">linkage=linkage</span><span class="s2">, </span><span class="s1">axis=axis</span><span class="s2">,</span>
                                 <span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">,</span>
                                 <span class="s1">label=label</span><span class="s2">, </span><span class="s1">rotate=rotate)</span>
    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s2">return </span><span class="s1">plotter.plot(ax=ax</span><span class="s2">, </span><span class="s1">tree_kws=tree_kws)</span>


<span class="s2">class </span><span class="s1">ClusterGrid(Grid):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">pivot_kws=</span><span class="s2">None, </span><span class="s1">z_score=</span><span class="s2">None, </span><span class="s1">standard_scale=</span><span class="s2">None,</span>
                 <span class="s1">figsize=</span><span class="s2">None, </span><span class="s1">row_colors=</span><span class="s2">None, </span><span class="s1">col_colors=</span><span class="s2">None, </span><span class="s1">mask=</span><span class="s2">None,</span>
                 <span class="s1">dendrogram_ratio=</span><span class="s2">None, </span><span class="s1">colors_ratio=</span><span class="s2">None, </span><span class="s1">cbar_pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Grid object for organizing clustered heatmap input on to axes&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">_no_scipy:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;ClusterGrid requires scipy to be available&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
            <span class="s1">self.data = data</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.data = pd.DataFrame(data)</span>

        <span class="s1">self.data2d = self.format_data(self.data</span><span class="s2">, </span><span class="s1">pivot_kws</span><span class="s2">, </span><span class="s1">z_score</span><span class="s2">,</span>
                                       <span class="s1">standard_scale)</span>

        <span class="s1">self.mask = _matrix_mask(self.data2d</span><span class="s2">, </span><span class="s1">mask)</span>

        <span class="s1">self._figure = plt.figure(figsize=figsize)</span>

        <span class="s1">self.row_colors</span><span class="s2">, </span><span class="s1">self.row_color_labels = \</span>
            <span class="s1">self._preprocess_colors(data</span><span class="s2">, </span><span class="s1">row_colors</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.col_colors</span><span class="s2">, </span><span class="s1">self.col_color_labels = \</span>
            <span class="s1">self._preprocess_colors(data</span><span class="s2">, </span><span class="s1">col_colors</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">row_dendrogram_ratio</span><span class="s2">, </span><span class="s1">col_dendrogram_ratio = dendrogram_ratio</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s1">row_dendrogram_ratio = col_dendrogram_ratio = dendrogram_ratio</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">row_colors_ratio</span><span class="s2">, </span><span class="s1">col_colors_ratio = colors_ratio</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s1">row_colors_ratio = col_colors_ratio = colors_ratio</span>

        <span class="s1">width_ratios = self.dim_ratios(self.row_colors</span><span class="s2">,</span>
                                       <span class="s1">row_dendrogram_ratio</span><span class="s2">,</span>
                                       <span class="s1">row_colors_ratio)</span>
        <span class="s1">height_ratios = self.dim_ratios(self.col_colors</span><span class="s2">,</span>
                                        <span class="s1">col_dendrogram_ratio</span><span class="s2">,</span>
                                        <span class="s1">col_colors_ratio)</span>

        <span class="s1">nrows = </span><span class="s4">2 </span><span class="s2">if </span><span class="s1">self.col_colors </span><span class="s2">is None else </span><span class="s4">3</span>
        <span class="s1">ncols = </span><span class="s4">2 </span><span class="s2">if </span><span class="s1">self.row_colors </span><span class="s2">is None else </span><span class="s4">3</span>

        <span class="s1">self.gs = gridspec.GridSpec(nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">,</span>
                                    <span class="s1">width_ratios=width_ratios</span><span class="s2">,</span>
                                    <span class="s1">height_ratios=height_ratios)</span>

        <span class="s1">self.ax_row_dendrogram = self._figure.add_subplot(self.gs[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">self.ax_col_dendrogram = self._figure.add_subplot(self.gs[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">self.ax_row_dendrogram.set_axis_off()</span>
        <span class="s1">self.ax_col_dendrogram.set_axis_off()</span>

        <span class="s1">self.ax_row_colors = </span><span class="s2">None</span>
        <span class="s1">self.ax_col_colors = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.row_colors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.ax_row_colors = self._figure.add_subplot(</span>
                <span class="s1">self.gs[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">self.col_colors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.ax_col_colors = self._figure.add_subplot(</span>
                <span class="s1">self.gs[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">self.ax_heatmap = self._figure.add_subplot(self.gs[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">cbar_pos </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.ax_cbar = self.cax = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Initialize the colorbar axes in the gridspec so that tight_layout</span>
            <span class="s5"># works. We will move it where it belongs later. This is a hack.</span>
            <span class="s1">self.ax_cbar = self._figure.add_subplot(self.gs[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">self.cax = self.ax_cbar  </span><span class="s5"># Backwards compatibility</span>
        <span class="s1">self.cbar_pos = cbar_pos</span>

        <span class="s1">self.dendrogram_row = </span><span class="s2">None</span>
        <span class="s1">self.dendrogram_col = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_preprocess_colors(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s0">&quot;&quot;&quot;Preprocess {row/col}_colors to extract labels and convert colors.&quot;&quot;&quot;</span>
        <span class="s1">labels = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">colors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(colors</span><span class="s2">, </span><span class="s1">(pd.DataFrame</span><span class="s2">, </span><span class="s1">pd.Series)):</span>

                <span class="s5"># If data is unindexed, raise</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">hasattr(data</span><span class="s2">, </span><span class="s3">&quot;index&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s2">not </span><span class="s1">hasattr(data</span><span class="s2">, </span><span class="s3">&quot;columns&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">axis == </span><span class="s4">1</span>
                <span class="s1">):</span>
                    <span class="s1">axis_name = </span><span class="s3">&quot;col&quot; </span><span class="s2">if </span><span class="s1">axis </span><span class="s2">else </span><span class="s3">&quot;row&quot;</span>
                    <span class="s1">msg = (</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">axis_name</span><span class="s2">}</span><span class="s3">_colors indices can't be matched with data &quot;</span>
                           <span class="s3">f&quot;indices. Provide </span><span class="s2">{</span><span class="s1">axis_name</span><span class="s2">}</span><span class="s3">_colors as a non-indexed &quot;</span>
                           <span class="s3">&quot;datatype, e.g. by using `.to_numpy()``&quot;</span><span class="s1">)</span>
                    <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

                <span class="s5"># Ensure colors match data indices</span>
                <span class="s2">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">colors = colors.reindex(data.index)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">colors = colors.reindex(data.columns)</span>

                <span class="s5"># Replace na's with white color</span>
                <span class="s5"># TODO We should set these to transparent instead</span>
                <span class="s1">colors = colors.astype(object).fillna(</span><span class="s3">'white'</span><span class="s1">)</span>

                <span class="s5"># Extract color values and labels from frame/series</span>
                <span class="s2">if </span><span class="s1">isinstance(colors</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
                    <span class="s1">labels = list(colors.columns)</span>
                    <span class="s1">colors = colors.T.values</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">colors.name </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">labels = [</span><span class="s3">&quot;&quot;</span><span class="s1">]</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">labels = [colors.name]</span>
                    <span class="s1">colors = colors.values</span>

            <span class="s1">colors = _convert_colors(colors)</span>

        <span class="s2">return </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">labels</span>

    <span class="s2">def </span><span class="s1">format_data(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">pivot_kws</span><span class="s2">, </span><span class="s1">z_score=</span><span class="s2">None,</span>
                    <span class="s1">standard_scale=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Extract variables from data or use directly.&quot;&quot;&quot;</span>

        <span class="s5"># Either the data is already in 2d matrix format, or need to do a pivot</span>
        <span class="s2">if </span><span class="s1">pivot_kws </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">data2d = data.pivot(**pivot_kws)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data2d = data</span>

        <span class="s2">if </span><span class="s1">z_score </span><span class="s2">is not None and </span><span class="s1">standard_scale </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'Cannot perform both z-scoring and standard-scaling on data'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">z_score </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">data2d = self.z_score(data2d</span><span class="s2">, </span><span class="s1">z_score)</span>
        <span class="s2">if </span><span class="s1">standard_scale </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">data2d = self.standard_scale(data2d</span><span class="s2">, </span><span class="s1">standard_scale)</span>
        <span class="s2">return </span><span class="s1">data2d</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">z_score(data2d</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Standarize the mean and variance of the data axis 
 
        Parameters 
        ---------- 
        data2d : pandas.DataFrame 
            Data to normalize 
        axis : int 
            Which axis to normalize across. If 0, normalize across rows, if 1, 
            normalize across columns. 
 
        Returns 
        ------- 
        normalized : pandas.DataFrame 
            Noramlized data with a mean of 0 and variance of 1 across the 
            specified axis. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">z_scored = data2d</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">z_scored = data2d.T</span>

        <span class="s1">z_scored = (z_scored - z_scored.mean()) / z_scored.std()</span>

        <span class="s2">if </span><span class="s1">axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">z_scored</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">z_scored.T</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">standard_scale(data2d</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Divide the data by the difference between the max and min 
 
        Parameters 
        ---------- 
        data2d : pandas.DataFrame 
            Data to normalize 
        axis : int 
            Which axis to normalize across. If 0, normalize across rows, if 1, 
            normalize across columns. 
 
        Returns 
        ------- 
        standardized : pandas.DataFrame 
            Noramlized data with a mean of 0 and variance of 1 across the 
            specified axis. 
 
        &quot;&quot;&quot;</span>
        <span class="s5"># Normalize these values to range from 0 to 1</span>
        <span class="s2">if </span><span class="s1">axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">standardized = data2d</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">standardized = data2d.T</span>

        <span class="s1">subtract = standardized.min()</span>
        <span class="s1">standardized = (standardized - subtract) / (</span>
            <span class="s1">standardized.max() - standardized.min())</span>

        <span class="s2">if </span><span class="s1">axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">standardized</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">standardized.T</span>

    <span class="s2">def </span><span class="s1">dim_ratios(self</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">dendrogram_ratio</span><span class="s2">, </span><span class="s1">colors_ratio):</span>
        <span class="s0">&quot;&quot;&quot;Get the proportions of the figure taken up by each axes.&quot;&quot;&quot;</span>
        <span class="s1">ratios = [dendrogram_ratio]</span>

        <span class="s2">if </span><span class="s1">colors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s5"># Colors are encoded as rgb, so there is an extra dimension</span>
            <span class="s2">if </span><span class="s1">np.ndim(colors) &gt; </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">n_colors = len(colors)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">n_colors = </span><span class="s4">1</span>

            <span class="s1">ratios += [n_colors * colors_ratio]</span>

        <span class="s5"># Add the ratio for the heatmap itself</span>
        <span class="s1">ratios.append(</span><span class="s4">1 </span><span class="s1">- sum(ratios))</span>

        <span class="s2">return </span><span class="s1">ratios</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">color_list_to_matrix_and_cmap(colors</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Turns a list of colors into a numpy matrix and matplotlib colormap 
 
        These arguments can now be plotted using heatmap(matrix, cmap) 
        and the provided colors will be plotted. 
 
        Parameters 
        ---------- 
        colors : list of matplotlib colors 
            Colors to label the rows or columns of a dataframe. 
        ind : list of ints 
            Ordering of the rows or columns, to reorder the original colors 
            by the clustered dendrogram order 
        axis : int 
            Which axis this is labeling 
 
        Returns 
        ------- 
        matrix : numpy.array 
            A numpy array of integer values, where each indexes into the cmap 
        cmap : matplotlib.colors.ListedColormap 
 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">mpl.colors.to_rgb(colors[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s5"># We have a 2D color structure</span>
            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = len(colors)</span><span class="s2">, </span><span class="s1">len(colors[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">if not </span><span class="s1">all(len(c) == n </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">colors[</span><span class="s4">1</span><span class="s1">:]):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Multiple side color vectors must have same size&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># We have one vector of colors</span>
            <span class="s1">m</span><span class="s2">, </span><span class="s1">n = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(colors)</span>
            <span class="s1">colors = [colors]</span>

        <span class="s5"># Map from unique colors to colormap index value</span>
        <span class="s1">unique_colors = {}</span>
        <span class="s1">matrix = np.zeros((m</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">int)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">inner </span><span class="s2">in </span><span class="s1">enumerate(colors):</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">color </span><span class="s2">in </span><span class="s1">enumerate(inner):</span>
                <span class="s1">idx = unique_colors.setdefault(color</span><span class="s2">, </span><span class="s1">len(unique_colors))</span>
                <span class="s1">matrix[i</span><span class="s2">, </span><span class="s1">j] = idx</span>

        <span class="s5"># Reorder for clustering and transpose for axis</span>
        <span class="s1">matrix = matrix[:</span><span class="s2">, </span><span class="s1">ind]</span>
        <span class="s2">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">matrix = matrix.T</span>

        <span class="s1">cmap = mpl.colors.ListedColormap(list(unique_colors))</span>
        <span class="s2">return </span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">cmap</span>

    <span class="s2">def </span><span class="s1">plot_dendrograms(self</span><span class="s2">, </span><span class="s1">row_cluster</span><span class="s2">, </span><span class="s1">col_cluster</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">method</span><span class="s2">,</span>
                         <span class="s1">row_linkage</span><span class="s2">, </span><span class="s1">col_linkage</span><span class="s2">, </span><span class="s1">tree_kws):</span>
        <span class="s5"># Plot the row dendrogram</span>
        <span class="s2">if </span><span class="s1">row_cluster:</span>
            <span class="s1">self.dendrogram_row = dendrogram(</span>
                <span class="s1">self.data2d</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">label=</span><span class="s2">False, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s2">,</span>
                <span class="s1">ax=self.ax_row_dendrogram</span><span class="s2">, </span><span class="s1">rotate=</span><span class="s2">True, </span><span class="s1">linkage=row_linkage</span><span class="s2">,</span>
                <span class="s1">tree_kws=tree_kws</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ax_row_dendrogram.set_xticks([])</span>
            <span class="s1">self.ax_row_dendrogram.set_yticks([])</span>
        <span class="s5"># PLot the column dendrogram</span>
        <span class="s2">if </span><span class="s1">col_cluster:</span>
            <span class="s1">self.dendrogram_col = dendrogram(</span>
                <span class="s1">self.data2d</span><span class="s2">, </span><span class="s1">metric=metric</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">label=</span><span class="s2">False,</span>
                <span class="s1">axis=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ax=self.ax_col_dendrogram</span><span class="s2">, </span><span class="s1">linkage=col_linkage</span><span class="s2">,</span>
                <span class="s1">tree_kws=tree_kws</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ax_col_dendrogram.set_xticks([])</span>
            <span class="s1">self.ax_col_dendrogram.set_yticks([])</span>
        <span class="s1">despine(ax=self.ax_row_dendrogram</span><span class="s2">, </span><span class="s1">bottom=</span><span class="s2">True, </span><span class="s1">left=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">despine(ax=self.ax_col_dendrogram</span><span class="s2">, </span><span class="s1">bottom=</span><span class="s2">True, </span><span class="s1">left=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_colors(self</span><span class="s2">, </span><span class="s1">xind</span><span class="s2">, </span><span class="s1">yind</span><span class="s2">, </span><span class="s1">**kws):</span>
        <span class="s0">&quot;&quot;&quot;Plots color labels between the dendrogram and the heatmap 
 
        Parameters 
        ---------- 
        heatmap_kws : dict 
            Keyword arguments heatmap 
 
        &quot;&quot;&quot;</span>
        <span class="s5"># Remove any custom colormap and centering</span>
        <span class="s5"># TODO this code has consistently caused problems when we</span>
        <span class="s5"># have missed kwargs that need to be excluded that it might</span>
        <span class="s5"># be better to rewrite *in*clusively.</span>
        <span class="s1">kws = kws.copy()</span>
        <span class="s1">kws.pop(</span><span class="s3">'cmap'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kws.pop(</span><span class="s3">'norm'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kws.pop(</span><span class="s3">'center'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kws.pop(</span><span class="s3">'annot'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kws.pop(</span><span class="s3">'vmin'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kws.pop(</span><span class="s3">'vmax'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kws.pop(</span><span class="s3">'robust'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kws.pop(</span><span class="s3">'xticklabels'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kws.pop(</span><span class="s3">'yticklabels'</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s5"># Plot the row colors</span>
        <span class="s2">if </span><span class="s1">self.row_colors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">matrix</span><span class="s2">, </span><span class="s1">cmap = self.color_list_to_matrix_and_cmap(</span>
                <span class="s1">self.row_colors</span><span class="s2">, </span><span class="s1">yind</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

            <span class="s5"># Get row_color labels</span>
            <span class="s2">if </span><span class="s1">self.row_color_labels </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">row_color_labels = self.row_color_labels</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">row_color_labels = </span><span class="s2">False</span>

            <span class="s1">heatmap(matrix</span><span class="s2">, </span><span class="s1">cmap=cmap</span><span class="s2">, </span><span class="s1">cbar=</span><span class="s2">False, </span><span class="s1">ax=self.ax_row_colors</span><span class="s2">,</span>
                    <span class="s1">xticklabels=row_color_labels</span><span class="s2">, </span><span class="s1">yticklabels=</span><span class="s2">False, </span><span class="s1">**kws)</span>

            <span class="s5"># Adjust rotation of labels</span>
            <span class="s2">if </span><span class="s1">row_color_labels </span><span class="s2">is not False</span><span class="s1">:</span>
                <span class="s1">plt.setp(self.ax_row_colors.get_xticklabels()</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s4">90</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">despine(self.ax_row_colors</span><span class="s2">, </span><span class="s1">left=</span><span class="s2">True, </span><span class="s1">bottom=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s5"># Plot the column colors</span>
        <span class="s2">if </span><span class="s1">self.col_colors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">matrix</span><span class="s2">, </span><span class="s1">cmap = self.color_list_to_matrix_and_cmap(</span>
                <span class="s1">self.col_colors</span><span class="s2">, </span><span class="s1">xind</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

            <span class="s5"># Get col_color labels</span>
            <span class="s2">if </span><span class="s1">self.col_color_labels </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">col_color_labels = self.col_color_labels</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">col_color_labels = </span><span class="s2">False</span>

            <span class="s1">heatmap(matrix</span><span class="s2">, </span><span class="s1">cmap=cmap</span><span class="s2">, </span><span class="s1">cbar=</span><span class="s2">False, </span><span class="s1">ax=self.ax_col_colors</span><span class="s2">,</span>
                    <span class="s1">xticklabels=</span><span class="s2">False, </span><span class="s1">yticklabels=col_color_labels</span><span class="s2">, </span><span class="s1">**kws)</span>

            <span class="s5"># Adjust rotation of labels, place on right side</span>
            <span class="s2">if </span><span class="s1">col_color_labels </span><span class="s2">is not False</span><span class="s1">:</span>
                <span class="s1">self.ax_col_colors.yaxis.tick_right()</span>
                <span class="s1">plt.setp(self.ax_col_colors.get_yticklabels()</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">despine(self.ax_col_colors</span><span class="s2">, </span><span class="s1">left=</span><span class="s2">True, </span><span class="s1">bottom=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_matrix(self</span><span class="s2">, </span><span class="s1">colorbar_kws</span><span class="s2">, </span><span class="s1">xind</span><span class="s2">, </span><span class="s1">yind</span><span class="s2">, </span><span class="s1">**kws):</span>
        <span class="s1">self.data2d = self.data2d.iloc[yind</span><span class="s2">, </span><span class="s1">xind]</span>
        <span class="s1">self.mask = self.mask.iloc[yind</span><span class="s2">, </span><span class="s1">xind]</span>

        <span class="s5"># Try to reorganize specified tick labels, if provided</span>
        <span class="s1">xtl = kws.pop(</span><span class="s3">&quot;xticklabels&quot;</span><span class="s2">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">xtl = np.asarray(xtl)[xind]</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">IndexError):</span>
            <span class="s2">pass</span>
        <span class="s1">ytl = kws.pop(</span><span class="s3">&quot;yticklabels&quot;</span><span class="s2">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">ytl = np.asarray(ytl)[yind]</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">IndexError):</span>
            <span class="s2">pass</span>

        <span class="s5"># Reorganize the annotations to match the heatmap</span>
        <span class="s1">annot = kws.pop(</span><span class="s3">&quot;annot&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">annot </span><span class="s2">is None or </span><span class="s1">annot </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(annot</span><span class="s2">, </span><span class="s1">bool):</span>
                <span class="s1">annot_data = self.data2d</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">annot_data = np.asarray(annot)</span>
                <span class="s2">if </span><span class="s1">annot_data.shape != self.data2d.shape:</span>
                    <span class="s1">err = </span><span class="s3">&quot;`data` and `annot` must have same shape.&quot;</span>
                    <span class="s2">raise </span><span class="s1">ValueError(err)</span>
                <span class="s1">annot_data = annot_data[yind][:</span><span class="s2">, </span><span class="s1">xind]</span>
            <span class="s1">annot = annot_data</span>

        <span class="s5"># Setting ax_cbar=None in clustermap call implies no colorbar</span>
        <span class="s1">kws.setdefault(</span><span class="s3">&quot;cbar&quot;</span><span class="s2">, </span><span class="s1">self.ax_cbar </span><span class="s2">is not None</span><span class="s1">)</span>
        <span class="s1">heatmap(self.data2d</span><span class="s2">, </span><span class="s1">ax=self.ax_heatmap</span><span class="s2">, </span><span class="s1">cbar_ax=self.ax_cbar</span><span class="s2">,</span>
                <span class="s1">cbar_kws=colorbar_kws</span><span class="s2">, </span><span class="s1">mask=self.mask</span><span class="s2">,</span>
                <span class="s1">xticklabels=xtl</span><span class="s2">, </span><span class="s1">yticklabels=ytl</span><span class="s2">, </span><span class="s1">annot=annot</span><span class="s2">, </span><span class="s1">**kws)</span>

        <span class="s1">ytl = self.ax_heatmap.get_yticklabels()</span>
        <span class="s1">ytl_rot = </span><span class="s2">None if not </span><span class="s1">ytl </span><span class="s2">else </span><span class="s1">ytl[</span><span class="s4">0</span><span class="s1">].get_rotation()</span>
        <span class="s1">self.ax_heatmap.yaxis.set_ticks_position(</span><span class="s3">'right'</span><span class="s1">)</span>
        <span class="s1">self.ax_heatmap.yaxis.set_label_position(</span><span class="s3">'right'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ytl_rot </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">ytl = self.ax_heatmap.get_yticklabels()</span>
            <span class="s1">plt.setp(ytl</span><span class="s2">, </span><span class="s1">rotation=ytl_rot)</span>

        <span class="s1">tight_params = dict(h_pad=</span><span class="s4">.02</span><span class="s2">, </span><span class="s1">w_pad=</span><span class="s4">.02</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.ax_cbar </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._figure.tight_layout(**tight_params)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Turn the colorbar axes off for tight layout so that its</span>
            <span class="s5"># ticks don't interfere with the rest of the plot layout.</span>
            <span class="s5"># Then move it.</span>
            <span class="s1">self.ax_cbar.set_axis_off()</span>
            <span class="s1">self._figure.tight_layout(**tight_params)</span>
            <span class="s1">self.ax_cbar.set_axis_on()</span>
            <span class="s1">self.ax_cbar.set_position(self.cbar_pos)</span>

    <span class="s2">def </span><span class="s1">plot(self</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">colorbar_kws</span><span class="s2">, </span><span class="s1">row_cluster</span><span class="s2">, </span><span class="s1">col_cluster</span><span class="s2">,</span>
             <span class="s1">row_linkage</span><span class="s2">, </span><span class="s1">col_linkage</span><span class="s2">, </span><span class="s1">tree_kws</span><span class="s2">, </span><span class="s1">**kws):</span>

        <span class="s5"># heatmap square=True sets the aspect ratio on the axes, but that is</span>
        <span class="s5"># not compatible with the multi-axes layout of clustergrid</span>
        <span class="s2">if </span><span class="s1">kws.get(</span><span class="s3">&quot;square&quot;</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">&quot;``square=True`` ignored in clustermap&quot;</span>
            <span class="s1">warnings.warn(msg)</span>
            <span class="s1">kws.pop(</span><span class="s3">&quot;square&quot;</span><span class="s1">)</span>

        <span class="s1">colorbar_kws = {} </span><span class="s2">if </span><span class="s1">colorbar_kws </span><span class="s2">is None else </span><span class="s1">colorbar_kws</span>

        <span class="s1">self.plot_dendrograms(row_cluster</span><span class="s2">, </span><span class="s1">col_cluster</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">method</span><span class="s2">,</span>
                              <span class="s1">row_linkage=row_linkage</span><span class="s2">, </span><span class="s1">col_linkage=col_linkage</span><span class="s2">,</span>
                              <span class="s1">tree_kws=tree_kws)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">xind = self.dendrogram_col.reordered_ind</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s1">xind = np.arange(self.data2d.shape[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">yind = self.dendrogram_row.reordered_ind</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s1">yind = np.arange(self.data2d.shape[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">self.plot_colors(xind</span><span class="s2">, </span><span class="s1">yind</span><span class="s2">, </span><span class="s1">**kws)</span>
        <span class="s1">self.plot_matrix(colorbar_kws</span><span class="s2">, </span><span class="s1">xind</span><span class="s2">, </span><span class="s1">yind</span><span class="s2">, </span><span class="s1">**kws)</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">clustermap(</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
    <span class="s1">pivot_kws=</span><span class="s2">None, </span><span class="s1">method=</span><span class="s3">'average'</span><span class="s2">, </span><span class="s1">metric=</span><span class="s3">'euclidean'</span><span class="s2">,</span>
    <span class="s1">z_score=</span><span class="s2">None, </span><span class="s1">standard_scale=</span><span class="s2">None, </span><span class="s1">figsize=(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">cbar_kws=</span><span class="s2">None, </span><span class="s1">row_cluster=</span><span class="s2">True, </span><span class="s1">col_cluster=</span><span class="s2">True,</span>
    <span class="s1">row_linkage=</span><span class="s2">None, </span><span class="s1">col_linkage=</span><span class="s2">None,</span>
    <span class="s1">row_colors=</span><span class="s2">None, </span><span class="s1">col_colors=</span><span class="s2">None, </span><span class="s1">mask=</span><span class="s2">None,</span>
    <span class="s1">dendrogram_ratio=</span><span class="s4">.2</span><span class="s2">, </span><span class="s1">colors_ratio=</span><span class="s4">0.03</span><span class="s2">,</span>
    <span class="s1">cbar_pos=(</span><span class="s4">.02</span><span class="s2">, </span><span class="s4">.8</span><span class="s2">, </span><span class="s4">.05</span><span class="s2">, </span><span class="s4">.18</span><span class="s1">)</span><span class="s2">, </span><span class="s1">tree_kws=</span><span class="s2">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Plot a matrix dataset as a hierarchically-clustered heatmap. 
 
    This function requires scipy to be available. 
 
    Parameters 
    ---------- 
    data : 2D array-like 
        Rectangular data for clustering. Cannot contain NAs. 
    pivot_kws : dict, optional 
        If `data` is a tidy dataframe, can provide keyword arguments for 
        pivot to create a rectangular dataframe. 
    method : str, optional 
        Linkage method to use for calculating clusters. See 
        :func:`scipy.cluster.hierarchy.linkage` documentation for more 
        information. 
    metric : str, optional 
        Distance metric to use for the data. See 
        :func:`scipy.spatial.distance.pdist` documentation for more options. 
        To use different metrics (or methods) for rows and columns, you may 
        construct each linkage matrix yourself and provide them as 
        `{row,col}_linkage`. 
    z_score : int or None, optional 
        Either 0 (rows) or 1 (columns). Whether or not to calculate z-scores 
        for the rows or the columns. Z scores are: z = (x - mean)/std, so 
        values in each row (column) will get the mean of the row (column) 
        subtracted, then divided by the standard deviation of the row (column). 
        This ensures that each row (column) has mean of 0 and variance of 1. 
    standard_scale : int or None, optional 
        Either 0 (rows) or 1 (columns). Whether or not to standardize that 
        dimension, meaning for each row or column, subtract the minimum and 
        divide each by its maximum. 
    figsize : tuple of (width, height), optional 
        Overall size of the figure. 
    cbar_kws : dict, optional 
        Keyword arguments to pass to `cbar_kws` in :func:`heatmap`, e.g. to 
        add a label to the colorbar. 
    {row,col}_cluster : bool, optional 
        If ``True``, cluster the {rows, columns}. 
    {row,col}_linkage : :class:`numpy.ndarray`, optional 
        Precomputed linkage matrix for the rows or columns. See 
        :func:`scipy.cluster.hierarchy.linkage` for specific formats. 
    {row,col}_colors : list-like or pandas DataFrame/Series, optional 
        List of colors to label for either the rows or columns. Useful to evaluate 
        whether samples within a group are clustered together. Can use nested lists or 
        DataFrame for multiple color levels of labeling. If given as a 
        :class:`pandas.DataFrame` or :class:`pandas.Series`, labels for the colors are 
        extracted from the DataFrames column names or from the name of the Series. 
        DataFrame/Series colors are also matched to the data by their index, ensuring 
        colors are drawn in the correct order. 
    mask : bool array or DataFrame, optional 
        If passed, data will not be shown in cells where `mask` is True. 
        Cells with missing values are automatically masked. Only used for 
        visualizing, not for calculating. 
    {dendrogram,colors}_ratio : float, or pair of floats, optional 
        Proportion of the figure size devoted to the two marginal elements. If 
        a pair is given, they correspond to (row, col) ratios. 
    cbar_pos : tuple of (left, bottom, width, height), optional 
        Position of the colorbar axes in the figure. Setting to ``None`` will 
        disable the colorbar. 
    tree_kws : dict, optional 
        Parameters for the :class:`matplotlib.collections.LineCollection` 
        that is used to plot the lines of the dendrogram tree. 
    kwargs : other keyword arguments 
        All other keyword arguments are passed to :func:`heatmap`. 
 
    Returns 
    ------- 
    :class:`ClusterGrid` 
        A :class:`ClusterGrid` instance. 
 
    See Also 
    -------- 
    heatmap : Plot rectangular data as a color-encoded matrix. 
 
    Notes 
    ----- 
    The returned object has a ``savefig`` method that should be used if you 
    want to save the figure object without clipping the dendrograms. 
 
    To access the reordered row indices, use: 
    ``clustergrid.dendrogram_row.reordered_ind`` 
 
    Column indices, use: 
    ``clustergrid.dendrogram_col.reordered_ind`` 
 
    Examples 
    -------- 
 
    .. include:: ../docstrings/clustermap.rst 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_no_scipy:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;clustermap requires scipy to be available&quot;</span><span class="s1">)</span>

    <span class="s1">plotter = ClusterGrid(data</span><span class="s2">, </span><span class="s1">pivot_kws=pivot_kws</span><span class="s2">, </span><span class="s1">figsize=figsize</span><span class="s2">,</span>
                          <span class="s1">row_colors=row_colors</span><span class="s2">, </span><span class="s1">col_colors=col_colors</span><span class="s2">,</span>
                          <span class="s1">z_score=z_score</span><span class="s2">, </span><span class="s1">standard_scale=standard_scale</span><span class="s2">,</span>
                          <span class="s1">mask=mask</span><span class="s2">, </span><span class="s1">dendrogram_ratio=dendrogram_ratio</span><span class="s2">,</span>
                          <span class="s1">colors_ratio=colors_ratio</span><span class="s2">, </span><span class="s1">cbar_pos=cbar_pos)</span>

    <span class="s2">return </span><span class="s1">plotter.plot(metric=metric</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">,</span>
                        <span class="s1">colorbar_kws=cbar_kws</span><span class="s2">,</span>
                        <span class="s1">row_cluster=row_cluster</span><span class="s2">, </span><span class="s1">col_cluster=col_cluster</span><span class="s2">,</span>
                        <span class="s1">row_linkage=row_linkage</span><span class="s2">, </span><span class="s1">col_linkage=col_linkage</span><span class="s2">,</span>
                        <span class="s1">tree_kws=tree_kws</span><span class="s2">, </span><span class="s1">**kwargs)</span>
</pre>
</body>
</html>