<html>
<head>
<title>categorical.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
categorical.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>
<span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">dedent</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">colorsys </span><span class="s0">import </span><span class="s1">rgb_to_hls</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib.collections </span><span class="s0">import </span><span class="s1">PatchCollection</span>
<span class="s0">from </span><span class="s1">matplotlib.patches </span><span class="s0">import </span><span class="s1">Rectangle</span>
<span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>

<span class="s0">from </span><span class="s1">seaborn._core.typing </span><span class="s0">import </span><span class="s1">default</span><span class="s0">, </span><span class="s1">deprecated</span>
<span class="s0">from </span><span class="s1">seaborn._base </span><span class="s0">import </span><span class="s1">VectorPlotter</span><span class="s0">, </span><span class="s1">infer_orient</span><span class="s0">, </span><span class="s1">categorical_order</span>
<span class="s0">from </span><span class="s1">seaborn._stats.density </span><span class="s0">import </span><span class="s1">KDE</span>
<span class="s0">from </span><span class="s1">seaborn </span><span class="s0">import </span><span class="s1">utils</span>
<span class="s0">from </span><span class="s1">seaborn.utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">desaturate</span><span class="s0">,</span>
    <span class="s1">_check_argument</span><span class="s0">,</span>
    <span class="s1">_draw_figure</span><span class="s0">,</span>
    <span class="s1">_default_color</span><span class="s0">,</span>
    <span class="s1">_get_patch_legend_artist</span><span class="s0">,</span>
    <span class="s1">_get_transform_functions</span><span class="s0">,</span>
    <span class="s1">_normalize_kwargs</span><span class="s0">,</span>
    <span class="s1">_scatter_legend_artist</span><span class="s0">,</span>
    <span class="s1">_version_predates</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">seaborn._compat </span><span class="s0">import </span><span class="s1">MarkerStyle</span>
<span class="s0">from </span><span class="s1">seaborn._statistics </span><span class="s0">import </span><span class="s1">EstimateAggregator</span><span class="s0">, </span><span class="s1">LetterValues</span>
<span class="s0">from </span><span class="s1">seaborn.palettes </span><span class="s0">import </span><span class="s1">light_palette</span>
<span class="s0">from </span><span class="s1">seaborn.axisgrid </span><span class="s0">import </span><span class="s1">FacetGrid</span><span class="s0">, </span><span class="s1">_facet_docs</span>


<span class="s1">__all__ = [</span>
    <span class="s2">&quot;catplot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stripplot&quot;</span><span class="s0">, </span><span class="s2">&quot;swarmplot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boxplot&quot;</span><span class="s0">, </span><span class="s2">&quot;violinplot&quot;</span><span class="s0">, </span><span class="s2">&quot;boxenplot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointplot&quot;</span><span class="s0">, </span><span class="s2">&quot;barplot&quot;</span><span class="s0">, </span><span class="s2">&quot;countplot&quot;</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s0">class </span><span class="s1">_CategoricalPlotter(VectorPlotter):</span>

    <span class="s1">wide_structure = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;@columns&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;@values&quot;</span><span class="s0">, </span><span class="s2">&quot;hue&quot;</span><span class="s1">: </span><span class="s2">&quot;@columns&quot;</span><span class="s1">}</span>
    <span class="s1">flat_structure = {</span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;@values&quot;</span><span class="s1">}</span>

    <span class="s1">_legend_attributes = [</span><span class="s2">&quot;color&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">data=</span><span class="s0">None,</span>
        <span class="s1">variables={}</span><span class="s0">,</span>
        <span class="s1">order=</span><span class="s0">None,</span>
        <span class="s1">orient=</span><span class="s0">None,</span>
        <span class="s1">require_numeric=</span><span class="s0">False,</span>
        <span class="s1">color=</span><span class="s0">None,</span>
        <span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">super().__init__(data=data</span><span class="s0">, </span><span class="s1">variables=variables)</span>

        <span class="s3"># This method takes care of some bookkeeping that is necessary because the</span>
        <span class="s3"># original categorical plots (prior to the 2021 refactor) had some rules that</span>
        <span class="s3"># don't fit exactly into VectorPlotter logic. It may be wise to have a second</span>
        <span class="s3"># round of refactoring that moves the logic deeper, but this will keep things</span>
        <span class="s3"># relatively sensible for now.</span>

        <span class="s3"># For wide data, orient determines assignment to x/y differently from the</span>
        <span class="s3"># default VectorPlotter rules. If we do decide to make orient part of the</span>
        <span class="s3"># _base variable assignment, we'll want to figure out how to express that.</span>
        <span class="s0">if </span><span class="s1">self.input_format == </span><span class="s2">&quot;wide&quot; </span><span class="s0">and </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;h&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">]:</span>
            <span class="s1">self.plot_data = self.plot_data.rename(columns={</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">})</span>
            <span class="s1">orig_variables = set(self.variables)</span>
            <span class="s1">orig_x = self.variables.pop(</span><span class="s2">&quot;x&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">orig_y = self.variables.pop(</span><span class="s2">&quot;y&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">orig_x_type = self.var_types.pop(</span><span class="s2">&quot;x&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">orig_y_type = self.var_types.pop(</span><span class="s2">&quot;y&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s2">&quot;x&quot; </span><span class="s0">in </span><span class="s1">orig_variables:</span>
                <span class="s1">self.variables[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = orig_x</span>
                <span class="s1">self.var_types[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = orig_x_type</span>
            <span class="s0">if </span><span class="s2">&quot;y&quot; </span><span class="s0">in </span><span class="s1">orig_variables:</span>
                <span class="s1">self.variables[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = orig_y</span>
                <span class="s1">self.var_types[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = orig_y_type</span>

        <span class="s3"># Initially there was more special code for wide-form data where plots were</span>
        <span class="s3"># multi-colored by default and then either palette or color could be used.</span>
        <span class="s3"># We want to provide backwards compatibility for this behavior in a relatively</span>
        <span class="s3"># simply way, so we delete the hue information when color is specified.</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">self.input_format == </span><span class="s2">&quot;wide&quot;</span>
            <span class="s0">and </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables</span>
            <span class="s0">and </span><span class="s1">color </span><span class="s0">is not None</span>
        <span class="s1">):</span>
            <span class="s1">self.plot_data.drop(</span><span class="s2">&quot;hue&quot;</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self.variables.pop(</span><span class="s2">&quot;hue&quot;</span><span class="s1">)</span>

        <span class="s3"># The concept of an &quot;orientation&quot; is important to the original categorical</span>
        <span class="s3"># plots, but there's no provision for it in VectorPlotter, so we need it here.</span>
        <span class="s3"># Note that it could be useful for the other functions in at least two ways</span>
        <span class="s3"># (orienting a univariate distribution plot from long-form data and selecting</span>
        <span class="s3"># the aggregation axis in lineplot), so we may want to eventually refactor it.</span>
        <span class="s1">self.orient = infer_orient(</span>
            <span class="s1">x=self.plot_data.get(</span><span class="s2">&quot;x&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">y=self.plot_data.get(</span><span class="s2">&quot;y&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">orient=orient</span><span class="s0">,</span>
            <span class="s1">require_numeric=</span><span class="s0">False,</span>
        <span class="s1">)</span>

        <span class="s1">self.legend = legend</span>

        <span class="s3"># Short-circuit in the case of an empty plot</span>
        <span class="s0">if not </span><span class="s1">self.has_xy_data:</span>
            <span class="s0">return</span>

        <span class="s3"># Categorical plots can be &quot;univariate&quot; in which case they get an anonymous</span>
        <span class="s3"># category label on the opposite axis. Note: this duplicates code in the core</span>
        <span class="s3"># scale_categorical function. We need to do it here because of the next line.</span>
        <span class="s0">if </span><span class="s1">self.orient </span><span class="s0">not in </span><span class="s1">self.variables:</span>
            <span class="s1">self.variables[self.orient] = </span><span class="s0">None</span>
            <span class="s1">self.var_types[self.orient] = </span><span class="s2">&quot;categorical&quot;</span>
            <span class="s1">self.plot_data[self.orient] = </span><span class="s2">&quot;&quot;</span>

        <span class="s3"># Categorical variables have discrete levels that we need to track</span>
        <span class="s1">cat_levels = categorical_order(self.plot_data[self.orient]</span><span class="s0">, </span><span class="s1">order)</span>
        <span class="s1">self.var_levels[self.orient] = cat_levels</span>

    <span class="s0">def </span><span class="s1">_hue_backcompat(self</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order</span><span class="s0">, </span><span class="s1">force_hue=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Implement backwards compatibility for hue parametrization. 
 
        Note: the force_hue parameter is used so that functions can be shown to 
        pass existing tests during refactoring and then tested for new behavior. 
        It can be removed after completion of the work. 
 
        &quot;&quot;&quot;</span>
        <span class="s3"># The original categorical functions applied a palette to the categorical axis</span>
        <span class="s3"># by default. We want to require an explicit hue mapping, to be more consistent</span>
        <span class="s3"># with how things work elsewhere now. I don't think there's any good way to</span>
        <span class="s3"># do this gently -- because it's triggered by the default value of hue=None,</span>
        <span class="s3"># users would always get a warning, unless we introduce some sentinel &quot;default&quot;</span>
        <span class="s3"># argument for this change. That's possible, but asking users to set `hue=None`</span>
        <span class="s3"># on every call is annoying.</span>
        <span class="s3"># We are keeping the logic for implementing the old behavior in with the current</span>
        <span class="s3"># system so that (a) we can punt on that decision and (b) we can ensure that</span>
        <span class="s3"># refactored code passes old tests.</span>
        <span class="s1">default_behavior = color </span><span class="s0">is None or </span><span class="s1">palette </span><span class="s0">is not None</span>
        <span class="s0">if </span><span class="s1">force_hue </span><span class="s0">and </span><span class="s2">&quot;hue&quot; </span><span class="s0">not in </span><span class="s1">self.variables </span><span class="s0">and </span><span class="s1">default_behavior:</span>
            <span class="s1">self._redundant_hue = </span><span class="s0">True</span>
            <span class="s1">self.plot_data[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] = self.plot_data[self.orient]</span>
            <span class="s1">self.variables[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] = self.variables[self.orient]</span>
            <span class="s1">self.var_types[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] = </span><span class="s2">&quot;categorical&quot;</span>
            <span class="s1">hue_order = self.var_levels[self.orient]</span>

            <span class="s3"># Because we convert the categorical axis variable to string,</span>
            <span class="s3"># we need to update a dictionary palette too</span>
            <span class="s0">if </span><span class="s1">isinstance(palette</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s1">palette = {str(k): v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">palette.items()}</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
                <span class="s1">redundant = (self.plot_data[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] == self.plot_data[self.orient]).all()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">redundant = </span><span class="s0">False</span>
            <span class="s1">self._redundant_hue = redundant</span>

        <span class="s3"># Previously, categorical plots had a trick where color= could seed the palette.</span>
        <span class="s3"># Because that's an explicit parameterization, we are going to give it one</span>
        <span class="s3"># release cycle with a warning before removing.</span>
        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables </span><span class="s0">and </span><span class="s1">palette </span><span class="s0">is None and </span><span class="s1">color </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">color = mpl.colors.to_hex(color)</span>
            <span class="s1">palette = </span><span class="s2">f&quot;dark:</span><span class="s0">{</span><span class="s1">color</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">Setting a gradient palette using color= is deprecated and will be &quot;</span>
                <span class="s2">f&quot;removed in v0.14.0. Set `palette='</span><span class="s0">{</span><span class="s1">palette</span><span class="s0">}</span><span class="s2">'` for the same effect.</span><span class="s0">\n</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order</span>

    <span class="s0">def </span><span class="s1">_palette_without_hue_backcompat(self</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order):</span>
        <span class="s5">&quot;&quot;&quot;Provide one cycle where palette= implies hue= when not provided&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">not in </span><span class="s1">self.variables </span><span class="s0">and </span><span class="s1">palette </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">Passing `palette` without assigning `hue` is deprecated &quot;</span>
                <span class="s2">f&quot;and will be removed in v0.14.0. Assign the `</span><span class="s0">{</span><span class="s1">self.orient</span><span class="s0">}</span><span class="s2">` variable &quot;</span>
                <span class="s2">&quot;to `hue` and set `legend=False` for the same effect.</span><span class="s0">\n</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

            <span class="s1">self.legend = </span><span class="s0">False</span>
            <span class="s1">self.plot_data[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] = self.plot_data[self.orient]</span>
            <span class="s1">self.variables[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] = self.variables.get(self.orient)</span>
            <span class="s1">self.var_types[</span><span class="s2">&quot;hue&quot;</span><span class="s1">] = self.var_types.get(self.orient)</span>

            <span class="s1">hue_order = self.var_levels.get(self.orient)</span>
            <span class="s1">self._var_levels.pop(</span><span class="s2">&quot;hue&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">hue_order</span>

    <span class="s0">def </span><span class="s1">_point_kwargs_backcompat(self</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">join</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Provide two cycles where scale= and join= work, but redirect to kwargs.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">scale </span><span class="s0">is not </span><span class="s1">deprecated:</span>
            <span class="s1">lw = mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">] * </span><span class="s4">1.8 </span><span class="s1">* scale</span>
            <span class="s1">mew = lw * </span><span class="s4">.75</span>
            <span class="s1">ms = lw * </span><span class="s4">2</span>

            <span class="s1">msg = (</span>
                <span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;The `scale` parameter is deprecated and will be removed in v0.15.0. &quot;</span>
                <span class="s2">&quot;You can now control the size of each plot element using matplotlib &quot;</span>
                <span class="s2">&quot;`Line2D` parameters (e.g., `linewidth`, `markersize`, etc.).&quot;</span>
                <span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
            <span class="s1">kwargs.update(linewidth=lw</span><span class="s0">, </span><span class="s1">markeredgewidth=mew</span><span class="s0">, </span><span class="s1">markersize=ms)</span>

        <span class="s0">if </span><span class="s1">join </span><span class="s0">is not </span><span class="s1">deprecated:</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;The `join` parameter is deprecated and will be removed in v0.15.0.&quot;</span>
            <span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">join:</span>
                <span class="s1">msg += (</span>
                    <span class="s2">&quot; You can remove the line between points with `linestyle='none'`.&quot;</span>
                <span class="s1">)</span>
                <span class="s1">kwargs.update(linestyle=</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">msg += </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_err_kws_backcompat(self</span><span class="s0">, </span><span class="s1">err_kws</span><span class="s0">, </span><span class="s1">errcolor</span><span class="s0">, </span><span class="s1">errwidth</span><span class="s0">, </span><span class="s1">capsize):</span>
        <span class="s5">&quot;&quot;&quot;Provide two cycles where existing signature-level err_kws are handled.&quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">deprecate_err_param(name</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">val):</span>
            <span class="s0">if </span><span class="s1">val </span><span class="s0">is </span><span class="s1">deprecated:</span>
                <span class="s0">return</span>
            <span class="s1">suggest = </span><span class="s2">f&quot;err_kws=</span><span class="s0">{{</span><span class="s2">'</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">': </span><span class="s0">{</span><span class="s1">val</span><span class="s0">!r}}}</span><span class="s2">&quot;</span>
            <span class="s1">msg = (</span>
                <span class="s2">f&quot;</span><span class="s0">\n\n</span><span class="s2">The `</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s2">` parameter is deprecated. And will be removed &quot;</span>
                <span class="s2">f&quot;in v0.15.0. Pass `</span><span class="s0">{</span><span class="s1">suggest</span><span class="s0">}</span><span class="s2">` instead.</span><span class="s0">\n</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">4</span><span class="s1">)</span>
            <span class="s1">err_kws[key] = val</span>

        <span class="s0">if </span><span class="s1">errcolor </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">deprecate_err_param(</span><span class="s2">&quot;errcolor&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">errcolor)</span>
        <span class="s1">deprecate_err_param(</span><span class="s2">&quot;errwidth&quot;</span><span class="s0">, </span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s1">errwidth)</span>

        <span class="s0">if </span><span class="s1">capsize </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">capsize = </span><span class="s4">0</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">Passing `capsize=None` is deprecated and will be removed &quot;</span>
                <span class="s2">&quot;in v0.15.0. Pass `capsize=0` to disable caps.</span><span class="s0">\n</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">err_kws</span><span class="s0">, </span><span class="s1">capsize</span>

    <span class="s0">def </span><span class="s1">_violin_scale_backcompat(self</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">scale_hue</span><span class="s0">, </span><span class="s1">density_norm</span><span class="s0">, </span><span class="s1">common_norm):</span>
        <span class="s5">&quot;&quot;&quot;Provide two cycles of backcompat for scale kwargs&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">scale </span><span class="s0">is not </span><span class="s1">deprecated:</span>
            <span class="s1">density_norm = scale</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">The `scale` parameter has been renamed and will be removed &quot;</span>
                <span class="s2">f&quot;in v0.15.0. Pass `density_norm=</span><span class="s0">{</span><span class="s1">scale</span><span class="s0">!r}</span><span class="s2">` for the same effect.&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">scale_hue </span><span class="s0">is not </span><span class="s1">deprecated:</span>
            <span class="s1">common_norm = scale_hue</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">The `scale_hue` parameter has been replaced and will be removed &quot;</span>
                <span class="s2">f&quot;in v0.15.0. Pass `common_norm=</span><span class="s0">{not </span><span class="s1">scale_hue</span><span class="s0">}</span><span class="s2">` for the same effect.&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">density_norm</span><span class="s0">, </span><span class="s1">common_norm</span>

    <span class="s0">def </span><span class="s1">_violin_bw_backcompat(self</span><span class="s0">, </span><span class="s1">bw</span><span class="s0">, </span><span class="s1">bw_method):</span>
        <span class="s5">&quot;&quot;&quot;Provide two cycles of backcompat for violin bandwidth parameterization.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">bw </span><span class="s0">is not </span><span class="s1">deprecated:</span>
            <span class="s1">bw_method = bw</span>
            <span class="s1">msg = dedent(</span><span class="s2">f&quot;&quot;&quot;</span><span class="s0">\n</span>
                <span class="s2">The `bw` parameter is deprecated in favor of `bw_method`/`bw_adjust`.</span>
                <span class="s2">Setting `bw_method=</span><span class="s0">{</span><span class="s1">bw</span><span class="s0">!r}</span><span class="s2">`, but please see docs for the new parameters</span>
                <span class="s2">and update your code. This will become an error in seaborn v0.15.0.</span>
            <span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">bw_method</span>

    <span class="s0">def </span><span class="s1">_boxen_scale_backcompat(self</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">width_method):</span>
        <span class="s5">&quot;&quot;&quot;Provide two cycles of backcompat for scale kwargs&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">scale </span><span class="s0">is not </span><span class="s1">deprecated:</span>
            <span class="s1">width_method = scale</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;</span><span class="s0">\n\n</span><span class="s2">The `scale` parameter has been renamed to `width_method` and &quot;</span>
                <span class="s2">f&quot;will be removed in v0.15. Pass `width_method=</span><span class="s0">{</span><span class="s1">scale</span><span class="s0">!r}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">scale == </span><span class="s2">&quot;area&quot;</span><span class="s1">:</span>
                <span class="s1">msg += </span><span class="s2">&quot;, but note that the result for 'area' will appear different.&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg += </span><span class="s2">&quot; for the same effect.&quot;</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">width_method</span>

    <span class="s0">def </span><span class="s1">_complement_color(self</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">base_color</span><span class="s0">, </span><span class="s1">hue_map):</span>
        <span class="s5">&quot;&quot;&quot;Allow a color to be set automatically using a basis of comparison.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">color == </span><span class="s2">&quot;gray&quot;</span><span class="s1">:</span>
            <span class="s1">msg = (</span>
                <span class="s2">'Use &quot;auto&quot; to set automatic grayscale colors. From v0.14.0, '</span>
                <span class="s2">'&quot;gray&quot; will default to matplotlib</span><span class="s0">\'</span><span class="s2">s definition.'</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">FutureWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
            <span class="s1">color = </span><span class="s2">&quot;auto&quot;</span>
        <span class="s0">elif </span><span class="s1">color </span><span class="s0">is None or </span><span class="s1">color </span><span class="s0">is </span><span class="s1">default:</span>
            <span class="s1">color = </span><span class="s2">&quot;auto&quot;</span>

        <span class="s0">if </span><span class="s1">color != </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">color</span>

        <span class="s0">if </span><span class="s1">hue_map.lookup_table </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">base_color </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return None</span>
            <span class="s1">basis = [mpl.colors.to_rgb(base_color)]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">basis = [mpl.colors.to_rgb(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">hue_map.lookup_table.values()]</span>
        <span class="s1">unique_colors = np.unique(basis</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">light_vals = [rgb_to_hls(*rgb[:</span><span class="s4">3</span><span class="s1">])[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">rgb </span><span class="s0">in </span><span class="s1">unique_colors]</span>
        <span class="s1">lum = min(light_vals) * </span><span class="s4">.6</span>
        <span class="s0">return </span><span class="s1">(lum</span><span class="s0">, </span><span class="s1">lum</span><span class="s0">, </span><span class="s1">lum)</span>

    <span class="s0">def </span><span class="s1">_map_prop_with_hue(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">fallback</span><span class="s0">, </span><span class="s1">plot_kws):</span>
        <span class="s5">&quot;&quot;&quot;Support pointplot behavior of modifying the marker/linestyle with hue.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is </span><span class="s1">default:</span>
            <span class="s1">value = plot_kws.pop(name</span><span class="s0">, </span><span class="s1">fallback)</span>

        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
            <span class="s1">levels = self._hue_map.levels</span>
            <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">mapping = {k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip(levels</span><span class="s0">, </span><span class="s1">value)}</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">mapping = {k: value </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">levels}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mapping = {</span><span class="s0">None</span><span class="s1">: value}</span>

        <span class="s0">return </span><span class="s1">mapping</span>

    <span class="s0">def </span><span class="s1">_adjust_cat_axis(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s5">&quot;&quot;&quot;Set ticks and limits for a categorical variable.&quot;&quot;&quot;</span>
        <span class="s3"># Note: in theory, this could happen in _attach for all categorical axes</span>
        <span class="s3"># But two reasons not to do that:</span>
        <span class="s3"># - If it happens before plotting, autoscaling messes up the plot limits</span>
        <span class="s3"># - It would change existing plots from other seaborn functions</span>
        <span class="s0">if </span><span class="s1">self.var_types[axis] != </span><span class="s2">&quot;categorical&quot;</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s3"># If both x/y data are empty, the correct way to set up the plot is</span>
        <span class="s3"># somewhat undefined; because we don't add null category data to the plot in</span>
        <span class="s3"># this case we don't *have* a categorical axis (yet), so best to just bail.</span>
        <span class="s0">if </span><span class="s1">self.plot_data[axis].empty:</span>
            <span class="s0">return</span>

        <span class="s3"># We can infer the total number of categories (including those from previous</span>
        <span class="s3"># plots that are not part of the plot we are currently making) from the number</span>
        <span class="s3"># of ticks, which matplotlib sets up while doing unit conversion. This feels</span>
        <span class="s3"># slightly risky, as if we are relying on something that may be a matplotlib</span>
        <span class="s3"># implementation detail. But I cannot think of a better way to keep track of</span>
        <span class="s3"># the state from previous categorical calls (see GH2516 for context)</span>
        <span class="s1">n = len(getattr(ax</span><span class="s0">, </span><span class="s2">f&quot;get_</span><span class="s0">{</span><span class="s1">axis</span><span class="s0">}</span><span class="s2">ticks&quot;</span><span class="s1">)())</span>

        <span class="s0">if </span><span class="s1">axis == </span><span class="s2">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">ax.xaxis.grid(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">ax.set_xlim(-</span><span class="s4">.5</span><span class="s0">, </span><span class="s1">n - </span><span class="s4">.5</span><span class="s0">, </span><span class="s1">auto=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ax.yaxis.grid(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s3"># Note limits that correspond to previously-inverted y axis</span>
            <span class="s1">ax.set_ylim(n - </span><span class="s4">.5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">.5</span><span class="s0">, </span><span class="s1">auto=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_dodge_needed(self):</span>
        <span class="s5">&quot;&quot;&quot;Return True when use of `hue` would cause overlaps.&quot;&quot;&quot;</span>
        <span class="s1">groupers = list({self.orient</span><span class="s0">, </span><span class="s2">&quot;col&quot;</span><span class="s0">, </span><span class="s2">&quot;row&quot;</span><span class="s1">} &amp; set(self.variables))</span>
        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
            <span class="s1">orient = self.plot_data[groupers].value_counts()</span>
            <span class="s1">paired = self.plot_data[[*groupers</span><span class="s0">, </span><span class="s2">&quot;hue&quot;</span><span class="s1">]].value_counts()</span>
            <span class="s0">return </span><span class="s1">orient.size != paired.size</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_dodge(self</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s5">&quot;&quot;&quot;Apply a dodge transform to coordinates in place.&quot;&quot;&quot;</span>
        <span class="s1">hue_idx = self._hue_map.levels.index(keys[</span><span class="s2">&quot;hue&quot;</span><span class="s1">])</span>
        <span class="s1">n = len(self._hue_map.levels)</span>
        <span class="s1">data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] /= n</span>

        <span class="s1">full_width = data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] * n</span>
        <span class="s1">offset = data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] * hue_idx + data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] / </span><span class="s4">2 </span><span class="s1">- full_width / </span><span class="s4">2</span>
        <span class="s1">data[self.orient] += offset</span>

    <span class="s0">def </span><span class="s1">_invert_scale(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">vars=(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">)):</span>
        <span class="s5">&quot;&quot;&quot;Undo scaling after computation so data are plotted correctly.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">vars:</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">inv = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">var[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">var == self.orient </span><span class="s0">and </span><span class="s2">&quot;width&quot; </span><span class="s0">in </span><span class="s1">data:</span>
                <span class="s1">hw = data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] / </span><span class="s4">2</span>
                <span class="s1">data[</span><span class="s2">&quot;edge&quot;</span><span class="s1">] = inv(data[var] - hw)</span>
                <span class="s1">data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = inv(data[var] + hw) - data[</span><span class="s2">&quot;edge&quot;</span><span class="s1">].to_numpy()</span>
            <span class="s0">for </span><span class="s1">suf </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s1">]:</span>
                <span class="s0">if </span><span class="s1">(col := </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">var</span><span class="s0">}{</span><span class="s1">suf</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">) </span><span class="s0">in </span><span class="s1">data:</span>
                    <span class="s1">data[col] = inv(data[col])</span>

    <span class="s0">def </span><span class="s1">_configure_legend(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">common_kws=</span><span class="s0">None, </span><span class="s1">semantic_kws=</span><span class="s0">None</span><span class="s1">):</span>

        <span class="s0">if </span><span class="s1">self.legend == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">show_legend = </span><span class="s0">not </span><span class="s1">self._redundant_hue </span><span class="s0">and </span><span class="s1">self.input_format != </span><span class="s2">&quot;wide&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">show_legend = bool(self.legend)</span>

        <span class="s0">if </span><span class="s1">show_legend:</span>
            <span class="s1">self.add_legend_data(ax</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">common_kws</span><span class="s0">, </span><span class="s1">semantic_kws=semantic_kws)</span>
            <span class="s1">handles</span><span class="s0">, </span><span class="s1">_ = ax.get_legend_handles_labels()</span>
            <span class="s0">if </span><span class="s1">handles:</span>
                <span class="s1">ax.legend(title=self.legend_title)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_native_width(self):</span>
        <span class="s5">&quot;&quot;&quot;Return unit of width separating categories on native numeric scale.&quot;&quot;&quot;</span>
        <span class="s3"># Categorical data always have a unit width</span>
        <span class="s0">if </span><span class="s1">self.var_types[self.orient] == </span><span class="s2">&quot;categorical&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s4">1</span>

        <span class="s3"># Otherwise, define the width as the smallest space between observations</span>
        <span class="s1">unique_values = np.unique(self.comp_data[self.orient])</span>
        <span class="s0">if </span><span class="s1">len(unique_values) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">native_width = np.nanmin(np.diff(unique_values))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">native_width = </span><span class="s4">1</span>
        <span class="s0">return </span><span class="s1">native_width</span>

    <span class="s0">def </span><span class="s1">_nested_offsets(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">dodge):</span>
        <span class="s5">&quot;&quot;&quot;Return offsets for each hue level for dodged plots.&quot;&quot;&quot;</span>
        <span class="s1">offsets = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables </span><span class="s0">and </span><span class="s1">self._hue_map.levels </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">n_levels = len(self._hue_map.levels)</span>
            <span class="s0">if </span><span class="s1">dodge:</span>
                <span class="s1">each_width = width / n_levels</span>
                <span class="s1">offsets = np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">width - each_width</span><span class="s0">, </span><span class="s1">n_levels)</span>
                <span class="s1">offsets -= offsets.mean()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">offsets = np.zeros(n_levels)</span>
        <span class="s0">return </span><span class="s1">offsets</span>

    <span class="s3"># Note that the plotting methods here aim (in most cases) to produce the</span>
    <span class="s3"># exact same artists as the original (pre 0.12) version of the code, so</span>
    <span class="s3"># there is some weirdness that might not otherwise be clean or make sense in</span>
    <span class="s3"># this context, such as adding empty artists for combinations of variables</span>
    <span class="s3"># with no observations</span>

    <span class="s0">def </span><span class="s1">plot_strips(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">jitter</span><span class="s0">,</span>
        <span class="s1">dodge</span><span class="s0">,</span>
        <span class="s1">color</span><span class="s0">,</span>
        <span class="s1">plot_kws</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">width = </span><span class="s4">.8 </span><span class="s1">* self._native_width</span>
        <span class="s1">offsets = self._nested_offsets(width</span><span class="s0">, </span><span class="s1">dodge)</span>

        <span class="s0">if </span><span class="s1">jitter </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">jlim = </span><span class="s4">0.1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">jlim = float(jitter)</span>
        <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables </span><span class="s0">and </span><span class="s1">dodge </span><span class="s0">and </span><span class="s1">self._hue_map.levels </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">jlim /= len(self._hue_map.levels)</span>
        <span class="s1">jlim *= self._native_width</span>
        <span class="s1">jitterer = partial(np.random.uniform</span><span class="s0">, </span><span class="s1">low=-jlim</span><span class="s0">, </span><span class="s1">high=+jlim)</span>

        <span class="s1">iter_vars = [self.orient]</span>
        <span class="s0">if </span><span class="s1">dodge:</span>
            <span class="s1">iter_vars.append(</span><span class="s2">&quot;hue&quot;</span><span class="s1">)</span>

        <span class="s1">ax = self.ax</span>
        <span class="s1">dodge_move = jitter_move = </span><span class="s4">0</span>

        <span class="s0">if </span><span class="s2">&quot;marker&quot; </span><span class="s0">in </span><span class="s1">plot_kws </span><span class="s0">and not </span><span class="s1">MarkerStyle(plot_kws[</span><span class="s2">&quot;marker&quot;</span><span class="s1">]).is_filled():</span>
            <span class="s1">plot_kws.pop(</span><span class="s2">&quot;edgecolor&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">sub_vars</span><span class="s0">, </span><span class="s1">sub_data </span><span class="s0">in </span><span class="s1">self.iter_data(iter_vars</span><span class="s0">,</span>
                                                 <span class="s1">from_comp_data=</span><span class="s0">True,</span>
                                                 <span class="s1">allow_empty=</span><span class="s0">True</span><span class="s1">):</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s0">if </span><span class="s1">offsets </span><span class="s0">is not None and </span><span class="s1">(offsets != </span><span class="s4">0</span><span class="s1">).any():</span>
                <span class="s1">dodge_move = offsets[sub_data[</span><span class="s2">&quot;hue&quot;</span><span class="s1">].map(self._hue_map.levels.index)]</span>

            <span class="s1">jitter_move = jitterer(size=len(sub_data)) </span><span class="s0">if </span><span class="s1">len(sub_data) &gt; </span><span class="s4">1 </span><span class="s0">else </span><span class="s4">0</span>

            <span class="s1">adjusted_data = sub_data[self.orient] + dodge_move + jitter_move</span>
            <span class="s1">sub_data[self.orient] = adjusted_data</span>
            <span class="s1">self._invert_scale(ax</span><span class="s0">, </span><span class="s1">sub_data)</span>

            <span class="s1">points = ax.scatter(sub_data[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sub_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">color=color</span><span class="s0">, </span><span class="s1">**plot_kws)</span>
            <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
                <span class="s1">points.set_facecolors(self._hue_map(sub_data[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]))</span>

        <span class="s1">self._configure_legend(ax</span><span class="s0">, </span><span class="s1">_scatter_legend_artist</span><span class="s0">, </span><span class="s1">common_kws=plot_kws)</span>

    <span class="s0">def </span><span class="s1">plot_swarms(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">dodge</span><span class="s0">,</span>
        <span class="s1">color</span><span class="s0">,</span>
        <span class="s1">warn_thresh</span><span class="s0">,</span>
        <span class="s1">plot_kws</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">width = </span><span class="s4">.8 </span><span class="s1">* self._native_width</span>
        <span class="s1">offsets = self._nested_offsets(width</span><span class="s0">, </span><span class="s1">dodge)</span>

        <span class="s1">iter_vars = [self.orient]</span>
        <span class="s0">if </span><span class="s1">dodge:</span>
            <span class="s1">iter_vars.append(</span><span class="s2">&quot;hue&quot;</span><span class="s1">)</span>

        <span class="s1">ax = self.ax</span>
        <span class="s1">point_collections = {}</span>
        <span class="s1">dodge_move = </span><span class="s4">0</span>

        <span class="s0">if </span><span class="s2">&quot;marker&quot; </span><span class="s0">in </span><span class="s1">plot_kws </span><span class="s0">and not </span><span class="s1">MarkerStyle(plot_kws[</span><span class="s2">&quot;marker&quot;</span><span class="s1">]).is_filled():</span>
            <span class="s1">plot_kws.pop(</span><span class="s2">&quot;edgecolor&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">sub_vars</span><span class="s0">, </span><span class="s1">sub_data </span><span class="s0">in </span><span class="s1">self.iter_data(iter_vars</span><span class="s0">,</span>
                                                 <span class="s1">from_comp_data=</span><span class="s0">True,</span>
                                                 <span class="s1">allow_empty=</span><span class="s0">True</span><span class="s1">):</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s0">if </span><span class="s1">offsets </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">dodge_move = offsets[sub_data[</span><span class="s2">&quot;hue&quot;</span><span class="s1">].map(self._hue_map.levels.index)]</span>

            <span class="s0">if not </span><span class="s1">sub_data.empty:</span>
                <span class="s1">sub_data[self.orient] = sub_data[self.orient] + dodge_move</span>

            <span class="s1">self._invert_scale(ax</span><span class="s0">, </span><span class="s1">sub_data)</span>

            <span class="s1">points = ax.scatter(sub_data[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sub_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">color=color</span><span class="s0">, </span><span class="s1">**plot_kws)</span>
            <span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">self.variables:</span>
                <span class="s1">points.set_facecolors(self._hue_map(sub_data[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]))</span>

            <span class="s0">if not </span><span class="s1">sub_data.empty:</span>
                <span class="s1">point_collections[(ax</span><span class="s0">, </span><span class="s1">sub_data[self.orient].iloc[</span><span class="s4">0</span><span class="s1">])] = points</span>

        <span class="s1">beeswarm = Beeswarm(width=width</span><span class="s0">, </span><span class="s1">orient=self.orient</span><span class="s0">, </span><span class="s1">warn_thresh=warn_thresh)</span>
        <span class="s0">for </span><span class="s1">(ax</span><span class="s0">, </span><span class="s1">center)</span><span class="s0">, </span><span class="s1">points </span><span class="s0">in </span><span class="s1">point_collections.items():</span>
            <span class="s0">if </span><span class="s1">points.get_offsets().shape[</span><span class="s4">0</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>

                <span class="s0">def </span><span class="s1">draw(points</span><span class="s0">, </span><span class="s1">renderer</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">center=center):</span>

                    <span class="s1">beeswarm(points</span><span class="s0">, </span><span class="s1">center)</span>

                    <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s1">:</span>
                        <span class="s1">scalex = </span><span class="s0">False</span>
                        <span class="s1">scaley = ax.get_autoscaley_on()</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">scalex = ax.get_autoscalex_on()</span>
                        <span class="s1">scaley = </span><span class="s0">False</span>

                    <span class="s3"># This prevents us from undoing the nice categorical axis limits</span>
                    <span class="s3"># set in _adjust_cat_axis, because that method currently leave</span>
                    <span class="s3"># the autoscale flag in its original setting. It may be better</span>
                    <span class="s3"># to disable autoscaling there to avoid needing to do this.</span>
                    <span class="s1">fixed_scale = self.var_types[self.orient] == </span><span class="s2">&quot;categorical&quot;</span>
                    <span class="s1">ax.update_datalim(points.get_datalim(ax.transData))</span>
                    <span class="s0">if not </span><span class="s1">fixed_scale </span><span class="s0">and </span><span class="s1">(scalex </span><span class="s0">or </span><span class="s1">scaley):</span>
                        <span class="s1">ax.autoscale_view(scalex=scalex</span><span class="s0">, </span><span class="s1">scaley=scaley)</span>

                    <span class="s1">super(points.__class__</span><span class="s0">, </span><span class="s1">points).draw(renderer)</span>

                <span class="s1">points.draw = draw.__get__(points)</span>

        <span class="s1">_draw_figure(ax.figure)</span>
        <span class="s1">self._configure_legend(ax</span><span class="s0">, </span><span class="s1">_scatter_legend_artist</span><span class="s0">, </span><span class="s1">plot_kws)</span>

    <span class="s0">def </span><span class="s1">plot_boxes(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">width</span><span class="s0">,</span>
        <span class="s1">dodge</span><span class="s0">,</span>
        <span class="s1">gap</span><span class="s0">,</span>
        <span class="s1">fill</span><span class="s0">,</span>
        <span class="s1">whis</span><span class="s0">,</span>
        <span class="s1">color</span><span class="s0">,</span>
        <span class="s1">linecolor</span><span class="s0">,</span>
        <span class="s1">linewidth</span><span class="s0">,</span>
        <span class="s1">fliersize</span><span class="s0">,</span>
        <span class="s1">plot_kws</span><span class="s0">,  </span><span class="s3"># TODO rename user_kws?</span>
    <span class="s1">):</span>

        <span class="s1">iter_vars = [</span><span class="s2">&quot;hue&quot;</span><span class="s1">]</span>
        <span class="s1">value_var = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[self.orient]</span>

        <span class="s0">def </span><span class="s1">get_props(element</span><span class="s0">, </span><span class="s1">artist=mpl.lines.Line2D):</span>
            <span class="s0">return </span><span class="s1">_normalize_kwargs(plot_kws.pop(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">element</span><span class="s0">}</span><span class="s2">props&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">, </span><span class="s1">artist)</span>

        <span class="s0">if not </span><span class="s1">fill </span><span class="s0">and </span><span class="s1">linewidth </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">linewidth = mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">]</span>

        <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;shownotches&quot;</span><span class="s0">, </span><span class="s1">plot_kws.pop(</span><span class="s2">&quot;notch&quot;</span><span class="s0">, False</span><span class="s1">))</span>

        <span class="s1">box_artist = mpl.patches.Rectangle </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">mpl.lines.Line2D</span>
        <span class="s1">props = {</span>
            <span class="s2">&quot;box&quot;</span><span class="s1">: get_props(</span><span class="s2">&quot;box&quot;</span><span class="s0">, </span><span class="s1">box_artist)</span><span class="s0">,</span>
            <span class="s2">&quot;median&quot;</span><span class="s1">: get_props(</span><span class="s2">&quot;median&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;whisker&quot;</span><span class="s1">: get_props(</span><span class="s2">&quot;whisker&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;flier&quot;</span><span class="s1">: get_props(</span><span class="s2">&quot;flier&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;cap&quot;</span><span class="s1">: get_props(</span><span class="s2">&quot;cap&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">props[</span><span class="s2">&quot;median&quot;</span><span class="s1">].setdefault(</span><span class="s2">&quot;solid_capstyle&quot;</span><span class="s0">, </span><span class="s2">&quot;butt&quot;</span><span class="s1">)</span>
        <span class="s1">props[</span><span class="s2">&quot;whisker&quot;</span><span class="s1">].setdefault(</span><span class="s2">&quot;solid_capstyle&quot;</span><span class="s0">, </span><span class="s2">&quot;butt&quot;</span><span class="s1">)</span>
        <span class="s1">props[</span><span class="s2">&quot;flier&quot;</span><span class="s1">].setdefault(</span><span class="s2">&quot;markersize&quot;</span><span class="s0">, </span><span class="s1">fliersize)</span>

        <span class="s1">ax = self.ax</span>

        <span class="s0">for </span><span class="s1">sub_vars</span><span class="s0">, </span><span class="s1">sub_data </span><span class="s0">in </span><span class="s1">self.iter_data(iter_vars</span><span class="s0">,</span>
                                                 <span class="s1">from_comp_data=</span><span class="s0">True,</span>
                                                 <span class="s1">allow_empty=</span><span class="s0">False</span><span class="s1">):</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s1">grouped = sub_data.groupby(self.orient)[value_var]</span>
            <span class="s1">value_data = [x.to_numpy() </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">grouped]</span>
            <span class="s1">stats = pd.DataFrame(mpl.cbook.boxplot_stats(value_data</span><span class="s0">, </span><span class="s1">whis=whis))</span>
            <span class="s1">positions = grouped.grouper.result_index.to_numpy(dtype=float)</span>

            <span class="s1">orig_width = width * self._native_width</span>
            <span class="s1">data = pd.DataFrame({self.orient: positions</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: orig_width})</span>
            <span class="s0">if </span><span class="s1">dodge:</span>
                <span class="s1">self._dodge(sub_vars</span><span class="s0">, </span><span class="s1">data)</span>
            <span class="s0">if </span><span class="s1">gap:</span>
                <span class="s1">data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] *= </span><span class="s4">1 </span><span class="s1">- gap</span>
            <span class="s1">capwidth = plot_kws.get(</span><span class="s2">&quot;capwidths&quot;</span><span class="s0">, </span><span class="s4">0.5 </span><span class="s1">* data[</span><span class="s2">&quot;width&quot;</span><span class="s1">])</span>

            <span class="s1">self._invert_scale(ax</span><span class="s0">, </span><span class="s1">data)</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">inv = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">value_var)</span>
            <span class="s0">for </span><span class="s1">stat </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s2">&quot;med&quot;</span><span class="s0">, </span><span class="s2">&quot;q1&quot;</span><span class="s0">, </span><span class="s2">&quot;q3&quot;</span><span class="s0">, </span><span class="s2">&quot;cilo&quot;</span><span class="s0">, </span><span class="s2">&quot;cihi&quot;</span><span class="s0">, </span><span class="s2">&quot;whislo&quot;</span><span class="s0">, </span><span class="s2">&quot;whishi&quot;</span><span class="s1">]:</span>
                <span class="s1">stats[stat] = inv(stats[stat])</span>
            <span class="s1">stats[</span><span class="s2">&quot;fliers&quot;</span><span class="s1">] = stats[</span><span class="s2">&quot;fliers&quot;</span><span class="s1">].map(inv)</span>

            <span class="s1">linear_orient_scale = getattr(ax</span><span class="s0">, </span><span class="s2">f&quot;get_</span><span class="s0">{</span><span class="s1">self.orient</span><span class="s0">}</span><span class="s2">scale&quot;</span><span class="s1">)() == </span><span class="s2">&quot;linear&quot;</span>

            <span class="s1">maincolor = self._hue_map(sub_vars[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]) </span><span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">sub_vars </span><span class="s0">else </span><span class="s1">color</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">boxprops = {</span>
                    <span class="s2">&quot;facecolor&quot;</span><span class="s1">: maincolor</span><span class="s0">, </span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">: linecolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;box&quot;</span><span class="s1">]</span>
                <span class="s1">}</span>
                <span class="s1">medianprops = {</span><span class="s2">&quot;color&quot;</span><span class="s1">: linecolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;median&quot;</span><span class="s1">]}</span>
                <span class="s1">whiskerprops = {</span><span class="s2">&quot;color&quot;</span><span class="s1">: linecolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;whisker&quot;</span><span class="s1">]}</span>
                <span class="s1">flierprops = {</span><span class="s2">&quot;markeredgecolor&quot;</span><span class="s1">: linecolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;flier&quot;</span><span class="s1">]}</span>
                <span class="s1">capprops = {</span><span class="s2">&quot;color&quot;</span><span class="s1">: linecolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;cap&quot;</span><span class="s1">]}</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">boxprops = {</span><span class="s2">&quot;color&quot;</span><span class="s1">: maincolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;box&quot;</span><span class="s1">]}</span>
                <span class="s1">medianprops = {</span><span class="s2">&quot;color&quot;</span><span class="s1">: maincolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;median&quot;</span><span class="s1">]}</span>
                <span class="s1">whiskerprops = {</span><span class="s2">&quot;color&quot;</span><span class="s1">: maincolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;whisker&quot;</span><span class="s1">]}</span>
                <span class="s1">flierprops = {</span><span class="s2">&quot;markeredgecolor&quot;</span><span class="s1">: maincolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;flier&quot;</span><span class="s1">]}</span>
                <span class="s1">capprops = {</span><span class="s2">&quot;color&quot;</span><span class="s1">: maincolor</span><span class="s0">, </span><span class="s1">**props[</span><span class="s2">&quot;cap&quot;</span><span class="s1">]}</span>

            <span class="s0">if </span><span class="s1">linewidth </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">prop_dict </span><span class="s0">in </span><span class="s1">[boxprops</span><span class="s0">, </span><span class="s1">medianprops</span><span class="s0">, </span><span class="s1">whiskerprops</span><span class="s0">, </span><span class="s1">capprops]:</span>
                    <span class="s1">prop_dict.setdefault(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s1">linewidth)</span>

            <span class="s1">default_kws = dict(</span>
                <span class="s1">bxpstats=stats.to_dict(</span><span class="s2">&quot;records&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">positions=data[self.orient]</span><span class="s0">,</span>
                <span class="s3"># Set width to 0 to avoid going out of domain</span>
                <span class="s1">widths=data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] </span><span class="s0">if </span><span class="s1">linear_orient_scale </span><span class="s0">else </span><span class="s4">0</span><span class="s0">,</span>
                <span class="s1">patch_artist=fill</span><span class="s0">,</span>
                <span class="s1">vert=self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s0">,</span>
                <span class="s1">manage_ticks=</span><span class="s0">False,</span>
                <span class="s1">boxprops=boxprops</span><span class="s0">,</span>
                <span class="s1">medianprops=medianprops</span><span class="s0">,</span>
                <span class="s1">whiskerprops=whiskerprops</span><span class="s0">,</span>
                <span class="s1">flierprops=flierprops</span><span class="s0">,</span>
                <span class="s1">capprops=capprops</span><span class="s0">,</span>
                <span class="s3"># Added in matplotlib 3.6.0; see below</span>
                <span class="s3"># capwidths=capwidth,</span>
                <span class="s1">**(</span>
                    <span class="s1">{} </span><span class="s0">if </span><span class="s1">_version_predates(mpl</span><span class="s0">, </span><span class="s2">&quot;3.6.0&quot;</span><span class="s1">)</span>
                    <span class="s0">else </span><span class="s1">{</span><span class="s2">&quot;capwidths&quot;</span><span class="s1">: capwidth}</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">boxplot_kws = {**default_kws</span><span class="s0">, </span><span class="s1">**plot_kws}</span>
            <span class="s1">artists = ax.bxp(**boxplot_kws)</span>

            <span class="s3"># Reset artist widths after adding so everything stays positive</span>
            <span class="s1">ori_idx = [</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">].index(self.orient)</span>

            <span class="s0">if not </span><span class="s1">linear_orient_scale:</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">box </span><span class="s0">in </span><span class="s1">enumerate(data.to_dict(</span><span class="s2">&quot;records&quot;</span><span class="s1">)):</span>
                    <span class="s1">p0 = box[</span><span class="s2">&quot;edge&quot;</span><span class="s1">]</span>
                    <span class="s1">p1 = box[</span><span class="s2">&quot;edge&quot;</span><span class="s1">] + box[</span><span class="s2">&quot;width&quot;</span><span class="s1">]</span>

                    <span class="s0">if </span><span class="s1">artists[</span><span class="s2">&quot;boxes&quot;</span><span class="s1">]:</span>
                        <span class="s1">box_artist = artists[</span><span class="s2">&quot;boxes&quot;</span><span class="s1">][i]</span>
                        <span class="s0">if </span><span class="s1">fill:</span>
                            <span class="s1">box_verts = box_artist.get_path().vertices.T</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">box_verts = box_artist.get_data()</span>
                        <span class="s1">box_verts[ori_idx][</span><span class="s4">0</span><span class="s1">] = p0</span>
                        <span class="s1">box_verts[ori_idx][</span><span class="s4">3</span><span class="s1">:] = p0</span>
                        <span class="s1">box_verts[ori_idx][</span><span class="s4">1</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] = p1</span>
                        <span class="s0">if not </span><span class="s1">fill:</span>
                            <span class="s3"># When fill is True, the data get changed in place</span>
                            <span class="s1">box_artist.set_data(box_verts)</span>
                        <span class="s1">ax.update_datalim(</span>
                            <span class="s1">np.transpose(box_verts)</span><span class="s0">,</span>
                            <span class="s1">updatex=self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s0">,</span>
                            <span class="s1">updatey=self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s0">,</span>
                        <span class="s1">)</span>

                    <span class="s0">if </span><span class="s1">artists[</span><span class="s2">&quot;medians&quot;</span><span class="s1">]:</span>
                        <span class="s1">verts = artists[</span><span class="s2">&quot;medians&quot;</span><span class="s1">][i].get_xydata().T</span>
                        <span class="s1">verts[ori_idx][:] = p0</span><span class="s0">, </span><span class="s1">p1</span>
                        <span class="s1">artists[</span><span class="s2">&quot;medians&quot;</span><span class="s1">][i].set_data(verts)</span>

                    <span class="s0">if </span><span class="s1">artists[</span><span class="s2">&quot;caps&quot;</span><span class="s1">]:</span>
                        <span class="s1">f_fwd</span><span class="s0">, </span><span class="s1">f_inv = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">self.orient)</span>
                        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">artists[</span><span class="s2">&quot;caps&quot;</span><span class="s1">][</span><span class="s4">2 </span><span class="s1">* i:</span><span class="s4">2 </span><span class="s1">* i + </span><span class="s4">2</span><span class="s1">]:</span>
                            <span class="s1">p0 = f_inv(f_fwd(box[self.orient]) - capwidth[i] / </span><span class="s4">2</span><span class="s1">)</span>
                            <span class="s1">p1 = f_inv(f_fwd(box[self.orient]) + capwidth[i] / </span><span class="s4">2</span><span class="s1">)</span>
                            <span class="s1">verts = line.get_xydata().T</span>
                            <span class="s1">verts[ori_idx][:] = p0</span><span class="s0">, </span><span class="s1">p1</span>
                            <span class="s1">line.set_data(verts)</span>

            <span class="s1">ax.add_container(BoxPlotContainer(artists))</span>

        <span class="s1">legend_artist = _get_patch_legend_artist(fill)</span>
        <span class="s1">self._configure_legend(ax</span><span class="s0">, </span><span class="s1">legend_artist</span><span class="s0">, </span><span class="s1">boxprops)</span>

    <span class="s0">def </span><span class="s1">plot_boxens(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">width</span><span class="s0">,</span>
        <span class="s1">dodge</span><span class="s0">,</span>
        <span class="s1">gap</span><span class="s0">,</span>
        <span class="s1">fill</span><span class="s0">,</span>
        <span class="s1">color</span><span class="s0">,</span>
        <span class="s1">linecolor</span><span class="s0">,</span>
        <span class="s1">linewidth</span><span class="s0">,</span>
        <span class="s1">width_method</span><span class="s0">,</span>
        <span class="s1">k_depth</span><span class="s0">,</span>
        <span class="s1">outlier_prop</span><span class="s0">,</span>
        <span class="s1">trust_alpha</span><span class="s0">,</span>
        <span class="s1">showfliers</span><span class="s0">,</span>
        <span class="s1">box_kws</span><span class="s0">,</span>
        <span class="s1">flier_kws</span><span class="s0">,</span>
        <span class="s1">line_kws</span><span class="s0">,</span>
        <span class="s1">plot_kws</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">iter_vars = [self.orient</span><span class="s0">, </span><span class="s2">&quot;hue&quot;</span><span class="s1">]</span>
        <span class="s1">value_var = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[self.orient]</span>

        <span class="s1">estimator = LetterValues(k_depth</span><span class="s0">, </span><span class="s1">outlier_prop</span><span class="s0">, </span><span class="s1">trust_alpha)</span>

        <span class="s1">width_method_options = [</span><span class="s2">&quot;exponential&quot;</span><span class="s0">, </span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s2">&quot;area&quot;</span><span class="s1">]</span>
        <span class="s1">_check_argument(</span><span class="s2">&quot;width_method&quot;</span><span class="s0">, </span><span class="s1">width_method_options</span><span class="s0">, </span><span class="s1">width_method)</span>

        <span class="s1">box_kws = plot_kws </span><span class="s0">if </span><span class="s1">box_kws </span><span class="s0">is None else </span><span class="s1">{**plot_kws</span><span class="s0">, </span><span class="s1">**box_kws}</span>
        <span class="s1">flier_kws = {} </span><span class="s0">if </span><span class="s1">flier_kws </span><span class="s0">is None else </span><span class="s1">flier_kws.copy()</span>
        <span class="s1">line_kws = {} </span><span class="s0">if </span><span class="s1">line_kws </span><span class="s0">is None else </span><span class="s1">line_kws.copy()</span>

        <span class="s0">if </span><span class="s1">linewidth </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">linewidth = </span><span class="s4">0.5 </span><span class="s1">* mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">linewidth = mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">]</span>

        <span class="s1">ax = self.ax</span>

        <span class="s0">for </span><span class="s1">sub_vars</span><span class="s0">, </span><span class="s1">sub_data </span><span class="s0">in </span><span class="s1">self.iter_data(iter_vars</span><span class="s0">,</span>
                                                 <span class="s1">from_comp_data=</span><span class="s0">True,</span>
                                                 <span class="s1">allow_empty=</span><span class="s0">False</span><span class="s1">):</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">inv_ori = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">self.orient)</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">inv_val = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">value_var)</span>

            <span class="s3"># Statistics</span>
            <span class="s1">lv_data = estimator(sub_data[value_var])</span>
            <span class="s1">n = lv_data[</span><span class="s2">&quot;k&quot;</span><span class="s1">] * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span>
            <span class="s1">vals = lv_data[</span><span class="s2">&quot;values&quot;</span><span class="s1">]</span>

            <span class="s1">pos_data = pd.DataFrame({</span>
                <span class="s1">self.orient: [sub_vars[self.orient]]</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: [width * self._native_width]</span><span class="s0">,</span>
            <span class="s1">})</span>
            <span class="s0">if </span><span class="s1">dodge:</span>
                <span class="s1">self._dodge(sub_vars</span><span class="s0">, </span><span class="s1">pos_data)</span>
            <span class="s0">if </span><span class="s1">gap:</span>
                <span class="s1">pos_data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] *= </span><span class="s4">1 </span><span class="s1">- gap</span>

            <span class="s3"># Letter-value boxes</span>
            <span class="s1">levels = lv_data[</span><span class="s2">&quot;levels&quot;</span><span class="s1">]</span>
            <span class="s1">exponent = (levels - </span><span class="s4">1 </span><span class="s1">- lv_data[</span><span class="s2">&quot;k&quot;</span><span class="s1">]).astype(float)</span>
            <span class="s0">if </span><span class="s1">width_method == </span><span class="s2">&quot;linear&quot;</span><span class="s1">:</span>
                <span class="s1">rel_widths = levels + </span><span class="s4">1</span>
            <span class="s0">elif </span><span class="s1">width_method == </span><span class="s2">&quot;exponential&quot;</span><span class="s1">:</span>
                <span class="s1">rel_widths = </span><span class="s4">2 </span><span class="s1">** exponent</span>
            <span class="s0">elif </span><span class="s1">width_method == </span><span class="s2">&quot;area&quot;</span><span class="s1">:</span>
                <span class="s1">tails = levels &lt; (lv_data[</span><span class="s2">&quot;k&quot;</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">rel_widths = </span><span class="s4">2 </span><span class="s1">** (exponent - tails) / np.diff(lv_data[</span><span class="s2">&quot;values&quot;</span><span class="s1">])</span>

            <span class="s1">center = pos_data[self.orient].item()</span>
            <span class="s1">widths = rel_widths / rel_widths.max() * pos_data[</span><span class="s2">&quot;width&quot;</span><span class="s1">].item()</span>

            <span class="s1">box_vals = inv_val(vals)</span>
            <span class="s1">box_pos = inv_ori(center - widths / </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">box_heights = inv_val(vals[</span><span class="s4">1</span><span class="s1">:]) - inv_val(vals[:-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">box_widths = inv_ori(center + widths / </span><span class="s4">2</span><span class="s1">) - inv_ori(center - widths / </span><span class="s4">2</span><span class="s1">)</span>

            <span class="s1">maincolor = self._hue_map(sub_vars[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]) </span><span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">sub_vars </span><span class="s0">else </span><span class="s1">color</span>
            <span class="s1">flier_colors = {</span>
                <span class="s2">&quot;facecolor&quot;</span><span class="s1">: </span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">: </span><span class="s2">&quot;.45&quot; </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">maincolor</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">cmap = light_palette(maincolor</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">boxcolors = cmap(</span><span class="s4">2 </span><span class="s1">** ((exponent + </span><span class="s4">2</span><span class="s1">) / </span><span class="s4">3</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">boxcolors = maincolor</span>

            <span class="s1">boxen = []</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
                <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s1">:</span>
                    <span class="s1">xy = (box_pos[i]</span><span class="s0">, </span><span class="s1">box_vals[i])</span>
                    <span class="s1">w</span><span class="s0">, </span><span class="s1">h = (box_widths[i]</span><span class="s0">, </span><span class="s1">box_heights[i])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">xy = (box_vals[i]</span><span class="s0">, </span><span class="s1">box_pos[i])</span>
                    <span class="s1">w</span><span class="s0">, </span><span class="s1">h = (box_heights[i]</span><span class="s0">, </span><span class="s1">box_widths[i])</span>
                <span class="s1">boxen.append(Rectangle(xy</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">h))</span>

            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">box_colors = {</span><span class="s2">&quot;facecolors&quot;</span><span class="s1">: boxcolors</span><span class="s0">, </span><span class="s2">&quot;edgecolors&quot;</span><span class="s1">: linecolor}</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">box_colors = {</span><span class="s2">&quot;facecolors&quot;</span><span class="s1">: </span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;edgecolors&quot;</span><span class="s1">: boxcolors}</span>

            <span class="s1">collection_kws = {**box_colors</span><span class="s0">, </span><span class="s2">&quot;linewidth&quot;</span><span class="s1">: linewidth</span><span class="s0">, </span><span class="s1">**box_kws}</span>
            <span class="s1">ax.add_collection(PatchCollection(boxen</span><span class="s0">, </span><span class="s1">**collection_kws)</span><span class="s0">, </span><span class="s1">autolim=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">ax.update_datalim(</span>
                <span class="s1">np.column_stack([box_vals</span><span class="s0">, </span><span class="s1">box_vals])</span><span class="s0">,</span>
                <span class="s1">updatex=self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s0">,</span>
                <span class="s1">updatey=self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s3"># Median line</span>
            <span class="s1">med = lv_data[</span><span class="s2">&quot;median&quot;</span><span class="s1">]</span>
            <span class="s1">hw = pos_data[</span><span class="s2">&quot;width&quot;</span><span class="s1">].item() / </span><span class="s4">2</span>
            <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s1">:</span>
                <span class="s1">x</span><span class="s0">, </span><span class="s1">y = inv_ori([center - hw</span><span class="s0">, </span><span class="s1">center + hw])</span><span class="s0">, </span><span class="s1">inv_val([med</span><span class="s0">, </span><span class="s1">med])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x</span><span class="s0">, </span><span class="s1">y = inv_val([med</span><span class="s0">, </span><span class="s1">med])</span><span class="s0">, </span><span class="s1">inv_ori([center - hw</span><span class="s0">, </span><span class="s1">center + hw])</span>
            <span class="s1">default_kws = {</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: linecolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">maincolor</span><span class="s0">,</span>
                <span class="s2">&quot;solid_capstyle&quot;</span><span class="s1">: </span><span class="s2">&quot;butt&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;linewidth&quot;</span><span class="s1">: </span><span class="s4">1.25 </span><span class="s1">* linewidth</span><span class="s0">,</span>
            <span class="s1">}</span>
            <span class="s1">ax.plot(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">**{**default_kws</span><span class="s0">, </span><span class="s1">**line_kws})</span>

            <span class="s3"># Outliers (&quot;fliers&quot;)</span>
            <span class="s0">if </span><span class="s1">showfliers:</span>
                <span class="s1">vals = inv_val(lv_data[</span><span class="s2">&quot;fliers&quot;</span><span class="s1">])</span>
                <span class="s1">pos = np.full(len(vals)</span><span class="s0">, </span><span class="s1">inv_ori(pos_data[self.orient].item()))</span>
                <span class="s1">x</span><span class="s0">, </span><span class="s1">y = (pos</span><span class="s0">, </span><span class="s1">vals) </span><span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot; </span><span class="s0">else </span><span class="s1">(vals</span><span class="s0">, </span><span class="s1">pos)</span>
                <span class="s1">ax.scatter(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">**{**flier_colors</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">: </span><span class="s4">25</span><span class="s0">, </span><span class="s1">**flier_kws})</span>

        <span class="s1">ax.autoscale_view(scalex=self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">scaley=self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s1">legend_artist = _get_patch_legend_artist(fill)</span>
        <span class="s1">common_kws = {**box_kws</span><span class="s0">, </span><span class="s2">&quot;linewidth&quot;</span><span class="s1">: linewidth</span><span class="s0">, </span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">: linecolor}</span>
        <span class="s1">self._configure_legend(ax</span><span class="s0">, </span><span class="s1">legend_artist</span><span class="s0">, </span><span class="s1">common_kws)</span>

    <span class="s0">def </span><span class="s1">plot_violins(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">width</span><span class="s0">,</span>
        <span class="s1">dodge</span><span class="s0">,</span>
        <span class="s1">gap</span><span class="s0">,</span>
        <span class="s1">split</span><span class="s0">,</span>
        <span class="s1">color</span><span class="s0">,</span>
        <span class="s1">fill</span><span class="s0">,</span>
        <span class="s1">linecolor</span><span class="s0">,</span>
        <span class="s1">linewidth</span><span class="s0">,</span>
        <span class="s1">inner</span><span class="s0">,</span>
        <span class="s1">density_norm</span><span class="s0">,</span>
        <span class="s1">common_norm</span><span class="s0">,</span>
        <span class="s1">kde_kws</span><span class="s0">,</span>
        <span class="s1">inner_kws</span><span class="s0">,</span>
        <span class="s1">plot_kws</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">iter_vars = [self.orient</span><span class="s0">, </span><span class="s2">&quot;hue&quot;</span><span class="s1">]</span>
        <span class="s1">value_var = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[self.orient]</span>

        <span class="s1">inner_options = [</span><span class="s2">&quot;box&quot;</span><span class="s0">, </span><span class="s2">&quot;quart&quot;</span><span class="s0">, </span><span class="s2">&quot;stick&quot;</span><span class="s0">, </span><span class="s2">&quot;point&quot;</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">_check_argument(</span><span class="s2">&quot;inner&quot;</span><span class="s0">, </span><span class="s1">inner_options</span><span class="s0">, </span><span class="s1">inner</span><span class="s0">, </span><span class="s1">prefix=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">_check_argument(</span><span class="s2">&quot;density_norm&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;area&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">density_norm)</span>

        <span class="s0">if </span><span class="s1">linewidth </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">linewidth = </span><span class="s4">1.25 </span><span class="s1">* mpl.rcParams[</span><span class="s2">&quot;patch.linewidth&quot;</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">linewidth = mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">inner </span><span class="s0">is not None and </span><span class="s1">inner.startswith(</span><span class="s2">&quot;box&quot;</span><span class="s1">):</span>
            <span class="s1">box_width = inner_kws.pop(</span><span class="s2">&quot;box_width&quot;</span><span class="s0">, </span><span class="s1">linewidth * </span><span class="s4">4.5</span><span class="s1">)</span>
            <span class="s1">whis_width = inner_kws.pop(</span><span class="s2">&quot;whis_width&quot;</span><span class="s0">, </span><span class="s1">box_width / </span><span class="s4">3</span><span class="s1">)</span>
            <span class="s1">marker = inner_kws.pop(</span><span class="s2">&quot;marker&quot;</span><span class="s0">, </span><span class="s2">&quot;_&quot; </span><span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot; </span><span class="s0">else </span><span class="s2">&quot;|&quot;</span><span class="s1">)</span>

        <span class="s1">kde = KDE(**kde_kws)</span>
        <span class="s1">ax = self.ax</span>
        <span class="s1">violin_data = []</span>

        <span class="s3"># Iterate through all the data splits once to compute the KDEs</span>
        <span class="s0">for </span><span class="s1">sub_vars</span><span class="s0">, </span><span class="s1">sub_data </span><span class="s0">in </span><span class="s1">self.iter_data(iter_vars</span><span class="s0">,</span>
                                                 <span class="s1">from_comp_data=</span><span class="s0">True,</span>
                                                 <span class="s1">allow_empty=</span><span class="s0">False</span><span class="s1">):</span>

            <span class="s1">sub_data[</span><span class="s2">&quot;weight&quot;</span><span class="s1">] = sub_data.get(</span><span class="s2">&quot;weights&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">stat_data = kde._transform(sub_data</span><span class="s0">, </span><span class="s1">value_var</span><span class="s0">, </span><span class="s1">[])</span>

            <span class="s1">maincolor = self._hue_map(sub_vars[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]) </span><span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">sub_vars </span><span class="s0">else </span><span class="s1">color</span>
            <span class="s0">if not </span><span class="s1">fill:</span>
                <span class="s1">linecolor = maincolor</span>
                <span class="s1">maincolor = </span><span class="s2">&quot;none&quot;</span>
            <span class="s1">default_kws = dict(</span>
                <span class="s1">facecolor=maincolor</span><span class="s0">,</span>
                <span class="s1">edgecolor=linecolor</span><span class="s0">,</span>
                <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">violin_data.append({</span>
                <span class="s2">&quot;position&quot;</span><span class="s1">: sub_vars[self.orient]</span><span class="s0">,</span>
                <span class="s2">&quot;observations&quot;</span><span class="s1">: sub_data[value_var]</span><span class="s0">,</span>
                <span class="s2">&quot;density&quot;</span><span class="s1">: stat_data[</span><span class="s2">&quot;density&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;support&quot;</span><span class="s1">: stat_data[value_var]</span><span class="s0">,</span>
                <span class="s2">&quot;kwargs&quot;</span><span class="s1">: {**default_kws</span><span class="s0">, </span><span class="s1">**plot_kws}</span><span class="s0">,</span>
                <span class="s2">&quot;sub_vars&quot;</span><span class="s1">: sub_vars</span><span class="s0">,</span>
                <span class="s2">&quot;ax&quot;</span><span class="s1">: self._get_axes(sub_vars)</span><span class="s0">,</span>
            <span class="s1">})</span>

        <span class="s3"># Once we've computed all the KDEs, get statistics for normalization</span>
        <span class="s0">def </span><span class="s1">vars_to_key(sub_vars):</span>
            <span class="s0">return </span><span class="s1">tuple((k</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">sub_vars.items() </span><span class="s0">if </span><span class="s1">k != self.orient)</span>

        <span class="s1">norm_keys = [vars_to_key(violin[</span><span class="s2">&quot;sub_vars&quot;</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">violin </span><span class="s0">in </span><span class="s1">violin_data]</span>
        <span class="s0">if </span><span class="s1">common_norm:</span>
            <span class="s1">common_max_density = np.nanmax([v[</span><span class="s2">&quot;density&quot;</span><span class="s1">].max() </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">violin_data])</span>
            <span class="s1">common_max_count = np.nanmax([len(v[</span><span class="s2">&quot;observations&quot;</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">violin_data])</span>
            <span class="s1">max_density = {key: common_max_density </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">norm_keys}</span>
            <span class="s1">max_count = {key: common_max_count </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">norm_keys}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s3"># Ignore warning when all violins are singular; it's not important</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s2">'ignore'</span><span class="s0">, </span><span class="s2">&quot;All-NaN (slice|axis) encountered&quot;</span><span class="s1">)</span>
                <span class="s1">max_density = {</span>
                    <span class="s1">key: np.nanmax([</span>
                        <span class="s1">v[</span><span class="s2">&quot;density&quot;</span><span class="s1">].max() </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">violin_data</span>
                        <span class="s0">if </span><span class="s1">vars_to_key(v[</span><span class="s2">&quot;sub_vars&quot;</span><span class="s1">]) == key</span>
                    <span class="s1">]) </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">norm_keys</span>
                <span class="s1">}</span>
            <span class="s1">max_count = {</span>
                <span class="s1">key: np.nanmax([</span>
                    <span class="s1">len(v[</span><span class="s2">&quot;observations&quot;</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">violin_data</span>
                    <span class="s0">if </span><span class="s1">vars_to_key(v[</span><span class="s2">&quot;sub_vars&quot;</span><span class="s1">]) == key</span>
                <span class="s1">]) </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">norm_keys</span>
            <span class="s1">}</span>

        <span class="s1">real_width = width * self._native_width</span>

        <span class="s3"># Now iterate through the violins again to apply the normalization and plot</span>
        <span class="s0">for </span><span class="s1">violin </span><span class="s0">in </span><span class="s1">violin_data:</span>

            <span class="s1">index = pd.RangeIndex(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">max(len(violin[</span><span class="s2">&quot;support&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">data = pd.DataFrame({</span>
                <span class="s1">self.orient: violin[</span><span class="s2">&quot;position&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">value_var: violin[</span><span class="s2">&quot;support&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;density&quot;</span><span class="s1">: violin[</span><span class="s2">&quot;density&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: real_width</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">, </span><span class="s1">index=index)</span>

            <span class="s0">if </span><span class="s1">dodge:</span>
                <span class="s1">self._dodge(violin[</span><span class="s2">&quot;sub_vars&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data)</span>
            <span class="s0">if </span><span class="s1">gap:</span>
                <span class="s1">data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] *= </span><span class="s4">1 </span><span class="s1">- gap</span>

            <span class="s3"># Normalize the density across the distribution(s) and relative to the width</span>
            <span class="s1">norm_key = vars_to_key(violin[</span><span class="s2">&quot;sub_vars&quot;</span><span class="s1">])</span>
            <span class="s1">hw = data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] / </span><span class="s4">2</span>
            <span class="s1">peak_density = violin[</span><span class="s2">&quot;density&quot;</span><span class="s1">].max()</span>
            <span class="s0">if </span><span class="s1">np.isnan(peak_density):</span>
                <span class="s1">span = </span><span class="s4">1</span>
            <span class="s0">elif </span><span class="s1">density_norm == </span><span class="s2">&quot;area&quot;</span><span class="s1">:</span>
                <span class="s1">span = data[</span><span class="s2">&quot;density&quot;</span><span class="s1">] / max_density[norm_key]</span>
            <span class="s0">elif </span><span class="s1">density_norm == </span><span class="s2">&quot;count&quot;</span><span class="s1">:</span>
                <span class="s1">count = len(violin[</span><span class="s2">&quot;observations&quot;</span><span class="s1">])</span>
                <span class="s1">span = data[</span><span class="s2">&quot;density&quot;</span><span class="s1">] / peak_density * (count / max_count[norm_key])</span>
            <span class="s0">elif </span><span class="s1">density_norm == </span><span class="s2">&quot;width&quot;</span><span class="s1">:</span>
                <span class="s1">span = data[</span><span class="s2">&quot;density&quot;</span><span class="s1">] / peak_density</span>
            <span class="s1">span = span * hw * (</span><span class="s4">2 </span><span class="s0">if </span><span class="s1">split </span><span class="s0">else </span><span class="s4">1</span><span class="s1">)</span>

            <span class="s3"># Handle split violins (i.e. asymmetric spans)</span>
            <span class="s1">right_side = (</span>
                <span class="s4">0 </span><span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">not in </span><span class="s1">self.variables</span>
                <span class="s0">else </span><span class="s1">self._hue_map.levels.index(violin[</span><span class="s2">&quot;sub_vars&quot;</span><span class="s1">][</span><span class="s2">&quot;hue&quot;</span><span class="s1">]) % </span><span class="s4">2</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">split:</span>
                <span class="s1">offsets = (hw</span><span class="s0">, </span><span class="s1">span - hw) </span><span class="s0">if </span><span class="s1">right_side </span><span class="s0">else </span><span class="s1">(span - hw</span><span class="s0">, </span><span class="s1">hw)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">offsets = span</span><span class="s0">, </span><span class="s1">span</span>

            <span class="s1">ax = violin[</span><span class="s2">&quot;ax&quot;</span><span class="s1">]</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">invx = _get_transform_functions(ax</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">invy = _get_transform_functions(ax</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">)</span>
            <span class="s1">inv_pos = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: invx</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: invy}[self.orient]</span>
            <span class="s1">inv_val = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: invx</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: invy}[value_var]</span>

            <span class="s1">linecolor = violin[</span><span class="s2">&quot;kwargs&quot;</span><span class="s1">][</span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">]</span>

            <span class="s3"># Handle singular datasets (one or more observations with no variance</span>
            <span class="s0">if </span><span class="s1">np.isnan(peak_density):</span>
                <span class="s1">pos = data[self.orient].iloc[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">val = violin[</span><span class="s2">&quot;observations&quot;</span><span class="s1">].mean()</span>
                <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s1">:</span>
                    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = [pos - offsets[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pos + offsets[</span><span class="s4">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[val</span><span class="s0">, </span><span class="s1">val]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = [val</span><span class="s0">, </span><span class="s1">val]</span><span class="s0">, </span><span class="s1">[pos - offsets[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pos + offsets[</span><span class="s4">1</span><span class="s1">]]</span>
                <span class="s1">ax.plot(invx(x)</span><span class="s0">, </span><span class="s1">invy(y)</span><span class="s0">, </span><span class="s1">color=linecolor</span><span class="s0">, </span><span class="s1">linewidth=linewidth)</span>
                <span class="s0">continue</span>

            <span class="s3"># Plot the main violin body</span>
            <span class="s1">plot_func = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: ax.fill_betweenx</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: ax.fill_between}[self.orient]</span>
            <span class="s1">plot_func(</span>
                <span class="s1">inv_val(data[value_var])</span><span class="s0">,</span>
                <span class="s1">inv_pos(data[self.orient] - offsets[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">,</span>
                <span class="s1">inv_pos(data[self.orient] + offsets[</span><span class="s4">1</span><span class="s1">])</span><span class="s0">,</span>
                <span class="s1">**violin[</span><span class="s2">&quot;kwargs&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>

            <span class="s3"># Adjust the observation data</span>
            <span class="s1">obs = violin[</span><span class="s2">&quot;observations&quot;</span><span class="s1">]</span>
            <span class="s1">pos_dict = {self.orient: violin[</span><span class="s2">&quot;position&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: real_width}</span>
            <span class="s0">if </span><span class="s1">dodge:</span>
                <span class="s1">self._dodge(violin[</span><span class="s2">&quot;sub_vars&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pos_dict)</span>
            <span class="s0">if </span><span class="s1">gap:</span>
                <span class="s1">pos_dict[</span><span class="s2">&quot;width&quot;</span><span class="s1">] *= (</span><span class="s4">1 </span><span class="s1">- gap)</span>

            <span class="s3"># --- Plot the inner components</span>
            <span class="s0">if </span><span class="s1">inner </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>

            <span class="s0">elif </span><span class="s1">inner.startswith(</span><span class="s2">&quot;point&quot;</span><span class="s1">):</span>
                <span class="s1">pos = np.array([pos_dict[self.orient]] * len(obs))</span>
                <span class="s0">if </span><span class="s1">split:</span>
                    <span class="s1">pos += (-</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">right_side </span><span class="s0">else </span><span class="s4">1</span><span class="s1">) * pos_dict[</span><span class="s2">&quot;width&quot;</span><span class="s1">] / </span><span class="s4">2</span>
                <span class="s1">x</span><span class="s0">, </span><span class="s1">y = (pos</span><span class="s0">, </span><span class="s1">obs) </span><span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot; </span><span class="s0">else </span><span class="s1">(obs</span><span class="s0">, </span><span class="s1">pos)</span>
                <span class="s1">kws = {</span>
                    <span class="s2">&quot;color&quot;</span><span class="s1">: linecolor</span><span class="s0">,</span>
                    <span class="s2">&quot;edgecolor&quot;</span><span class="s1">: linecolor</span><span class="s0">,</span>
                    <span class="s2">&quot;s&quot;</span><span class="s1">: (linewidth * </span><span class="s4">2</span><span class="s1">) ** </span><span class="s4">2</span><span class="s0">,</span>
                    <span class="s2">&quot;zorder&quot;</span><span class="s1">: violin[</span><span class="s2">&quot;kwargs&quot;</span><span class="s1">].get(</span><span class="s2">&quot;zorder&quot;</span><span class="s0">, </span><span class="s4">2</span><span class="s1">) + </span><span class="s4">1</span><span class="s0">,</span>
                    <span class="s1">**inner_kws</span><span class="s0">,</span>
                <span class="s1">}</span>
                <span class="s1">ax.scatter(invx(x)</span><span class="s0">, </span><span class="s1">invy(y)</span><span class="s0">, </span><span class="s1">**kws)</span>

            <span class="s0">elif </span><span class="s1">inner.startswith(</span><span class="s2">&quot;stick&quot;</span><span class="s1">):</span>
                <span class="s1">pos0 = np.interp(obs</span><span class="s0">, </span><span class="s1">data[value_var]</span><span class="s0">, </span><span class="s1">data[self.orient] - offsets[</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s1">pos1 = np.interp(obs</span><span class="s0">, </span><span class="s1">data[value_var]</span><span class="s0">, </span><span class="s1">data[self.orient] + offsets[</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">pos_pts = np.stack([inv_pos(pos0)</span><span class="s0">, </span><span class="s1">inv_pos(pos1)])</span>
                <span class="s1">val_pts = np.stack([inv_val(obs)</span><span class="s0">, </span><span class="s1">inv_val(obs)])</span>
                <span class="s1">segments = np.stack([pos_pts</span><span class="s0">, </span><span class="s1">val_pts]).transpose(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s1">:</span>
                    <span class="s1">segments = segments[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">::-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">kws = {</span>
                    <span class="s2">&quot;color&quot;</span><span class="s1">: linecolor</span><span class="s0">,</span>
                    <span class="s2">&quot;linewidth&quot;</span><span class="s1">: linewidth / </span><span class="s4">2</span><span class="s0">,</span>
                    <span class="s1">**inner_kws</span><span class="s0">,</span>
                <span class="s1">}</span>
                <span class="s1">lines = mpl.collections.LineCollection(segments</span><span class="s0">, </span><span class="s1">**kws)</span>
                <span class="s1">ax.add_collection(lines</span><span class="s0">, </span><span class="s1">autolim=</span><span class="s0">False</span><span class="s1">)</span>

            <span class="s0">elif </span><span class="s1">inner.startswith(</span><span class="s2">&quot;quart&quot;</span><span class="s1">):</span>
                <span class="s1">stats = np.percentile(obs</span><span class="s0">, </span><span class="s1">[</span><span class="s4">25</span><span class="s0">, </span><span class="s4">50</span><span class="s0">, </span><span class="s4">75</span><span class="s1">])</span>
                <span class="s1">pos0 = np.interp(stats</span><span class="s0">, </span><span class="s1">data[value_var]</span><span class="s0">, </span><span class="s1">data[self.orient] - offsets[</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s1">pos1 = np.interp(stats</span><span class="s0">, </span><span class="s1">data[value_var]</span><span class="s0">, </span><span class="s1">data[self.orient] + offsets[</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">pos_pts = np.stack([inv_pos(pos0)</span><span class="s0">, </span><span class="s1">inv_pos(pos1)])</span>
                <span class="s1">val_pts = np.stack([inv_val(stats)</span><span class="s0">, </span><span class="s1">inv_val(stats)])</span>
                <span class="s1">segments = np.stack([pos_pts</span><span class="s0">, </span><span class="s1">val_pts]).transpose(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s1">:</span>
                    <span class="s1">segments = segments[:</span><span class="s0">, </span><span class="s1">::-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">:]</span>
                <span class="s1">dashes = [(</span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">.75</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">.75</span><span class="s1">)]</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">segment </span><span class="s0">in </span><span class="s1">enumerate(segments):</span>
                    <span class="s1">kws = {</span>
                        <span class="s2">&quot;color&quot;</span><span class="s1">: linecolor</span><span class="s0">,</span>
                        <span class="s2">&quot;linewidth&quot;</span><span class="s1">: linewidth</span><span class="s0">,</span>
                        <span class="s2">&quot;dashes&quot;</span><span class="s1">: dashes[i]</span><span class="s0">,</span>
                        <span class="s1">**inner_kws</span><span class="s0">,</span>
                    <span class="s1">}</span>
                    <span class="s1">ax.plot(*segment</span><span class="s0">, </span><span class="s1">**kws)</span>

            <span class="s0">elif </span><span class="s1">inner.startswith(</span><span class="s2">&quot;box&quot;</span><span class="s1">):</span>
                <span class="s1">stats = mpl.cbook.boxplot_stats(obs)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">pos = np.array(pos_dict[self.orient])</span>
                <span class="s0">if </span><span class="s1">split:</span>
                    <span class="s1">pos += (-</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">right_side </span><span class="s0">else </span><span class="s4">1</span><span class="s1">) * pos_dict[</span><span class="s2">&quot;width&quot;</span><span class="s1">] / </span><span class="s4">2</span>
                <span class="s1">pos = [pos</span><span class="s0">, </span><span class="s1">pos]</span><span class="s0">, </span><span class="s1">[pos</span><span class="s0">, </span><span class="s1">pos]</span><span class="s0">, </span><span class="s1">[pos]</span>
                <span class="s1">val = (</span>
                    <span class="s1">[stats[</span><span class="s2">&quot;whislo&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">stats[</span><span class="s2">&quot;whishi&quot;</span><span class="s1">]]</span><span class="s0">,</span>
                    <span class="s1">[stats[</span><span class="s2">&quot;q1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">stats[</span><span class="s2">&quot;q3&quot;</span><span class="s1">]]</span><span class="s0">,</span>
                    <span class="s1">[stats[</span><span class="s2">&quot;med&quot;</span><span class="s1">]]</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s1">:</span>
                    <span class="s1">(x0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">x2)</span><span class="s0">, </span><span class="s1">(y0</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">y2) = pos</span><span class="s0">, </span><span class="s1">val</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">(x0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">x2)</span><span class="s0">, </span><span class="s1">(y0</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">y2) = val</span><span class="s0">, </span><span class="s1">pos</span>

                <span class="s0">if </span><span class="s1">split:</span>
                    <span class="s1">offset = (</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">right_side </span><span class="s0">else </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) * box_width / </span><span class="s4">72 </span><span class="s1">/ </span><span class="s4">2</span>
                    <span class="s1">dx</span><span class="s0">, </span><span class="s1">dy = (offset</span><span class="s0">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot; </span><span class="s0">else </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">-offset)</span>
                    <span class="s1">trans = ax.transData + mpl.transforms.ScaledTranslation(</span>
                        <span class="s1">dx</span><span class="s0">, </span><span class="s1">dy</span><span class="s0">, </span><span class="s1">ax.figure.dpi_scale_trans</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">trans = ax.transData</span>
                <span class="s1">line_kws = {</span>
                    <span class="s2">&quot;color&quot;</span><span class="s1">: linecolor</span><span class="s0">,</span>
                    <span class="s2">&quot;transform&quot;</span><span class="s1">: trans</span><span class="s0">,</span>
                    <span class="s1">**inner_kws</span><span class="s0">,</span>
                    <span class="s2">&quot;linewidth&quot;</span><span class="s1">: whis_width</span><span class="s0">,</span>
                <span class="s1">}</span>
                <span class="s1">ax.plot(invx(x0)</span><span class="s0">, </span><span class="s1">invy(y0)</span><span class="s0">, </span><span class="s1">**line_kws)</span>
                <span class="s1">line_kws[</span><span class="s2">&quot;linewidth&quot;</span><span class="s1">] = box_width</span>
                <span class="s1">ax.plot(invx(x1)</span><span class="s0">, </span><span class="s1">invy(y1)</span><span class="s0">, </span><span class="s1">**line_kws)</span>
                <span class="s1">dot_kws = {</span>
                    <span class="s2">&quot;marker&quot;</span><span class="s1">: marker</span><span class="s0">,</span>
                    <span class="s2">&quot;markersize&quot;</span><span class="s1">: box_width / </span><span class="s4">1.2</span><span class="s0">,</span>
                    <span class="s2">&quot;markeredgewidth&quot;</span><span class="s1">: box_width / </span><span class="s4">5</span><span class="s0">,</span>
                    <span class="s2">&quot;transform&quot;</span><span class="s1">: trans</span><span class="s0">,</span>
                    <span class="s1">**inner_kws</span><span class="s0">,</span>
                    <span class="s2">&quot;markeredgecolor&quot;</span><span class="s1">: </span><span class="s2">&quot;w&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;markerfacecolor&quot;</span><span class="s1">: </span><span class="s2">&quot;w&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;color&quot;</span><span class="s1">: linecolor</span><span class="s0">,  </span><span class="s3"># simplify tests</span>
                <span class="s1">}</span>
                <span class="s1">ax.plot(invx(x2)</span><span class="s0">, </span><span class="s1">invy(y2)</span><span class="s0">, </span><span class="s1">**dot_kws)</span>

        <span class="s1">legend_artist = _get_patch_legend_artist(fill)</span>
        <span class="s1">common_kws = {**plot_kws</span><span class="s0">, </span><span class="s2">&quot;linewidth&quot;</span><span class="s1">: linewidth</span><span class="s0">, </span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">: linecolor}</span>
        <span class="s1">self._configure_legend(ax</span><span class="s0">, </span><span class="s1">legend_artist</span><span class="s0">, </span><span class="s1">common_kws)</span>

    <span class="s0">def </span><span class="s1">plot_points(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">aggregator</span><span class="s0">,</span>
        <span class="s1">markers</span><span class="s0">,</span>
        <span class="s1">linestyles</span><span class="s0">,</span>
        <span class="s1">dodge</span><span class="s0">,</span>
        <span class="s1">color</span><span class="s0">,</span>
        <span class="s1">capsize</span><span class="s0">,</span>
        <span class="s1">err_kws</span><span class="s0">,</span>
        <span class="s1">plot_kws</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">agg_var = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[self.orient]</span>
        <span class="s1">iter_vars = [</span><span class="s2">&quot;hue&quot;</span><span class="s1">]</span>

        <span class="s1">plot_kws = _normalize_kwargs(plot_kws</span><span class="s0">, </span><span class="s1">mpl.lines.Line2D)</span>
        <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s1">mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">] * </span><span class="s4">1.8</span><span class="s1">)</span>
        <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;markeredgewidth&quot;</span><span class="s0">, </span><span class="s1">plot_kws[</span><span class="s2">&quot;linewidth&quot;</span><span class="s1">] * </span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;markersize&quot;</span><span class="s0">, </span><span class="s1">plot_kws[</span><span class="s2">&quot;linewidth&quot;</span><span class="s1">] * np.sqrt(</span><span class="s4">2 </span><span class="s1">* np.pi))</span>

        <span class="s1">markers = self._map_prop_with_hue(</span><span class="s2">&quot;marker&quot;</span><span class="s0">, </span><span class="s1">markers</span><span class="s0">, </span><span class="s2">&quot;o&quot;</span><span class="s0">, </span><span class="s1">plot_kws)</span>
        <span class="s1">linestyles = self._map_prop_with_hue(</span><span class="s2">&quot;linestyle&quot;</span><span class="s0">, </span><span class="s1">linestyles</span><span class="s0">, </span><span class="s2">&quot;-&quot;</span><span class="s0">, </span><span class="s1">plot_kws)</span>

        <span class="s1">base_positions = self.var_levels[self.orient]</span>
        <span class="s0">if </span><span class="s1">self.var_types[self.orient] == </span><span class="s2">&quot;categorical&quot;</span><span class="s1">:</span>
            <span class="s1">min_cat_val = int(self.comp_data[self.orient].min())</span>
            <span class="s1">max_cat_val = int(self.comp_data[self.orient].max())</span>
            <span class="s1">base_positions = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(min_cat_val</span><span class="s0">, </span><span class="s1">max_cat_val + </span><span class="s4">1</span><span class="s1">)]</span>

        <span class="s1">n_hue_levels = </span><span class="s4">0 </span><span class="s0">if </span><span class="s1">self._hue_map.levels </span><span class="s0">is None else </span><span class="s1">len(self._hue_map.levels)</span>
        <span class="s0">if </span><span class="s1">dodge </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">dodge = </span><span class="s4">.025 </span><span class="s1">* n_hue_levels</span>

        <span class="s1">ax = self.ax</span>

        <span class="s0">for </span><span class="s1">sub_vars</span><span class="s0">, </span><span class="s1">sub_data </span><span class="s0">in </span><span class="s1">self.iter_data(iter_vars</span><span class="s0">,</span>
                                                 <span class="s1">from_comp_data=</span><span class="s0">True,</span>
                                                 <span class="s1">allow_empty=</span><span class="s0">True</span><span class="s1">):</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s1">ori_axis = getattr(ax</span><span class="s0">, </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.orient</span><span class="s0">}</span><span class="s2">axis&quot;</span><span class="s1">)</span>
            <span class="s1">transform</span><span class="s0">, </span><span class="s1">_ = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">self.orient)</span>
            <span class="s1">positions = transform(ori_axis.convert_units(base_positions))</span>
            <span class="s1">agg_data = sub_data </span><span class="s0">if </span><span class="s1">sub_data.empty </span><span class="s0">else </span><span class="s1">(</span>
                <span class="s1">sub_data</span>
                <span class="s1">.groupby(self.orient)</span>
                <span class="s1">.apply(aggregator</span><span class="s0">, </span><span class="s1">agg_var)</span>
                <span class="s1">.reindex(pd.Index(positions</span><span class="s0">, </span><span class="s1">name=self.orient))</span>
                <span class="s1">.reset_index()</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">dodge:</span>
                <span class="s1">hue_idx = self._hue_map.levels.index(sub_vars[</span><span class="s2">&quot;hue&quot;</span><span class="s1">])</span>
                <span class="s1">step_size = dodge / (n_hue_levels - </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">offset = -dodge / </span><span class="s4">2 </span><span class="s1">+ step_size * hue_idx</span>
                <span class="s1">agg_data[self.orient] += offset * self._native_width</span>

            <span class="s1">self._invert_scale(ax</span><span class="s0">, </span><span class="s1">agg_data)</span>

            <span class="s1">sub_kws = plot_kws.copy()</span>
            <span class="s1">sub_kws.update(</span>
                <span class="s1">marker=markers[sub_vars.get(</span><span class="s2">&quot;hue&quot;</span><span class="s1">)]</span><span class="s0">,</span>
                <span class="s1">linestyle=linestyles[sub_vars.get(</span><span class="s2">&quot;hue&quot;</span><span class="s1">)]</span><span class="s0">,</span>
                <span class="s1">color=self._hue_map(sub_vars[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]) </span><span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">sub_vars </span><span class="s0">else </span><span class="s1">color</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">line</span><span class="s0">, </span><span class="s1">= ax.plot(agg_data[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">agg_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**sub_kws)</span>

            <span class="s1">sub_err_kws = err_kws.copy()</span>
            <span class="s1">line_props = line.properties()</span>
            <span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s2">&quot;alpha&quot;</span><span class="s0">, </span><span class="s2">&quot;zorder&quot;</span><span class="s1">]:</span>
                <span class="s1">sub_err_kws.setdefault(prop</span><span class="s0">, </span><span class="s1">line_props[prop])</span>
            <span class="s0">if </span><span class="s1">aggregator.error_method </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self.plot_errorbars(ax</span><span class="s0">, </span><span class="s1">agg_data</span><span class="s0">, </span><span class="s1">capsize</span><span class="s0">, </span><span class="s1">sub_err_kws)</span>

        <span class="s1">legend_artist = partial(mpl.lines.Line2D</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">semantic_kws = {</span><span class="s2">&quot;hue&quot;</span><span class="s1">: {</span><span class="s2">&quot;marker&quot;</span><span class="s1">: markers</span><span class="s0">, </span><span class="s2">&quot;linestyle&quot;</span><span class="s1">: linestyles}}</span>
        <span class="s1">self._configure_legend(ax</span><span class="s0">, </span><span class="s1">legend_artist</span><span class="s0">, </span><span class="s1">sub_kws</span><span class="s0">, </span><span class="s1">semantic_kws)</span>

    <span class="s0">def </span><span class="s1">plot_bars(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">aggregator</span><span class="s0">,</span>
        <span class="s1">dodge</span><span class="s0">,</span>
        <span class="s1">gap</span><span class="s0">,</span>
        <span class="s1">width</span><span class="s0">,</span>
        <span class="s1">fill</span><span class="s0">,</span>
        <span class="s1">color</span><span class="s0">,</span>
        <span class="s1">capsize</span><span class="s0">,</span>
        <span class="s1">err_kws</span><span class="s0">,</span>
        <span class="s1">plot_kws</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">agg_var = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[self.orient]</span>
        <span class="s1">iter_vars = [</span><span class="s2">&quot;hue&quot;</span><span class="s1">]</span>

        <span class="s1">ax = self.ax</span>

        <span class="s0">if </span><span class="s1">self._hue_map.levels </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dodge = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">dodge </span><span class="s0">and </span><span class="s1">capsize </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">capsize = capsize / len(self._hue_map.levels)</span>

        <span class="s0">if not </span><span class="s1">fill:</span>
            <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s4">1.5 </span><span class="s1">* mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">])</span>

        <span class="s1">err_kws.setdefault(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s4">1.5 </span><span class="s1">* mpl.rcParams[</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="s1">])</span>

        <span class="s0">for </span><span class="s1">sub_vars</span><span class="s0">, </span><span class="s1">sub_data </span><span class="s0">in </span><span class="s1">self.iter_data(iter_vars</span><span class="s0">,</span>
                                                 <span class="s1">from_comp_data=</span><span class="s0">True,</span>
                                                 <span class="s1">allow_empty=</span><span class="s0">True</span><span class="s1">):</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s1">agg_data = sub_data </span><span class="s0">if </span><span class="s1">sub_data.empty </span><span class="s0">else </span><span class="s1">(</span>
                <span class="s1">sub_data</span>
                <span class="s1">.groupby(self.orient)</span>
                <span class="s1">.apply(aggregator</span><span class="s0">, </span><span class="s1">agg_var)</span>
                <span class="s1">.reset_index()</span>
            <span class="s1">)</span>

            <span class="s1">agg_data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width * self._native_width</span>
            <span class="s0">if </span><span class="s1">dodge:</span>
                <span class="s1">self._dodge(sub_vars</span><span class="s0">, </span><span class="s1">agg_data)</span>
            <span class="s0">if </span><span class="s1">gap:</span>
                <span class="s1">agg_data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] *= </span><span class="s4">1 </span><span class="s1">- gap</span>

            <span class="s1">agg_data[</span><span class="s2">&quot;edge&quot;</span><span class="s1">] = agg_data[self.orient] - agg_data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] / </span><span class="s4">2</span>
            <span class="s1">self._invert_scale(ax</span><span class="s0">, </span><span class="s1">agg_data)</span>

            <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s1">:</span>
                <span class="s1">bar_func = ax.bar</span>
                <span class="s1">kws = dict(</span>
                    <span class="s1">x=agg_data[</span><span class="s2">&quot;edge&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">height=agg_data[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">width=agg_data[</span><span class="s2">&quot;width&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bar_func = ax.barh</span>
                <span class="s1">kws = dict(</span>
                    <span class="s1">y=agg_data[</span><span class="s2">&quot;edge&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">width=agg_data[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">height=agg_data[</span><span class="s2">&quot;width&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>

            <span class="s1">main_color = self._hue_map(sub_vars[</span><span class="s2">&quot;hue&quot;</span><span class="s1">]) </span><span class="s0">if </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">sub_vars </span><span class="s0">else </span><span class="s1">color</span>

            <span class="s3"># Set both color and facecolor for property cycle logic</span>
            <span class="s1">kws[</span><span class="s2">&quot;align&quot;</span><span class="s1">] = </span><span class="s2">&quot;edge&quot;</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">kws.update(color=main_color</span><span class="s0">, </span><span class="s1">facecolor=main_color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">kws.update(color=main_color</span><span class="s0">, </span><span class="s1">edgecolor=main_color</span><span class="s0">, </span><span class="s1">facecolor=</span><span class="s2">&quot;none&quot;</span><span class="s1">)</span>

            <span class="s1">bar_func(**{**kws</span><span class="s0">, </span><span class="s1">**plot_kws})</span>

            <span class="s0">if </span><span class="s1">aggregator.error_method </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self.plot_errorbars(</span>
                    <span class="s1">ax</span><span class="s0">, </span><span class="s1">agg_data</span><span class="s0">, </span><span class="s1">capsize</span><span class="s0">,</span>
                    <span class="s1">{</span><span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s2">&quot;.26&quot; </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">main_color</span><span class="s0">, </span><span class="s1">**err_kws}</span>
                <span class="s1">)</span>

        <span class="s1">legend_artist = _get_patch_legend_artist(fill)</span>
        <span class="s1">self._configure_legend(ax</span><span class="s0">, </span><span class="s1">legend_artist</span><span class="s0">, </span><span class="s1">plot_kws)</span>

    <span class="s0">def </span><span class="s1">plot_errorbars(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">capsize</span><span class="s0">, </span><span class="s1">err_kws):</span>

        <span class="s1">var = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[self.orient]</span>
        <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">data.to_dict(</span><span class="s2">&quot;records&quot;</span><span class="s1">):</span>

            <span class="s1">row = dict(row)</span>
            <span class="s1">pos = np.array([row[self.orient]</span><span class="s0">, </span><span class="s1">row[self.orient]])</span>
            <span class="s1">val = np.array([row[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">var</span><span class="s0">}</span><span class="s2">min&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">row[</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">var</span><span class="s0">}</span><span class="s2">max&quot;</span><span class="s1">]])</span>

            <span class="s0">if </span><span class="s1">capsize:</span>

                <span class="s1">cw = capsize * self._native_width / </span><span class="s4">2</span>
                <span class="s1">scl</span><span class="s0">, </span><span class="s1">inv = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">self.orient)</span>
                <span class="s1">cap = inv(scl(pos[</span><span class="s4">0</span><span class="s1">]) - cw)</span><span class="s0">, </span><span class="s1">inv(scl(pos[</span><span class="s4">1</span><span class="s1">]) + cw)</span>

                <span class="s1">pos = np.concatenate([</span>
                    <span class="s1">[*cap</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">*cap]</span>
                <span class="s1">])</span>
                <span class="s1">val = np.concatenate([</span>
                    <span class="s1">[val[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">val[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">val[-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">val[-</span><span class="s4">1</span><span class="s1">]]</span><span class="s0">,</span>
                <span class="s1">])</span>

            <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;x&quot;</span><span class="s1">:</span>
                <span class="s1">args = pos</span><span class="s0">, </span><span class="s1">val</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">args = val</span><span class="s0">, </span><span class="s1">pos</span>
            <span class="s1">ax.plot(*args</span><span class="s0">, </span><span class="s1">**err_kws)</span>


<span class="s0">class </span><span class="s1">_CategoricalAggPlotter(_CategoricalPlotter):</span>

    <span class="s1">flat_structure = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;@index&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;@values&quot;</span><span class="s1">}</span>


<span class="s1">_categorical_docs = dict(</span>

    <span class="s3"># Shared narrative docs</span>
    <span class="s1">categorical_narrative=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">See the :ref:`tutorial &lt;categorical_tutorial&gt;` for more information. 
 
    .. note:: 
        By default, this function treats one of the variables as categorical 
        and draws data at ordinal positions (0, 1, ... n) on the relevant axis. 
        As of version 0.13.0, this can be disabled by setting `native_scale=True`. 
    &quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>

    <span class="s3"># Shared function parameters</span>
    <span class="s1">input_params=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">x, y, hue : names of variables in `data` or vector data 
        Inputs for plotting long-form data. See examples for interpretation.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">categorical_data=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">data : DataFrame, Series, dict, array, or list of arrays 
        Dataset for plotting. If `x` and `y` are absent, this is 
        interpreted as wide-form. Otherwise it is expected to be long-form.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">order_vars=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">order, hue_order : lists of strings 
        Order to plot the categorical levels in; otherwise the levels are 
        inferred from the data objects.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">stat_api_params=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">estimator : string or callable that maps vector -&gt; scalar 
        Statistical function to estimate within each categorical bin. 
    errorbar : string, (string, number) tuple, callable or None 
        Name of errorbar method (either &quot;ci&quot;, &quot;pi&quot;, &quot;se&quot;, or &quot;sd&quot;), or a tuple 
        with a method name and a level parameter, or a function that maps from a 
        vector to a (min, max) interval, or None to hide errorbar. 
 
        .. versionadded:: v0.12.0 
    n_boot : int 
        Number of bootstrap samples used to compute confidence intervals. 
    units : name of variable in `data` or vector data 
        Identifier of sampling units; used by the errorbar function to 
        perform a multilevel bootstrap and account for repeated measures 
    seed : int, `numpy.random.Generator`, or `numpy.random.RandomState` 
        Seed or random number generator for reproducible bootstrapping.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">ci=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">ci : float 
        Level of the confidence interval to show, in [0, 100]. 
 
        .. deprecated:: v0.12.0 
            Use `errorbar=(&quot;ci&quot;, ...)`.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">orient=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">orient : &quot;v&quot; | &quot;h&quot; | &quot;x&quot; | &quot;y&quot; 
        Orientation of the plot (vertical or horizontal). This is usually 
        inferred based on the type of the input variables, but it can be used 
        to resolve ambiguity when both `x` and `y` are numeric or when 
        plotting wide-form data. 
 
        .. versionchanged:: v0.13.0 
            Added 'x'/'y' as options, equivalent to 'v'/'h'.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">color=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">color : matplotlib color 
        Single color for the elements in the plot.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">palette=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">palette : palette name, list, dict, or :class:`matplotlib.colors.Colormap` 
        Color palette that maps the hue variable. If the palette is a dictionary, 
        keys should be names of levels and values should be matplotlib colors. 
        The type/value will sometimes force a qualitative/quantitative mapping.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">hue_norm=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">hue_norm : tuple or :class:`matplotlib.colors.Normalize` object 
        Normalization in data units for colormap applied to the `hue` 
        variable when it is numeric. Not relevant if `hue` is categorical. 
 
        .. versionadded:: v0.12.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">saturation=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">saturation : float 
        Proportion of the original saturation to draw fill colors in. Large 
        patches often look better with desaturated colors, but set this to 
        `1` if you want the colors to perfectly match the input values.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">capsize=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">capsize : float 
        Width of the &quot;caps&quot; on error bars, relative to bar spacing.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">errcolor=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">errcolor : matplotlib color 
        Color used for the error bar lines. 
 
        .. deprecated:: 0.13.0 
            Use `err_kws={'color': ...}`.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">errwidth=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">errwidth : float 
        Thickness of error bar lines (and caps), in points. 
 
        .. deprecated:: 0.13.0 
            Use `err_kws={'linewidth': ...}`.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">fill=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">fill : bool 
        If True, use a solid patch. Otherwise, draw as line art. 
 
        .. versionadded:: v0.13.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">gap=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">gap : float 
        Shrink on the orient axis by this factor to add a gap between dodged elements. 
 
        .. versionadded:: 0.13.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">width=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">width : float 
        Width allotted to each element on the orient axis. When `native_scale=True`, 
        it is relative to the minimum distance between two values in the native scale.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">dodge=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">dodge : &quot;auto&quot; or bool 
        When hue mapping is used, whether elements should be narrowed and shifted along 
        the orient axis to eliminate overlap. If `&quot;auto&quot;`, set to `True` when the 
        orient variable is crossed with the categorical variable or `False` otherwise. 
 
        .. versionchanged:: 0.13.0 
 
            Added `&quot;auto&quot;` mode as a new default.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">linewidth=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">linewidth : float 
        Width of the lines that frame the plot elements.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">linecolor=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">linecolor : color 
        Color to use for line elements, when `fill` is True. 
 
        .. versionadded:: v0.13.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">log_scale=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">log_scale : bool or number, or pair of bools or numbers 
        Set axis scale(s) to log. A single value sets the data axis for any numeric 
        axes in the plot. A pair of values sets each axis independently. 
        Numeric values are interpreted as the desired base (default 10). 
        When `None` or `False`, seaborn defers to the existing Axes scale. 
 
        .. versionadded:: v0.13.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">native_scale=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">native_scale : bool 
        When True, numeric or datetime values on the categorical axis will maintain 
        their original scaling rather than being converted to fixed indices. 
 
        .. versionadded:: v0.13.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">formatter=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">formatter : callable 
        Function for converting categorical data into strings. Affects both grouping 
        and tick labels. 
 
        .. versionadded:: v0.13.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">legend=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">legend : &quot;auto&quot;, &quot;brief&quot;, &quot;full&quot;, or False 
        How to draw the legend. If &quot;brief&quot;, numeric `hue` and `size` 
        variables will be represented with a sample of evenly spaced values. 
        If &quot;full&quot;, every group will get an entry in the legend. If &quot;auto&quot;, 
        choose between brief or full representation based on number of levels. 
        If `False`, no legend data is added and no legend is drawn. 
 
        .. versionadded:: v0.13.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">err_kws=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">err_kws : dict 
        Parameters of :class:`matplotlib.lines.Line2D`, for the error bar artists. 
 
        .. versionadded:: v0.13.0</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">ax_in=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">ax : matplotlib Axes 
        Axes object to draw the plot onto, otherwise uses the current Axes.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">ax_out=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">ax : matplotlib Axes 
        Returns the Axes object with the plot drawn onto it.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>

    <span class="s3"># Shared see also</span>
    <span class="s1">boxplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">boxplot : A traditional box-and-whisker plot with a similar API.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">violinplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">violinplot : A combination of boxplot and kernel density estimation.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">stripplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">stripplot : A scatterplot where one variable is categorical. Can be used 
                in conjunction with other plots to show each observation.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">swarmplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">swarmplot : A categorical scatterplot where the points do not overlap. Can 
                be used with other plots to show each observation.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">barplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">barplot : Show point estimates and confidence intervals using bars.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">countplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">countplot : Show the counts of observations in each categorical bin.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">pointplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">pointplot : Show point estimates and confidence intervals using dots.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">catplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">catplot : Combine a categorical plot with a :class:`FacetGrid`.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">boxenplot=dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">boxenplot : An enhanced boxplot for larger datasets.</span><span class="s0">\ 
    </span><span class="s2">&quot;&quot;&quot;</span><span class="s1">)</span><span class="s0">,</span>

<span class="s1">)</span>

<span class="s1">_categorical_docs.update(_facet_docs)</span>


<span class="s0">def </span><span class="s1">boxplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None,</span>
    <span class="s1">orient=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">saturation=</span><span class="s4">.75</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True,</span>
    <span class="s1">dodge=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">width=</span><span class="s4">.8</span><span class="s0">, </span><span class="s1">gap=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">whis=</span><span class="s4">1.5</span><span class="s0">, </span><span class="s1">linecolor=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">linewidth=</span><span class="s0">None,</span>
    <span class="s1">fliersize=</span><span class="s0">None, </span><span class="s1">hue_norm=</span><span class="s0">None, </span><span class="s1">native_scale=</span><span class="s0">False, </span><span class="s1">log_scale=</span><span class="s0">None, </span><span class="s1">formatter=</span><span class="s0">None,</span>
    <span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">ax=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s1">p = _CategoricalPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s1">p.plot_data.empty:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">if </span><span class="s1">dodge == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s3"># Needs to be before scale_categorical changes the coordinate series dtype</span>
        <span class="s1">dodge = p._dodge_needed()</span>

    <span class="s0">if </span><span class="s1">p.var_types.get(p.orient) == </span><span class="s2">&quot;categorical&quot; </span><span class="s0">or not </span><span class="s1">native_scale:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(ax</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s1">saturation = saturation </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s4">1</span>
    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm</span><span class="s0">, </span><span class="s1">saturation=saturation)</span>
    <span class="s1">color = _default_color(</span>
        <span class="s1">ax.fill_between</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">,</span>
        <span class="s1">{k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items() </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;fc&quot;</span><span class="s0">, </span><span class="s2">&quot;facecolor&quot;</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">saturation=saturation</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">linecolor = p._complement_color(linecolor</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map)</span>

    <span class="s1">p.plot_boxes(</span>
        <span class="s1">width=width</span><span class="s0">,</span>
        <span class="s1">dodge=dodge</span><span class="s0">,</span>
        <span class="s1">gap=gap</span><span class="s0">,</span>
        <span class="s1">fill=fill</span><span class="s0">,</span>
        <span class="s1">whis=whis</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">linecolor=linecolor</span><span class="s0">,</span>
        <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
        <span class="s1">fliersize=fliersize</span><span class="s0">,</span>
        <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p._add_axis_labels(ax)</span>
    <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">boxplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Draw a box plot to show distributions with respect to categories. 
 
    A box plot (or box-and-whisker plot) shows the distribution of quantitative 
    data in a way that facilitates comparisons between variables or across 
    levels of a categorical variable. The box shows the quartiles of the 
    dataset while the whiskers extend to show the rest of the distribution, 
    except for points that are determined to be &quot;outliers&quot; using a method 
    that is a function of the inter-quartile range. 
 
    {categorical_narrative} 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    {order_vars} 
    {orient} 
    {color} 
    {palette} 
    {saturation} 
    {fill} 
    {dodge} 
    {width} 
    {gap} 
    whis : float or pair of floats 
        Paramater that controls whisker length. If scalar, whiskers are drawn 
        to the farthest datapoint within *whis * IQR* from the nearest hinge. 
        If a tuple, it is interpreted as percentiles that whiskers represent. 
    {linecolor} 
    {linewidth} 
    fliersize : float 
        Size of the markers used to indicate outlier observations. 
    {hue_norm} 
    {log_scale} 
    {native_scale} 
    {formatter} 
    {legend} 
    {ax_in} 
    kwargs : key, value mappings 
        Other keyword arguments are passed through to 
        :meth:`matplotlib.axes.Axes.boxplot`. 
 
    Returns 
    ------- 
    {ax_out} 
 
    See Also 
    -------- 
    {violinplot} 
    {stripplot} 
    {swarmplot} 
    {catplot} 
 
    Examples 
    -------- 
    .. include:: ../docstrings/boxplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">def </span><span class="s1">violinplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None,</span>
    <span class="s1">orient=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">saturation=</span><span class="s4">.75</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True,</span>
    <span class="s1">inner=</span><span class="s2">&quot;box&quot;</span><span class="s0">, </span><span class="s1">split=</span><span class="s0">False, </span><span class="s1">width=</span><span class="s4">.8</span><span class="s0">, </span><span class="s1">dodge=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">gap=</span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">linewidth=</span><span class="s0">None, </span><span class="s1">linecolor=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">cut=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">gridsize=</span><span class="s4">100</span><span class="s0">,</span>
    <span class="s1">bw_method=</span><span class="s2">&quot;scott&quot;</span><span class="s0">, </span><span class="s1">bw_adjust=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">density_norm=</span><span class="s2">&quot;area&quot;</span><span class="s0">, </span><span class="s1">common_norm=</span><span class="s0">False,</span>
    <span class="s1">hue_norm=</span><span class="s0">None, </span><span class="s1">formatter=</span><span class="s0">None, </span><span class="s1">log_scale=</span><span class="s0">None, </span><span class="s1">native_scale=</span><span class="s0">False,</span>
    <span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">scale=deprecated</span><span class="s0">, </span><span class="s1">scale_hue=deprecated</span><span class="s0">, </span><span class="s1">bw=deprecated</span><span class="s0">,</span>
    <span class="s1">inner_kws=</span><span class="s0">None, </span><span class="s1">ax=</span><span class="s0">None, </span><span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>

    <span class="s1">p = _CategoricalPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s1">p.plot_data.empty:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">if </span><span class="s1">dodge == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s3"># Needs to be before scale_categorical changes the coordinate series dtype</span>
        <span class="s1">dodge = p._dodge_needed()</span>

    <span class="s0">if </span><span class="s1">p.var_types.get(p.orient) == </span><span class="s2">&quot;categorical&quot; </span><span class="s0">or not </span><span class="s1">native_scale:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(ax</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s1">saturation = saturation </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s4">1</span>
    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm</span><span class="s0">, </span><span class="s1">saturation=saturation)</span>
    <span class="s1">color = _default_color(</span>
        <span class="s1">ax.fill_between</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">,</span>
        <span class="s1">{k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items() </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;fc&quot;</span><span class="s0">, </span><span class="s2">&quot;facecolor&quot;</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">saturation=saturation</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">linecolor = p._complement_color(linecolor</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map)</span>

    <span class="s1">density_norm</span><span class="s0">, </span><span class="s1">common_norm = p._violin_scale_backcompat(</span>
        <span class="s1">scale</span><span class="s0">, </span><span class="s1">scale_hue</span><span class="s0">, </span><span class="s1">density_norm</span><span class="s0">, </span><span class="s1">common_norm</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">bw_method = p._violin_bw_backcompat(bw</span><span class="s0">, </span><span class="s1">bw_method)</span>
    <span class="s1">kde_kws = dict(cut=cut</span><span class="s0">, </span><span class="s1">gridsize=gridsize</span><span class="s0">, </span><span class="s1">bw_method=bw_method</span><span class="s0">, </span><span class="s1">bw_adjust=bw_adjust)</span>
    <span class="s1">inner_kws = {} </span><span class="s0">if </span><span class="s1">inner_kws </span><span class="s0">is None else </span><span class="s1">inner_kws.copy()</span>

    <span class="s1">p.plot_violins(</span>
        <span class="s1">width=width</span><span class="s0">,</span>
        <span class="s1">dodge=dodge</span><span class="s0">,</span>
        <span class="s1">gap=gap</span><span class="s0">,</span>
        <span class="s1">split=split</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">fill=fill</span><span class="s0">,</span>
        <span class="s1">linecolor=linecolor</span><span class="s0">,</span>
        <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
        <span class="s1">inner=inner</span><span class="s0">,</span>
        <span class="s1">density_norm=density_norm</span><span class="s0">,</span>
        <span class="s1">common_norm=common_norm</span><span class="s0">,</span>
        <span class="s1">kde_kws=kde_kws</span><span class="s0">,</span>
        <span class="s1">inner_kws=inner_kws</span><span class="s0">,</span>
        <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p._add_axis_labels(ax)</span>
    <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">violinplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Draw a patch representing a KDE and add observations or box plot statistics. 
 
    A violin plot plays a similar role as a box-and-whisker plot. It shows the 
    distribution of data points after grouping by one (or more) variables. 
    Unlike a box plot, each violin is drawn using a kernel density estimate 
    of the underlying distribution. 
 
    {categorical_narrative} 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    {order_vars} 
    {orient} 
    {color} 
    {palette} 
    {saturation} 
    {fill} 
    inner : {{&quot;box&quot;, &quot;quart&quot;, &quot;point&quot;, &quot;stick&quot;, None}} 
        Representation of the data in the violin interior. One of the following: 
 
        - `&quot;box&quot;`: draw a miniature box-and-whisker plot 
        - `&quot;quart&quot;`: show the quartiles of the data 
        - `&quot;point&quot;` or `&quot;stick&quot;`: show each observation 
    split : bool 
        Show an un-mirrored distribution, alternating sides when using `hue`. 
 
        .. versionchanged:: v0.13.0 
            Previously, this option required a `hue` variable with exactly two levels. 
    {width} 
    {dodge} 
    {gap} 
    {linewidth} 
    {linecolor} 
    cut : float 
        Distance, in units of bandwidth, to extend the density past extreme 
        datapoints. Set to 0 to limit the violin within the data range. 
    gridsize : int 
        Number of points in the discrete grid used to evaluate the KDE. 
    bw_method : {{&quot;scott&quot;, &quot;silverman&quot;, float}} 
        Either the name of a reference rule or the scale factor to use when 
        computing the kernel bandwidth. The actual kernel size will be 
        determined by multiplying the scale factor by the standard deviation of 
        the data within each group. 
 
        .. versionadded:: v0.13.0 
    bw_adjust: float 
        Factor that scales the bandwidth to use more or less smoothing. 
 
        .. versionadded:: v0.13.0 
    density_norm : {{&quot;area&quot;, &quot;count&quot;, &quot;width&quot;}} 
        Method that normalizes each density to determine the violin's width. 
        If `area`, each violin will have the same area. If `count`, the width 
        will be proportional to the number of observations. If `width`, each 
        violin will have the same width. 
 
        .. versionadded:: v0.13.0 
    common_norm : bool 
        When `True`, normalize the density across all violins. 
 
        .. versionadded:: v0.13.0 
    {hue_norm} 
    {formatter} 
    {log_scale} 
    {native_scale} 
    {legend} 
    scale : {{&quot;area&quot;, &quot;count&quot;, &quot;width&quot;}} 
        .. deprecated:: v0.13.0 
            See `density_norm`. 
    scale_hue : bool 
        .. deprecated:: v0.13.0 
            See `common_norm`. 
    bw : {{'scott', 'silverman', float}} 
        .. deprecated:: v0.13.0 
            See `bw_method` and `bw_adjust`. 
    inner_kws : dict of key, value mappings 
        Keyword arguments for the &quot;inner&quot; plot, passed to one of: 
 
        - :class:`matplotlib.collections.LineCollection` (with `inner=&quot;stick&quot;`) 
        - :meth:`matplotlib.axes.Axes.scatter` (with `inner=&quot;point&quot;`) 
        - :meth:`matplotlib.axes.Axes.plot` (with `inner=&quot;quart&quot;` or `inner=&quot;box&quot;`) 
 
        Additionally, with `inner=&quot;box&quot;`, the keywords `box_width`, `whis_width`, 
        and `marker` receive special handling for the components of the &quot;box&quot; plot. 
 
        .. versionadded:: v0.13.0 
    {ax_in} 
    kwargs : key, value mappings 
        Keyword arguments for the violin patches, passsed through to 
        :meth:`matplotlib.axes.Axes.fill_between`. 
 
    Returns 
    ------- 
    {ax_out} 
 
    See Also 
    -------- 
    {boxplot} 
    {stripplot} 
    {swarmplot} 
    {catplot} 
 
    Examples 
    -------- 
    .. include:: ../docstrings/violinplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">def </span><span class="s1">boxenplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None,</span>
    <span class="s1">orient=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">saturation=</span><span class="s4">.75</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True,</span>
    <span class="s1">dodge=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">width=</span><span class="s4">.8</span><span class="s0">, </span><span class="s1">gap=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">linewidth=</span><span class="s0">None, </span><span class="s1">linecolor=</span><span class="s0">None,</span>
    <span class="s1">width_method=</span><span class="s2">&quot;exponential&quot;</span><span class="s0">, </span><span class="s1">k_depth=</span><span class="s2">&quot;tukey&quot;</span><span class="s0">, </span><span class="s1">outlier_prop=</span><span class="s4">0.007</span><span class="s0">, </span><span class="s1">trust_alpha=</span><span class="s4">0.05</span><span class="s0">,</span>
    <span class="s1">showfliers=</span><span class="s0">True, </span><span class="s1">hue_norm=</span><span class="s0">None, </span><span class="s1">log_scale=</span><span class="s0">None, </span><span class="s1">native_scale=</span><span class="s0">False, </span><span class="s1">formatter=</span><span class="s0">None,</span>
    <span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">scale=deprecated</span><span class="s0">, </span><span class="s1">box_kws=</span><span class="s0">None, </span><span class="s1">flier_kws=</span><span class="s0">None, </span><span class="s1">line_kws=</span><span class="s0">None,</span>
    <span class="s1">ax=</span><span class="s0">None, </span><span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>

    <span class="s1">p = _CategoricalPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s1">p.plot_data.empty:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">if </span><span class="s1">dodge == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s3"># Needs to be before scale_categorical changes the coordinate series dtype</span>
        <span class="s1">dodge = p._dodge_needed()</span>

    <span class="s0">if </span><span class="s1">p.var_types.get(p.orient) == </span><span class="s2">&quot;categorical&quot; </span><span class="s0">or not </span><span class="s1">native_scale:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(ax</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s3"># Longer-term deprecations</span>
    <span class="s1">width_method = p._boxen_scale_backcompat(scale</span><span class="s0">, </span><span class="s1">width_method)</span>

    <span class="s1">saturation = saturation </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s4">1</span>
    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm</span><span class="s0">, </span><span class="s1">saturation=saturation)</span>
    <span class="s1">color = _default_color(</span>
        <span class="s1">ax.fill_between</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">,</span>
        <span class="s1">{}</span><span class="s0">,  </span><span class="s3"># TODO how to get default color?</span>
        <span class="s3"># {k: v for k, v in kwargs.items() if k in [&quot;c&quot;, &quot;color&quot;, &quot;fc&quot;, &quot;facecolor&quot;]},</span>
        <span class="s1">saturation=saturation</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">linecolor = p._complement_color(linecolor</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map)</span>

    <span class="s1">p.plot_boxens(</span>
        <span class="s1">width=width</span><span class="s0">,</span>
        <span class="s1">dodge=dodge</span><span class="s0">,</span>
        <span class="s1">gap=gap</span><span class="s0">,</span>
        <span class="s1">fill=fill</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">linecolor=linecolor</span><span class="s0">,</span>
        <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
        <span class="s1">width_method=width_method</span><span class="s0">,</span>
        <span class="s1">k_depth=k_depth</span><span class="s0">,</span>
        <span class="s1">outlier_prop=outlier_prop</span><span class="s0">,</span>
        <span class="s1">trust_alpha=trust_alpha</span><span class="s0">,</span>
        <span class="s1">showfliers=showfliers</span><span class="s0">,</span>
        <span class="s1">box_kws=box_kws</span><span class="s0">,</span>
        <span class="s1">flier_kws=flier_kws</span><span class="s0">,</span>
        <span class="s1">line_kws=line_kws</span><span class="s0">,</span>
        <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p._add_axis_labels(ax)</span>
    <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">boxenplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Draw an enhanced box plot for larger datasets. 
 
    This style of plot was originally named a &quot;letter value&quot; plot because it 
    shows a large number of quantiles that are defined as &quot;letter values&quot;.  It 
    is similar to a box plot in plotting a nonparametric representation of a 
    distribution in which all features correspond to actual observations. By 
    plotting more quantiles, it provides more information about the shape of 
    the distribution, particularly in the tails. 
 
    {categorical_narrative} 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    {order_vars} 
    {orient} 
    {color} 
    {palette} 
    {saturation} 
    {fill} 
    {dodge} 
    {width} 
    {gap} 
    {linewidth} 
    {linecolor} 
    width_method : {{&quot;exponential&quot;, &quot;linear&quot;, &quot;area&quot;}} 
        Method to use for the width of the letter value boxes: 
 
        - `&quot;exponential&quot;`: Represent the corresponding percentile 
        - `&quot;linear&quot;`: Decrease by a constant amount for each box 
        - `&quot;area&quot;`: Represent the density of data points in that box 
    k_depth : {{&quot;tukey&quot;, &quot;proportion&quot;, &quot;trustworthy&quot;, &quot;full&quot;}} or int 
        The number of levels to compute and draw in each tail: 
 
        - `&quot;tukey&quot;`: Use log2(n) - 3 levels, covering similar range as boxplot whiskers 
        - `&quot;proportion&quot;`: Leave approximately `outlier_prop` fliers 
        - `&quot;trusthworthy&quot;`: Extend to level with confidence of at least `trust_alpha` 
        - `&quot;full&quot;`: Use log2(n) + 1 levels and extend to most extreme points 
    outlier_prop : float 
        Proportion of data expected to be outliers; used when `k_depth=&quot;proportion&quot;`. 
    trust_alpha : float 
        Confidence threshold for most extreme level; used when `k_depth=&quot;trustworthy&quot;`. 
    showfliers : bool 
        If False, suppress the plotting of outliers. 
    {hue_norm} 
    {log_scale} 
    {native_scale} 
    {formatter} 
    {legend} 
    box_kws: dict 
        Keyword arguments for the box artists; passed to 
        :class:`matplotlib.patches.Rectangle`. 
 
        .. versionadded:: v0.12.0 
    line_kws: dict 
        Keyword arguments for the line denoting the median; passed to 
        :meth:`matplotlib.axes.Axes.plot`. 
 
        .. versionadded:: v0.12.0 
    flier_kws: dict 
        Keyword arguments for the scatter denoting the outlier observations; 
        passed to :meth:`matplotlib.axes.Axes.scatter`. 
 
        .. versionadded:: v0.12.0 
    {ax_in} 
    kwargs : key, value mappings 
        Other keyword arguments are passed to :class:`matplotlib.patches.Rectangle`, 
        superceded by those in `box_kws`. 
 
    Returns 
    ------- 
    {ax_out} 
 
    See Also 
    -------- 
    {violinplot} 
    {boxplot} 
    {catplot} 
 
    Notes 
    ----- 
 
    For a more extensive explanation, you can read the paper that introduced the plot: 
    https://vita.had.co.nz/papers/letter-value-plot.html 
 
    Examples 
    -------- 
    .. include:: ../docstrings/boxenplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">def </span><span class="s1">stripplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None,</span>
    <span class="s1">jitter=</span><span class="s0">True, </span><span class="s1">dodge=</span><span class="s0">False, </span><span class="s1">orient=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None,</span>
    <span class="s1">size=</span><span class="s4">5</span><span class="s0">, </span><span class="s1">edgecolor=default</span><span class="s0">, </span><span class="s1">linewidth=</span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">hue_norm=</span><span class="s0">None, </span><span class="s1">log_scale=</span><span class="s0">None, </span><span class="s1">native_scale=</span><span class="s0">False, </span><span class="s1">formatter=</span><span class="s0">None, </span><span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">,</span>
    <span class="s1">ax=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s1">p = _CategoricalPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s1">p.plot_data.empty:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">if </span><span class="s1">p.var_types.get(p.orient) == </span><span class="s2">&quot;categorical&quot; </span><span class="s0">or not </span><span class="s1">native_scale:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(ax</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm)</span>
    <span class="s1">color = _default_color(ax.scatter</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">kwargs)</span>
    <span class="s1">edgecolor = p._complement_color(edgecolor</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map)</span>

    <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;zorder&quot;</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">size = kwargs.get(</span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s1">size)</span>

    <span class="s1">kwargs.update(</span>
        <span class="s1">s=size ** </span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">edgecolor=edgecolor</span><span class="s0">,</span>
        <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p.plot_strips(</span>
        <span class="s1">jitter=jitter</span><span class="s0">,</span>
        <span class="s1">dodge=dodge</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s3"># XXX this happens inside a plotting method in the distribution plots</span>
    <span class="s3"># but maybe it's better out here? Alternatively, we have an open issue</span>
    <span class="s3"># suggesting that _attach could add default axes labels, which seems smart.</span>
    <span class="s1">p._add_axis_labels(ax)</span>
    <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">stripplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Draw a categorical scatterplot using jitter to reduce overplotting. 
 
    A strip plot can be drawn on its own, but it is also a good complement 
    to a box or violin plot in cases where you want to show all observations 
    along with some representation of the underlying distribution. 
 
    {categorical_narrative} 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    {order_vars} 
    jitter : float, `True`/`1` is special-cased 
        Amount of jitter (only along the categorical axis) to apply. This 
        can be useful when you have many points and they overlap, so that 
        it is easier to see the distribution. You can specify the amount 
        of jitter (half the width of the uniform random variable support), 
        or use `True` for a good default. 
    dodge : bool 
        When a `hue` variable is assigned, setting this to `True` will 
        separate the strips for different hue levels along the categorical 
        axis and narrow the amount of space allotedto each strip. Otherwise, 
        the points for each level will be plotted in the same strip. 
    {orient} 
    {color} 
    {palette} 
    size : float 
        Radius of the markers, in points. 
    edgecolor : matplotlib color, &quot;gray&quot; is special-cased 
        Color of the lines around each point. If you pass `&quot;gray&quot;`, the 
        brightness is determined by the color palette used for the body 
        of the points. Note that `stripplot` has `linewidth=0` by default, 
        so edge colors are only visible with nonzero line width. 
    {linewidth} 
    {hue_norm} 
    {log_scale} 
    {native_scale} 
    {formatter} 
    {legend} 
    {ax_in} 
    kwargs : key, value mappings 
        Other keyword arguments are passed through to 
        :meth:`matplotlib.axes.Axes.scatter`. 
 
    Returns 
    ------- 
    {ax_out} 
 
    See Also 
    -------- 
    {swarmplot} 
    {boxplot} 
    {violinplot} 
    {catplot} 
 
    Examples 
    -------- 
    .. include:: ../docstrings/stripplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">def </span><span class="s1">swarmplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None,</span>
    <span class="s1">dodge=</span><span class="s0">False, </span><span class="s1">orient=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None,</span>
    <span class="s1">size=</span><span class="s4">5</span><span class="s0">, </span><span class="s1">edgecolor=</span><span class="s0">None, </span><span class="s1">linewidth=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">hue_norm=</span><span class="s0">None, </span><span class="s1">log_scale=</span><span class="s0">None,</span>
    <span class="s1">native_scale=</span><span class="s0">False, </span><span class="s1">formatter=</span><span class="s0">None, </span><span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">warn_thresh=</span><span class="s4">.05</span><span class="s0">,</span>
    <span class="s1">ax=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s1">p = _CategoricalPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s1">p.plot_data.empty:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">if </span><span class="s1">p.var_types.get(p.orient) == </span><span class="s2">&quot;categorical&quot; </span><span class="s0">or not </span><span class="s1">native_scale:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(ax</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s0">if not </span><span class="s1">p.has_xy_data:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm)</span>
    <span class="s1">color = _default_color(ax.scatter</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">kwargs)</span>
    <span class="s1">edgecolor = p._complement_color(edgecolor</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map)</span>

    <span class="s1">kwargs.setdefault(</span><span class="s2">&quot;zorder&quot;</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">size = kwargs.get(</span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s1">size)</span>

    <span class="s0">if </span><span class="s1">linewidth </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">linewidth = size / </span><span class="s4">10</span>

    <span class="s1">kwargs.update(dict(</span>
        <span class="s1">s=size ** </span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">edgecolor=edgecolor</span><span class="s0">,</span>
        <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
    <span class="s1">))</span>

    <span class="s1">p.plot_swarms(</span>
        <span class="s1">dodge=dodge</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">warn_thresh=warn_thresh</span><span class="s0">,</span>
        <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p._add_axis_labels(ax)</span>
    <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">swarmplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Draw a categorical scatterplot with points adjusted to be non-overlapping. 
 
    This function is similar to :func:`stripplot`, but the points are adjusted 
    (only along the categorical axis) so that they don't overlap. This gives a 
    better representation of the distribution of values, but it does not scale 
    well to large numbers of observations. This style of plot is sometimes 
    called a &quot;beeswarm&quot;. 
 
    A swarm plot can be drawn on its own, but it is also a good complement 
    to a box or violin plot in cases where you want to show all observations 
    along with some representation of the underlying distribution. 
 
    {categorical_narrative} 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    {order_vars} 
    dodge : bool 
        When a `hue` variable is assigned, setting this to `True` will 
        separate the swaarms for different hue levels along the categorical 
        axis and narrow the amount of space allotedto each strip. Otherwise, 
        the points for each level will be plotted in the same swarm. 
    {orient} 
    {color} 
    {palette} 
    size : float 
        Radius of the markers, in points. 
    edgecolor : matplotlib color, &quot;gray&quot; is special-cased 
        Color of the lines around each point. If you pass `&quot;gray&quot;`, the 
        brightness is determined by the color palette used for the body 
        of the points. 
    {linewidth} 
    {log_scale} 
    {native_scale} 
    {formatter} 
    {legend} 
    {ax_in} 
    kwargs : key, value mappings 
        Other keyword arguments are passed through to 
        :meth:`matplotlib.axes.Axes.scatter`. 
 
    Returns 
    ------- 
    {ax_out} 
 
    See Also 
    -------- 
    {boxplot} 
    {violinplot} 
    {stripplot} 
    {catplot} 
 
    Examples 
    -------- 
    .. include:: ../docstrings/swarmplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">def </span><span class="s1">barplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None,</span>
    <span class="s1">estimator=</span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">errorbar=(</span><span class="s2">&quot;ci&quot;</span><span class="s0">, </span><span class="s4">95</span><span class="s1">)</span><span class="s0">, </span><span class="s1">n_boot=</span><span class="s4">1000</span><span class="s0">, </span><span class="s1">units=</span><span class="s0">None, </span><span class="s1">seed=</span><span class="s0">None,</span>
    <span class="s1">orient=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">saturation=</span><span class="s4">.75</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True, </span><span class="s1">hue_norm=</span><span class="s0">None,</span>
    <span class="s1">width=</span><span class="s4">.8</span><span class="s0">, </span><span class="s1">dodge=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">gap=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">log_scale=</span><span class="s0">None, </span><span class="s1">native_scale=</span><span class="s0">False, </span><span class="s1">formatter=</span><span class="s0">None,</span>
    <span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">capsize=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">err_kws=</span><span class="s0">None,</span>
    <span class="s1">ci=deprecated</span><span class="s0">, </span><span class="s1">errcolor=deprecated</span><span class="s0">, </span><span class="s1">errwidth=deprecated</span><span class="s0">, </span><span class="s1">ax=</span><span class="s0">None, </span><span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>

    <span class="s1">errorbar = utils._deprecate_ci(errorbar</span><span class="s0">, </span><span class="s1">ci)</span>

    <span class="s3"># Be backwards compatible with len passed directly, which</span>
    <span class="s3"># does not work in Series.agg (maybe a pandas bug?)</span>
    <span class="s0">if </span><span class="s1">estimator </span><span class="s0">is </span><span class="s1">len:</span>
        <span class="s1">estimator = </span><span class="s2">&quot;size&quot;</span>

    <span class="s1">p = _CategoricalAggPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">units=units)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s1">p.plot_data.empty:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">if </span><span class="s1">dodge == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s3"># Needs to be before scale_categorical changes the coordinate series dtype</span>
        <span class="s1">dodge = p._dodge_needed()</span>

    <span class="s0">if </span><span class="s1">p.var_types.get(p.orient) == </span><span class="s2">&quot;categorical&quot; </span><span class="s0">or not </span><span class="s1">native_scale:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(ax</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s1">saturation = saturation </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s4">1</span>
    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm</span><span class="s0">, </span><span class="s1">saturation=saturation)</span>
    <span class="s1">color = _default_color(ax.bar</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">saturation=saturation)</span>

    <span class="s1">aggregator = EstimateAggregator(estimator</span><span class="s0">, </span><span class="s1">errorbar</span><span class="s0">, </span><span class="s1">n_boot=n_boot</span><span class="s0">, </span><span class="s1">seed=seed)</span>
    <span class="s1">err_kws = {} </span><span class="s0">if </span><span class="s1">err_kws </span><span class="s0">is None else </span><span class="s1">_normalize_kwargs(err_kws</span><span class="s0">, </span><span class="s1">mpl.lines.Line2D)</span>

    <span class="s3"># Deprecations to remove in v0.15.0.</span>
    <span class="s1">err_kws</span><span class="s0">, </span><span class="s1">capsize = p._err_kws_backcompat(err_kws</span><span class="s0">, </span><span class="s1">errcolor</span><span class="s0">, </span><span class="s1">errwidth</span><span class="s0">, </span><span class="s1">capsize)</span>

    <span class="s1">p.plot_bars(</span>
        <span class="s1">aggregator=aggregator</span><span class="s0">,</span>
        <span class="s1">dodge=dodge</span><span class="s0">,</span>
        <span class="s1">width=width</span><span class="s0">,</span>
        <span class="s1">gap=gap</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">fill=fill</span><span class="s0">,</span>
        <span class="s1">capsize=capsize</span><span class="s0">,</span>
        <span class="s1">err_kws=err_kws</span><span class="s0">,</span>
        <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p._add_axis_labels(ax)</span>
    <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">barplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Show point estimates and errors as rectangular bars. 
 
    A bar plot represents an aggregate or statistical estimate for a numeric 
    variable with the height of each rectangle and indicates the uncertainty 
    around that estimate using an error bar. Bar plots include 0 in the 
    axis range, and they are a good choice when 0 is a meaningful value 
    for the variable to take. 
 
    {categorical_narrative} 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    {order_vars} 
    {stat_api_params} 
    {orient} 
    {color} 
    {palette} 
    {saturation} 
    {fill} 
    {hue_norm} 
    {width} 
    {dodge} 
    {gap} 
    {log_scale} 
    {native_scale} 
    {formatter} 
    {legend} 
    {capsize} 
    {err_kws} 
    {ci} 
    {errcolor} 
    {errwidth} 
    {ax_in} 
    kwargs : key, value mappings 
        Other parameters are passed through to :class:`matplotlib.patches.Rectangle`. 
 
    Returns 
    ------- 
    {ax_out} 
 
    See Also 
    -------- 
    {countplot} 
    {pointplot} 
    {catplot} 
 
    Notes 
    ----- 
 
    For datasets where 0 is not a meaningful value, a :func:`pointplot` will 
    allow you to focus on differences between levels of one or more categorical 
    variables. 
 
    It is also important to keep in mind that a bar plot shows only the mean (or 
    other aggregate) value, but it is often more informative to show the 
    distribution of values at each level of the categorical variables. In those 
    cases, approaches such as a :func:`boxplot` or :func:`violinplot` may be 
    more appropriate. 
 
    Examples 
    -------- 
    .. include:: ../docstrings/barplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">def </span><span class="s1">pointplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None,</span>
    <span class="s1">estimator=</span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">errorbar=(</span><span class="s2">&quot;ci&quot;</span><span class="s0">, </span><span class="s4">95</span><span class="s1">)</span><span class="s0">, </span><span class="s1">n_boot=</span><span class="s4">1000</span><span class="s0">, </span><span class="s1">units=</span><span class="s0">None, </span><span class="s1">seed=</span><span class="s0">None,</span>
    <span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">hue_norm=</span><span class="s0">None, </span><span class="s1">markers=default</span><span class="s0">, </span><span class="s1">linestyles=default</span><span class="s0">,</span>
    <span class="s1">dodge=</span><span class="s0">False, </span><span class="s1">log_scale=</span><span class="s0">None, </span><span class="s1">native_scale=</span><span class="s0">False, </span><span class="s1">orient=</span><span class="s0">None, </span><span class="s1">capsize=</span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">formatter=</span><span class="s0">None, </span><span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">err_kws=</span><span class="s0">None,</span>
    <span class="s1">ci=deprecated</span><span class="s0">, </span><span class="s1">errwidth=deprecated</span><span class="s0">, </span><span class="s1">join=deprecated</span><span class="s0">, </span><span class="s1">scale=deprecated</span><span class="s0">,</span>
    <span class="s1">ax=</span><span class="s0">None,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>

    <span class="s1">errorbar = utils._deprecate_ci(errorbar</span><span class="s0">, </span><span class="s1">ci)</span>

    <span class="s1">p = _CategoricalAggPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">units=units)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s3"># Handle special backwards compatibility where pointplot originally</span>
        <span class="s3"># did *not* default to multi-colored unless a palette was specified.</span>
        <span class="s1">color=</span><span class="s2">&quot;C0&quot; </span><span class="s0">if </span><span class="s1">(color </span><span class="s0">is None and </span><span class="s1">palette </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s1">p.plot_data.empty:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">if </span><span class="s1">p.var_types.get(p.orient) == </span><span class="s2">&quot;categorical&quot; </span><span class="s0">or not </span><span class="s1">native_scale:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(ax</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm)</span>
    <span class="s1">color = _default_color(ax.plot</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">kwargs)</span>

    <span class="s1">aggregator = EstimateAggregator(estimator</span><span class="s0">, </span><span class="s1">errorbar</span><span class="s0">, </span><span class="s1">n_boot=n_boot</span><span class="s0">, </span><span class="s1">seed=seed)</span>
    <span class="s1">err_kws = {} </span><span class="s0">if </span><span class="s1">err_kws </span><span class="s0">is None else </span><span class="s1">_normalize_kwargs(err_kws</span><span class="s0">, </span><span class="s1">mpl.lines.Line2D)</span>

    <span class="s3"># Deprecations to remove in v0.15.0.</span>
    <span class="s1">p._point_kwargs_backcompat(scale</span><span class="s0">, </span><span class="s1">join</span><span class="s0">, </span><span class="s1">kwargs)</span>
    <span class="s1">err_kws</span><span class="s0">, </span><span class="s1">capsize = p._err_kws_backcompat(err_kws</span><span class="s0">, None, </span><span class="s1">errwidth</span><span class="s0">, </span><span class="s1">capsize)</span>

    <span class="s1">p.plot_points(</span>
        <span class="s1">aggregator=aggregator</span><span class="s0">,</span>
        <span class="s1">markers=markers</span><span class="s0">,</span>
        <span class="s1">linestyles=linestyles</span><span class="s0">,</span>
        <span class="s1">dodge=dodge</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">capsize=capsize</span><span class="s0">,</span>
        <span class="s1">err_kws=err_kws</span><span class="s0">,</span>
        <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p._add_axis_labels(ax)</span>
    <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">pointplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Show point estimates and errors using lines with markers. 
 
    A point plot represents an estimate of central tendency for a numeric 
    variable by the position of the dot and provides some indication of the 
    uncertainty around that estimate using error bars. 
 
    Point plots can be more useful than bar plots for focusing comparisons 
    between different levels of one or more categorical variables. They are 
    particularly adept at showing interactions: how the relationship between 
    levels of one categorical variable changes across levels of a second 
    categorical variable. The lines that join each point from the same `hue` 
    level allow interactions to be judged by differences in slope, which is 
    easier for the eyes than comparing the heights of several groups of points 
    or bars. 
 
    {categorical_narrative} 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    {order_vars} 
    {stat_api_params} 
    {color} 
    {palette} 
    markers : string or list of strings 
        Markers to use for each of the `hue` levels. 
    linestyles : string or list of strings 
        Line styles to use for each of the `hue` levels. 
    dodge : bool or float 
        Amount to separate the points for each level of the `hue` variable along 
        the categorical axis. Setting to `True` will apply a small default. 
    {log_scale} 
    {native_scale} 
    {orient} 
    {capsize} 
    {formatter} 
    {legend} 
    {err_kws} 
    {ci} 
    {errwidth} 
    join : bool 
        If `True`, connect point estimates with a line. 
 
        .. deprecated:: v0.13.0 
            Set `linestyle=&quot;none&quot;` to remove the lines between the points. 
    scale : float 
        Scale factor for the plot elements. 
 
        .. deprecated:: v0.13.0 
            Control element sizes with :class:`matplotlib.lines.Line2D` parameters. 
    {ax_in} 
    kwargs : key, value mappings 
        Other parameters are passed through to :class:`matplotlib.lines.Line2D`. 
 
        .. versionadded:: v0.13.0 
 
    Returns 
    ------- 
    {ax_out} 
 
    See Also 
    -------- 
    {barplot} 
    {catplot} 
 
    Notes 
    ----- 
    It is important to keep in mind that a point plot shows only the mean (or 
    other estimator) value, but in many cases it may be more informative to 
    show the distribution of values at each level of the categorical variables. 
    In that case, other approaches such as a box or violin plot may be more 
    appropriate. 
 
    Examples 
    -------- 
    .. include:: ../docstrings/pointplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">def </span><span class="s1">countplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None,</span>
    <span class="s1">orient=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">saturation=</span><span class="s4">.75</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True, </span><span class="s1">hue_norm=</span><span class="s0">None,</span>
    <span class="s1">stat=</span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s1">width=</span><span class="s4">.8</span><span class="s0">, </span><span class="s1">dodge=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">gap=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">log_scale=</span><span class="s0">None, </span><span class="s1">native_scale=</span><span class="s0">False,</span>
    <span class="s1">formatter=</span><span class="s0">None, </span><span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">ax=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s0">if </span><span class="s1">x </span><span class="s0">is None and </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">orient = </span><span class="s2">&quot;y&quot;</span>
        <span class="s1">x = </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">list(y) </span><span class="s0">else None</span>
    <span class="s0">elif </span><span class="s1">x </span><span class="s0">is not None and </span><span class="s1">y </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">orient = </span><span class="s2">&quot;x&quot;</span>
        <span class="s1">y = </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">list(x) </span><span class="s0">else None</span>
    <span class="s0">elif </span><span class="s1">x </span><span class="s0">is not None and </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Cannot pass values for both `x` and `y`.&quot;</span><span class="s1">)</span>

    <span class="s1">p = _CategoricalAggPlotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s0">if </span><span class="s1">p.plot_data.empty:</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">if </span><span class="s1">dodge == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s3"># Needs to be before scale_categorical changes the coordinate series dtype</span>
        <span class="s1">dodge = p._dodge_needed()</span>

    <span class="s0">if </span><span class="s1">p.var_types.get(p.orient) == </span><span class="s2">&quot;categorical&quot; </span><span class="s0">or not </span><span class="s1">native_scale:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(ax</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s1">saturation = saturation </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s4">1</span>
    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm</span><span class="s0">, </span><span class="s1">saturation=saturation)</span>
    <span class="s1">color = _default_color(ax.bar</span><span class="s0">, </span><span class="s1">hue</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">saturation)</span>

    <span class="s1">count_axis = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[p.orient]</span>
    <span class="s0">if </span><span class="s1">p.input_format == </span><span class="s2">&quot;wide&quot;</span><span class="s1">:</span>
        <span class="s1">p.plot_data[count_axis] = </span><span class="s4">1</span>

    <span class="s1">_check_argument(</span><span class="s2">&quot;stat&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;percent&quot;</span><span class="s0">, </span><span class="s2">&quot;probability&quot;</span><span class="s0">, </span><span class="s2">&quot;proportion&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">stat)</span>
    <span class="s1">p.variables[count_axis] = stat</span>
    <span class="s0">if </span><span class="s1">stat != </span><span class="s2">&quot;count&quot;</span><span class="s1">:</span>
        <span class="s1">denom = </span><span class="s4">100 </span><span class="s0">if </span><span class="s1">stat == </span><span class="s2">&quot;percent&quot; </span><span class="s0">else </span><span class="s4">1</span>
        <span class="s1">p.plot_data[count_axis] /= len(p.plot_data) / denom</span>

    <span class="s1">aggregator = EstimateAggregator(</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s1">errorbar=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s1">p.plot_bars(</span>
        <span class="s1">aggregator=aggregator</span><span class="s0">,</span>
        <span class="s1">dodge=dodge</span><span class="s0">,</span>
        <span class="s1">width=width</span><span class="s0">,</span>
        <span class="s1">gap=gap</span><span class="s0">,</span>
        <span class="s1">color=color</span><span class="s0">,</span>
        <span class="s1">fill=fill</span><span class="s0">,</span>
        <span class="s1">capsize=</span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">err_kws={}</span><span class="s0">,</span>
        <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">p._add_axis_labels(ax)</span>
    <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s0">return </span><span class="s1">ax</span>


<span class="s1">countplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Show the counts of observations in each categorical bin using bars. 
 
    A count plot can be thought of as a histogram across a categorical, instead 
    of quantitative, variable. The basic API and options are identical to those 
    for :func:`barplot`, so you can compare counts across nested variables. 
 
    Note that :func:`histplot` function offers similar functionality with additional 
    features (e.g. bar stacking), although its default behavior is somewhat different. 
 
    {categorical_narrative} 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    {order_vars} 
    {orient} 
    {color} 
    {palette} 
    {saturation} 
    {hue_norm} 
    stat : {{'count', 'percent', 'proportion', 'probability'}} 
        Statistic to compute; when not `'count'`, bar heights will be normalized so that 
        they sum to 100 (for `'percent'`) or 1 (otherwise) across the plot. 
 
        .. versionadded:: v0.13.0 
    {width} 
    {dodge} 
    {log_scale} 
    {native_scale} 
    {formatter} 
    {legend} 
    {ax_in} 
    kwargs : key, value mappings 
        Other parameters are passed through to :class:`matplotlib.patches.Rectangle`. 
 
    Returns 
    ------- 
    {ax_out} 
 
    See Also 
    -------- 
    histplot : Bin and count observations with additional options. 
    {barplot} 
    {catplot} 
 
    Examples 
    -------- 
    .. include:: ../docstrings/countplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">def </span><span class="s1">catplot(</span>
    <span class="s1">data=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">hue=</span><span class="s0">None, </span><span class="s1">row=</span><span class="s0">None, </span><span class="s1">col=</span><span class="s0">None, </span><span class="s1">kind=</span><span class="s2">&quot;strip&quot;</span><span class="s0">,</span>
    <span class="s1">estimator=</span><span class="s2">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">errorbar=(</span><span class="s2">&quot;ci&quot;</span><span class="s0">, </span><span class="s4">95</span><span class="s1">)</span><span class="s0">, </span><span class="s1">n_boot=</span><span class="s4">1000</span><span class="s0">, </span><span class="s1">units=</span><span class="s0">None, </span><span class="s1">seed=</span><span class="s0">None,</span>
    <span class="s1">order=</span><span class="s0">None, </span><span class="s1">hue_order=</span><span class="s0">None, </span><span class="s1">row_order=</span><span class="s0">None, </span><span class="s1">col_order=</span><span class="s0">None, </span><span class="s1">col_wrap=</span><span class="s0">None,</span>
    <span class="s1">height=</span><span class="s4">5</span><span class="s0">, </span><span class="s1">aspect=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">log_scale=</span><span class="s0">None, </span><span class="s1">native_scale=</span><span class="s0">False, </span><span class="s1">formatter=</span><span class="s0">None,</span>
    <span class="s1">orient=</span><span class="s0">None, </span><span class="s1">color=</span><span class="s0">None, </span><span class="s1">palette=</span><span class="s0">None, </span><span class="s1">hue_norm=</span><span class="s0">None, </span><span class="s1">legend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">,</span>
    <span class="s1">legend_out=</span><span class="s0">True, </span><span class="s1">sharex=</span><span class="s0">True, </span><span class="s1">sharey=</span><span class="s0">True, </span><span class="s1">margin_titles=</span><span class="s0">False, </span><span class="s1">facet_kws=</span><span class="s0">None,</span>
    <span class="s1">ci=deprecated</span><span class="s0">, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s3"># Check for attempt to plot onto specific axes and warn</span>
    <span class="s0">if </span><span class="s2">&quot;ax&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">msg = (</span><span class="s2">&quot;catplot is a figure-level function and does not accept &quot;</span>
               <span class="s2">f&quot;target axes. You may wish to try </span><span class="s0">{</span><span class="s1">kind</span><span class="s0">}</span><span class="s2">plot&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">UserWarning)</span>
        <span class="s1">kwargs.pop(</span><span class="s2">&quot;ax&quot;</span><span class="s1">)</span>

    <span class="s1">desaturated_kinds = [</span><span class="s2">&quot;bar&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;box&quot;</span><span class="s0">, </span><span class="s2">&quot;violin&quot;</span><span class="s0">, </span><span class="s2">&quot;boxen&quot;</span><span class="s1">]</span>
    <span class="s1">undodged_kinds = [</span><span class="s2">&quot;strip&quot;</span><span class="s0">, </span><span class="s2">&quot;swarm&quot;</span><span class="s0">, </span><span class="s2">&quot;point&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">kind </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;bar&quot;</span><span class="s0">, </span><span class="s2">&quot;point&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s1">]:</span>
        <span class="s1">Plotter = _CategoricalAggPlotter</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">Plotter = _CategoricalPlotter</span>

    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;count&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">x </span><span class="s0">is None and </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">orient = </span><span class="s2">&quot;y&quot;</span>
            <span class="s1">x = </span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">x </span><span class="s0">is not None and </span><span class="s1">y </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">orient = </span><span class="s2">&quot;x&quot;</span>
            <span class="s1">y = </span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">x </span><span class="s0">is not None and </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot pass values for both `x` and `y`.&quot;</span><span class="s1">)</span>

    <span class="s1">p = Plotter(</span>
        <span class="s1">data=data</span><span class="s0">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">hue=hue</span><span class="s0">, </span><span class="s1">row=row</span><span class="s0">, </span><span class="s1">col=col</span><span class="s0">, </span><span class="s1">units=units)</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s3"># Handle special backwards compatibility where pointplot originally</span>
        <span class="s3"># did *not* default to multi-colored unless a palette was specified.</span>
        <span class="s1">color=</span><span class="s2">&quot;C0&quot; </span><span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;point&quot; </span><span class="s0">and </span><span class="s1">palette </span><span class="s0">is None and </span><span class="s1">color </span><span class="s0">is None else </span><span class="s1">color</span><span class="s0">,</span>
        <span class="s1">legend=legend</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;row&quot;</span><span class="s0">, </span><span class="s2">&quot;col&quot;</span><span class="s1">]:</span>
        <span class="s3"># Handle faceting variables that lack name information</span>
        <span class="s0">if </span><span class="s1">var </span><span class="s0">in </span><span class="s1">p.variables </span><span class="s0">and </span><span class="s1">p.variables[var] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">p.variables[var] = </span><span class="s2">f&quot;_</span><span class="s0">{</span><span class="s1">var</span><span class="s0">}</span><span class="s2">_&quot;</span>

    <span class="s3"># Adapt the plot_data dataframe for use with FacetGrid</span>
    <span class="s1">facet_data = p.plot_data.rename(columns=p.variables)</span>
    <span class="s1">facet_data = facet_data.loc[:</span><span class="s0">, </span><span class="s1">~facet_data.columns.duplicated()]</span>

    <span class="s1">col_name = p.variables.get(</span><span class="s2">&quot;col&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">row_name = p.variables.get(</span><span class="s2">&quot;row&quot;</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">facet_kws </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">facet_kws = {}</span>

    <span class="s1">g = FacetGrid(</span>
        <span class="s1">data=facet_data</span><span class="s0">, </span><span class="s1">row=row_name</span><span class="s0">, </span><span class="s1">col=col_name</span><span class="s0">, </span><span class="s1">col_wrap=col_wrap</span><span class="s0">,</span>
        <span class="s1">row_order=row_order</span><span class="s0">, </span><span class="s1">col_order=col_order</span><span class="s0">, </span><span class="s1">sharex=sharex</span><span class="s0">, </span><span class="s1">sharey=sharey</span><span class="s0">,</span>
        <span class="s1">legend_out=legend_out</span><span class="s0">, </span><span class="s1">margin_titles=margin_titles</span><span class="s0">,</span>
        <span class="s1">height=height</span><span class="s0">, </span><span class="s1">aspect=aspect</span><span class="s0">,</span>
        <span class="s1">**facet_kws</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s3"># Capture this here because scale_categorical is going to insert a (null)</span>
    <span class="s3"># x variable even if it is empty. It's not clear whether that needs to</span>
    <span class="s3"># happen or if disabling that is the cleaner solution.</span>
    <span class="s1">has_xy_data = p.has_xy_data</span>

    <span class="s0">if not </span><span class="s1">native_scale </span><span class="s0">or </span><span class="s1">p.var_types[p.orient] == </span><span class="s2">&quot;categorical&quot;</span><span class="s1">:</span>
        <span class="s1">p.scale_categorical(p.orient</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">formatter=formatter)</span>

    <span class="s1">p._attach(g</span><span class="s0">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s0">if not </span><span class="s1">has_xy_data:</span>
        <span class="s0">return </span><span class="s1">g</span>

    <span class="s3"># Deprecations to remove in v0.14.0.</span>
    <span class="s1">hue_order = p._palette_without_hue_backcompat(palette</span><span class="s0">, </span><span class="s1">hue_order)</span>
    <span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order = p._hue_backcompat(color</span><span class="s0">, </span><span class="s1">palette</span><span class="s0">, </span><span class="s1">hue_order)</span>

    <span class="s3"># Othe deprecations</span>
    <span class="s1">errorbar = utils._deprecate_ci(errorbar</span><span class="s0">, </span><span class="s1">ci)</span>

    <span class="s1">saturation = kwargs.pop(</span>
        <span class="s2">&quot;saturation&quot;</span><span class="s0">,</span>
        <span class="s4">0.75 </span><span class="s0">if </span><span class="s1">kind </span><span class="s0">in </span><span class="s1">desaturated_kinds </span><span class="s0">and </span><span class="s1">kwargs.get(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, True</span><span class="s1">) </span><span class="s0">else </span><span class="s4">1</span>
    <span class="s1">)</span>
    <span class="s1">p.map_hue(palette=palette</span><span class="s0">, </span><span class="s1">order=hue_order</span><span class="s0">, </span><span class="s1">norm=hue_norm</span><span class="s0">, </span><span class="s1">saturation=saturation)</span>

    <span class="s3"># Set a default color</span>
    <span class="s3"># Otherwise each artist will be plotted separately and trip the color cycle</span>
    <span class="s0">if </span><span class="s1">hue </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">color = </span><span class="s2">&quot;C0&quot; </span><span class="s0">if </span><span class="s1">color </span><span class="s0">is None else </span><span class="s1">color</span>
        <span class="s0">if </span><span class="s1">saturation &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">color = desaturate(color</span><span class="s0">, </span><span class="s1">saturation)</span>

    <span class="s1">edgecolor = p._complement_color(kwargs.pop(</span><span class="s2">&quot;edgecolor&quot;</span><span class="s0">, </span><span class="s1">default)</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map)</span>

    <span class="s1">width = kwargs.pop(</span><span class="s2">&quot;width&quot;</span><span class="s0">, </span><span class="s4">0.8</span><span class="s1">)</span>
    <span class="s1">dodge = kwargs.pop(</span><span class="s2">&quot;dodge&quot;</span><span class="s0">, False if </span><span class="s1">kind </span><span class="s0">in </span><span class="s1">undodged_kinds </span><span class="s0">else </span><span class="s2">&quot;auto&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">dodge == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
        <span class="s1">dodge = p._dodge_needed()</span>

    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">&quot;strip&quot;</span><span class="s1">:</span>

        <span class="s1">jitter = kwargs.pop(</span><span class="s2">&quot;jitter&quot;</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">plot_kws = kwargs.copy()</span>
        <span class="s1">plot_kws[</span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">] = edgecolor</span>
        <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;zorder&quot;</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s2">&quot;s&quot; </span><span class="s0">not in </span><span class="s1">plot_kws:</span>
            <span class="s1">plot_kws[</span><span class="s2">&quot;s&quot;</span><span class="s1">] = plot_kws.pop(</span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s4">5</span><span class="s1">) ** </span><span class="s4">2</span>

        <span class="s1">p.plot_strips(</span>
            <span class="s1">jitter=jitter</span><span class="s0">,</span>
            <span class="s1">dodge=dodge</span><span class="s0">,</span>
            <span class="s1">color=color</span><span class="s0">,</span>
            <span class="s1">plot_kws=plot_kws</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;swarm&quot;</span><span class="s1">:</span>

        <span class="s1">warn_thresh = kwargs.pop(</span><span class="s2">&quot;warn_thresh&quot;</span><span class="s0">, </span><span class="s4">.05</span><span class="s1">)</span>
        <span class="s1">plot_kws = kwargs.copy()</span>
        <span class="s1">plot_kws[</span><span class="s2">&quot;edgecolor&quot;</span><span class="s1">] = edgecolor</span>
        <span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;zorder&quot;</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s2">&quot;s&quot; </span><span class="s0">not in </span><span class="s1">plot_kws:</span>
            <span class="s1">plot_kws[</span><span class="s2">&quot;s&quot;</span><span class="s1">] = plot_kws.pop(</span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s4">5</span><span class="s1">) ** </span><span class="s4">2</span>

        <span class="s0">if </span><span class="s1">plot_kws.setdefault(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">plot_kws[</span><span class="s2">&quot;linewidth&quot;</span><span class="s1">] = np.sqrt(plot_kws[</span><span class="s2">&quot;s&quot;</span><span class="s1">]) / </span><span class="s4">10</span>

        <span class="s1">p.plot_swarms(</span>
            <span class="s1">dodge=dodge</span><span class="s0">,</span>
            <span class="s1">color=color</span><span class="s0">,</span>
            <span class="s1">warn_thresh=warn_thresh</span><span class="s0">,</span>
            <span class="s1">plot_kws=plot_kws</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;box&quot;</span><span class="s1">:</span>

        <span class="s1">plot_kws = kwargs.copy()</span>
        <span class="s1">gap = plot_kws.pop(</span><span class="s2">&quot;gap&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">fill = plot_kws.pop(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">whis = plot_kws.pop(</span><span class="s2">&quot;whis&quot;</span><span class="s0">, </span><span class="s4">1.5</span><span class="s1">)</span>
        <span class="s1">linewidth = plot_kws.pop(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">fliersize = plot_kws.pop(</span><span class="s2">&quot;fliersize&quot;</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">linecolor = p._complement_color(</span>
            <span class="s1">plot_kws.pop(</span><span class="s2">&quot;linecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;auto&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map</span>
        <span class="s1">)</span>

        <span class="s1">p.plot_boxes(</span>
            <span class="s1">width=width</span><span class="s0">,</span>
            <span class="s1">dodge=dodge</span><span class="s0">,</span>
            <span class="s1">gap=gap</span><span class="s0">,</span>
            <span class="s1">fill=fill</span><span class="s0">,</span>
            <span class="s1">whis=whis</span><span class="s0">,</span>
            <span class="s1">color=color</span><span class="s0">,</span>
            <span class="s1">linecolor=linecolor</span><span class="s0">,</span>
            <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
            <span class="s1">fliersize=fliersize</span><span class="s0">,</span>
            <span class="s1">plot_kws=plot_kws</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;violin&quot;</span><span class="s1">:</span>

        <span class="s1">plot_kws = kwargs.copy()</span>
        <span class="s1">gap = plot_kws.pop(</span><span class="s2">&quot;gap&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">fill = plot_kws.pop(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">split = plot_kws.pop(</span><span class="s2">&quot;split&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">inner = plot_kws.pop(</span><span class="s2">&quot;inner&quot;</span><span class="s0">, </span><span class="s2">&quot;box&quot;</span><span class="s1">)</span>
        <span class="s1">density_norm = plot_kws.pop(</span><span class="s2">&quot;density_norm&quot;</span><span class="s0">, </span><span class="s2">&quot;area&quot;</span><span class="s1">)</span>
        <span class="s1">common_norm = plot_kws.pop(</span><span class="s2">&quot;common_norm&quot;</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s1">scale = plot_kws.pop(</span><span class="s2">&quot;scale&quot;</span><span class="s0">, </span><span class="s1">deprecated)</span>
        <span class="s1">scale_hue = plot_kws.pop(</span><span class="s2">&quot;scale_hue&quot;</span><span class="s0">, </span><span class="s1">deprecated)</span>
        <span class="s1">density_norm</span><span class="s0">, </span><span class="s1">common_norm = p._violin_scale_backcompat(</span>
            <span class="s1">scale</span><span class="s0">, </span><span class="s1">scale_hue</span><span class="s0">, </span><span class="s1">density_norm</span><span class="s0">, </span><span class="s1">common_norm</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">bw_method = p._violin_bw_backcompat(</span>
            <span class="s1">plot_kws.pop(</span><span class="s2">&quot;bw&quot;</span><span class="s0">, </span><span class="s1">deprecated)</span><span class="s0">, </span><span class="s1">plot_kws.pop(</span><span class="s2">&quot;bw_method&quot;</span><span class="s0">, </span><span class="s2">&quot;scott&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">kde_kws = dict(</span>
            <span class="s1">cut=plot_kws.pop(</span><span class="s2">&quot;cut&quot;</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">gridsize=plot_kws.pop(</span><span class="s2">&quot;gridsize&quot;</span><span class="s0">, </span><span class="s4">100</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">bw_adjust=plot_kws.pop(</span><span class="s2">&quot;bw_adjust&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">bw_method=bw_method</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">inner_kws = plot_kws.pop(</span><span class="s2">&quot;inner_kws&quot;</span><span class="s0">, </span><span class="s1">{}).copy()</span>
        <span class="s1">linewidth = plot_kws.pop(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">linecolor = plot_kws.pop(</span><span class="s2">&quot;linecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;auto&quot;</span><span class="s1">)</span>
        <span class="s1">linecolor = p._complement_color(linecolor</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map)</span>

        <span class="s1">p.plot_violins(</span>
            <span class="s1">width=width</span><span class="s0">,</span>
            <span class="s1">dodge=dodge</span><span class="s0">,</span>
            <span class="s1">gap=gap</span><span class="s0">,</span>
            <span class="s1">split=split</span><span class="s0">,</span>
            <span class="s1">color=color</span><span class="s0">,</span>
            <span class="s1">fill=fill</span><span class="s0">,</span>
            <span class="s1">linecolor=linecolor</span><span class="s0">,</span>
            <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
            <span class="s1">inner=inner</span><span class="s0">,</span>
            <span class="s1">density_norm=density_norm</span><span class="s0">,</span>
            <span class="s1">common_norm=common_norm</span><span class="s0">,</span>
            <span class="s1">kde_kws=kde_kws</span><span class="s0">,</span>
            <span class="s1">inner_kws=inner_kws</span><span class="s0">,</span>
            <span class="s1">plot_kws=plot_kws</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;boxen&quot;</span><span class="s1">:</span>

        <span class="s1">plot_kws = kwargs.copy()</span>
        <span class="s1">gap = plot_kws.pop(</span><span class="s2">&quot;gap&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">fill = plot_kws.pop(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">linecolor = plot_kws.pop(</span><span class="s2">&quot;linecolor&quot;</span><span class="s0">, </span><span class="s2">&quot;auto&quot;</span><span class="s1">)</span>
        <span class="s1">linewidth = plot_kws.pop(</span><span class="s2">&quot;linewidth&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">k_depth = plot_kws.pop(</span><span class="s2">&quot;k_depth&quot;</span><span class="s0">, </span><span class="s2">&quot;tukey&quot;</span><span class="s1">)</span>
        <span class="s1">width_method = plot_kws.pop(</span><span class="s2">&quot;width_method&quot;</span><span class="s0">, </span><span class="s2">&quot;exponential&quot;</span><span class="s1">)</span>
        <span class="s1">outlier_prop = plot_kws.pop(</span><span class="s2">&quot;outlier_prop&quot;</span><span class="s0">, </span><span class="s4">0.007</span><span class="s1">)</span>
        <span class="s1">trust_alpha = plot_kws.pop(</span><span class="s2">&quot;trust_alpha&quot;</span><span class="s0">, </span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">showfliers = plot_kws.pop(</span><span class="s2">&quot;showfliers&quot;</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">box_kws = plot_kws.pop(</span><span class="s2">&quot;box_kws&quot;</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s1">flier_kws = plot_kws.pop(</span><span class="s2">&quot;flier_kws&quot;</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s1">line_kws = plot_kws.pop(</span><span class="s2">&quot;line_kws&quot;</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s0">if </span><span class="s2">&quot;scale&quot; </span><span class="s0">in </span><span class="s1">plot_kws:</span>
            <span class="s1">width_method = p._boxen_scale_backcompat(</span>
                <span class="s1">plot_kws[</span><span class="s2">&quot;scale&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">width_method</span>
            <span class="s1">)</span>
        <span class="s1">linecolor = p._complement_color(linecolor</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">p._hue_map)</span>

        <span class="s1">p.plot_boxens(</span>
            <span class="s1">width=width</span><span class="s0">,</span>
            <span class="s1">dodge=dodge</span><span class="s0">,</span>
            <span class="s1">gap=gap</span><span class="s0">,</span>
            <span class="s1">fill=fill</span><span class="s0">,</span>
            <span class="s1">color=color</span><span class="s0">,</span>
            <span class="s1">linecolor=linecolor</span><span class="s0">,</span>
            <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
            <span class="s1">width_method=width_method</span><span class="s0">,</span>
            <span class="s1">k_depth=k_depth</span><span class="s0">,</span>
            <span class="s1">outlier_prop=outlier_prop</span><span class="s0">,</span>
            <span class="s1">trust_alpha=trust_alpha</span><span class="s0">,</span>
            <span class="s1">showfliers=showfliers</span><span class="s0">,</span>
            <span class="s1">box_kws=box_kws</span><span class="s0">,</span>
            <span class="s1">flier_kws=flier_kws</span><span class="s0">,</span>
            <span class="s1">line_kws=line_kws</span><span class="s0">,</span>
            <span class="s1">plot_kws=plot_kws</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;point&quot;</span><span class="s1">:</span>

        <span class="s1">aggregator = EstimateAggregator(</span>
            <span class="s1">estimator</span><span class="s0">, </span><span class="s1">errorbar</span><span class="s0">, </span><span class="s1">n_boot=n_boot</span><span class="s0">, </span><span class="s1">seed=seed</span>
        <span class="s1">)</span>

        <span class="s1">markers = kwargs.pop(</span><span class="s2">&quot;markers&quot;</span><span class="s0">, </span><span class="s1">default)</span>
        <span class="s1">linestyles = kwargs.pop(</span><span class="s2">&quot;linestyles&quot;</span><span class="s0">, </span><span class="s1">default)</span>

        <span class="s3"># Deprecations to remove in v0.15.0.</span>
        <span class="s3"># TODO Uncomment when removing deprecation backcompat</span>
        <span class="s3"># capsize = kwargs.pop(&quot;capsize&quot;, 0)</span>
        <span class="s3"># err_kws = _normalize_kwargs(kwargs.pop(&quot;err_kws&quot;, {}), mpl.lines.Line2D)</span>
        <span class="s1">p._point_kwargs_backcompat(</span>
            <span class="s1">kwargs.pop(</span><span class="s2">&quot;scale&quot;</span><span class="s0">, </span><span class="s1">deprecated)</span><span class="s0">,</span>
            <span class="s1">kwargs.pop(</span><span class="s2">&quot;join&quot;</span><span class="s0">, </span><span class="s1">deprecated)</span><span class="s0">,</span>
            <span class="s1">kwargs</span>
        <span class="s1">)</span>
        <span class="s1">err_kws</span><span class="s0">, </span><span class="s1">capsize = p._err_kws_backcompat(</span>
            <span class="s1">_normalize_kwargs(kwargs.pop(</span><span class="s2">&quot;err_kws&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">, </span><span class="s1">mpl.lines.Line2D)</span><span class="s0">,</span>
            <span class="s0">None,</span>
            <span class="s1">errwidth=kwargs.pop(</span><span class="s2">&quot;errwidth&quot;</span><span class="s0">, </span><span class="s1">deprecated)</span><span class="s0">,</span>
            <span class="s1">capsize=kwargs.pop(</span><span class="s2">&quot;capsize&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">p.plot_points(</span>
            <span class="s1">aggregator=aggregator</span><span class="s0">,</span>
            <span class="s1">markers=markers</span><span class="s0">,</span>
            <span class="s1">linestyles=linestyles</span><span class="s0">,</span>
            <span class="s1">dodge=dodge</span><span class="s0">,</span>
            <span class="s1">color=color</span><span class="s0">,</span>
            <span class="s1">capsize=capsize</span><span class="s0">,</span>
            <span class="s1">err_kws=err_kws</span><span class="s0">,</span>
            <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;bar&quot;</span><span class="s1">:</span>

        <span class="s1">aggregator = EstimateAggregator(</span>
            <span class="s1">estimator</span><span class="s0">, </span><span class="s1">errorbar</span><span class="s0">, </span><span class="s1">n_boot=n_boot</span><span class="s0">, </span><span class="s1">seed=seed</span>
        <span class="s1">)</span>
        <span class="s1">err_kws</span><span class="s0">, </span><span class="s1">capsize = p._err_kws_backcompat(</span>
            <span class="s1">_normalize_kwargs(kwargs.pop(</span><span class="s2">&quot;err_kws&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">, </span><span class="s1">mpl.lines.Line2D)</span><span class="s0">,</span>
            <span class="s1">errcolor=kwargs.pop(</span><span class="s2">&quot;errcolor&quot;</span><span class="s0">, </span><span class="s1">deprecated)</span><span class="s0">,</span>
            <span class="s1">errwidth=kwargs.pop(</span><span class="s2">&quot;errwidth&quot;</span><span class="s0">, </span><span class="s1">deprecated)</span><span class="s0">,</span>
            <span class="s1">capsize=kwargs.pop(</span><span class="s2">&quot;capsize&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">gap = kwargs.pop(</span><span class="s2">&quot;gap&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">fill = kwargs.pop(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">p.plot_bars(</span>
            <span class="s1">aggregator=aggregator</span><span class="s0">,</span>
            <span class="s1">dodge=dodge</span><span class="s0">,</span>
            <span class="s1">width=width</span><span class="s0">,</span>
            <span class="s1">gap=gap</span><span class="s0">,</span>
            <span class="s1">color=color</span><span class="s0">,</span>
            <span class="s1">fill=fill</span><span class="s0">,</span>
            <span class="s1">capsize=capsize</span><span class="s0">,</span>
            <span class="s1">err_kws=err_kws</span><span class="s0">,</span>
            <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">&quot;count&quot;</span><span class="s1">:</span>

        <span class="s1">aggregator = EstimateAggregator(</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s1">errorbar=</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s1">count_axis = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s1">}[p.orient]</span>
        <span class="s1">p.plot_data[count_axis] = </span><span class="s4">1</span>

        <span class="s1">stat_options = [</span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;percent&quot;</span><span class="s0">, </span><span class="s2">&quot;probability&quot;</span><span class="s0">, </span><span class="s2">&quot;proportion&quot;</span><span class="s1">]</span>
        <span class="s1">stat = _check_argument(</span><span class="s2">&quot;stat&quot;</span><span class="s0">, </span><span class="s1">stat_options</span><span class="s0">, </span><span class="s1">kwargs.pop(</span><span class="s2">&quot;stat&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s1">))</span>
        <span class="s1">p.variables[count_axis] = stat</span>
        <span class="s0">if </span><span class="s1">stat != </span><span class="s2">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s1">denom = </span><span class="s4">100 </span><span class="s0">if </span><span class="s1">stat == </span><span class="s2">&quot;percent&quot; </span><span class="s0">else </span><span class="s4">1</span>
            <span class="s1">p.plot_data[count_axis] /= len(p.plot_data) / denom</span>

        <span class="s1">gap = kwargs.pop(</span><span class="s2">&quot;gap&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">fill = kwargs.pop(</span><span class="s2">&quot;fill&quot;</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">p.plot_bars(</span>
            <span class="s1">aggregator=aggregator</span><span class="s0">,</span>
            <span class="s1">dodge=dodge</span><span class="s0">,</span>
            <span class="s1">width=width</span><span class="s0">,</span>
            <span class="s1">gap=gap</span><span class="s0">,</span>
            <span class="s1">color=color</span><span class="s0">,</span>
            <span class="s1">fill=fill</span><span class="s0">,</span>
            <span class="s1">capsize=</span><span class="s4">0</span><span class="s0">,</span>
            <span class="s1">err_kws={}</span><span class="s0">,</span>
            <span class="s1">plot_kws=kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msg = (</span>
            <span class="s2">f&quot;Invalid `kind`: </span><span class="s0">{</span><span class="s1">kind</span><span class="s0">!r}</span><span class="s2">. Options are 'strip', 'swarm', &quot;</span>
            <span class="s2">&quot;'box', 'boxen', 'violin', 'bar', 'count', and 'point'.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">g.axes.flat:</span>
        <span class="s1">p._adjust_cat_axis(ax</span><span class="s0">, </span><span class="s1">axis=p.orient)</span>

    <span class="s1">g.set_axis_labels(p.variables.get(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">p.variables.get(</span><span class="s2">&quot;y&quot;</span><span class="s1">))</span>
    <span class="s1">g.set_titles()</span>
    <span class="s1">g.tight_layout()</span>

    <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">g.axes.flat:</span>
        <span class="s1">g._update_legend_data(ax)</span>
        <span class="s1">ax.legend_ = </span><span class="s0">None</span>

    <span class="s0">if </span><span class="s1">legend </span><span class="s0">and </span><span class="s2">&quot;hue&quot; </span><span class="s0">in </span><span class="s1">p.variables </span><span class="s0">and </span><span class="s1">p.input_format == </span><span class="s2">&quot;long&quot;</span><span class="s1">:</span>
        <span class="s1">g.add_legend(title=p.variables.get(</span><span class="s2">&quot;hue&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">label_order=hue_order)</span>

    <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s3"># Replace the dataframe on the FacetGrid for any subsequent maps</span>
        <span class="s1">g.data = data</span>

    <span class="s0">return </span><span class="s1">g</span>


<span class="s1">catplot.__doc__ = dedent(</span><span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
    </span><span class="s2">Figure-level interface for drawing categorical plots onto a FacetGrid. 
 
    This function provides access to several axes-level functions that 
    show the relationship between a numerical and one or more categorical 
    variables using one of several visual representations. The `kind` 
    parameter selects the underlying axes-level function to use. 
 
    Categorical scatterplots: 
 
    - :func:`stripplot` (with `kind=&quot;strip&quot;`; the default) 
    - :func:`swarmplot` (with `kind=&quot;swarm&quot;`) 
 
    Categorical distribution plots: 
 
    - :func:`boxplot` (with `kind=&quot;box&quot;`) 
    - :func:`violinplot` (with `kind=&quot;violin&quot;`) 
    - :func:`boxenplot` (with `kind=&quot;boxen&quot;`) 
 
    Categorical estimate plots: 
 
    - :func:`pointplot` (with `kind=&quot;point&quot;`) 
    - :func:`barplot` (with `kind=&quot;bar&quot;`) 
    - :func:`countplot` (with `kind=&quot;count&quot;`) 
 
    Extra keyword arguments are passed to the underlying function, so you 
    should refer to the documentation for each to see kind-specific options. 
 
    {categorical_narrative} 
 
    After plotting, the :class:`FacetGrid` with the plot is returned and can 
    be used directly to tweak supporting plot details or add other layers. 
 
    Parameters 
    ---------- 
    {categorical_data} 
    {input_params} 
    row, col : names of variables in `data` or vector data 
        Categorical variables that will determine the faceting of the grid. 
    kind : str 
        The kind of plot to draw, corresponds to the name of a categorical 
        axes-level plotting function. Options are: &quot;strip&quot;, &quot;swarm&quot;, &quot;box&quot;, &quot;violin&quot;, 
        &quot;boxen&quot;, &quot;point&quot;, &quot;bar&quot;, or &quot;count&quot;. 
    {stat_api_params} 
    {order_vars} 
    row_order, col_order : lists of strings 
        Order to organize the rows and/or columns of the grid in; otherwise the 
        orders are inferred from the data objects. 
    {col_wrap} 
    {height} 
    {aspect} 
    {native_scale} 
    {formatter} 
    {orient} 
    {color} 
    {palette} 
    {hue_norm} 
    {legend} 
    {legend_out} 
    {share_xy} 
    {margin_titles} 
    facet_kws : dict 
        Dictionary of other keyword arguments to pass to :class:`FacetGrid`. 
    kwargs : key, value pairings 
        Other keyword arguments are passed through to the underlying plotting 
        function. 
 
    Returns 
    ------- 
    :class:`FacetGrid` 
        Returns the :class:`FacetGrid` object with the plot on it for further 
        tweaking. 
 
    Examples 
    -------- 
    .. include:: ../docstrings/catplot.rst 
 
    &quot;&quot;&quot;</span><span class="s1">).format(**_categorical_docs)</span>


<span class="s0">class </span><span class="s1">Beeswarm:</span>
    <span class="s5">&quot;&quot;&quot;Modifies a scatterplot artist to show a beeswarm plot.&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">width=</span><span class="s4">0.8</span><span class="s0">, </span><span class="s1">warn_thresh=</span><span class="s4">.05</span><span class="s1">):</span>

        <span class="s1">self.orient = orient</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.warn_thresh = warn_thresh</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">center):</span>
        <span class="s5">&quot;&quot;&quot;Swarm `points`, a PathCollection, around the `center` position.&quot;&quot;&quot;</span>
        <span class="s3"># Convert from point size (area) to diameter</span>

        <span class="s1">ax = points.axes</span>
        <span class="s1">dpi = ax.figure.dpi</span>

        <span class="s3"># Get the original positions of the points</span>
        <span class="s1">orig_xy_data = points.get_offsets()</span>

        <span class="s3"># Reset the categorical positions to the center line</span>
        <span class="s1">cat_idx = </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;y&quot; </span><span class="s0">else </span><span class="s4">0</span>
        <span class="s1">orig_xy_data[:</span><span class="s0">, </span><span class="s1">cat_idx] = center</span>

        <span class="s3"># Transform the data coordinates to point coordinates.</span>
        <span class="s3"># We'll figure out the swarm positions in the latter</span>
        <span class="s3"># and then convert back to data coordinates and replot</span>
        <span class="s1">orig_x_data</span><span class="s0">, </span><span class="s1">orig_y_data = orig_xy_data.T</span>
        <span class="s1">orig_xy = ax.transData.transform(orig_xy_data)</span>

        <span class="s3"># Order the variables so that x is the categorical axis</span>
        <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">orig_xy = orig_xy[:</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]</span>

        <span class="s3"># Add a column with each point's radius</span>
        <span class="s1">sizes = points.get_sizes()</span>
        <span class="s0">if </span><span class="s1">sizes.size == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">sizes = np.repeat(sizes</span><span class="s0">, </span><span class="s1">orig_xy.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">edge = points.get_linewidth().item()</span>
        <span class="s1">radii = (np.sqrt(sizes) + edge) / </span><span class="s4">2 </span><span class="s1">* (dpi / </span><span class="s4">72</span><span class="s1">)</span>
        <span class="s1">orig_xy = np.c_[orig_xy</span><span class="s0">, </span><span class="s1">radii]</span>

        <span class="s3"># Sort along the value axis to facilitate the beeswarm</span>
        <span class="s1">sorter = np.argsort(orig_xy[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">orig_xyr = orig_xy[sorter]</span>

        <span class="s3"># Adjust points along the categorical axis to prevent overlaps</span>
        <span class="s1">new_xyr = np.empty_like(orig_xyr)</span>
        <span class="s1">new_xyr[sorter] = self.beeswarm(orig_xyr)</span>

        <span class="s3"># Transform the point coordinates back to data coordinates</span>
        <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">new_xy = new_xyr[:</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_xy = new_xyr[:</span><span class="s0">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">new_x_data</span><span class="s0">, </span><span class="s1">new_y_data = ax.transData.inverted().transform(new_xy).T</span>

        <span class="s3"># Add gutters</span>
        <span class="s1">t_fwd</span><span class="s0">, </span><span class="s1">t_inv = _get_transform_functions(ax</span><span class="s0">, </span><span class="s1">self.orient)</span>
        <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">self.add_gutters(new_y_data</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">t_fwd</span><span class="s0">, </span><span class="s1">t_inv)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.add_gutters(new_x_data</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">t_fwd</span><span class="s0">, </span><span class="s1">t_inv)</span>

        <span class="s3"># Reposition the points so they do not overlap</span>
        <span class="s0">if </span><span class="s1">self.orient == </span><span class="s2">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">points.set_offsets(np.c_[orig_x_data</span><span class="s0">, </span><span class="s1">new_y_data])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">points.set_offsets(np.c_[new_x_data</span><span class="s0">, </span><span class="s1">orig_y_data])</span>

    <span class="s0">def </span><span class="s1">beeswarm(self</span><span class="s0">, </span><span class="s1">orig_xyr):</span>
        <span class="s5">&quot;&quot;&quot;Adjust x position of points to avoid overlaps.&quot;&quot;&quot;</span>
        <span class="s3"># In this method, `x` is always the categorical axis</span>
        <span class="s3"># Center of the swarm, in point coordinates</span>
        <span class="s1">midline = orig_xyr[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>

        <span class="s3"># Start the swarm with the first point</span>
        <span class="s1">swarm = np.atleast_2d(orig_xyr[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s3"># Loop over the remaining points</span>
        <span class="s0">for </span><span class="s1">xyr_i </span><span class="s0">in </span><span class="s1">orig_xyr[</span><span class="s4">1</span><span class="s1">:]:</span>

            <span class="s3"># Find the points in the swarm that could possibly</span>
            <span class="s3"># overlap with the point we are currently placing</span>
            <span class="s1">neighbors = self.could_overlap(xyr_i</span><span class="s0">, </span><span class="s1">swarm)</span>

            <span class="s3"># Find positions that would be valid individually</span>
            <span class="s3"># with respect to each of the swarm neighbors</span>
            <span class="s1">candidates = self.position_candidates(xyr_i</span><span class="s0">, </span><span class="s1">neighbors)</span>

            <span class="s3"># Sort candidates by their centrality</span>
            <span class="s1">offsets = np.abs(candidates[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] - midline)</span>
            <span class="s1">candidates = candidates[np.argsort(offsets)]</span>

            <span class="s3"># Find the first candidate that does not overlap any neighbors</span>
            <span class="s1">new_xyr_i = self.first_non_overlapping_candidate(candidates</span><span class="s0">, </span><span class="s1">neighbors)</span>

            <span class="s3"># Place it into the swarm</span>
            <span class="s1">swarm = np.vstack([swarm</span><span class="s0">, </span><span class="s1">new_xyr_i])</span>

        <span class="s0">return </span><span class="s1">swarm</span>

    <span class="s0">def </span><span class="s1">could_overlap(self</span><span class="s0">, </span><span class="s1">xyr_i</span><span class="s0">, </span><span class="s1">swarm):</span>
        <span class="s5">&quot;&quot;&quot;Return a list of all swarm points that could overlap with target.&quot;&quot;&quot;</span>
        <span class="s3"># Because we work backwards through the swarm and can short-circuit,</span>
        <span class="s3"># the for-loop is faster than vectorization</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">y_i</span><span class="s0">, </span><span class="s1">r_i = xyr_i</span>
        <span class="s1">neighbors = []</span>
        <span class="s0">for </span><span class="s1">xyr_j </span><span class="s0">in </span><span class="s1">reversed(swarm):</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">y_j</span><span class="s0">, </span><span class="s1">r_j = xyr_j</span>
            <span class="s0">if </span><span class="s1">(y_i - y_j) &lt; (r_i + r_j):</span>
                <span class="s1">neighbors.append(xyr_j)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">break</span>
        <span class="s0">return </span><span class="s1">np.array(neighbors)[::-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">position_candidates(self</span><span class="s0">, </span><span class="s1">xyr_i</span><span class="s0">, </span><span class="s1">neighbors):</span>
        <span class="s5">&quot;&quot;&quot;Return a list of coordinates that might be valid by adjusting x.&quot;&quot;&quot;</span>
        <span class="s1">candidates = [xyr_i]</span>
        <span class="s1">x_i</span><span class="s0">, </span><span class="s1">y_i</span><span class="s0">, </span><span class="s1">r_i = xyr_i</span>
        <span class="s1">left_first = </span><span class="s0">True</span>
        <span class="s0">for </span><span class="s1">x_j</span><span class="s0">, </span><span class="s1">y_j</span><span class="s0">, </span><span class="s1">r_j </span><span class="s0">in </span><span class="s1">neighbors:</span>
            <span class="s1">dy = y_i - y_j</span>
            <span class="s1">dx = np.sqrt(max((r_i + r_j) ** </span><span class="s4">2 </span><span class="s1">- dy ** </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)) * </span><span class="s4">1.05</span>
            <span class="s1">cl</span><span class="s0">, </span><span class="s1">cr = (x_j - dx</span><span class="s0">, </span><span class="s1">y_i</span><span class="s0">, </span><span class="s1">r_i)</span><span class="s0">, </span><span class="s1">(x_j + dx</span><span class="s0">, </span><span class="s1">y_i</span><span class="s0">, </span><span class="s1">r_i)</span>
            <span class="s0">if </span><span class="s1">left_first:</span>
                <span class="s1">new_candidates = [cl</span><span class="s0">, </span><span class="s1">cr]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">new_candidates = [cr</span><span class="s0">, </span><span class="s1">cl]</span>
            <span class="s1">candidates.extend(new_candidates)</span>
            <span class="s1">left_first = </span><span class="s0">not </span><span class="s1">left_first</span>
        <span class="s0">return </span><span class="s1">np.array(candidates)</span>

    <span class="s0">def </span><span class="s1">first_non_overlapping_candidate(self</span><span class="s0">, </span><span class="s1">candidates</span><span class="s0">, </span><span class="s1">neighbors):</span>
        <span class="s5">&quot;&quot;&quot;Find the first candidate that does not overlap with the swarm.&quot;&quot;&quot;</span>

        <span class="s3"># If we have no neighbors, all candidates are good.</span>
        <span class="s0">if </span><span class="s1">len(neighbors) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">candidates[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">neighbors_x = neighbors[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">neighbors_y = neighbors[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">neighbors_r = neighbors[:</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">xyr_i </span><span class="s0">in </span><span class="s1">candidates:</span>

            <span class="s1">x_i</span><span class="s0">, </span><span class="s1">y_i</span><span class="s0">, </span><span class="s1">r_i = xyr_i</span>

            <span class="s1">dx = neighbors_x - x_i</span>
            <span class="s1">dy = neighbors_y - y_i</span>
            <span class="s1">sq_distances = np.square(dx) + np.square(dy)</span>

            <span class="s1">sep_needed = np.square(neighbors_r + r_i)</span>

            <span class="s3"># Good candidate does not overlap any of neighbors which means that</span>
            <span class="s3"># squared distance between candidate and any of the neighbors has</span>
            <span class="s3"># to be at least square of the summed radii</span>
            <span class="s1">good_candidate = np.all(sq_distances &gt;= sep_needed)</span>

            <span class="s0">if </span><span class="s1">good_candidate:</span>
                <span class="s0">return </span><span class="s1">xyr_i</span>

        <span class="s0">raise </span><span class="s1">RuntimeError(</span>
            <span class="s2">&quot;No non-overlapping candidates found. This should not happen.&quot;</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_gutters(self</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">trans_fwd</span><span class="s0">, </span><span class="s1">trans_inv):</span>
        <span class="s5">&quot;&quot;&quot;Stop points from extending beyond their territory.&quot;&quot;&quot;</span>
        <span class="s1">half_width = self.width / </span><span class="s4">2</span>
        <span class="s1">low_gutter = trans_inv(trans_fwd(center) - half_width)</span>
        <span class="s1">off_low = points &lt; low_gutter</span>
        <span class="s0">if </span><span class="s1">off_low.any():</span>
            <span class="s1">points[off_low] = low_gutter</span>
        <span class="s1">high_gutter = trans_inv(trans_fwd(center) + half_width)</span>
        <span class="s1">off_high = points &gt; high_gutter</span>
        <span class="s0">if </span><span class="s1">off_high.any():</span>
            <span class="s1">points[off_high] = high_gutter</span>

        <span class="s1">gutter_prop = (off_high + off_low).sum() / len(points)</span>
        <span class="s0">if </span><span class="s1">gutter_prop &gt; self.warn_thresh:</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;{:.1%} of the points cannot be placed; you may want &quot;</span>
                <span class="s2">&quot;to decrease the size of the markers or use stripplot.&quot;</span>
            <span class="s1">).format(gutter_prop)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">UserWarning)</span>

        <span class="s0">return </span><span class="s1">points</span>


<span class="s1">BoxPlotArtists = namedtuple(</span><span class="s2">&quot;BoxPlotArtists&quot;</span><span class="s0">, </span><span class="s2">&quot;box median whiskers caps fliers mean&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">BoxPlotContainer:</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">artist_dict):</span>

        <span class="s1">self.boxes = artist_dict[</span><span class="s2">&quot;boxes&quot;</span><span class="s1">]</span>
        <span class="s1">self.medians = artist_dict[</span><span class="s2">&quot;medians&quot;</span><span class="s1">]</span>
        <span class="s1">self.whiskers = artist_dict[</span><span class="s2">&quot;whiskers&quot;</span><span class="s1">]</span>
        <span class="s1">self.caps = artist_dict[</span><span class="s2">&quot;caps&quot;</span><span class="s1">]</span>
        <span class="s1">self.fliers = artist_dict[</span><span class="s2">&quot;fliers&quot;</span><span class="s1">]</span>
        <span class="s1">self.means = artist_dict[</span><span class="s2">&quot;means&quot;</span><span class="s1">]</span>

        <span class="s1">self._label = </span><span class="s0">None</span>
        <span class="s1">self._children = [</span>
            <span class="s1">*self.boxes</span><span class="s0">,</span>
            <span class="s1">*self.medians</span><span class="s0">,</span>
            <span class="s1">*self.whiskers</span><span class="s0">,</span>
            <span class="s1">*self.caps</span><span class="s0">,</span>
            <span class="s1">*self.fliers</span><span class="s0">,</span>
            <span class="s1">*self.means</span><span class="s0">,</span>
        <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;BoxPlotContainer object with </span><span class="s0">{</span><span class="s1">len(self.boxes)</span><span class="s0">} </span><span class="s2">boxes&gt;&quot;</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">idx):</span>
        <span class="s1">pair_slice = slice(</span><span class="s4">2 </span><span class="s1">* idx</span><span class="s0">, </span><span class="s4">2 </span><span class="s1">* idx + </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">BoxPlotArtists(</span>
            <span class="s1">self.boxes[idx] </span><span class="s0">if </span><span class="s1">self.boxes </span><span class="s0">else </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">self.medians[idx] </span><span class="s0">if </span><span class="s1">self.medians </span><span class="s0">else </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">self.whiskers[pair_slice] </span><span class="s0">if </span><span class="s1">self.whiskers </span><span class="s0">else </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">self.caps[pair_slice] </span><span class="s0">if </span><span class="s1">self.caps </span><span class="s0">else </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">self.fliers[idx] </span><span class="s0">if </span><span class="s1">self.fliers </span><span class="s0">else </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">self.means[idx]</span><span class="s0">if </span><span class="s1">self.means </span><span class="s0">else </span><span class="s1">[]</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">yield from </span><span class="s1">(self[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self.boxes)))</span>

    <span class="s0">def </span><span class="s1">get_label(self):</span>
        <span class="s0">return </span><span class="s1">self._label</span>

    <span class="s0">def </span><span class="s1">set_label(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">self._label = value</span>

    <span class="s0">def </span><span class="s1">get_children(self):</span>
        <span class="s0">return </span><span class="s1">self._children</span>

    <span class="s0">def </span><span class="s1">remove(self):</span>
        <span class="s0">for </span><span class="s1">child </span><span class="s0">in </span><span class="s1">self._children:</span>
            <span class="s1">child.remove()</span>
</pre>
</body>
</html>