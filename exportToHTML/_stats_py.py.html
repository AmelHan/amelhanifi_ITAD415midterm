<html>
<head>
<title>_stats_py.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_stats_py.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2002 Gary Strangman.  All rights reserved</span>
<span class="s0"># Copyright 2002-2016 The SciPy Developers</span>
<span class="s0">#</span>
<span class="s0"># The original code from Gary Strangman was heavily adapted for</span>
<span class="s0"># use in SciPy by Travis Oliphant.  The original code came with the</span>
<span class="s0"># following disclaimer:</span>
<span class="s0">#</span>
<span class="s0"># This software is provided &quot;as-is&quot;.  There are no expressed or implied</span>
<span class="s0"># warranties of any kind, including, but not limited to, the warranties</span>
<span class="s0"># of merchantability and fitness for a given application.  In no event</span>
<span class="s0"># shall Gary Strangman be liable for any direct, indirect, incidental,</span>
<span class="s0"># special, exemplary or consequential damages (including, but not limited</span>
<span class="s0"># to, loss of use, data or profits, or business interruption) however</span>
<span class="s0"># caused and on any theory of liability, whether in contract, strict</span>
<span class="s0"># liability or tort (including negligence or otherwise) arising in any way</span>
<span class="s0"># out of the use of this software, even if advised of the possibility of</span>
<span class="s0"># such damage.</span>

<span class="s2">&quot;&quot;&quot; 
A collection of basic statistical functions for Python. 
 
References 
---------- 
.. [CRCProbStat2000] Zwillinger, D. and Kokoska, S. (2000). CRC Standard 
   Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New 
   York. 2000. 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">import </span><span class="s1">math</span>
<span class="s3">from </span><span class="s1">math </span><span class="s3">import </span><span class="s1">gcd</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">namedtuple</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">array</span><span class="s3">, </span><span class="s1">asarray</span><span class="s3">, </span><span class="s1">ma</span>
<span class="s3">from </span><span class="s1">numpy.lib </span><span class="s3">import </span><span class="s1">NumpyVersion</span>
<span class="s3">from </span><span class="s1">numpy.testing </span><span class="s3">import </span><span class="s1">suppress_warnings</span>

<span class="s3">from </span><span class="s1">scipy.spatial.distance </span><span class="s3">import </span><span class="s1">cdist</span>
<span class="s3">from </span><span class="s1">scipy.ndimage </span><span class="s3">import </span><span class="s1">_measurements</span>
<span class="s3">from </span><span class="s1">scipy._lib._util </span><span class="s3">import </span><span class="s1">(check_random_state</span><span class="s3">, </span><span class="s1">MapWrapper</span><span class="s3">, </span><span class="s1">_get_nan</span><span class="s3">,</span>
                              <span class="s1">rng_integers</span><span class="s3">, </span><span class="s1">_rename_parameter</span><span class="s3">, </span><span class="s1">_contains_nan)</span>

<span class="s3">import </span><span class="s1">scipy.special </span><span class="s3">as </span><span class="s1">special</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">linalg</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">distributions</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_mstats_basic </span><span class="s3">as </span><span class="s1">mstats_basic</span>
<span class="s3">from </span><span class="s1">._stats_mstats_common </span><span class="s3">import </span><span class="s1">(_find_repeats</span><span class="s3">, </span><span class="s1">linregress</span><span class="s3">, </span><span class="s1">theilslopes</span><span class="s3">,</span>
                                   <span class="s1">siegelslopes)</span>
<span class="s3">from </span><span class="s1">._stats </span><span class="s3">import </span><span class="s1">(_kendall_dis</span><span class="s3">, </span><span class="s1">_toint64</span><span class="s3">, </span><span class="s1">_weightedrankedtau</span><span class="s3">,</span>
                     <span class="s1">_local_correlations)</span>
<span class="s3">from </span><span class="s1">dataclasses </span><span class="s3">import </span><span class="s1">dataclass</span>
<span class="s3">from </span><span class="s1">._hypotests </span><span class="s3">import </span><span class="s1">_all_partitions</span>
<span class="s3">from </span><span class="s1">._stats_pythran </span><span class="s3">import </span><span class="s1">_compute_outer_prob_inside_method</span>
<span class="s3">from </span><span class="s1">._resampling </span><span class="s3">import </span><span class="s1">(MonteCarloMethod</span><span class="s3">, </span><span class="s1">PermutationMethod</span><span class="s3">, </span><span class="s1">BootstrapMethod</span><span class="s3">,</span>
                          <span class="s1">monte_carlo_test</span><span class="s3">, </span><span class="s1">permutation_test</span><span class="s3">, </span><span class="s1">bootstrap</span><span class="s3">,</span>
                          <span class="s1">_batch_generator)</span>
<span class="s3">from </span><span class="s1">._axis_nan_policy </span><span class="s3">import </span><span class="s1">(_axis_nan_policy_factory</span><span class="s3">,</span>
                               <span class="s1">_broadcast_concatenate)</span>
<span class="s3">from </span><span class="s1">._binomtest </span><span class="s3">import </span><span class="s1">_binary_search_for_binom_tst </span><span class="s3">as </span><span class="s1">_binary_search</span>
<span class="s3">from </span><span class="s1">scipy._lib._bunch </span><span class="s3">import </span><span class="s1">_make_tuple_bunch</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">stats</span>
<span class="s3">from </span><span class="s1">scipy.optimize </span><span class="s3">import </span><span class="s1">root_scalar</span>


<span class="s0"># Functions/classes in other files should be added in `__init__.py`, not here</span>
<span class="s1">__all__ = [</span><span class="s4">'find_repeats'</span><span class="s3">, </span><span class="s4">'gmean'</span><span class="s3">, </span><span class="s4">'hmean'</span><span class="s3">, </span><span class="s4">'pmean'</span><span class="s3">, </span><span class="s4">'mode'</span><span class="s3">, </span><span class="s4">'tmean'</span><span class="s3">, </span><span class="s4">'tvar'</span><span class="s3">,</span>
           <span class="s4">'tmin'</span><span class="s3">, </span><span class="s4">'tmax'</span><span class="s3">, </span><span class="s4">'tstd'</span><span class="s3">, </span><span class="s4">'tsem'</span><span class="s3">, </span><span class="s4">'moment'</span><span class="s3">,</span>
           <span class="s4">'skew'</span><span class="s3">, </span><span class="s4">'kurtosis'</span><span class="s3">, </span><span class="s4">'describe'</span><span class="s3">, </span><span class="s4">'skewtest'</span><span class="s3">, </span><span class="s4">'kurtosistest'</span><span class="s3">,</span>
           <span class="s4">'normaltest'</span><span class="s3">, </span><span class="s4">'jarque_bera'</span><span class="s3">,</span>
           <span class="s4">'scoreatpercentile'</span><span class="s3">, </span><span class="s4">'percentileofscore'</span><span class="s3">,</span>
           <span class="s4">'cumfreq'</span><span class="s3">, </span><span class="s4">'relfreq'</span><span class="s3">, </span><span class="s4">'obrientransform'</span><span class="s3">,</span>
           <span class="s4">'sem'</span><span class="s3">, </span><span class="s4">'zmap'</span><span class="s3">, </span><span class="s4">'zscore'</span><span class="s3">, </span><span class="s4">'gzscore'</span><span class="s3">, </span><span class="s4">'iqr'</span><span class="s3">, </span><span class="s4">'gstd'</span><span class="s3">,</span>
           <span class="s4">'median_abs_deviation'</span><span class="s3">,</span>
           <span class="s4">'sigmaclip'</span><span class="s3">, </span><span class="s4">'trimboth'</span><span class="s3">, </span><span class="s4">'trim1'</span><span class="s3">, </span><span class="s4">'trim_mean'</span><span class="s3">,</span>
           <span class="s4">'f_oneway'</span><span class="s3">, </span><span class="s4">'pearsonr'</span><span class="s3">, </span><span class="s4">'fisher_exact'</span><span class="s3">,</span>
           <span class="s4">'spearmanr'</span><span class="s3">, </span><span class="s4">'pointbiserialr'</span><span class="s3">,</span>
           <span class="s4">'kendalltau'</span><span class="s3">, </span><span class="s4">'weightedtau'</span><span class="s3">, </span><span class="s4">'multiscale_graphcorr'</span><span class="s3">,</span>
           <span class="s4">'linregress'</span><span class="s3">, </span><span class="s4">'siegelslopes'</span><span class="s3">, </span><span class="s4">'theilslopes'</span><span class="s3">, </span><span class="s4">'ttest_1samp'</span><span class="s3">,</span>
           <span class="s4">'ttest_ind'</span><span class="s3">, </span><span class="s4">'ttest_ind_from_stats'</span><span class="s3">, </span><span class="s4">'ttest_rel'</span><span class="s3">,</span>
           <span class="s4">'kstest'</span><span class="s3">, </span><span class="s4">'ks_1samp'</span><span class="s3">, </span><span class="s4">'ks_2samp'</span><span class="s3">,</span>
           <span class="s4">'chisquare'</span><span class="s3">, </span><span class="s4">'power_divergence'</span><span class="s3">,</span>
           <span class="s4">'tiecorrect'</span><span class="s3">, </span><span class="s4">'ranksums'</span><span class="s3">, </span><span class="s4">'kruskal'</span><span class="s3">, </span><span class="s4">'friedmanchisquare'</span><span class="s3">,</span>
           <span class="s4">'rankdata'</span><span class="s3">,</span>
           <span class="s4">'combine_pvalues'</span><span class="s3">, </span><span class="s4">'wasserstein_distance'</span><span class="s3">, </span><span class="s4">'energy_distance'</span><span class="s3">,</span>
           <span class="s4">'brunnermunzel'</span><span class="s3">, </span><span class="s4">'alexandergovern'</span><span class="s3">,</span>
           <span class="s4">'expectile'</span><span class="s3">, </span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">_chk_asarray(a</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">a = np.ravel(a)</span>
        <span class="s1">outaxis = </span><span class="s5">0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">a = np.asarray(a)</span>
        <span class="s1">outaxis = axis</span>

    <span class="s3">if </span><span class="s1">a.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">a = np.atleast_1d(a)</span>

    <span class="s3">return </span><span class="s1">a</span><span class="s3">, </span><span class="s1">outaxis</span>


<span class="s3">def </span><span class="s1">_chk2_asarray(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">a = np.ravel(a)</span>
        <span class="s1">b = np.ravel(b)</span>
        <span class="s1">outaxis = </span><span class="s5">0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">a = np.asarray(a)</span>
        <span class="s1">b = np.asarray(b)</span>
        <span class="s1">outaxis = axis</span>

    <span class="s3">if </span><span class="s1">a.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">a = np.atleast_1d(a)</span>
    <span class="s3">if </span><span class="s1">b.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">b = np.atleast_1d(b)</span>

    <span class="s3">return </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">outaxis</span>


<span class="s1">SignificanceResult = _make_tuple_bunch(</span><span class="s4">'SignificanceResult'</span><span class="s3">,</span>
                                       <span class="s1">[</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[])</span>


<span class="s0"># note that `weights` are paired with `x`</span>
<span class="s1">@_axis_nan_policy_factory(</span>
        <span class="s3">lambda </span><span class="s1">x: x</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">too_small=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">paired=</span><span class="s3">True,</span>
        <span class="s1">result_to_tuple=</span><span class="s3">lambda </span><span class="s1">x: (x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">kwd_samples=[</span><span class="s4">'weights'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">gmean(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Compute the weighted geometric mean along the specified axis. 
 
    The weighted geometric mean of the array :math:`a_i` associated to weights 
    :math:`w_i` is: 
 
    .. math:: 
 
        \exp \left( \frac{ \sum_{i=1}^n w_i \ln a_i }{ \sum_{i=1}^n w_i } 
                   \right) \, , 
 
    and, with equal weights, it gives: 
 
    .. math:: 
 
        \sqrt[n]{ \prod_{i=1}^n a_i } \, . 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array or object that can be converted to an array. 
    axis : int or None, optional 
        Axis along which the geometric mean is computed. Default is 0. 
        If None, compute over the whole array `a`. 
    dtype : dtype, optional 
        Type to which the input arrays are cast before the calculation is 
        performed. 
    weights : array_like, optional 
        The `weights` array must be broadcastable to the same shape as `a`. 
        Default is None, which gives each value a weight of 1.0. 
 
    Returns 
    ------- 
    gmean : ndarray 
        See `dtype` parameter above. 
 
    See Also 
    -------- 
    numpy.mean : Arithmetic average 
    numpy.average : Weighted average 
    hmean : Harmonic mean 
 
    References 
    ---------- 
    .. [1] &quot;Weighted Geometric Mean&quot;, *Wikipedia*, 
           https://en.wikipedia.org/wiki/Weighted_geometric_mean. 
    .. [2] Grossman, J., Grossman, M., Katz, R., &quot;Averages: A New Approach&quot;, 
           Archimedes Foundation, 1983 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import gmean 
    &gt;&gt;&gt; gmean([1, 4]) 
    2.0 
    &gt;&gt;&gt; gmean([1, 2, 3, 4, 5, 6, 7]) 
    3.3800151591412964 
    &gt;&gt;&gt; gmean([1, 4, 7], weights=[3, 1, 3]) 
    2.80668351922014 
 
    &quot;&quot;&quot;</span>

    <span class="s1">a = np.asarray(a</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

    <span class="s3">if </span><span class="s1">weights </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">weights = np.asarray(weights</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

    <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">log_a = np.log(a)</span>

    <span class="s3">return </span><span class="s1">np.exp(np.average(log_a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">weights=weights))</span>


<span class="s1">@_axis_nan_policy_factory(</span>
        <span class="s3">lambda </span><span class="s1">x: x</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">too_small=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">paired=</span><span class="s3">True,</span>
        <span class="s1">result_to_tuple=</span><span class="s3">lambda </span><span class="s1">x: (x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">kwd_samples=[</span><span class="s4">'weights'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">hmean(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Calculate the weighted harmonic mean along the specified axis. 
 
    The weighted harmonic mean of the array :math:`a_i` associated to weights 
    :math:`w_i` is: 
 
    .. math:: 
 
        \frac{ \sum_{i=1}^n w_i }{ \sum_{i=1}^n \frac{w_i}{a_i} } \, , 
 
    and, with equal weights, it gives: 
 
    .. math:: 
 
        \frac{ n }{ \sum_{i=1}^n \frac{1}{a_i} } \, . 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array, masked array or object that can be converted to an array. 
    axis : int or None, optional 
        Axis along which the harmonic mean is computed. Default is 0. 
        If None, compute over the whole array `a`. 
    dtype : dtype, optional 
        Type of the returned array and of the accumulator in which the 
        elements are summed. If `dtype` is not specified, it defaults to the 
        dtype of `a`, unless `a` has an integer `dtype` with a precision less 
        than that of the default platform integer. In that case, the default 
        platform integer is used. 
    weights : array_like, optional 
        The weights array can either be 1-D (in which case its length must be 
        the size of `a` along the given `axis`) or of the same shape as `a`. 
        Default is None, which gives each value a weight of 1.0. 
 
        .. versionadded:: 1.9 
 
    Returns 
    ------- 
    hmean : ndarray 
        See `dtype` parameter above. 
 
    See Also 
    -------- 
    numpy.mean : Arithmetic average 
    numpy.average : Weighted average 
    gmean : Geometric mean 
 
    Notes 
    ----- 
    The harmonic mean is computed over a single dimension of the input 
    array, axis=0 by default, or all values in the array if axis=None. 
    float64 intermediate and return values are used for integer inputs. 
 
    References 
    ---------- 
    .. [1] &quot;Weighted Harmonic Mean&quot;, *Wikipedia*, 
           https://en.wikipedia.org/wiki/Harmonic_mean#Weighted_harmonic_mean 
    .. [2] Ferger, F., &quot;The nature and use of the harmonic mean&quot;, Journal of 
           the American Statistical Association, vol. 26, pp. 36-40, 1931 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import hmean 
    &gt;&gt;&gt; hmean([1, 4]) 
    1.6000000000000001 
    &gt;&gt;&gt; hmean([1, 2, 3, 4, 5, 6, 7]) 
    2.6997245179063363 
    &gt;&gt;&gt; hmean([1, 4, 7], weights=[3, 1, 3]) 
    1.9029126213592233 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">a = np.array(a</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
    <span class="s3">elif </span><span class="s1">dtype:</span>
        <span class="s0"># Must change the default dtype allowing array type</span>
        <span class="s3">if </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">np.ma.MaskedArray):</span>
            <span class="s1">a = np.ma.asarray(a</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a = np.asarray(a</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

    <span class="s3">if </span><span class="s1">np.all(a &gt;= </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0"># Harmonic mean only defined if greater than or equal to zero.</span>
        <span class="s3">if </span><span class="s1">weights </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">weights = np.asanyarray(weights</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

        <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s5">1.0 </span><span class="s1">/ np.average(</span><span class="s5">1.0 </span><span class="s1">/ a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">weights=weights)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Harmonic mean only defined if all elements greater &quot;</span>
                         <span class="s4">&quot;than or equal to zero&quot;</span><span class="s1">)</span>


<span class="s1">@_axis_nan_policy_factory(</span>
        <span class="s3">lambda </span><span class="s1">x: x</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">too_small=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">paired=</span><span class="s3">True,</span>
        <span class="s1">result_to_tuple=</span><span class="s3">lambda </span><span class="s1">x: (x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">kwd_samples=[</span><span class="s4">'weights'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">pmean(a</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Calculate the weighted power mean along the specified axis. 
 
    The weighted power mean of the array :math:`a_i` associated to weights 
    :math:`w_i` is: 
 
    .. math:: 
 
        \left( \frac{ \sum_{i=1}^n w_i a_i^p }{ \sum_{i=1}^n w_i } 
              \right)^{ 1 / p } \, , 
 
    and, with equal weights, it gives: 
 
    .. math:: 
 
        \left( \frac{ 1 }{ n } \sum_{i=1}^n a_i^p \right)^{ 1 / p }  \, . 
 
    When ``p=0``, it returns the geometric mean. 
 
    This mean is also called generalized mean or HÃ¶lder mean, and must not be 
    confused with the Kolmogorov generalized mean, also called 
    quasi-arithmetic mean or generalized f-mean [3]_. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array, masked array or object that can be converted to an array. 
    p : int or float 
        Exponent. 
    axis : int or None, optional 
        Axis along which the power mean is computed. Default is 0. 
        If None, compute over the whole array `a`. 
    dtype : dtype, optional 
        Type of the returned array and of the accumulator in which the 
        elements are summed. If `dtype` is not specified, it defaults to the 
        dtype of `a`, unless `a` has an integer `dtype` with a precision less 
        than that of the default platform integer. In that case, the default 
        platform integer is used. 
    weights : array_like, optional 
        The weights array can either be 1-D (in which case its length must be 
        the size of `a` along the given `axis`) or of the same shape as `a`. 
        Default is None, which gives each value a weight of 1.0. 
 
    Returns 
    ------- 
    pmean : ndarray, see `dtype` parameter above. 
        Output array containing the power mean values. 
 
    See Also 
    -------- 
    numpy.average : Weighted average 
    gmean : Geometric mean 
    hmean : Harmonic mean 
 
    Notes 
    ----- 
    The power mean is computed over a single dimension of the input 
    array, ``axis=0`` by default, or all values in the array if ``axis=None``. 
    float64 intermediate and return values are used for integer inputs. 
 
    .. versionadded:: 1.9 
 
    References 
    ---------- 
    .. [1] &quot;Generalized Mean&quot;, *Wikipedia*, 
           https://en.wikipedia.org/wiki/Generalized_mean 
    .. [2] Norris, N., &quot;Convexity properties of generalized mean value 
           functions&quot;, The Annals of Mathematical Statistics, vol. 8, 
           pp. 118-120, 1937 
    .. [3] Bullen, P.S., Handbook of Means and Their Inequalities, 2003 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import pmean, hmean, gmean 
    &gt;&gt;&gt; pmean([1, 4], 1.3) 
    2.639372938300652 
    &gt;&gt;&gt; pmean([1, 2, 3, 4, 5, 6, 7], 1.3) 
    4.157111214492084 
    &gt;&gt;&gt; pmean([1, 4, 7], -2, weights=[3, 1, 3]) 
    1.4969684896631954 
 
    For p=-1, power mean is equal to harmonic mean: 
 
    &gt;&gt;&gt; pmean([1, 4, 7], -1, weights=[3, 1, 3]) 
    1.9029126213592233 
    &gt;&gt;&gt; hmean([1, 4, 7], weights=[3, 1, 3]) 
    1.9029126213592233 
 
    For p=0, power mean is defined as the geometric mean: 
 
    &gt;&gt;&gt; pmean([1, 4, 7], 0, weights=[3, 1, 3]) 
    2.80668351922014 
    &gt;&gt;&gt; gmean([1, 4, 7], weights=[3, 1, 3]) 
    2.80668351922014 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(p</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">float)):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Power mean only defined for exponent of type int or &quot;</span>
                         <span class="s4">&quot;float.&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">p == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">gmean(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">weights=weights)</span>

    <span class="s3">if not </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">a = np.array(a</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
    <span class="s3">elif </span><span class="s1">dtype:</span>
        <span class="s0"># Must change the default dtype allowing array type</span>
        <span class="s3">if </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">np.ma.MaskedArray):</span>
            <span class="s1">a = np.ma.asarray(a</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a = np.asarray(a</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

    <span class="s3">if </span><span class="s1">np.all(a &gt;= </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0"># Power mean only defined if greater than or equal to zero</span>
        <span class="s3">if </span><span class="s1">weights </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">weights = np.asanyarray(weights</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

        <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">np.float_power(</span>
                <span class="s1">np.average(np.float_power(a</span><span class="s3">, </span><span class="s1">p)</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">weights=weights)</span><span class="s3">,</span>
                <span class="s5">1</span><span class="s1">/p)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Power mean only defined if all elements greater &quot;</span>
                         <span class="s4">&quot;than or equal to zero&quot;</span><span class="s1">)</span>


<span class="s1">ModeResult = namedtuple(</span><span class="s4">'ModeResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'mode'</span><span class="s3">, </span><span class="s4">'count'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">_mode_result(mode</span><span class="s3">, </span><span class="s1">count):</span>
    <span class="s0"># When a slice is empty, `_axis_nan_policy` automatically produces</span>
    <span class="s0"># NaN for `mode` and `count`. This is a reasonable convention for `mode`,</span>
    <span class="s0"># but `count` should not be NaN; it should be zero.</span>
    <span class="s1">i = np.isnan(count)</span>
    <span class="s3">if </span><span class="s1">i.shape == ():</span>
        <span class="s1">count = count.dtype(</span><span class="s5">0</span><span class="s1">) </span><span class="s3">if </span><span class="s1">i </span><span class="s3">else </span><span class="s1">count</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">count[i] = </span><span class="s5">0</span>
    <span class="s3">return </span><span class="s1">ModeResult(mode</span><span class="s3">, </span><span class="s1">count)</span>


<span class="s1">@_axis_nan_policy_factory(_mode_result</span><span class="s3">, </span><span class="s1">override={</span><span class="s4">'vectorization'</span><span class="s1">: </span><span class="s3">True,</span>
                                                  <span class="s4">'nan_propagation'</span><span class="s1">: </span><span class="s3">False</span><span class="s1">})</span>
<span class="s3">def </span><span class="s1">mode(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s4">r&quot;&quot;&quot;Return an array of the modal (most common) value in the passed array. 
 
    If there is more than one such value, only one is returned. 
    The bin-count for the modal bins is also returned. 
 
    Parameters 
    ---------- 
    a : array_like 
        Numeric, n-dimensional array of which to find mode(s). 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over 
        the whole array `a`. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': treats nan as it would treat any other value 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
    keepdims : bool, optional 
        If set to ``False``, the `axis` over which the statistic is taken 
        is consumed (eliminated from the output array). If set to ``True``, 
        the `axis` is retained with size one, and the result will broadcast 
        correctly against the input array. 
 
    Returns 
    ------- 
    mode : ndarray 
        Array of modal values. 
    count : ndarray 
        Array of counts for each mode. 
 
    Notes 
    ----- 
    The mode  is calculated using `numpy.unique`. 
    In NumPy versions 1.21 and after, all NaNs - even those with different 
    binary representations - are treated as equivalent and counted as separate 
    instances of the same value. 
 
    By convention, the mode of an empty array is NaN, and the associated count 
    is zero. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[3, 0, 3, 7], 
    ...               [3, 2, 6, 2], 
    ...               [1, 7, 2, 8], 
    ...               [3, 0, 6, 1], 
    ...               [3, 2, 5, 5]]) 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; stats.mode(a, keepdims=True) 
    ModeResult(mode=array([[3, 0, 6, 1]]), count=array([[4, 2, 2, 1]])) 
 
    To get mode of whole array, specify ``axis=None``: 
 
    &gt;&gt;&gt; stats.mode(a, axis=None, keepdims=True) 
    ModeResult(mode=[[3]], count=[[5]]) 
    &gt;&gt;&gt; stats.mode(a, axis=None, keepdims=False) 
    ModeResult(mode=3, count=5) 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>
    <span class="s0"># `axis`, `nan_policy`, and `keepdims` are handled by `_axis_nan_policy`</span>
    <span class="s3">if not </span><span class="s1">np.issubdtype(a.dtype</span><span class="s3">, </span><span class="s1">np.number):</span>
        <span class="s1">message = (</span><span class="s4">&quot;Argument `a` is not recognized as numeric. &quot;</span>
                   <span class="s4">&quot;Support for input that cannot be coerced to a numeric &quot;</span>
                   <span class="s4">&quot;array was deprecated in SciPy 1.9.0 and removed in SciPy &quot;</span>
                   <span class="s4">&quot;1.11.0. Please consider `np.unique`.&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">TypeError(message)</span>

    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">NaN = _get_nan(a)</span>
        <span class="s3">return </span><span class="s1">ModeResult(*np.array([NaN</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=NaN.dtype))</span>

    <span class="s1">vals</span><span class="s3">, </span><span class="s1">cnts = np.unique(a</span><span class="s3">, </span><span class="s1">return_counts=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">modes</span><span class="s3">, </span><span class="s1">counts = vals[cnts.argmax()]</span><span class="s3">, </span><span class="s1">cnts.max()</span>
    <span class="s3">return </span><span class="s1">ModeResult(modes[()]</span><span class="s3">, </span><span class="s1">counts[()])</span>


<span class="s3">def </span><span class="s1">_mask_to_limits(a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive):</span>
    <span class="s2">&quot;&quot;&quot;Mask an array for values outside of given limits. 
 
    This is primarily a utility function. 
 
    Parameters 
    ---------- 
    a : array 
    limits : (float or None, float or None) 
        A tuple consisting of the (lower limit, upper limit).  Values in the 
        input array less than the lower limit or greater than the upper limit 
        will be masked out. None implies no limit. 
    inclusive : (bool, bool) 
        A tuple consisting of the (lower flag, upper flag).  These flags 
        determine whether values exactly equal to lower or upper are allowed. 
 
    Returns 
    ------- 
    A MaskedArray. 
 
    Raises 
    ------ 
    A ValueError if there are no values within the given limits. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">lower_limit</span><span class="s3">, </span><span class="s1">upper_limit = limits</span>
    <span class="s1">lower_include</span><span class="s3">, </span><span class="s1">upper_include = inclusive</span>
    <span class="s1">am = ma.MaskedArray(a)</span>
    <span class="s3">if </span><span class="s1">lower_limit </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">lower_include:</span>
            <span class="s1">am = ma.masked_less(am</span><span class="s3">, </span><span class="s1">lower_limit)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">am = ma.masked_less_equal(am</span><span class="s3">, </span><span class="s1">lower_limit)</span>

    <span class="s3">if </span><span class="s1">upper_limit </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">upper_include:</span>
            <span class="s1">am = ma.masked_greater(am</span><span class="s3">, </span><span class="s1">upper_limit)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">am = ma.masked_greater_equal(am</span><span class="s3">, </span><span class="s1">upper_limit)</span>

    <span class="s3">if </span><span class="s1">am.count() == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No array values within given limits&quot;</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">am</span>


<span class="s3">def </span><span class="s1">tmean(a</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">inclusive=(</span><span class="s3">True, True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the trimmed mean. 
 
    This function finds the arithmetic mean of given values, ignoring values 
    outside the given `limits`. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of values. 
    limits : None or (lower limit, upper limit), optional 
        Values in the input array less than the lower limit or greater than the 
        upper limit will be ignored.  When limits is None (default), then all 
        values are used.  Either of the limit values in the tuple can also be 
        None representing a half-open interval. 
    inclusive : (bool, bool), optional 
        A tuple consisting of the (lower flag, upper flag).  These flags 
        determine whether values exactly equal to the lower or upper limits 
        are included.  The default value is (True, True). 
    axis : int or None, optional 
        Axis along which to compute test. Default is None. 
 
    Returns 
    ------- 
    tmean : ndarray 
        Trimmed mean. 
 
    See Also 
    -------- 
    trim_mean : Returns mean after trimming a proportion from both tails. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = np.arange(20) 
    &gt;&gt;&gt; stats.tmean(x) 
    9.5 
    &gt;&gt;&gt; stats.tmean(x, (3,17)) 
    10.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s3">if </span><span class="s1">limits </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.mean(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">am = _mask_to_limits(a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive)</span>
    <span class="s1">mean = np.ma.filled(am.mean(axis=axis)</span><span class="s3">, </span><span class="s1">fill_value=np.nan)</span>
    <span class="s3">return </span><span class="s1">mean </span><span class="s3">if </span><span class="s1">mean.ndim &gt; </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">mean.item()</span>


<span class="s3">def </span><span class="s1">tvar(a</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">inclusive=(</span><span class="s3">True, True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the trimmed variance. 
 
    This function computes the sample variance of an array of values, 
    while ignoring values which are outside of given `limits`. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of values. 
    limits : None or (lower limit, upper limit), optional 
        Values in the input array less than the lower limit or greater than the 
        upper limit will be ignored. When limits is None, then all values are 
        used. Either of the limit values in the tuple can also be None 
        representing a half-open interval.  The default value is None. 
    inclusive : (bool, bool), optional 
        A tuple consisting of the (lower flag, upper flag).  These flags 
        determine whether values exactly equal to the lower or upper limits 
        are included.  The default value is (True, True). 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over the 
        whole array `a`. 
    ddof : int, optional 
        Delta degrees of freedom.  Default is 1. 
 
    Returns 
    ------- 
    tvar : float 
        Trimmed variance. 
 
    Notes 
    ----- 
    `tvar` computes the unbiased sample variance, i.e. it uses a correction 
    factor ``n / (n - 1)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = np.arange(20) 
    &gt;&gt;&gt; stats.tvar(x) 
    35.0 
    &gt;&gt;&gt; stats.tvar(x, (3,17)) 
    20.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s1">a = a.astype(float)</span>
    <span class="s3">if </span><span class="s1">limits </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">a.var(ddof=ddof</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">am = _mask_to_limits(a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive)</span>
    <span class="s1">amnan = am.filled(fill_value=np.nan)</span>
    <span class="s3">return </span><span class="s1">np.nanvar(amnan</span><span class="s3">, </span><span class="s1">ddof=ddof</span><span class="s3">, </span><span class="s1">axis=axis)</span>


<span class="s3">def </span><span class="s1">tmin(a</span><span class="s3">, </span><span class="s1">lowerlimit=</span><span class="s3">None, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">inclusive=</span><span class="s3">True, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the trimmed minimum. 
 
    This function finds the miminum value of an array `a` along the 
    specified axis, but only considering values greater than a specified 
    lower limit. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of values. 
    lowerlimit : None or float, optional 
        Values in the input array less than the given limit will be ignored. 
        When lowerlimit is None, then all values are used. The default value 
        is None. 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over the 
        whole array `a`. 
    inclusive : {True, False}, optional 
        This flag determines whether values exactly equal to the lower limit 
        are included.  The default value is True. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    tmin : float, int or ndarray 
        Trimmed minimum. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = np.arange(20) 
    &gt;&gt;&gt; stats.tmin(x) 
    0 
 
    &gt;&gt;&gt; stats.tmin(x, 13) 
    13 
 
    &gt;&gt;&gt; stats.tmin(x, 13, inclusive=False) 
    14 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">am = _mask_to_limits(a</span><span class="s3">, </span><span class="s1">(lowerlimit</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(inclusive</span><span class="s3">, False</span><span class="s1">))</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(am</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">am = ma.masked_invalid(am)</span>

    <span class="s1">res = ma.minimum.reduce(am</span><span class="s3">, </span><span class="s1">axis).data</span>
    <span class="s3">if </span><span class="s1">res.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">res[()]</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">tmax(a</span><span class="s3">, </span><span class="s1">upperlimit=</span><span class="s3">None, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">inclusive=</span><span class="s3">True, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the trimmed maximum. 
 
    This function computes the maximum value of an array along a given axis, 
    while ignoring values larger than a specified upper limit. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of values. 
    upperlimit : None or float, optional 
        Values in the input array greater than the given limit will be ignored. 
        When upperlimit is None, then all values are used. The default value 
        is None. 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over the 
        whole array `a`. 
    inclusive : {True, False}, optional 
        This flag determines whether values exactly equal to the upper limit 
        are included.  The default value is True. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    tmax : float, int or ndarray 
        Trimmed maximum. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = np.arange(20) 
    &gt;&gt;&gt; stats.tmax(x) 
    19 
 
    &gt;&gt;&gt; stats.tmax(x, 13) 
    13 
 
    &gt;&gt;&gt; stats.tmax(x, 13, inclusive=False) 
    12 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">am = _mask_to_limits(a</span><span class="s3">, </span><span class="s1">(</span><span class="s3">None, </span><span class="s1">upperlimit)</span><span class="s3">, </span><span class="s1">(</span><span class="s3">False, </span><span class="s1">inclusive))</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(am</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">am = ma.masked_invalid(am)</span>

    <span class="s1">res = ma.maximum.reduce(am</span><span class="s3">, </span><span class="s1">axis).data</span>
    <span class="s3">if </span><span class="s1">res.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">res[()]</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">tstd(a</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">inclusive=(</span><span class="s3">True, True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the trimmed sample standard deviation. 
 
    This function finds the sample standard deviation of given values, 
    ignoring values outside the given `limits`. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of values. 
    limits : None or (lower limit, upper limit), optional 
        Values in the input array less than the lower limit or greater than the 
        upper limit will be ignored. When limits is None, then all values are 
        used. Either of the limit values in the tuple can also be None 
        representing a half-open interval.  The default value is None. 
    inclusive : (bool, bool), optional 
        A tuple consisting of the (lower flag, upper flag).  These flags 
        determine whether values exactly equal to the lower or upper limits 
        are included.  The default value is (True, True). 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over the 
        whole array `a`. 
    ddof : int, optional 
        Delta degrees of freedom.  Default is 1. 
 
    Returns 
    ------- 
    tstd : float 
        Trimmed sample standard deviation. 
 
    Notes 
    ----- 
    `tstd` computes the unbiased sample standard deviation, i.e. it uses a 
    correction factor ``n / (n - 1)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = np.arange(20) 
    &gt;&gt;&gt; stats.tstd(x) 
    5.9160797830996161 
    &gt;&gt;&gt; stats.tstd(x, (3,17)) 
    4.4721359549995796 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">np.sqrt(tvar(a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof))</span>


<span class="s3">def </span><span class="s1">tsem(a</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None, </span><span class="s1">inclusive=(</span><span class="s3">True, True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the trimmed standard error of the mean. 
 
    This function finds the standard error of the mean for given 
    values, ignoring values outside the given `limits`. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of values. 
    limits : None or (lower limit, upper limit), optional 
        Values in the input array less than the lower limit or greater than the 
        upper limit will be ignored. When limits is None, then all values are 
        used. Either of the limit values in the tuple can also be None 
        representing a half-open interval.  The default value is None. 
    inclusive : (bool, bool), optional 
        A tuple consisting of the (lower flag, upper flag).  These flags 
        determine whether values exactly equal to the lower or upper limits 
        are included.  The default value is (True, True). 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over the 
        whole array `a`. 
    ddof : int, optional 
        Delta degrees of freedom.  Default is 1. 
 
    Returns 
    ------- 
    tsem : float 
        Trimmed standard error of the mean. 
 
    Notes 
    ----- 
    `tsem` uses unbiased sample standard deviation, i.e. it uses a 
    correction factor ``n / (n - 1)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = np.arange(20) 
    &gt;&gt;&gt; stats.tsem(x) 
    1.3228756555322954 
    &gt;&gt;&gt; stats.tsem(x, (3,17)) 
    1.1547005383792515 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asarray(a).ravel()</span>
    <span class="s3">if </span><span class="s1">limits </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">a.std(ddof=ddof) / np.sqrt(a.size)</span>

    <span class="s1">am = _mask_to_limits(a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive)</span>
    <span class="s1">sd = np.sqrt(np.ma.var(am</span><span class="s3">, </span><span class="s1">ddof=ddof</span><span class="s3">, </span><span class="s1">axis=axis))</span>
    <span class="s3">return </span><span class="s1">sd / np.sqrt(am.count())</span>


<span class="s0">#####################################</span>
<span class="s0">#              MOMENTS              #</span>
<span class="s0">#####################################</span>


<span class="s3">def </span><span class="s1">_moment_outputs(kwds):</span>
    <span class="s1">moment = np.atleast_1d(kwds.get(</span><span class="s4">'moment'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s3">if </span><span class="s1">moment.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'moment' must be a scalar or a non-empty 1D &quot;</span>
                         <span class="s4">&quot;list/array.&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">len(moment)</span>


<span class="s3">def </span><span class="s1">_moment_result_object(*args):</span>
    <span class="s3">if </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">np.asarray(args)</span>

<span class="s0"># `moment` fits into the `_axis_nan_policy` pattern, but it is a bit unusual</span>
<span class="s0"># because the number of outputs is variable. Specifically,</span>
<span class="s0"># `result_to_tuple=lambda x: (x,)` may be surprising for a function that</span>
<span class="s0"># can produce more than one output, but it is intended here.</span>
<span class="s0"># When `moment is called to produce the output:</span>
<span class="s0"># - `result_to_tuple` packs the returned array into a single-element tuple,</span>
<span class="s0"># - `_moment_result_object` extracts and returns that single element.</span>
<span class="s0"># However, when the input array is empty, `moment` is never called. Instead,</span>
<span class="s0"># - `_check_empty_inputs` is used to produce an empty array with the</span>
<span class="s0">#   appropriate dimensions.</span>
<span class="s0"># - A list comprehension creates the appropriate number of copies of this</span>
<span class="s0">#   array, depending on `n_outputs`.</span>
<span class="s0"># - This list - which may have multiple elements - is passed into</span>
<span class="s0">#   `_moment_result_object`.</span>
<span class="s0"># - If there is a single output, `_moment_result_object` extracts and returns</span>
<span class="s0">#   the single output from the list.</span>
<span class="s0"># - If there are multiple outputs, and therefore multiple elements in the list,</span>
<span class="s0">#   `_moment_result_object` converts the list of arrays to a single array and</span>
<span class="s0">#   returns it.</span>
<span class="s0"># Currently this leads to a slight inconsistency: when the input array is</span>
<span class="s0"># empty, there is no distinction between the `moment` function being called</span>
<span class="s0"># with parameter `moments=1` and `moments=[1]`; the latter *should* produce</span>
<span class="s0"># the same as the former but with a singleton zeroth dimension.</span>
<span class="s1">@_axis_nan_policy_factory(  </span><span class="s0"># noqa: E302</span>
    <span class="s1">_moment_result_object</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">result_to_tuple=</span><span class="s3">lambda </span><span class="s1">x: (x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">n_outputs=_moment_outputs</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">moment(a</span><span class="s3">, </span><span class="s1">moment=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">center=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Calculate the nth moment about the mean for a sample. 
 
    A moment is a specific quantitative measure of the shape of a set of 
    points. It is often used to calculate coefficients of skewness and kurtosis 
    due to its close relationship with them. 
 
    Parameters 
    ---------- 
    a : array_like 
       Input array. 
    moment : int or array_like of ints, optional 
       Order of central moment that is returned. Default is 1. 
    axis : int or None, optional 
       Axis along which the central moment is computed. Default is 0. 
       If None, compute over the whole array `a`. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    center : float or None, optional 
       The point about which moments are taken. This can be the sample mean, 
       the origin, or any other be point. If `None` (default) compute the 
       center as the sample mean. 
 
    Returns 
    ------- 
    n-th moment about the `center` : ndarray or float 
       The appropriate moment along the given axis or over all values if axis 
       is None. The denominator for the moment calculation is the number of 
       observations, no degrees of freedom correction is done. 
 
    See Also 
    -------- 
    kurtosis, skew, describe 
 
    Notes 
    ----- 
    The k-th moment of a data sample is: 
 
    .. math:: 
 
        m_k = \frac{1}{n} \sum_{i = 1}^n (x_i - c)^k 
 
    Where `n` is the number of samples, and `c` is the center around which the 
    moment is calculated. This function uses exponentiation by squares [1]_ for 
    efficiency. 
 
    Note that, if `a` is an empty array (``a.size == 0``), array `moment` with 
    one element (`moment.size == 1`) is treated the same as scalar `moment` 
    (``np.isscalar(moment)``). This might produce arrays of unexpected shape. 
 
    References 
    ---------- 
    .. [1] https://eli.thegreenplace.net/2009/03/21/efficient-integer-exponentiation-algorithms 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import moment 
    &gt;&gt;&gt; moment([1, 2, 3, 4, 5], moment=1) 
    0.0 
    &gt;&gt;&gt; moment([1, 2, 3, 4, 5], moment=2) 
    2.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s0"># for array_like moment input, return a value for each.</span>
    <span class="s3">if not </span><span class="s1">np.isscalar(moment):</span>
        <span class="s0"># Calculated the mean once at most, and only if it will be used</span>
        <span class="s1">calculate_mean = center </span><span class="s3">is None and </span><span class="s1">np.any(np.asarray(moment) &gt; </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">mean = a.mean(axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">if </span><span class="s1">calculate_mean </span><span class="s3">else None</span>
        <span class="s1">mmnt = []</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">moment:</span>
            <span class="s3">if </span><span class="s1">center </span><span class="s3">is None and </span><span class="s1">i &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">mmnt.append(_moment(a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean=mean))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">mmnt.append(_moment(a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean=center))</span>
        <span class="s3">return </span><span class="s1">np.array(mmnt)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_moment(a</span><span class="s3">, </span><span class="s1">moment</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean=center)</span>


<span class="s0"># Moment with optional pre-computed mean, equal to a.mean(axis, keepdims=True)</span>
<span class="s3">def </span><span class="s1">_moment(a</span><span class="s3">, </span><span class="s1">moment</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">mean=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">np.abs(moment - np.round(moment)) &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;All moment parameters must be integers&quot;</span><span class="s1">)</span>

    <span class="s0"># moment of empty array is the same regardless of order</span>
    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.mean(a</span><span class="s3">, </span><span class="s1">axis=axis)</span>

    <span class="s1">dtype = a.dtype.type </span><span class="s3">if </span><span class="s1">a.dtype.kind </span><span class="s3">in </span><span class="s4">'fc' </span><span class="s3">else </span><span class="s1">np.float64</span>

    <span class="s3">if </span><span class="s1">moment == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">(moment == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">mean </span><span class="s3">is None</span><span class="s1">):</span>
        <span class="s0"># By definition the zeroth moment is always 1, and the first *central*</span>
        <span class="s0"># moment is 0.</span>
        <span class="s1">shape = list(a.shape)</span>
        <span class="s3">del </span><span class="s1">shape[axis]</span>

        <span class="s3">if </span><span class="s1">len(shape) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">dtype(</span><span class="s5">1.0 </span><span class="s3">if </span><span class="s1">moment == </span><span class="s5">0 </span><span class="s3">else </span><span class="s5">0.0</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(np.ones(shape</span><span class="s3">, </span><span class="s1">dtype=dtype) </span><span class="s3">if </span><span class="s1">moment == </span><span class="s5">0</span>
                    <span class="s3">else </span><span class="s1">np.zeros(shape</span><span class="s3">, </span><span class="s1">dtype=dtype))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># Exponentiation by squares: form exponent sequence</span>
        <span class="s1">n_list = [moment]</span>
        <span class="s1">current_n = moment</span>
        <span class="s3">while </span><span class="s1">current_n &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">current_n % </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">current_n = (current_n - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">current_n /= </span><span class="s5">2</span>
            <span class="s1">n_list.append(current_n)</span>

        <span class="s0"># Starting point for exponentiation by squares</span>
        <span class="s1">mean = (a.mean(axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">if </span><span class="s1">mean </span><span class="s3">is None</span>
                <span class="s3">else </span><span class="s1">np.asarray(mean</span><span class="s3">, </span><span class="s1">dtype=dtype)[()])</span>
        <span class="s1">a_zero_mean = a - mean</span>

        <span class="s1">eps = np.finfo(a_zero_mean.dtype).resolution * </span><span class="s5">10</span>
        <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">rel_diff = np.max(np.abs(a_zero_mean)</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">,</span>
                              <span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">) / np.abs(mean)</span>
        <span class="s3">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">precision_loss = np.any(rel_diff &lt; eps)</span>
        <span class="s1">n = a.shape[axis] </span><span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None else </span><span class="s1">a.size</span>
        <span class="s3">if </span><span class="s1">precision_loss </span><span class="s3">and </span><span class="s1">n &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">message = (</span><span class="s4">&quot;Precision loss occurred in moment calculation due to &quot;</span>
                       <span class="s4">&quot;catastrophic cancellation. This occurs when the data &quot;</span>
                       <span class="s4">&quot;are nearly identical. Results may be unreliable.&quot;</span><span class="s1">)</span>
            <span class="s1">warnings.warn(message</span><span class="s3">, </span><span class="s1">RuntimeWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">4</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">n_list[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">s = a_zero_mean.copy()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">s = a_zero_mean**</span><span class="s5">2</span>

        <span class="s0"># Perform multiplications</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">n_list[-</span><span class="s5">2</span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">s = s**</span><span class="s5">2</span>
            <span class="s3">if </span><span class="s1">n % </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">s *= a_zero_mean</span>
        <span class="s3">return </span><span class="s1">np.mean(s</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s3">def </span><span class="s1">_var(x</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">mean=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0"># Calculate variance of sample, warning if precision is lost</span>
    <span class="s1">var = _moment(x</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean=mean)</span>
    <span class="s3">if </span><span class="s1">ddof != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">n = x.shape[axis] </span><span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None else </span><span class="s1">x.size</span>
        <span class="s1">var *= np.divide(n</span><span class="s3">, </span><span class="s1">n-ddof)  </span><span class="s0"># to avoid error on division by zero</span>
    <span class="s3">return </span><span class="s1">var</span>


<span class="s1">@_axis_nan_policy_factory(</span>
    <span class="s3">lambda </span><span class="s1">x: x</span><span class="s3">, </span><span class="s1">result_to_tuple=</span><span class="s3">lambda </span><span class="s1">x: (x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">1</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">skew(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">bias=</span><span class="s3">True, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Compute the sample skewness of a data set. 
 
    For normally distributed data, the skewness should be about zero. For 
    unimodal continuous distributions, a skewness value greater than zero means 
    that there is more weight in the right tail of the distribution. The 
    function `skewtest` can be used to determine if the skewness value 
    is close enough to zero, statistically speaking. 
 
    Parameters 
    ---------- 
    a : ndarray 
        Input array. 
    axis : int or None, optional 
        Axis along which skewness is calculated. Default is 0. 
        If None, compute over the whole array `a`. 
    bias : bool, optional 
        If False, then the calculations are corrected for statistical bias. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    skewness : ndarray 
        The skewness of values along an axis, returning NaN where all values 
        are equal. 
 
    Notes 
    ----- 
    The sample skewness is computed as the Fisher-Pearson coefficient 
    of skewness, i.e. 
 
    .. math:: 
 
        g_1=\frac{m_3}{m_2^{3/2}} 
 
    where 
 
    .. math:: 
 
        m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i 
 
    is the biased sample :math:`i\texttt{th}` central moment, and 
    :math:`\bar{x}` is 
    the sample mean.  If ``bias`` is False, the calculations are 
    corrected for bias and the value computed is the adjusted 
    Fisher-Pearson standardized moment coefficient, i.e. 
 
    .. math:: 
 
        G_1=\frac{k_3}{k_2^{3/2}}= 
            \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}. 
 
    References 
    ---------- 
    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard 
       Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New 
       York. 2000. 
       Section 2.2.24.1 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import skew 
    &gt;&gt;&gt; skew([1, 2, 3, 4, 5]) 
    0.0 
    &gt;&gt;&gt; skew([2, 8, 0, 4, 1, 9, 9, 0]) 
    0.2650554122698573 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">n = a.shape[axis]</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">a = ma.masked_invalid(a)</span>
        <span class="s3">return </span><span class="s1">mstats_basic.skew(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">bias)</span>

    <span class="s1">mean = a.mean(axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">m2 = _moment(a</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean=mean)</span>
    <span class="s1">m3 = _moment(a</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean=mean)</span>
    <span class="s3">with </span><span class="s1">np.errstate(all=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">zero = (m2 &lt;= (np.finfo(m2.dtype).resolution * mean.squeeze(axis))**</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">vals = np.where(zero</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">m3 / m2**</span><span class="s5">1.5</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">bias:</span>
        <span class="s1">can_correct = ~zero &amp; (n &gt; </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">can_correct.any():</span>
            <span class="s1">m2 = np.extract(can_correct</span><span class="s3">, </span><span class="s1">m2)</span>
            <span class="s1">m3 = np.extract(can_correct</span><span class="s3">, </span><span class="s1">m3)</span>
            <span class="s1">nval = np.sqrt((n - </span><span class="s5">1.0</span><span class="s1">) * n) / (n - </span><span class="s5">2.0</span><span class="s1">) * m3 / m2**</span><span class="s5">1.5</span>
            <span class="s1">np.place(vals</span><span class="s3">, </span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">nval)</span>

    <span class="s3">return </span><span class="s1">vals[()]</span>


<span class="s1">@_axis_nan_policy_factory(</span>
    <span class="s3">lambda </span><span class="s1">x: x</span><span class="s3">, </span><span class="s1">result_to_tuple=</span><span class="s3">lambda </span><span class="s1">x: (x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">1</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">kurtosis(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">fisher=</span><span class="s3">True, </span><span class="s1">bias=</span><span class="s3">True, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset. 
 
    Kurtosis is the fourth central moment divided by the square of the 
    variance. If Fisher's definition is used, then 3.0 is subtracted from 
    the result to give 0.0 for a normal distribution. 
 
    If bias is False then the kurtosis is calculated using k statistics to 
    eliminate bias coming from biased moment estimators 
 
    Use `kurtosistest` to see if result is close enough to normal. 
 
    Parameters 
    ---------- 
    a : array 
        Data for which the kurtosis is calculated. 
    axis : int or None, optional 
        Axis along which the kurtosis is calculated. Default is 0. 
        If None, compute over the whole array `a`. 
    fisher : bool, optional 
        If True, Fisher's definition is used (normal ==&gt; 0.0). If False, 
        Pearson's definition is used (normal ==&gt; 3.0). 
    bias : bool, optional 
        If False, then the calculations are corrected for statistical bias. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 'propagate' returns nan, 
        'raise' throws an error, 'omit' performs the calculations ignoring nan 
        values. Default is 'propagate'. 
 
    Returns 
    ------- 
    kurtosis : array 
        The kurtosis of values along an axis, returning NaN where all values 
        are equal. 
 
    References 
    ---------- 
    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard 
       Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New 
       York. 2000. 
 
    Examples 
    -------- 
    In Fisher's definition, the kurtosis of the normal distribution is zero. 
    In the following example, the kurtosis is close to zero, because it was 
    calculated from the dataset, not from the continuous distribution. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import norm, kurtosis 
    &gt;&gt;&gt; data = norm.rvs(size=1000, random_state=3) 
    &gt;&gt;&gt; kurtosis(data) 
    -0.06928694200380558 
 
    The distribution with a higher kurtosis has a heavier tail. 
    The zero valued kurtosis of the normal distribution in Fisher's definition 
    can serve as a reference point. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import scipy.stats as stats 
    &gt;&gt;&gt; from scipy.stats import kurtosis 
 
    &gt;&gt;&gt; x = np.linspace(-5, 5, 100) 
    &gt;&gt;&gt; ax = plt.subplot() 
    &gt;&gt;&gt; distnames = ['laplace', 'norm', 'uniform'] 
 
    &gt;&gt;&gt; for distname in distnames: 
    ...     if distname == 'uniform': 
    ...         dist = getattr(stats, distname)(loc=-2, scale=4) 
    ...     else: 
    ...         dist = getattr(stats, distname) 
    ...     data = dist.rvs(size=1000) 
    ...     kur = kurtosis(data, fisher=True) 
    ...     y = dist.pdf(x) 
    ...     ax.plot(x, y, label=&quot;{}, {}&quot;.format(distname, round(kur, 3))) 
    ...     ax.legend() 
 
    The Laplace distribution has a heavier tail than the normal distribution. 
    The uniform distribution (which has negative kurtosis) has the thinnest 
    tail. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">a = ma.masked_invalid(a)</span>
        <span class="s3">return </span><span class="s1">mstats_basic.kurtosis(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">fisher</span><span class="s3">, </span><span class="s1">bias)</span>

    <span class="s1">n = a.shape[axis]</span>
    <span class="s1">mean = a.mean(axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">m2 = _moment(a</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean=mean)</span>
    <span class="s1">m4 = _moment(a</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean=mean)</span>
    <span class="s3">with </span><span class="s1">np.errstate(all=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">zero = (m2 &lt;= (np.finfo(m2.dtype).resolution * mean.squeeze(axis))**</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">vals = np.where(zero</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">m4 / m2**</span><span class="s5">2.0</span><span class="s1">)</span>

    <span class="s3">if not </span><span class="s1">bias:</span>
        <span class="s1">can_correct = ~zero &amp; (n &gt; </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">can_correct.any():</span>
            <span class="s1">m2 = np.extract(can_correct</span><span class="s3">, </span><span class="s1">m2)</span>
            <span class="s1">m4 = np.extract(can_correct</span><span class="s3">, </span><span class="s1">m4)</span>
            <span class="s1">nval = </span><span class="s5">1.0</span><span class="s1">/(n-</span><span class="s5">2</span><span class="s1">)/(n-</span><span class="s5">3</span><span class="s1">) * ((n**</span><span class="s5">2</span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">)*m4/m2**</span><span class="s5">2.0 </span><span class="s1">- </span><span class="s5">3</span><span class="s1">*(n-</span><span class="s5">1</span><span class="s1">)**</span><span class="s5">2.0</span><span class="s1">)</span>
            <span class="s1">np.place(vals</span><span class="s3">, </span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">nval + </span><span class="s5">3.0</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">vals[()] - </span><span class="s5">3 </span><span class="s3">if </span><span class="s1">fisher </span><span class="s3">else </span><span class="s1">vals[()]</span>


<span class="s1">DescribeResult = namedtuple(</span><span class="s4">'DescribeResult'</span><span class="s3">,</span>
                            <span class="s1">(</span><span class="s4">'nobs'</span><span class="s3">, </span><span class="s4">'minmax'</span><span class="s3">, </span><span class="s4">'mean'</span><span class="s3">, </span><span class="s4">'variance'</span><span class="s3">, </span><span class="s4">'skewness'</span><span class="s3">,</span>
                             <span class="s4">'kurtosis'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">describe(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">bias=</span><span class="s3">True, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute several descriptive statistics of the passed array. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input data. 
    axis : int or None, optional 
        Axis along which statistics are calculated. Default is 0. 
        If None, compute over the whole array `a`. 
    ddof : int, optional 
        Delta degrees of freedom (only for variance).  Default is 1. 
    bias : bool, optional 
        If False, then the skewness and kurtosis calculations are corrected 
        for statistical bias. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
        * 'propagate': returns nan 
        * 'raise': throws an error 
        * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    nobs : int or ndarray of ints 
        Number of observations (length of data along `axis`). 
        When 'omit' is chosen as nan_policy, the length along each axis 
        slice is counted separately. 
    minmax: tuple of ndarrays or floats 
        Minimum and maximum value of `a` along the given axis. 
    mean : ndarray or float 
        Arithmetic mean of `a` along the given axis. 
    variance : ndarray or float 
        Unbiased variance of `a` along the given axis; denominator is number 
        of observations minus one. 
    skewness : ndarray or float 
        Skewness of `a` along the given axis, based on moment calculations 
        with denominator equal to the number of observations, i.e. no degrees 
        of freedom correction. 
    kurtosis : ndarray or float 
        Kurtosis (Fisher) of `a` along the given axis.  The kurtosis is 
        normalized so that it is zero for the normal distribution.  No 
        degrees of freedom are used. 
 
    See Also 
    -------- 
    skew, kurtosis 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; a = np.arange(10) 
    &gt;&gt;&gt; stats.describe(a) 
    DescribeResult(nobs=10, minmax=(0, 9), mean=4.5, 
                   variance=9.166666666666666, skewness=0.0, 
                   kurtosis=-1.2242424242424244) 
    &gt;&gt;&gt; b = [[1, 2], [3, 4]] 
    &gt;&gt;&gt; stats.describe(b) 
    DescribeResult(nobs=2, minmax=(array([1, 2]), array([3, 4])), 
                   mean=array([2., 3.]), variance=array([2., 2.]), 
                   skewness=array([0., 0.]), kurtosis=array([-2., -2.])) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">a = ma.masked_invalid(a)</span>
        <span class="s3">return </span><span class="s1">mstats_basic.describe(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">, </span><span class="s1">bias)</span>

    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The input must not be empty.&quot;</span><span class="s1">)</span>
    <span class="s1">n = a.shape[axis]</span>
    <span class="s1">mm = (np.min(a</span><span class="s3">, </span><span class="s1">axis=axis)</span><span class="s3">, </span><span class="s1">np.max(a</span><span class="s3">, </span><span class="s1">axis=axis))</span>
    <span class="s1">m = np.mean(a</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">v = _var(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">ddof=ddof)</span>
    <span class="s1">sk = skew(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">bias=bias)</span>
    <span class="s1">kurt = kurtosis(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">bias=bias)</span>

    <span class="s3">return </span><span class="s1">DescribeResult(n</span><span class="s3">, </span><span class="s1">mm</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">sk</span><span class="s3">, </span><span class="s1">kurt)</span>

<span class="s0">#####################################</span>
<span class="s0">#         NORMALITY TESTS           #</span>
<span class="s0">#####################################</span>


<span class="s3">def </span><span class="s1">_normtest_finish(z</span><span class="s3">, </span><span class="s1">alternative):</span>
    <span class="s2">&quot;&quot;&quot;Common code between all the normality-test functions.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'less'</span><span class="s1">:</span>
        <span class="s1">prob = distributions.norm.cdf(z)</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">'greater'</span><span class="s1">:</span>
        <span class="s1">prob = distributions.norm.sf(z)</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">'two-sided'</span><span class="s1">:</span>
        <span class="s1">prob = </span><span class="s5">2 </span><span class="s1">* distributions.norm.sf(np.abs(z))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;alternative must be &quot;</span>
                         <span class="s4">&quot;'less', 'greater' or 'two-sided'&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">z.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">z = z[()]</span>

    <span class="s3">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">prob</span>


<span class="s1">SkewtestResult = namedtuple(</span><span class="s4">'SkewtestResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">skewtest(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Test whether the skew is different from the normal distribution. 
 
    This function tests the null hypothesis that the skewness of 
    the population that the sample was drawn from is the same 
    as that of a corresponding normal distribution. 
 
    Parameters 
    ---------- 
    a : array 
        The data to be tested. 
    axis : int or None, optional 
       Axis along which statistics are calculated. Default is 0. 
       If None, compute over the whole array `a`. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
        * 'propagate': returns nan 
        * 'raise': throws an error 
        * 'omit': performs the calculations ignoring nan values 
 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        The following options are available: 
 
        * 'two-sided': the skewness of the distribution underlying the sample 
          is different from that of the normal distribution (i.e. 0) 
        * 'less': the skewness of the distribution underlying the sample 
          is less than that of the normal distribution 
        * 'greater': the skewness of the distribution underlying the sample 
          is greater than that of the normal distribution 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    statistic : float 
        The computed z-score for this test. 
    pvalue : float 
        The p-value for the hypothesis test. 
 
    Notes 
    ----- 
    The sample size must be at least 8. 
 
    References 
    ---------- 
    .. [1] R. B. D'Agostino, A. J. Belanger and R. B. D'Agostino Jr., 
            &quot;A suggestion for using powerful and informative tests of 
            normality&quot;, American Statistician 44, pp. 316-321, 1990. 
    .. [2] Shapiro, S. S., &amp; Wilk, M. B. (1965). An analysis of variance test 
           for normality (complete samples). Biometrika, 52(3/4), 591-611. 
    .. [3] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be 
           Zero: Calculating Exact P-values When Permutations Are Randomly 
           Drawn.&quot; Statistical Applications in Genetics and Molecular Biology 
           9.1 (2010). 
 
    Examples 
    -------- 
    Suppose we wish to infer from measurements whether the weights of adult 
    human males in a medical study are not normally distributed [2]_. 
    The weights (lbs) are recorded in the array ``x`` below. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([148, 154, 158, 160, 161, 162, 166, 170, 182, 195, 236]) 
 
    The skewness test from [1]_ begins by computing a statistic based on the 
    sample skewness. 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; res = stats.skewtest(x) 
    &gt;&gt;&gt; res.statistic 
    2.7788579769903414 
 
    Because normal distributions have zero skewness, the magnitude of this 
    statistic tends to be low for samples drawn from a normal distribution. 
 
    The test is performed by comparing the observed value of the 
    statistic against the null distribution: the distribution of statistic 
    values derived under the null hypothesis that the weights were drawn from 
    a normal distribution. 
 
    For this test, the null distribution of the statistic for very large 
    samples is the standard normal distribution. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; dist = stats.norm() 
    &gt;&gt;&gt; st_val = np.linspace(-5, 5, 100) 
    &gt;&gt;&gt; pdf = dist.pdf(st_val) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; def st_plot(ax):  # we'll re-use this 
    ...     ax.plot(st_val, pdf) 
    ...     ax.set_title(&quot;Skew Test Null Distribution&quot;) 
    ...     ax.set_xlabel(&quot;statistic&quot;) 
    ...     ax.set_ylabel(&quot;probability density&quot;) 
    &gt;&gt;&gt; st_plot(ax) 
    &gt;&gt;&gt; plt.show() 
 
    The comparison is quantified by the p-value: the proportion of values in 
    the null distribution as extreme or more extreme than the observed 
    value of the statistic. In a two-sided test, elements of the null 
    distribution greater than the observed statistic and elements of the null 
    distribution less than the negative of the observed statistic are both 
    considered &quot;more extreme&quot;. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; st_plot(ax) 
    &gt;&gt;&gt; pvalue = dist.cdf(-res.statistic) + dist.sf(res.statistic) 
    &gt;&gt;&gt; annotation = (f'p-value={pvalue:.3f}\n(shaded area)') 
    &gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8) 
    &gt;&gt;&gt; _ = ax.annotate(annotation, (3, 0.005), (3.25, 0.02), arrowprops=props) 
    &gt;&gt;&gt; i = st_val &gt;= res.statistic 
    &gt;&gt;&gt; ax.fill_between(st_val[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; i = st_val &lt;= -res.statistic 
    &gt;&gt;&gt; ax.fill_between(st_val[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; ax.set_xlim(-5, 5) 
    &gt;&gt;&gt; ax.set_ylim(0, 0.1) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.005455036974740185 
 
    If the p-value is &quot;small&quot; - that is, if there is a low probability of 
    sampling data from a normally distributed population that produces such an 
    extreme value of the statistic - this may be taken as evidence against 
    the null hypothesis in favor of the alternative: the weights were not 
    drawn from a normal distribution. Note that: 
 
    - The inverse is not true; that is, the test is not used to provide 
      evidence for the null hypothesis. 
    - The threshold for values that will be considered &quot;small&quot; is a choice that 
      should be made before the data is analyzed [3]_ with consideration of the 
      risks of both false positives (incorrectly rejecting the null hypothesis) 
      and false negatives (failure to reject a false null hypothesis). 
 
    Note that the standard normal distribution provides an asymptotic 
    approximation of the null distribution; it is only accurate for samples 
    with many observations. For small samples like ours, 
    `scipy.stats.monte_carlo_test` may provide a more accurate, albeit 
    stochastic, approximation of the exact p-value. 
 
    &gt;&gt;&gt; def statistic(x, axis): 
    ...     # get just the skewtest statistic; ignore the p-value 
    ...     return stats.skewtest(x, axis=axis).statistic 
    &gt;&gt;&gt; res = stats.monte_carlo_test(x, stats.norm.rvs, statistic) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; st_plot(ax) 
    &gt;&gt;&gt; ax.hist(res.null_distribution, np.linspace(-5, 5, 50), 
    ...         density=True) 
    &gt;&gt;&gt; ax.legend(['aymptotic approximation\n(many observations)', 
    ...            'Monte Carlo approximation\n(11 observations)']) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.0062  # may vary 
 
    In this case, the asymptotic approximation and Monte Carlo approximation 
    agree fairly closely, even for our small sample. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">a = ma.masked_invalid(a)</span>
        <span class="s3">return </span><span class="s1">mstats_basic.skewtest(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">alternative)</span>

    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">a = np.ravel(a)</span>
        <span class="s1">axis = </span><span class="s5">0</span>
    <span class="s1">b2 = skew(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">n = a.shape[axis]</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">8</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;skewtest is not valid with less than 8 samples; %i samples&quot;</span>
            <span class="s4">&quot; were given.&quot; </span><span class="s1">% int(n))</span>
    <span class="s1">y = b2 * math.sqrt(((n + </span><span class="s5">1</span><span class="s1">) * (n + </span><span class="s5">3</span><span class="s1">)) / (</span><span class="s5">6.0 </span><span class="s1">* (n - </span><span class="s5">2</span><span class="s1">)))</span>
    <span class="s1">beta2 = (</span><span class="s5">3.0 </span><span class="s1">* (n**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">27</span><span class="s1">*n - </span><span class="s5">70</span><span class="s1">) * (n+</span><span class="s5">1</span><span class="s1">) * (n+</span><span class="s5">3</span><span class="s1">) /</span>
             <span class="s1">((n-</span><span class="s5">2.0</span><span class="s1">) * (n+</span><span class="s5">5</span><span class="s1">) * (n+</span><span class="s5">7</span><span class="s1">) * (n+</span><span class="s5">9</span><span class="s1">)))</span>
    <span class="s1">W2 = -</span><span class="s5">1 </span><span class="s1">+ math.sqrt(</span><span class="s5">2 </span><span class="s1">* (beta2 - </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">delta = </span><span class="s5">1 </span><span class="s1">/ math.sqrt(</span><span class="s5">0.5 </span><span class="s1">* math.log(W2))</span>
    <span class="s1">alpha = math.sqrt(</span><span class="s5">2.0 </span><span class="s1">/ (W2 - </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">y = np.where(y == </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s1">Z = delta * np.log(y / alpha + np.sqrt((y / alpha)**</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s3">return </span><span class="s1">SkewtestResult(*_normtest_finish(Z</span><span class="s3">, </span><span class="s1">alternative))</span>


<span class="s1">KurtosistestResult = namedtuple(</span><span class="s4">'KurtosistestResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">kurtosistest(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Test whether a dataset has normal kurtosis. 
 
    This function tests the null hypothesis that the kurtosis 
    of the population from which the sample was drawn is that 
    of the normal distribution. 
 
    Parameters 
    ---------- 
    a : array 
        Array of the sample data. 
    axis : int or None, optional 
       Axis along which to compute test. Default is 0. If None, 
       compute over the whole array `a`. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
        * 'propagate': returns nan 
        * 'raise': throws an error 
        * 'omit': performs the calculations ignoring nan values 
 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the kurtosis of the distribution underlying the sample 
          is different from that of the normal distribution 
        * 'less': the kurtosis of the distribution underlying the sample 
          is less than that of the normal distribution 
        * 'greater': the kurtosis of the distribution underlying the sample 
          is greater than that of the normal distribution 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    statistic : float 
        The computed z-score for this test. 
    pvalue : float 
        The p-value for the hypothesis test. 
 
    Notes 
    ----- 
    Valid only for n&gt;20. This function uses the method described in [1]_. 
 
    References 
    ---------- 
    .. [1] see e.g. F. J. Anscombe, W. J. Glynn, &quot;Distribution of the kurtosis 
       statistic b2 for normal samples&quot;, Biometrika, vol. 70, pp. 227-234, 1983. 
    .. [2] Shapiro, S. S., &amp; Wilk, M. B. (1965). An analysis of variance test 
           for normality (complete samples). Biometrika, 52(3/4), 591-611. 
    .. [3] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be 
           Zero: Calculating Exact P-values When Permutations Are Randomly 
           Drawn.&quot; Statistical Applications in Genetics and Molecular Biology 
           9.1 (2010). 
    .. [4] Panagiotakos, D. B. (2008). The value of p-value in biomedical 
           research. The open cardiovascular medicine journal, 2, 97. 
 
    Examples 
    -------- 
    Suppose we wish to infer from measurements whether the weights of adult 
    human males in a medical study are not normally distributed [2]_. 
    The weights (lbs) are recorded in the array ``x`` below. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([148, 154, 158, 160, 161, 162, 166, 170, 182, 195, 236]) 
 
    The kurtosis test from [1]_ begins by computing a statistic based on the 
    sample (excess/Fisher) kurtosis. 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; res = stats.kurtosistest(x) 
    &gt;&gt;&gt; res.statistic 
    2.3048235214240873 
 
    (The test warns that our sample has too few observations to perform the 
    test. We'll return to this at the end of the example.) 
    Because normal distributions have zero excess kurtosis (by definition), 
    the magnitude of this statistic tends to be low for samples drawn from a 
    normal distribution. 
 
    The test is performed by comparing the observed value of the 
    statistic against the null distribution: the distribution of statistic 
    values derived under the null hypothesis that the weights were drawn from 
    a normal distribution. 
 
    For this test, the null distribution of the statistic for very large 
    samples is the standard normal distribution. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; dist = stats.norm() 
    &gt;&gt;&gt; kt_val = np.linspace(-5, 5, 100) 
    &gt;&gt;&gt; pdf = dist.pdf(kt_val) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; def kt_plot(ax):  # we'll re-use this 
    ...     ax.plot(kt_val, pdf) 
    ...     ax.set_title(&quot;Kurtosis Test Null Distribution&quot;) 
    ...     ax.set_xlabel(&quot;statistic&quot;) 
    ...     ax.set_ylabel(&quot;probability density&quot;) 
    &gt;&gt;&gt; kt_plot(ax) 
    &gt;&gt;&gt; plt.show() 
 
    The comparison is quantified by the p-value: the proportion of values in 
    the null distribution as extreme or more extreme than the observed 
    value of the statistic. In a two-sided test in which the statistic is 
    positive, elements of the null distribution greater than the observed 
    statistic and elements of the null distribution less than the negative of 
    the observed statistic are both considered &quot;more extreme&quot;. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; kt_plot(ax) 
    &gt;&gt;&gt; pvalue = dist.cdf(-res.statistic) + dist.sf(res.statistic) 
    &gt;&gt;&gt; annotation = (f'p-value={pvalue:.3f}\n(shaded area)') 
    &gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8) 
    &gt;&gt;&gt; _ = ax.annotate(annotation, (3, 0.005), (3.25, 0.02), arrowprops=props) 
    &gt;&gt;&gt; i = kt_val &gt;= res.statistic 
    &gt;&gt;&gt; ax.fill_between(kt_val[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; i = kt_val &lt;= -res.statistic 
    &gt;&gt;&gt; ax.fill_between(kt_val[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; ax.set_xlim(-5, 5) 
    &gt;&gt;&gt; ax.set_ylim(0, 0.1) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.0211764592113868 
 
    If the p-value is &quot;small&quot; - that is, if there is a low probability of 
    sampling data from a normally distributed population that produces such an 
    extreme value of the statistic - this may be taken as evidence against 
    the null hypothesis in favor of the alternative: the weights were not 
    drawn from a normal distribution. Note that: 
 
    - The inverse is not true; that is, the test is not used to provide 
      evidence for the null hypothesis. 
    - The threshold for values that will be considered &quot;small&quot; is a choice that 
      should be made before the data is analyzed [3]_ with consideration of the 
      risks of both false positives (incorrectly rejecting the null hypothesis) 
      and false negatives (failure to reject a false null hypothesis). 
 
    Note that the standard normal distribution provides an asymptotic 
    approximation of the null distribution; it is only accurate for samples 
    with many observations. This is the reason we received a warning at the 
    beginning of the example; our sample is quite small. In this case, 
    `scipy.stats.monte_carlo_test` may provide a more accurate, albeit 
    stochastic, approximation of the exact p-value. 
 
    &gt;&gt;&gt; def statistic(x, axis): 
    ...     # get just the skewtest statistic; ignore the p-value 
    ...     return stats.kurtosistest(x, axis=axis).statistic 
    &gt;&gt;&gt; res = stats.monte_carlo_test(x, stats.norm.rvs, statistic) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; kt_plot(ax) 
    &gt;&gt;&gt; ax.hist(res.null_distribution, np.linspace(-5, 5, 50), 
    ...         density=True) 
    &gt;&gt;&gt; ax.legend(['aymptotic approximation\n(many observations)', 
    ...            'Monte Carlo approximation\n(11 observations)']) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.0272  # may vary 
 
    Furthermore, despite their stochastic nature, p-values computed in this way 
    can be used to exactly control the rate of false rejections of the null 
    hypothesis [4]_. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">a = ma.masked_invalid(a)</span>
        <span class="s3">return </span><span class="s1">mstats_basic.kurtosistest(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">alternative)</span>

    <span class="s1">n = a.shape[axis]</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">5</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;kurtosistest requires at least 5 observations; %i observations&quot;</span>
            <span class="s4">&quot; were given.&quot; </span><span class="s1">% int(n))</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">20</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;kurtosistest only valid for n&gt;=20 ... continuing &quot;</span>
                      <span class="s4">&quot;anyway, n=%i&quot; </span><span class="s1">% int(n))</span>
    <span class="s1">b2 = kurtosis(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">fisher=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s1">E = </span><span class="s5">3.0</span><span class="s1">*(n-</span><span class="s5">1</span><span class="s1">) / (n+</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">varb2 = </span><span class="s5">24.0</span><span class="s1">*n*(n-</span><span class="s5">2</span><span class="s1">)*(n-</span><span class="s5">3</span><span class="s1">) / ((n+</span><span class="s5">1</span><span class="s1">)*(n+</span><span class="s5">1.</span><span class="s1">)*(n+</span><span class="s5">3</span><span class="s1">)*(n+</span><span class="s5">5</span><span class="s1">))  </span><span class="s0"># [1]_ Eq. 1</span>
    <span class="s1">x = (b2-E) / np.sqrt(varb2)  </span><span class="s0"># [1]_ Eq. 4</span>
    <span class="s0"># [1]_ Eq. 2:</span>
    <span class="s1">sqrtbeta1 = </span><span class="s5">6.0</span><span class="s1">*(n*n-</span><span class="s5">5</span><span class="s1">*n+</span><span class="s5">2</span><span class="s1">)/((n+</span><span class="s5">7</span><span class="s1">)*(n+</span><span class="s5">9</span><span class="s1">)) * np.sqrt((</span><span class="s5">6.0</span><span class="s1">*(n+</span><span class="s5">3</span><span class="s1">)*(n+</span><span class="s5">5</span><span class="s1">)) /</span>
                                                        <span class="s1">(n*(n-</span><span class="s5">2</span><span class="s1">)*(n-</span><span class="s5">3</span><span class="s1">)))</span>
    <span class="s0"># [1]_ Eq. 3:</span>
    <span class="s1">A = </span><span class="s5">6.0 </span><span class="s1">+ </span><span class="s5">8.0</span><span class="s1">/sqrtbeta1 * (</span><span class="s5">2.0</span><span class="s1">/sqrtbeta1 + np.sqrt(</span><span class="s5">1</span><span class="s1">+</span><span class="s5">4.0</span><span class="s1">/(sqrtbeta1**</span><span class="s5">2</span><span class="s1">)))</span>
    <span class="s1">term1 = </span><span class="s5">1 </span><span class="s1">- </span><span class="s5">2</span><span class="s1">/(</span><span class="s5">9.0</span><span class="s1">*A)</span>
    <span class="s1">denom = </span><span class="s5">1 </span><span class="s1">+ x*np.sqrt(</span><span class="s5">2</span><span class="s1">/(A-</span><span class="s5">4.0</span><span class="s1">))</span>
    <span class="s1">term2 = np.sign(denom) * np.where(denom == </span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">,</span>
                                      <span class="s1">np.power((</span><span class="s5">1</span><span class="s1">-</span><span class="s5">2.0</span><span class="s1">/A)/np.abs(denom)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">))</span>
    <span class="s3">if </span><span class="s1">np.any(denom == </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Test statistic not defined in some cases due to division by &quot; </span><span class="s1">\</span>
              <span class="s4">&quot;zero. Return nan in that case...&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>

    <span class="s1">Z = (term1 - term2) / np.sqrt(</span><span class="s5">2</span><span class="s1">/(</span><span class="s5">9.0</span><span class="s1">*A))  </span><span class="s0"># [1]_ Eq. 5</span>

    <span class="s0"># zprob uses upper tail, so Z needs to be positive</span>
    <span class="s3">return </span><span class="s1">KurtosistestResult(*_normtest_finish(Z</span><span class="s3">, </span><span class="s1">alternative))</span>


<span class="s1">NormaltestResult = namedtuple(</span><span class="s4">'NormaltestResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">normaltest(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Test whether a sample differs from a normal distribution. 
 
    This function tests the null hypothesis that a sample comes 
    from a normal distribution.  It is based on D'Agostino and 
    Pearson's [1]_, [2]_ test that combines skew and kurtosis to 
    produce an omnibus test of normality. 
 
    Parameters 
    ---------- 
    a : array_like 
        The array containing the sample to be tested. 
    axis : int or None, optional 
        Axis along which to compute test. Default is 0. If None, 
        compute over the whole array `a`. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    statistic : float or array 
        ``s^2 + k^2``, where ``s`` is the z-score returned by `skewtest` and 
        ``k`` is the z-score returned by `kurtosistest`. 
    pvalue : float or array 
       A 2-sided chi squared probability for the hypothesis test. 
 
    References 
    ---------- 
    .. [1] D'Agostino, R. B. (1971), &quot;An omnibus test of normality for 
           moderate and large sample size&quot;, Biometrika, 58, 341-348 
    .. [2] D'Agostino, R. and Pearson, E. S. (1973), &quot;Tests for departure from 
           normality&quot;, Biometrika, 60, 613-622 
    .. [3] Shapiro, S. S., &amp; Wilk, M. B. (1965). An analysis of variance test 
           for normality (complete samples). Biometrika, 52(3/4), 591-611. 
    .. [4] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be 
           Zero: Calculating Exact P-values When Permutations Are Randomly 
           Drawn.&quot; Statistical Applications in Genetics and Molecular Biology 
           9.1 (2010). 
    .. [5] Panagiotakos, D. B. (2008). The value of p-value in biomedical 
           research. The open cardiovascular medicine journal, 2, 97. 
 
    Examples 
    -------- 
    Suppose we wish to infer from measurements whether the weights of adult 
    human males in a medical study are not normally distributed [3]_. 
    The weights (lbs) are recorded in the array ``x`` below. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([148, 154, 158, 160, 161, 162, 166, 170, 182, 195, 236]) 
 
    The normality test of [1]_ and [2]_ begins by computing a statistic based 
    on the sample skewness and kurtosis. 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; res = stats.normaltest(x) 
    &gt;&gt;&gt; res.statistic 
    13.034263121192582 
 
    (The test warns that our sample has too few observations to perform the 
    test. We'll return to this at the end of the example.) 
    Because the normal distribution has zero skewness and zero 
    (&quot;excess&quot; or &quot;Fisher&quot;) kurtosis, the value of this statistic tends to be 
    low for samples drawn from a normal distribution. 
 
    The test is performed by comparing the observed value of the statistic 
    against the null distribution: the distribution of statistic values derived 
    under the null hypothesis that the weights were drawn from a normal 
    distribution. 
    For this normality test, the null distribution for very large samples is 
    the chi-squared distribution with two degrees of freedom. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; dist = stats.chi2(df=2) 
    &gt;&gt;&gt; stat_vals = np.linspace(0, 16, 100) 
    &gt;&gt;&gt; pdf = dist.pdf(stat_vals) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; def plot(ax):  # we'll re-use this 
    ...     ax.plot(stat_vals, pdf) 
    ...     ax.set_title(&quot;Normality Test Null Distribution&quot;) 
    ...     ax.set_xlabel(&quot;statistic&quot;) 
    ...     ax.set_ylabel(&quot;probability density&quot;) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; plt.show() 
 
    The comparison is quantified by the p-value: the proportion of values in 
    the null distribution greater than or equal to the observed value of the 
    statistic. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; pvalue = dist.sf(res.statistic) 
    &gt;&gt;&gt; annotation = (f'p-value={pvalue:.6f}\n(shaded area)') 
    &gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8) 
    &gt;&gt;&gt; _ = ax.annotate(annotation, (13.5, 5e-4), (14, 5e-3), arrowprops=props) 
    &gt;&gt;&gt; i = stat_vals &gt;= res.statistic  # index more extreme statistic values 
    &gt;&gt;&gt; ax.fill_between(stat_vals[i], y1=0, y2=pdf[i]) 
    &gt;&gt;&gt; ax.set_xlim(8, 16) 
    &gt;&gt;&gt; ax.set_ylim(0, 0.01) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.0014779023013100172 
 
    If the p-value is &quot;small&quot; - that is, if there is a low probability of 
    sampling data from a normally distributed population that produces such an 
    extreme value of the statistic - this may be taken as evidence against 
    the null hypothesis in favor of the alternative: the weights were not 
    drawn from a normal distribution. Note that: 
 
    - The inverse is not true; that is, the test is not used to provide 
      evidence for the null hypothesis. 
    - The threshold for values that will be considered &quot;small&quot; is a choice that 
      should be made before the data is analyzed [4]_ with consideration of the 
      risks of both false positives (incorrectly rejecting the null hypothesis) 
      and false negatives (failure to reject a false null hypothesis). 
 
    Note that the chi-squared distribution provides an asymptotic 
    approximation of the null distribution; it is only accurate for samples 
    with many observations. This is the reason we received a warning at the 
    beginning of the example; our sample is quite small. In this case, 
    `scipy.stats.monte_carlo_test` may provide a more accurate, albeit 
    stochastic, approximation of the exact p-value. 
 
    &gt;&gt;&gt; def statistic(x, axis): 
    ...     # Get only the `normaltest` statistic; ignore approximate p-value 
    ...     return stats.normaltest(x, axis=axis).statistic 
    &gt;&gt;&gt; res = stats.monte_carlo_test(x, stats.norm.rvs, statistic, 
    ...                              alternative='greater') 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; ax.hist(res.null_distribution, np.linspace(0, 25, 50), 
    ...         density=True) 
    &gt;&gt;&gt; ax.legend(['aymptotic approximation (many observations)', 
    ...            'Monte Carlo approximation (11 observations)']) 
    &gt;&gt;&gt; ax.set_xlim(0, 14) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.0082  # may vary 
 
    Furthermore, despite their stochastic nature, p-values computed in this way 
    can be used to exactly control the rate of false rejections of the null 
    hypothesis [5]_. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">a = ma.masked_invalid(a)</span>
        <span class="s3">return </span><span class="s1">mstats_basic.normaltest(a</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">s</span><span class="s3">, </span><span class="s1">_ = skewtest(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">_ = kurtosistest(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">k2 = s*s + k*k</span>

    <span class="s3">return </span><span class="s1">NormaltestResult(k2</span><span class="s3">, </span><span class="s1">distributions.chi2.sf(k2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>


<span class="s1">@_axis_nan_policy_factory(SignificanceResult</span><span class="s3">, </span><span class="s1">default_axis=</span><span class="s3">None</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">jarque_bera(x</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Perform the Jarque-Bera goodness of fit test on sample data. 
 
    The Jarque-Bera test tests whether the sample data has the skewness and 
    kurtosis matching a normal distribution. 
 
    Note that this test only works for a large enough number of data samples 
    (&gt;2000) as the test statistic asymptotically has a Chi-squared distribution 
    with 2 degrees of freedom. 
 
    Parameters 
    ---------- 
    x : array_like 
        Observations of a random variable. 
    axis : int or None, default: 0 
        If an int, the axis of the input along which to compute the statistic. 
        The statistic of each axis-slice (e.g. row) of the input will appear in 
        a corresponding element of the output. 
        If ``None``, the input will be raveled before computing the statistic. 
 
    Returns 
    ------- 
    result : SignificanceResult 
        An object with the following attributes: 
 
        statistic : float 
            The test statistic. 
        pvalue : float 
            The p-value for the hypothesis test. 
 
    References 
    ---------- 
    .. [1] Jarque, C. and Bera, A. (1980) &quot;Efficient tests for normality, 
           homoscedasticity and serial independence of regression residuals&quot;, 
           6 Econometric Letters 255-259. 
    .. [2] Shapiro, S. S., &amp; Wilk, M. B. (1965). An analysis of variance test 
           for normality (complete samples). Biometrika, 52(3/4), 591-611. 
    .. [3] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be 
           Zero: Calculating Exact P-values When Permutations Are Randomly 
           Drawn.&quot; Statistical Applications in Genetics and Molecular Biology 
           9.1 (2010). 
    .. [4] Panagiotakos, D. B. (2008). The value of p-value in biomedical 
           research. The open cardiovascular medicine journal, 2, 97. 
 
    Examples 
    -------- 
    Suppose we wish to infer from measurements whether the weights of adult 
    human males in a medical study are not normally distributed [2]_. 
    The weights (lbs) are recorded in the array ``x`` below. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([148, 154, 158, 160, 161, 162, 166, 170, 182, 195, 236]) 
 
    The Jarque-Bera test begins by computing a statistic based on the sample 
    skewness and kurtosis. 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; res = stats.jarque_bera(x) 
    &gt;&gt;&gt; res.statistic 
    6.982848237344646 
 
    Because the normal distribution has zero skewness and zero 
    (&quot;excess&quot; or &quot;Fisher&quot;) kurtosis, the value of this statistic tends to be 
    low for samples drawn from a normal distribution. 
 
    The test is performed by comparing the observed value of the statistic 
    against the null distribution: the distribution of statistic values derived 
    under the null hypothesis that the weights were drawn from a normal 
    distribution. 
    For the Jarque-Bera test, the null distribution for very large samples is 
    the chi-squared distribution with two degrees of freedom. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; dist = stats.chi2(df=2) 
    &gt;&gt;&gt; jb_val = np.linspace(0, 11, 100) 
    &gt;&gt;&gt; pdf = dist.pdf(jb_val) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; def jb_plot(ax):  # we'll re-use this 
    ...     ax.plot(jb_val, pdf) 
    ...     ax.set_title(&quot;Jarque-Bera Null Distribution&quot;) 
    ...     ax.set_xlabel(&quot;statistic&quot;) 
    ...     ax.set_ylabel(&quot;probability density&quot;) 
    &gt;&gt;&gt; jb_plot(ax) 
    &gt;&gt;&gt; plt.show() 
 
    The comparison is quantified by the p-value: the proportion of values in 
    the null distribution greater than or equal to the observed value of the 
    statistic. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; jb_plot(ax) 
    &gt;&gt;&gt; pvalue = dist.sf(res.statistic) 
    &gt;&gt;&gt; annotation = (f'p-value={pvalue:.6f}\n(shaded area)') 
    &gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8) 
    &gt;&gt;&gt; _ = ax.annotate(annotation, (7.5, 0.01), (8, 0.05), arrowprops=props) 
    &gt;&gt;&gt; i = jb_val &gt;= res.statistic  # indices of more extreme statistic values 
    &gt;&gt;&gt; ax.fill_between(jb_val[i], y1=0, y2=pdf[i]) 
    &gt;&gt;&gt; ax.set_xlim(0, 11) 
    &gt;&gt;&gt; ax.set_ylim(0, 0.3) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.03045746622458189 
 
    If the p-value is &quot;small&quot; - that is, if there is a low probability of 
    sampling data from a normally distributed population that produces such an 
    extreme value of the statistic - this may be taken as evidence against 
    the null hypothesis in favor of the alternative: the weights were not 
    drawn from a normal distribution. Note that: 
 
    - The inverse is not true; that is, the test is not used to provide 
      evidence for the null hypothesis. 
    - The threshold for values that will be considered &quot;small&quot; is a choice that 
      should be made before the data is analyzed [3]_ with consideration of the 
      risks of both false positives (incorrectly rejecting the null hypothesis) 
      and false negatives (failure to reject a false null hypothesis). 
 
    Note that the chi-squared distribution provides an asymptotic approximation 
    of the null distribution; it is only accurate for samples with many 
    observations. For small samples like ours, `scipy.stats.monte_carlo_test` 
    may provide a more accurate, albeit stochastic, approximation of the 
    exact p-value. 
 
    &gt;&gt;&gt; def statistic(x, axis): 
    ...     # underlying calculation of the Jarque Bera statistic 
    ...     s = stats.skew(x, axis=axis) 
    ...     k = stats.kurtosis(x, axis=axis) 
    ...     return x.shape[axis]/6 * (s**2 + k**2/4) 
    &gt;&gt;&gt; res = stats.monte_carlo_test(x, stats.norm.rvs, statistic, 
    ...                              alternative='greater') 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; jb_plot(ax) 
    &gt;&gt;&gt; ax.hist(res.null_distribution, np.linspace(0, 10, 50), 
    ...         density=True) 
    &gt;&gt;&gt; ax.legend(['aymptotic approximation (many observations)', 
    ...            'Monte Carlo approximation (11 observations)']) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.0097  # may vary 
 
    Furthermore, despite their stochastic nature, p-values computed in this way 
    can be used to exactly control the rate of false rejections of the null 
    hypothesis [4]_. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.asarray(x)</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">x = x.ravel()</span>
        <span class="s1">axis = </span><span class="s5">0</span>

    <span class="s1">n = x.shape[axis]</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'At least one observation is required.'</span><span class="s1">)</span>

    <span class="s1">mu = x.mean(axis=axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">diffx = x - mu</span>
    <span class="s1">s = skew(diffx</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">_no_deco=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">k = kurtosis(diffx</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">_no_deco=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">statistic = n / </span><span class="s5">6 </span><span class="s1">* (s**</span><span class="s5">2 </span><span class="s1">+ k**</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">pvalue = distributions.chi2.sf(statistic</span><span class="s3">, </span><span class="s1">df=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">SignificanceResult(statistic</span><span class="s3">, </span><span class="s1">pvalue)</span>


<span class="s0">#####################################</span>
<span class="s0">#        FREQUENCY FUNCTIONS        #</span>
<span class="s0">#####################################</span>


<span class="s3">def </span><span class="s1">scoreatpercentile(a</span><span class="s3">, </span><span class="s1">per</span><span class="s3">, </span><span class="s1">limit=()</span><span class="s3">, </span><span class="s1">interpolation_method=</span><span class="s4">'fraction'</span><span class="s3">,</span>
                      <span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Calculate the score at a given percentile of the input sequence. 
 
    For example, the score at `per=50` is the median. If the desired quantile 
    lies between two data points, we interpolate between them, according to 
    the value of `interpolation`. If the parameter `limit` is provided, it 
    should be a tuple (lower, upper) of two values. 
 
    Parameters 
    ---------- 
    a : array_like 
        A 1-D array of values from which to extract score. 
    per : array_like 
        Percentile(s) at which to extract score.  Values should be in range 
        [0,100]. 
    limit : tuple, optional 
        Tuple of two scalars, the lower and upper limits within which to 
        compute the percentile. Values of `a` outside 
        this (closed) interval will be ignored. 
    interpolation_method : {'fraction', 'lower', 'higher'}, optional 
        Specifies the interpolation method to use, 
        when the desired quantile lies between two data points `i` and `j` 
        The following options are available (default is 'fraction'): 
 
          * 'fraction': ``i + (j - i) * fraction`` where ``fraction`` is the 
            fractional part of the index surrounded by ``i`` and ``j`` 
          * 'lower': ``i`` 
          * 'higher': ``j`` 
 
    axis : int, optional 
        Axis along which the percentiles are computed. Default is None. If 
        None, compute over the whole array `a`. 
 
    Returns 
    ------- 
    score : float or ndarray 
        Score at percentile(s). 
 
    See Also 
    -------- 
    percentileofscore, numpy.percentile 
 
    Notes 
    ----- 
    This function will become obsolete in the future. 
    For NumPy 1.9 and higher, `numpy.percentile` provides all the functionality 
    that `scoreatpercentile` provides.  And it's significantly faster. 
    Therefore it's recommended to use `numpy.percentile` for users that have 
    numpy &gt;= 1.9. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; a = np.arange(100) 
    &gt;&gt;&gt; stats.scoreatpercentile(a, 50) 
    49.5 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># adapted from NumPy's percentile function.  When we require numpy &gt;= 1.8,</span>
    <span class="s0"># the implementation of this function can be replaced by np.percentile.</span>
    <span class="s1">a = np.asarray(a)</span>
    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0"># empty array, return nan(s) with shape matching `per`</span>
        <span class="s3">if </span><span class="s1">np.isscalar(per):</span>
            <span class="s3">return </span><span class="s1">np.nan</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.full(np.asarray(per).shape</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>

    <span class="s3">if </span><span class="s1">limit:</span>
        <span class="s1">a = a[(limit[</span><span class="s5">0</span><span class="s1">] &lt;= a) &amp; (a &lt;= limit[</span><span class="s5">1</span><span class="s1">])]</span>

    <span class="s1">sorted_ = np.sort(a</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">axis = </span><span class="s5">0</span>

    <span class="s3">return </span><span class="s1">_compute_qth_percentile(sorted_</span><span class="s3">, </span><span class="s1">per</span><span class="s3">, </span><span class="s1">interpolation_method</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s0"># handle sequence of per's without calling sort multiple times</span>
<span class="s3">def </span><span class="s1">_compute_qth_percentile(sorted_</span><span class="s3">, </span><span class="s1">per</span><span class="s3">, </span><span class="s1">interpolation_method</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s3">if not </span><span class="s1">np.isscalar(per):</span>
        <span class="s1">score = [_compute_qth_percentile(sorted_</span><span class="s3">, </span><span class="s1">i</span><span class="s3">,</span>
                                         <span class="s1">interpolation_method</span><span class="s3">, </span><span class="s1">axis)</span>
                 <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">per]</span>
        <span class="s3">return </span><span class="s1">np.array(score)</span>

    <span class="s3">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= per &lt;= </span><span class="s5">100</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;percentile must be in the range [0, 100]&quot;</span><span class="s1">)</span>

    <span class="s1">indexer = [slice(</span><span class="s3">None</span><span class="s1">)] * sorted_.ndim</span>
    <span class="s1">idx = per / </span><span class="s5">100. </span><span class="s1">* (sorted_.shape[axis] - </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">int(idx) != idx:</span>
        <span class="s0"># round fractional indices according to interpolation method</span>
        <span class="s3">if </span><span class="s1">interpolation_method == </span><span class="s4">'lower'</span><span class="s1">:</span>
            <span class="s1">idx = int(np.floor(idx))</span>
        <span class="s3">elif </span><span class="s1">interpolation_method == </span><span class="s4">'higher'</span><span class="s1">:</span>
            <span class="s1">idx = int(np.ceil(idx))</span>
        <span class="s3">elif </span><span class="s1">interpolation_method == </span><span class="s4">'fraction'</span><span class="s1">:</span>
            <span class="s3">pass  </span><span class="s0"># keep idx as fraction and interpolate</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;interpolation_method can only be 'fraction', &quot;</span>
                             <span class="s4">&quot;'lower' or 'higher'&quot;</span><span class="s1">)</span>

    <span class="s1">i = int(idx)</span>
    <span class="s3">if </span><span class="s1">i == idx:</span>
        <span class="s1">indexer[axis] = slice(i</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">weights = array(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">sumval = </span><span class="s5">1.0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">indexer[axis] = slice(i</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">j = i + </span><span class="s5">1</span>
        <span class="s1">weights = array([(j - idx)</span><span class="s3">, </span><span class="s1">(idx - i)]</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s1">wshape = [</span><span class="s5">1</span><span class="s1">] * sorted_.ndim</span>
        <span class="s1">wshape[axis] = </span><span class="s5">2</span>
        <span class="s1">weights.shape = wshape</span>
        <span class="s1">sumval = weights.sum()</span>

    <span class="s0"># Use np.add.reduce (== np.sum but a little faster) to coerce data type</span>
    <span class="s3">return </span><span class="s1">np.add.reduce(sorted_[tuple(indexer)] * weights</span><span class="s3">, </span><span class="s1">axis=axis) / sumval</span>


<span class="s3">def </span><span class="s1">percentileofscore(a</span><span class="s3">, </span><span class="s1">score</span><span class="s3">, </span><span class="s1">kind=</span><span class="s4">'rank'</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the percentile rank of a score relative to a list of scores. 
 
    A `percentileofscore` of, for example, 80% means that 80% of the 
    scores in `a` are below the given score. In the case of gaps or 
    ties, the exact definition depends on the optional keyword, `kind`. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array to which `score` is compared. 
    score : array_like 
        Scores to compute percentiles for. 
    kind : {'rank', 'weak', 'strict', 'mean'}, optional 
        Specifies the interpretation of the resulting score. 
        The following options are available (default is 'rank'): 
 
          * 'rank': Average percentage ranking of score.  In case of multiple 
            matches, average the percentage rankings of all matching scores. 
          * 'weak': This kind corresponds to the definition of a cumulative 
            distribution function.  A percentileofscore of 80% means that 80% 
            of values are less than or equal to the provided score. 
          * 'strict': Similar to &quot;weak&quot;, except that only values that are 
            strictly less than the given score are counted. 
          * 'mean': The average of the &quot;weak&quot; and &quot;strict&quot; scores, often used 
            in testing.  See https://en.wikipedia.org/wiki/Percentile_rank 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Specifies how to treat `nan` values in `a`. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan (for each value in `score`). 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    pcos : float 
        Percentile-position of score (0-100) relative to `a`. 
 
    See Also 
    -------- 
    numpy.percentile 
    scipy.stats.scoreatpercentile, scipy.stats.rankdata 
 
    Examples 
    -------- 
    Three-quarters of the given values lie below a given score: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 4], 3) 
    75.0 
 
    With multiple matches, note how the scores of the two matches, 0.6 
    and 0.8 respectively, are averaged: 
 
    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3) 
    70.0 
 
    Only 2/5 values are strictly less than 3: 
 
    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='strict') 
    40.0 
 
    But 4/5 values are less than or equal to 3: 
 
    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='weak') 
    80.0 
 
    The average between the weak and the strict scores is: 
 
    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='mean') 
    60.0 
 
    Score arrays (of any dimensionality) are supported: 
 
    &gt;&gt;&gt; stats.percentileofscore([1, 2, 3, 3, 4], [2, 3]) 
    array([40., 70.]) 
 
    The inputs can be infinite: 
 
    &gt;&gt;&gt; stats.percentileofscore([-np.inf, 0, 1, np.inf], [1, 2, np.inf]) 
    array([75., 75., 100.]) 
 
    If `a` is empty, then the resulting percentiles are all `nan`: 
 
    &gt;&gt;&gt; stats.percentileofscore([], [1, 2]) 
    array([nan, nan]) 
    &quot;&quot;&quot;</span>

    <span class="s1">a = np.asarray(a)</span>
    <span class="s1">n = len(a)</span>
    <span class="s1">score = np.asarray(score)</span>

    <span class="s0"># Nan treatment</span>
    <span class="s1">cna</span><span class="s3">, </span><span class="s1">npa = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy</span><span class="s3">, </span><span class="s1">use_summation=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">cns</span><span class="s3">, </span><span class="s1">nps = _contains_nan(score</span><span class="s3">, </span><span class="s1">nan_policy</span><span class="s3">, </span><span class="s1">use_summation=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">(cna </span><span class="s3">or </span><span class="s1">cns) </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'raise'</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The input contains nan values&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">cns:</span>
        <span class="s0"># If a score is nan, then the output should be nan</span>
        <span class="s0"># (also if nan_policy is &quot;omit&quot;, because it only applies to `a`)</span>
        <span class="s1">score = ma.masked_where(np.isnan(score)</span><span class="s3">, </span><span class="s1">score)</span>

    <span class="s3">if </span><span class="s1">cna:</span>
        <span class="s3">if </span><span class="s1">nan_policy == </span><span class="s4">&quot;omit&quot;</span><span class="s1">:</span>
            <span class="s0"># Don't count nans</span>
            <span class="s1">a = ma.masked_where(np.isnan(a)</span><span class="s3">, </span><span class="s1">a)</span>
            <span class="s1">n = a.count()</span>

        <span class="s3">if </span><span class="s1">nan_policy == </span><span class="s4">&quot;propagate&quot;</span><span class="s1">:</span>
            <span class="s0"># All outputs should be nans</span>
            <span class="s1">n = </span><span class="s5">0</span>

    <span class="s0"># Cannot compare to empty list ==&gt; nan</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">perct = np.full_like(score</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">dtype=np.float64)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># Prepare broadcasting</span>
        <span class="s1">score = score[...</span><span class="s3">, None</span><span class="s1">]</span>

        <span class="s3">def </span><span class="s1">count(x):</span>
            <span class="s3">return </span><span class="s1">np.count_nonzero(x</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0"># Despite using masked_array to omit nan values from processing,</span>
        <span class="s0"># the CI tests on &quot;Azure pipelines&quot; (but not on the other CI servers)</span>
        <span class="s0"># emits warnings when there are nan values, contrarily to the purpose</span>
        <span class="s0"># of masked_arrays. As a fix, we simply suppress the warnings.</span>
        <span class="s3">with </span><span class="s1">suppress_warnings() </span><span class="s3">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s3">,</span>
                       <span class="s4">&quot;invalid value encountered in less&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s3">,</span>
                       <span class="s4">&quot;invalid value encountered in greater&quot;</span><span class="s1">)</span>

            <span class="s0"># Main computations/logic</span>
            <span class="s3">if </span><span class="s1">kind == </span><span class="s4">'rank'</span><span class="s1">:</span>
                <span class="s1">left = count(a &lt; score)</span>
                <span class="s1">right = count(a &lt;= score)</span>
                <span class="s1">plus1 = left &lt; right</span>
                <span class="s1">perct = (left + right + plus1) * (</span><span class="s5">50.0 </span><span class="s1">/ n)</span>
            <span class="s3">elif </span><span class="s1">kind == </span><span class="s4">'strict'</span><span class="s1">:</span>
                <span class="s1">perct = count(a &lt; score) * (</span><span class="s5">100.0 </span><span class="s1">/ n)</span>
            <span class="s3">elif </span><span class="s1">kind == </span><span class="s4">'weak'</span><span class="s1">:</span>
                <span class="s1">perct = count(a &lt;= score) * (</span><span class="s5">100.0 </span><span class="s1">/ n)</span>
            <span class="s3">elif </span><span class="s1">kind == </span><span class="s4">'mean'</span><span class="s1">:</span>
                <span class="s1">left = count(a &lt; score)</span>
                <span class="s1">right = count(a &lt;= score)</span>
                <span class="s1">perct = (left + right) * (</span><span class="s5">50.0 </span><span class="s1">/ n)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;kind can only be 'rank', 'strict', 'weak' or 'mean'&quot;</span><span class="s1">)</span>

    <span class="s0"># Re-insert nan values</span>
    <span class="s1">perct = ma.filled(perct</span><span class="s3">, </span><span class="s1">np.nan)</span>

    <span class="s3">if </span><span class="s1">perct.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">perct[()]</span>
    <span class="s3">return </span><span class="s1">perct</span>


<span class="s1">HistogramResult = namedtuple(</span><span class="s4">'HistogramResult'</span><span class="s3">,</span>
                             <span class="s1">(</span><span class="s4">'count'</span><span class="s3">, </span><span class="s4">'lowerlimit'</span><span class="s3">, </span><span class="s4">'binsize'</span><span class="s3">, </span><span class="s4">'extrapoints'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">_histogram(a</span><span class="s3">, </span><span class="s1">numbins=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">defaultlimits=</span><span class="s3">None, </span><span class="s1">weights=</span><span class="s3">None,</span>
               <span class="s1">printextras=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Create a histogram. 
 
    Separate the range into several bins and return the number of instances 
    in each bin. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of scores which will be put into bins. 
    numbins : int, optional 
        The number of bins to use for the histogram. Default is 10. 
    defaultlimits : tuple (lower, upper), optional 
        The lower and upper values for the range of the histogram. 
        If no value is given, a range slightly larger than the range of the 
        values in a is used. Specifically ``(a.min() - s, a.max() + s)``, 
        where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``. 
    weights : array_like, optional 
        The weights for each value in `a`. Default is None, which gives each 
        value a weight of 1.0 
    printextras : bool, optional 
        If True, if there are extra points (i.e. the points that fall outside 
        the bin limits) a warning is raised saying how many of those points 
        there are.  Default is False. 
 
    Returns 
    ------- 
    count : ndarray 
        Number of points (or sum of weights) in each bin. 
    lowerlimit : float 
        Lowest value of histogram, the lower limit of the first bin. 
    binsize : float 
        The size of the bins (all bins have the same size). 
    extrapoints : int 
        The number of points outside the range of the histogram. 
 
    See Also 
    -------- 
    numpy.histogram 
 
    Notes 
    ----- 
    This histogram is based on numpy's histogram but has a larger range by 
    default if default limits is not set. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.ravel(a)</span>
    <span class="s3">if </span><span class="s1">defaultlimits </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0"># handle empty arrays. Undetermined range, so use 0-1.</span>
            <span class="s1">defaultlimits = (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># no range given, so use values in `a`</span>
            <span class="s1">data_min = a.min()</span>
            <span class="s1">data_max = a.max()</span>
            <span class="s0"># Have bins extend past min and max values slightly</span>
            <span class="s1">s = (data_max - data_min) / (</span><span class="s5">2. </span><span class="s1">* (numbins - </span><span class="s5">1.</span><span class="s1">))</span>
            <span class="s1">defaultlimits = (data_min - s</span><span class="s3">, </span><span class="s1">data_max + s)</span>

    <span class="s0"># use numpy's histogram method to compute bins</span>
    <span class="s1">hist</span><span class="s3">, </span><span class="s1">bin_edges = np.histogram(a</span><span class="s3">, </span><span class="s1">bins=numbins</span><span class="s3">, </span><span class="s1">range=defaultlimits</span><span class="s3">,</span>
                                   <span class="s1">weights=weights)</span>
    <span class="s0"># hist are not always floats, convert to keep with old output</span>
    <span class="s1">hist = np.array(hist</span><span class="s3">, </span><span class="s1">dtype=float)</span>
    <span class="s0"># fixed width for bins is assumed, as numpy's histogram gives</span>
    <span class="s0"># fixed width bins for int values for 'bins'</span>
    <span class="s1">binsize = bin_edges[</span><span class="s5">1</span><span class="s1">] - bin_edges[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0"># calculate number of extra points</span>
    <span class="s1">extrapoints = len([v </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">a</span>
                       <span class="s3">if </span><span class="s1">defaultlimits[</span><span class="s5">0</span><span class="s1">] &gt; v </span><span class="s3">or </span><span class="s1">v &gt; defaultlimits[</span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s3">if </span><span class="s1">extrapoints &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">printextras:</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;Points outside given histogram range = %s&quot;</span>
                      <span class="s1">% extrapoints)</span>

    <span class="s3">return </span><span class="s1">HistogramResult(hist</span><span class="s3">, </span><span class="s1">defaultlimits[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">binsize</span><span class="s3">, </span><span class="s1">extrapoints)</span>


<span class="s1">CumfreqResult = namedtuple(</span><span class="s4">'CumfreqResult'</span><span class="s3">,</span>
                           <span class="s1">(</span><span class="s4">'cumcount'</span><span class="s3">, </span><span class="s4">'lowerlimit'</span><span class="s3">, </span><span class="s4">'binsize'</span><span class="s3">,</span>
                            <span class="s4">'extrapoints'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">cumfreq(a</span><span class="s3">, </span><span class="s1">numbins=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">defaultreallimits=</span><span class="s3">None, </span><span class="s1">weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return a cumulative frequency histogram, using the histogram function. 
 
    A cumulative histogram is a mapping that counts the cumulative number of 
    observations in all of the bins up to the specified bin. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    numbins : int, optional 
        The number of bins to use for the histogram. Default is 10. 
    defaultreallimits : tuple (lower, upper), optional 
        The lower and upper values for the range of the histogram. 
        If no value is given, a range slightly larger than the range of the 
        values in `a` is used. Specifically ``(a.min() - s, a.max() + s)``, 
        where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``. 
    weights : array_like, optional 
        The weights for each value in `a`. Default is None, which gives each 
        value a weight of 1.0 
 
    Returns 
    ------- 
    cumcount : ndarray 
        Binned values of cumulative frequency. 
    lowerlimit : float 
        Lower real limit 
    binsize : float 
        Width of each bin. 
    extrapoints : int 
        Extra points. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = [1, 4, 2, 1, 3, 1] 
    &gt;&gt;&gt; res = stats.cumfreq(x, numbins=4, defaultreallimits=(1.5, 5)) 
    &gt;&gt;&gt; res.cumcount 
    array([ 1.,  2.,  3.,  3.]) 
    &gt;&gt;&gt; res.extrapoints 
    3 
 
    Create a normal distribution with 1000 random values 
 
    &gt;&gt;&gt; samples = stats.norm.rvs(size=1000, random_state=rng) 
 
    Calculate cumulative frequencies 
 
    &gt;&gt;&gt; res = stats.cumfreq(samples, numbins=25) 
 
    Calculate space of values for x 
 
    &gt;&gt;&gt; x = res.lowerlimit + np.linspace(0, res.binsize*res.cumcount.size, 
    ...                                  res.cumcount.size) 
 
    Plot histogram and cumulative histogram 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(10, 4)) 
    &gt;&gt;&gt; ax1 = fig.add_subplot(1, 2, 1) 
    &gt;&gt;&gt; ax2 = fig.add_subplot(1, 2, 2) 
    &gt;&gt;&gt; ax1.hist(samples, bins=25) 
    &gt;&gt;&gt; ax1.set_title('Histogram') 
    &gt;&gt;&gt; ax2.bar(x, res.cumcount, width=res.binsize) 
    &gt;&gt;&gt; ax2.set_title('Cumulative histogram') 
    &gt;&gt;&gt; ax2.set_xlim([x.min(), x.max()]) 
 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">h</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">e = _histogram(a</span><span class="s3">, </span><span class="s1">numbins</span><span class="s3">, </span><span class="s1">defaultreallimits</span><span class="s3">, </span><span class="s1">weights=weights)</span>
    <span class="s1">cumhist = np.cumsum(h * </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">CumfreqResult(cumhist</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">e)</span>


<span class="s1">RelfreqResult = namedtuple(</span><span class="s4">'RelfreqResult'</span><span class="s3">,</span>
                           <span class="s1">(</span><span class="s4">'frequency'</span><span class="s3">, </span><span class="s4">'lowerlimit'</span><span class="s3">, </span><span class="s4">'binsize'</span><span class="s3">,</span>
                            <span class="s4">'extrapoints'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">relfreq(a</span><span class="s3">, </span><span class="s1">numbins=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">defaultreallimits=</span><span class="s3">None, </span><span class="s1">weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return a relative frequency histogram, using the histogram function. 
 
    A relative frequency  histogram is a mapping of the number of 
    observations in each of the bins relative to the total of observations. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    numbins : int, optional 
        The number of bins to use for the histogram. Default is 10. 
    defaultreallimits : tuple (lower, upper), optional 
        The lower and upper values for the range of the histogram. 
        If no value is given, a range slightly larger than the range of the 
        values in a is used. Specifically ``(a.min() - s, a.max() + s)``, 
        where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``. 
    weights : array_like, optional 
        The weights for each value in `a`. Default is None, which gives each 
        value a weight of 1.0 
 
    Returns 
    ------- 
    frequency : ndarray 
        Binned values of relative frequency. 
    lowerlimit : float 
        Lower real limit. 
    binsize : float 
        Width of each bin. 
    extrapoints : int 
        Extra points. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; a = np.array([2, 4, 1, 2, 3, 2]) 
    &gt;&gt;&gt; res = stats.relfreq(a, numbins=4) 
    &gt;&gt;&gt; res.frequency 
    array([ 0.16666667, 0.5       , 0.16666667,  0.16666667]) 
    &gt;&gt;&gt; np.sum(res.frequency)  # relative frequencies should add up to 1 
    1.0 
 
    Create a normal distribution with 1000 random values 
 
    &gt;&gt;&gt; samples = stats.norm.rvs(size=1000, random_state=rng) 
 
    Calculate relative frequencies 
 
    &gt;&gt;&gt; res = stats.relfreq(samples, numbins=25) 
 
    Calculate space of values for x 
 
    &gt;&gt;&gt; x = res.lowerlimit + np.linspace(0, res.binsize*res.frequency.size, 
    ...                                  res.frequency.size) 
 
    Plot relative frequency histogram 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(5, 4)) 
    &gt;&gt;&gt; ax = fig.add_subplot(1, 1, 1) 
    &gt;&gt;&gt; ax.bar(x, res.frequency, width=res.binsize) 
    &gt;&gt;&gt; ax.set_title('Relative frequency histogram') 
    &gt;&gt;&gt; ax.set_xlim([x.min(), x.max()]) 
 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asanyarray(a)</span>
    <span class="s1">h</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">e = _histogram(a</span><span class="s3">, </span><span class="s1">numbins</span><span class="s3">, </span><span class="s1">defaultreallimits</span><span class="s3">, </span><span class="s1">weights=weights)</span>
    <span class="s1">h = h / a.shape[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">return </span><span class="s1">RelfreqResult(h</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">e)</span>


<span class="s0">#####################################</span>
<span class="s0">#        VARIABILITY FUNCTIONS      #</span>
<span class="s0">#####################################</span>

<span class="s3">def </span><span class="s1">obrientransform(*samples):</span>
    <span class="s2">&quot;&quot;&quot;Compute the O'Brien transform on input data (any number of arrays). 
 
    Used to test for homogeneity of variance prior to running one-way stats. 
    Each array in ``*samples`` is one level of a factor. 
    If `f_oneway` is run on the transformed data and found significant, 
    the variances are unequal.  From Maxwell and Delaney [1]_, p.112. 
 
    Parameters 
    ---------- 
    sample1, sample2, ... : array_like 
        Any number of arrays. 
 
    Returns 
    ------- 
    obrientransform : ndarray 
        Transformed data for use in an ANOVA.  The first dimension 
        of the result corresponds to the sequence of transformed 
        arrays.  If the arrays given are all 1-D of the same length, 
        the return value is a 2-D array; otherwise it is a 1-D array 
        of type object, with each element being an ndarray. 
 
    References 
    ---------- 
    .. [1] S. E. Maxwell and H. D. Delaney, &quot;Designing Experiments and 
           Analyzing Data: A Model Comparison Perspective&quot;, Wadsworth, 1990. 
 
    Examples 
    -------- 
    We'll test the following data sets for differences in their variance. 
 
    &gt;&gt;&gt; x = [10, 11, 13, 9, 7, 12, 12, 9, 10] 
    &gt;&gt;&gt; y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15] 
 
    Apply the O'Brien transform to the data. 
 
    &gt;&gt;&gt; from scipy.stats import obrientransform 
    &gt;&gt;&gt; tx, ty = obrientransform(x, y) 
 
    Use `scipy.stats.f_oneway` to apply a one-way ANOVA test to the 
    transformed data. 
 
    &gt;&gt;&gt; from scipy.stats import f_oneway 
    &gt;&gt;&gt; F, p = f_oneway(tx, ty) 
    &gt;&gt;&gt; p 
    0.1314139477040335 
 
    If we require that ``p &lt; 0.05`` for significance, we cannot conclude 
    that the variances are different. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">TINY = np.sqrt(np.finfo(float).eps)</span>

    <span class="s0"># `arrays` will hold the transformed arguments.</span>
    <span class="s1">arrays = []</span>
    <span class="s1">sLast = </span><span class="s3">None</span>

    <span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples:</span>
        <span class="s1">a = np.asarray(sample)</span>
        <span class="s1">n = len(a)</span>
        <span class="s1">mu = np.mean(a)</span>
        <span class="s1">sq = (a - mu)**</span><span class="s5">2</span>
        <span class="s1">sumsq = sq.sum()</span>

        <span class="s0"># The O'Brien transform.</span>
        <span class="s1">t = ((n - </span><span class="s5">1.5</span><span class="s1">) * n * sq - </span><span class="s5">0.5 </span><span class="s1">* sumsq) / ((n - </span><span class="s5">1</span><span class="s1">) * (n - </span><span class="s5">2</span><span class="s1">))</span>

        <span class="s0"># Check that the mean of the transformed data is equal to the</span>
        <span class="s0"># original variance.</span>
        <span class="s1">var = sumsq / (n - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">abs(var - np.mean(t)) &gt; TINY:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Lack of convergence in obrientransform.'</span><span class="s1">)</span>

        <span class="s1">arrays.append(t)</span>
        <span class="s1">sLast = a.shape</span>

    <span class="s3">if </span><span class="s1">sLast:</span>
        <span class="s3">for </span><span class="s1">arr </span><span class="s3">in </span><span class="s1">arrays[:-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">sLast != arr.shape:</span>
                <span class="s3">return </span><span class="s1">np.array(arrays</span><span class="s3">, </span><span class="s1">dtype=object)</span>
    <span class="s3">return </span><span class="s1">np.array(arrays)</span>


<span class="s1">@_axis_nan_policy_factory(</span>
    <span class="s3">lambda </span><span class="s1">x: x</span><span class="s3">, </span><span class="s1">result_to_tuple=</span><span class="s3">lambda </span><span class="s1">x: (x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">too_small=</span><span class="s5">1</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">sem(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute standard error of the mean. 
 
    Calculate the standard error of the mean (or standard error of 
    measurement) of the values in the input array. 
 
    Parameters 
    ---------- 
    a : array_like 
        An array containing the values for which the standard error is 
        returned. 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over 
        the whole array `a`. 
    ddof : int, optional 
        Delta degrees-of-freedom. How many degrees of freedom to adjust 
        for bias in limited samples relative to the population estimate 
        of variance. Defaults to 1. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    s : ndarray or float 
        The standard error of the mean in the sample(s), along the input axis. 
 
    Notes 
    ----- 
    The default value for `ddof` is different to the default (0) used by other 
    ddof containing routines, such as np.std and np.nanstd. 
 
    Examples 
    -------- 
    Find standard error along the first axis: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; a = np.arange(20).reshape(5,4) 
    &gt;&gt;&gt; stats.sem(a) 
    array([ 2.8284,  2.8284,  2.8284,  2.8284]) 
 
    Find standard error across the whole array, using n degrees of freedom: 
 
    &gt;&gt;&gt; stats.sem(a, axis=None, ddof=0) 
    1.2893796958227628 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n = a.shape[axis]</span>
    <span class="s1">s = np.std(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">ddof=ddof) / np.sqrt(n)</span>
    <span class="s3">return </span><span class="s1">s</span>


<span class="s3">def </span><span class="s1">_isconst(x):</span>
    <span class="s2">&quot;&quot;&quot; 
    Check if all values in x are the same.  nans are ignored. 
 
    x must be a 1d array. 
 
    The return value is a 1d array with length 1, so it can be used 
    in np.apply_along_axis. 
    &quot;&quot;&quot;</span>
    <span class="s1">y = x[~np.isnan(x)]</span>
    <span class="s3">if </span><span class="s1">y.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array([</span><span class="s3">True</span><span class="s1">])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">(y[</span><span class="s5">0</span><span class="s1">] == y).all(keepdims=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_quiet_nanmean(x):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute nanmean for the 1d array x, but quietly return nan if x is all nan. 
 
    The return value is a 1d array with length 1, so it can be used 
    in np.apply_along_axis. 
    &quot;&quot;&quot;</span>
    <span class="s1">y = x[~np.isnan(x)]</span>
    <span class="s3">if </span><span class="s1">y.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array([np.nan])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.mean(y</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_quiet_nanstd(x</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute nanstd for the 1d array x, but quietly return nan if x is all nan. 
 
    The return value is a 1d array with length 1, so it can be used 
    in np.apply_along_axis. 
    &quot;&quot;&quot;</span>
    <span class="s1">y = x[~np.isnan(x)]</span>
    <span class="s3">if </span><span class="s1">y.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array([np.nan])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.std(y</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True, </span><span class="s1">ddof=ddof)</span>


<span class="s3">def </span><span class="s1">zscore(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute the z score. 
 
    Compute the z score of each value in the sample, relative to the 
    sample mean and standard deviation. 
 
    Parameters 
    ---------- 
    a : array_like 
        An array like object containing the sample data. 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over 
        the whole array `a`. 
    ddof : int, optional 
        Degrees of freedom correction in the calculation of the 
        standard deviation. Default is 0. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 'propagate' returns nan, 
        'raise' throws an error, 'omit' performs the calculations ignoring nan 
        values. Default is 'propagate'.  Note that when the value is 'omit', 
        nans in the input also propagate to the output, but they do not affect 
        the z-scores computed for the non-nan values. 
 
    Returns 
    ------- 
    zscore : array_like 
        The z-scores, standardized by mean and standard deviation of 
        input array `a`. 
 
    See Also 
    -------- 
    numpy.mean : Arithmetic average 
    numpy.std : Arithmetic standard deviation 
    scipy.stats.gzscore : Geometric standard score 
 
    Notes 
    ----- 
    This function preserves ndarray subclasses, and works also with 
    matrices and masked arrays (it uses `asanyarray` instead of 
    `asarray` for parameters). 
 
    References 
    ---------- 
    .. [1] &quot;Standard score&quot;, *Wikipedia*, 
           https://en.wikipedia.org/wiki/Standard_score. 
    .. [2] Huck, S. W., Cross, T. L., Clark, S. B, &quot;Overcoming misconceptions 
           about Z-scores&quot;, Teaching Statistics, vol. 8, pp. 38-40, 1986 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091, 
    ...                0.1954,  0.6307,  0.6599,  0.1065,  0.0508]) 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; stats.zscore(a) 
    array([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786, 
            0.6748, -1.1488, -1.3324]) 
 
    Computing along a specified axis, using n-1 degrees of freedom 
    (``ddof=1``) to calculate the standard deviation: 
 
    &gt;&gt;&gt; b = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608], 
    ...               [ 0.7149,  0.0775,  0.6072,  0.9656], 
    ...               [ 0.6341,  0.1403,  0.9759,  0.4064], 
    ...               [ 0.5918,  0.6948,  0.904 ,  0.3721], 
    ...               [ 0.0921,  0.2481,  0.1188,  0.1366]]) 
    &gt;&gt;&gt; stats.zscore(b, axis=1, ddof=1) 
    array([[-0.19264823, -1.28415119,  1.07259584,  0.40420358], 
           [ 0.33048416, -1.37380874,  0.04251374,  1.00081084], 
           [ 0.26796377, -1.12598418,  1.23283094, -0.37481053], 
           [-0.22095197,  0.24468594,  1.19042819, -1.21416216], 
           [-0.82780366,  1.4457416 , -0.43867764, -0.1792603 ]]) 
 
    An example with `nan_policy='omit'`: 
 
    &gt;&gt;&gt; x = np.array([[25.11, 30.10, np.nan, 32.02, 43.15], 
    ...               [14.95, 16.06, 121.25, 94.35, 29.81]]) 
    &gt;&gt;&gt; stats.zscore(x, axis=1, nan_policy='omit') 
    array([[-1.13490897, -0.37830299,         nan, -0.08718406,  1.60039602], 
           [-0.91611681, -0.89090508,  1.4983032 ,  0.88731639, -0.5785977 ]]) 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">zmap(a</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">ddof=ddof</span><span class="s3">, </span><span class="s1">nan_policy=nan_policy)</span>


<span class="s3">def </span><span class="s1">gzscore(a</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute the geometric standard score. 
 
    Compute the geometric z score of each strictly positive value in the 
    sample, relative to the geometric mean and standard deviation. 
    Mathematically the geometric z score can be evaluated as:: 
 
        gzscore = log(a/gmu) / log(gsigma) 
 
    where ``gmu`` (resp. ``gsigma``) is the geometric mean (resp. standard 
    deviation). 
 
    Parameters 
    ---------- 
    a : array_like 
        Sample data. 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over 
        the whole array `a`. 
    ddof : int, optional 
        Degrees of freedom correction in the calculation of the 
        standard deviation. Default is 0. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 'propagate' returns nan, 
        'raise' throws an error, 'omit' performs the calculations ignoring nan 
        values. Default is 'propagate'.  Note that when the value is 'omit', 
        nans in the input also propagate to the output, but they do not affect 
        the geometric z scores computed for the non-nan values. 
 
    Returns 
    ------- 
    gzscore : array_like 
        The geometric z scores, standardized by geometric mean and geometric 
        standard deviation of input array `a`. 
 
    See Also 
    -------- 
    gmean : Geometric mean 
    gstd : Geometric standard deviation 
    zscore : Standard score 
 
    Notes 
    ----- 
    This function preserves ndarray subclasses, and works also with 
    matrices and masked arrays (it uses ``asanyarray`` instead of 
    ``asarray`` for parameters). 
 
    .. versionadded:: 1.8 
 
    References 
    ---------- 
    .. [1] &quot;Geometric standard score&quot;, *Wikipedia*, 
           https://en.wikipedia.org/wiki/Geometric_standard_deviation#Geometric_standard_score. 
 
    Examples 
    -------- 
    Draw samples from a log-normal distribution: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import zscore, gzscore 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; mu, sigma = 3., 1.  # mean and standard deviation 
    &gt;&gt;&gt; x = rng.lognormal(mu, sigma, size=500) 
 
    Display the histogram of the samples: 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hist(x, 50) 
    &gt;&gt;&gt; plt.show() 
 
    Display the histogram of the samples standardized by the classical zscore. 
    Distribution is rescaled but its shape is unchanged. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hist(zscore(x), 50) 
    &gt;&gt;&gt; plt.show() 
 
    Demonstrate that the distribution of geometric zscores is rescaled and 
    quasinormal: 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hist(gzscore(x), 50) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asanyarray(a)</span>
    <span class="s1">log = ma.log </span><span class="s3">if </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">ma.MaskedArray) </span><span class="s3">else </span><span class="s1">np.log</span>

    <span class="s3">return </span><span class="s1">zscore(log(a)</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">ddof=ddof</span><span class="s3">, </span><span class="s1">nan_policy=nan_policy)</span>


<span class="s3">def </span><span class="s1">zmap(scores</span><span class="s3">, </span><span class="s1">compare</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Calculate the relative z-scores. 
 
    Return an array of z-scores, i.e., scores that are standardized to 
    zero mean and unit variance, where mean and variance are calculated 
    from the comparison array. 
 
    Parameters 
    ---------- 
    scores : array_like 
        The input for which z-scores are calculated. 
    compare : array_like 
        The input from which the mean and standard deviation of the 
        normalization are taken; assumed to have the same dimension as 
        `scores`. 
    axis : int or None, optional 
        Axis over which mean and variance of `compare` are calculated. 
        Default is 0. If None, compute over the whole array `scores`. 
    ddof : int, optional 
        Degrees of freedom correction in the calculation of the 
        standard deviation. Default is 0. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle the occurrence of nans in `compare`. 
        'propagate' returns nan, 'raise' raises an exception, 'omit' 
        performs the calculations ignoring nan values. Default is 
        'propagate'. Note that when the value is 'omit', nans in `scores` 
        also propagate to the output, but they do not affect the z-scores 
        computed for the non-nan values. 
 
    Returns 
    ------- 
    zscore : array_like 
        Z-scores, in the same shape as `scores`. 
 
    Notes 
    ----- 
    This function preserves ndarray subclasses, and works also with 
    matrices and masked arrays (it uses `asanyarray` instead of 
    `asarray` for parameters). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import zmap 
    &gt;&gt;&gt; a = [0.5, 2.0, 2.5, 3] 
    &gt;&gt;&gt; b = [0, 1, 2, 3, 4] 
    &gt;&gt;&gt; zmap(a, b) 
    array([-1.06066017,  0.        ,  0.35355339,  0.70710678]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asanyarray(compare)</span>

    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.empty(a.shape)</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">mn = _quiet_nanmean(a.ravel())</span>
            <span class="s1">std = _quiet_nanstd(a.ravel()</span><span class="s3">, </span><span class="s1">ddof=ddof)</span>
            <span class="s1">isconst = _isconst(a.ravel())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">mn = np.apply_along_axis(_quiet_nanmean</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a)</span>
            <span class="s1">std = np.apply_along_axis(_quiet_nanstd</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">ddof=ddof)</span>
            <span class="s1">isconst = np.apply_along_axis(_isconst</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">mn = a.mean(axis=axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">std = a.std(axis=axis</span><span class="s3">, </span><span class="s1">ddof=ddof</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">isconst = (a.item(</span><span class="s5">0</span><span class="s1">) == a).all()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">isconst = (_first(a</span><span class="s3">, </span><span class="s1">axis) == a).all(axis=axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s0"># Set std deviations that are 0 to 1 to avoid division by 0.</span>
    <span class="s1">std[isconst] = </span><span class="s5">1.0</span>
    <span class="s1">z = (scores - mn) / std</span>
    <span class="s0"># Set the outputs associated with a constant input to nan.</span>
    <span class="s1">z[np.broadcast_to(isconst</span><span class="s3">, </span><span class="s1">z.shape)] = np.nan</span>
    <span class="s3">return </span><span class="s1">z</span>


<span class="s3">def </span><span class="s1">gstd(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Calculate the geometric standard deviation of an array. 
 
    The geometric standard deviation describes the spread of a set of numbers 
    where the geometric mean is preferred. It is a multiplicative factor, and 
    so a dimensionless quantity. 
 
    It is defined as the exponent of the standard deviation of ``log(a)``. 
    Mathematically the population geometric standard deviation can be 
    evaluated as:: 
 
        gstd = exp(std(log(a))) 
 
    .. versionadded:: 1.3.0 
 
    Parameters 
    ---------- 
    a : array_like 
        An array like object containing the sample data. 
    axis : int, tuple or None, optional 
        Axis along which to operate. Default is 0. If None, compute over 
        the whole array `a`. 
    ddof : int, optional 
        Degree of freedom correction in the calculation of the 
        geometric standard deviation. Default is 1. 
 
    Returns 
    ------- 
    gstd : ndarray or float 
        An array of the geometric standard deviation. If `axis` is None or `a` 
        is a 1d array a float is returned. 
 
    See Also 
    -------- 
    gmean : Geometric mean 
    numpy.std : Standard deviation 
    gzscore : Geometric standard score 
 
    Notes 
    ----- 
    As the calculation requires the use of logarithms the geometric standard 
    deviation only supports strictly positive values. Any non-positive or 
    infinite values will raise a `ValueError`. 
    The geometric standard deviation is sometimes confused with the exponent of 
    the standard deviation, ``exp(std(a))``. Instead the geometric standard 
    deviation is ``exp(std(log(a)))``. 
    The default value for `ddof` is different to the default value (0) used 
    by other ddof containing functions, such as ``np.std`` and ``np.nanstd``. 
 
    References 
    ---------- 
    .. [1] &quot;Geometric standard deviation&quot;, *Wikipedia*, 
           https://en.wikipedia.org/wiki/Geometric_standard_deviation. 
    .. [2] Kirkwood, T. B., &quot;Geometric means and measures of dispersion&quot;, 
           Biometrics, vol. 35, pp. 908-909, 1979 
 
    Examples 
    -------- 
    Find the geometric standard deviation of a log-normally distributed sample. 
    Note that the standard deviation of the distribution is one, on a 
    log scale this evaluates to approximately ``exp(1)``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import gstd 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; sample = rng.lognormal(mean=0, sigma=1, size=1000) 
    &gt;&gt;&gt; gstd(sample) 
    2.810010162475324 
 
    Compute the geometric standard deviation of a multidimensional array and 
    of a given axis. 
 
    &gt;&gt;&gt; a = np.arange(1, 25).reshape(2, 3, 4) 
    &gt;&gt;&gt; gstd(a, axis=None) 
    2.2944076136018947 
    &gt;&gt;&gt; gstd(a, axis=2) 
    array([[1.82424757, 1.22436866, 1.13183117], 
           [1.09348306, 1.07244798, 1.05914985]]) 
    &gt;&gt;&gt; gstd(a, axis=(1,2)) 
    array([2.12939215, 1.22120169]) 
 
    The geometric standard deviation further handles masked arrays. 
 
    &gt;&gt;&gt; a = np.arange(1, 25).reshape(2, 3, 4) 
    &gt;&gt;&gt; ma = np.ma.masked_where(a &gt; 16, a) 
    &gt;&gt;&gt; ma 
    masked_array( 
      data=[[[1, 2, 3, 4], 
             [5, 6, 7, 8], 
             [9, 10, 11, 12]], 
            [[13, 14, 15, 16], 
             [--, --, --, --], 
             [--, --, --, --]]], 
      mask=[[[False, False, False, False], 
             [False, False, False, False], 
             [False, False, False, False]], 
            [[False, False, False, False], 
             [ True,  True,  True,  True], 
             [ True,  True,  True,  True]]], 
      fill_value=999999) 
    &gt;&gt;&gt; gstd(ma, axis=2) 
    masked_array( 
      data=[[1.8242475707663655, 1.2243686572447428, 1.1318311657788478], 
            [1.0934830582350938, --, --]], 
      mask=[[False, False, False], 
            [False,  True,  True]], 
      fill_value=999999) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asanyarray(a)</span>
    <span class="s1">log = ma.log </span><span class="s3">if </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">ma.MaskedArray) </span><span class="s3">else </span><span class="s1">np.log</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;error&quot;</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s3">return </span><span class="s1">np.exp(np.std(log(a)</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">ddof=ddof))</span>
    <span class="s3">except </span><span class="s1">RuntimeWarning </span><span class="s3">as </span><span class="s1">w:</span>
        <span class="s3">if </span><span class="s1">np.isinf(a).any():</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">'Infinite value encountered. The geometric standard deviation '</span>
                <span class="s4">'is defined for strictly positive values only.'</span>
            <span class="s1">) </span><span class="s3">from </span><span class="s1">w</span>
        <span class="s1">a_nan = np.isnan(a)</span>
        <span class="s1">a_nan_any = a_nan.any()</span>
        <span class="s0"># exclude NaN's from negativity check, but</span>
        <span class="s0"># avoid expensive masking for arrays with no NaN</span>
        <span class="s3">if </span><span class="s1">((a_nan_any </span><span class="s3">and </span><span class="s1">np.less_equal(np.nanmin(a)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)) </span><span class="s3">or</span>
                <span class="s1">(</span><span class="s3">not </span><span class="s1">a_nan_any </span><span class="s3">and </span><span class="s1">np.less_equal(a</span><span class="s3">, </span><span class="s5">0</span><span class="s1">).any())):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">'Non positive value encountered. The geometric standard '</span>
                <span class="s4">'deviation is defined for strictly positive values only.'</span>
            <span class="s1">) </span><span class="s3">from </span><span class="s1">w</span>
        <span class="s3">elif </span><span class="s4">'Degrees of freedom &lt;= 0 for slice' </span><span class="s1">== str(w):</span>
            <span class="s3">raise </span><span class="s1">ValueError(w) </span><span class="s3">from </span><span class="s1">w</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0">#  Remaining warnings don't need to be exceptions.</span>
            <span class="s3">return </span><span class="s1">np.exp(np.std(log(a</span><span class="s3">, </span><span class="s1">where=~a_nan)</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">ddof=ddof))</span>
    <span class="s3">except </span><span class="s1">TypeError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">'Invalid array input. The inputs could not be '</span>
            <span class="s4">'safely coerced to any supported types'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>


<span class="s0"># Private dictionary initialized only once at module level</span>
<span class="s0"># See https://en.wikipedia.org/wiki/Robust_measures_of_scale</span>
<span class="s1">_scale_conversions = {</span><span class="s4">'raw'</span><span class="s1">: </span><span class="s5">1.0</span><span class="s3">,</span>
                      <span class="s4">'normal'</span><span class="s1">: special.erfinv(</span><span class="s5">0.5</span><span class="s1">) * </span><span class="s5">2.0 </span><span class="s1">* math.sqrt(</span><span class="s5">2.0</span><span class="s1">)}</span>


<span class="s1">@_axis_nan_policy_factory(</span>
    <span class="s3">lambda </span><span class="s1">x: x</span><span class="s3">, </span><span class="s1">result_to_tuple=</span><span class="s3">lambda </span><span class="s1">x: (x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">default_axis=</span><span class="s3">None, </span><span class="s1">override={</span><span class="s4">'nan_propagation'</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">iqr(x</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None, </span><span class="s1">rng=(</span><span class="s5">25</span><span class="s3">, </span><span class="s5">75</span><span class="s1">)</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">,</span>
        <span class="s1">interpolation=</span><span class="s4">'linear'</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot; 
    Compute the interquartile range of the data along the specified axis. 
 
    The interquartile range (IQR) is the difference between the 75th and 
    25th percentile of the data. It is a measure of the dispersion 
    similar to standard deviation or variance, but is much more robust 
    against outliers [2]_. 
 
    The ``rng`` parameter allows this function to compute other 
    percentile ranges than the actual IQR. For example, setting 
    ``rng=(0, 100)`` is equivalent to `numpy.ptp`. 
 
    The IQR of an empty array is `np.nan`. 
 
    .. versionadded:: 0.18.0 
 
    Parameters 
    ---------- 
    x : array_like 
        Input array or object that can be converted to an array. 
    axis : int or sequence of int, optional 
        Axis along which the range is computed. The default is to 
        compute the IQR for the entire array. 
    rng : Two-element sequence containing floats in range of [0,100] optional 
        Percentiles over which to compute the range. Each must be 
        between 0 and 100, inclusive. The default is the true IQR: 
        ``(25, 75)``. The order of the elements is not important. 
    scale : scalar or str, optional 
        The numerical value of scale will be divided out of the final 
        result. The following string values are recognized: 
 
          * 'raw' : No scaling, just return the raw IQR. 
            **Deprecated!**  Use ``scale=1`` instead. 
          * 'normal' : Scale by 
            :math:`2 \sqrt{2} erf^{-1}(\frac{1}{2}) \approx 1.349`. 
 
        The default is 1.0. The use of ``scale='raw'`` is deprecated infavor 
        of ``scale=1`` and will raise an error in SciPy 1.12.0. 
        Array-like `scale` is also allowed, as long 
        as it broadcasts correctly to the output such that 
        ``out / scale`` is a valid operation. The output dimensions 
        depend on the input array, `x`, the `axis` argument, and the 
        `keepdims` flag. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
    interpolation : str, optional 
 
        Specifies the interpolation method to use when the percentile 
        boundaries lie between two data points ``i`` and ``j``. 
        The following options are available (default is 'linear'): 
 
          * 'linear': ``i + (j - i)*fraction``, where ``fraction`` is the 
            fractional part of the index surrounded by ``i`` and ``j``. 
          * 'lower': ``i``. 
          * 'higher': ``j``. 
          * 'nearest': ``i`` or ``j`` whichever is nearest. 
          * 'midpoint': ``(i + j)/2``. 
 
        For NumPy &gt;= 1.22.0, the additional options provided by the ``method`` 
        keyword of `numpy.percentile` are also valid. 
 
    keepdims : bool, optional 
        If this is set to True, the reduced axes are left in the 
        result as dimensions with size one. With this option, the result 
        will broadcast correctly against the original array `x`. 
 
    Returns 
    ------- 
    iqr : scalar or ndarray 
        If ``axis=None``, a scalar is returned. If the input contains 
        integers or floats of smaller precision than ``np.float64``, then the 
        output data-type is ``np.float64``. Otherwise, the output data-type is 
        the same as that of the input. 
 
    See Also 
    -------- 
    numpy.std, numpy.var 
 
    References 
    ---------- 
    .. [1] &quot;Interquartile range&quot; https://en.wikipedia.org/wiki/Interquartile_range 
    .. [2] &quot;Robust measures of scale&quot; https://en.wikipedia.org/wiki/Robust_measures_of_scale 
    .. [3] &quot;Quantile&quot; https://en.wikipedia.org/wiki/Quantile 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import iqr 
    &gt;&gt;&gt; x = np.array([[10, 7, 4], [3, 2, 1]]) 
    &gt;&gt;&gt; x 
    array([[10,  7,  4], 
           [ 3,  2,  1]]) 
    &gt;&gt;&gt; iqr(x) 
    4.0 
    &gt;&gt;&gt; iqr(x, axis=0) 
    array([ 3.5,  2.5,  1.5]) 
    &gt;&gt;&gt; iqr(x, axis=1) 
    array([ 3.,  1.]) 
    &gt;&gt;&gt; iqr(x, axis=1, keepdims=True) 
    array([[ 3.], 
           [ 1.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = asarray(x)</span>

    <span class="s0"># This check prevents percentile from raising an error later. Also, it is</span>
    <span class="s0"># consistent with `np.var` and `np.std`.</span>
    <span class="s3">if not </span><span class="s1">x.size:</span>
        <span class="s3">return </span><span class="s1">_get_nan(x)</span>

    <span class="s0"># An error may be raised here, so fail-fast, before doing lengthy</span>
    <span class="s0"># computations, even though `scale` is not used until later</span>
    <span class="s3">if </span><span class="s1">isinstance(scale</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">scale_key = scale.lower()</span>
        <span class="s3">if </span><span class="s1">scale_key </span><span class="s3">not in </span><span class="s1">_scale_conversions:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">scale</span><span class="s3">} </span><span class="s4">not a valid scale for `iqr`&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">scale_key == </span><span class="s4">'raw'</span><span class="s1">:</span>
            <span class="s1">msg = (</span><span class="s4">&quot;The use of 'scale=</span><span class="s3">\&quot;</span><span class="s4">raw</span><span class="s3">\&quot;</span><span class="s4">' is deprecated infavor of &quot;</span>
                   <span class="s4">&quot;'scale=1' and will raise an error in SciPy 1.12.0.&quot;</span><span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">scale = _scale_conversions[scale_key]</span>

    <span class="s0"># Select the percentile function to use based on nans and policy</span>
    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(x</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">percentile_func = np.nanpercentile</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">percentile_func = np.percentile</span>

    <span class="s3">if </span><span class="s1">len(rng) != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;quantile range must be two element sequence&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">np.isnan(rng).any():</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;range must not contain NaNs&quot;</span><span class="s1">)</span>

    <span class="s1">rng = sorted(rng)</span>
    <span class="s3">if </span><span class="s1">NumpyVersion(np.__version__) &gt;= </span><span class="s4">'1.22.0'</span><span class="s1">:</span>
        <span class="s1">pct = percentile_func(x</span><span class="s3">, </span><span class="s1">rng</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">method=interpolation</span><span class="s3">,</span>
                              <span class="s1">keepdims=keepdims)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">pct = percentile_func(x</span><span class="s3">, </span><span class="s1">rng</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">interpolation=interpolation</span><span class="s3">,</span>
                              <span class="s1">keepdims=keepdims)</span>
    <span class="s1">out = np.subtract(pct[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">pct[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s3">if </span><span class="s1">scale != </span><span class="s5">1.0</span><span class="s1">:</span>
        <span class="s1">out /= scale</span>

    <span class="s3">return </span><span class="s1">out</span>


<span class="s3">def </span><span class="s1">_mad_1d(x</span><span class="s3">, </span><span class="s1">center</span><span class="s3">, </span><span class="s1">nan_policy):</span>
    <span class="s0"># Median absolute deviation for 1-d array x.</span>
    <span class="s0"># This is a helper function for `median_abs_deviation`; it assumes its</span>
    <span class="s0"># arguments have been validated already.  In particular,  x must be a</span>
    <span class="s0"># 1-d numpy array, center must be callable, and if nan_policy is not</span>
    <span class="s0"># 'propagate', it is assumed to be 'omit', because 'raise' is handled</span>
    <span class="s0"># in `median_abs_deviation`.</span>
    <span class="s0"># No warning is generated if x is empty or all nan.</span>
    <span class="s1">isnan = np.isnan(x)</span>
    <span class="s3">if </span><span class="s1">isnan.any():</span>
        <span class="s3">if </span><span class="s1">nan_policy == </span><span class="s4">'propagate'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.nan</span>
        <span class="s1">x = x[~isnan]</span>
    <span class="s3">if </span><span class="s1">x.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0"># MAD of an empty array is nan.</span>
        <span class="s3">return </span><span class="s1">np.nan</span>
    <span class="s0"># Edge cases have been handled, so do the basic MAD calculation.</span>
    <span class="s1">med = center(x)</span>
    <span class="s1">mad = np.median(np.abs(x - med))</span>
    <span class="s3">return </span><span class="s1">mad</span>


<span class="s3">def </span><span class="s1">median_abs_deviation(x</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">center=np.median</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.0</span><span class="s3">,</span>
                         <span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot; 
    Compute the median absolute deviation of the data along the given axis. 
 
    The median absolute deviation (MAD, [1]_) computes the median over the 
    absolute deviations from the median. It is a measure of dispersion 
    similar to the standard deviation but more robust to outliers [2]_. 
 
    The MAD of an empty array is ``np.nan``. 
 
    .. versionadded:: 1.5.0 
 
    Parameters 
    ---------- 
    x : array_like 
        Input array or object that can be converted to an array. 
    axis : int or None, optional 
        Axis along which the range is computed. Default is 0. If None, compute 
        the MAD over the entire array. 
    center : callable, optional 
        A function that will return the central value. The default is to use 
        np.median. Any user defined function used will need to have the 
        function signature ``func(arr, axis)``. 
    scale : scalar or str, optional 
        The numerical value of scale will be divided out of the final 
        result. The default is 1.0. The string &quot;normal&quot; is also accepted, 
        and results in `scale` being the inverse of the standard normal 
        quantile function at 0.75, which is approximately 0.67449. 
        Array-like scale is also allowed, as long as it broadcasts correctly 
        to the output such that ``out / scale`` is a valid operation. The 
        output dimensions depend on the input array, `x`, and the `axis` 
        argument. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
        * 'propagate': returns nan 
        * 'raise': throws an error 
        * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    mad : scalar or ndarray 
        If ``axis=None``, a scalar is returned. If the input contains 
        integers or floats of smaller precision than ``np.float64``, then the 
        output data-type is ``np.float64``. Otherwise, the output data-type is 
        the same as that of the input. 
 
    See Also 
    -------- 
    numpy.std, numpy.var, numpy.median, scipy.stats.iqr, scipy.stats.tmean, 
    scipy.stats.tstd, scipy.stats.tvar 
 
    Notes 
    ----- 
    The `center` argument only affects the calculation of the central value 
    around which the MAD is calculated. That is, passing in ``center=np.mean`` 
    will calculate the MAD around the mean - it will not calculate the *mean* 
    absolute deviation. 
 
    The input array may contain `inf`, but if `center` returns `inf`, the 
    corresponding MAD for that data will be `nan`. 
 
    References 
    ---------- 
    .. [1] &quot;Median absolute deviation&quot;, 
           https://en.wikipedia.org/wiki/Median_absolute_deviation 
    .. [2] &quot;Robust measures of scale&quot;, 
           https://en.wikipedia.org/wiki/Robust_measures_of_scale 
 
    Examples 
    -------- 
    When comparing the behavior of `median_abs_deviation` with ``np.std``, 
    the latter is affected when we change a single value of an array to have an 
    outlier value while the MAD hardly changes: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = stats.norm.rvs(size=100, scale=1, random_state=123456) 
    &gt;&gt;&gt; x.std() 
    0.9973906394005013 
    &gt;&gt;&gt; stats.median_abs_deviation(x) 
    0.82832610097857 
    &gt;&gt;&gt; x[0] = 345.6 
    &gt;&gt;&gt; x.std() 
    34.42304872314415 
    &gt;&gt;&gt; stats.median_abs_deviation(x) 
    0.8323442311590675 
 
    Axis handling example: 
 
    &gt;&gt;&gt; x = np.array([[10, 7, 4], [3, 2, 1]]) 
    &gt;&gt;&gt; x 
    array([[10,  7,  4], 
           [ 3,  2,  1]]) 
    &gt;&gt;&gt; stats.median_abs_deviation(x) 
    array([3.5, 2.5, 1.5]) 
    &gt;&gt;&gt; stats.median_abs_deviation(x, axis=None) 
    2.0 
 
    Scale normal example: 
 
    &gt;&gt;&gt; x = stats.norm.rvs(size=1000000, scale=2, random_state=123456) 
    &gt;&gt;&gt; stats.median_abs_deviation(x) 
    1.3487398527041636 
    &gt;&gt;&gt; stats.median_abs_deviation(x, scale='normal') 
    1.9996446978061115 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">callable(center):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;The argument 'center' must be callable. The given &quot;</span>
                        <span class="s4">f&quot;value </span><span class="s3">{</span><span class="s1">repr(center)</span><span class="s3">} </span><span class="s4">is not callable.&quot;</span><span class="s1">)</span>

    <span class="s0"># An error may be raised here, so fail-fast, before doing lengthy</span>
    <span class="s0"># computations, even though `scale` is not used until later</span>
    <span class="s3">if </span><span class="s1">isinstance(scale</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s3">if </span><span class="s1">scale.lower() == </span><span class="s4">'normal'</span><span class="s1">:</span>
            <span class="s1">scale = </span><span class="s5">0.6744897501960817  </span><span class="s0"># special.ndtri(0.75)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">scale</span><span class="s3">} </span><span class="s4">is not a valid scale value.&quot;</span><span class="s1">)</span>

    <span class="s1">x = asarray(x)</span>

    <span class="s0"># Consistent with `np.var` and `np.std`.</span>
    <span class="s3">if not </span><span class="s1">x.size:</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.nan</span>
        <span class="s1">nan_shape = tuple(item </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">item </span><span class="s3">in </span><span class="s1">enumerate(x.shape) </span><span class="s3">if </span><span class="s1">i != axis)</span>
        <span class="s3">if </span><span class="s1">nan_shape == ():</span>
            <span class="s0"># Return nan, not array(nan)</span>
            <span class="s3">return </span><span class="s1">np.nan</span>
        <span class="s3">return </span><span class="s1">np.full(nan_shape</span><span class="s3">, </span><span class="s1">np.nan)</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(x</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">contains_nan:</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">mad = _mad_1d(x.ravel()</span><span class="s3">, </span><span class="s1">center</span><span class="s3">, </span><span class="s1">nan_policy)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">mad = np.apply_along_axis(_mad_1d</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">center</span><span class="s3">, </span><span class="s1">nan_policy)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">med = center(x</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">)</span>
            <span class="s1">mad = np.median(np.abs(x - med))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Wrap the call to center() in expand_dims() so it acts like</span>
            <span class="s0"># keepdims=True was used.</span>
            <span class="s1">med = np.expand_dims(center(x</span><span class="s3">, </span><span class="s1">axis=axis)</span><span class="s3">, </span><span class="s1">axis)</span>
            <span class="s1">mad = np.median(np.abs(x - med)</span><span class="s3">, </span><span class="s1">axis=axis)</span>

    <span class="s3">return </span><span class="s1">mad / scale</span>


<span class="s0">#####################################</span>
<span class="s0">#         TRIMMING FUNCTIONS        #</span>
<span class="s0">#####################################</span>


<span class="s1">SigmaclipResult = namedtuple(</span><span class="s4">'SigmaclipResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'clipped'</span><span class="s3">, </span><span class="s4">'lower'</span><span class="s3">, </span><span class="s4">'upper'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">sigmaclip(a</span><span class="s3">, </span><span class="s1">low=</span><span class="s5">4.</span><span class="s3">, </span><span class="s1">high=</span><span class="s5">4.</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Perform iterative sigma-clipping of array elements. 
 
    Starting from the full sample, all elements outside the critical range are 
    removed, i.e. all elements of the input array `c` that satisfy either of 
    the following conditions:: 
 
        c &lt; mean(c) - std(c)*low 
        c &gt; mean(c) + std(c)*high 
 
    The iteration continues with the updated sample until no 
    elements are outside the (updated) range. 
 
    Parameters 
    ---------- 
    a : array_like 
        Data array, will be raveled if not 1-D. 
    low : float, optional 
        Lower bound factor of sigma clipping. Default is 4. 
    high : float, optional 
        Upper bound factor of sigma clipping. Default is 4. 
 
    Returns 
    ------- 
    clipped : ndarray 
        Input array with clipped elements removed. 
    lower : float 
        Lower threshold value use for clipping. 
    upper : float 
        Upper threshold value use for clipping. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import sigmaclip 
    &gt;&gt;&gt; a = np.concatenate((np.linspace(9.5, 10.5, 31), 
    ...                     np.linspace(0, 20, 5))) 
    &gt;&gt;&gt; fact = 1.5 
    &gt;&gt;&gt; c, low, upp = sigmaclip(a, fact, fact) 
    &gt;&gt;&gt; c 
    array([  9.96666667,  10.        ,  10.03333333,  10.        ]) 
    &gt;&gt;&gt; c.var(), c.std() 
    (0.00055555555555555165, 0.023570226039551501) 
    &gt;&gt;&gt; low, c.mean() - fact*c.std(), c.min() 
    (9.9646446609406727, 9.9646446609406727, 9.9666666666666668) 
    &gt;&gt;&gt; upp, c.mean() + fact*c.std(), c.max() 
    (10.035355339059327, 10.035355339059327, 10.033333333333333) 
 
    &gt;&gt;&gt; a = np.concatenate((np.linspace(9.5, 10.5, 11), 
    ...                     np.linspace(-100, -50, 3))) 
    &gt;&gt;&gt; c, low, upp = sigmaclip(a, 1.8, 1.8) 
    &gt;&gt;&gt; (c == np.linspace(9.5, 10.5, 11)).all() 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.asarray(a).ravel()</span>
    <span class="s1">delta = </span><span class="s5">1</span>
    <span class="s3">while </span><span class="s1">delta:</span>
        <span class="s1">c_std = c.std()</span>
        <span class="s1">c_mean = c.mean()</span>
        <span class="s1">size = c.size</span>
        <span class="s1">critlower = c_mean - c_std * low</span>
        <span class="s1">critupper = c_mean + c_std * high</span>
        <span class="s1">c = c[(c &gt;= critlower) &amp; (c &lt;= critupper)]</span>
        <span class="s1">delta = size - c.size</span>

    <span class="s3">return </span><span class="s1">SigmaclipResult(c</span><span class="s3">, </span><span class="s1">critlower</span><span class="s3">, </span><span class="s1">critupper)</span>


<span class="s3">def </span><span class="s1">trimboth(a</span><span class="s3">, </span><span class="s1">proportiontocut</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Slice off a proportion of items from both ends of an array. 
 
    Slice off the passed proportion of items from both ends of the passed 
    array (i.e., with `proportiontocut` = 0.1, slices leftmost 10% **and** 
    rightmost 10% of scores). The trimmed values are the lowest and 
    highest ones. 
    Slice off less if proportion results in a non-integer slice index (i.e. 
    conservatively slices off `proportiontocut`). 
 
    Parameters 
    ---------- 
    a : array_like 
        Data to trim. 
    proportiontocut : float 
        Proportion (in range 0-1) of total data set to trim of each end. 
    axis : int or None, optional 
        Axis along which to trim data. Default is 0. If None, compute over 
        the whole array `a`. 
 
    Returns 
    ------- 
    out : ndarray 
        Trimmed version of array `a`. The order of the trimmed content 
        is undefined. 
 
    See Also 
    -------- 
    trim_mean 
 
    Examples 
    -------- 
    Create an array of 10 values and trim 10% of those values from each end: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
    &gt;&gt;&gt; stats.trimboth(a, 0.1) 
    array([1, 3, 2, 4, 5, 6, 7, 8]) 
 
    Note that the elements of the input array are trimmed by value, but the 
    output array is not necessarily sorted. 
 
    The proportion to trim is rounded down to the nearest integer. For 
    instance, trimming 25% of the values from each end of an array of 10 
    values will return an array of 6 values: 
 
    &gt;&gt;&gt; b = np.arange(10) 
    &gt;&gt;&gt; stats.trimboth(b, 1/4).shape 
    (6,) 
 
    Multidimensional arrays can be trimmed along any axis or across the entire 
    array: 
 
    &gt;&gt;&gt; c = [2, 4, 6, 8, 0, 1, 3, 5, 7, 9] 
    &gt;&gt;&gt; d = np.array([a, b, c]) 
    &gt;&gt;&gt; stats.trimboth(d, 0.4, axis=0).shape 
    (1, 10) 
    &gt;&gt;&gt; stats.trimboth(d, 0.4, axis=1).shape 
    (3, 2) 
    &gt;&gt;&gt; stats.trimboth(d, 0.4, axis=None).shape 
    (6,) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asarray(a)</span>

    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">a</span>

    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">a = a.ravel()</span>
        <span class="s1">axis = </span><span class="s5">0</span>

    <span class="s1">nobs = a.shape[axis]</span>
    <span class="s1">lowercut = int(proportiontocut * nobs)</span>
    <span class="s1">uppercut = nobs - lowercut</span>
    <span class="s3">if </span><span class="s1">(lowercut &gt;= uppercut):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Proportion too big.&quot;</span><span class="s1">)</span>

    <span class="s1">atmp = np.partition(a</span><span class="s3">, </span><span class="s1">(lowercut</span><span class="s3">, </span><span class="s1">uppercut - </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">sl = [slice(</span><span class="s3">None</span><span class="s1">)] * atmp.ndim</span>
    <span class="s1">sl[axis] = slice(lowercut</span><span class="s3">, </span><span class="s1">uppercut)</span>
    <span class="s3">return </span><span class="s1">atmp[tuple(sl)]</span>


<span class="s3">def </span><span class="s1">trim1(a</span><span class="s3">, </span><span class="s1">proportiontocut</span><span class="s3">, </span><span class="s1">tail=</span><span class="s4">'right'</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Slice off a proportion from ONE end of the passed array distribution. 
 
    If `proportiontocut` = 0.1, slices off 'leftmost' or 'rightmost' 
    10% of scores. The lowest or highest values are trimmed (depending on 
    the tail). 
    Slice off less if proportion results in a non-integer slice index 
    (i.e. conservatively slices off `proportiontocut` ). 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    proportiontocut : float 
        Fraction to cut off of 'left' or 'right' of distribution. 
    tail : {'left', 'right'}, optional 
        Defaults to 'right'. 
    axis : int or None, optional 
        Axis along which to trim data. Default is 0. If None, compute over 
        the whole array `a`. 
 
    Returns 
    ------- 
    trim1 : ndarray 
        Trimmed version of array `a`. The order of the trimmed content is 
        undefined. 
 
    Examples 
    -------- 
    Create an array of 10 values and trim 20% of its lowest values: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
    &gt;&gt;&gt; stats.trim1(a, 0.2, 'left') 
    array([2, 4, 3, 5, 6, 7, 8, 9]) 
 
    Note that the elements of the input array are trimmed by value, but the 
    output array is not necessarily sorted. 
 
    The proportion to trim is rounded down to the nearest integer. For 
    instance, trimming 25% of the values from an array of 10 values will 
    return an array of 8 values: 
 
    &gt;&gt;&gt; b = np.arange(10) 
    &gt;&gt;&gt; stats.trim1(b, 1/4).shape 
    (8,) 
 
    Multidimensional arrays can be trimmed along any axis or across the entire 
    array: 
 
    &gt;&gt;&gt; c = [2, 4, 6, 8, 0, 1, 3, 5, 7, 9] 
    &gt;&gt;&gt; d = np.array([a, b, c]) 
    &gt;&gt;&gt; stats.trim1(d, 0.8, axis=0).shape 
    (1, 10) 
    &gt;&gt;&gt; stats.trim1(d, 0.8, axis=1).shape 
    (3, 2) 
    &gt;&gt;&gt; stats.trim1(d, 0.8, axis=None).shape 
    (6,) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asarray(a)</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">a = a.ravel()</span>
        <span class="s1">axis = </span><span class="s5">0</span>

    <span class="s1">nobs = a.shape[axis]</span>

    <span class="s0"># avoid possible corner case</span>
    <span class="s3">if </span><span class="s1">proportiontocut &gt;= </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">[]</span>

    <span class="s3">if </span><span class="s1">tail.lower() == </span><span class="s4">'right'</span><span class="s1">:</span>
        <span class="s1">lowercut = </span><span class="s5">0</span>
        <span class="s1">uppercut = nobs - int(proportiontocut * nobs)</span>

    <span class="s3">elif </span><span class="s1">tail.lower() == </span><span class="s4">'left'</span><span class="s1">:</span>
        <span class="s1">lowercut = int(proportiontocut * nobs)</span>
        <span class="s1">uppercut = nobs</span>

    <span class="s1">atmp = np.partition(a</span><span class="s3">, </span><span class="s1">(lowercut</span><span class="s3">, </span><span class="s1">uppercut - </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">sl = [slice(</span><span class="s3">None</span><span class="s1">)] * atmp.ndim</span>
    <span class="s1">sl[axis] = slice(lowercut</span><span class="s3">, </span><span class="s1">uppercut)</span>
    <span class="s3">return </span><span class="s1">atmp[tuple(sl)]</span>


<span class="s3">def </span><span class="s1">trim_mean(a</span><span class="s3">, </span><span class="s1">proportiontocut</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return mean of array after trimming distribution from both tails. 
 
    If `proportiontocut` = 0.1, slices off 'leftmost' and 'rightmost' 10% of 
    scores. The input is sorted before slicing. Slices off less if proportion 
    results in a non-integer slice index (i.e., conservatively slices off 
    `proportiontocut` ). 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    proportiontocut : float 
        Fraction to cut off of both tails of the distribution. 
    axis : int or None, optional 
        Axis along which the trimmed means are computed. Default is 0. 
        If None, compute over the whole array `a`. 
 
    Returns 
    ------- 
    trim_mean : ndarray 
        Mean of trimmed array. 
 
    See Also 
    -------- 
    trimboth 
    tmean : Compute the trimmed mean ignoring values outside given `limits`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = np.arange(20) 
    &gt;&gt;&gt; stats.trim_mean(x, 0.1) 
    9.5 
    &gt;&gt;&gt; x2 = x.reshape(5, 4) 
    &gt;&gt;&gt; x2 
    array([[ 0,  1,  2,  3], 
           [ 4,  5,  6,  7], 
           [ 8,  9, 10, 11], 
           [12, 13, 14, 15], 
           [16, 17, 18, 19]]) 
    &gt;&gt;&gt; stats.trim_mean(x2, 0.25) 
    array([  8.,   9.,  10.,  11.]) 
    &gt;&gt;&gt; stats.trim_mean(x2, 0.25, axis=1) 
    array([  1.5,   5.5,   9.5,  13.5,  17.5]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.asarray(a)</span>

    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.nan</span>

    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">a = a.ravel()</span>
        <span class="s1">axis = </span><span class="s5">0</span>

    <span class="s1">nobs = a.shape[axis]</span>
    <span class="s1">lowercut = int(proportiontocut * nobs)</span>
    <span class="s1">uppercut = nobs - lowercut</span>
    <span class="s3">if </span><span class="s1">(lowercut &gt; uppercut):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Proportion too big.&quot;</span><span class="s1">)</span>

    <span class="s1">atmp = np.partition(a</span><span class="s3">, </span><span class="s1">(lowercut</span><span class="s3">, </span><span class="s1">uppercut - </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">sl = [slice(</span><span class="s3">None</span><span class="s1">)] * atmp.ndim</span>
    <span class="s1">sl[axis] = slice(lowercut</span><span class="s3">, </span><span class="s1">uppercut)</span>
    <span class="s3">return </span><span class="s1">np.mean(atmp[tuple(sl)]</span><span class="s3">, </span><span class="s1">axis=axis)</span>


<span class="s1">F_onewayResult = namedtuple(</span><span class="s4">'F_onewayResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">_create_f_oneway_nan_result(shape</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s2">&quot;&quot;&quot; 
    This is a helper function for f_oneway for creating the return values 
    in certain degenerate conditions.  It creates return values that are 
    all nan with the appropriate shape for the given `shape` and `axis`. 
    &quot;&quot;&quot;</span>
    <span class="s1">axis = np.core.multiarray.normalize_axis_index(axis</span><span class="s3">, </span><span class="s1">len(shape))</span>
    <span class="s1">shp = shape[:axis] + shape[axis+</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s3">if </span><span class="s1">shp == ():</span>
        <span class="s1">f = np.nan</span>
        <span class="s1">prob = np.nan</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">f = np.full(shp</span><span class="s3">, </span><span class="s1">fill_value=np.nan)</span>
        <span class="s1">prob = f.copy()</span>
    <span class="s3">return </span><span class="s1">F_onewayResult(f</span><span class="s3">, </span><span class="s1">prob)</span>


<span class="s3">def </span><span class="s1">_first(arr</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s2">&quot;&quot;&quot;Return arr[..., 0:1, ...] where 0:1 is in the `axis` position.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">np.take_along_axis(arr</span><span class="s3">, </span><span class="s1">np.array(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ndmin=arr.ndim)</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s3">def </span><span class="s1">f_oneway(*samples</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Perform one-way ANOVA. 
 
    The one-way ANOVA tests the null hypothesis that two or more groups have 
    the same population mean.  The test is applied to samples from two or 
    more groups, possibly with differing sizes. 
 
    Parameters 
    ---------- 
    sample1, sample2, ... : array_like 
        The sample measurements for each group.  There must be at least 
        two arguments.  If the arrays are multidimensional, then all the 
        dimensions of the array must be the same except for `axis`. 
    axis : int, optional 
        Axis of the input arrays along which the test is applied. 
        Default is 0. 
 
    Returns 
    ------- 
    statistic : float 
        The computed F statistic of the test. 
    pvalue : float 
        The associated p-value from the F distribution. 
 
    Warns 
    ----- 
    `~scipy.stats.ConstantInputWarning` 
        Raised if all values within each of the input arrays are identical. 
        In this case the F statistic is either infinite or isn't defined, 
        so ``np.inf`` or ``np.nan`` is returned. 
 
    `~scipy.stats.DegenerateDataWarning` 
        Raised if the length of any input array is 0, or if all the input 
        arrays have length 1.  ``np.nan`` is returned for the F statistic 
        and the p-value in these cases. 
 
    Notes 
    ----- 
    The ANOVA test has important assumptions that must be satisfied in order 
    for the associated p-value to be valid. 
 
    1. The samples are independent. 
    2. Each sample is from a normally distributed population. 
    3. The population standard deviations of the groups are all equal.  This 
       property is known as homoscedasticity. 
 
    If these assumptions are not true for a given set of data, it may still 
    be possible to use the Kruskal-Wallis H-test (`scipy.stats.kruskal`) or 
    the Alexander-Govern test (`scipy.stats.alexandergovern`) although with 
    some loss of power. 
 
    The length of each group must be at least one, and there must be at 
    least one group with length greater than one.  If these conditions 
    are not satisfied, a warning is generated and (``np.nan``, ``np.nan``) 
    is returned. 
 
    If all values in each group are identical, and there exist at least two 
    groups with different values, the function generates a warning and 
    returns (``np.inf``, 0). 
 
    If all values in all groups are the same, function generates a warning 
    and returns (``np.nan``, ``np.nan``). 
 
    The algorithm is from Heiman [2]_, pp.394-7. 
 
    References 
    ---------- 
    .. [1] R. Lowry, &quot;Concepts and Applications of Inferential Statistics&quot;, 
           Chapter 14, 2014, http://vassarstats.net/textbook/ 
 
    .. [2] G.W. Heiman, &quot;Understanding research methods and statistics: An 
           integrated introduction for psychology&quot;, Houghton, Mifflin and 
           Company, 2001. 
 
    .. [3] G.H. McDonald, &quot;Handbook of Biological Statistics&quot;, One-way ANOVA. 
           http://www.biostathandbook.com/onewayanova.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import f_oneway 
 
    Here are some data [3]_ on a shell measurement (the length of the anterior 
    adductor muscle scar, standardized by dividing by length) in the mussel 
    Mytilus trossulus from five locations: Tillamook, Oregon; Newport, Oregon; 
    Petersburg, Alaska; Magadan, Russia; and Tvarminne, Finland, taken from a 
    much larger data set used in McDonald et al. (1991). 
 
    &gt;&gt;&gt; tillamook = [0.0571, 0.0813, 0.0831, 0.0976, 0.0817, 0.0859, 0.0735, 
    ...              0.0659, 0.0923, 0.0836] 
    &gt;&gt;&gt; newport = [0.0873, 0.0662, 0.0672, 0.0819, 0.0749, 0.0649, 0.0835, 
    ...            0.0725] 
    &gt;&gt;&gt; petersburg = [0.0974, 0.1352, 0.0817, 0.1016, 0.0968, 0.1064, 0.105] 
    &gt;&gt;&gt; magadan = [0.1033, 0.0915, 0.0781, 0.0685, 0.0677, 0.0697, 0.0764, 
    ...            0.0689] 
    &gt;&gt;&gt; tvarminne = [0.0703, 0.1026, 0.0956, 0.0973, 0.1039, 0.1045] 
    &gt;&gt;&gt; f_oneway(tillamook, newport, petersburg, magadan, tvarminne) 
    F_onewayResult(statistic=7.121019471642447, pvalue=0.0002812242314534544) 
 
    `f_oneway` accepts multidimensional input arrays.  When the inputs 
    are multidimensional and `axis` is not given, the test is performed 
    along the first axis of the input arrays.  For the following data, the 
    test is performed three times, once for each column. 
 
    &gt;&gt;&gt; a = np.array([[9.87, 9.03, 6.81], 
    ...               [7.18, 8.35, 7.00], 
    ...               [8.39, 7.58, 7.68], 
    ...               [7.45, 6.33, 9.35], 
    ...               [6.41, 7.10, 9.33], 
    ...               [8.00, 8.24, 8.44]]) 
    &gt;&gt;&gt; b = np.array([[6.35, 7.30, 7.16], 
    ...               [6.65, 6.68, 7.63], 
    ...               [5.72, 7.73, 6.72], 
    ...               [7.01, 9.19, 7.41], 
    ...               [7.75, 7.87, 8.30], 
    ...               [6.90, 7.97, 6.97]]) 
    &gt;&gt;&gt; c = np.array([[3.31, 8.77, 1.01], 
    ...               [8.25, 3.24, 3.62], 
    ...               [6.32, 8.81, 5.19], 
    ...               [7.48, 8.83, 8.91], 
    ...               [8.59, 6.01, 6.07], 
    ...               [3.07, 9.72, 7.48]]) 
    &gt;&gt;&gt; F, p = f_oneway(a, b, c) 
    &gt;&gt;&gt; F 
    array([1.75676344, 0.03701228, 3.76439349]) 
    &gt;&gt;&gt; p 
    array([0.20630784, 0.96375203, 0.04733157]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">len(samples) &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'at least two inputs are required;'</span>
                        <span class="s4">f' got </span><span class="s3">{</span><span class="s1">len(samples)</span><span class="s3">}</span><span class="s4">.'</span><span class="s1">)</span>

    <span class="s1">samples = [np.asarray(sample</span><span class="s3">, </span><span class="s1">dtype=float) </span><span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples]</span>

    <span class="s0"># ANOVA on N groups, each in its own array</span>
    <span class="s1">num_groups = len(samples)</span>

    <span class="s0"># We haven't explicitly validated axis, but if it is bad, this call of</span>
    <span class="s0"># np.concatenate will raise np.AxisError.  The call will raise ValueError</span>
    <span class="s0"># if the dimensions of all the arrays, except the axis dimension, are not</span>
    <span class="s0"># the same.</span>
    <span class="s1">alldata = np.concatenate(samples</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">bign = alldata.shape[axis]</span>

    <span class="s0"># Check this after forming alldata, so shape errors are detected</span>
    <span class="s0"># and reported before checking for 0 length inputs.</span>
    <span class="s3">if </span><span class="s1">any(sample.shape[axis] == </span><span class="s5">0 </span><span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples):</span>
        <span class="s1">warnings.warn(stats.DegenerateDataWarning(</span><span class="s4">'at least one input '</span>
                                                  <span class="s4">'has length 0'</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s1">_create_f_oneway_nan_result(alldata.shape</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s0"># Must have at least one group with length greater than 1.</span>
    <span class="s3">if </span><span class="s1">all(sample.shape[axis] == </span><span class="s5">1 </span><span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples):</span>
        <span class="s1">msg = (</span><span class="s4">'all input arrays have length 1.  f_oneway requires that at '</span>
               <span class="s4">'least one input has length greater than 1.'</span><span class="s1">)</span>
        <span class="s1">warnings.warn(stats.DegenerateDataWarning(msg))</span>
        <span class="s3">return </span><span class="s1">_create_f_oneway_nan_result(alldata.shape</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s0"># Check if all values within each group are identical, and if the common</span>
    <span class="s0"># value in at least one group is different from that in another group.</span>
    <span class="s0"># Based on https://github.com/scipy/scipy/issues/11669</span>

    <span class="s0"># If axis=0, say, and the groups have shape (n0, ...), (n1, ...), ...,</span>
    <span class="s0"># then is_const is a boolean array with shape (num_groups, ...).</span>
    <span class="s0"># It is True if the values within the groups along the axis slice are</span>
    <span class="s0"># identical. In the typical case where each input array is 1-d, is_const is</span>
    <span class="s0"># a 1-d array with length num_groups.</span>
    <span class="s1">is_const = np.concatenate(</span>
        <span class="s1">[(_first(sample</span><span class="s3">, </span><span class="s1">axis) == sample).all(axis=axis</span><span class="s3">,</span>
                                              <span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
         <span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples]</span><span class="s3">,</span>
        <span class="s1">axis=axis</span>
    <span class="s1">)</span>

    <span class="s0"># all_const is a boolean array with shape (...) (see previous comment).</span>
    <span class="s0"># It is True if the values within each group along the axis slice are</span>
    <span class="s0"># the same (e.g. [[3, 3, 3], [5, 5, 5, 5], [4, 4, 4]]).</span>
    <span class="s1">all_const = is_const.all(axis=axis)</span>
    <span class="s3">if </span><span class="s1">all_const.any():</span>
        <span class="s1">msg = (</span><span class="s4">&quot;Each of the input arrays is constant;&quot;</span>
               <span class="s4">&quot;the F statistic is not defined or infinite&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(stats.ConstantInputWarning(msg))</span>

    <span class="s0"># all_same_const is True if all the values in the groups along the axis=0</span>
    <span class="s0"># slice are the same (e.g. [[3, 3, 3], [3, 3, 3, 3], [3, 3, 3]]).</span>
    <span class="s1">all_same_const = (_first(alldata</span><span class="s3">, </span><span class="s1">axis) == alldata).all(axis=axis)</span>

    <span class="s0"># Determine the mean of the data, and subtract that from all inputs to a</span>
    <span class="s0"># variance (via sum_of_sq / sq_of_sum) calculation.  Variance is invariant</span>
    <span class="s0"># to a shift in location, and centering all data around zero vastly</span>
    <span class="s0"># improves numerical stability.</span>
    <span class="s1">offset = alldata.mean(axis=axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">alldata -= offset</span>

    <span class="s1">normalized_ss = _square_of_sums(alldata</span><span class="s3">, </span><span class="s1">axis=axis) / bign</span>

    <span class="s1">sstot = _sum_of_squares(alldata</span><span class="s3">, </span><span class="s1">axis=axis) - normalized_ss</span>

    <span class="s1">ssbn = </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples:</span>
        <span class="s1">ssbn += _square_of_sums(sample - offset</span><span class="s3">,</span>
                                <span class="s1">axis=axis) / sample.shape[axis]</span>

    <span class="s0"># Naming: variables ending in bn/b are for &quot;between treatments&quot;, wn/w are</span>
    <span class="s0"># for &quot;within treatments&quot;</span>
    <span class="s1">ssbn -= normalized_ss</span>
    <span class="s1">sswn = sstot - ssbn</span>
    <span class="s1">dfbn = num_groups - </span><span class="s5">1</span>
    <span class="s1">dfwn = bign - num_groups</span>
    <span class="s1">msb = ssbn / dfbn</span>
    <span class="s1">msw = sswn / dfwn</span>
    <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">f = msb / msw</span>

    <span class="s1">prob = special.fdtrc(dfbn</span><span class="s3">, </span><span class="s1">dfwn</span><span class="s3">, </span><span class="s1">f)   </span><span class="s0"># equivalent to stats.f.sf</span>

    <span class="s0"># Fix any f values that should be inf or nan because the corresponding</span>
    <span class="s0"># inputs were constant.</span>
    <span class="s3">if </span><span class="s1">np.isscalar(f):</span>
        <span class="s3">if </span><span class="s1">all_same_const:</span>
            <span class="s1">f = np.nan</span>
            <span class="s1">prob = np.nan</span>
        <span class="s3">elif </span><span class="s1">all_const:</span>
            <span class="s1">f = np.inf</span>
            <span class="s1">prob = </span><span class="s5">0.0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">f[all_const] = np.inf</span>
        <span class="s1">prob[all_const] = </span><span class="s5">0.0</span>
        <span class="s1">f[all_same_const] = np.nan</span>
        <span class="s1">prob[all_same_const] = np.nan</span>

    <span class="s3">return </span><span class="s1">F_onewayResult(f</span><span class="s3">, </span><span class="s1">prob)</span>


<span class="s3">def </span><span class="s1">alexandergovern(*samples</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Performs the Alexander Govern test. 
 
    The Alexander-Govern approximation tests the equality of k independent 
    means in the face of heterogeneity of variance. The test is applied to 
    samples from two or more groups, possibly with differing sizes. 
 
    Parameters 
    ---------- 
    sample1, sample2, ... : array_like 
        The sample measurements for each group.  There must be at least 
        two samples. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
        * 'propagate': returns nan 
        * 'raise': throws an error 
        * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    res : AlexanderGovernResult 
        An object with attributes: 
 
        statistic : float 
            The computed A statistic of the test. 
        pvalue : float 
            The associated p-value from the chi-squared distribution. 
 
    Warns 
    ----- 
    `~scipy.stats.ConstantInputWarning` 
        Raised if an input is a constant array.  The statistic is not defined 
        in this case, so ``np.nan`` is returned. 
 
    See Also 
    -------- 
    f_oneway : one-way ANOVA 
 
    Notes 
    ----- 
    The use of this test relies on several assumptions. 
 
    1. The samples are independent. 
    2. Each sample is from a normally distributed population. 
    3. Unlike `f_oneway`, this test does not assume on homoscedasticity, 
       instead relaxing the assumption of equal variances. 
 
    Input samples must be finite, one dimensional, and with size greater than 
    one. 
 
    References 
    ---------- 
    .. [1] Alexander, Ralph A., and Diane M. Govern. &quot;A New and Simpler 
           Approximation for ANOVA under Variance Heterogeneity.&quot; Journal 
           of Educational Statistics, vol. 19, no. 2, 1994, pp. 91-101. 
           JSTOR, www.jstor.org/stable/1165140. Accessed 12 Sept. 2020. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import alexandergovern 
 
    Here are some data on annual percentage rate of interest charged on 
    new car loans at nine of the largest banks in four American cities 
    taken from the National Institute of Standards and Technology's 
    ANOVA dataset. 
 
    We use `alexandergovern` to test the null hypothesis that all cities 
    have the same mean APR against the alternative that the cities do not 
    all have the same mean APR. We decide that a significance level of 5% 
    is required to reject the null hypothesis in favor of the alternative. 
 
    &gt;&gt;&gt; atlanta = [13.75, 13.75, 13.5, 13.5, 13.0, 13.0, 13.0, 12.75, 12.5] 
    &gt;&gt;&gt; chicago = [14.25, 13.0, 12.75, 12.5, 12.5, 12.4, 12.3, 11.9, 11.9] 
    &gt;&gt;&gt; houston = [14.0, 14.0, 13.51, 13.5, 13.5, 13.25, 13.0, 12.5, 12.5] 
    &gt;&gt;&gt; memphis = [15.0, 14.0, 13.75, 13.59, 13.25, 12.97, 12.5, 12.25, 
    ...           11.89] 
    &gt;&gt;&gt; alexandergovern(atlanta, chicago, houston, memphis) 
    AlexanderGovernResult(statistic=4.65087071883494, 
                          pvalue=0.19922132490385214) 
 
    The p-value is 0.1992, indicating a nearly 20% chance of observing 
    such an extreme value of the test statistic under the null hypothesis. 
    This exceeds 5%, so we do not reject the null hypothesis in favor of 
    the alternative. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">samples = _alexandergovern_input_validation(samples</span><span class="s3">, </span><span class="s1">nan_policy)</span>

    <span class="s3">if </span><span class="s1">np.any([(sample == sample[</span><span class="s5">0</span><span class="s1">]).all() </span><span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples]):</span>
        <span class="s1">msg = </span><span class="s4">&quot;An input array is constant; the statistic is not defined.&quot;</span>
        <span class="s1">warnings.warn(stats.ConstantInputWarning(msg))</span>
        <span class="s3">return </span><span class="s1">AlexanderGovernResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>

    <span class="s0"># The following formula numbers reference the equation described on</span>
    <span class="s0"># page 92 by Alexander, Govern. Formulas 5, 6, and 7 describe other</span>
    <span class="s0"># tests that serve as the basis for equation (8) but are not needed</span>
    <span class="s0"># to perform the test.</span>

    <span class="s0"># precalculate mean and length of each sample</span>
    <span class="s1">lengths = np.array([ma.count(sample) </span><span class="s3">if </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span>
                        <span class="s3">else </span><span class="s1">len(sample) </span><span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples])</span>
    <span class="s1">means = np.array([np.mean(sample) </span><span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples])</span>

    <span class="s0"># (1) determine standard error of the mean for each sample</span>
    <span class="s1">standard_errors = [np.std(sample</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">) / np.sqrt(length)</span>
                       <span class="s3">for </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">length </span><span class="s3">in </span><span class="s1">zip(samples</span><span class="s3">, </span><span class="s1">lengths)]</span>

    <span class="s0"># (2) define a weight for each sample</span>
    <span class="s1">inv_sq_se = </span><span class="s5">1 </span><span class="s1">/ np.square(standard_errors)</span>
    <span class="s1">weights = inv_sq_se / np.sum(inv_sq_se)</span>

    <span class="s0"># (3) determine variance-weighted estimate of the common mean</span>
    <span class="s1">var_w = np.sum(weights * means)</span>

    <span class="s0"># (4) determine one-sample t statistic for each group</span>
    <span class="s1">t_stats = (means - var_w)/standard_errors</span>

    <span class="s0"># calculate parameters to be used in transformation</span>
    <span class="s1">v = lengths - </span><span class="s5">1</span>
    <span class="s1">a = v - </span><span class="s5">.5</span>
    <span class="s1">b = </span><span class="s5">48 </span><span class="s1">* a**</span><span class="s5">2</span>
    <span class="s1">c = (a * np.log(</span><span class="s5">1 </span><span class="s1">+ (t_stats ** </span><span class="s5">2</span><span class="s1">)/v))**</span><span class="s5">.5</span>

    <span class="s0"># (8) perform a normalizing transformation on t statistic</span>
    <span class="s1">z = (c + ((c**</span><span class="s5">3 </span><span class="s1">+ </span><span class="s5">3</span><span class="s1">*c)/b) -</span>
         <span class="s1">((</span><span class="s5">4</span><span class="s1">*c**</span><span class="s5">7 </span><span class="s1">+ </span><span class="s5">33</span><span class="s1">*c**</span><span class="s5">5 </span><span class="s1">+ </span><span class="s5">240</span><span class="s1">*c**</span><span class="s5">3 </span><span class="s1">+ </span><span class="s5">855</span><span class="s1">*c) /</span>
          <span class="s1">(b**</span><span class="s5">2</span><span class="s1">*</span><span class="s5">10 </span><span class="s1">+ </span><span class="s5">8</span><span class="s1">*b*c**</span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">1000</span><span class="s1">*b)))</span>

    <span class="s0"># (9) calculate statistic</span>
    <span class="s1">A = np.sum(np.square(z))</span>

    <span class="s0"># &quot;[the p value is determined from] central chi-square random deviates</span>
    <span class="s0"># with k - 1 degrees of freedom&quot;. Alexander, Govern (94)</span>
    <span class="s1">p = distributions.chi2.sf(A</span><span class="s3">, </span><span class="s1">len(samples) - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">AlexanderGovernResult(A</span><span class="s3">, </span><span class="s1">p)</span>


<span class="s3">def </span><span class="s1">_alexandergovern_input_validation(samples</span><span class="s3">, </span><span class="s1">nan_policy):</span>
    <span class="s3">if </span><span class="s1">len(samples) &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;2 or more inputs required, got </span><span class="s3">{</span><span class="s1">len(samples)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0"># input arrays are flattened</span>
    <span class="s1">samples = [np.asarray(sample</span><span class="s3">, </span><span class="s1">dtype=float) </span><span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples]</span>

    <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">enumerate(samples):</span>
        <span class="s3">if </span><span class="s1">np.size(sample) &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Input sample size must be greater than one.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">sample.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Input samples must be one-dimensional&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">np.isinf(sample).any():</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Input samples must be finite.&quot;</span><span class="s1">)</span>

        <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(sample</span><span class="s3">,</span>
                                                 <span class="s1">nan_policy=nan_policy)</span>
        <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
            <span class="s1">samples[i] = ma.masked_invalid(sample)</span>
    <span class="s3">return </span><span class="s1">samples</span>


<span class="s1">@dataclass</span>
<span class="s3">class </span><span class="s1">AlexanderGovernResult:</span>
    <span class="s1">statistic: float</span>
    <span class="s1">pvalue: float</span>


<span class="s3">def </span><span class="s1">_pearsonr_fisher_ci(r</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">confidence_level</span><span class="s3">, </span><span class="s1">alternative):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute the confidence interval for Pearson's R. 
 
    Fisher's transformation is used to compute the confidence interval 
    (https://en.wikipedia.org/wiki/Fisher_transformation). 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">r == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">zr = np.inf</span>
    <span class="s3">elif </span><span class="s1">r == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">zr = -np.inf</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">zr = np.arctanh(r)</span>

    <span class="s3">if </span><span class="s1">n &gt; </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s1">se = np.sqrt(</span><span class="s5">1 </span><span class="s1">/ (n - </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">:</span>
            <span class="s1">h = special.ndtri(</span><span class="s5">0.5 </span><span class="s1">+ confidence_level/</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">zlo = zr - h*se</span>
            <span class="s1">zhi = zr + h*se</span>
            <span class="s1">rlo = np.tanh(zlo)</span>
            <span class="s1">rhi = np.tanh(zhi)</span>
        <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">&quot;less&quot;</span><span class="s1">:</span>
            <span class="s1">h = special.ndtri(confidence_level)</span>
            <span class="s1">zhi = zr + h*se</span>
            <span class="s1">rhi = np.tanh(zhi)</span>
            <span class="s1">rlo = -</span><span class="s5">1.0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># alternative == &quot;greater&quot;:</span>
            <span class="s1">h = special.ndtri(confidence_level)</span>
            <span class="s1">zlo = zr - h*se</span>
            <span class="s1">rlo = np.tanh(zlo)</span>
            <span class="s1">rhi = </span><span class="s5">1.0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">rlo</span><span class="s3">, </span><span class="s1">rhi = -</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span>

    <span class="s3">return </span><span class="s1">ConfidenceInterval(low=rlo</span><span class="s3">, </span><span class="s1">high=rhi)</span>


<span class="s3">def </span><span class="s1">_pearsonr_bootstrap_ci(confidence_level</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">alternative):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute the confidence interval for Pearson's R using the bootstrap. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">statistic(x</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s1">statistic</span><span class="s3">, </span><span class="s1">_ = pearsonr(x</span><span class="s3">, </span><span class="s1">y)</span>
        <span class="s3">return </span><span class="s1">statistic</span>

    <span class="s1">res = bootstrap((x</span><span class="s3">, </span><span class="s1">y)</span><span class="s3">, </span><span class="s1">statistic</span><span class="s3">, </span><span class="s1">confidence_level=confidence_level</span><span class="s3">,</span>
                    <span class="s1">paired=</span><span class="s3">True, </span><span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">**method._asdict())</span>
    <span class="s0"># for one-sided confidence intervals, bootstrap gives +/- inf on one side</span>
    <span class="s1">res.confidence_interval = np.clip(res.confidence_interval</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">ConfidenceInterval(*res.confidence_interval)</span>


<span class="s1">ConfidenceInterval = namedtuple(</span><span class="s4">'ConfidenceInterval'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'low'</span><span class="s3">, </span><span class="s4">'high'</span><span class="s1">])</span>

<span class="s1">PearsonRResultBase = _make_tuple_bunch(</span><span class="s4">'PearsonRResultBase'</span><span class="s3">,</span>
                                       <span class="s1">[</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[])</span>


<span class="s3">class </span><span class="s1">PearsonRResult(PearsonRResultBase):</span>
    <span class="s2">&quot;&quot;&quot; 
    Result of `scipy.stats.pearsonr` 
 
    Attributes 
    ---------- 
    statistic : float 
        Pearson product-moment correlation coefficient. 
    pvalue : float 
        The p-value associated with the chosen alternative. 
 
    Methods 
    ------- 
    confidence_interval 
        Computes the confidence interval of the correlation 
        coefficient `statistic` for the given confidence level. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s1">super().__init__(statistic</span><span class="s3">, </span><span class="s1">pvalue)</span>
        <span class="s1">self._alternative = alternative</span>
        <span class="s1">self._n = n</span>
        <span class="s1">self._x = x</span>
        <span class="s1">self._y = y</span>

        <span class="s0"># add alias for consistency with other correlation functions</span>
        <span class="s1">self.correlation = statistic</span>

    <span class="s3">def </span><span class="s1">confidence_interval(self</span><span class="s3">, </span><span class="s1">confidence_level=</span><span class="s5">0.95</span><span class="s3">, </span><span class="s1">method=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        The confidence interval for the correlation coefficient. 
 
        Compute the confidence interval for the correlation coefficient 
        ``statistic`` with the given confidence level. 
 
        If `method` is not provided, 
        The confidence interval is computed using the Fisher transformation 
        F(r) = arctanh(r) [1]_.  When the sample pairs are drawn from a 
        bivariate normal distribution, F(r) approximately follows a normal 
        distribution with standard error ``1/sqrt(n - 3)``, where ``n`` is the 
        length of the original samples along the calculation axis. When 
        ``n &lt;= 3``, this approximation does not yield a finite, real standard 
        error, so we define the confidence interval to be -1 to 1. 
 
        If `method` is an instance of `BootstrapMethod`, the confidence 
        interval is computed using `scipy.stats.bootstrap` with the provided 
        configuration options and other appropriate settings. In some cases, 
        confidence limits may be NaN due to a degenerate resample, and this is 
        typical for very small samples (~6 observations). 
 
        Parameters 
        ---------- 
        confidence_level : float 
            The confidence level for the calculation of the correlation 
            coefficient confidence interval. Default is 0.95. 
 
        method : BootstrapMethod, optional 
            Defines the method used to compute the confidence interval. See 
            method description for details. 
 
            .. versionadded:: 1.11.0 
 
        Returns 
        ------- 
        ci : namedtuple 
            The confidence interval is returned in a ``namedtuple`` with 
            fields `low` and `high`. 
 
        References 
        ---------- 
        .. [1] &quot;Pearson correlation coefficient&quot;, Wikipedia, 
               https://en.wikipedia.org/wiki/Pearson_correlation_coefficient 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(method</span><span class="s3">, </span><span class="s1">BootstrapMethod):</span>
            <span class="s1">ci = _pearsonr_bootstrap_ci(confidence_level</span><span class="s3">, </span><span class="s1">method</span><span class="s3">,</span>
                                        <span class="s1">self._x</span><span class="s3">, </span><span class="s1">self._y</span><span class="s3">, </span><span class="s1">self._alternative)</span>
        <span class="s3">elif </span><span class="s1">method </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">ci = _pearsonr_fisher_ci(self.statistic</span><span class="s3">, </span><span class="s1">self._n</span><span class="s3">, </span><span class="s1">confidence_level</span><span class="s3">,</span>
                                     <span class="s1">self._alternative)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">message = (</span><span class="s4">'`method` must be an instance of `BootstrapMethod` '</span>
                       <span class="s4">'or None.'</span><span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">ValueError(message)</span>
        <span class="s3">return </span><span class="s1">ci</span>

<span class="s3">def </span><span class="s1">pearsonr(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s1">method=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot; 
    Pearson correlation coefficient and p-value for testing non-correlation. 
 
    The Pearson correlation coefficient [1]_ measures the linear relationship 
    between two datasets. Like other correlation 
    coefficients, this one varies between -1 and +1 with 0 implying no 
    correlation. Correlations of -1 or +1 imply an exact linear relationship. 
    Positive correlations imply that as x increases, so does y. Negative 
    correlations imply that as x increases, y decreases. 
 
    This function also performs a test of the null hypothesis that the 
    distributions underlying the samples are uncorrelated and normally 
    distributed. (See Kowalski [3]_ 
    for a discussion of the effects of non-normality of the input on the 
    distribution of the correlation coefficient.) 
    The p-value roughly indicates the probability of an uncorrelated system 
    producing datasets that have a Pearson correlation at least as extreme 
    as the one computed from these datasets. 
 
    Parameters 
    ---------- 
    x : (N,) array_like 
        Input array. 
    y : (N,) array_like 
        Input array. 
    alternative : {'two-sided', 'greater', 'less'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        The following options are available: 
 
        * 'two-sided': the correlation is nonzero 
        * 'less': the correlation is negative (less than zero) 
        * 'greater':  the correlation is positive (greater than zero) 
 
        .. versionadded:: 1.9.0 
    method : ResamplingMethod, optional 
        Defines the method used to compute the p-value. If `method` is an 
        instance of `PermutationMethod`/`MonteCarloMethod`, the p-value is 
        computed using 
        `scipy.stats.permutation_test`/`scipy.stats.monte_carlo_test` with the 
        provided configuration options and other appropriate settings. 
        Otherwise, the p-value is computed as documented in the notes. 
 
        .. versionadded:: 1.11.0 
 
    Returns 
    ------- 
    result : `~scipy.stats._result_classes.PearsonRResult` 
        An object with the following attributes: 
 
        statistic : float 
            Pearson product-moment correlation coefficient. 
        pvalue : float 
            The p-value associated with the chosen alternative. 
 
        The object has the following method: 
 
        confidence_interval(confidence_level, method) 
            This computes the confidence interval of the correlation 
            coefficient `statistic` for the given confidence level. 
            The confidence interval is returned in a ``namedtuple`` with 
            fields `low` and `high`. If `method` is not provided, the 
            confidence interval is computed using the Fisher transformation 
            [1]_. If `method` is an instance of `BootstrapMethod`, the 
            confidence interval is computed using `scipy.stats.bootstrap` with 
            the provided configuration options and other appropriate settings. 
            In some cases, confidence limits may be NaN due to a degenerate 
            resample, and this is typical for very small samples (~6 
            observations). 
 
    Warns 
    ----- 
    `~scipy.stats.ConstantInputWarning` 
        Raised if an input is a constant array.  The correlation coefficient 
        is not defined in this case, so ``np.nan`` is returned. 
 
    `~scipy.stats.NearConstantInputWarning` 
        Raised if an input is &quot;nearly&quot; constant.  The array ``x`` is considered 
        nearly constant if ``norm(x - mean(x)) &lt; 1e-13 * abs(mean(x))``. 
        Numerical errors in the calculation ``x - mean(x)`` in this case might 
        result in an inaccurate calculation of r. 
 
    See Also 
    -------- 
    spearmanr : Spearman rank-order correlation coefficient. 
    kendalltau : Kendall's tau, a correlation measure for ordinal data. 
 
    Notes 
    ----- 
    The correlation coefficient is calculated as follows: 
 
    .. math:: 
 
        r = \frac{\sum (x - m_x) (y - m_y)} 
                 {\sqrt{\sum (x - m_x)^2 \sum (y - m_y)^2}} 
 
    where :math:`m_x` is the mean of the vector x and :math:`m_y` is 
    the mean of the vector y. 
 
    Under the assumption that x and y are drawn from 
    independent normal distributions (so the population correlation coefficient 
    is 0), the probability density function of the sample correlation 
    coefficient r is ([1]_, [2]_): 
 
    .. math:: 
        f(r) = \frac{{(1-r^2)}^{n/2-2}}{\mathrm{B}(\frac{1}{2},\frac{n}{2}-1)} 
 
    where n is the number of samples, and B is the beta function.  This 
    is sometimes referred to as the exact distribution of r.  This is 
    the distribution that is used in `pearsonr` to compute the p-value when 
    the `method` parameter is left at its default value (None). 
    The distribution is a beta distribution on the interval [-1, 1], 
    with equal shape parameters a = b = n/2 - 1.  In terms of SciPy's 
    implementation of the beta distribution, the distribution of r is:: 
 
        dist = scipy.stats.beta(n/2 - 1, n/2 - 1, loc=-1, scale=2) 
 
    The default p-value returned by `pearsonr` is a two-sided p-value. For a 
    given sample with correlation coefficient r, the p-value is 
    the probability that abs(r') of a random sample x' and y' drawn from 
    the population with zero correlation would be greater than or equal 
    to abs(r). In terms of the object ``dist`` shown above, the p-value 
    for a given r and length n can be computed as:: 
 
        p = 2*dist.cdf(-abs(r)) 
 
    When n is 2, the above continuous distribution is not well-defined. 
    One can interpret the limit of the beta distribution as the shape 
    parameters a and b approach a = b = 0 as a discrete distribution with 
    equal probability masses at r = 1 and r = -1.  More directly, one 
    can observe that, given the data x = [x1, x2] and y = [y1, y2], and 
    assuming x1 != x2 and y1 != y2, the only possible values for r are 1 
    and -1.  Because abs(r') for any sample x' and y' with length 2 will 
    be 1, the two-sided p-value for a sample of length 2 is always 1. 
 
    For backwards compatibility, the object that is returned also behaves 
    like a tuple of length two that holds the statistic and the p-value. 
 
    References 
    ---------- 
    .. [1] &quot;Pearson correlation coefficient&quot;, Wikipedia, 
           https://en.wikipedia.org/wiki/Pearson_correlation_coefficient 
    .. [2] Student, &quot;Probable error of a correlation coefficient&quot;, 
           Biometrika, Volume 6, Issue 2-3, 1 September 1908, pp. 302-310. 
    .. [3] C. J. Kowalski, &quot;On the Effects of Non-Normality on the Distribution 
           of the Sample Product-Moment Correlation Coefficient&quot; 
           Journal of the Royal Statistical Society. Series C (Applied 
           Statistics), Vol. 21, No. 1 (1972), pp. 1-12. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x, y = [1, 2, 3, 4, 5, 6, 7], [10, 9, 2.5, 6, 4, 3, 2] 
    &gt;&gt;&gt; res = stats.pearsonr(x, y) 
    &gt;&gt;&gt; res 
    PearsonRResult(statistic=-0.828503883588428, pvalue=0.021280260007523286) 
 
    To perform an exact permutation version of the test: 
 
    &gt;&gt;&gt; rng = np.random.default_rng(7796654889291491997) 
    &gt;&gt;&gt; method = stats.PermutationMethod(n_resamples=np.inf, random_state=rng) 
    &gt;&gt;&gt; stats.pearsonr(x, y, method=method) 
    PearsonRResult(statistic=-0.828503883588428, pvalue=0.028174603174603175) 
 
    To perform the test under the null hypothesis that the data were drawn from 
    *uniform* distributions: 
 
    &gt;&gt;&gt; method = stats.MonteCarloMethod(rvs=(rng.uniform, rng.uniform)) 
    &gt;&gt;&gt; stats.pearsonr(x, y, method=method) 
    PearsonRResult(statistic=-0.828503883588428, pvalue=0.0188) 
 
    To produce an asymptotic 90% confidence interval: 
 
    &gt;&gt;&gt; res.confidence_interval(confidence_level=0.9) 
    ConfidenceInterval(low=-0.9644331982722841, high=-0.3460237473272273) 
 
    And for a bootstrap confidence interval: 
 
    &gt;&gt;&gt; method = stats.BootstrapMethod(method='BCa', random_state=rng) 
    &gt;&gt;&gt; res.confidence_interval(confidence_level=0.9, method=method) 
    ConfidenceInterval(low=-0.9983163756488651, high=-0.22771001702132443)  # may vary 
 
    There is a linear dependence between x and y if y = a + b*x + e, where 
    a,b are constants and e is a random error term, assumed to be independent 
    of x. For simplicity, assume that x is standard normal, a=0, b=1 and let 
    e follow a normal distribution with mean zero and standard deviation s&gt;0. 
 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; s = 0.5 
    &gt;&gt;&gt; x = stats.norm.rvs(size=500, random_state=rng) 
    &gt;&gt;&gt; e = stats.norm.rvs(scale=s, size=500, random_state=rng) 
    &gt;&gt;&gt; y = x + e 
    &gt;&gt;&gt; stats.pearsonr(x, y).statistic 
    0.9001942438244763 
 
    This should be close to the exact value given by 
 
    &gt;&gt;&gt; 1/np.sqrt(1 + s**2) 
    0.8944271909999159 
 
    For s=0.5, we observe a high level of correlation. In general, a large 
    variance of the noise reduces the correlation, while the correlation 
    approaches one as the variance of the error goes to zero. 
 
    It is important to keep in mind that no correlation does not imply 
    independence unless (x, y) is jointly normal. Correlation can even be zero 
    when there is a very simple dependence structure: if X follows a 
    standard normal distribution, let y = abs(x). Note that the correlation 
    between x and y is zero. Indeed, since the expectation of x is zero, 
    cov(x, y) = E[x*y]. By definition, this equals E[x*abs(x)] which is zero 
    by symmetry. The following lines of code illustrate this observation: 
 
    &gt;&gt;&gt; y = np.abs(x) 
    &gt;&gt;&gt; stats.pearsonr(x, y) 
    PearsonRResult(statistic=-0.05444919272687482, pvalue=0.22422294836207743) 
 
    A non-zero correlation coefficient can be misleading. For example, if X has 
    a standard normal distribution, define y = x if x &lt; 0 and y = 0 otherwise. 
    A simple calculation shows that corr(x, y) = sqrt(2/Pi) = 0.797..., 
    implying a high level of correlation: 
 
    &gt;&gt;&gt; y = np.where(x &lt; 0, x, 0) 
    &gt;&gt;&gt; stats.pearsonr(x, y) 
    PearsonRResult(statistic=0.861985781588, pvalue=4.813432002751103e-149) 
 
    This is unintuitive since there is no dependence of x and y if x is larger 
    than zero which happens in about half of the cases if we sample x and y. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n = len(x)</span>
    <span class="s3">if </span><span class="s1">n != len(y):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'x and y must have the same length.'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'x and y must have length at least 2.'</span><span class="s1">)</span>

    <span class="s1">x = np.asarray(x)</span>
    <span class="s1">y = np.asarray(y)</span>

    <span class="s3">if </span><span class="s1">(np.issubdtype(x.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating)</span>
            <span class="s3">or </span><span class="s1">np.issubdtype(y.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating)):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'This function does not support complex data'</span><span class="s1">)</span>

    <span class="s0"># If an input is constant, the correlation coefficient is not defined.</span>
    <span class="s3">if </span><span class="s1">(x == x[</span><span class="s5">0</span><span class="s1">]).all() </span><span class="s3">or </span><span class="s1">(y == y[</span><span class="s5">0</span><span class="s1">]).all():</span>
        <span class="s1">msg = (</span><span class="s4">&quot;An input array is constant; the correlation coefficient &quot;</span>
               <span class="s4">&quot;is not defined.&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(stats.ConstantInputWarning(msg))</span>
        <span class="s1">result = PearsonRResult(statistic=np.nan</span><span class="s3">, </span><span class="s1">pvalue=np.nan</span><span class="s3">, </span><span class="s1">n=n</span><span class="s3">,</span>
                                <span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">x=x</span><span class="s3">, </span><span class="s1">y=y)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">if </span><span class="s1">isinstance(method</span><span class="s3">, </span><span class="s1">PermutationMethod):</span>
        <span class="s3">def </span><span class="s1">statistic(y):</span>
            <span class="s1">statistic</span><span class="s3">, </span><span class="s1">_ = pearsonr(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">alternative=alternative)</span>
            <span class="s3">return </span><span class="s1">statistic</span>

        <span class="s1">res = permutation_test((y</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">statistic</span><span class="s3">, </span><span class="s1">permutation_type=</span><span class="s4">'pairings'</span><span class="s3">,</span>
                               <span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">**method._asdict())</span>

        <span class="s3">return </span><span class="s1">PearsonRResult(statistic=res.statistic</span><span class="s3">, </span><span class="s1">pvalue=res.pvalue</span><span class="s3">, </span><span class="s1">n=n</span><span class="s3">,</span>
                              <span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">x=x</span><span class="s3">, </span><span class="s1">y=y)</span>
    <span class="s3">elif </span><span class="s1">isinstance(method</span><span class="s3">, </span><span class="s1">MonteCarloMethod):</span>
        <span class="s3">def </span><span class="s1">statistic(x</span><span class="s3">, </span><span class="s1">y):</span>
            <span class="s1">statistic</span><span class="s3">, </span><span class="s1">_ = pearsonr(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">alternative=alternative)</span>
            <span class="s3">return </span><span class="s1">statistic</span>

        <span class="s3">if </span><span class="s1">method.rvs </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">rng = np.random.default_rng()</span>
            <span class="s1">method.rvs = rng.normal</span><span class="s3">, </span><span class="s1">rng.normal</span>

        <span class="s1">res = monte_carlo_test((x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">statistic=statistic</span><span class="s3">,</span>
                               <span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">**method._asdict())</span>

        <span class="s3">return </span><span class="s1">PearsonRResult(statistic=res.statistic</span><span class="s3">, </span><span class="s1">pvalue=res.pvalue</span><span class="s3">, </span><span class="s1">n=n</span><span class="s3">,</span>
                              <span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">x=x</span><span class="s3">, </span><span class="s1">y=y)</span>
    <span class="s3">elif </span><span class="s1">method </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">message = (</span><span class="s4">'`method` must be an instance of `PermutationMethod`,'</span>
                   <span class="s4">'`MonteCarloMethod`, or None.'</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">ValueError(message)</span>

    <span class="s0"># dtype is the data type for the calculations.  This expression ensures</span>
    <span class="s0"># that the data type is at least 64 bit floating point.  It might have</span>
    <span class="s0"># more precision if the input is, for example, np.longdouble.</span>
    <span class="s1">dtype = type(</span><span class="s5">1.0 </span><span class="s1">+ x[</span><span class="s5">0</span><span class="s1">] + y[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s3">if </span><span class="s1">n == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">r = dtype(np.sign(x[</span><span class="s5">1</span><span class="s1">] - x[</span><span class="s5">0</span><span class="s1">])*np.sign(y[</span><span class="s5">1</span><span class="s1">] - y[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">result = PearsonRResult(statistic=r</span><span class="s3">, </span><span class="s1">pvalue=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">n=n</span><span class="s3">,</span>
                                <span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">x=x</span><span class="s3">, </span><span class="s1">y=y)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s1">xmean = x.mean(dtype=dtype)</span>
    <span class="s1">ymean = y.mean(dtype=dtype)</span>

    <span class="s0"># By using `astype(dtype)`, we ensure that the intermediate calculations</span>
    <span class="s0"># use at least 64 bit floating point.</span>
    <span class="s1">xm = x.astype(dtype) - xmean</span>
    <span class="s1">ym = y.astype(dtype) - ymean</span>

    <span class="s0"># Unlike np.linalg.norm or the expression sqrt((xm*xm).sum()),</span>
    <span class="s0"># scipy.linalg.norm(xm) does not overflow if xm is, for example,</span>
    <span class="s0"># [-5e210, 5e210, 3e200, -3e200]</span>
    <span class="s1">normxm = linalg.norm(xm)</span>
    <span class="s1">normym = linalg.norm(ym)</span>

    <span class="s1">threshold = </span><span class="s5">1e-13</span>
    <span class="s3">if </span><span class="s1">normxm &lt; threshold*abs(xmean) </span><span class="s3">or </span><span class="s1">normym &lt; threshold*abs(ymean):</span>
        <span class="s0"># If all the values in x (likewise y) are very close to the mean,</span>
        <span class="s0"># the loss of precision that occurs in the subtraction xm = x - xmean</span>
        <span class="s0"># might result in large errors in r.</span>
        <span class="s1">msg = (</span><span class="s4">&quot;An input array is nearly constant; the computed &quot;</span>
               <span class="s4">&quot;correlation coefficient may be inaccurate.&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(stats.NearConstantInputWarning(msg))</span>

    <span class="s1">r = np.dot(xm/normxm</span><span class="s3">, </span><span class="s1">ym/normym)</span>

    <span class="s0"># Presumably, if abs(r) &gt; 1, then it is only some small artifact of</span>
    <span class="s0"># floating point arithmetic.</span>
    <span class="s1">r = max(min(r</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s0"># As explained in the docstring, the distribution of `r` under the null</span>
    <span class="s0"># hypothesis is the beta distribution on (-1, 1) with a = b = n/2 - 1.</span>
    <span class="s1">ab = n/</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1</span>
    <span class="s1">dist = stats.beta(ab</span><span class="s3">, </span><span class="s1">ab</span><span class="s3">, </span><span class="s1">loc=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'two-sided'</span><span class="s1">:</span>
        <span class="s1">prob = </span><span class="s5">2</span><span class="s1">*dist.sf(abs(r))</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">'less'</span><span class="s1">:</span>
        <span class="s1">prob = dist.cdf(r)</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">'greater'</span><span class="s1">:</span>
        <span class="s1">prob = dist.sf(r)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'alternative must be one of '</span>
                         <span class="s4">'[&quot;two-sided&quot;, &quot;less&quot;, &quot;greater&quot;]'</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">PearsonRResult(statistic=r</span><span class="s3">, </span><span class="s1">pvalue=prob</span><span class="s3">, </span><span class="s1">n=n</span><span class="s3">,</span>
                          <span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">x=x</span><span class="s3">, </span><span class="s1">y=y)</span>


<span class="s3">def </span><span class="s1">fisher_exact(table</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Perform a Fisher exact test on a 2x2 contingency table. 
 
    The null hypothesis is that the true odds ratio of the populations 
    underlying the observations is one, and the observations were sampled 
    from these populations under a condition: the marginals of the 
    resulting table must equal those of the observed table. The statistic 
    returned is the unconditional maximum likelihood estimate of the odds 
    ratio, and the p-value is the probability under the null hypothesis of 
    obtaining a table at least as extreme as the one that was actually 
    observed. There are other possible choices of statistic and two-sided 
    p-value definition associated with Fisher's exact test; please see the 
    Notes for more information. 
 
    Parameters 
    ---------- 
    table : array_like of ints 
        A 2x2 contingency table.  Elements must be non-negative integers. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the odds ratio of the underlying population is not one 
        * 'less': the odds ratio of the underlying population is less than one 
        * 'greater': the odds ratio of the underlying population is greater 
          than one 
 
        See the Notes for more details. 
 
    Returns 
    ------- 
    res : SignificanceResult 
        An object containing attributes: 
 
        statistic : float 
            This is the prior odds ratio, not a posterior estimate. 
        pvalue : float 
            The probability under the null hypothesis of obtaining a 
            table at least as extreme as the one that was actually observed. 
 
    See Also 
    -------- 
    chi2_contingency : Chi-square test of independence of variables in a 
        contingency table.  This can be used as an alternative to 
        `fisher_exact` when the numbers in the table are large. 
    contingency.odds_ratio : Compute the odds ratio (sample or conditional 
        MLE) for a 2x2 contingency table. 
    barnard_exact : Barnard's exact test, which is a more powerful alternative 
        than Fisher's exact test for 2x2 contingency tables. 
    boschloo_exact : Boschloo's exact test, which is a more powerful 
        alternative than Fisher's exact test for 2x2 contingency tables. 
 
    Notes 
    ----- 
    *Null hypothesis and p-values* 
 
    The null hypothesis is that the true odds ratio of the populations 
    underlying the observations is one, and the observations were sampled at 
    random from these populations under a condition: the marginals of the 
    resulting table must equal those of the observed table. Equivalently, 
    the null hypothesis is that the input table is from the hypergeometric 
    distribution with parameters (as used in `hypergeom`) 
    ``M = a + b + c + d``, ``n = a + b`` and ``N = a + c``, where the 
    input table is ``[[a, b], [c, d]]``.  This distribution has support 
    ``max(0, N + n - M) &lt;= x &lt;= min(N, n)``, or, in terms of the values 
    in the input table, ``min(0, a - d) &lt;= x &lt;= a + min(b, c)``.  ``x`` 
    can be interpreted as the upper-left element of a 2x2 table, so the 
    tables in the distribution have form:: 
 
        [  x           n - x     ] 
        [N - x    M - (n + N) + x] 
 
    For example, if:: 
 
        table = [6  2] 
                [1  4] 
 
    then the support is ``2 &lt;= x &lt;= 7``, and the tables in the distribution 
    are:: 
 
        [2 6]   [3 5]   [4 4]   [5 3]   [6 2]  [7 1] 
        [5 0]   [4 1]   [3 2]   [2 3]   [1 4]  [0 5] 
 
    The probability of each table is given by the hypergeometric distribution 
    ``hypergeom.pmf(x, M, n, N)``.  For this example, these are (rounded to 
    three significant digits):: 
 
        x       2      3      4      5       6        7 
        p  0.0163  0.163  0.408  0.326  0.0816  0.00466 
 
    These can be computed with:: 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.stats import hypergeom 
        &gt;&gt;&gt; table = np.array([[6, 2], [1, 4]]) 
        &gt;&gt;&gt; M = table.sum() 
        &gt;&gt;&gt; n = table[0].sum() 
        &gt;&gt;&gt; N = table[:, 0].sum() 
        &gt;&gt;&gt; start, end = hypergeom.support(M, n, N) 
        &gt;&gt;&gt; hypergeom.pmf(np.arange(start, end+1), M, n, N) 
        array([0.01631702, 0.16317016, 0.40792541, 0.32634033, 0.08158508, 
               0.004662  ]) 
 
    The two-sided p-value is the probability that, under the null hypothesis, 
    a random table would have a probability equal to or less than the 
    probability of the input table.  For our example, the probability of 
    the input table (where ``x = 6``) is 0.0816.  The x values where the 
    probability does not exceed this are 2, 6 and 7, so the two-sided p-value 
    is ``0.0163 + 0.0816 + 0.00466 ~= 0.10256``:: 
 
        &gt;&gt;&gt; from scipy.stats import fisher_exact 
        &gt;&gt;&gt; res = fisher_exact(table, alternative='two-sided') 
        &gt;&gt;&gt; res.pvalue 
        0.10256410256410257 
 
    The one-sided p-value for ``alternative='greater'`` is the probability 
    that a random table has ``x &gt;= a``, which in our example is ``x &gt;= 6``, 
    or ``0.0816 + 0.00466 ~= 0.08626``:: 
 
        &gt;&gt;&gt; res = fisher_exact(table, alternative='greater') 
        &gt;&gt;&gt; res.pvalue 
        0.08624708624708627 
 
    This is equivalent to computing the survival function of the 
    distribution at ``x = 5`` (one less than ``x`` from the input table, 
    because we want to include the probability of ``x = 6`` in the sum):: 
 
        &gt;&gt;&gt; hypergeom.sf(5, M, n, N) 
        0.08624708624708627 
 
    For ``alternative='less'``, the one-sided p-value is the probability 
    that a random table has ``x &lt;= a``, (i.e. ``x &lt;= 6`` in our example), 
    or ``0.0163 + 0.163 + 0.408 + 0.326 + 0.0816 ~= 0.9949``:: 
 
        &gt;&gt;&gt; res = fisher_exact(table, alternative='less') 
        &gt;&gt;&gt; res.pvalue 
        0.9953379953379957 
 
    This is equivalent to computing the cumulative distribution function 
    of the distribution at ``x = 6``: 
 
        &gt;&gt;&gt; hypergeom.cdf(6, M, n, N) 
        0.9953379953379957 
 
    *Odds ratio* 
 
    The calculated odds ratio is different from the value computed by the 
    R function ``fisher.test``.  This implementation returns the &quot;sample&quot; 
    or &quot;unconditional&quot; maximum likelihood estimate, while ``fisher.test`` 
    in R uses the conditional maximum likelihood estimate.  To compute the 
    conditional maximum likelihood estimate of the odds ratio, use 
    `scipy.stats.contingency.odds_ratio`. 
 
    References 
    ---------- 
    .. [1] Fisher, Sir Ronald A, &quot;The Design of Experiments: 
           Mathematics of a Lady Tasting Tea.&quot; ISBN 978-0-486-41151-4, 1935. 
    .. [2] &quot;Fisher's exact test&quot;, 
           https://en.wikipedia.org/wiki/Fisher's_exact_test 
    .. [3] Emma V. Low et al. &quot;Identifying the lowest effective dose of 
           acetazolamide for the prophylaxis of acute mountain sickness: 
           systematic review and meta-analysis.&quot; 
           BMJ, 345, :doi:`10.1136/bmj.e6779`, 2012. 
 
    Examples 
    -------- 
    In [3]_, the effective dose of acetazolamide for the prophylaxis of acute 
    mountain sickness was investigated. The study notably concluded: 
 
        Acetazolamide 250 mg, 500 mg, and 750 mg daily were all efficacious for 
        preventing acute mountain sickness. Acetazolamide 250 mg was the lowest 
        effective dose with available evidence for this indication. 
 
    The following table summarizes the results of the experiment in which 
    some participants took a daily dose of acetazolamide 250 mg while others 
    took a placebo. 
    Cases of acute mountain sickness were recorded:: 
 
                                    Acetazolamide   Control/Placebo 
        Acute mountain sickness            7           17 
        No                                15            5 
 
 
    Is there evidence that the acetazolamide 250 mg reduces the risk of 
    acute mountain sickness? 
    We begin by formulating a null hypothesis :math:`H_0`: 
 
        The odds of experiencing acute mountain sickness are the same with 
        the acetazolamide treatment as they are with placebo. 
 
    Let's assess the plausibility of this hypothesis with 
    Fisher's test. 
 
    &gt;&gt;&gt; from scipy.stats import fisher_exact 
    &gt;&gt;&gt; res = fisher_exact([[7, 17], [15, 5]], alternative='less') 
    &gt;&gt;&gt; res.statistic 
    0.13725490196078433 
    &gt;&gt;&gt; res.pvalue 
    0.0028841933752349743 
 
    Using a significance level of 5%, we would reject the null hypothesis in 
    favor of the alternative hypothesis: &quot;The odds of experiencing acute 
    mountain sickness with acetazolamide treatment are less than the odds of 
    experiencing acute mountain sickness with placebo.&quot; 
 
    .. note:: 
 
        Because the null distribution of Fisher's exact test is formed under 
        the assumption that both row and column sums are fixed, the result of 
        the test are conservative when applied to an experiment in which the 
        row sums are not fixed. 
 
        In this case, the column sums are fixed; there are 22 subjects in each 
        group. But the number of cases of acute mountain sickness is not 
        (and cannot be) fixed before conducting the experiment. It is a 
        consequence. 
 
        Boschloo's test does not depend on the assumption that the row sums 
        are fixed, and consequently, it provides a more powerful test in this 
        situation. 
 
        &gt;&gt;&gt; from scipy.stats import boschloo_exact 
        &gt;&gt;&gt; res = boschloo_exact([[7, 17], [15, 5]], alternative='less') 
        &gt;&gt;&gt; res.statistic 
        0.0028841933752349743 
        &gt;&gt;&gt; res.pvalue 
        0.0015141406667567101 
 
        We verify that the p-value is less than with `fisher_exact`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">hypergeom = distributions.hypergeom</span>
    <span class="s0"># int32 is not enough for the algorithm</span>
    <span class="s1">c = np.asarray(table</span><span class="s3">, </span><span class="s1">dtype=np.int64)</span>
    <span class="s3">if not </span><span class="s1">c.shape == (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The input `table` must be of shape (2, 2).&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">np.any(c &lt; </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;All values in `table` must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s5">0 </span><span class="s3">in </span><span class="s1">c.sum(axis=</span><span class="s5">0</span><span class="s1">) </span><span class="s3">or </span><span class="s5">0 </span><span class="s3">in </span><span class="s1">c.sum(axis=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0"># If both values in a row or column are zero, the p-value is 1 and</span>
        <span class="s0"># the odds ratio is NaN.</span>
        <span class="s3">return </span><span class="s1">SignificanceResult(np.nan</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">c[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">oddsratio = c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] * c[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] / (c[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] * c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">oddsratio = np.inf</span>

    <span class="s1">n1 = c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] + c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">n2 = c[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] + c[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">n = c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] + c[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">pmf(x):</span>
        <span class="s3">return </span><span class="s1">hypergeom.pmf(x</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n)</span>

    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'less'</span><span class="s1">:</span>
        <span class="s1">pvalue = hypergeom.cdf(c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n)</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">'greater'</span><span class="s1">:</span>
        <span class="s0"># Same formula as the 'less' case, but with the second column.</span>
        <span class="s1">pvalue = hypergeom.cdf(c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] + c[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">'two-sided'</span><span class="s1">:</span>
        <span class="s1">mode = int((n + </span><span class="s5">1</span><span class="s1">) * (n1 + </span><span class="s5">1</span><span class="s1">) / (n1 + n2 + </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">pexact = hypergeom.pmf(c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n)</span>
        <span class="s1">pmode = hypergeom.pmf(mode</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n)</span>

        <span class="s1">epsilon = </span><span class="s5">1e-14</span>
        <span class="s1">gamma = </span><span class="s5">1 </span><span class="s1">+ epsilon</span>

        <span class="s3">if </span><span class="s1">np.abs(pexact - pmode) / np.maximum(pexact</span><span class="s3">, </span><span class="s1">pmode) &lt;= epsilon:</span>
            <span class="s3">return </span><span class="s1">SignificanceResult(oddsratio</span><span class="s3">, </span><span class="s5">1.</span><span class="s1">)</span>

        <span class="s3">elif </span><span class="s1">c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] &lt; mode:</span>
            <span class="s1">plower = hypergeom.cdf(c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n)</span>
            <span class="s3">if </span><span class="s1">hypergeom.pmf(n</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n) &gt; pexact * gamma:</span>
                <span class="s3">return </span><span class="s1">SignificanceResult(oddsratio</span><span class="s3">, </span><span class="s1">plower)</span>

            <span class="s1">guess = _binary_search(</span><span class="s3">lambda </span><span class="s1">x: -pmf(x)</span><span class="s3">, </span><span class="s1">-pexact * gamma</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">n)</span>
            <span class="s1">pvalue = plower + hypergeom.sf(guess</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pupper = hypergeom.sf(c[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n)</span>
            <span class="s3">if </span><span class="s1">hypergeom.pmf(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n) &gt; pexact * gamma:</span>
                <span class="s3">return </span><span class="s1">SignificanceResult(oddsratio</span><span class="s3">, </span><span class="s1">pupper)</span>

            <span class="s1">guess = _binary_search(pmf</span><span class="s3">, </span><span class="s1">pexact * gamma</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">mode)</span>
            <span class="s1">pvalue = pupper + hypergeom.cdf(guess</span><span class="s3">, </span><span class="s1">n1 + n2</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s4">&quot;`alternative` should be one of {'two-sided', 'less', 'greater'}&quot;</span>
        <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s1">pvalue = min(pvalue</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">SignificanceResult(oddsratio</span><span class="s3">, </span><span class="s1">pvalue)</span>


<span class="s3">def </span><span class="s1">spearmanr(a</span><span class="s3">, </span><span class="s1">b=</span><span class="s3">None, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">,</span>
              <span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Calculate a Spearman correlation coefficient with associated p-value. 
 
    The Spearman rank-order correlation coefficient is a nonparametric measure 
    of the monotonicity of the relationship between two datasets. 
    Like other correlation coefficients, 
    this one varies between -1 and +1 with 0 implying no correlation. 
    Correlations of -1 or +1 imply an exact monotonic relationship. Positive 
    correlations imply that as x increases, so does y. Negative correlations 
    imply that as x increases, y decreases. 
 
    The p-value roughly indicates the probability of an uncorrelated system 
    producing datasets that have a Spearman correlation at least as extreme 
    as the one computed from these datasets. Although calculation of the 
    p-value does not make strong assumptions about the distributions underlying 
    the samples, it is only accurate for very large samples (&gt;500 
    observations). For smaller sample sizes, consider a permutation test (see 
    Examples section below). 
 
    Parameters 
    ---------- 
    a, b : 1D or 2D array_like, b is optional 
        One or two 1-D or 2-D arrays containing multiple variables and 
        observations. When these are 1-D, each represents a vector of 
        observations of a single variable. For the behavior in the 2-D case, 
        see under ``axis``, below. 
        Both arrays need to have the same length in the ``axis`` dimension. 
    axis : int or None, optional 
        If axis=0 (default), then each column represents a variable, with 
        observations in the rows. If axis=1, the relationship is transposed: 
        each row represents a variable, while the columns contain observations. 
        If axis=None, then both arrays will be raveled. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
        * 'propagate': returns nan 
        * 'raise': throws an error 
        * 'omit': performs the calculations ignoring nan values 
 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        The following options are available: 
 
        * 'two-sided': the correlation is nonzero 
        * 'less': the correlation is negative (less than zero) 
        * 'greater':  the correlation is positive (greater than zero) 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    res : SignificanceResult 
        An object containing attributes: 
 
        statistic : float or ndarray (2-D square) 
            Spearman correlation matrix or correlation coefficient (if only 2 
            variables are given as parameters). Correlation matrix is square 
            with length equal to total number of variables (columns or rows) in 
            ``a`` and ``b`` combined. 
        pvalue : float 
            The p-value for a hypothesis test whose null hypothesis 
            is that two samples have no ordinal correlation. See 
            `alternative` above for alternative hypotheses. `pvalue` has the 
            same shape as `statistic`. 
 
    Warns 
    ----- 
    `~scipy.stats.ConstantInputWarning` 
        Raised if an input is a constant array.  The correlation coefficient 
        is not defined in this case, so ``np.nan`` is returned. 
 
    References 
    ---------- 
    .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard 
       Probability and Statistics Tables and Formulae. Chapman &amp; Hall: New 
       York. 2000. 
       Section  14.7 
    .. [2] Kendall, M. G. and Stuart, A. (1973). 
       The Advanced Theory of Statistics, Volume 2: Inference and Relationship. 
       Griffin. 1973. 
       Section 31.18 
    .. [3] Kershenobich, D., Fierro, F. J., &amp; Rojkind, M. (1970). The 
       relationship between the free pool of proline and collagen content in 
       human liver cirrhosis. The Journal of Clinical Investigation, 49(12), 
       2246-2249. 
    .. [4] Hollander, M., Wolfe, D. A., &amp; Chicken, E. (2013). Nonparametric 
       statistical methods. John Wiley &amp; Sons. 
    .. [5] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be 
       Zero: Calculating Exact P-values When Permutations Are Randomly Drawn.&quot; 
       Statistical Applications in Genetics and Molecular Biology 9.1 (2010). 
    .. [6] Ludbrook, J., &amp; Dudley, H. (1998). Why permutation tests are 
       superior to t and F tests in biomedical research. The American 
       Statistician, 52(2), 127-132. 
 
    Examples 
    -------- 
    Consider the following data from [3]_, which studied the relationship 
    between free proline (an amino acid) and total collagen (a protein often 
    found in connective tissue) in unhealthy human livers. 
 
    The ``x`` and ``y`` arrays below record measurements of the two compounds. 
    The observations are paired: each free proline measurement was taken from 
    the same liver as the total collagen measurement at the same index. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; # total collagen (mg/g dry weight of liver) 
    &gt;&gt;&gt; x = np.array([7.1, 7.1, 7.2, 8.3, 9.4, 10.5, 11.4]) 
    &gt;&gt;&gt; # free proline (Î¼ mole/g dry weight of liver) 
    &gt;&gt;&gt; y = np.array([2.8, 2.9, 2.8, 2.6, 3.5, 4.6, 5.0]) 
 
    These data were analyzed in [4]_ using Spearman's correlation coefficient, 
    a statistic sensitive to monotonic correlation between the samples. 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; res = stats.spearmanr(x, y) 
    &gt;&gt;&gt; res.statistic 
    0.7000000000000001 
 
    The value of this statistic tends to be high (close to 1) for samples with 
    a strongly positive ordinal correlation, low (close to -1) for samples with 
    a strongly negative ordinal correlation, and small in magnitude (close to 
    zero) for samples with weak ordinal correlation. 
 
    The test is performed by comparing the observed value of the 
    statistic against the null distribution: the distribution of statistic 
    values derived under the null hypothesis that total collagen and free 
    proline measurements are independent. 
 
    For this test, the statistic can be transformed such that the null 
    distribution for large samples is Student's t distribution with 
    ``len(x) - 2`` degrees of freedom. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; dof = len(x)-2  # len(x) == len(y) 
    &gt;&gt;&gt; dist = stats.t(df=dof) 
    &gt;&gt;&gt; t_vals = np.linspace(-5, 5, 100) 
    &gt;&gt;&gt; pdf = dist.pdf(t_vals) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; def plot(ax):  # we'll re-use this 
    ...     ax.plot(t_vals, pdf) 
    ...     ax.set_title(&quot;Spearman's Rho Test Null Distribution&quot;) 
    ...     ax.set_xlabel(&quot;statistic&quot;) 
    ...     ax.set_ylabel(&quot;probability density&quot;) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; plt.show() 
 
    The comparison is quantified by the p-value: the proportion of values in 
    the null distribution as extreme or more extreme than the observed 
    value of the statistic. In a two-sided test in which the statistic is 
    positive, elements of the null distribution greater than the transformed 
    statistic and elements of the null distribution less than the negative of 
    the observed statistic are both considered &quot;more extreme&quot;. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; rs = res.statistic  # original statistic 
    &gt;&gt;&gt; transformed = rs * np.sqrt(dof / ((rs+1.0)*(1.0-rs))) 
    &gt;&gt;&gt; pvalue = dist.cdf(-transformed) + dist.sf(transformed) 
    &gt;&gt;&gt; annotation = (f'p-value={pvalue:.4f}\n(shaded area)') 
    &gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8) 
    &gt;&gt;&gt; _ = ax.annotate(annotation, (2.7, 0.025), (3, 0.03), arrowprops=props) 
    &gt;&gt;&gt; i = t_vals &gt;= transformed 
    &gt;&gt;&gt; ax.fill_between(t_vals[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; i = t_vals &lt;= -transformed 
    &gt;&gt;&gt; ax.fill_between(t_vals[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; ax.set_xlim(-5, 5) 
    &gt;&gt;&gt; ax.set_ylim(0, 0.1) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.07991669030889909  # two-sided p-value 
 
    If the p-value is &quot;small&quot; - that is, if there is a low probability of 
    sampling data from independent distributions that produces such an extreme 
    value of the statistic - this may be taken as evidence against the null 
    hypothesis in favor of the alternative: the distribution of total collagen 
    and free proline are *not* independent. Note that: 
 
    - The inverse is not true; that is, the test is not used to provide 
      evidence for the null hypothesis. 
    - The threshold for values that will be considered &quot;small&quot; is a choice that 
      should be made before the data is analyzed [5]_ with consideration of the 
      risks of both false positives (incorrectly rejecting the null hypothesis) 
      and false negatives (failure to reject a false null hypothesis). 
    - Small p-values are not evidence for a *large* effect; rather, they can 
      only provide evidence for a &quot;significant&quot; effect, meaning that they are 
      unlikely to have occurred under the null hypothesis. 
 
    Suppose that before performing the experiment, the authors had reason 
    to predict a positive correlation between the total collagen and free 
    proline measurements, and that they had chosen to assess the plausibility 
    of the null hypothesis against a one-sided alternative: free proline has a 
    positive ordinal correlation with total collagen. In this case, only those 
    values in the null distribution that are as great or greater than the 
    observed statistic are considered to be more extreme. 
 
    &gt;&gt;&gt; res = stats.spearmanr(x, y, alternative='greater') 
    &gt;&gt;&gt; res.statistic 
    0.7000000000000001  # same statistic 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; pvalue = dist.sf(transformed) 
    &gt;&gt;&gt; annotation = (f'p-value={pvalue:.6f}\n(shaded area)') 
    &gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8) 
    &gt;&gt;&gt; _ = ax.annotate(annotation, (3, 0.018), (3.5, 0.03), arrowprops=props) 
    &gt;&gt;&gt; i = t_vals &gt;= transformed 
    &gt;&gt;&gt; ax.fill_between(t_vals[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; ax.set_xlim(1, 5) 
    &gt;&gt;&gt; ax.set_ylim(0, 0.1) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.03995834515444954  # one-sided p-value; half of the two-sided p-value 
 
    Note that the t-distribution provides an asymptotic approximation of the 
    null distribution; it is only accurate for samples with many observations. 
    For small samples, it may be more appropriate to perform a permutation 
    test: Under the null hypothesis that total collagen and free proline are 
    independent, each of the free proline measurements were equally likely to 
    have been observed with any of the total collagen measurements. Therefore, 
    we can form an *exact* null distribution by calculating the statistic under 
    each possible pairing of elements between ``x`` and ``y``. 
 
    &gt;&gt;&gt; def statistic(x):  # explore all possible pairings by permuting `x` 
    ...     rs = stats.spearmanr(x, y).statistic  # ignore pvalue 
    ...     transformed = rs * np.sqrt(dof / ((rs+1.0)*(1.0-rs))) 
    ...     return transformed 
    &gt;&gt;&gt; ref = stats.permutation_test((x,), statistic, alternative='greater', 
    ...                              permutation_type='pairings') 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; ax.hist(ref.null_distribution, np.linspace(-5, 5, 26), 
    ...         density=True) 
    &gt;&gt;&gt; ax.legend(['aymptotic approximation\n(many observations)', 
    ...            f'exact \n({len(ref.null_distribution)} permutations)']) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; ref.pvalue 
    0.04563492063492063  # exact one-sided p-value 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None and </span><span class="s1">axis &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;spearmanr only handles 1-D or 2-D arrays, &quot;</span>
                         <span class="s4">&quot;supplied axis argument {}, please use only &quot;</span>
                         <span class="s4">&quot;values 0, 1 or None for axis&quot;</span><span class="s1">.format(axis))</span>

    <span class="s1">a</span><span class="s3">, </span><span class="s1">axisout = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s3">if </span><span class="s1">a.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;spearmanr only handles 1-D or 2-D arrays&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">b </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">a.ndim &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`spearmanr` needs at least 2 &quot;</span>
                             <span class="s4">&quot;variables to compare&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># Concatenate a and b, so that we now only have to handle the case</span>
        <span class="s0"># of a 2-D `a`.</span>
        <span class="s1">b</span><span class="s3">, </span><span class="s1">_ = _chk_asarray(b</span><span class="s3">, </span><span class="s1">axis)</span>
        <span class="s3">if </span><span class="s1">axisout == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">a = np.column_stack((a</span><span class="s3">, </span><span class="s1">b))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a = np.row_stack((a</span><span class="s3">, </span><span class="s1">b))</span>

    <span class="s1">n_vars = a.shape[</span><span class="s5">1 </span><span class="s1">- axisout]</span>
    <span class="s1">n_obs = a.shape[axisout]</span>
    <span class="s3">if </span><span class="s1">n_obs &lt;= </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># Handle empty arrays or single observations.</span>
        <span class="s1">res = SignificanceResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
        <span class="s1">res.correlation = np.nan</span>
        <span class="s3">return </span><span class="s1">res</span>

    <span class="s1">warn_msg = (</span><span class="s4">&quot;An input array is constant; the correlation coefficient &quot;</span>
                <span class="s4">&quot;is not defined.&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">axisout == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(a[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] == a[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]).all() </span><span class="s3">or </span><span class="s1">(a[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] == a[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]).all():</span>
            <span class="s0"># If an input is constant, the correlation coefficient</span>
            <span class="s0"># is not defined.</span>
            <span class="s1">warnings.warn(stats.ConstantInputWarning(warn_msg))</span>
            <span class="s1">res = SignificanceResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
            <span class="s1">res.correlation = np.nan</span>
            <span class="s3">return </span><span class="s1">res</span>
    <span class="s3">else</span><span class="s1">:  </span><span class="s0"># case when axisout == 1 b/c a is 2 dim only</span>
        <span class="s3">if </span><span class="s1">(a[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">:][</span><span class="s5">0</span><span class="s1">] == a[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">:]).all() </span><span class="s3">or </span><span class="s1">(a[</span><span class="s5">1</span><span class="s3">, </span><span class="s1">:][</span><span class="s5">0</span><span class="s1">] == a[</span><span class="s5">1</span><span class="s3">, </span><span class="s1">:]).all():</span>
            <span class="s0"># If an input is constant, the correlation coefficient</span>
            <span class="s0"># is not defined.</span>
            <span class="s1">warnings.warn(stats.ConstantInputWarning(warn_msg))</span>
            <span class="s1">res = SignificanceResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
            <span class="s1">res.correlation = np.nan</span>
            <span class="s3">return </span><span class="s1">res</span>

    <span class="s1">a_contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(a</span><span class="s3">, </span><span class="s1">nan_policy)</span>
    <span class="s1">variable_has_nan = np.zeros(n_vars</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s3">if </span><span class="s1">a_contains_nan:</span>
        <span class="s3">if </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">mstats_basic.spearmanr(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">nan_policy=nan_policy</span><span class="s3">,</span>
                                          <span class="s1">alternative=alternative)</span>
        <span class="s3">elif </span><span class="s1">nan_policy == </span><span class="s4">'propagate'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">a.ndim == </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n_vars &lt;= </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">res = SignificanceResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
                <span class="s1">res.correlation = np.nan</span>
                <span class="s3">return </span><span class="s1">res</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># Keep track of variables with NaNs, set the outputs to NaN</span>
                <span class="s0"># only for those variables</span>
                <span class="s1">variable_has_nan = np.isnan(a).any(axis=axisout)</span>

    <span class="s1">a_ranked = np.apply_along_axis(rankdata</span><span class="s3">, </span><span class="s1">axisout</span><span class="s3">, </span><span class="s1">a)</span>
    <span class="s1">rs = np.corrcoef(a_ranked</span><span class="s3">, </span><span class="s1">rowvar=axisout)</span>
    <span class="s1">dof = n_obs - </span><span class="s5">2  </span><span class="s0"># degrees of freedom</span>

    <span class="s0"># rs can have elements equal to 1, so avoid zero division warnings</span>
    <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s0"># clip the small negative values possibly caused by rounding</span>
        <span class="s0"># errors before taking the square root</span>
        <span class="s1">t = rs * np.sqrt((dof/((rs+</span><span class="s5">1.0</span><span class="s1">)*(</span><span class="s5">1.0</span><span class="s1">-rs))).clip(</span><span class="s5">0</span><span class="s1">))</span>

    <span class="s1">t</span><span class="s3">, </span><span class="s1">prob = _ttest_finish(dof</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative)</span>

    <span class="s0"># For backwards compatibility, return scalars when comparing 2 columns</span>
    <span class="s3">if </span><span class="s1">rs.shape == (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
        <span class="s1">res = SignificanceResult(rs[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">prob[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">res.correlation = rs[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">res</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">rs[variable_has_nan</span><span class="s3">, </span><span class="s1">:] = np.nan</span>
        <span class="s1">rs[:</span><span class="s3">, </span><span class="s1">variable_has_nan] = np.nan</span>
        <span class="s1">res = SignificanceResult(rs</span><span class="s3">, </span><span class="s1">prob)</span>
        <span class="s1">res.correlation = rs</span>
        <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">pointbiserialr(x</span><span class="s3">, </span><span class="s1">y):</span>
    <span class="s2">r&quot;&quot;&quot;Calculate a point biserial correlation coefficient and its p-value. 
 
    The point biserial correlation is used to measure the relationship 
    between a binary variable, x, and a continuous variable, y. Like other 
    correlation coefficients, this one varies between -1 and +1 with 0 
    implying no correlation. Correlations of -1 or +1 imply a determinative 
    relationship. 
 
    This function may be computed using a shortcut formula but produces the 
    same result as `pearsonr`. 
 
    Parameters 
    ---------- 
    x : array_like of bools 
        Input array. 
    y : array_like 
        Input array. 
 
    Returns 
    ------- 
    res: SignificanceResult 
        An object containing attributes: 
 
        statistic : float 
            The R value. 
        pvalue : float 
            The two-sided p-value. 
 
    Notes 
    ----- 
    `pointbiserialr` uses a t-test with ``n-1`` degrees of freedom. 
    It is equivalent to `pearsonr`. 
 
    The value of the point-biserial correlation can be calculated from: 
 
    .. math:: 
 
        r_{pb} = \frac{\overline{Y_1} - \overline{Y_0}} 
                      {s_y} 
                 \sqrt{\frac{N_0 N_1} 
                            {N (N - 1)}} 
 
    Where :math:`\overline{Y_{0}}` and :math:`\overline{Y_{1}}` are means 
    of the metric observations coded 0 and 1 respectively; :math:`N_{0}` and 
    :math:`N_{1}` are number of observations coded 0 and 1 respectively; 
    :math:`N` is the total number of observations and :math:`s_{y}` is the 
    standard deviation of all the metric observations. 
 
    A value of :math:`r_{pb}` that is significantly different from zero is 
    completely equivalent to a significant difference in means between the two 
    groups. Thus, an independent groups t Test with :math:`N-2` degrees of 
    freedom may be used to test whether :math:`r_{pb}` is nonzero. The 
    relation between the t-statistic for comparing two independent groups and 
    :math:`r_{pb}` is given by: 
 
    .. math:: 
 
        t = \sqrt{N - 2}\frac{r_{pb}}{\sqrt{1 - r^{2}_{pb}}} 
 
    References 
    ---------- 
    .. [1] J. Lev, &quot;The Point Biserial Coefficient of Correlation&quot;, Ann. Math. 
           Statist., Vol. 20, no.1, pp. 125-126, 1949. 
 
    .. [2] R.F. Tate, &quot;Correlation Between a Discrete and a Continuous 
           Variable. Point-Biserial Correlation.&quot;, Ann. Math. Statist., Vol. 25, 
           np. 3, pp. 603-607, 1954. 
 
    .. [3] D. Kornbrot &quot;Point Biserial Correlation&quot;, In Wiley StatsRef: 
           Statistics Reference Online (eds N. Balakrishnan, et al.), 2014. 
           :doi:`10.1002/9781118445112.stat06227` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; a = np.array([0, 0, 0, 1, 1, 1, 1]) 
    &gt;&gt;&gt; b = np.arange(7) 
    &gt;&gt;&gt; stats.pointbiserialr(a, b) 
    (0.8660254037844386, 0.011724811003954652) 
    &gt;&gt;&gt; stats.pearsonr(a, b) 
    (0.86602540378443871, 0.011724811003954626) 
    &gt;&gt;&gt; np.corrcoef(a, b) 
    array([[ 1.       ,  0.8660254], 
           [ 0.8660254,  1.       ]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">rpb</span><span class="s3">, </span><span class="s1">prob = pearsonr(x</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s0"># create result object with alias for backward compatibility</span>
    <span class="s1">res = SignificanceResult(rpb</span><span class="s3">, </span><span class="s1">prob)</span>
    <span class="s1">res.correlation = rpb</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">kendalltau(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">initial_lexsort=</span><span class="s3">None, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">,</span>
               <span class="s1">method=</span><span class="s4">'auto'</span><span class="s3">, </span><span class="s1">variant=</span><span class="s4">'b'</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Calculate Kendall's tau, a correlation measure for ordinal data. 
 
    Kendall's tau is a measure of the correspondence between two rankings. 
    Values close to 1 indicate strong agreement, and values close to -1 
    indicate strong disagreement. This implements two variants of Kendall's 
    tau: tau-b (the default) and tau-c (also known as Stuart's tau-c). These 
    differ only in how they are normalized to lie within the range -1 to 1; 
    the hypothesis tests (their p-values) are identical. Kendall's original 
    tau-a is not implemented separately because both tau-b and tau-c reduce 
    to tau-a in the absence of ties. 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Arrays of rankings, of the same shape. If arrays are not 1-D, they 
        will be flattened to 1-D. 
    initial_lexsort : bool, optional, deprecated 
        This argument is unused. 
 
        .. deprecated:: 1.10.0 
           `kendalltau` keyword argument `initial_lexsort` is deprecated as it 
           is unused and will be removed in SciPy 1.12.0. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    method : {'auto', 'asymptotic', 'exact'}, optional 
        Defines which method is used to calculate the p-value [5]_. 
        The following options are available (default is 'auto'): 
 
          * 'auto': selects the appropriate method based on a trade-off 
            between speed and accuracy 
          * 'asymptotic': uses a normal approximation valid for large samples 
          * 'exact': computes the exact p-value, but can only be used if no ties 
            are present. As the sample size increases, the 'exact' computation 
            time may grow and the result may lose some precision. 
    variant : {'b', 'c'}, optional 
        Defines which variant of Kendall's tau is returned. Default is 'b'. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        The following options are available: 
 
        * 'two-sided': the rank correlation is nonzero 
        * 'less': the rank correlation is negative (less than zero) 
        * 'greater':  the rank correlation is positive (greater than zero) 
 
    Returns 
    ------- 
    res : SignificanceResult 
        An object containing attributes: 
 
        statistic : float 
           The tau statistic. 
        pvalue : float 
           The p-value for a hypothesis test whose null hypothesis is 
           an absence of association, tau = 0. 
 
    See Also 
    -------- 
    spearmanr : Calculates a Spearman rank-order correlation coefficient. 
    theilslopes : Computes the Theil-Sen estimator for a set of points (x, y). 
    weightedtau : Computes a weighted version of Kendall's tau. 
 
    Notes 
    ----- 
    The definition of Kendall's tau that is used is [2]_:: 
 
      tau_b = (P - Q) / sqrt((P + Q + T) * (P + Q + U)) 
 
      tau_c = 2 (P - Q) / (n**2 * (m - 1) / m) 
 
    where P is the number of concordant pairs, Q the number of discordant 
    pairs, T the number of ties only in `x`, and U the number of ties only in 
    `y`.  If a tie occurs for the same pair in both `x` and `y`, it is not 
    added to either T or U. n is the total number of samples, and m is the 
    number of unique values in either `x` or `y`, whichever is smaller. 
 
    References 
    ---------- 
    .. [1] Maurice G. Kendall, &quot;A New Measure of Rank Correlation&quot;, Biometrika 
           Vol. 30, No. 1/2, pp. 81-93, 1938. 
    .. [2] Maurice G. Kendall, &quot;The treatment of ties in ranking problems&quot;, 
           Biometrika Vol. 33, No. 3, pp. 239-251. 1945. 
    .. [3] Gottfried E. Noether, &quot;Elements of Nonparametric Statistics&quot;, John 
           Wiley &amp; Sons, 1967. 
    .. [4] Peter M. Fenwick, &quot;A new data structure for cumulative frequency 
           tables&quot;, Software: Practice and Experience, Vol. 24, No. 3, 
           pp. 327-336, 1994. 
    .. [5] Maurice G. Kendall, &quot;Rank Correlation Methods&quot; (4th Edition), 
           Charles Griffin &amp; Co., 1970. 
    .. [6] Kershenobich, D., Fierro, F. J., &amp; Rojkind, M. (1970). The 
           relationship between the free pool of proline and collagen content 
           in human liver cirrhosis. The Journal of Clinical Investigation, 
           49(12), 2246-2249. 
    .. [7] Hollander, M., Wolfe, D. A., &amp; Chicken, E. (2013). Nonparametric 
           statistical methods. John Wiley &amp; Sons. 
    .. [8] B. Phipson and G. K. Smyth. &quot;Permutation P-values Should Never Be 
           Zero: Calculating Exact P-values When Permutations Are Randomly 
           Drawn.&quot; Statistical Applications in Genetics and Molecular Biology 
           9.1 (2010). 
 
    Examples 
    -------- 
    Consider the following data from [6]_, which studied the relationship 
    between free proline (an amino acid) and total collagen (a protein often 
    found in connective tissue) in unhealthy human livers. 
 
    The ``x`` and ``y`` arrays below record measurements of the two compounds. 
    The observations are paired: each free proline measurement was taken from 
    the same liver as the total collagen measurement at the same index. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; # total collagen (mg/g dry weight of liver) 
    &gt;&gt;&gt; x = np.array([7.1, 7.1, 7.2, 8.3, 9.4, 10.5, 11.4]) 
    &gt;&gt;&gt; # free proline (Î¼ mole/g dry weight of liver) 
    &gt;&gt;&gt; y = np.array([2.8, 2.9, 2.8, 2.6, 3.5, 4.6, 5.0]) 
 
    These data were analyzed in [7]_ using Spearman's correlation coefficient, 
    a statistic similar to to Kendall's tau in that it is also sensitive to 
    ordinal correlation between the samples. Let's perform an analagous study 
    using Kendall's tau. 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; res = stats.kendalltau(x, y) 
    &gt;&gt;&gt; res.statistic 
    0.5499999999999999 
 
    The value of this statistic tends to be high (close to 1) for samples with 
    a strongly positive ordinal correlation, low (close to -1) for samples with 
    a strongly negative ordinal correlation, and small in magnitude (close to 
    zero) for samples with weak ordinal correlation. 
 
    The test is performed by comparing the observed value of the 
    statistic against the null distribution: the distribution of statistic 
    values derived under the null hypothesis that total collagen and free 
    proline measurements are independent. 
 
    For this test, the null distribution for large samples without ties is 
    approximated as the normal distribution with variance 
    ``(2*(2*n + 5))/(9*n*(n - 1))``, where ``n = len(x)``. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; n = len(x)  # len(x) == len(y) 
    &gt;&gt;&gt; var = (2*(2*n + 5))/(9*n*(n - 1)) 
    &gt;&gt;&gt; dist = stats.norm(scale=np.sqrt(var)) 
    &gt;&gt;&gt; z_vals = np.linspace(-1.25, 1.25, 100) 
    &gt;&gt;&gt; pdf = dist.pdf(z_vals) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; def plot(ax):  # we'll re-use this 
    ...     ax.plot(z_vals, pdf) 
    ...     ax.set_title(&quot;Kendall Tau Test Null Distribution&quot;) 
    ...     ax.set_xlabel(&quot;statistic&quot;) 
    ...     ax.set_ylabel(&quot;probability density&quot;) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; plt.show() 
 
    The comparison is quantified by the p-value: the proportion of values in 
    the null distribution as extreme or more extreme than the observed 
    value of the statistic. In a two-sided test in which the statistic is 
    positive, elements of the null distribution greater than the transformed 
    statistic and elements of the null distribution less than the negative of 
    the observed statistic are both considered &quot;more extreme&quot;. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; pvalue = dist.cdf(-res.statistic) + dist.sf(res.statistic) 
    &gt;&gt;&gt; annotation = (f'p-value={pvalue:.4f}\n(shaded area)') 
    &gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8) 
    &gt;&gt;&gt; _ = ax.annotate(annotation, (0.65, 0.15), (0.8, 0.3), arrowprops=props) 
    &gt;&gt;&gt; i = z_vals &gt;= res.statistic 
    &gt;&gt;&gt; ax.fill_between(z_vals[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; i = z_vals &lt;= -res.statistic 
    &gt;&gt;&gt; ax.fill_between(z_vals[i], y1=0, y2=pdf[i], color='C0') 
    &gt;&gt;&gt; ax.set_xlim(-1.25, 1.25) 
    &gt;&gt;&gt; ax.set_ylim(0, 0.5) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; res.pvalue 
    0.09108705741631495  # approximate p-value 
 
    Note that there is slight disagreement between the shaded area of the curve 
    and the p-value returned by `kendalltau`. This is because our data has 
    ties, and we have neglected a tie correction to the null distribution 
    variance that `kendalltau` performs. For samples without ties, the shaded 
    areas of our plot and p-value returned by `kendalltau` would match exactly. 
 
    If the p-value is &quot;small&quot; - that is, if there is a low probability of 
    sampling data from independent distributions that produces such an extreme 
    value of the statistic - this may be taken as evidence against the null 
    hypothesis in favor of the alternative: the distribution of total collagen 
    and free proline are *not* independent. Note that: 
 
    - The inverse is not true; that is, the test is not used to provide 
      evidence for the null hypothesis. 
    - The threshold for values that will be considered &quot;small&quot; is a choice that 
      should be made before the data is analyzed [8]_ with consideration of the 
      risks of both false positives (incorrectly rejecting the null hypothesis) 
      and false negatives (failure to reject a false null hypothesis). 
    - Small p-values are not evidence for a *large* effect; rather, they can 
      only provide evidence for a &quot;significant&quot; effect, meaning that they are 
      unlikely to have occurred under the null hypothesis. 
 
    For samples without ties of moderate size, `kendalltau` can compute the 
    p-value exactly. However, in the presence of ties, `kendalltau` resorts 
    to an asymptotic approximation. Nonetheles, we can use a permutation test 
    to compute the null distribution exactly: Under the null hypothesis that 
    total collagen and free proline are independent, each of the free proline 
    measurements were equally likely to have been observed with any of the 
    total collagen measurements. Therefore, we can form an *exact* null 
    distribution by calculating the statistic under each possible pairing of 
    elements between ``x`` and ``y``. 
 
    &gt;&gt;&gt; def statistic(x):  # explore all possible pairings by permuting `x` 
    ...     return stats.kendalltau(x, y).statistic  # ignore pvalue 
    &gt;&gt;&gt; ref = stats.permutation_test((x,), statistic, 
    ...                              permutation_type='pairings') 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5)) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; bins = np.linspace(-1.25, 1.25, 25) 
    &gt;&gt;&gt; ax.hist(ref.null_distribution, bins=bins, density=True) 
    &gt;&gt;&gt; ax.legend(['aymptotic approximation\n(many observations)', 
    ...            'exact null distribution']) 
    &gt;&gt;&gt; plot(ax) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; ref.pvalue 
    0.12222222222222222  # exact p-value 
 
    Note that there is significant disagreement between the exact p-value 
    calculated here and the approximation returned by `kendalltau` above. For 
    small samples with ties, consider performing a permutation test for more 
    accurate results. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">initial_lexsort </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">msg = (</span><span class="s4">&quot;'kendalltau' keyword argument 'initial_lexsort' is deprecated&quot;</span>
               <span class="s4">&quot; as it is unused and will be removed in SciPy 1.12.0.&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">x = np.asarray(x).ravel()</span>
    <span class="s1">y = np.asarray(y).ravel()</span>

    <span class="s3">if </span><span class="s1">x.size != y.size:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;All inputs to `kendalltau` must be of the same &quot;</span>
                         <span class="s4">f&quot;size, found x-size </span><span class="s3">{</span><span class="s1">x.size</span><span class="s3">} </span><span class="s4">and y-size </span><span class="s3">{</span><span class="s1">y.size</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s3">elif not </span><span class="s1">x.size </span><span class="s3">or not </span><span class="s1">y.size:</span>
        <span class="s0"># Return NaN if arrays are empty</span>
        <span class="s1">res = SignificanceResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
        <span class="s1">res.correlation = np.nan</span>
        <span class="s3">return </span><span class="s1">res</span>

    <span class="s0"># check both x and y</span>
    <span class="s1">cnx</span><span class="s3">, </span><span class="s1">npx = _contains_nan(x</span><span class="s3">, </span><span class="s1">nan_policy)</span>
    <span class="s1">cny</span><span class="s3">, </span><span class="s1">npy = _contains_nan(y</span><span class="s3">, </span><span class="s1">nan_policy)</span>
    <span class="s1">contains_nan = cnx </span><span class="s3">or </span><span class="s1">cny</span>
    <span class="s3">if </span><span class="s1">npx == </span><span class="s4">'omit' </span><span class="s3">or </span><span class="s1">npy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">nan_policy = </span><span class="s4">'omit'</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'propagate'</span><span class="s1">:</span>
        <span class="s1">res = SignificanceResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
        <span class="s1">res.correlation = np.nan</span>
        <span class="s3">return </span><span class="s1">res</span>

    <span class="s3">elif </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s1">x = ma.masked_invalid(x)</span>
        <span class="s1">y = ma.masked_invalid(y)</span>
        <span class="s3">if </span><span class="s1">variant == </span><span class="s4">'b'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">mstats_basic.kendalltau(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">method=method</span><span class="s3">, </span><span class="s1">use_ties=</span><span class="s3">True,</span>
                                           <span class="s1">alternative=alternative)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">message = (</span><span class="s4">&quot;nan_policy='omit' is currently compatible only with &quot;</span>
                       <span class="s4">&quot;variant='b'.&quot;</span><span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">ValueError(message)</span>

    <span class="s3">def </span><span class="s1">count_rank_tie(ranks):</span>
        <span class="s1">cnt = np.bincount(ranks).astype(</span><span class="s4">'int64'</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">cnt = cnt[cnt &gt; </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0"># Python ints to avoid overflow down the line</span>
        <span class="s3">return </span><span class="s1">(int((cnt * (cnt - </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2</span><span class="s1">).sum())</span><span class="s3">,</span>
                <span class="s1">int((cnt * (cnt - </span><span class="s5">1.</span><span class="s1">) * (cnt - </span><span class="s5">2</span><span class="s1">)).sum())</span><span class="s3">,</span>
                <span class="s1">int((cnt * (cnt - </span><span class="s5">1.</span><span class="s1">) * (</span><span class="s5">2</span><span class="s1">*cnt + </span><span class="s5">5</span><span class="s1">)).sum()))</span>

    <span class="s1">size = x.size</span>
    <span class="s1">perm = np.argsort(y)  </span><span class="s0"># sort on y and convert y to dense ranks</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">y = x[perm]</span><span class="s3">, </span><span class="s1">y[perm]</span>
    <span class="s1">y = np.r_[</span><span class="s3">True, </span><span class="s1">y[</span><span class="s5">1</span><span class="s1">:] != y[:-</span><span class="s5">1</span><span class="s1">]].cumsum(dtype=np.intp)</span>

    <span class="s0"># stable sort on x and convert x to dense ranks</span>
    <span class="s1">perm = np.argsort(x</span><span class="s3">, </span><span class="s1">kind=</span><span class="s4">'mergesort'</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">y = x[perm]</span><span class="s3">, </span><span class="s1">y[perm]</span>
    <span class="s1">x = np.r_[</span><span class="s3">True, </span><span class="s1">x[</span><span class="s5">1</span><span class="s1">:] != x[:-</span><span class="s5">1</span><span class="s1">]].cumsum(dtype=np.intp)</span>

    <span class="s1">dis = _kendall_dis(x</span><span class="s3">, </span><span class="s1">y)  </span><span class="s0"># discordant pairs</span>

    <span class="s1">obs = np.r_[</span><span class="s3">True, </span><span class="s1">(x[</span><span class="s5">1</span><span class="s1">:] != x[:-</span><span class="s5">1</span><span class="s1">]) | (y[</span><span class="s5">1</span><span class="s1">:] != y[:-</span><span class="s5">1</span><span class="s1">])</span><span class="s3">, True</span><span class="s1">]</span>
    <span class="s1">cnt = np.diff(np.nonzero(obs)[</span><span class="s5">0</span><span class="s1">]).astype(</span><span class="s4">'int64'</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s1">ntie = int((cnt * (cnt - </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2</span><span class="s1">).sum())  </span><span class="s0"># joint ties</span>
    <span class="s1">xtie</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">x1 = count_rank_tie(x)     </span><span class="s0"># ties in x, stats</span>
    <span class="s1">ytie</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">y1 = count_rank_tie(y)     </span><span class="s0"># ties in y, stats</span>

    <span class="s1">tot = (size * (size - </span><span class="s5">1</span><span class="s1">)) // </span><span class="s5">2</span>

    <span class="s3">if </span><span class="s1">xtie == tot </span><span class="s3">or </span><span class="s1">ytie == tot:</span>
        <span class="s1">res = SignificanceResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
        <span class="s1">res.correlation = np.nan</span>
        <span class="s3">return </span><span class="s1">res</span>

    <span class="s0"># Note that tot = con + dis + (xtie - ntie) + (ytie - ntie) + ntie</span>
    <span class="s0">#               = con + dis + xtie + ytie - ntie</span>
    <span class="s1">con_minus_dis = tot - xtie - ytie + ntie - </span><span class="s5">2 </span><span class="s1">* dis</span>
    <span class="s3">if </span><span class="s1">variant == </span><span class="s4">'b'</span><span class="s1">:</span>
        <span class="s1">tau = con_minus_dis / np.sqrt(tot - xtie) / np.sqrt(tot - ytie)</span>
    <span class="s3">elif </span><span class="s1">variant == </span><span class="s4">'c'</span><span class="s1">:</span>
        <span class="s1">minclasses = min(len(set(x))</span><span class="s3">, </span><span class="s1">len(set(y)))</span>
        <span class="s1">tau = </span><span class="s5">2</span><span class="s1">*con_minus_dis / (size**</span><span class="s5">2 </span><span class="s1">* (minclasses-</span><span class="s5">1</span><span class="s1">)/minclasses)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unknown variant of the method chosen: </span><span class="s3">{</span><span class="s1">variant</span><span class="s3">}</span><span class="s4">. &quot;</span>
                         <span class="s4">&quot;variant must be 'b' or 'c'.&quot;</span><span class="s1">)</span>

    <span class="s0"># Limit range to fix computational errors</span>
    <span class="s1">tau = min(</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">max(-</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">tau))</span>

    <span class="s0"># The p-value calculation is the same for all variants since the p-value</span>
    <span class="s0"># depends only on con_minus_dis.</span>
    <span class="s3">if </span><span class="s1">method == </span><span class="s4">'exact' </span><span class="s3">and </span><span class="s1">(xtie != </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">ytie != </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Ties found, exact method cannot be used.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">method == </span><span class="s4">'auto'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(xtie == </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">ytie == </span><span class="s5">0</span><span class="s1">) </span><span class="s3">and </span><span class="s1">(size &lt;= </span><span class="s5">33 </span><span class="s3">or</span>
                                          <span class="s1">min(dis</span><span class="s3">, </span><span class="s1">tot-dis) &lt;= </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">method = </span><span class="s4">'exact'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">method = </span><span class="s4">'asymptotic'</span>

    <span class="s3">if </span><span class="s1">xtie == </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">ytie == </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">method == </span><span class="s4">'exact'</span><span class="s1">:</span>
        <span class="s1">pvalue = mstats_basic._kendall_p_exact(size</span><span class="s3">, </span><span class="s1">tot-dis</span><span class="s3">, </span><span class="s1">alternative)</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s4">'asymptotic'</span><span class="s1">:</span>
        <span class="s0"># con_minus_dis is approx normally distributed with this variance [3]_</span>
        <span class="s1">m = size * (size - </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">var = ((m * (</span><span class="s5">2</span><span class="s1">*size + </span><span class="s5">5</span><span class="s1">) - x1 - y1) / </span><span class="s5">18 </span><span class="s1">+</span>
               <span class="s1">(</span><span class="s5">2 </span><span class="s1">* xtie * ytie) / m + x0 * y0 / (</span><span class="s5">9 </span><span class="s1">* m * (size - </span><span class="s5">2</span><span class="s1">)))</span>
        <span class="s1">z = con_minus_dis / np.sqrt(var)</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">pvalue = _normtest_finish(z</span><span class="s3">, </span><span class="s1">alternative)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unknown method </span><span class="s3">{</span><span class="s1">method</span><span class="s3">} </span><span class="s4">specified.  Use 'auto', &quot;</span>
                         <span class="s4">&quot;'exact' or 'asymptotic'.&quot;</span><span class="s1">)</span>

    <span class="s0"># create result object with alias for backward compatibility</span>
    <span class="s1">res = SignificanceResult(tau</span><span class="s3">, </span><span class="s1">pvalue)</span>
    <span class="s1">res.correlation = tau</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">weightedtau(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rank=</span><span class="s3">True, </span><span class="s1">weigher=</span><span class="s3">None, </span><span class="s1">additive=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Compute a weighted version of Kendall's :math:`\tau`. 
 
    The weighted :math:`\tau` is a weighted version of Kendall's 
    :math:`\tau` in which exchanges of high weight are more influential than 
    exchanges of low weight. The default parameters compute the additive 
    hyperbolic version of the index, :math:`\tau_\mathrm h`, which has 
    been shown to provide the best balance between important and 
    unimportant elements [1]_. 
 
    The weighting is defined by means of a rank array, which assigns a 
    nonnegative rank to each element (higher importance ranks being 
    associated with smaller values, e.g., 0 is the highest possible rank), 
    and a weigher function, which assigns a weight based on the rank to 
    each element. The weight of an exchange is then the sum or the product 
    of the weights of the ranks of the exchanged elements. The default 
    parameters compute :math:`\tau_\mathrm h`: an exchange between 
    elements with rank :math:`r` and :math:`s` (starting from zero) has 
    weight :math:`1/(r+1) + 1/(s+1)`. 
 
    Specifying a rank array is meaningful only if you have in mind an 
    external criterion of importance. If, as it usually happens, you do 
    not have in mind a specific rank, the weighted :math:`\tau` is 
    defined by averaging the values obtained using the decreasing 
    lexicographical rank by (`x`, `y`) and by (`y`, `x`). This is the 
    behavior with default parameters. Note that the convention used 
    here for ranking (lower values imply higher importance) is opposite 
    to that used by other SciPy statistical functions. 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Arrays of scores, of the same shape. If arrays are not 1-D, they will 
        be flattened to 1-D. 
    rank : array_like of ints or bool, optional 
        A nonnegative rank assigned to each element. If it is None, the 
        decreasing lexicographical rank by (`x`, `y`) will be used: elements of 
        higher rank will be those with larger `x`-values, using `y`-values to 
        break ties (in particular, swapping `x` and `y` will give a different 
        result). If it is False, the element indices will be used 
        directly as ranks. The default is True, in which case this 
        function returns the average of the values obtained using the 
        decreasing lexicographical rank by (`x`, `y`) and by (`y`, `x`). 
    weigher : callable, optional 
        The weigher function. Must map nonnegative integers (zero 
        representing the most important element) to a nonnegative weight. 
        The default, None, provides hyperbolic weighing, that is, 
        rank :math:`r` is mapped to weight :math:`1/(r+1)`. 
    additive : bool, optional 
        If True, the weight of an exchange is computed by adding the 
        weights of the ranks of the exchanged elements; otherwise, the weights 
        are multiplied. The default is True. 
 
    Returns 
    ------- 
    res: SignificanceResult 
        An object containing attributes: 
 
        statistic : float 
           The weighted :math:`\tau` correlation index. 
        pvalue : float 
           Presently ``np.nan``, as the null distribution of the statistic is 
           unknown (even in the additive hyperbolic case). 
 
    See Also 
    -------- 
    kendalltau : Calculates Kendall's tau. 
    spearmanr : Calculates a Spearman rank-order correlation coefficient. 
    theilslopes : Computes the Theil-Sen estimator for a set of points (x, y). 
 
    Notes 
    ----- 
    This function uses an :math:`O(n \log n)`, mergesort-based algorithm 
    [1]_ that is a weighted extension of Knight's algorithm for Kendall's 
    :math:`\tau` [2]_. It can compute Shieh's weighted :math:`\tau` [3]_ 
    between rankings without ties (i.e., permutations) by setting 
    `additive` and `rank` to False, as the definition given in [1]_ is a 
    generalization of Shieh's. 
 
    NaNs are considered the smallest possible score. 
 
    .. versionadded:: 0.19.0 
 
    References 
    ---------- 
    .. [1] Sebastiano Vigna, &quot;A weighted correlation index for rankings with 
           ties&quot;, Proceedings of the 24th international conference on World 
           Wide Web, pp. 1166-1176, ACM, 2015. 
    .. [2] W.R. Knight, &quot;A Computer Method for Calculating Kendall's Tau with 
           Ungrouped Data&quot;, Journal of the American Statistical Association, 
           Vol. 61, No. 314, Part 1, pp. 436-439, 1966. 
    .. [3] Grace S. Shieh. &quot;A weighted Kendall's tau statistic&quot;, Statistics &amp; 
           Probability Letters, Vol. 39, No. 1, pp. 17-24, 1998. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = [12, 2, 1, 12, 2] 
    &gt;&gt;&gt; y = [1, 4, 7, 1, 0] 
    &gt;&gt;&gt; res = stats.weightedtau(x, y) 
    &gt;&gt;&gt; res.statistic 
    -0.56694968153682723 
    &gt;&gt;&gt; res.pvalue 
    nan 
    &gt;&gt;&gt; res = stats.weightedtau(x, y, additive=False) 
    &gt;&gt;&gt; res.statistic 
    -0.62205716951801038 
 
    NaNs are considered the smallest possible score: 
 
    &gt;&gt;&gt; x = [12, 2, 1, 12, 2] 
    &gt;&gt;&gt; y = [1, 4, 7, 1, np.nan] 
    &gt;&gt;&gt; res = stats.weightedtau(x, y) 
    &gt;&gt;&gt; res.statistic 
    -0.56694968153682723 
 
    This is exactly Kendall's tau: 
 
    &gt;&gt;&gt; x = [12, 2, 1, 12, 2] 
    &gt;&gt;&gt; y = [1, 4, 7, 1, 0] 
    &gt;&gt;&gt; res = stats.weightedtau(x, y, weigher=lambda x: 1) 
    &gt;&gt;&gt; res.statistic 
    -0.47140452079103173 
 
    &gt;&gt;&gt; x = [12, 2, 1, 12, 2] 
    &gt;&gt;&gt; y = [1, 4, 7, 1, 0] 
    &gt;&gt;&gt; stats.weightedtau(x, y, rank=None) 
    SignificanceResult(statistic=-0.4157652301037516, pvalue=nan) 
    &gt;&gt;&gt; stats.weightedtau(y, x, rank=None) 
    SignificanceResult(statistic=-0.7181341329699028, pvalue=nan) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.asarray(x).ravel()</span>
    <span class="s1">y = np.asarray(y).ravel()</span>

    <span class="s3">if </span><span class="s1">x.size != y.size:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;All inputs to `weightedtau` must be &quot;</span>
                         <span class="s4">&quot;of the same size, &quot;</span>
                         <span class="s4">&quot;found x-size {} and y-size {}&quot;</span><span class="s1">.format(x.size</span><span class="s3">, </span><span class="s1">y.size))</span>
    <span class="s3">if not </span><span class="s1">x.size:</span>
        <span class="s0"># Return NaN if arrays are empty</span>
        <span class="s1">res = SignificanceResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
        <span class="s1">res.correlation = np.nan</span>
        <span class="s3">return </span><span class="s1">res</span>

    <span class="s0"># If there are NaNs we apply _toint64()</span>
    <span class="s3">if </span><span class="s1">np.isnan(np.sum(x)):</span>
        <span class="s1">x = _toint64(x)</span>
    <span class="s3">if </span><span class="s1">np.isnan(np.sum(y)):</span>
        <span class="s1">y = _toint64(y)</span>

    <span class="s0"># Reduce to ranks unsupported types</span>
    <span class="s3">if </span><span class="s1">x.dtype != y.dtype:</span>
        <span class="s3">if </span><span class="s1">x.dtype != np.int64:</span>
            <span class="s1">x = _toint64(x)</span>
        <span class="s3">if </span><span class="s1">y.dtype != np.int64:</span>
            <span class="s1">y = _toint64(y)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">x.dtype </span><span class="s3">not in </span><span class="s1">(np.int32</span><span class="s3">, </span><span class="s1">np.int64</span><span class="s3">, </span><span class="s1">np.float32</span><span class="s3">, </span><span class="s1">np.float64):</span>
            <span class="s1">x = _toint64(x)</span>
            <span class="s1">y = _toint64(y)</span>

    <span class="s3">if </span><span class="s1">rank </span><span class="s3">is True</span><span class="s1">:</span>
        <span class="s1">tau = (</span>
            <span class="s1">_weightedrankedtau(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, None, </span><span class="s1">weigher</span><span class="s3">, </span><span class="s1">additive) +</span>
            <span class="s1">_weightedrankedtau(y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, None, </span><span class="s1">weigher</span><span class="s3">, </span><span class="s1">additive)</span>
        <span class="s1">) / </span><span class="s5">2</span>
        <span class="s1">res = SignificanceResult(tau</span><span class="s3">, </span><span class="s1">np.nan)</span>
        <span class="s1">res.correlation = tau</span>
        <span class="s3">return </span><span class="s1">res</span>

    <span class="s3">if </span><span class="s1">rank </span><span class="s3">is False</span><span class="s1">:</span>
        <span class="s1">rank = np.arange(x.size</span><span class="s3">, </span><span class="s1">dtype=np.intp)</span>
    <span class="s3">elif </span><span class="s1">rank </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">rank = np.asarray(rank).ravel()</span>
        <span class="s3">if </span><span class="s1">rank.size != x.size:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;All inputs to `weightedtau` must be of the same size, &quot;</span>
                <span class="s4">&quot;found x-size {} and rank-size {}&quot;</span><span class="s1">.format(x.size</span><span class="s3">, </span><span class="s1">rank.size)</span>
            <span class="s1">)</span>

    <span class="s1">tau = _weightedrankedtau(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">, </span><span class="s1">weigher</span><span class="s3">, </span><span class="s1">additive)</span>
    <span class="s1">res = SignificanceResult(tau</span><span class="s3">, </span><span class="s1">np.nan)</span>
    <span class="s1">res.correlation = tau</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s0"># FROM MGCPY: https://github.com/neurodata/mgcpy</span>


<span class="s3">class </span><span class="s1">_ParallelP:</span>
    <span class="s2">&quot;&quot;&quot;Helper function to calculate parallel p-value.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">random_states):</span>
        <span class="s1">self.x = x</span>
        <span class="s1">self.y = y</span>
        <span class="s1">self.random_states = random_states</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">index):</span>
        <span class="s1">order = self.random_states[index].permutation(self.y.shape[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">permy = self.y[order][:</span><span class="s3">, </span><span class="s1">order]</span>

        <span class="s0"># calculate permuted stats, store in null distribution</span>
        <span class="s1">perm_stat = _mgc_stat(self.x</span><span class="s3">, </span><span class="s1">permy)[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s3">return </span><span class="s1">perm_stat</span>


<span class="s3">def </span><span class="s1">_perm_test(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">stat</span><span class="s3">, </span><span class="s1">reps=</span><span class="s5">1000</span><span class="s3">, </span><span class="s1">workers=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Helper function that calculates the p-value. See below for uses. 
 
    Parameters 
    ---------- 
    x, y : ndarray 
        `x` and `y` have shapes `(n, p)` and `(n, q)`. 
    stat : float 
        The sample test statistic. 
    reps : int, optional 
        The number of replications used to estimate the null when using the 
        permutation test. The default is 1000 replications. 
    workers : int or map-like callable, optional 
        If `workers` is an int the population is subdivided into `workers` 
        sections and evaluated in parallel (uses 
        `multiprocessing.Pool &lt;multiprocessing&gt;`). Supply `-1` to use all cores 
        available to the Process. Alternatively supply a map-like callable, 
        such as `multiprocessing.Pool.map` for evaluating the population in 
        parallel. This evaluation is carried out as `workers(func, iterable)`. 
        Requires that `func` be pickleable. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    Returns 
    ------- 
    pvalue : float 
        The sample test p-value. 
    null_dist : list 
        The approximated null distribution. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># generate seeds for each rep (change to new parallel random number</span>
    <span class="s0"># capabilities in numpy &gt;= 1.17+)</span>
    <span class="s1">random_state = check_random_state(random_state)</span>
    <span class="s1">random_states = [np.random.RandomState(rng_integers(random_state</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">32</span><span class="s3">,</span>
                     <span class="s1">size=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">dtype=np.uint32)) </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(reps)]</span>

    <span class="s0"># parallelizes with specified workers over number of reps and set seeds</span>
    <span class="s1">parallelp = _ParallelP(x=x</span><span class="s3">, </span><span class="s1">y=y</span><span class="s3">, </span><span class="s1">random_states=random_states)</span>
    <span class="s3">with </span><span class="s1">MapWrapper(workers) </span><span class="s3">as </span><span class="s1">mapwrapper:</span>
        <span class="s1">null_dist = np.array(list(mapwrapper(parallelp</span><span class="s3">, </span><span class="s1">range(reps))))</span>

    <span class="s0"># calculate p-value and significant permutation map through list</span>
    <span class="s1">pvalue = (</span><span class="s5">1 </span><span class="s1">+ (null_dist &gt;= stat).sum()) / (</span><span class="s5">1 </span><span class="s1">+ reps)</span>

    <span class="s3">return </span><span class="s1">pvalue</span><span class="s3">, </span><span class="s1">null_dist</span>


<span class="s3">def </span><span class="s1">_euclidean_dist(x):</span>
    <span class="s3">return </span><span class="s1">cdist(x</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s1">MGCResult = _make_tuple_bunch(</span><span class="s4">'MGCResult'</span><span class="s3">,</span>
                              <span class="s1">[</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">, </span><span class="s4">'mgc_dict'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[])</span>


<span class="s3">def </span><span class="s1">multiscale_graphcorr(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">compute_distance=_euclidean_dist</span><span class="s3">, </span><span class="s1">reps=</span><span class="s5">1000</span><span class="s3">,</span>
                         <span class="s1">workers=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">is_twosamp=</span><span class="s3">False, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Computes the Multiscale Graph Correlation (MGC) test statistic. 
 
    Specifically, for each point, MGC finds the :math:`k`-nearest neighbors for 
    one property (e.g. cloud density), and the :math:`l`-nearest neighbors for 
    the other property (e.g. grass wetness) [1]_. This pair :math:`(k, l)` is 
    called the &quot;scale&quot;. A priori, however, it is not know which scales will be 
    most informative. So, MGC computes all distance pairs, and then efficiently 
    computes the distance correlations for all scales. The local correlations 
    illustrate which scales are relatively informative about the relationship. 
    The key, therefore, to successfully discover and decipher relationships 
    between disparate data modalities is to adaptively determine which scales 
    are the most informative, and the geometric implication for the most 
    informative scales. Doing so not only provides an estimate of whether the 
    modalities are related, but also provides insight into how the 
    determination was made. This is especially important in high-dimensional 
    data, where simple visualizations do not reveal relationships to the 
    unaided human eye. Characterizations of this implementation in particular 
    have been derived from and benchmarked within in [2]_. 
 
    Parameters 
    ---------- 
    x, y : ndarray 
        If ``x`` and ``y`` have shapes ``(n, p)`` and ``(n, q)`` where `n` is 
        the number of samples and `p` and `q` are the number of dimensions, 
        then the MGC independence test will be run.  Alternatively, ``x`` and 
        ``y`` can have shapes ``(n, n)`` if they are distance or similarity 
        matrices, and ``compute_distance`` must be sent to ``None``. If ``x`` 
        and ``y`` have shapes ``(n, p)`` and ``(m, p)``, an unpaired 
        two-sample MGC test will be run. 
    compute_distance : callable, optional 
        A function that computes the distance or similarity among the samples 
        within each data matrix. Set to ``None`` if ``x`` and ``y`` are 
        already distance matrices. The default uses the euclidean norm metric. 
        If you are calling a custom function, either create the distance 
        matrix before-hand or create a function of the form 
        ``compute_distance(x)`` where `x` is the data matrix for which 
        pairwise distances are calculated. 
    reps : int, optional 
        The number of replications used to estimate the null when using the 
        permutation test. The default is ``1000``. 
    workers : int or map-like callable, optional 
        If ``workers`` is an int the population is subdivided into ``workers`` 
        sections and evaluated in parallel (uses ``multiprocessing.Pool 
        &lt;multiprocessing&gt;``). Supply ``-1`` to use all cores available to the 
        Process. Alternatively supply a map-like callable, such as 
        ``multiprocessing.Pool.map`` for evaluating the p-value in parallel. 
        This evaluation is carried out as ``workers(func, iterable)``. 
        Requires that `func` be pickleable. The default is ``1``. 
    is_twosamp : bool, optional 
        If `True`, a two sample test will be run. If ``x`` and ``y`` have 
        shapes ``(n, p)`` and ``(m, p)``, this optional will be overridden and 
        set to ``True``. Set to ``True`` if ``x`` and ``y`` both have shapes 
        ``(n, p)`` and a two sample test is desired. The default is ``False``. 
        Note that this will not run if inputs are distance matrices. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    Returns 
    ------- 
    res : MGCResult 
        An object containing attributes: 
 
        statistic : float 
            The sample MGC test statistic within `[-1, 1]`. 
        pvalue : float 
            The p-value obtained via permutation. 
        mgc_dict : dict 
            Contains additional useful results: 
 
                - mgc_map : ndarray 
                    A 2D representation of the latent geometry of the 
                    relationship. 
                - opt_scale : (int, int) 
                    The estimated optimal scale as a `(x, y)` pair. 
                - null_dist : list 
                    The null distribution derived from the permuted matrices. 
 
    See Also 
    -------- 
    pearsonr : Pearson correlation coefficient and p-value for testing 
               non-correlation. 
    kendalltau : Calculates Kendall's tau. 
    spearmanr : Calculates a Spearman rank-order correlation coefficient. 
 
    Notes 
    ----- 
    A description of the process of MGC and applications on neuroscience data 
    can be found in [1]_. It is performed using the following steps: 
 
    #. Two distance matrices :math:`D^X` and :math:`D^Y` are computed and 
       modified to be mean zero columnwise. This results in two 
       :math:`n \times n` distance matrices :math:`A` and :math:`B` (the 
       centering and unbiased modification) [3]_. 
 
    #. For all values :math:`k` and :math:`l` from :math:`1, ..., n`, 
 
       * The :math:`k`-nearest neighbor and :math:`l`-nearest neighbor graphs 
         are calculated for each property. Here, :math:`G_k (i, j)` indicates 
         the :math:`k`-smallest values of the :math:`i`-th row of :math:`A` 
         and :math:`H_l (i, j)` indicates the :math:`l` smallested values of 
         the :math:`i`-th row of :math:`B` 
 
       * Let :math:`\circ` denotes the entry-wise matrix product, then local 
         correlations are summed and normalized using the following statistic: 
 
    .. math:: 
 
        c^{kl} = \frac{\sum_{ij} A G_k B H_l} 
                      {\sqrt{\sum_{ij} A^2 G_k \times \sum_{ij} B^2 H_l}} 
 
    #. The MGC test statistic is the smoothed optimal local correlation of 
       :math:`\{ c^{kl} \}`. Denote the smoothing operation as :math:`R(\cdot)` 
       (which essentially set all isolated large correlations) as 0 and 
       connected large correlations the same as before, see [3]_.) MGC is, 
 
    .. math:: 
 
        MGC_n (x, y) = \max_{(k, l)} R \left(c^{kl} \left( x_n, y_n \right) 
                                                    \right) 
 
    The test statistic returns a value between :math:`(-1, 1)` since it is 
    normalized. 
 
    The p-value returned is calculated using a permutation test. This process 
    is completed by first randomly permuting :math:`y` to estimate the null 
    distribution and then calculating the probability of observing a test 
    statistic, under the null, at least as extreme as the observed test 
    statistic. 
 
    MGC requires at least 5 samples to run with reliable results. It can also 
    handle high-dimensional data sets. 
    In addition, by manipulating the input data matrices, the two-sample 
    testing problem can be reduced to the independence testing problem [4]_. 
    Given sample data :math:`U` and :math:`V` of sizes :math:`p \times n` 
    :math:`p \times m`, data matrix :math:`X` and :math:`Y` can be created as 
    follows: 
 
    .. math:: 
 
        X = [U | V] \in \mathcal{R}^{p \times (n + m)} 
        Y = [0_{1 \times n} | 1_{1 \times m}] \in \mathcal{R}^{(n + m)} 
 
    Then, the MGC statistic can be calculated as normal. This methodology can 
    be extended to similar tests such as distance correlation [4]_. 
 
    .. versionadded:: 1.4.0 
 
    References 
    ---------- 
    .. [1] Vogelstein, J. T., Bridgeford, E. W., Wang, Q., Priebe, C. E., 
           Maggioni, M., &amp; Shen, C. (2019). Discovering and deciphering 
           relationships across disparate data modalities. ELife. 
    .. [2] Panda, S., Palaniappan, S., Xiong, J., Swaminathan, A., 
           Ramachandran, S., Bridgeford, E. W., ... Vogelstein, J. T. (2019). 
           mgcpy: A Comprehensive High Dimensional Independence Testing Python 
           Package. :arXiv:`1907.02088` 
    .. [3] Shen, C., Priebe, C.E., &amp; Vogelstein, J. T. (2019). From distance 
           correlation to multiscale graph correlation. Journal of the American 
           Statistical Association. 
    .. [4] Shen, C. &amp; Vogelstein, J. T. (2018). The Exact Equivalence of 
           Distance and Kernel Methods for Hypothesis Testing. 
           :arXiv:`1806.05514` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import multiscale_graphcorr 
    &gt;&gt;&gt; x = np.arange(100) 
    &gt;&gt;&gt; y = x 
    &gt;&gt;&gt; res = multiscale_graphcorr(x, y) 
    &gt;&gt;&gt; res.statistic, res.pvalue 
    (1.0, 0.001) 
 
    To run an unpaired two-sample test, 
 
    &gt;&gt;&gt; x = np.arange(100) 
    &gt;&gt;&gt; y = np.arange(79) 
    &gt;&gt;&gt; res = multiscale_graphcorr(x, y) 
    &gt;&gt;&gt; res.statistic, res.pvalue  # doctest: +SKIP 
    (0.033258146255703246, 0.023) 
 
    or, if shape of the inputs are the same, 
 
    &gt;&gt;&gt; x = np.arange(100) 
    &gt;&gt;&gt; y = x 
    &gt;&gt;&gt; res = multiscale_graphcorr(x, y, is_twosamp=True) 
    &gt;&gt;&gt; res.statistic, res.pvalue  # doctest: +SKIP 
    (-0.008021809890200488, 1.0) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">np.ndarray) </span><span class="s3">or not </span><span class="s1">isinstance(y</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;x and y must be ndarrays&quot;</span><span class="s1">)</span>

    <span class="s0"># convert arrays of type (n,) to (n, 1)</span>
    <span class="s3">if </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">x = x[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
    <span class="s3">elif </span><span class="s1">x.ndim != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Expected a 2-D array `x`, found shape &quot;</span>
                         <span class="s4">&quot;{}&quot;</span><span class="s1">.format(x.shape))</span>
    <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">y = y[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
    <span class="s3">elif </span><span class="s1">y.ndim != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Expected a 2-D array `y`, found shape &quot;</span>
                         <span class="s4">&quot;{}&quot;</span><span class="s1">.format(y.shape))</span>

    <span class="s1">nx</span><span class="s3">, </span><span class="s1">px = x.shape</span>
    <span class="s1">ny</span><span class="s3">, </span><span class="s1">py = y.shape</span>

    <span class="s0"># check for NaNs</span>
    <span class="s1">_contains_nan(x</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'raise'</span><span class="s1">)</span>
    <span class="s1">_contains_nan(y</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'raise'</span><span class="s1">)</span>

    <span class="s0"># check for positive or negative infinity and raise error</span>
    <span class="s3">if </span><span class="s1">np.sum(np.isinf(x)) &gt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">np.sum(np.isinf(y)) &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Inputs contain infinities&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">nx != ny:</span>
        <span class="s3">if </span><span class="s1">px == py:</span>
            <span class="s0"># reshape x and y for two sample testing</span>
            <span class="s1">is_twosamp = </span><span class="s3">True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Shape mismatch, x and y must have shape [n, p] &quot;</span>
                             <span class="s4">&quot;and [n, q] or have shape [n, p] and [m, p].&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">nx &lt; </span><span class="s5">5 </span><span class="s3">or </span><span class="s1">ny &lt; </span><span class="s5">5</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;MGC requires at least 5 samples to give reasonable &quot;</span>
                         <span class="s4">&quot;results.&quot;</span><span class="s1">)</span>

    <span class="s0"># convert x and y to float</span>
    <span class="s1">x = x.astype(np.float64)</span>
    <span class="s1">y = y.astype(np.float64)</span>

    <span class="s0"># check if compute_distance_matrix if a callable()</span>
    <span class="s3">if not </span><span class="s1">callable(compute_distance) </span><span class="s3">and </span><span class="s1">compute_distance </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Compute_distance must be a function.&quot;</span><span class="s1">)</span>

    <span class="s0"># check if number of reps exists, integer, or &gt; 0 (if under 1000 raises</span>
    <span class="s0"># warning)</span>
    <span class="s3">if not </span><span class="s1">isinstance(reps</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">or </span><span class="s1">reps &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Number of reps must be an integer greater than 0.&quot;</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">reps &lt; </span><span class="s5">1000</span><span class="s1">:</span>
        <span class="s1">msg = (</span><span class="s4">&quot;The number of replications is low (under 1000), and p-value &quot;</span>
               <span class="s4">&quot;calculations may be unreliable. Use the p-value result, with &quot;</span>
               <span class="s4">&quot;caution!&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>

    <span class="s3">if </span><span class="s1">is_twosamp:</span>
        <span class="s3">if </span><span class="s1">compute_distance </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Cannot run if inputs are distance matrices&quot;</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y = _two_sample_transform(x</span><span class="s3">, </span><span class="s1">y)</span>

    <span class="s3">if </span><span class="s1">compute_distance </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s0"># compute distance matrices for x and y</span>
        <span class="s1">x = compute_distance(x)</span>
        <span class="s1">y = compute_distance(y)</span>

    <span class="s0"># calculate MGC stat</span>
    <span class="s1">stat</span><span class="s3">, </span><span class="s1">stat_dict = _mgc_stat(x</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s1">stat_mgc_map = stat_dict[</span><span class="s4">&quot;stat_mgc_map&quot;</span><span class="s1">]</span>
    <span class="s1">opt_scale = stat_dict[</span><span class="s4">&quot;opt_scale&quot;</span><span class="s1">]</span>

    <span class="s0"># calculate permutation MGC p-value</span>
    <span class="s1">pvalue</span><span class="s3">, </span><span class="s1">null_dist = _perm_test(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">stat</span><span class="s3">, </span><span class="s1">reps=reps</span><span class="s3">, </span><span class="s1">workers=workers</span><span class="s3">,</span>
                                   <span class="s1">random_state=random_state)</span>

    <span class="s0"># save all stats (other than stat/p-value) in dictionary</span>
    <span class="s1">mgc_dict = {</span><span class="s4">&quot;mgc_map&quot;</span><span class="s1">: stat_mgc_map</span><span class="s3">,</span>
                <span class="s4">&quot;opt_scale&quot;</span><span class="s1">: opt_scale</span><span class="s3">,</span>
                <span class="s4">&quot;null_dist&quot;</span><span class="s1">: null_dist}</span>

    <span class="s0"># create result object with alias for backward compatibility</span>
    <span class="s1">res = MGCResult(stat</span><span class="s3">, </span><span class="s1">pvalue</span><span class="s3">, </span><span class="s1">mgc_dict)</span>
    <span class="s1">res.stat = stat</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_mgc_stat(distx</span><span class="s3">, </span><span class="s1">disty):</span>
    <span class="s2">r&quot;&quot;&quot;Helper function that calculates the MGC stat. See above for use. 
 
    Parameters 
    ---------- 
    distx, disty : ndarray 
        `distx` and `disty` have shapes `(n, p)` and `(n, q)` or 
        `(n, n)` and `(n, n)` 
        if distance matrices. 
 
    Returns 
    ------- 
    stat : float 
        The sample MGC test statistic within `[-1, 1]`. 
    stat_dict : dict 
        Contains additional useful additional returns containing the following 
        keys: 
 
            - stat_mgc_map : ndarray 
                MGC-map of the statistics. 
            - opt_scale : (float, float) 
                The estimated optimal scale as a `(x, y)` pair. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># calculate MGC map and optimal scale</span>
    <span class="s1">stat_mgc_map = _local_correlations(distx</span><span class="s3">, </span><span class="s1">disty</span><span class="s3">, </span><span class="s1">global_corr=</span><span class="s4">'mgc'</span><span class="s1">)</span>

    <span class="s1">n</span><span class="s3">, </span><span class="s1">m = stat_mgc_map.shape</span>
    <span class="s3">if </span><span class="s1">m == </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># the global scale at is the statistic calculated at maximial nearest</span>
        <span class="s0"># neighbors. There is not enough local scale to search over, so</span>
        <span class="s0"># default to global scale</span>
        <span class="s1">stat = stat_mgc_map[m - </span><span class="s5">1</span><span class="s1">][n - </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">opt_scale = m * n</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">samp_size = len(distx) - </span><span class="s5">1</span>

        <span class="s0"># threshold to find connected region of significant local correlations</span>
        <span class="s1">sig_connect = _threshold_mgc_map(stat_mgc_map</span><span class="s3">, </span><span class="s1">samp_size)</span>

        <span class="s0"># maximum within the significant region</span>
        <span class="s1">stat</span><span class="s3">, </span><span class="s1">opt_scale = _smooth_mgc_map(sig_connect</span><span class="s3">, </span><span class="s1">stat_mgc_map)</span>

    <span class="s1">stat_dict = {</span><span class="s4">&quot;stat_mgc_map&quot;</span><span class="s1">: stat_mgc_map</span><span class="s3">,</span>
                 <span class="s4">&quot;opt_scale&quot;</span><span class="s1">: opt_scale}</span>

    <span class="s3">return </span><span class="s1">stat</span><span class="s3">, </span><span class="s1">stat_dict</span>


<span class="s3">def </span><span class="s1">_threshold_mgc_map(stat_mgc_map</span><span class="s3">, </span><span class="s1">samp_size):</span>
    <span class="s2">r&quot;&quot;&quot; 
    Finds a connected region of significance in the MGC-map by thresholding. 
 
    Parameters 
    ---------- 
    stat_mgc_map : ndarray 
        All local correlations within `[-1,1]`. 
    samp_size : int 
        The sample size of original data. 
 
    Returns 
    ------- 
    sig_connect : ndarray 
        A binary matrix with 1's indicating the significant region. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = stat_mgc_map.shape</span>

    <span class="s0"># 0.02 is simply an empirical threshold, this can be set to 0.01 or 0.05</span>
    <span class="s0"># with varying levels of performance. Threshold is based on a beta</span>
    <span class="s0"># approximation.</span>
    <span class="s1">per_sig = </span><span class="s5">1 </span><span class="s1">- (</span><span class="s5">0.02 </span><span class="s1">/ samp_size)  </span><span class="s0"># Percentile to consider as significant</span>
    <span class="s1">threshold = samp_size * (samp_size - </span><span class="s5">3</span><span class="s1">)/</span><span class="s5">4 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">/</span><span class="s5">2  </span><span class="s0"># Beta approximation</span>
    <span class="s1">threshold = distributions.beta.ppf(per_sig</span><span class="s3">, </span><span class="s1">threshold</span><span class="s3">, </span><span class="s1">threshold) * </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1</span>

    <span class="s0"># the global scale at is the statistic calculated at maximial nearest</span>
    <span class="s0"># neighbors. Threshold is the maximum on the global and local scales</span>
    <span class="s1">threshold = max(threshold</span><span class="s3">, </span><span class="s1">stat_mgc_map[m - </span><span class="s5">1</span><span class="s1">][n - </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s0"># find the largest connected component of significant correlations</span>
    <span class="s1">sig_connect = stat_mgc_map &gt; threshold</span>
    <span class="s3">if </span><span class="s1">np.sum(sig_connect) &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">sig_connect</span><span class="s3">, </span><span class="s1">_ = _measurements.label(sig_connect)</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">label_counts = np.unique(sig_connect</span><span class="s3">, </span><span class="s1">return_counts=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s0"># skip the first element in label_counts, as it is count(zeros)</span>
        <span class="s1">max_label = np.argmax(label_counts[</span><span class="s5">1</span><span class="s1">:]) + </span><span class="s5">1</span>
        <span class="s1">sig_connect = sig_connect == max_label</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">sig_connect = np.array([[</span><span class="s3">False</span><span class="s1">]])</span>

    <span class="s3">return </span><span class="s1">sig_connect</span>


<span class="s3">def </span><span class="s1">_smooth_mgc_map(sig_connect</span><span class="s3">, </span><span class="s1">stat_mgc_map):</span>
    <span class="s2">&quot;&quot;&quot;Finds the smoothed maximal within the significant region R. 
 
    If area of R is too small it returns the last local correlation. Otherwise, 
    returns the maximum within significant_connected_region. 
 
    Parameters 
    ---------- 
    sig_connect : ndarray 
        A binary matrix with 1's indicating the significant region. 
    stat_mgc_map : ndarray 
        All local correlations within `[-1, 1]`. 
 
    Returns 
    ------- 
    stat : float 
        The sample MGC statistic within `[-1, 1]`. 
    opt_scale: (float, float) 
        The estimated optimal scale as an `(x, y)` pair. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = stat_mgc_map.shape</span>

    <span class="s0"># the global scale at is the statistic calculated at maximial nearest</span>
    <span class="s0"># neighbors. By default, statistic and optimal scale are global.</span>
    <span class="s1">stat = stat_mgc_map[m - </span><span class="s5">1</span><span class="s1">][n - </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">opt_scale = [m</span><span class="s3">, </span><span class="s1">n]</span>

    <span class="s3">if </span><span class="s1">np.linalg.norm(sig_connect) != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0"># proceed only when the connected region's area is sufficiently large</span>
        <span class="s0"># 0.02 is simply an empirical threshold, this can be set to 0.01 or 0.05</span>
        <span class="s0"># with varying levels of performance</span>
        <span class="s3">if </span><span class="s1">np.sum(sig_connect) &gt;= np.ceil(</span><span class="s5">0.02 </span><span class="s1">* max(m</span><span class="s3">, </span><span class="s1">n)) * min(m</span><span class="s3">, </span><span class="s1">n):</span>
            <span class="s1">max_corr = max(stat_mgc_map[sig_connect])</span>

            <span class="s0"># find all scales within significant_connected_region that maximize</span>
            <span class="s0"># the local correlation</span>
            <span class="s1">max_corr_index = np.where((stat_mgc_map &gt;= max_corr) &amp; sig_connect)</span>

            <span class="s3">if </span><span class="s1">max_corr &gt;= stat:</span>
                <span class="s1">stat = max_corr</span>

                <span class="s1">k</span><span class="s3">, </span><span class="s1">l = max_corr_index</span>
                <span class="s1">one_d_indices = k * n + l  </span><span class="s0"># 2D to 1D indexing</span>
                <span class="s1">k = np.max(one_d_indices) // n</span>
                <span class="s1">l = np.max(one_d_indices) % n</span>
                <span class="s1">opt_scale = [k+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">l+</span><span class="s5">1</span><span class="s1">]  </span><span class="s0"># adding 1s to match R indexing</span>

    <span class="s3">return </span><span class="s1">stat</span><span class="s3">, </span><span class="s1">opt_scale</span>


<span class="s3">def </span><span class="s1">_two_sample_transform(u</span><span class="s3">, </span><span class="s1">v):</span>
    <span class="s2">&quot;&quot;&quot;Helper function that concatenates x and y for two sample MGC stat. 
 
    See above for use. 
 
    Parameters 
    ---------- 
    u, v : ndarray 
        `u` and `v` have shapes `(n, p)` and `(m, p)`. 
 
    Returns 
    ------- 
    x : ndarray 
        Concatenate `u` and `v` along the `axis = 0`. `x` thus has shape 
        `(2n, p)`. 
    y : ndarray 
        Label matrix for `x` where 0 refers to samples that comes from `u` and 
        1 refers to samples that come from `v`. `y` thus has shape `(2n, 1)`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nx = u.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">ny = v.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">x = np.concatenate([u</span><span class="s3">, </span><span class="s1">v]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">y = np.concatenate([np.zeros(nx)</span><span class="s3">, </span><span class="s1">np.ones(ny)]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">).reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span>


<span class="s0">#####################################</span>
<span class="s0">#       INFERENTIAL STATISTICS      #</span>
<span class="s0">#####################################</span>

<span class="s1">TtestResultBase = _make_tuple_bunch(</span><span class="s4">'TtestResultBase'</span><span class="s3">,</span>
                                    <span class="s1">[</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'df'</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">TtestResult(TtestResultBase):</span>
    <span class="s2">&quot;&quot;&quot; 
    Result of a t-test. 
 
    See the documentation of the particular t-test function for more 
    information about the definition of the statistic and meaning of 
    the confidence interval. 
 
    Attributes 
    ---------- 
    statistic : float or array 
        The t-statistic of the sample. 
    pvalue : float or array 
        The p-value associated with the given alternative. 
    df : float or array 
        The number of degrees of freedom used in calculation of the 
        t-statistic; this is one less than the size of the sample 
        (``a.shape[axis]-1`` if there are no masked elements or omitted NaNs). 
 
    Methods 
    ------- 
    confidence_interval 
        Computes a confidence interval around the population statistic 
        for the given confidence level. 
        The confidence interval is returned in a ``namedtuple`` with 
        fields `low` and `high`. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">statistic</span><span class="s3">, </span><span class="s1">pvalue</span><span class="s3">, </span><span class="s1">df</span><span class="s3">,  </span><span class="s0"># public</span>
                 <span class="s1">alternative</span><span class="s3">, </span><span class="s1">standard_error</span><span class="s3">, </span><span class="s1">estimate):  </span><span class="s0"># private</span>
        <span class="s1">super().__init__(statistic</span><span class="s3">, </span><span class="s1">pvalue</span><span class="s3">, </span><span class="s1">df=df)</span>
        <span class="s1">self._alternative = alternative</span>
        <span class="s1">self._standard_error = standard_error  </span><span class="s0"># denominator of t-statistic</span>
        <span class="s1">self._estimate = estimate  </span><span class="s0"># point estimate of sample mean</span>

    <span class="s3">def </span><span class="s1">confidence_interval(self</span><span class="s3">, </span><span class="s1">confidence_level=</span><span class="s5">0.95</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        confidence_level : float 
            The confidence level for the calculation of the population mean 
            confidence interval. Default is 0.95. 
 
        Returns 
        ------- 
        ci : namedtuple 
            The confidence interval is returned in a ``namedtuple`` with 
            fields `low` and `high`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">low</span><span class="s3">, </span><span class="s1">high = _t_confidence_interval(self.df</span><span class="s3">, </span><span class="s1">self.statistic</span><span class="s3">,</span>
                                           <span class="s1">confidence_level</span><span class="s3">, </span><span class="s1">self._alternative)</span>
        <span class="s1">low = low * self._standard_error + self._estimate</span>
        <span class="s1">high = high * self._standard_error + self._estimate</span>
        <span class="s3">return </span><span class="s1">ConfidenceInterval(low=low</span><span class="s3">, </span><span class="s1">high=high)</span>


<span class="s3">def </span><span class="s1">pack_TtestResult(statistic</span><span class="s3">, </span><span class="s1">pvalue</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">, </span><span class="s1">standard_error</span><span class="s3">,</span>
                     <span class="s1">estimate):</span>
    <span class="s0"># this could be any number of dimensions (including 0d), but there is</span>
    <span class="s0"># at most one unique non-NaN value</span>
    <span class="s1">alternative = np.atleast_1d(alternative)  </span><span class="s0"># can't index 0D object</span>
    <span class="s1">alternative = alternative[np.isfinite(alternative)]</span>
    <span class="s1">alternative = alternative[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">alternative.size </span><span class="s3">else </span><span class="s1">np.nan</span>
    <span class="s3">return </span><span class="s1">TtestResult(statistic</span><span class="s3">, </span><span class="s1">pvalue</span><span class="s3">, </span><span class="s1">df=df</span><span class="s3">, </span><span class="s1">alternative=alternative</span><span class="s3">,</span>
                       <span class="s1">standard_error=standard_error</span><span class="s3">, </span><span class="s1">estimate=estimate)</span>


<span class="s3">def </span><span class="s1">unpack_TtestResult(res):</span>
    <span class="s3">return </span><span class="s1">(res.statistic</span><span class="s3">, </span><span class="s1">res.pvalue</span><span class="s3">, </span><span class="s1">res.df</span><span class="s3">, </span><span class="s1">res._alternative</span><span class="s3">,</span>
            <span class="s1">res._standard_error</span><span class="s3">, </span><span class="s1">res._estimate)</span>


<span class="s1">@_axis_nan_policy_factory(pack_TtestResult</span><span class="s3">, </span><span class="s1">default_axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s5">2</span><span class="s3">,</span>
                          <span class="s1">result_to_tuple=unpack_TtestResult</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">6</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">ttest_1samp(a</span><span class="s3">, </span><span class="s1">popmean</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">,</span>
                <span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Calculate the T-test for the mean of ONE group of scores. 
 
    This is a test for the null hypothesis that the expected value 
    (mean) of a sample of independent observations `a` is equal to the given 
    population mean, `popmean`. 
 
    Parameters 
    ---------- 
    a : array_like 
        Sample observation. 
    popmean : float or array_like 
        Expected value in null hypothesis. If array_like, then its length along 
        `axis` must equal 1, and it must otherwise be broadcastable with `a`. 
    axis : int or None, optional 
        Axis along which to compute test; default is 0. If None, compute over 
        the whole array `a`. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the mean of the underlying distribution of the sample 
          is different than the given population mean (`popmean`) 
        * 'less': the mean of the underlying distribution of the sample is 
          less than the given population mean (`popmean`) 
        * 'greater': the mean of the underlying distribution of the sample is 
          greater than the given population mean (`popmean`) 
 
    Returns 
    ------- 
    result : `~scipy.stats._result_classes.TtestResult` 
        An object with the following attributes: 
 
        statistic : float or array 
            The t-statistic. 
        pvalue : float or array 
            The p-value associated with the given alternative. 
        df : float or array 
            The number of degrees of freedom used in calculation of the 
            t-statistic; this is one less than the size of the sample 
            (``a.shape[axis]``). 
 
            .. versionadded:: 1.10.0 
 
        The object also has the following method: 
 
        confidence_interval(confidence_level=0.95) 
            Computes a confidence interval around the population 
            mean for the given confidence level. 
            The confidence interval is returned in a ``namedtuple`` with 
            fields `low` and `high`. 
 
            .. versionadded:: 1.10.0 
 
    Notes 
    ----- 
    The statistic is calculated as ``(np.mean(a) - popmean)/se``, where 
    ``se`` is the standard error. Therefore, the statistic will be positive 
    when the sample mean is greater than the population mean and negative when 
    the sample mean is less than the population mean. 
 
    Examples 
    -------- 
    Suppose we wish to test the null hypothesis that the mean of a population 
    is equal to 0.5. We choose a confidence level of 99%; that is, we will 
    reject the null hypothesis in favor of the alternative if the p-value is 
    less than 0.01. 
 
    When testing random variates from the standard uniform distribution, which 
    has a mean of 0.5, we expect the data to be consistent with the null 
    hypothesis most of the time. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; rvs = stats.uniform.rvs(size=50, random_state=rng) 
    &gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5) 
    TtestResult(statistic=2.456308468440, pvalue=0.017628209047638, df=49) 
 
    As expected, the p-value of 0.017 is not below our threshold of 0.01, so 
    we cannot reject the null hypothesis. 
 
    When testing data from the standard *normal* distribution, which has a mean 
    of 0, we would expect the null hypothesis to be rejected. 
 
    &gt;&gt;&gt; rvs = stats.norm.rvs(size=50, random_state=rng) 
    &gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5) 
    TtestResult(statistic=-7.433605518875, pvalue=1.416760157221e-09, df=49) 
 
    Indeed, the p-value is lower than our threshold of 0.01, so we reject the 
    null hypothesis in favor of the default &quot;two-sided&quot; alternative: the mean 
    of the population is *not* equal to 0.5. 
 
    However, suppose we were to test the null hypothesis against the 
    one-sided alternative that the mean of the population is *greater* than 
    0.5. Since the mean of the standard normal is less than 0.5, we would not 
    expect the null hypothesis to be rejected. 
 
    &gt;&gt;&gt; stats.ttest_1samp(rvs, popmean=0.5, alternative='greater') 
    TtestResult(statistic=-7.433605518875, pvalue=0.99999999929, df=49) 
 
    Unsurprisingly, with a p-value greater than our threshold, we would not 
    reject the null hypothesis. 
 
    Note that when working with a confidence level of 99%, a true null 
    hypothesis will be rejected approximately 1% of the time. 
 
    &gt;&gt;&gt; rvs = stats.uniform.rvs(size=(100, 50), random_state=rng) 
    &gt;&gt;&gt; res = stats.ttest_1samp(rvs, popmean=0.5, axis=1) 
    &gt;&gt;&gt; np.sum(res.pvalue &lt; 0.01) 
    1 
 
    Indeed, even though all 100 samples above were drawn from the standard 
    uniform distribution, which *does* have a population mean of 0.5, we would 
    mistakenly reject the null hypothesis for one of them. 
 
    `ttest_1samp` can also compute a confidence interval around the population 
    mean. 
 
    &gt;&gt;&gt; rvs = stats.norm.rvs(size=50, random_state=rng) 
    &gt;&gt;&gt; res = stats.ttest_1samp(rvs, popmean=0) 
    &gt;&gt;&gt; ci = res.confidence_interval(confidence_level=0.95) 
    &gt;&gt;&gt; ci 
    ConfidenceInterval(low=-0.3193887540880017, high=0.2898583388980972) 
 
    The bounds of the 95% confidence interval are the 
    minimum and maximum values of the parameter `popmean` for which the 
    p-value of the test would be 0.05. 
 
    &gt;&gt;&gt; res = stats.ttest_1samp(rvs, popmean=ci.low) 
    &gt;&gt;&gt; np.testing.assert_allclose(res.pvalue, 0.05) 
    &gt;&gt;&gt; res = stats.ttest_1samp(rvs, popmean=ci.high) 
    &gt;&gt;&gt; np.testing.assert_allclose(res.pvalue, 0.05) 
 
    Under certain assumptions about the population from which a sample 
    is drawn, the confidence interval with confidence level 95% is expected 
    to contain the true population mean in 95% of sample replications. 
 
    &gt;&gt;&gt; rvs = stats.norm.rvs(size=(50, 1000), loc=1, random_state=rng) 
    &gt;&gt;&gt; res = stats.ttest_1samp(rvs, popmean=0) 
    &gt;&gt;&gt; ci = res.confidence_interval() 
    &gt;&gt;&gt; contains_pop_mean = (ci.low &lt; 1) &amp; (ci.high &gt; 1) 
    &gt;&gt;&gt; contains_pop_mean.sum() 
    953 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">n = a.shape[axis]</span>
    <span class="s1">df = n - </span><span class="s5">1</span>

    <span class="s1">mean = np.mean(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">popmean = np.squeeze(popmean</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`popmean.shape[axis]` must equal 1.&quot;</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
    <span class="s1">d = mean - popmean</span>
    <span class="s1">v = _var(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">denom = np.sqrt(v / n)</span>

    <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">t = np.divide(d</span><span class="s3">, </span><span class="s1">denom)</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">prob = _ttest_finish(df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative)</span>

    <span class="s0"># when nan_policy='omit', `df` can be different for different axis-slices</span>
    <span class="s1">df = np.broadcast_to(df</span><span class="s3">, </span><span class="s1">t.shape)[()]</span>
    <span class="s0"># _axis_nan_policy decorator doesn't play well with strings</span>
    <span class="s1">alternative_num = {</span><span class="s4">&quot;less&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s3">, </span><span class="s4">&quot;greater&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}[alternative]</span>
    <span class="s3">return </span><span class="s1">TtestResult(t</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">df=df</span><span class="s3">, </span><span class="s1">alternative=alternative_num</span><span class="s3">,</span>
                       <span class="s1">standard_error=denom</span><span class="s3">, </span><span class="s1">estimate=mean)</span>


<span class="s3">def </span><span class="s1">_t_confidence_interval(df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">confidence_level</span><span class="s3">, </span><span class="s1">alternative):</span>
    <span class="s0"># Input validation on `alternative` is already done</span>
    <span class="s0"># We just need IV on confidence_level</span>
    <span class="s3">if </span><span class="s1">confidence_level &lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">confidence_level &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">message = </span><span class="s4">&quot;`confidence_level` must be a number between 0 and 1.&quot;</span>
        <span class="s3">raise </span><span class="s1">ValueError(message)</span>

    <span class="s3">if </span><span class="s1">alternative &lt; </span><span class="s5">0</span><span class="s1">:  </span><span class="s0"># 'less'</span>
        <span class="s1">p = confidence_level</span>
        <span class="s1">low</span><span class="s3">, </span><span class="s1">high = np.broadcast_arrays(-np.inf</span><span class="s3">, </span><span class="s1">special.stdtrit(df</span><span class="s3">, </span><span class="s1">p))</span>
    <span class="s3">elif </span><span class="s1">alternative &gt; </span><span class="s5">0</span><span class="s1">:  </span><span class="s0"># 'greater'</span>
        <span class="s1">p = </span><span class="s5">1 </span><span class="s1">- confidence_level</span>
        <span class="s1">low</span><span class="s3">, </span><span class="s1">high = np.broadcast_arrays(special.stdtrit(df</span><span class="s3">, </span><span class="s1">p)</span><span class="s3">, </span><span class="s1">np.inf)</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s5">0</span><span class="s1">:  </span><span class="s0"># 'two-sided'</span>
        <span class="s1">tail_probability = (</span><span class="s5">1 </span><span class="s1">- confidence_level)/</span><span class="s5">2</span>
        <span class="s1">p = tail_probability</span><span class="s3">, </span><span class="s5">1</span><span class="s1">-tail_probability</span>
        <span class="s0"># axis of p must be the zeroth and orthogonal to all the rest</span>
        <span class="s1">p = np.reshape(p</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">] + [</span><span class="s5">1</span><span class="s1">]*np.asarray(df).ndim)</span>
        <span class="s1">low</span><span class="s3">, </span><span class="s1">high = special.stdtrit(df</span><span class="s3">, </span><span class="s1">p)</span>
    <span class="s3">else</span><span class="s1">:  </span><span class="s0"># alternative is NaN when input is empty (see _axis_nan_policy)</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">nans = np.broadcast_arrays(t</span><span class="s3">, </span><span class="s1">np.nan)</span>
        <span class="s1">low</span><span class="s3">, </span><span class="s1">high = nans</span><span class="s3">, </span><span class="s1">nans</span>

    <span class="s3">return </span><span class="s1">low[()]</span><span class="s3">, </span><span class="s1">high[()]</span>


<span class="s3">def </span><span class="s1">_ttest_finish(df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative):</span>
    <span class="s2">&quot;&quot;&quot;Common code between all 3 t-test functions.&quot;&quot;&quot;</span>
    <span class="s0"># We use ``stdtr`` directly here as it handles the case when ``nan``</span>
    <span class="s0"># values are present in the data and masked arrays are passed</span>
    <span class="s0"># while ``t.cdf`` emits runtime warnings. This way ``_ttest_finish``</span>
    <span class="s0"># can be shared between the ``stats`` and ``mstats`` versions.</span>

    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'less'</span><span class="s1">:</span>
        <span class="s1">pval = special.stdtr(df</span><span class="s3">, </span><span class="s1">t)</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">'greater'</span><span class="s1">:</span>
        <span class="s1">pval = special.stdtr(df</span><span class="s3">, </span><span class="s1">-t)</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">'two-sided'</span><span class="s1">:</span>
        <span class="s1">pval = special.stdtr(df</span><span class="s3">, </span><span class="s1">-np.abs(t))*</span><span class="s5">2</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;alternative must be &quot;</span>
                         <span class="s4">&quot;'less', 'greater' or 'two-sided'&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">t.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">t = t[()]</span>
    <span class="s3">if </span><span class="s1">pval.ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">pval = pval[()]</span>

    <span class="s3">return </span><span class="s1">t</span><span class="s3">, </span><span class="s1">pval</span>


<span class="s3">def </span><span class="s1">_ttest_ind_from_stats(mean1</span><span class="s3">, </span><span class="s1">mean2</span><span class="s3">, </span><span class="s1">denom</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">alternative):</span>

    <span class="s1">d = mean1 - mean2</span>
    <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">t = np.divide(d</span><span class="s3">, </span><span class="s1">denom)</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">prob = _ttest_finish(df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative)</span>

    <span class="s3">return </span><span class="s1">(t</span><span class="s3">, </span><span class="s1">prob)</span>


<span class="s3">def </span><span class="s1">_unequal_var_ttest_denom(v1</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">n2):</span>
    <span class="s1">vn1 = v1 / n1</span>
    <span class="s1">vn2 = v2 / n2</span>
    <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">df = (vn1 + vn2)**</span><span class="s5">2 </span><span class="s1">/ (vn1**</span><span class="s5">2 </span><span class="s1">/ (n1 - </span><span class="s5">1</span><span class="s1">) + vn2**</span><span class="s5">2 </span><span class="s1">/ (n2 - </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s0"># If df is undefined, variances are zero (assumes n1 &gt; 0 &amp; n2 &gt; 0).</span>
    <span class="s0"># Hence it doesn't matter what df is as long as it's not NaN.</span>
    <span class="s1">df = np.where(np.isnan(df)</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">df)</span>
    <span class="s1">denom = np.sqrt(vn1 + vn2)</span>
    <span class="s3">return </span><span class="s1">df</span><span class="s3">, </span><span class="s1">denom</span>


<span class="s3">def </span><span class="s1">_equal_var_ttest_denom(v1</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">n2):</span>
    <span class="s0"># If there is a single observation in one sample, this formula for pooled</span>
    <span class="s0"># variance breaks down because the variance of that sample is undefined.</span>
    <span class="s0"># The pooled variance is still defined, though, because the (n-1) in the</span>
    <span class="s0"># numerator should cancel with the (n-1) in the denominator, leaving only</span>
    <span class="s0"># the sum of squared differences from the mean: zero.</span>
    <span class="s1">v1 = np.where(n1 == </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">v1)[()]</span>
    <span class="s1">v2 = np.where(n2 == </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">v2)[()]</span>

    <span class="s1">df = n1 + n2 - </span><span class="s5">2.0</span>
    <span class="s1">svar = ((n1 - </span><span class="s5">1</span><span class="s1">) * v1 + (n2 - </span><span class="s5">1</span><span class="s1">) * v2) / df</span>
    <span class="s1">denom = np.sqrt(svar * (</span><span class="s5">1.0 </span><span class="s1">/ n1 + </span><span class="s5">1.0 </span><span class="s1">/ n2))</span>
    <span class="s3">return </span><span class="s1">df</span><span class="s3">, </span><span class="s1">denom</span>


<span class="s1">Ttest_indResult = namedtuple(</span><span class="s4">'Ttest_indResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">ttest_ind_from_stats(mean1</span><span class="s3">, </span><span class="s1">std1</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">mean2</span><span class="s3">, </span><span class="s1">std2</span><span class="s3">, </span><span class="s1">nobs2</span><span class="s3">,</span>
                         <span class="s1">equal_var=</span><span class="s3">True, </span><span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot; 
    T-test for means of two independent samples from descriptive statistics. 
 
    This is a test for the null hypothesis that two independent 
    samples have identical average (expected) values. 
 
    Parameters 
    ---------- 
    mean1 : array_like 
        The mean(s) of sample 1. 
    std1 : array_like 
        The corrected sample standard deviation of sample 1 (i.e. ``ddof=1``). 
    nobs1 : array_like 
        The number(s) of observations of sample 1. 
    mean2 : array_like 
        The mean(s) of sample 2. 
    std2 : array_like 
        The corrected sample standard deviation of sample 2 (i.e. ``ddof=1``). 
    nobs2 : array_like 
        The number(s) of observations of sample 2. 
    equal_var : bool, optional 
        If True (default), perform a standard independent 2 sample test 
        that assumes equal population variances [1]_. 
        If False, perform Welch's t-test, which does not assume equal 
        population variance [2]_. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the means of the distributions are unequal. 
        * 'less': the mean of the first distribution is less than the 
          mean of the second distribution. 
        * 'greater': the mean of the first distribution is greater than the 
          mean of the second distribution. 
 
        .. versionadded:: 1.6.0 
 
    Returns 
    ------- 
    statistic : float or array 
        The calculated t-statistics. 
    pvalue : float or array 
        The two-tailed p-value. 
 
    See Also 
    -------- 
    scipy.stats.ttest_ind 
 
    Notes 
    ----- 
    The statistic is calculated as ``(mean1 - mean2)/se``, where ``se`` is the 
    standard error. Therefore, the statistic will be positive when `mean1` is 
    greater than `mean2` and negative when `mean1` is less than `mean2`. 
 
    This method does not check whether any of the elements of `std1` or `std2` 
    are negative. If any elements of the `std1` or `std2` parameters are 
    negative in a call to this method, this method will return the same result 
    as if it were passed ``numpy.abs(std1)`` and ``numpy.abs(std2)``, 
    respectively, instead; no exceptions or warnings will be emitted. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test 
 
    .. [2] https://en.wikipedia.org/wiki/Welch%27s_t-test 
 
    Examples 
    -------- 
    Suppose we have the summary data for two samples, as follows (with the 
    Sample Variance being the corrected sample variance):: 
 
                         Sample   Sample 
                   Size   Mean   Variance 
        Sample 1    13    15.0     87.5 
        Sample 2    11    12.0     39.0 
 
    Apply the t-test to this data (with the assumption that the population 
    variances are equal): 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import ttest_ind_from_stats 
    &gt;&gt;&gt; ttest_ind_from_stats(mean1=15.0, std1=np.sqrt(87.5), nobs1=13, 
    ...                      mean2=12.0, std2=np.sqrt(39.0), nobs2=11) 
    Ttest_indResult(statistic=0.9051358093310269, pvalue=0.3751996797581487) 
 
    For comparison, here is the data from which those summary statistics 
    were taken.  With this data, we can compute the same result using 
    `scipy.stats.ttest_ind`: 
 
    &gt;&gt;&gt; a = np.array([1, 3, 4, 6, 11, 13, 15, 19, 22, 24, 25, 26, 26]) 
    &gt;&gt;&gt; b = np.array([2, 4, 6, 9, 11, 13, 14, 15, 18, 19, 21]) 
    &gt;&gt;&gt; from scipy.stats import ttest_ind 
    &gt;&gt;&gt; ttest_ind(a, b) 
    Ttest_indResult(statistic=0.905135809331027, pvalue=0.3751996797581486) 
 
    Suppose we instead have binary data and would like to apply a t-test to 
    compare the proportion of 1s in two independent groups:: 
 
                          Number of    Sample     Sample 
                    Size    ones        Mean     Variance 
        Sample 1    150      30         0.2        0.161073 
        Sample 2    200      45         0.225      0.175251 
 
    The sample mean :math:`\hat{p}` is the proportion of ones in the sample 
    and the variance for a binary observation is estimated by 
    :math:`\hat{p}(1-\hat{p})`. 
 
    &gt;&gt;&gt; ttest_ind_from_stats(mean1=0.2, std1=np.sqrt(0.161073), nobs1=150, 
    ...                      mean2=0.225, std2=np.sqrt(0.175251), nobs2=200) 
    Ttest_indResult(statistic=-0.5627187905196761, pvalue=0.5739887114209541) 
 
    For comparison, we could compute the t statistic and p-value using 
    arrays of 0s and 1s and `scipy.stat.ttest_ind`, as above. 
 
    &gt;&gt;&gt; group1 = np.array([1]*30 + [0]*(150-30)) 
    &gt;&gt;&gt; group2 = np.array([1]*45 + [0]*(200-45)) 
    &gt;&gt;&gt; ttest_ind(group1, group2) 
    Ttest_indResult(statistic=-0.5627179589855622, pvalue=0.573989277115258) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mean1 = np.asarray(mean1)</span>
    <span class="s1">std1 = np.asarray(std1)</span>
    <span class="s1">mean2 = np.asarray(mean2)</span>
    <span class="s1">std2 = np.asarray(std2)</span>
    <span class="s3">if </span><span class="s1">equal_var:</span>
        <span class="s1">df</span><span class="s3">, </span><span class="s1">denom = _equal_var_ttest_denom(std1**</span><span class="s5">2</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">, </span><span class="s1">std2**</span><span class="s5">2</span><span class="s3">, </span><span class="s1">nobs2)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">df</span><span class="s3">, </span><span class="s1">denom = _unequal_var_ttest_denom(std1**</span><span class="s5">2</span><span class="s3">, </span><span class="s1">nobs1</span><span class="s3">,</span>
                                             <span class="s1">std2**</span><span class="s5">2</span><span class="s3">, </span><span class="s1">nobs2)</span>

    <span class="s1">res = _ttest_ind_from_stats(mean1</span><span class="s3">, </span><span class="s1">mean2</span><span class="s3">, </span><span class="s1">denom</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">alternative)</span>
    <span class="s3">return </span><span class="s1">Ttest_indResult(*res)</span>


<span class="s1">@_axis_nan_policy_factory(pack_TtestResult</span><span class="s3">, </span><span class="s1">default_axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s5">2</span><span class="s3">,</span>
                          <span class="s1">result_to_tuple=unpack_TtestResult</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">6</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">ttest_ind(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">equal_var=</span><span class="s3">True, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">,</span>
              <span class="s1">permutations=</span><span class="s3">None, </span><span class="s1">random_state=</span><span class="s3">None, </span><span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s3">,</span>
              <span class="s1">trim=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Calculate the T-test for the means of *two independent* samples of scores. 
 
    This is a test for the null hypothesis that 2 independent samples 
    have identical average (expected) values. This test assumes that the 
    populations have identical variances by default. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        The arrays must have the same shape, except in the dimension 
        corresponding to `axis` (the first, by default). 
    axis : int or None, optional 
        Axis along which to compute test. If None, compute over the whole 
        arrays, `a`, and `b`. 
    equal_var : bool, optional 
        If True (default), perform a standard independent 2 sample test 
        that assumes equal population variances [1]_. 
        If False, perform Welch's t-test, which does not assume equal 
        population variance [2]_. 
 
        .. versionadded:: 0.11.0 
 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
        The 'omit' option is not currently available for permutation tests or 
        one-sided asympyotic tests. 
 
    permutations : non-negative int, np.inf, or None (default), optional 
        If 0 or None (default), use the t-distribution to calculate p-values. 
        Otherwise, `permutations` is  the number of random permutations that 
        will be used to estimate p-values using a permutation test. If 
        `permutations` equals or exceeds the number of distinct partitions of 
        the pooled data, an exact test is performed instead (i.e. each 
        distinct partition is used exactly once). See Notes for details. 
 
        .. versionadded:: 1.7.0 
 
    random_state : {None, int, `numpy.random.Generator`, 
            `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
        Pseudorandom number generator state used to generate permutations 
        (used only when `permutations` is not None). 
 
        .. versionadded:: 1.7.0 
 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the means of the distributions underlying the samples 
          are unequal. 
        * 'less': the mean of the distribution underlying the first sample 
          is less than the mean of the distribution underlying the second 
          sample. 
        * 'greater': the mean of the distribution underlying the first 
          sample is greater than the mean of the distribution underlying 
          the second sample. 
 
        .. versionadded:: 1.6.0 
 
    trim : float, optional 
        If nonzero, performs a trimmed (Yuen's) t-test. 
        Defines the fraction of elements to be trimmed from each end of the 
        input samples. If 0 (default), no elements will be trimmed from either 
        side. The number of trimmed elements from each tail is the floor of the 
        trim times the number of elements. Valid range is [0, .5). 
 
        .. versionadded:: 1.7 
 
    Returns 
    ------- 
    result : `~scipy.stats._result_classes.TtestResult` 
        An object with the following attributes: 
 
        statistic : float or ndarray 
            The t-statistic. 
        pvalue : float or ndarray 
            The p-value associated with the given alternative. 
        df : float or ndarray 
            The number of degrees of freedom used in calculation of the 
            t-statistic. This is always NaN for a permutation t-test. 
 
            .. versionadded:: 1.11.0 
 
        The object also has the following method: 
 
        confidence_interval(confidence_level=0.95) 
            Computes a confidence interval around the difference in 
            population means for the given confidence level. 
            The confidence interval is returned in a ``namedtuple`` with 
            fields ``low`` and ``high``. 
            When a permutation t-test is performed, the confidence interval 
            is not computed, and fields ``low`` and ``high`` contain NaN. 
 
            .. versionadded:: 1.11.0 
 
    Notes 
    ----- 
    Suppose we observe two independent samples, e.g. flower petal lengths, and 
    we are considering whether the two samples were drawn from the same 
    population (e.g. the same species of flower or two species with similar 
    petal characteristics) or two different populations. 
 
    The t-test quantifies the difference between the arithmetic means 
    of the two samples. The p-value quantifies the probability of observing 
    as or more extreme values assuming the null hypothesis, that the 
    samples are drawn from populations with the same population means, is true. 
    A p-value larger than a chosen threshold (e.g. 5% or 1%) indicates that 
    our observation is not so unlikely to have occurred by chance. Therefore, 
    we do not reject the null hypothesis of equal population means. 
    If the p-value is smaller than our threshold, then we have evidence 
    against the null hypothesis of equal population means. 
 
    By default, the p-value is determined by comparing the t-statistic of the 
    observed data against a theoretical t-distribution. 
    When ``1 &lt; permutations &lt; binom(n, k)``, where 
 
    * ``k`` is the number of observations in `a`, 
    * ``n`` is the total number of observations in `a` and `b`, and 
    * ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``), 
 
    the data are pooled (concatenated), randomly assigned to either group `a` 
    or `b`, and the t-statistic is calculated. This process is performed 
    repeatedly (`permutation` times), generating a distribution of the 
    t-statistic under the null hypothesis, and the t-statistic of the observed 
    data is compared to this distribution to determine the p-value. 
    Specifically, the p-value reported is the &quot;achieved significance level&quot; 
    (ASL) as defined in 4.4 of [3]_. Note that there are other ways of 
    estimating p-values using randomized permutation tests; for other 
    options, see the more general `permutation_test`. 
 
    When ``permutations &gt;= binom(n, k)``, an exact test is performed: the data 
    are partitioned between the groups in each distinct way exactly once. 
 
    The permutation test can be computationally expensive and not necessarily 
    more accurate than the analytical test, but it does not make strong 
    assumptions about the shape of the underlying distribution. 
 
    Use of trimming is commonly referred to as the trimmed t-test. At times 
    called Yuen's t-test, this is an extension of Welch's t-test, with the 
    difference being the use of winsorized means in calculation of the variance 
    and the trimmed sample size in calculation of the statistic. Trimming is 
    recommended if the underlying distribution is long-tailed or contaminated 
    with outliers [4]_. 
 
    The statistic is calculated as ``(np.mean(a) - np.mean(b))/se``, where 
    ``se`` is the standard error. Therefore, the statistic will be positive 
    when the sample mean of `a` is greater than the sample mean of `b` and 
    negative when the sample mean of `a` is less than the sample mean of 
    `b`. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test 
 
    .. [2] https://en.wikipedia.org/wiki/Welch%27s_t-test 
 
    .. [3] B. Efron and T. Hastie. Computer Age Statistical Inference. (2016). 
 
    .. [4] Yuen, Karen K. &quot;The Two-Sample Trimmed t for Unequal Population 
           Variances.&quot; Biometrika, vol. 61, no. 1, 1974, pp. 165-170. JSTOR, 
           www.jstor.org/stable/2334299. Accessed 30 Mar. 2021. 
 
    .. [5] Yuen, Karen K., and W. J. Dixon. &quot;The Approximate Behaviour and 
           Performance of the Two-Sample Trimmed t.&quot; Biometrika, vol. 60, 
           no. 2, 1973, pp. 369-374. JSTOR, www.jstor.org/stable/2334550. 
           Accessed 30 Mar. 2021. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Test with sample with identical means: 
 
    &gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng) 
    &gt;&gt;&gt; rvs2 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng) 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs2) 
    Ttest_indResult(statistic=-0.4390847099199348, pvalue=0.6606952038870015) 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs2, equal_var=False) 
    Ttest_indResult(statistic=-0.4390847099199348, pvalue=0.6606952553131064) 
 
    `ttest_ind` underestimates p for unequal variances: 
 
    &gt;&gt;&gt; rvs3 = stats.norm.rvs(loc=5, scale=20, size=500, random_state=rng) 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3) 
    Ttest_indResult(statistic=-1.6370984482905417, pvalue=0.1019251574705033) 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs3, equal_var=False) 
    Ttest_indResult(statistic=-1.637098448290542, pvalue=0.10202110497954867) 
 
    When ``n1 != n2``, the equal variance t-statistic is no longer equal to the 
    unequal variance t-statistic: 
 
    &gt;&gt;&gt; rvs4 = stats.norm.rvs(loc=5, scale=20, size=100, random_state=rng) 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4) 
    Ttest_indResult(statistic=-1.9481646859513422, pvalue=0.05186270935842703) 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs4, equal_var=False) 
    Ttest_indResult(statistic=-1.3146566100751664, pvalue=0.1913495266513811) 
 
    T-test with different means, variance, and n: 
 
    &gt;&gt;&gt; rvs5 = stats.norm.rvs(loc=8, scale=20, size=100, random_state=rng) 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5) 
    Ttest_indResult(statistic=-2.8415950600298774, pvalue=0.0046418707568707885) 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5, equal_var=False) 
    Ttest_indResult(statistic=-1.8686598649188084, pvalue=0.06434714193919686) 
 
    When performing a permutation test, more permutations typically yields 
    more accurate results. Use a ``np.random.Generator`` to ensure 
    reproducibility: 
 
    &gt;&gt;&gt; stats.ttest_ind(rvs1, rvs5, permutations=10000, 
    ...                 random_state=rng) 
    Ttest_indResult(statistic=-2.8415950600298774, pvalue=0.0052994700529947) 
 
    Take these two samples, one of which has an extreme tail. 
 
    &gt;&gt;&gt; a = (56, 128.6, 12, 123.8, 64.34, 78, 763.3) 
    &gt;&gt;&gt; b = (1.1, 2.9, 4.2) 
 
    Use the `trim` keyword to perform a trimmed (Yuen) t-test. For example, 
    using 20% trimming, ``trim=.2``, the test will reduce the impact of one 
    (``np.floor(trim*len(a))``) element from each tail of sample `a`. It will 
    have no effect on sample `b` because ``np.floor(trim*len(b))`` is 0. 
 
    &gt;&gt;&gt; stats.ttest_ind(a, b, trim=.2) 
    Ttest_indResult(statistic=3.4463884028073513, 
                    pvalue=0.01369338726499547) 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= trim &lt; </span><span class="s5">.5</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Trimming percentage should be 0 &lt;= `trim` &lt; .5.&quot;</span><span class="s1">)</span>

    <span class="s1">NaN = _get_nan(a</span><span class="s3">, </span><span class="s1">b)</span>

    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">b.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0"># _axis_nan_policy decorator ensures this only happens with 1d input</span>
        <span class="s3">return </span><span class="s1">TtestResult(NaN</span><span class="s3">, </span><span class="s1">NaN</span><span class="s3">, </span><span class="s1">df=NaN</span><span class="s3">, </span><span class="s1">alternative=NaN</span><span class="s3">,</span>
                           <span class="s1">standard_error=NaN</span><span class="s3">, </span><span class="s1">estimate=NaN)</span>

    <span class="s3">if </span><span class="s1">permutations </span><span class="s3">is not None and </span><span class="s1">permutations != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">trim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Permutations are currently not supported &quot;</span>
                             <span class="s4">&quot;with trimming.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">permutations &lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">(np.isfinite(permutations) </span><span class="s3">and</span>
                                <span class="s1">int(permutations) != permutations):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Permutations must be a non-negative integer.&quot;</span><span class="s1">)</span>

        <span class="s1">t</span><span class="s3">, </span><span class="s1">prob = _permutation_ttest(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">permutations=permutations</span><span class="s3">,</span>
                                     <span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">equal_var=equal_var</span><span class="s3">,</span>
                                     <span class="s1">nan_policy=nan_policy</span><span class="s3">,</span>
                                     <span class="s1">random_state=random_state</span><span class="s3">,</span>
                                     <span class="s1">alternative=alternative)</span>
        <span class="s1">df</span><span class="s3">, </span><span class="s1">denom</span><span class="s3">, </span><span class="s1">estimate = NaN</span><span class="s3">, </span><span class="s1">NaN</span><span class="s3">, </span><span class="s1">NaN</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n1 = a.shape[axis]</span>
        <span class="s1">n2 = b.shape[axis]</span>

        <span class="s3">if </span><span class="s1">trim == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">equal_var:</span>
                <span class="s1">old_errstate = np.geterr()</span>
                <span class="s1">np.seterr(divide=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">)</span>
            <span class="s1">v1 = _var(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">v2 = _var(b</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">equal_var:</span>
                <span class="s1">np.seterr(**old_errstate)</span>
            <span class="s1">m1 = np.mean(a</span><span class="s3">, </span><span class="s1">axis)</span>
            <span class="s1">m2 = np.mean(b</span><span class="s3">, </span><span class="s1">axis)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">v1</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">n1 = _ttest_trim_var_mean_len(a</span><span class="s3">, </span><span class="s1">trim</span><span class="s3">, </span><span class="s1">axis)</span>
            <span class="s1">v2</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">, </span><span class="s1">n2 = _ttest_trim_var_mean_len(b</span><span class="s3">, </span><span class="s1">trim</span><span class="s3">, </span><span class="s1">axis)</span>

        <span class="s3">if </span><span class="s1">equal_var:</span>
            <span class="s1">df</span><span class="s3">, </span><span class="s1">denom = _equal_var_ttest_denom(v1</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">n2)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">df</span><span class="s3">, </span><span class="s1">denom = _unequal_var_ttest_denom(v1</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">, </span><span class="s1">n2)</span>
        <span class="s1">t</span><span class="s3">, </span><span class="s1">prob = _ttest_ind_from_stats(m1</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">, </span><span class="s1">denom</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">alternative)</span>

        <span class="s0"># when nan_policy='omit', `df` can be different for different axis-slices</span>
        <span class="s1">df = np.broadcast_to(df</span><span class="s3">, </span><span class="s1">t.shape)[()]</span>
        <span class="s1">estimate = m1-m2</span>

    <span class="s0"># _axis_nan_policy decorator doesn't play well with strings</span>
    <span class="s1">alternative_num = {</span><span class="s4">&quot;less&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s3">, </span><span class="s4">&quot;greater&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}[alternative]</span>
    <span class="s3">return </span><span class="s1">TtestResult(t</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">df=df</span><span class="s3">, </span><span class="s1">alternative=alternative_num</span><span class="s3">,</span>
                       <span class="s1">standard_error=denom</span><span class="s3">, </span><span class="s1">estimate=estimate)</span>


<span class="s3">def </span><span class="s1">_ttest_trim_var_mean_len(a</span><span class="s3">, </span><span class="s1">trim</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s2">&quot;&quot;&quot;Variance, mean, and length of winsorized input along specified axis&quot;&quot;&quot;</span>
    <span class="s0"># for use with `ttest_ind` when trimming.</span>
    <span class="s0"># further calculations in this test assume that the inputs are sorted.</span>
    <span class="s0"># From [4] Section 1 &quot;Let x_1, ..., x_n be n ordered observations...&quot;</span>
    <span class="s1">a = np.sort(a</span><span class="s3">, </span><span class="s1">axis=axis)</span>

    <span class="s0"># `g` is the number of elements to be replaced on each tail, converted</span>
    <span class="s0"># from a percentage amount of trimming</span>
    <span class="s1">n = a.shape[axis]</span>
    <span class="s1">g = int(n * trim)</span>

    <span class="s0"># Calculate the Winsorized variance of the input samples according to</span>
    <span class="s0"># specified `g`</span>
    <span class="s1">v = _calculate_winsorized_variance(a</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s0"># the total number of elements in the trimmed samples</span>
    <span class="s1">n -= </span><span class="s5">2 </span><span class="s1">* g</span>

    <span class="s0"># calculate the g-times trimmed mean, as defined in [4] (1-1)</span>
    <span class="s1">m = trim_mean(a</span><span class="s3">, </span><span class="s1">trim</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s3">return </span><span class="s1">v</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span>


<span class="s3">def </span><span class="s1">_calculate_winsorized_variance(a</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s2">&quot;&quot;&quot;Calculates g-times winsorized variance along specified axis&quot;&quot;&quot;</span>
    <span class="s0"># it is expected that the input `a` is sorted along the correct axis</span>
    <span class="s3">if </span><span class="s1">g == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_var(a</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s0"># move the intended axis to the end that way it is easier to manipulate</span>
    <span class="s1">a_win = np.moveaxis(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0"># save where NaNs are for later use.</span>
    <span class="s1">nans_indices = np.any(np.isnan(a_win)</span><span class="s3">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0"># Winsorization and variance calculation are done in one step in [4]</span>
    <span class="s0"># (1-3), but here winsorization is done first; replace the left and</span>
    <span class="s0"># right sides with the repeating value. This can be see in effect in (</span>
    <span class="s0"># 1-3) in [4], where the leftmost and rightmost tails are replaced with</span>
    <span class="s0"># `(g + 1) * x_{g + 1}` on the left and `(g + 1) * x_{n - g}` on the</span>
    <span class="s0"># right. Zero-indexing turns `g + 1` to `g`, and `n - g` to `- g - 1` in</span>
    <span class="s0"># array indexing.</span>
    <span class="s1">a_win[...</span><span class="s3">, </span><span class="s1">:g] = a_win[...</span><span class="s3">, </span><span class="s1">[g]]</span>
    <span class="s1">a_win[...</span><span class="s3">, </span><span class="s1">-g:] = a_win[...</span><span class="s3">, </span><span class="s1">[-g - </span><span class="s5">1</span><span class="s1">]]</span>

    <span class="s0"># Determine the variance. In [4], the degrees of freedom is expressed as</span>
    <span class="s0"># `h - 1`, where `h = n - 2g` (unnumbered equations in Section 1, end of</span>
    <span class="s0"># page 369, beginning of page 370). This is converted to NumPy's format,</span>
    <span class="s0"># `n - ddof` for use with `np.var`. The result is converted to an</span>
    <span class="s0"># array to accommodate indexing later.</span>
    <span class="s1">var_win = np.asarray(_var(a_win</span><span class="s3">, </span><span class="s1">ddof=(</span><span class="s5">2 </span><span class="s1">* g + </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s0"># with `nan_policy='propagate'`, NaNs may be completely trimmed out</span>
    <span class="s0"># because they were sorted into the tail of the array. In these cases,</span>
    <span class="s0"># replace computed variances with `np.nan`.</span>
    <span class="s1">var_win[nans_indices] = np.nan</span>
    <span class="s3">return </span><span class="s1">var_win</span>


<span class="s3">def </span><span class="s1">_permutation_distribution_t(data</span><span class="s3">, </span><span class="s1">permutations</span><span class="s3">, </span><span class="s1">size_a</span><span class="s3">, </span><span class="s1">equal_var</span><span class="s3">,</span>
                                <span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Generation permutation distribution of t statistic&quot;&quot;&quot;</span>

    <span class="s1">random_state = check_random_state(random_state)</span>

    <span class="s0"># prepare permutation indices</span>
    <span class="s1">size = data.shape[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s0"># number of distinct combinations</span>
    <span class="s1">n_max = special.comb(size</span><span class="s3">, </span><span class="s1">size_a)</span>

    <span class="s3">if </span><span class="s1">permutations &lt; n_max:</span>
        <span class="s1">perm_generator = (random_state.permutation(size)</span>
                          <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(permutations))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">permutations = n_max</span>
        <span class="s1">perm_generator = (np.concatenate(z)</span>
                          <span class="s3">for </span><span class="s1">z </span><span class="s3">in </span><span class="s1">_all_partitions(size_a</span><span class="s3">, </span><span class="s1">size-size_a))</span>

    <span class="s1">t_stat = []</span>
    <span class="s3">for </span><span class="s1">indices </span><span class="s3">in </span><span class="s1">_batch_generator(perm_generator</span><span class="s3">, </span><span class="s1">batch=</span><span class="s5">50</span><span class="s1">):</span>
        <span class="s0"># get one batch from perm_generator at a time as a list</span>
        <span class="s1">indices = np.array(indices)</span>
        <span class="s0"># generate permutations</span>
        <span class="s1">data_perm = data[...</span><span class="s3">, </span><span class="s1">indices]</span>
        <span class="s0"># move axis indexing permutations to position 0 to broadcast</span>
        <span class="s0"># nicely with t_stat_observed, which doesn't have this dimension</span>
        <span class="s1">data_perm = np.moveaxis(data_perm</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">a = data_perm[...</span><span class="s3">, </span><span class="s1">:size_a]</span>
        <span class="s1">b = data_perm[...</span><span class="s3">, </span><span class="s1">size_a:]</span>
        <span class="s1">t_stat.append(_calc_t_stat(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">equal_var))</span>

    <span class="s1">t_stat = np.concatenate(t_stat</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">t_stat</span><span class="s3">, </span><span class="s1">permutations</span><span class="s3">, </span><span class="s1">n_max</span>


<span class="s3">def </span><span class="s1">_calc_t_stat(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">equal_var</span><span class="s3">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Calculate the t statistic along the given dimension.&quot;&quot;&quot;</span>
    <span class="s1">na = a.shape[axis]</span>
    <span class="s1">nb = b.shape[axis]</span>
    <span class="s1">avg_a = np.mean(a</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">avg_b = np.mean(b</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">var_a = _var(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">var_b = _var(b</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">if not </span><span class="s1">equal_var:</span>
        <span class="s1">denom = _unequal_var_ttest_denom(var_a</span><span class="s3">, </span><span class="s1">na</span><span class="s3">, </span><span class="s1">var_b</span><span class="s3">, </span><span class="s1">nb)[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">denom = _equal_var_ttest_denom(var_a</span><span class="s3">, </span><span class="s1">na</span><span class="s3">, </span><span class="s1">var_b</span><span class="s3">, </span><span class="s1">nb)[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">return </span><span class="s1">(avg_a-avg_b)/denom</span>


<span class="s3">def </span><span class="s1">_permutation_ttest(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">permutations</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">equal_var=</span><span class="s3">True,</span>
                       <span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">, </span><span class="s1">random_state=</span><span class="s3">None,</span>
                       <span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Calculates the T-test for the means of TWO INDEPENDENT samples of scores 
    using permutation methods. 
 
    This test is similar to `stats.ttest_ind`, except it doesn't rely on an 
    approximate normality assumption since it uses a permutation test. 
    This function is only called from ttest_ind when permutations is not None. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        The arrays must be broadcastable, except along the dimension 
        corresponding to `axis` (the zeroth, by default). 
    axis : int, optional 
        The axis over which to operate on a and b. 
    permutations : int, optional 
        Number of permutations used to calculate p-value. If greater than or 
        equal to the number of distinct permutations, perform an exact test. 
    equal_var : bool, optional 
        If False, an equal variance (Welch's) t-test is conducted.  Otherwise, 
        an ordinary t-test is conducted. 
    random_state : {None, int, `numpy.random.Generator`}, optional 
        If `seed` is None the `numpy.random.Generator` singleton is used. 
        If `seed` is an int, a new ``Generator`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` instance then that instance is 
        used. 
        Pseudorandom number generator state used for generating random 
        permutations. 
 
    Returns 
    ------- 
    statistic : float or array 
        The calculated t-statistic. 
    pvalue : float or array 
        The p-value. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">random_state = check_random_state(random_state)</span>

    <span class="s1">t_stat_observed = _calc_t_stat(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">equal_var</span><span class="s3">, </span><span class="s1">axis=axis)</span>

    <span class="s1">na = a.shape[axis]</span>
    <span class="s1">mat = _broadcast_concatenate((a</span><span class="s3">, </span><span class="s1">b)</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">mat = np.moveaxis(mat</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">t_stat</span><span class="s3">, </span><span class="s1">permutations</span><span class="s3">, </span><span class="s1">n_max = _permutation_distribution_t(</span>
        <span class="s1">mat</span><span class="s3">, </span><span class="s1">permutations</span><span class="s3">, </span><span class="s1">size_a=na</span><span class="s3">, </span><span class="s1">equal_var=equal_var</span><span class="s3">,</span>
        <span class="s1">random_state=random_state)</span>

    <span class="s1">compare = {</span><span class="s4">&quot;less&quot;</span><span class="s1">: np.less_equal</span><span class="s3">,</span>
               <span class="s4">&quot;greater&quot;</span><span class="s1">: np.greater_equal</span><span class="s3">,</span>
               <span class="s4">&quot;two-sided&quot;</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y: (x &lt;= -np.abs(y)) | (x &gt;= np.abs(y))}</span>

    <span class="s0"># Calculate the p-values</span>
    <span class="s1">cmps = compare[alternative](t_stat</span><span class="s3">, </span><span class="s1">t_stat_observed)</span>
    <span class="s0"># Randomized test p-value calculation should use biased estimate; see e.g.</span>
    <span class="s0"># https://www.degruyter.com/document/doi/10.2202/1544-6115.1585/</span>
    <span class="s1">adjustment = </span><span class="s5">1 </span><span class="s3">if </span><span class="s1">n_max &gt; permutations </span><span class="s3">else </span><span class="s5">0</span>
    <span class="s1">pvalues = (cmps.sum(axis=</span><span class="s5">0</span><span class="s1">) + adjustment) / (permutations + adjustment)</span>

    <span class="s0"># nans propagate naturally in statistic calculation, but need to be</span>
    <span class="s0"># propagated manually into pvalues</span>
    <span class="s3">if </span><span class="s1">nan_policy == </span><span class="s4">'propagate' </span><span class="s3">and </span><span class="s1">np.isnan(t_stat_observed).any():</span>
        <span class="s3">if </span><span class="s1">np.ndim(pvalues) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">pvalues = np.float64(np.nan)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pvalues[np.isnan(t_stat_observed)] = np.nan</span>

    <span class="s3">return </span><span class="s1">(t_stat_observed</span><span class="s3">, </span><span class="s1">pvalues)</span>


<span class="s3">def </span><span class="s1">_get_len(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">msg):</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">n = a.shape[axis]</span>
    <span class="s3">except </span><span class="s1">IndexError:</span>
        <span class="s3">raise </span><span class="s1">np.AxisError(axis</span><span class="s3">, </span><span class="s1">a.ndim</span><span class="s3">, </span><span class="s1">msg) </span><span class="s3">from None</span>
    <span class="s3">return </span><span class="s1">n</span>


<span class="s1">@_axis_nan_policy_factory(pack_TtestResult</span><span class="s3">, </span><span class="s1">default_axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s5">2</span><span class="s3">,</span>
                          <span class="s1">result_to_tuple=unpack_TtestResult</span><span class="s3">, </span><span class="s1">n_outputs=</span><span class="s5">6</span><span class="s3">,</span>
                          <span class="s1">paired=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">ttest_rel(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Calculate the t-test on TWO RELATED samples of scores, a and b. 
 
    This is a test for the null hypothesis that two related or 
    repeated samples have identical average (expected) values. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        The arrays must have the same shape. 
    axis : int or None, optional 
        Axis along which to compute test. If None, compute over the whole 
        arrays, `a`, and `b`. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the means of the distributions underlying the samples 
          are unequal. 
        * 'less': the mean of the distribution underlying the first sample 
          is less than the mean of the distribution underlying the second 
          sample. 
        * 'greater': the mean of the distribution underlying the first 
          sample is greater than the mean of the distribution underlying 
          the second sample. 
 
        .. versionadded:: 1.6.0 
 
    Returns 
    ------- 
    result : `~scipy.stats._result_classes.TtestResult` 
        An object with the following attributes: 
 
        statistic : float or array 
            The t-statistic. 
        pvalue : float or array 
            The p-value associated with the given alternative. 
        df : float or array 
            The number of degrees of freedom used in calculation of the 
            t-statistic; this is one less than the size of the sample 
            (``a.shape[axis]``). 
 
            .. versionadded:: 1.10.0 
 
        The object also has the following method: 
 
        confidence_interval(confidence_level=0.95) 
            Computes a confidence interval around the difference in 
            population means for the given confidence level. 
            The confidence interval is returned in a ``namedtuple`` with 
            fields `low` and `high`. 
 
            .. versionadded:: 1.10.0 
 
    Notes 
    ----- 
    Examples for use are scores of the same set of student in 
    different exams, or repeated sampling from the same units. The 
    test measures whether the average score differs significantly 
    across samples (e.g. exams). If we observe a large p-value, for 
    example greater than 0.05 or 0.1 then we cannot reject the null 
    hypothesis of identical average scores. If the p-value is smaller 
    than the threshold, e.g. 1%, 5% or 10%, then we reject the null 
    hypothesis of equal averages. Small p-values are associated with 
    large t-statistics. 
 
    The t-statistic is calculated as ``np.mean(a - b)/se``, where ``se`` is the 
    standard error. Therefore, the t-statistic will be positive when the sample 
    mean of ``a - b`` is greater than zero and negative when the sample mean of 
    ``a - b`` is less than zero. 
 
    References 
    ---------- 
    https://en.wikipedia.org/wiki/T-test#Dependent_t-test_for_paired_samples 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    &gt;&gt;&gt; rvs1 = stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng) 
    &gt;&gt;&gt; rvs2 = (stats.norm.rvs(loc=5, scale=10, size=500, random_state=rng) 
    ...         + stats.norm.rvs(scale=0.2, size=500, random_state=rng)) 
    &gt;&gt;&gt; stats.ttest_rel(rvs1, rvs2) 
    TtestResult(statistic=-0.4549717054410304, pvalue=0.6493274702088672, df=499)  # noqa 
    &gt;&gt;&gt; rvs3 = (stats.norm.rvs(loc=8, scale=10, size=500, random_state=rng) 
    ...         + stats.norm.rvs(scale=0.2, size=500, random_state=rng)) 
    &gt;&gt;&gt; stats.ttest_rel(rvs1, rvs3) 
    TtestResult(statistic=-5.879467544540889, pvalue=7.540777129099917e-09, df=499)  # noqa 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis = _chk2_asarray(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">na = _get_len(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;first argument&quot;</span><span class="s1">)</span>
    <span class="s1">nb = _get_len(b</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;second argument&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">na != nb:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'unequal length arrays'</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">na == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">nb == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0"># _axis_nan_policy decorator ensures this only happens with 1d input</span>
        <span class="s1">NaN = _get_nan(a</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s3">return </span><span class="s1">TtestResult(NaN</span><span class="s3">, </span><span class="s1">NaN</span><span class="s3">, </span><span class="s1">df=NaN</span><span class="s3">, </span><span class="s1">alternative=NaN</span><span class="s3">,</span>
                           <span class="s1">standard_error=NaN</span><span class="s3">, </span><span class="s1">estimate=NaN)</span>

    <span class="s1">n = a.shape[axis]</span>
    <span class="s1">df = n - </span><span class="s5">1</span>

    <span class="s1">d = (a - b).astype(np.float64)</span>
    <span class="s1">v = _var(d</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">dm = np.mean(d</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">denom = np.sqrt(v / n)</span>

    <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">t = np.divide(dm</span><span class="s3">, </span><span class="s1">denom)</span>
    <span class="s1">t</span><span class="s3">, </span><span class="s1">prob = _ttest_finish(df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative)</span>

    <span class="s0"># when nan_policy='omit', `df` can be different for different axis-slices</span>
    <span class="s1">df = np.broadcast_to(df</span><span class="s3">, </span><span class="s1">t.shape)[()]</span>

    <span class="s0"># _axis_nan_policy decorator doesn't play well with strings</span>
    <span class="s1">alternative_num = {</span><span class="s4">&quot;less&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s3">, </span><span class="s4">&quot;greater&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}[alternative]</span>
    <span class="s3">return </span><span class="s1">TtestResult(t</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">df=df</span><span class="s3">, </span><span class="s1">alternative=alternative_num</span><span class="s3">,</span>
                       <span class="s1">standard_error=denom</span><span class="s3">, </span><span class="s1">estimate=dm)</span>


<span class="s0"># Map from names to lambda_ values used in power_divergence().</span>
<span class="s1">_power_div_lambda_names = {</span>
    <span class="s4">&quot;pearson&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s4">&quot;log-likelihood&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s4">&quot;freeman-tukey&quot;</span><span class="s1">: -</span><span class="s5">0.5</span><span class="s3">,</span>
    <span class="s4">&quot;mod-log-likelihood&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s3">,</span>
    <span class="s4">&quot;neyman&quot;</span><span class="s1">: -</span><span class="s5">2</span><span class="s3">,</span>
    <span class="s4">&quot;cressie-read&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s1">/</span><span class="s5">3</span><span class="s3">,</span>
<span class="s1">}</span>


<span class="s3">def </span><span class="s1">_count(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Count the number of non-masked elements of an array. 
 
    This function behaves like `np.ma.count`, but is much faster 
    for ndarrays. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">hasattr(a</span><span class="s3">, </span><span class="s4">'count'</span><span class="s1">):</span>
        <span class="s1">num = a.count(axis=axis)</span>
        <span class="s3">if </span><span class="s1">isinstance(num</span><span class="s3">, </span><span class="s1">np.ndarray) </span><span class="s3">and </span><span class="s1">num.ndim == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0"># In some cases, the `count` method returns a scalar array (e.g.</span>
            <span class="s0"># np.array(3)), but we want a plain integer.</span>
            <span class="s1">num = int(num)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">num = a.size</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">num = a.shape[axis]</span>
    <span class="s3">return </span><span class="s1">num</span>


<span class="s3">def </span><span class="s1">_m_broadcast_to(a</span><span class="s3">, </span><span class="s1">shape):</span>
    <span class="s3">if </span><span class="s1">np.ma.isMaskedArray(a):</span>
        <span class="s3">return </span><span class="s1">np.ma.masked_array(np.broadcast_to(a</span><span class="s3">, </span><span class="s1">shape)</span><span class="s3">,</span>
                                  <span class="s1">mask=np.broadcast_to(a.mask</span><span class="s3">, </span><span class="s1">shape))</span>
    <span class="s3">return </span><span class="s1">np.broadcast_to(a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">subok=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s1">Power_divergenceResult = namedtuple(</span><span class="s4">'Power_divergenceResult'</span><span class="s3">,</span>
                                    <span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">power_divergence(f_obs</span><span class="s3">, </span><span class="s1">f_exp=</span><span class="s3">None, </span><span class="s1">ddof=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">lambda_=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Cressie-Read power divergence statistic and goodness of fit test. 
 
    This function tests the null hypothesis that the categorical data 
    has the given frequencies, using the Cressie-Read power divergence 
    statistic. 
 
    Parameters 
    ---------- 
    f_obs : array_like 
        Observed frequencies in each category. 
    f_exp : array_like, optional 
        Expected frequencies in each category.  By default the categories are 
        assumed to be equally likely. 
    ddof : int, optional 
        &quot;Delta degrees of freedom&quot;: adjustment to the degrees of freedom 
        for the p-value.  The p-value is computed using a chi-squared 
        distribution with ``k - 1 - ddof`` degrees of freedom, where `k` 
        is the number of observed frequencies.  The default value of `ddof` 
        is 0. 
    axis : int or None, optional 
        The axis of the broadcast result of `f_obs` and `f_exp` along which to 
        apply the test.  If axis is None, all values in `f_obs` are treated 
        as a single data set.  Default is 0. 
    lambda_ : float or str, optional 
        The power in the Cressie-Read power divergence statistic.  The default 
        is 1.  For convenience, `lambda_` may be assigned one of the following 
        strings, in which case the corresponding numerical value is used: 
 
        * ``&quot;pearson&quot;`` (value 1) 
            Pearson's chi-squared statistic. In this case, the function is 
            equivalent to `chisquare`. 
        * ``&quot;log-likelihood&quot;`` (value 0) 
            Log-likelihood ratio. Also known as the G-test [3]_. 
        * ``&quot;freeman-tukey&quot;`` (value -1/2) 
            Freeman-Tukey statistic. 
        * ``&quot;mod-log-likelihood&quot;`` (value -1) 
            Modified log-likelihood ratio. 
        * ``&quot;neyman&quot;`` (value -2) 
            Neyman's statistic. 
        * ``&quot;cressie-read&quot;`` (value 2/3) 
            The power recommended in [5]_. 
 
    Returns 
    ------- 
    res: Power_divergenceResult 
        An object containing attributes: 
 
        statistic : float or ndarray 
            The Cressie-Read power divergence test statistic.  The value is 
            a float if `axis` is None or if` `f_obs` and `f_exp` are 1-D. 
        pvalue : float or ndarray 
            The p-value of the test.  The value is a float if `ddof` and the 
            return value `stat` are scalars. 
 
    See Also 
    -------- 
    chisquare 
 
    Notes 
    ----- 
    This test is invalid when the observed or expected frequencies in each 
    category are too small.  A typical rule is that all of the observed 
    and expected frequencies should be at least 5. 
 
    Also, the sum of the observed and expected frequencies must be the same 
    for the test to be valid; `power_divergence` raises an error if the sums 
    do not agree within a relative tolerance of ``1e-8``. 
 
    When `lambda_` is less than zero, the formula for the statistic involves 
    dividing by `f_obs`, so a warning or error may be generated if any value 
    in `f_obs` is 0. 
 
    Similarly, a warning or error may be generated if any value in `f_exp` is 
    zero when `lambda_` &gt;= 0. 
 
    The default degrees of freedom, k-1, are for the case when no parameters 
    of the distribution are estimated. If p parameters are estimated by 
    efficient maximum likelihood then the correct degrees of freedom are 
    k-1-p. If the parameters are estimated in a different way, then the 
    dof can be between k-1-p and k-1. However, it is also possible that 
    the asymptotic distribution is not a chisquare, in which case this 
    test is not appropriate. 
 
    This function handles masked arrays.  If an element of `f_obs` or `f_exp` 
    is masked, then data at that position is ignored, and does not count 
    towards the size of the data set. 
 
    .. versionadded:: 0.13.0 
 
    References 
    ---------- 
    .. [1] Lowry, Richard.  &quot;Concepts and Applications of Inferential 
           Statistics&quot;. Chapter 8. 
           https://web.archive.org/web/20171015035606/http://faculty.vassar.edu/lowry/ch8pt1.html 
    .. [2] &quot;Chi-squared test&quot;, https://en.wikipedia.org/wiki/Chi-squared_test 
    .. [3] &quot;G-test&quot;, https://en.wikipedia.org/wiki/G-test 
    .. [4] Sokal, R. R. and Rohlf, F. J. &quot;Biometry: the principles and 
           practice of statistics in biological research&quot;, New York: Freeman 
           (1981) 
    .. [5] Cressie, N. and Read, T. R. C., &quot;Multinomial Goodness-of-Fit 
           Tests&quot;, J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984), 
           pp. 440-464. 
 
    Examples 
    -------- 
    (See `chisquare` for more examples.) 
 
    When just `f_obs` is given, it is assumed that the expected frequencies 
    are uniform and given by the mean of the observed frequencies.  Here we 
    perform a G-test (i.e. use the log-likelihood ratio statistic): 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import power_divergence 
    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], lambda_='log-likelihood') 
    (2.006573162632538, 0.84823476779463769) 
 
    The expected frequencies can be given with the `f_exp` argument: 
 
    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], 
    ...                  f_exp=[16, 16, 16, 16, 16, 8], 
    ...                  lambda_='log-likelihood') 
    (3.3281031458963746, 0.6495419288047497) 
 
    When `f_obs` is 2-D, by default the test is applied to each column. 
 
    &gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T 
    &gt;&gt;&gt; obs.shape 
    (6, 2) 
    &gt;&gt;&gt; power_divergence(obs, lambda_=&quot;log-likelihood&quot;) 
    (array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225])) 
 
    By setting ``axis=None``, the test is applied to all data in the array, 
    which is equivalent to applying the test to the flattened array. 
 
    &gt;&gt;&gt; power_divergence(obs, axis=None) 
    (23.31034482758621, 0.015975692534127565) 
    &gt;&gt;&gt; power_divergence(obs.ravel()) 
    (23.31034482758621, 0.015975692534127565) 
 
    `ddof` is the change to make to the default degrees of freedom. 
 
    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], ddof=1) 
    (2.0, 0.73575888234288467) 
 
    The calculation of the p-values is done by broadcasting the 
    test statistic with `ddof`. 
 
    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], ddof=[0,1,2]) 
    (2.0, array([ 0.84914504,  0.73575888,  0.5724067 ])) 
 
    `f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has 
    shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting 
    `f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared 
    statistics, we must use ``axis=1``: 
 
    &gt;&gt;&gt; power_divergence([16, 18, 16, 14, 12, 12], 
    ...                  f_exp=[[16, 16, 16, 16, 16, 8], 
    ...                         [8, 20, 20, 16, 12, 12]], 
    ...                  axis=1) 
    (array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846])) 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Convert the input argument `lambda_` to a numerical value.</span>
    <span class="s3">if </span><span class="s1">isinstance(lambda_</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s3">if </span><span class="s1">lambda_ </span><span class="s3">not in </span><span class="s1">_power_div_lambda_names:</span>
            <span class="s1">names = repr(list(_power_div_lambda_names.keys()))[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid string for lambda_: {!r}. &quot;</span>
                             <span class="s4">&quot;Valid strings are {}&quot;</span><span class="s1">.format(lambda_</span><span class="s3">, </span><span class="s1">names))</span>
        <span class="s1">lambda_ = _power_div_lambda_names[lambda_]</span>
    <span class="s3">elif </span><span class="s1">lambda_ </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">lambda_ = </span><span class="s5">1</span>

    <span class="s1">f_obs = np.asanyarray(f_obs)</span>
    <span class="s1">f_obs_float = f_obs.astype(np.float64)</span>

    <span class="s3">if </span><span class="s1">f_exp </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">f_exp = np.asanyarray(f_exp)</span>
        <span class="s1">bshape = np.broadcast_shapes(f_obs_float.shape</span><span class="s3">, </span><span class="s1">f_exp.shape)</span>
        <span class="s1">f_obs_float = _m_broadcast_to(f_obs_float</span><span class="s3">, </span><span class="s1">bshape)</span>
        <span class="s1">f_exp = _m_broadcast_to(f_exp</span><span class="s3">, </span><span class="s1">bshape)</span>
        <span class="s1">rtol = </span><span class="s5">1e-8  </span><span class="s0"># to pass existing tests</span>
        <span class="s3">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">f_obs_sum = f_obs_float.sum(axis=axis)</span>
            <span class="s1">f_exp_sum = f_exp.sum(axis=axis)</span>
            <span class="s1">relative_diff = (np.abs(f_obs_sum - f_exp_sum) /</span>
                             <span class="s1">np.minimum(f_obs_sum</span><span class="s3">, </span><span class="s1">f_exp_sum))</span>
            <span class="s1">diff_gt_tol = (relative_diff &gt; rtol).any()</span>
        <span class="s3">if </span><span class="s1">diff_gt_tol:</span>
            <span class="s1">msg = (</span><span class="s4">f&quot;For each axis slice, the sum of the observed &quot;</span>
                   <span class="s4">f&quot;frequencies must agree with the sum of the &quot;</span>
                   <span class="s4">f&quot;expected frequencies to a relative tolerance &quot;</span>
                   <span class="s4">f&quot;of </span><span class="s3">{</span><span class="s1">rtol</span><span class="s3">}</span><span class="s4">, but the percent differences are:</span><span class="s3">\n</span><span class="s4">&quot;</span>
                   <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">relative_diff</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># Ignore 'invalid' errors so the edge case of a data set with length 0</span>
        <span class="s0"># is handled without spurious warnings.</span>
        <span class="s3">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">f_exp = f_obs.mean(axis=axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s0"># `terms` is the array of terms that are summed along `axis` to create</span>
    <span class="s0"># the test statistic.  We use some specialized code for a few special</span>
    <span class="s0"># cases of lambda_.</span>
    <span class="s3">if </span><span class="s1">lambda_ == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># Pearson's chi-squared statistic</span>
        <span class="s1">terms = (f_obs_float - f_exp)**</span><span class="s5">2 </span><span class="s1">/ f_exp</span>
    <span class="s3">elif </span><span class="s1">lambda_ == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0"># Log-likelihood ratio (i.e. G-test)</span>
        <span class="s1">terms = </span><span class="s5">2.0 </span><span class="s1">* special.xlogy(f_obs</span><span class="s3">, </span><span class="s1">f_obs / f_exp)</span>
    <span class="s3">elif </span><span class="s1">lambda_ == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># Modified log-likelihood ratio</span>
        <span class="s1">terms = </span><span class="s5">2.0 </span><span class="s1">* special.xlogy(f_exp</span><span class="s3">, </span><span class="s1">f_exp / f_obs)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># General Cressie-Read power divergence.</span>
        <span class="s1">terms = f_obs * ((f_obs / f_exp)**lambda_ - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">terms /= </span><span class="s5">0.5 </span><span class="s1">* lambda_ * (lambda_ + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">stat = terms.sum(axis=axis)</span>

    <span class="s1">num_obs = _count(terms</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">ddof = asarray(ddof)</span>
    <span class="s1">p = distributions.chi2.sf(stat</span><span class="s3">, </span><span class="s1">num_obs - </span><span class="s5">1 </span><span class="s1">- ddof)</span>

    <span class="s3">return </span><span class="s1">Power_divergenceResult(stat</span><span class="s3">, </span><span class="s1">p)</span>


<span class="s3">def </span><span class="s1">chisquare(f_obs</span><span class="s3">, </span><span class="s1">f_exp=</span><span class="s3">None, </span><span class="s1">ddof=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Calculate a one-way chi-square test. 
 
    The chi-square test tests the null hypothesis that the categorical data 
    has the given frequencies. 
 
    Parameters 
    ---------- 
    f_obs : array_like 
        Observed frequencies in each category. 
    f_exp : array_like, optional 
        Expected frequencies in each category.  By default the categories are 
        assumed to be equally likely. 
    ddof : int, optional 
        &quot;Delta degrees of freedom&quot;: adjustment to the degrees of freedom 
        for the p-value.  The p-value is computed using a chi-squared 
        distribution with ``k - 1 - ddof`` degrees of freedom, where `k` 
        is the number of observed frequencies.  The default value of `ddof` 
        is 0. 
    axis : int or None, optional 
        The axis of the broadcast result of `f_obs` and `f_exp` along which to 
        apply the test.  If axis is None, all values in `f_obs` are treated 
        as a single data set.  Default is 0. 
 
    Returns 
    ------- 
    res: Power_divergenceResult 
        An object containing attributes: 
 
        chisq : float or ndarray 
            The chi-squared test statistic.  The value is a float if `axis` is 
            None or `f_obs` and `f_exp` are 1-D. 
        pvalue : float or ndarray 
            The p-value of the test.  The value is a float if `ddof` and the 
            return value `chisq` are scalars. 
 
    See Also 
    -------- 
    scipy.stats.power_divergence 
    scipy.stats.fisher_exact : Fisher exact test on a 2x2 contingency table. 
    scipy.stats.barnard_exact : An unconditional exact test. An alternative 
        to chi-squared test for small sample sizes. 
 
    Notes 
    ----- 
    This test is invalid when the observed or expected frequencies in each 
    category are too small.  A typical rule is that all of the observed 
    and expected frequencies should be at least 5. According to [3]_, the 
    total number of samples is recommended to be greater than 13, 
    otherwise exact tests (such as Barnard's Exact test) should be used 
    because they do not overreject. 
 
    Also, the sum of the observed and expected frequencies must be the same 
    for the test to be valid; `chisquare` raises an error if the sums do not 
    agree within a relative tolerance of ``1e-8``. 
 
    The default degrees of freedom, k-1, are for the case when no parameters 
    of the distribution are estimated. If p parameters are estimated by 
    efficient maximum likelihood then the correct degrees of freedom are 
    k-1-p. If the parameters are estimated in a different way, then the 
    dof can be between k-1-p and k-1. However, it is also possible that 
    the asymptotic distribution is not chi-square, in which case this test 
    is not appropriate. 
 
    References 
    ---------- 
    .. [1] Lowry, Richard.  &quot;Concepts and Applications of Inferential 
           Statistics&quot;. Chapter 8. 
           https://web.archive.org/web/20171022032306/http://vassarstats.net:80/textbook/ch8pt1.html 
    .. [2] &quot;Chi-squared test&quot;, https://en.wikipedia.org/wiki/Chi-squared_test 
    .. [3] Pearson, Karl. &quot;On the criterion that a given system of deviations from the probable 
           in the case of a correlated system of variables is such that it can be reasonably 
           supposed to have arisen from random sampling&quot;, Philosophical Magazine. Series 5. 50 
           (1900), pp. 157-175. 
    .. [4] Mannan, R. William and E. Charles. Meslow. &quot;Bird populations and 
           vegetation characteristics in managed and old-growth forests, 
           northeastern Oregon.&quot; Journal of Wildlife Management 
           48, 1219-1238, :doi:`10.2307/3801783`, 1984. 
 
    Examples 
    -------- 
    In [4]_, bird foraging behavior was investigated in an old-growth forest 
    of Oregon. 
    In the forest, 44% of the canopy volume was Douglas fir, 
    24% was ponderosa pine, 29% was grand fir, and 3% was western larch. 
    The authors observed the behavior of several species of birds, one of 
    which was the red-breasted nuthatch. They made 189 observations of this 
    species foraging, recording 43 (&quot;23%&quot;) of observations in Douglas fir, 
    52 (&quot;28%&quot;) in ponderosa pine, 54 (&quot;29%&quot;) in grand fir, and 40 (&quot;21%&quot;) in 
    western larch. 
 
    Using a chi-square test, we can test the null hypothesis that the 
    proportions of foraging events are equal to the proportions of canopy 
    volume. The authors of the paper considered a p-value less than 1% to be 
    significant. 
 
    Using the above proportions of canopy volume and observed events, we can 
    infer expected frequencies. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; f_exp = np.array([44, 24, 29, 3]) / 100 * 189 
 
    The observed frequencies of foraging were: 
 
    &gt;&gt;&gt; f_obs = np.array([43, 52, 54, 40]) 
 
    We can now compare the observed frequencies with the expected frequencies. 
 
    &gt;&gt;&gt; from scipy.stats import chisquare 
    &gt;&gt;&gt; chisquare(f_obs=f_obs, f_exp=f_exp) 
    Power_divergenceResult(statistic=228.23515947653874, pvalue=3.3295585338846486e-49) 
 
    The p-value is well below the chosen significance level. Hence, the 
    authors considered the difference to be significant and concluded 
    that the relative proportions of foraging events were not the same 
    as the relative proportions of tree canopy volume. 
 
    Following are other generic examples to demonstrate how the other 
    parameters can be used. 
 
    When just `f_obs` is given, it is assumed that the expected frequencies 
    are uniform and given by the mean of the observed frequencies. 
 
    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12]) 
    Power_divergenceResult(statistic=2.0, pvalue=0.84914503608460956) 
 
    With `f_exp` the expected frequencies can be given. 
 
    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], f_exp=[16, 16, 16, 16, 16, 8]) 
    Power_divergenceResult(statistic=3.5, pvalue=0.62338762774958223) 
 
    When `f_obs` is 2-D, by default the test is applied to each column. 
 
    &gt;&gt;&gt; obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T 
    &gt;&gt;&gt; obs.shape 
    (6, 2) 
    &gt;&gt;&gt; chisquare(obs) 
    Power_divergenceResult(statistic=array([2.        , 6.66666667]), pvalue=array([0.84914504, 0.24663415])) 
 
    By setting ``axis=None``, the test is applied to all data in the array, 
    which is equivalent to applying the test to the flattened array. 
 
    &gt;&gt;&gt; chisquare(obs, axis=None) 
    Power_divergenceResult(statistic=23.31034482758621, pvalue=0.015975692534127565) 
    &gt;&gt;&gt; chisquare(obs.ravel()) 
    Power_divergenceResult(statistic=23.310344827586206, pvalue=0.01597569253412758) 
 
    `ddof` is the change to make to the default degrees of freedom. 
 
    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=1) 
    Power_divergenceResult(statistic=2.0, pvalue=0.7357588823428847) 
 
    The calculation of the p-values is done by broadcasting the 
    chi-squared statistic with `ddof`. 
 
    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], ddof=[0,1,2]) 
    Power_divergenceResult(statistic=2.0, pvalue=array([0.84914504, 0.73575888, 0.5724067 ])) 
 
    `f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has 
    shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting 
    `f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared 
    statistics, we use ``axis=1``: 
 
    &gt;&gt;&gt; chisquare([16, 18, 16, 14, 12, 12], 
    ...           f_exp=[[16, 16, 16, 16, 16, 8], [8, 20, 20, 16, 12, 12]], 
    ...           axis=1) 
    Power_divergenceResult(statistic=array([3.5 , 9.25]), pvalue=array([0.62338763, 0.09949846])) 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa</span>
    <span class="s3">return </span><span class="s1">power_divergence(f_obs</span><span class="s3">, </span><span class="s1">f_exp=f_exp</span><span class="s3">, </span><span class="s1">ddof=ddof</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">,</span>
                            <span class="s1">lambda_=</span><span class="s4">&quot;pearson&quot;</span><span class="s1">)</span>


<span class="s1">KstestResult = _make_tuple_bunch(</span><span class="s4">'KstestResult'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">]</span><span class="s3">,</span>
                                 <span class="s1">[</span><span class="s4">'statistic_location'</span><span class="s3">, </span><span class="s4">'statistic_sign'</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_compute_dplus(cdfvals</span><span class="s3">, </span><span class="s1">x):</span>
    <span class="s2">&quot;&quot;&quot;Computes D+ as used in the Kolmogorov-Smirnov test. 
 
    Parameters 
    ---------- 
    cdfvals : array_like 
        Sorted array of CDF values between 0 and 1 
    x: array_like 
        Sorted array of the stochastic variable itself 
 
    Returns 
    ------- 
    res: Pair with the following elements: 
        - The maximum distance of the CDF values below Uniform(0, 1). 
        - The location at which the maximum is reached. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n = len(cdfvals)</span>
    <span class="s1">dplus = (np.arange(</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">n + </span><span class="s5">1</span><span class="s1">) / n - cdfvals)</span>
    <span class="s1">amax = dplus.argmax()</span>
    <span class="s1">loc_max = x[amax]</span>
    <span class="s3">return </span><span class="s1">(dplus[amax]</span><span class="s3">, </span><span class="s1">loc_max)</span>


<span class="s3">def </span><span class="s1">_compute_dminus(cdfvals</span><span class="s3">, </span><span class="s1">x):</span>
    <span class="s2">&quot;&quot;&quot;Computes D- as used in the Kolmogorov-Smirnov test. 
 
    Parameters 
    ---------- 
    cdfvals : array_like 
        Sorted array of CDF values between 0 and 1 
    x: array_like 
        Sorted array of the stochastic variable itself 
 
    Returns 
    ------- 
    res: Pair with the following elements: 
        - Maximum distance of the CDF values above Uniform(0, 1) 
        - The location at which the maximum is reached. 
    &quot;&quot;&quot;</span>
    <span class="s1">n = len(cdfvals)</span>
    <span class="s1">dminus = (cdfvals - np.arange(</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">n)/n)</span>
    <span class="s1">amax = dminus.argmax()</span>
    <span class="s1">loc_max = x[amax]</span>
    <span class="s3">return </span><span class="s1">(dminus[amax]</span><span class="s3">, </span><span class="s1">loc_max)</span>


<span class="s1">@_rename_parameter(</span><span class="s4">&quot;mode&quot;</span><span class="s3">, </span><span class="s4">&quot;method&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">ks_1samp(x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">, </span><span class="s1">args=()</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'auto'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Performs the one-sample Kolmogorov-Smirnov test for goodness of fit. 
 
    This test compares the underlying distribution F(x) of a sample 
    against a given continuous distribution G(x). See Notes for a description 
    of the available null and alternative hypotheses. 
 
    Parameters 
    ---------- 
    x : array_like 
        a 1-D array of observations of iid random variables. 
    cdf : callable 
        callable used to calculate the cdf. 
    args : tuple, sequence, optional 
        Distribution parameters, used with `cdf`. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the null and alternative hypotheses. Default is 'two-sided'. 
        Please see explanations in the Notes below. 
    method : {'auto', 'exact', 'approx', 'asymp'}, optional 
        Defines the distribution used for calculating the p-value. 
        The following options are available (default is 'auto'): 
 
          * 'auto' : selects one of the other options. 
          * 'exact' : uses the exact distribution of test statistic. 
          * 'approx' : approximates the two-sided probability with twice 
            the one-sided probability 
          * 'asymp': uses asymptotic distribution of test statistic 
 
    Returns 
    ------- 
    res: KstestResult 
        An object containing attributes: 
 
        statistic : float 
            KS test statistic, either D+, D-, or D (the maximum of the two) 
        pvalue : float 
            One-tailed or two-tailed p-value. 
        statistic_location : float 
            Value of `x` corresponding with the KS statistic; i.e., the 
            distance between the empirical distribution function and the 
            hypothesized cumulative distribution function is measured at this 
            observation. 
        statistic_sign : int 
            +1 if the KS statistic is the maximum positive difference between 
            the empirical distribution function and the hypothesized cumulative 
            distribution function (D+); -1 if the KS statistic is the maximum 
            negative difference (D-). 
 
 
    See Also 
    -------- 
    ks_2samp, kstest 
 
    Notes 
    ----- 
    There are three options for the null and corresponding alternative 
    hypothesis that can be selected using the `alternative` parameter. 
 
    - `two-sided`: The null hypothesis is that the two distributions are 
      identical, F(x)=G(x) for all x; the alternative is that they are not 
      identical. 
 
    - `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the 
      alternative is that F(x) &lt; G(x) for at least one x. 
 
    - `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the 
      alternative is that F(x) &gt; G(x) for at least one x. 
 
    Note that the alternative hypotheses describe the *CDFs* of the 
    underlying distributions, not the observed values. For example, 
    suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in 
    x1 tend to be less than those in x2. 
 
    Examples 
    -------- 
    Suppose we wish to test the null hypothesis that a sample is distributed 
    according to the standard normal. 
    We choose a confidence level of 95%; that is, we will reject the null 
    hypothesis in favor of the alternative if the p-value is less than 0.05. 
 
    When testing uniformly distributed data, we would expect the 
    null hypothesis to be rejected. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; stats.ks_1samp(stats.uniform.rvs(size=100, random_state=rng), 
    ...                stats.norm.cdf) 
    KstestResult(statistic=0.5001899973268688, pvalue=1.1616392184763533e-23) 
 
    Indeed, the p-value is lower than our threshold of 0.05, so we reject the 
    null hypothesis in favor of the default &quot;two-sided&quot; alternative: the data 
    are *not* distributed according to the standard normal. 
 
    When testing random variates from the standard normal distribution, we 
    expect the data to be consistent with the null hypothesis most of the time. 
 
    &gt;&gt;&gt; x = stats.norm.rvs(size=100, random_state=rng) 
    &gt;&gt;&gt; stats.ks_1samp(x, stats.norm.cdf) 
    KstestResult(statistic=0.05345882212970396, pvalue=0.9227159037744717) 
 
    As expected, the p-value of 0.92 is not below our threshold of 0.05, so 
    we cannot reject the null hypothesis. 
 
    Suppose, however, that the random variates are distributed according to 
    a normal distribution that is shifted toward greater values. In this case, 
    the cumulative density function (CDF) of the underlying distribution tends 
    to be *less* than the CDF of the standard normal. Therefore, we would 
    expect the null hypothesis to be rejected with ``alternative='less'``: 
 
    &gt;&gt;&gt; x = stats.norm.rvs(size=100, loc=0.5, random_state=rng) 
    &gt;&gt;&gt; stats.ks_1samp(x, stats.norm.cdf, alternative='less') 
    KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743) 
 
    and indeed, with p-value smaller than our threshold, we reject the null 
    hypothesis in favor of the alternative. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mode = method</span>

    <span class="s1">alternative = {</span><span class="s4">'t'</span><span class="s1">: </span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s4">'g'</span><span class="s1">: </span><span class="s4">'greater'</span><span class="s3">, </span><span class="s4">'l'</span><span class="s1">: </span><span class="s4">'less'</span><span class="s1">}.get(</span>
        <span class="s1">alternative.lower()[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">alternative)</span>
    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s4">'greater'</span><span class="s3">, </span><span class="s4">'less'</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unexpected alternative %s&quot; </span><span class="s1">% alternative)</span>
    <span class="s3">if </span><span class="s1">np.ma.is_masked(x):</span>
        <span class="s1">x = x.compressed()</span>

    <span class="s1">N = len(x)</span>
    <span class="s1">x = np.sort(x)</span>
    <span class="s1">cdfvals = cdf(x</span><span class="s3">, </span><span class="s1">*args)</span>

    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'greater'</span><span class="s1">:</span>
        <span class="s1">Dplus</span><span class="s3">, </span><span class="s1">d_location = _compute_dplus(cdfvals</span><span class="s3">, </span><span class="s1">x)</span>
        <span class="s3">return </span><span class="s1">KstestResult(Dplus</span><span class="s3">, </span><span class="s1">distributions.ksone.sf(Dplus</span><span class="s3">, </span><span class="s1">N)</span><span class="s3">,</span>
                            <span class="s1">statistic_location=d_location</span><span class="s3">,</span>
                            <span class="s1">statistic_sign=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'less'</span><span class="s1">:</span>
        <span class="s1">Dminus</span><span class="s3">, </span><span class="s1">d_location = _compute_dminus(cdfvals</span><span class="s3">, </span><span class="s1">x)</span>
        <span class="s3">return </span><span class="s1">KstestResult(Dminus</span><span class="s3">, </span><span class="s1">distributions.ksone.sf(Dminus</span><span class="s3">, </span><span class="s1">N)</span><span class="s3">,</span>
                            <span class="s1">statistic_location=d_location</span><span class="s3">,</span>
                            <span class="s1">statistic_sign=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0"># alternative == 'two-sided':</span>
    <span class="s1">Dplus</span><span class="s3">, </span><span class="s1">dplus_location = _compute_dplus(cdfvals</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s1">Dminus</span><span class="s3">, </span><span class="s1">dminus_location = _compute_dminus(cdfvals</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">if </span><span class="s1">Dplus &gt; Dminus:</span>
        <span class="s1">D = Dplus</span>
        <span class="s1">d_location = dplus_location</span>
        <span class="s1">d_sign = </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">D = Dminus</span>
        <span class="s1">d_location = dminus_location</span>
        <span class="s1">d_sign = -</span><span class="s5">1</span>

    <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'auto'</span><span class="s1">:  </span><span class="s0"># Always select exact</span>
        <span class="s1">mode = </span><span class="s4">'exact'</span>
    <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'exact'</span><span class="s1">:</span>
        <span class="s1">prob = distributions.kstwo.sf(D</span><span class="s3">, </span><span class="s1">N)</span>
    <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">'asymp'</span><span class="s1">:</span>
        <span class="s1">prob = distributions.kstwobign.sf(D * np.sqrt(N))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># mode == 'approx'</span>
        <span class="s1">prob = </span><span class="s5">2 </span><span class="s1">* distributions.ksone.sf(D</span><span class="s3">, </span><span class="s1">N)</span>
    <span class="s1">prob = np.clip(prob</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">KstestResult(D</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">,</span>
                        <span class="s1">statistic_location=d_location</span><span class="s3">,</span>
                        <span class="s1">statistic_sign=d_sign)</span>


<span class="s1">Ks_2sampResult = KstestResult</span>


<span class="s3">def </span><span class="s1">_compute_prob_outside_square(n</span><span class="s3">, </span><span class="s1">h):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute the proportion of paths that pass outside the two diagonal lines. 
 
    Parameters 
    ---------- 
    n : integer 
        n &gt; 0 
    h : integer 
        0 &lt;= h &lt;= n 
 
    Returns 
    ------- 
    p : float 
        The proportion of paths that pass outside the lines x-y = +/-h. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Compute Pr(D_{n,n} &gt;= h/n)</span>
    <span class="s0"># Prob = 2 * ( binom(2n, n-h) - binom(2n, n-2a) + binom(2n, n-3a) - ... )</span>
    <span class="s0"># / binom(2n, n)</span>
    <span class="s0"># This formulation exhibits subtractive cancellation.</span>
    <span class="s0"># Instead divide each term by binom(2n, n), then factor common terms</span>
    <span class="s0"># and use a Horner-like algorithm</span>
    <span class="s0"># P = 2 * A0 * (1 - A1*(1 - A2*(1 - A3*(1 - A4*(...)))))</span>

    <span class="s1">P = </span><span class="s5">0.0</span>
    <span class="s1">k = int(np.floor(n / h))</span>
    <span class="s3">while </span><span class="s1">k &gt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">p1 = </span><span class="s5">1.0</span>
        <span class="s0"># Each of the Ai terms has numerator and denominator with</span>
        <span class="s0"># h simple terms.</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(h):</span>
            <span class="s1">p1 = (n - k * h - j) * p1 / (n + k * h + j + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">P = p1 * (</span><span class="s5">1.0 </span><span class="s1">- P)</span>
        <span class="s1">k -= </span><span class="s5">1</span>
    <span class="s3">return </span><span class="s5">2 </span><span class="s1">* P</span>


<span class="s3">def </span><span class="s1">_count_paths_outside_method(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">h):</span>
    <span class="s2">&quot;&quot;&quot;Count the number of paths that pass outside the specified diagonal. 
 
    Parameters 
    ---------- 
    m : integer 
        m &gt; 0 
    n : integer 
        n &gt; 0 
    g : integer 
        g is greatest common divisor of m and n 
    h : integer 
        0 &lt;= h &lt;= lcm(m,n) 
 
    Returns 
    ------- 
    p : float 
        The number of paths that go low. 
        The calculation may overflow - check for a finite answer. 
 
    Notes 
    ----- 
    Count the integer lattice paths from (0, 0) to (m, n), which at some 
    point (x, y) along the path, satisfy: 
      m*y &lt;= n*x - h*g 
    The paths make steps of size +1 in either positive x or positive y 
    directions. 
 
    We generally follow Hodges' treatment of Drion/Gnedenko/Korolyuk. 
    Hodges, J.L. Jr., 
    &quot;The Significance Probability of the Smirnov Two-Sample Test,&quot; 
    Arkiv fiur Matematik, 3, No. 43 (1958), 469-86. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Compute #paths which stay lower than x/m-y/n = h/lcm(m,n)</span>
    <span class="s0"># B(x, y) = #{paths from (0,0) to (x,y) without</span>
    <span class="s0">#             previously crossing the boundary}</span>
    <span class="s0">#         = binom(x, y) - #{paths which already reached the boundary}</span>
    <span class="s0"># Multiply by the number of path extensions going from (x, y) to (m, n)</span>
    <span class="s0"># Sum.</span>

    <span class="s0"># Probability is symmetrical in m, n.  Computation below assumes m &gt;= n.</span>
    <span class="s3">if </span><span class="s1">m &lt; n:</span>
        <span class="s1">m</span><span class="s3">, </span><span class="s1">n = n</span><span class="s3">, </span><span class="s1">m</span>
    <span class="s1">mg = m // g</span>
    <span class="s1">ng = n // g</span>

    <span class="s0"># Not every x needs to be considered.</span>
    <span class="s0"># xj holds the list of x values to be checked.</span>
    <span class="s0"># Wherever n*x/m + ng*h crosses an integer</span>
    <span class="s1">lxj = n + (mg-h)//mg</span>
    <span class="s1">xj = [(h + mg * j + ng-</span><span class="s5">1</span><span class="s1">)//ng </span><span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(lxj)]</span>
    <span class="s0"># B is an array just holding a few values of B(x,y), the ones needed.</span>
    <span class="s0"># B[j] == B(x_j, j)</span>
    <span class="s3">if </span><span class="s1">lxj == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">special.binom(m + n</span><span class="s3">, </span><span class="s1">n)</span>
    <span class="s1">B = np.zeros(lxj)</span>
    <span class="s1">B[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>
    <span class="s0"># Compute the B(x, y) terms</span>
    <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">lxj):</span>
        <span class="s1">Bj = special.binom(xj[j] + j</span><span class="s3">, </span><span class="s1">j)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(j):</span>
            <span class="s1">bin = special.binom(xj[j] - xj[i] + j - i</span><span class="s3">, </span><span class="s1">j-i)</span>
            <span class="s1">Bj -= bin * B[i]</span>
        <span class="s1">B[j] = Bj</span>
    <span class="s0"># Compute the number of path extensions...</span>
    <span class="s1">num_paths = </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(lxj):</span>
        <span class="s1">bin = special.binom((m-xj[j]) + (n - j)</span><span class="s3">, </span><span class="s1">n-j)</span>
        <span class="s1">term = B[j] * bin</span>
        <span class="s1">num_paths += term</span>
    <span class="s3">return </span><span class="s1">num_paths</span>


<span class="s3">def </span><span class="s1">_attempt_exact_2kssamp(n1</span><span class="s3">, </span><span class="s1">n2</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">alternative):</span>
    <span class="s2">&quot;&quot;&quot;Attempts to compute the exact 2sample probability. 
 
    n1, n2 are the sample sizes 
    g is the gcd(n1, n2) 
    d is the computed max difference in ECDFs 
 
    Returns (success, d, probability) 
    &quot;&quot;&quot;</span>
    <span class="s1">lcm = (n1 // g) * n2</span>
    <span class="s1">h = int(np.round(d * lcm))</span>
    <span class="s1">d = h * </span><span class="s5">1.0 </span><span class="s1">/ lcm</span>
    <span class="s3">if </span><span class="s1">h == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return True, </span><span class="s1">d</span><span class="s3">, </span><span class="s5">1.0</span>
    <span class="s1">saw_fp_error</span><span class="s3">, </span><span class="s1">prob = </span><span class="s3">False, </span><span class="s1">np.nan</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">&quot;raise&quot;</span><span class="s3">, </span><span class="s1">over=</span><span class="s4">&quot;raise&quot;</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'two-sided'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">n1 == n2:</span>
                    <span class="s1">prob = _compute_prob_outside_square(n1</span><span class="s3">, </span><span class="s1">h)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">prob = _compute_outer_prob_inside_method(n1</span><span class="s3">, </span><span class="s1">n2</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">h)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">n1 == n2:</span>
                    <span class="s0"># prob = binom(2n, n-h) / binom(2n, n)</span>
                    <span class="s0"># Evaluating in that form incurs roundoff errors</span>
                    <span class="s0"># from special.binom. Instead calculate directly</span>
                    <span class="s1">jrange = np.arange(h)</span>
                    <span class="s1">prob = np.prod((n1 - jrange) / (n1 + jrange + </span><span class="s5">1.0</span><span class="s1">))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">with </span><span class="s1">np.errstate(over=</span><span class="s4">'raise'</span><span class="s1">):</span>
                        <span class="s1">num_paths = _count_paths_outside_method(n1</span><span class="s3">, </span><span class="s1">n2</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">h)</span>
                    <span class="s1">bin = special.binom(n1 + n2</span><span class="s3">, </span><span class="s1">n1)</span>
                    <span class="s3">if </span><span class="s1">num_paths &gt; bin </span><span class="s3">or </span><span class="s1">np.isinf(bin):</span>
                        <span class="s1">saw_fp_error = </span><span class="s3">True</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">prob = num_paths / bin</span>

    <span class="s3">except </span><span class="s1">(FloatingPointError</span><span class="s3">, </span><span class="s1">OverflowError):</span>
        <span class="s1">saw_fp_error = </span><span class="s3">True</span>

    <span class="s3">if </span><span class="s1">saw_fp_error:</span>
        <span class="s3">return False, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">np.nan</span>
    <span class="s3">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= prob &lt;= </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3">return False, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">prob</span>
    <span class="s3">return True, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">prob</span>


<span class="s1">@_rename_parameter(</span><span class="s4">&quot;mode&quot;</span><span class="s3">, </span><span class="s4">&quot;method&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">ks_2samp(data1</span><span class="s3">, </span><span class="s1">data2</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'auto'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Performs the two-sample Kolmogorov-Smirnov test for goodness of fit. 
 
    This test compares the underlying continuous distributions F(x) and G(x) 
    of two independent samples.  See Notes for a description of the available 
    null and alternative hypotheses. 
 
    Parameters 
    ---------- 
    data1, data2 : array_like, 1-Dimensional 
        Two arrays of sample observations assumed to be drawn from a continuous 
        distribution, sample sizes can be different. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the null and alternative hypotheses. Default is 'two-sided'. 
        Please see explanations in the Notes below. 
    method : {'auto', 'exact', 'asymp'}, optional 
        Defines the method used for calculating the p-value. 
        The following options are available (default is 'auto'): 
 
          * 'auto' : use 'exact' for small size arrays, 'asymp' for large 
          * 'exact' : use exact distribution of test statistic 
          * 'asymp' : use asymptotic distribution of test statistic 
 
    Returns 
    ------- 
    res: KstestResult 
        An object containing attributes: 
 
        statistic : float 
            KS test statistic. 
        pvalue : float 
            One-tailed or two-tailed p-value. 
        statistic_location : float 
            Value from `data1` or `data2` corresponding with the KS statistic; 
            i.e., the distance between the empirical distribution functions is 
            measured at this observation. 
        statistic_sign : int 
            +1 if the empirical distribution function of `data1` exceeds 
            the empirical distribution function of `data2` at 
            `statistic_location`, otherwise -1. 
 
    See Also 
    -------- 
    kstest, ks_1samp, epps_singleton_2samp, anderson_ksamp 
 
    Notes 
    ----- 
    There are three options for the null and corresponding alternative 
    hypothesis that can be selected using the `alternative` parameter. 
 
    - `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the 
      alternative is that F(x) &lt; G(x) for at least one x. The statistic 
      is the magnitude of the minimum (most negative) difference between the 
      empirical distribution functions of the samples. 
 
    - `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the 
      alternative is that F(x) &gt; G(x) for at least one x. The statistic 
      is the maximum (most positive) difference between the empirical 
      distribution functions of the samples. 
 
    - `two-sided`: The null hypothesis is that the two distributions are 
      identical, F(x)=G(x) for all x; the alternative is that they are not 
      identical. The statistic is the maximum absolute difference between the 
      empirical distribution functions of the samples. 
 
    Note that the alternative hypotheses describe the *CDFs* of the 
    underlying distributions, not the observed values of the data. For example, 
    suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in 
    x1 tend to be less than those in x2. 
 
    If the KS statistic is large, then the p-value will be small, and this may 
    be taken as evidence against the null hypothesis in favor of the 
    alternative. 
 
    If ``method='exact'``, `ks_2samp` attempts to compute an exact p-value, 
    that is, the probability under the null hypothesis of obtaining a test 
    statistic value as extreme as the value computed from the data. 
    If ``method='asymp'``, the asymptotic Kolmogorov-Smirnov distribution is 
    used to compute an approximate p-value. 
    If ``method='auto'``, an exact p-value computation is attempted if both 
    sample sizes are less than 10000; otherwise, the asymptotic method is used. 
    In any case, if an exact p-value calculation is attempted and fails, a 
    warning will be emitted, and the asymptotic p-value will be returned. 
 
    The 'two-sided' 'exact' computation computes the complementary probability 
    and then subtracts from 1.  As such, the minimum probability it can return 
    is about 1e-16.  While the algorithm itself is exact, numerical 
    errors may accumulate for large sample sizes.   It is most suited to 
    situations in which one of the sample sizes is only a few thousand. 
 
    We generally follow Hodges' treatment of Drion/Gnedenko/Korolyuk [1]_. 
 
    References 
    ---------- 
    .. [1] Hodges, J.L. Jr.,  &quot;The Significance Probability of the Smirnov 
           Two-Sample Test,&quot; Arkiv fiur Matematik, 3, No. 43 (1958), 469-86. 
 
    Examples 
    -------- 
    Suppose we wish to test the null hypothesis that two samples were drawn 
    from the same distribution. 
    We choose a confidence level of 95%; that is, we will reject the null 
    hypothesis in favor of the alternative if the p-value is less than 0.05. 
 
    If the first sample were drawn from a uniform distribution and the second 
    were drawn from the standard normal, we would expect the null hypothesis 
    to be rejected. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; sample1 = stats.uniform.rvs(size=100, random_state=rng) 
    &gt;&gt;&gt; sample2 = stats.norm.rvs(size=110, random_state=rng) 
    &gt;&gt;&gt; stats.ks_2samp(sample1, sample2) 
    KstestResult(statistic=0.5454545454545454, pvalue=7.37417839555191e-15) 
 
    Indeed, the p-value is lower than our threshold of 0.05, so we reject the 
    null hypothesis in favor of the default &quot;two-sided&quot; alternative: the data 
    were *not* drawn from the same distribution. 
 
    When both samples are drawn from the same distribution, we expect the data 
    to be consistent with the null hypothesis most of the time. 
 
    &gt;&gt;&gt; sample1 = stats.norm.rvs(size=105, random_state=rng) 
    &gt;&gt;&gt; sample2 = stats.norm.rvs(size=95, random_state=rng) 
    &gt;&gt;&gt; stats.ks_2samp(sample1, sample2) 
    KstestResult(statistic=0.10927318295739348, pvalue=0.5438289009927495) 
 
    As expected, the p-value of 0.54 is not below our threshold of 0.05, so 
    we cannot reject the null hypothesis. 
 
    Suppose, however, that the first sample were drawn from 
    a normal distribution shifted toward greater values. In this case, 
    the cumulative density function (CDF) of the underlying distribution tends 
    to be *less* than the CDF underlying the second sample. Therefore, we would 
    expect the null hypothesis to be rejected with ``alternative='less'``: 
 
    &gt;&gt;&gt; sample1 = stats.norm.rvs(size=105, loc=0.5, random_state=rng) 
    &gt;&gt;&gt; stats.ks_2samp(sample1, sample2, alternative='less') 
    KstestResult(statistic=0.4055137844611529, pvalue=3.5474563068855554e-08) 
 
    and indeed, with p-value smaller than our threshold, we reject the null 
    hypothesis in favor of the alternative. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mode = method</span>

    <span class="s3">if </span><span class="s1">mode </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'auto'</span><span class="s3">, </span><span class="s4">'exact'</span><span class="s3">, </span><span class="s4">'asymp'</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f'Invalid value for mode: </span><span class="s3">{</span><span class="s1">mode</span><span class="s3">}</span><span class="s4">'</span><span class="s1">)</span>
    <span class="s1">alternative = {</span><span class="s4">'t'</span><span class="s1">: </span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s4">'g'</span><span class="s1">: </span><span class="s4">'greater'</span><span class="s3">, </span><span class="s4">'l'</span><span class="s1">: </span><span class="s4">'less'</span><span class="s1">}.get(</span>
        <span class="s1">alternative.lower()[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">alternative)</span>
    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s4">'less'</span><span class="s3">, </span><span class="s4">'greater'</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f'Invalid value for alternative: </span><span class="s3">{</span><span class="s1">alternative</span><span class="s3">}</span><span class="s4">'</span><span class="s1">)</span>
    <span class="s1">MAX_AUTO_N = </span><span class="s5">10000  </span><span class="s0"># 'auto' will attempt to be exact if n1,n2 &lt;= MAX_AUTO_N</span>
    <span class="s3">if </span><span class="s1">np.ma.is_masked(data1):</span>
        <span class="s1">data1 = data1.compressed()</span>
    <span class="s3">if </span><span class="s1">np.ma.is_masked(data2):</span>
        <span class="s1">data2 = data2.compressed()</span>
    <span class="s1">data1 = np.sort(data1)</span>
    <span class="s1">data2 = np.sort(data2)</span>
    <span class="s1">n1 = data1.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">n2 = data2.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">min(n1</span><span class="s3">, </span><span class="s1">n2) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Data passed to ks_2samp must not be empty'</span><span class="s1">)</span>

    <span class="s1">data_all = np.concatenate([data1</span><span class="s3">, </span><span class="s1">data2])</span>
    <span class="s0"># using searchsorted solves equal data problem</span>
    <span class="s1">cdf1 = np.searchsorted(data1</span><span class="s3">, </span><span class="s1">data_all</span><span class="s3">, </span><span class="s1">side=</span><span class="s4">'right'</span><span class="s1">) / n1</span>
    <span class="s1">cdf2 = np.searchsorted(data2</span><span class="s3">, </span><span class="s1">data_all</span><span class="s3">, </span><span class="s1">side=</span><span class="s4">'right'</span><span class="s1">) / n2</span>
    <span class="s1">cddiffs = cdf1 - cdf2</span>

    <span class="s0"># Identify the location of the statistic</span>
    <span class="s1">argminS = np.argmin(cddiffs)</span>
    <span class="s1">argmaxS = np.argmax(cddiffs)</span>
    <span class="s1">loc_minS = data_all[argminS]</span>
    <span class="s1">loc_maxS = data_all[argmaxS]</span>

    <span class="s0"># Ensure sign of minS is not negative.</span>
    <span class="s1">minS = np.clip(-cddiffs[argminS]</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">maxS = cddiffs[argmaxS]</span>

    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'less' </span><span class="s3">or </span><span class="s1">(alternative == </span><span class="s4">'two-sided' </span><span class="s3">and </span><span class="s1">minS &gt; maxS):</span>
        <span class="s1">d = minS</span>
        <span class="s1">d_location = loc_minS</span>
        <span class="s1">d_sign = -</span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">d = maxS</span>
        <span class="s1">d_location = loc_maxS</span>
        <span class="s1">d_sign = </span><span class="s5">1</span>
    <span class="s1">g = gcd(n1</span><span class="s3">, </span><span class="s1">n2)</span>
    <span class="s1">n1g = n1 // g</span>
    <span class="s1">n2g = n2 // g</span>
    <span class="s1">prob = -np.inf</span>
    <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'auto'</span><span class="s1">:</span>
        <span class="s1">mode = </span><span class="s4">'exact' </span><span class="s3">if </span><span class="s1">max(n1</span><span class="s3">, </span><span class="s1">n2) &lt;= MAX_AUTO_N </span><span class="s3">else </span><span class="s4">'asymp'</span>
    <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">'exact'</span><span class="s1">:</span>
        <span class="s0"># If lcm(n1, n2) is too big, switch from exact to asymp</span>
        <span class="s3">if </span><span class="s1">n1g &gt;= np.iinfo(np.int32).max / n2g:</span>
            <span class="s1">mode = </span><span class="s4">'asymp'</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">f&quot;Exact ks_2samp calculation not possible with samples sizes &quot;</span>
                <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">n1</span><span class="s3">} </span><span class="s4">and </span><span class="s3">{</span><span class="s1">n2</span><span class="s3">}</span><span class="s4">. Switching to 'asymp'.&quot;</span><span class="s3">, </span><span class="s1">RuntimeWarning</span><span class="s3">,</span>
                <span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'exact'</span><span class="s1">:</span>
        <span class="s1">success</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">prob = _attempt_exact_2kssamp(n1</span><span class="s3">, </span><span class="s1">n2</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">alternative)</span>
        <span class="s3">if not </span><span class="s1">success:</span>
            <span class="s1">mode = </span><span class="s4">'asymp'</span>
            <span class="s1">warnings.warn(</span><span class="s4">f&quot;ks_2samp: Exact calculation unsuccessful. &quot;</span>
                          <span class="s4">f&quot;Switching to method=</span><span class="s3">{</span><span class="s1">mode</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s3">, </span><span class="s1">RuntimeWarning</span><span class="s3">,</span>
                          <span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'asymp'</span><span class="s1">:</span>
        <span class="s0"># The product n1*n2 is large.  Use Smirnov's asymptoptic formula.</span>
        <span class="s0"># Ensure float to avoid overflow in multiplication</span>
        <span class="s0"># sorted because the one-sided formula is not symmetric in n1, n2</span>
        <span class="s1">m</span><span class="s3">, </span><span class="s1">n = sorted([float(n1)</span><span class="s3">, </span><span class="s1">float(n2)]</span><span class="s3">, </span><span class="s1">reverse=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">en = m * n / (m + n)</span>
        <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'two-sided'</span><span class="s1">:</span>
            <span class="s1">prob = distributions.kstwo.sf(d</span><span class="s3">, </span><span class="s1">np.round(en))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">z = np.sqrt(en) * d</span>
            <span class="s0"># Use Hodges' suggested approximation Eqn 5.3</span>
            <span class="s0"># Requires m to be the larger of (n1, n2)</span>
            <span class="s1">expt = -</span><span class="s5">2 </span><span class="s1">* z**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">2 </span><span class="s1">* z * (m + </span><span class="s5">2</span><span class="s1">*n)/np.sqrt(m*n*(m+n))/</span><span class="s5">3.0</span>
            <span class="s1">prob = np.exp(expt)</span>

    <span class="s1">prob = np.clip(prob</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">KstestResult(d</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">statistic_location=d_location</span><span class="s3">,</span>
                        <span class="s1">statistic_sign=d_sign)</span>


<span class="s3">def </span><span class="s1">_parse_kstest_args(data1</span><span class="s3">, </span><span class="s1">data2</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">N):</span>
    <span class="s0"># kstest allows many different variations of arguments.</span>
    <span class="s0"># Pull out the parsing into a separate function</span>
    <span class="s0"># (xvals, yvals, )  # 2sample</span>
    <span class="s0"># (xvals, cdf function,..)</span>
    <span class="s0"># (xvals, name of distribution, ...)</span>
    <span class="s0"># (name of distribution, name of distribution, ...)</span>

    <span class="s0"># Returns xvals, yvals, cdf</span>
    <span class="s0"># where cdf is a cdf function, or None</span>
    <span class="s0"># and yvals is either an array_like of values, or None</span>
    <span class="s0"># and xvals is array_like.</span>
    <span class="s1">rvsfunc</span><span class="s3">, </span><span class="s1">cdf = </span><span class="s3">None, None</span>
    <span class="s3">if </span><span class="s1">isinstance(data1</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">rvsfunc = getattr(distributions</span><span class="s3">, </span><span class="s1">data1).rvs</span>
    <span class="s3">elif </span><span class="s1">callable(data1):</span>
        <span class="s1">rvsfunc = data1</span>

    <span class="s3">if </span><span class="s1">isinstance(data2</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">cdf = getattr(distributions</span><span class="s3">, </span><span class="s1">data2).cdf</span>
        <span class="s1">data2 = </span><span class="s3">None</span>
    <span class="s3">elif </span><span class="s1">callable(data2):</span>
        <span class="s1">cdf = data2</span>
        <span class="s1">data2 = </span><span class="s3">None</span>

    <span class="s1">data1 = np.sort(rvsfunc(*args</span><span class="s3">, </span><span class="s1">size=N) </span><span class="s3">if </span><span class="s1">rvsfunc </span><span class="s3">else </span><span class="s1">data1)</span>
    <span class="s3">return </span><span class="s1">data1</span><span class="s3">, </span><span class="s1">data2</span><span class="s3">, </span><span class="s1">cdf</span>


<span class="s1">@_rename_parameter(</span><span class="s4">&quot;mode&quot;</span><span class="s3">, </span><span class="s4">&quot;method&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">kstest(rvs</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">, </span><span class="s1">args=()</span><span class="s3">, </span><span class="s1">N=</span><span class="s5">20</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'auto'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Performs the (one-sample or two-sample) Kolmogorov-Smirnov test for 
    goodness of fit. 
 
    The one-sample test compares the underlying distribution F(x) of a sample 
    against a given distribution G(x). The two-sample test compares the 
    underlying distributions of two independent samples. Both tests are valid 
    only for continuous distributions. 
 
    Parameters 
    ---------- 
    rvs : str, array_like, or callable 
        If an array, it should be a 1-D array of observations of random 
        variables. 
        If a callable, it should be a function to generate random variables; 
        it is required to have a keyword argument `size`. 
        If a string, it should be the name of a distribution in `scipy.stats`, 
        which will be used to generate random variables. 
    cdf : str, array_like or callable 
        If array_like, it should be a 1-D array of observations of random 
        variables, and the two-sample test is performed 
        (and rvs must be array_like). 
        If a callable, that callable is used to calculate the cdf. 
        If a string, it should be the name of a distribution in `scipy.stats`, 
        which will be used as the cdf function. 
    args : tuple, sequence, optional 
        Distribution parameters, used if `rvs` or `cdf` are strings or 
        callables. 
    N : int, optional 
        Sample size if `rvs` is string or callable.  Default is 20. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the null and alternative hypotheses. Default is 'two-sided'. 
        Please see explanations in the Notes below. 
    method : {'auto', 'exact', 'approx', 'asymp'}, optional 
        Defines the distribution used for calculating the p-value. 
        The following options are available (default is 'auto'): 
 
          * 'auto' : selects one of the other options. 
          * 'exact' : uses the exact distribution of test statistic. 
          * 'approx' : approximates the two-sided probability with twice the 
            one-sided probability 
          * 'asymp': uses asymptotic distribution of test statistic 
 
    Returns 
    ------- 
    res: KstestResult 
        An object containing attributes: 
 
        statistic : float 
            KS test statistic, either D+, D-, or D (the maximum of the two) 
        pvalue : float 
            One-tailed or two-tailed p-value. 
        statistic_location : float 
            In a one-sample test, this is the value of `rvs` 
            corresponding with the KS statistic; i.e., the distance between 
            the empirical distribution function and the hypothesized cumulative 
            distribution function is measured at this observation. 
 
            In a two-sample test, this is the value from `rvs` or `cdf` 
            corresponding with the KS statistic; i.e., the distance between 
            the empirical distribution functions is measured at this 
            observation. 
        statistic_sign : int 
            In a one-sample test, this is +1 if the KS statistic is the 
            maximum positive difference between the empirical distribution 
            function and the hypothesized cumulative distribution function 
            (D+); it is -1 if the KS statistic is the maximum negative 
            difference (D-). 
 
            In a two-sample test, this is +1 if the empirical distribution 
            function of `rvs` exceeds the empirical distribution 
            function of `cdf` at `statistic_location`, otherwise -1. 
 
    See Also 
    -------- 
    ks_1samp, ks_2samp 
 
    Notes 
    ----- 
    There are three options for the null and corresponding alternative 
    hypothesis that can be selected using the `alternative` parameter. 
 
    - `two-sided`: The null hypothesis is that the two distributions are 
      identical, F(x)=G(x) for all x; the alternative is that they are not 
      identical. 
 
    - `less`: The null hypothesis is that F(x) &gt;= G(x) for all x; the 
      alternative is that F(x) &lt; G(x) for at least one x. 
 
    - `greater`: The null hypothesis is that F(x) &lt;= G(x) for all x; the 
      alternative is that F(x) &gt; G(x) for at least one x. 
 
    Note that the alternative hypotheses describe the *CDFs* of the 
    underlying distributions, not the observed values. For example, 
    suppose x1 ~ F and x2 ~ G. If F(x) &gt; G(x) for all x, the values in 
    x1 tend to be less than those in x2. 
 
 
    Examples 
    -------- 
    Suppose we wish to test the null hypothesis that a sample is distributed 
    according to the standard normal. 
    We choose a confidence level of 95%; that is, we will reject the null 
    hypothesis in favor of the alternative if the p-value is less than 0.05. 
 
    When testing uniformly distributed data, we would expect the 
    null hypothesis to be rejected. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; stats.kstest(stats.uniform.rvs(size=100, random_state=rng), 
    ...              stats.norm.cdf) 
    KstestResult(statistic=0.5001899973268688, pvalue=1.1616392184763533e-23) 
 
    Indeed, the p-value is lower than our threshold of 0.05, so we reject the 
    null hypothesis in favor of the default &quot;two-sided&quot; alternative: the data 
    are *not* distributed according to the standard normal. 
 
    When testing random variates from the standard normal distribution, we 
    expect the data to be consistent with the null hypothesis most of the time. 
 
    &gt;&gt;&gt; x = stats.norm.rvs(size=100, random_state=rng) 
    &gt;&gt;&gt; stats.kstest(x, stats.norm.cdf) 
    KstestResult(statistic=0.05345882212970396, pvalue=0.9227159037744717) 
 
    As expected, the p-value of 0.92 is not below our threshold of 0.05, so 
    we cannot reject the null hypothesis. 
 
    Suppose, however, that the random variates are distributed according to 
    a normal distribution that is shifted toward greater values. In this case, 
    the cumulative density function (CDF) of the underlying distribution tends 
    to be *less* than the CDF of the standard normal. Therefore, we would 
    expect the null hypothesis to be rejected with ``alternative='less'``: 
 
    &gt;&gt;&gt; x = stats.norm.rvs(size=100, loc=0.5, random_state=rng) 
    &gt;&gt;&gt; stats.kstest(x, stats.norm.cdf, alternative='less') 
    KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743) 
 
    and indeed, with p-value smaller than our threshold, we reject the null 
    hypothesis in favor of the alternative. 
 
    For convenience, the previous test can be performed using the name of the 
    distribution as the second argument. 
 
    &gt;&gt;&gt; stats.kstest(x, &quot;norm&quot;, alternative='less') 
    KstestResult(statistic=0.17482387821055168, pvalue=0.001913921057766743) 
 
    The examples above have all been one-sample tests identical to those 
    performed by `ks_1samp`. Note that `kstest` can also perform two-sample 
    tests identical to those performed by `ks_2samp`. For example, when two 
    samples are drawn from the same distribution, we expect the data to be 
    consistent with the null hypothesis most of the time. 
 
    &gt;&gt;&gt; sample1 = stats.laplace.rvs(size=105, random_state=rng) 
    &gt;&gt;&gt; sample2 = stats.laplace.rvs(size=95, random_state=rng) 
    &gt;&gt;&gt; stats.kstest(sample1, sample2) 
    KstestResult(statistic=0.11779448621553884, pvalue=0.4494256912629795) 
 
    As expected, the p-value of 0.45 is not below our threshold of 0.05, so 
    we cannot reject the null hypothesis. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># to not break compatibility with existing code</span>
    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">'two_sided'</span><span class="s1">:</span>
        <span class="s1">alternative = </span><span class="s4">'two-sided'</span>
    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s4">'greater'</span><span class="s3">, </span><span class="s4">'less'</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unexpected alternative %s&quot; </span><span class="s1">% alternative)</span>
    <span class="s1">xvals</span><span class="s3">, </span><span class="s1">yvals</span><span class="s3">, </span><span class="s1">cdf = _parse_kstest_args(rvs</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">N)</span>
    <span class="s3">if </span><span class="s1">cdf:</span>
        <span class="s3">return </span><span class="s1">ks_1samp(xvals</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">, </span><span class="s1">args=args</span><span class="s3">, </span><span class="s1">alternative=alternative</span><span class="s3">,</span>
                        <span class="s1">method=method)</span>
    <span class="s3">return </span><span class="s1">ks_2samp(xvals</span><span class="s3">, </span><span class="s1">yvals</span><span class="s3">, </span><span class="s1">alternative=alternative</span><span class="s3">, </span><span class="s1">method=method)</span>


<span class="s3">def </span><span class="s1">tiecorrect(rankvals):</span>
    <span class="s2">&quot;&quot;&quot;Tie correction factor for Mann-Whitney U and Kruskal-Wallis H tests. 
 
    Parameters 
    ---------- 
    rankvals : array_like 
        A 1-D sequence of ranks.  Typically this will be the array 
        returned by `~scipy.stats.rankdata`. 
 
    Returns 
    ------- 
    factor : float 
        Correction factor for U or H. 
 
    See Also 
    -------- 
    rankdata : Assign ranks to the data 
    mannwhitneyu : Mann-Whitney rank test 
    kruskal : Kruskal-Wallis H test 
 
    References 
    ---------- 
    .. [1] Siegel, S. (1956) Nonparametric Statistics for the Behavioral 
           Sciences.  New York: McGraw-Hill. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import tiecorrect, rankdata 
    &gt;&gt;&gt; tiecorrect([1, 2.5, 2.5, 4]) 
    0.9 
    &gt;&gt;&gt; ranks = rankdata([1, 3, 2, 4, 5, 7, 2, 8, 4]) 
    &gt;&gt;&gt; ranks 
    array([ 1. ,  4. ,  2.5,  5.5,  7. ,  8. ,  2.5,  9. ,  5.5]) 
    &gt;&gt;&gt; tiecorrect(ranks) 
    0.9833333333333333 
 
    &quot;&quot;&quot;</span>
    <span class="s1">arr = np.sort(rankvals)</span>
    <span class="s1">idx = np.nonzero(np.r_[</span><span class="s3">True, </span><span class="s1">arr[</span><span class="s5">1</span><span class="s1">:] != arr[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, True</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">cnt = np.diff(idx).astype(np.float64)</span>

    <span class="s1">size = np.float64(arr.size)</span>
    <span class="s3">return </span><span class="s5">1.0 </span><span class="s3">if </span><span class="s1">size &lt; </span><span class="s5">2 </span><span class="s3">else </span><span class="s5">1.0 </span><span class="s1">- (cnt**</span><span class="s5">3 </span><span class="s1">- cnt).sum() / (size**</span><span class="s5">3 </span><span class="s1">- size)</span>


<span class="s1">RanksumsResult = namedtuple(</span><span class="s4">'RanksumsResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s1">@_axis_nan_policy_factory(RanksumsResult</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s5">2</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">ranksums(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'two-sided'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the Wilcoxon rank-sum statistic for two samples. 
 
    The Wilcoxon rank-sum test tests the null hypothesis that two sets 
    of measurements are drawn from the same distribution.  The alternative 
    hypothesis is that values in one sample are more likely to be 
    larger than the values in the other sample. 
 
    This test should be used to compare two samples from continuous 
    distributions.  It does not handle ties between measurements 
    in x and y.  For tie-handling and an optional continuity correction 
    see `scipy.stats.mannwhitneyu`. 
 
    Parameters 
    ---------- 
    x,y : array_like 
        The data from the two samples. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        The following options are available: 
 
        * 'two-sided': one of the distributions (underlying `x` or `y`) is 
          stochastically greater than the other. 
        * 'less': the distribution underlying `x` is stochastically less 
          than the distribution underlying `y`. 
        * 'greater': the distribution underlying `x` is stochastically greater 
          than the distribution underlying `y`. 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    statistic : float 
        The test statistic under the large-sample approximation that the 
        rank sum statistic is normally distributed. 
    pvalue : float 
        The p-value of the test. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Wilcoxon_rank-sum_test 
 
    Examples 
    -------- 
    We can test the hypothesis that two independent unequal-sized samples are 
    drawn from the same distribution with computing the Wilcoxon rank-sum 
    statistic. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import ranksums 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; sample1 = rng.uniform(-1, 1, 200) 
    &gt;&gt;&gt; sample2 = rng.uniform(-0.5, 1.5, 300) # a shifted distribution 
    &gt;&gt;&gt; ranksums(sample1, sample2) 
    RanksumsResult(statistic=-7.887059, pvalue=3.09390448e-15)  # may vary 
    &gt;&gt;&gt; ranksums(sample1, sample2, alternative='less') 
    RanksumsResult(statistic=-7.750585297581713, pvalue=4.573497606342543e-15) # may vary 
    &gt;&gt;&gt; ranksums(sample1, sample2, alternative='greater') 
    RanksumsResult(statistic=-7.750585297581713, pvalue=0.9999999999999954) # may vary 
 
    The p-value of less than ``0.05`` indicates that this test rejects the 
    hypothesis at the 5% significance level. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">y = map(np.asarray</span><span class="s3">, </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y))</span>
    <span class="s1">n1 = len(x)</span>
    <span class="s1">n2 = len(y)</span>
    <span class="s1">alldata = np.concatenate((x</span><span class="s3">, </span><span class="s1">y))</span>
    <span class="s1">ranked = rankdata(alldata)</span>
    <span class="s1">x = ranked[:n1]</span>
    <span class="s1">s = np.sum(x</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">expected = n1 * (n1+n2+</span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2.0</span>
    <span class="s1">z = (s - expected) / np.sqrt(n1*n2*(n1+n2+</span><span class="s5">1</span><span class="s1">)/</span><span class="s5">12.0</span><span class="s1">)</span>
    <span class="s1">z</span><span class="s3">, </span><span class="s1">prob = _normtest_finish(z</span><span class="s3">, </span><span class="s1">alternative)</span>

    <span class="s3">return </span><span class="s1">RanksumsResult(z</span><span class="s3">, </span><span class="s1">prob)</span>


<span class="s1">KruskalResult = namedtuple(</span><span class="s4">'KruskalResult'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s1">@_axis_nan_policy_factory(KruskalResult</span><span class="s3">, </span><span class="s1">n_samples=</span><span class="s3">None</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">kruskal(*samples</span><span class="s3">, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the Kruskal-Wallis H-test for independent samples. 
 
    The Kruskal-Wallis H-test tests the null hypothesis that the population 
    median of all of the groups are equal.  It is a non-parametric version of 
    ANOVA.  The test works on 2 or more independent samples, which may have 
    different sizes.  Note that rejecting the null hypothesis does not 
    indicate which of the groups differs.  Post hoc comparisons between 
    groups are required to determine which groups are different. 
 
    Parameters 
    ---------- 
    sample1, sample2, ... : array_like 
       Two or more arrays with the sample measurements can be given as 
       arguments. Samples must be one-dimensional. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    statistic : float 
       The Kruskal-Wallis H statistic, corrected for ties. 
    pvalue : float 
       The p-value for the test using the assumption that H has a chi 
       square distribution. The p-value returned is the survival function of 
       the chi square distribution evaluated at H. 
 
    See Also 
    -------- 
    f_oneway : 1-way ANOVA. 
    mannwhitneyu : Mann-Whitney rank test on two samples. 
    friedmanchisquare : Friedman test for repeated measurements. 
 
    Notes 
    ----- 
    Due to the assumption that H has a chi square distribution, the number 
    of samples in each group must not be too small.  A typical rule is 
    that each sample must have at least 5 measurements. 
 
    References 
    ---------- 
    .. [1] W. H. Kruskal &amp; W. W. Wallis, &quot;Use of Ranks in 
       One-Criterion Variance Analysis&quot;, Journal of the American Statistical 
       Association, Vol. 47, Issue 260, pp. 583-621, 1952. 
    .. [2] https://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = [1, 3, 5, 7, 9] 
    &gt;&gt;&gt; y = [2, 4, 6, 8, 10] 
    &gt;&gt;&gt; stats.kruskal(x, y) 
    KruskalResult(statistic=0.2727272727272734, pvalue=0.6015081344405895) 
 
    &gt;&gt;&gt; x = [1, 1, 1] 
    &gt;&gt;&gt; y = [2, 2, 2] 
    &gt;&gt;&gt; z = [2, 2] 
    &gt;&gt;&gt; stats.kruskal(x, y, z) 
    KruskalResult(statistic=7.0, pvalue=0.0301973834223185) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">samples = list(map(np.asarray</span><span class="s3">, </span><span class="s1">samples))</span>

    <span class="s1">num_groups = len(samples)</span>
    <span class="s3">if </span><span class="s1">num_groups &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Need at least two groups in stats.kruskal()&quot;</span><span class="s1">)</span>

    <span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples:</span>
        <span class="s3">if </span><span class="s1">sample.size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">NaN = _get_nan(*samples)</span>
            <span class="s3">return </span><span class="s1">KruskalResult(NaN</span><span class="s3">, </span><span class="s1">NaN)</span>
        <span class="s3">elif </span><span class="s1">sample.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Samples must be one-dimensional.&quot;</span><span class="s1">)</span>

    <span class="s1">n = np.asarray(list(map(len</span><span class="s3">, </span><span class="s1">samples)))</span>

    <span class="s3">if </span><span class="s1">nan_policy </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">'propagate'</span><span class="s3">, </span><span class="s4">'raise'</span><span class="s3">, </span><span class="s4">'omit'</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;nan_policy must be 'propagate', 'raise' or 'omit'&quot;</span><span class="s1">)</span>

    <span class="s1">contains_nan = </span><span class="s3">False</span>
    <span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples:</span>
        <span class="s1">cn = _contains_nan(sample</span><span class="s3">, </span><span class="s1">nan_policy)</span>
        <span class="s3">if </span><span class="s1">cn[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">contains_nan = </span><span class="s3">True</span>
            <span class="s3">break</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">sample </span><span class="s3">in </span><span class="s1">samples:</span>
            <span class="s1">sample = ma.masked_invalid(sample)</span>
        <span class="s3">return </span><span class="s1">mstats_basic.kruskal(*samples)</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">'propagate'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">KruskalResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>

    <span class="s1">alldata = np.concatenate(samples)</span>
    <span class="s1">ranked = rankdata(alldata)</span>
    <span class="s1">ties = tiecorrect(ranked)</span>
    <span class="s3">if </span><span class="s1">ties == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'All numbers are identical in kruskal'</span><span class="s1">)</span>

    <span class="s0"># Compute sum^2/n for each group and sum</span>
    <span class="s1">j = np.insert(np.cumsum(n)</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">ssbn = </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(num_groups):</span>
        <span class="s1">ssbn += _square_of_sums(ranked[j[i]:j[i+</span><span class="s5">1</span><span class="s1">]]) / n[i]</span>

    <span class="s1">totaln = np.sum(n</span><span class="s3">, </span><span class="s1">dtype=float)</span>
    <span class="s1">h = </span><span class="s5">12.0 </span><span class="s1">/ (totaln * (totaln + </span><span class="s5">1</span><span class="s1">)) * ssbn - </span><span class="s5">3 </span><span class="s1">* (totaln + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">df = num_groups - </span><span class="s5">1</span>
    <span class="s1">h /= ties</span>

    <span class="s3">return </span><span class="s1">KruskalResult(h</span><span class="s3">, </span><span class="s1">distributions.chi2.sf(h</span><span class="s3">, </span><span class="s1">df))</span>


<span class="s1">FriedmanchisquareResult = namedtuple(</span><span class="s4">'FriedmanchisquareResult'</span><span class="s3">,</span>
                                     <span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">friedmanchisquare(*samples):</span>
    <span class="s2">&quot;&quot;&quot;Compute the Friedman test for repeated samples. 
 
    The Friedman test tests the null hypothesis that repeated samples of 
    the same individuals have the same distribution.  It is often used 
    to test for consistency among samples obtained in different ways. 
    For example, if two sampling techniques are used on the same set of 
    individuals, the Friedman test can be used to determine if the two 
    sampling techniques are consistent. 
 
    Parameters 
    ---------- 
    sample1, sample2, sample3... : array_like 
        Arrays of observations.  All of the arrays must have the same number 
        of elements.  At least three samples must be given. 
 
    Returns 
    ------- 
    statistic : float 
        The test statistic, correcting for ties. 
    pvalue : float 
        The associated p-value assuming that the test statistic has a chi 
        squared distribution. 
 
    Notes 
    ----- 
    Due to the assumption that the test statistic has a chi squared 
    distribution, the p-value is only reliable for n &gt; 10 and more than 
    6 repeated samples. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Friedman_test 
    .. [2] P. Sprent and N.C. Smeeton, &quot;Applied Nonparametric Statistical 
           Methods, Third Edition&quot;. Chapter 6, Section 6.3.2. 
 
    Examples 
    -------- 
    In [2]_, the pulse rate (per minute) of a group of seven students was 
    measured before exercise, immediately after exercise and 5 minutes 
    after exercise. Is there evidence to suggest that the pulse rates on 
    these three occasions are similar? 
 
    We begin by formulating a null hypothesis :math:`H_0`: 
 
        The pulse rates are identical on these three occasions. 
 
    Let's assess the plausibility of this hypothesis with a Friedman test. 
 
    &gt;&gt;&gt; from scipy.stats import friedmanchisquare 
    &gt;&gt;&gt; before = [72, 96, 88, 92, 74, 76, 82] 
    &gt;&gt;&gt; immediately_after = [120, 120, 132, 120, 101, 96, 112] 
    &gt;&gt;&gt; five_min_after = [76, 95, 104, 96, 84, 72, 76] 
    &gt;&gt;&gt; res = friedmanchisquare(before, immediately_after, five_min_after) 
    &gt;&gt;&gt; res.statistic 
    10.57142857142857 
    &gt;&gt;&gt; res.pvalue 
    0.005063414171757498 
 
    Using a significance level of 5%, we would reject the null hypothesis in 
    favor of the alternative hypothesis: &quot;the pulse rates are different on 
    these three occasions&quot;. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">k = len(samples)</span>
    <span class="s3">if </span><span class="s1">k &lt; </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'At least 3 sets of samples must be given '</span>
                         <span class="s4">'for Friedman test, got {}.'</span><span class="s1">.format(k))</span>

    <span class="s1">n = len(samples[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">k):</span>
        <span class="s3">if </span><span class="s1">len(samples[i]) != n:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Unequal N in friedmanchisquare.  Aborting.'</span><span class="s1">)</span>

    <span class="s0"># Rank data</span>
    <span class="s1">data = np.vstack(samples).T</span>
    <span class="s1">data = data.astype(float)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(data)):</span>
        <span class="s1">data[i] = rankdata(data[i])</span>

    <span class="s0"># Handle ties</span>
    <span class="s1">ties = </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">data:</span>
        <span class="s1">replist</span><span class="s3">, </span><span class="s1">repnum = find_repeats(array(d))</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">repnum:</span>
            <span class="s1">ties += t * (t*t - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">c = </span><span class="s5">1 </span><span class="s1">- ties / (k*(k*k - </span><span class="s5">1</span><span class="s1">)*n)</span>

    <span class="s1">ssbn = np.sum(data.sum(axis=</span><span class="s5">0</span><span class="s1">)**</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">chisq = (</span><span class="s5">12.0 </span><span class="s1">/ (k*n*(k+</span><span class="s5">1</span><span class="s1">)) * ssbn - </span><span class="s5">3</span><span class="s1">*n*(k+</span><span class="s5">1</span><span class="s1">)) / c</span>

    <span class="s3">return </span><span class="s1">FriedmanchisquareResult(chisq</span><span class="s3">, </span><span class="s1">distributions.chi2.sf(chisq</span><span class="s3">, </span><span class="s1">k - </span><span class="s5">1</span><span class="s1">))</span>


<span class="s1">BrunnerMunzelResult = namedtuple(</span><span class="s4">'BrunnerMunzelResult'</span><span class="s3">,</span>
                                 <span class="s1">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">brunnermunzel(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s3">, </span><span class="s1">distribution=</span><span class="s4">&quot;t&quot;</span><span class="s3">,</span>
                  <span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Compute the Brunner-Munzel test on samples x and y. 
 
    The Brunner-Munzel test is a nonparametric test of the null hypothesis that 
    when values are taken one by one from each group, the probabilities of 
    getting large values in both groups are equal. 
    Unlike the Wilcoxon-Mann-Whitney's U test, this does not require the 
    assumption of equivariance of two groups. Note that this does not assume 
    the distributions are same. This test works on two independent samples, 
    which may have different sizes. 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Array of samples, should be one-dimensional. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
          * 'two-sided' 
          * 'less': one-sided 
          * 'greater': one-sided 
    distribution : {'t', 'normal'}, optional 
        Defines how to get the p-value. 
        The following options are available (default is 't'): 
 
          * 't': get the p-value by t-distribution 
          * 'normal': get the p-value by standard normal distribution. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': returns nan 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Returns 
    ------- 
    statistic : float 
        The Brunner-Munzer W statistic. 
    pvalue : float 
        p-value assuming an t distribution. One-sided or 
        two-sided, depending on the choice of `alternative` and `distribution`. 
 
    See Also 
    -------- 
    mannwhitneyu : Mann-Whitney rank test on two samples. 
 
    Notes 
    ----- 
    Brunner and Munzel recommended to estimate the p-value by t-distribution 
    when the size of data is 50 or less. If the size is lower than 10, it would 
    be better to use permuted Brunner Munzel test (see [2]_). 
 
    References 
    ---------- 
    .. [1] Brunner, E. and Munzel, U. &quot;The nonparametric Benhrens-Fisher 
           problem: Asymptotic theory and a small-sample approximation&quot;. 
           Biometrical Journal. Vol. 42(2000): 17-25. 
    .. [2] Neubert, K. and Brunner, E. &quot;A studentized permutation test for the 
           non-parametric Behrens-Fisher problem&quot;. Computational Statistics and 
           Data Analysis. Vol. 51(2007): 5192-5204. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x1 = [1,2,1,1,1,1,1,1,1,1,2,4,1,1] 
    &gt;&gt;&gt; x2 = [3,3,4,3,1,2,3,1,1,5,4] 
    &gt;&gt;&gt; w, p_value = stats.brunnermunzel(x1, x2) 
    &gt;&gt;&gt; w 
    3.1374674823029505 
    &gt;&gt;&gt; p_value 
    0.0057862086661515377 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.asarray(x)</span>
    <span class="s1">y = np.asarray(y)</span>

    <span class="s0"># check both x and y</span>
    <span class="s1">cnx</span><span class="s3">, </span><span class="s1">npx = _contains_nan(x</span><span class="s3">, </span><span class="s1">nan_policy)</span>
    <span class="s1">cny</span><span class="s3">, </span><span class="s1">npy = _contains_nan(y</span><span class="s3">, </span><span class="s1">nan_policy)</span>
    <span class="s1">contains_nan = cnx </span><span class="s3">or </span><span class="s1">cny</span>
    <span class="s3">if </span><span class="s1">npx == </span><span class="s4">&quot;omit&quot; </span><span class="s3">or </span><span class="s1">npy == </span><span class="s4">&quot;omit&quot;</span><span class="s1">:</span>
        <span class="s1">nan_policy = </span><span class="s4">&quot;omit&quot;</span>

    <span class="s3">if </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">&quot;propagate&quot;</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">BrunnerMunzelResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
    <span class="s3">elif </span><span class="s1">contains_nan </span><span class="s3">and </span><span class="s1">nan_policy == </span><span class="s4">&quot;omit&quot;</span><span class="s1">:</span>
        <span class="s1">x = ma.masked_invalid(x)</span>
        <span class="s1">y = ma.masked_invalid(y)</span>
        <span class="s3">return </span><span class="s1">mstats_basic.brunnermunzel(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">, </span><span class="s1">distribution)</span>

    <span class="s1">nx = len(x)</span>
    <span class="s1">ny = len(y)</span>
    <span class="s3">if </span><span class="s1">nx == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">ny == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">BrunnerMunzelResult(np.nan</span><span class="s3">, </span><span class="s1">np.nan)</span>
    <span class="s1">rankc = rankdata(np.concatenate((x</span><span class="s3">, </span><span class="s1">y)))</span>
    <span class="s1">rankcx = rankc[</span><span class="s5">0</span><span class="s1">:nx]</span>
    <span class="s1">rankcy = rankc[nx:nx+ny]</span>
    <span class="s1">rankcx_mean = np.mean(rankcx)</span>
    <span class="s1">rankcy_mean = np.mean(rankcy)</span>
    <span class="s1">rankx = rankdata(x)</span>
    <span class="s1">ranky = rankdata(y)</span>
    <span class="s1">rankx_mean = np.mean(rankx)</span>
    <span class="s1">ranky_mean = np.mean(ranky)</span>

    <span class="s1">Sx = np.sum(np.power(rankcx - rankx - rankcx_mean + rankx_mean</span><span class="s3">, </span><span class="s5">2.0</span><span class="s1">))</span>
    <span class="s1">Sx /= nx - </span><span class="s5">1</span>
    <span class="s1">Sy = np.sum(np.power(rankcy - ranky - rankcy_mean + ranky_mean</span><span class="s3">, </span><span class="s5">2.0</span><span class="s1">))</span>
    <span class="s1">Sy /= ny - </span><span class="s5">1</span>

    <span class="s1">wbfn = nx * ny * (rankcy_mean - rankcx_mean)</span>
    <span class="s1">wbfn /= (nx + ny) * np.sqrt(nx * Sx + ny * Sy)</span>

    <span class="s3">if </span><span class="s1">distribution == </span><span class="s4">&quot;t&quot;</span><span class="s1">:</span>
        <span class="s1">df_numer = np.power(nx * Sx + ny * Sy</span><span class="s3">, </span><span class="s5">2.0</span><span class="s1">)</span>
        <span class="s1">df_denom = np.power(nx * Sx</span><span class="s3">, </span><span class="s5">2.0</span><span class="s1">) / (nx - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">df_denom += np.power(ny * Sy</span><span class="s3">, </span><span class="s5">2.0</span><span class="s1">) / (ny - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">df = df_numer / df_denom</span>

        <span class="s3">if </span><span class="s1">(df_numer == </span><span class="s5">0</span><span class="s1">) </span><span class="s3">and </span><span class="s1">(df_denom == </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s1">message = (</span><span class="s4">&quot;p-value cannot be estimated with `distribution='t' &quot;</span>
                       <span class="s4">&quot;because degrees of freedom parameter is undefined &quot;</span>
                       <span class="s4">&quot;(0/0). Try using `distribution='normal'&quot;</span><span class="s1">)</span>
            <span class="s1">warnings.warn(message</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>

        <span class="s1">p = distributions.t.cdf(wbfn</span><span class="s3">, </span><span class="s1">df)</span>
    <span class="s3">elif </span><span class="s1">distribution == </span><span class="s4">&quot;normal&quot;</span><span class="s1">:</span>
        <span class="s1">p = distributions.norm.cdf(wbfn)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;distribution should be 't' or 'normal'&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">alternative == </span><span class="s4">&quot;greater&quot;</span><span class="s1">:</span>
        <span class="s3">pass</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">&quot;less&quot;</span><span class="s1">:</span>
        <span class="s1">p = </span><span class="s5">1 </span><span class="s1">- p</span>
    <span class="s3">elif </span><span class="s1">alternative == </span><span class="s4">&quot;two-sided&quot;</span><span class="s1">:</span>
        <span class="s1">p = </span><span class="s5">2 </span><span class="s1">* np.min([p</span><span class="s3">, </span><span class="s5">1</span><span class="s1">-p])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;alternative should be 'less', 'greater' or 'two-sided'&quot;</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">BrunnerMunzelResult(wbfn</span><span class="s3">, </span><span class="s1">p)</span>


<span class="s3">def </span><span class="s1">combine_pvalues(pvalues</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'fisher'</span><span class="s3">, </span><span class="s1">weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Combine p-values from independent tests that bear upon the same hypothesis. 
 
    These methods are intended only for combining p-values from hypothesis 
    tests based upon continuous distributions. 
 
    Each method assumes that under the null hypothesis, the p-values are 
    sampled independently and uniformly from the interval [0, 1]. A test 
    statistic (different for each method) is computed and a combined 
    p-value is calculated based upon the distribution of this test statistic 
    under the null hypothesis. 
 
    Parameters 
    ---------- 
    pvalues : array_like, 1-D 
        Array of p-values assumed to come from independent tests based on 
        continuous distributions. 
    method : {'fisher', 'pearson', 'tippett', 'stouffer', 'mudholkar_george'} 
 
        Name of method to use to combine p-values. 
 
        The available methods are (see Notes for details): 
 
        * 'fisher': Fisher's method (Fisher's combined probability test) 
        * 'pearson': Pearson's method 
        * 'mudholkar_george': Mudholkar's and George's method 
        * 'tippett': Tippett's method 
        * 'stouffer': Stouffer's Z-score method 
    weights : array_like, 1-D, optional 
        Optional array of weights used only for Stouffer's Z-score method. 
 
    Returns 
    ------- 
    res : SignificanceResult 
        An object containing attributes: 
 
        statistic : float 
            The statistic calculated by the specified method. 
        pvalue : float 
            The combined p-value. 
 
    Notes 
    ----- 
    If this function is applied to tests with a discrete statistics such as 
    any rank test or contingency-table test, it will yield systematically 
    wrong results, e.g. Fisher's method will systematically overestimate the 
    p-value [1]_. This problem becomes less severe for large sample sizes 
    when the discrete distributions become approximately continuous. 
 
    The differences between the methods can be best illustrated by their 
    statistics and what aspects of a combination of p-values they emphasise 
    when considering significance [2]_. For example, methods emphasising large 
    p-values are more sensitive to strong false and true negatives; conversely 
    methods focussing on small p-values are sensitive to positives. 
 
    * The statistics of Fisher's method (also known as Fisher's combined 
      probability test) [3]_ is :math:`-2\\sum_i \\log(p_i)`, which is 
      equivalent (as a test statistics) to the product of individual p-values: 
      :math:`\\prod_i p_i`. Under the null hypothesis, this statistics follows 
      a :math:`\\chi^2` distribution. This method emphasises small p-values. 
    * Pearson's method uses :math:`-2\\sum_i\\log(1-p_i)`, which is equivalent 
      to :math:`\\prod_i \\frac{1}{1-p_i}` [2]_. 
      It thus emphasises large p-values. 
    * Mudholkar and George compromise between Fisher's and Pearson's method by 
      averaging their statistics [4]_. Their method emphasises extreme 
      p-values, both close to 1 and 0. 
    * Stouffer's method [5]_ uses Z-scores and the statistic: 
      :math:`\\sum_i \\Phi^{-1} (p_i)`, where :math:`\\Phi` is the CDF of the 
      standard normal distribution. The advantage of this method is that it is 
      straightforward to introduce weights, which can make Stouffer's method 
      more powerful than Fisher's method when the p-values are from studies 
      of different size [6]_ [7]_. 
    * Tippett's method uses the smallest p-value as a statistic. 
      (Mind that this minimum is not the combined p-value.) 
 
    Fisher's method may be extended to combine p-values from dependent tests 
    [8]_. Extensions such as Brown's method and Kost's method are not currently 
    implemented. 
 
    .. versionadded:: 0.15.0 
 
    References 
    ---------- 
    .. [1] Kincaid, W. M., &quot;The Combination of Tests Based on Discrete 
           Distributions.&quot; Journal of the American Statistical Association 57, 
           no. 297 (1962), 10-19. 
    .. [2] Heard, N. and Rubin-Delanchey, P. &quot;Choosing between methods of 
           combining p-values.&quot;  Biometrika 105.1 (2018): 239-246. 
    .. [3] https://en.wikipedia.org/wiki/Fisher%27s_method 
    .. [4] George, E. O., and G. S. Mudholkar. &quot;On the convolution of logistic 
           random variables.&quot; Metrika 30.1 (1983): 1-13. 
    .. [5] https://en.wikipedia.org/wiki/Fisher%27s_method#Relation_to_Stouffer.27s_Z-score_method 
    .. [6] Whitlock, M. C. &quot;Combining probability from independent tests: the 
           weighted Z-method is superior to Fisher's approach.&quot; Journal of 
           Evolutionary Biology 18, no. 5 (2005): 1368-1373. 
    .. [7] Zaykin, Dmitri V. &quot;Optimally weighted Z-test is a powerful method 
           for combining probabilities in meta-analysis.&quot; Journal of 
           Evolutionary Biology 24, no. 8 (2011): 1836-1841. 
    .. [8] https://en.wikipedia.org/wiki/Extensions_of_Fisher%27s_method 
 
    &quot;&quot;&quot;</span>
    <span class="s1">pvalues = np.asarray(pvalues)</span>
    <span class="s3">if </span><span class="s1">pvalues.ndim != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;pvalues is not 1-D&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">method == </span><span class="s4">'fisher'</span><span class="s1">:</span>
        <span class="s1">statistic = -</span><span class="s5">2 </span><span class="s1">* np.sum(np.log(pvalues))</span>
        <span class="s1">pval = distributions.chi2.sf(statistic</span><span class="s3">, </span><span class="s5">2 </span><span class="s1">* len(pvalues))</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s4">'pearson'</span><span class="s1">:</span>
        <span class="s1">statistic = </span><span class="s5">2 </span><span class="s1">* np.sum(np.log1p(-pvalues))</span>
        <span class="s1">pval = distributions.chi2.cdf(-statistic</span><span class="s3">, </span><span class="s5">2 </span><span class="s1">* len(pvalues))</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s4">'mudholkar_george'</span><span class="s1">:</span>
        <span class="s1">normalizing_factor = np.sqrt(</span><span class="s5">3</span><span class="s1">/len(pvalues))/np.pi</span>
        <span class="s1">statistic = -np.sum(np.log(pvalues)) + np.sum(np.log1p(-pvalues))</span>
        <span class="s1">nu = </span><span class="s5">5 </span><span class="s1">* len(pvalues) + </span><span class="s5">4</span>
        <span class="s1">approx_factor = np.sqrt(nu / (nu - </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">pval = distributions.t.sf(statistic * normalizing_factor</span>
                                  <span class="s1">* approx_factor</span><span class="s3">, </span><span class="s1">nu)</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s4">'tippett'</span><span class="s1">:</span>
        <span class="s1">statistic = np.min(pvalues)</span>
        <span class="s1">pval = distributions.beta.cdf(statistic</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">len(pvalues))</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s4">'stouffer'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">weights = np.ones_like(pvalues)</span>
        <span class="s3">elif </span><span class="s1">len(weights) != len(pvalues):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;pvalues and weights must be of the same size.&quot;</span><span class="s1">)</span>

        <span class="s1">weights = np.asarray(weights)</span>
        <span class="s3">if </span><span class="s1">weights.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;weights is not 1-D&quot;</span><span class="s1">)</span>

        <span class="s1">Zi = distributions.norm.isf(pvalues)</span>
        <span class="s1">statistic = np.dot(weights</span><span class="s3">, </span><span class="s1">Zi) / np.linalg.norm(weights)</span>
        <span class="s1">pval = distributions.norm.sf(statistic)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">f&quot;Invalid method </span><span class="s3">{</span><span class="s1">method</span><span class="s3">!r}</span><span class="s4">. Valid methods are 'fisher', &quot;</span>
            <span class="s4">&quot;'pearson', 'mudholkar_george', 'tippett', and 'stouffer'&quot;</span>
        <span class="s1">)</span>

    <span class="s3">return </span><span class="s1">SignificanceResult(statistic</span><span class="s3">, </span><span class="s1">pval)</span>


<span class="s0">#####################################</span>
<span class="s0">#       STATISTICAL DISTANCES       #</span>
<span class="s0">#####################################</span>


<span class="s3">def </span><span class="s1">wasserstein_distance(u_values</span><span class="s3">, </span><span class="s1">v_values</span><span class="s3">, </span><span class="s1">u_weights=</span><span class="s3">None, </span><span class="s1">v_weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot; 
    Compute the first Wasserstein distance between two 1D distributions. 
 
    This distance is also known as the earth mover's distance, since it can be 
    seen as the minimum amount of &quot;work&quot; required to transform :math:`u` into 
    :math:`v`, where &quot;work&quot; is measured as the amount of distribution weight 
    that must be moved, multiplied by the distance it has to be moved. 
 
    .. versionadded:: 1.0.0 
 
    Parameters 
    ---------- 
    u_values, v_values : array_like 
        Values observed in the (empirical) distribution. 
    u_weights, v_weights : array_like, optional 
        Weight for each value. If unspecified, each value is assigned the same 
        weight. 
        `u_weights` (resp. `v_weights`) must have the same length as 
        `u_values` (resp. `v_values`). If the weight sum differs from 1, it 
        must still be positive and finite so that the weights can be normalized 
        to sum to 1. 
 
    Returns 
    ------- 
    distance : float 
        The computed distance between the distributions. 
 
    Notes 
    ----- 
    The first Wasserstein distance between the distributions :math:`u` and 
    :math:`v` is: 
 
    .. math:: 
 
        l_1 (u, v) = \inf_{\pi \in \Gamma (u, v)} \int_{\mathbb{R} \times 
        \mathbb{R}} |x-y| \mathrm{d} \pi (x, y) 
 
    where :math:`\Gamma (u, v)` is the set of (probability) distributions on 
    :math:`\mathbb{R} \times \mathbb{R}` whose marginals are :math:`u` and 
    :math:`v` on the first and second factors respectively. 
 
    If :math:`U` and :math:`V` are the respective CDFs of :math:`u` and 
    :math:`v`, this distance also equals to: 
 
    .. math:: 
 
        l_1(u, v) = \int_{-\infty}^{+\infty} |U-V| 
 
    See [2]_ for a proof of the equivalence of both definitions. 
 
    The input distributions can be empirical, therefore coming from samples 
    whose values are effectively inputs of the function, or they can be seen as 
    generalized functions, in which case they are weighted sums of Dirac delta 
    functions located at the specified values. 
 
    References 
    ---------- 
    .. [1] &quot;Wasserstein metric&quot;, https://en.wikipedia.org/wiki/Wasserstein_metric 
    .. [2] Ramdas, Garcia, Cuturi &quot;On Wasserstein Two Sample Testing and Related 
           Families of Nonparametric Tests&quot; (2015). :arXiv:`1509.02237`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import wasserstein_distance 
    &gt;&gt;&gt; wasserstein_distance([0, 1, 3], [5, 6, 8]) 
    5.0 
    &gt;&gt;&gt; wasserstein_distance([0, 1], [0, 1], [3, 1], [2, 2]) 
    0.25 
    &gt;&gt;&gt; wasserstein_distance([3.4, 3.9, 7.5, 7.8], [4.5, 1.4], 
    ...                      [1.4, 0.9, 3.1, 7.2], [3.2, 3.5]) 
    4.0781331438047861 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_cdf_distance(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">u_values</span><span class="s3">, </span><span class="s1">v_values</span><span class="s3">, </span><span class="s1">u_weights</span><span class="s3">, </span><span class="s1">v_weights)</span>


<span class="s3">def </span><span class="s1">energy_distance(u_values</span><span class="s3">, </span><span class="s1">v_values</span><span class="s3">, </span><span class="s1">u_weights=</span><span class="s3">None, </span><span class="s1">v_weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Compute the energy distance between two 1D distributions. 
 
    .. versionadded:: 1.0.0 
 
    Parameters 
    ---------- 
    u_values, v_values : array_like 
        Values observed in the (empirical) distribution. 
    u_weights, v_weights : array_like, optional 
        Weight for each value. If unspecified, each value is assigned the same 
        weight. 
        `u_weights` (resp. `v_weights`) must have the same length as 
        `u_values` (resp. `v_values`). If the weight sum differs from 1, it 
        must still be positive and finite so that the weights can be normalized 
        to sum to 1. 
 
    Returns 
    ------- 
    distance : float 
        The computed distance between the distributions. 
 
    Notes 
    ----- 
    The energy distance between two distributions :math:`u` and :math:`v`, whose 
    respective CDFs are :math:`U` and :math:`V`, equals to: 
 
    .. math:: 
 
        D(u, v) = \left( 2\mathbb E|X - Y| - \mathbb E|X - X'| - 
        \mathbb E|Y - Y'| \right)^{1/2} 
 
    where :math:`X` and :math:`X'` (resp. :math:`Y` and :math:`Y'`) are 
    independent random variables whose probability distribution is :math:`u` 
    (resp. :math:`v`). 
 
    Sometimes the square of this quantity is referred to as the &quot;energy 
    distance&quot; (e.g. in [2]_, [4]_), but as noted in [1]_ and [3]_, only the 
    definition above satisfies the axioms of a distance function (metric). 
 
    As shown in [2]_, for one-dimensional real-valued variables, the energy 
    distance is linked to the non-distribution-free version of the CramÃ©r-von 
    Mises distance: 
 
    .. math:: 
 
        D(u, v) = \sqrt{2} l_2(u, v) = \left( 2 \int_{-\infty}^{+\infty} (U-V)^2 
        \right)^{1/2} 
 
    Note that the common CramÃ©r-von Mises criterion uses the distribution-free 
    version of the distance. See [2]_ (section 2), for more details about both 
    versions of the distance. 
 
    The input distributions can be empirical, therefore coming from samples 
    whose values are effectively inputs of the function, or they can be seen as 
    generalized functions, in which case they are weighted sums of Dirac delta 
    functions located at the specified values. 
 
    References 
    ---------- 
    .. [1] Rizzo, Szekely &quot;Energy distance.&quot; Wiley Interdisciplinary Reviews: 
           Computational Statistics, 8(1):27-38 (2015). 
    .. [2] Szekely &quot;E-statistics: The energy of statistical samples.&quot; Bowling 
           Green State University, Department of Mathematics and Statistics, 
           Technical Report 02-16 (2002). 
    .. [3] &quot;Energy distance&quot;, https://en.wikipedia.org/wiki/Energy_distance 
    .. [4] Bellemare, Danihelka, Dabney, Mohamed, Lakshminarayanan, Hoyer, 
           Munos &quot;The Cramer Distance as a Solution to Biased Wasserstein 
           Gradients&quot; (2017). :arXiv:`1705.10743`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import energy_distance 
    &gt;&gt;&gt; energy_distance([0], [2]) 
    2.0000000000000004 
    &gt;&gt;&gt; energy_distance([0, 8], [0, 8], [3, 1], [2, 2]) 
    1.0000000000000002 
    &gt;&gt;&gt; energy_distance([0.7, 7.4, 2.4, 6.8], [1.4, 8. ], 
    ...                 [2.1, 4.2, 7.4, 8. ], [7.6, 8.8]) 
    0.88003340976158217 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">np.sqrt(</span><span class="s5">2</span><span class="s1">) * _cdf_distance(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">u_values</span><span class="s3">, </span><span class="s1">v_values</span><span class="s3">,</span>
                                      <span class="s1">u_weights</span><span class="s3">, </span><span class="s1">v_weights)</span>


<span class="s3">def </span><span class="s1">_cdf_distance(p</span><span class="s3">, </span><span class="s1">u_values</span><span class="s3">, </span><span class="s1">v_values</span><span class="s3">, </span><span class="s1">u_weights=</span><span class="s3">None, </span><span class="s1">v_weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot; 
    Compute, between two one-dimensional distributions :math:`u` and 
    :math:`v`, whose respective CDFs are :math:`U` and :math:`V`, the 
    statistical distance that is defined as: 
 
    .. math:: 
 
        l_p(u, v) = \left( \int_{-\infty}^{+\infty} |U-V|^p \right)^{1/p} 
 
    p is a positive parameter; p = 1 gives the Wasserstein distance, p = 2 
    gives the energy distance. 
 
    Parameters 
    ---------- 
    u_values, v_values : array_like 
        Values observed in the (empirical) distribution. 
    u_weights, v_weights : array_like, optional 
        Weight for each value. If unspecified, each value is assigned the same 
        weight. 
        `u_weights` (resp. `v_weights`) must have the same length as 
        `u_values` (resp. `v_values`). If the weight sum differs from 1, it 
        must still be positive and finite so that the weights can be normalized 
        to sum to 1. 
 
    Returns 
    ------- 
    distance : float 
        The computed distance between the distributions. 
 
    Notes 
    ----- 
    The input distributions can be empirical, therefore coming from samples 
    whose values are effectively inputs of the function, or they can be seen as 
    generalized functions, in which case they are weighted sums of Dirac delta 
    functions located at the specified values. 
 
    References 
    ---------- 
    .. [1] Bellemare, Danihelka, Dabney, Mohamed, Lakshminarayanan, Hoyer, 
           Munos &quot;The Cramer Distance as a Solution to Biased Wasserstein 
           Gradients&quot; (2017). :arXiv:`1705.10743`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">u_values</span><span class="s3">, </span><span class="s1">u_weights = _validate_distribution(u_values</span><span class="s3">, </span><span class="s1">u_weights)</span>
    <span class="s1">v_values</span><span class="s3">, </span><span class="s1">v_weights = _validate_distribution(v_values</span><span class="s3">, </span><span class="s1">v_weights)</span>

    <span class="s1">u_sorter = np.argsort(u_values)</span>
    <span class="s1">v_sorter = np.argsort(v_values)</span>

    <span class="s1">all_values = np.concatenate((u_values</span><span class="s3">, </span><span class="s1">v_values))</span>
    <span class="s1">all_values.sort(kind=</span><span class="s4">'mergesort'</span><span class="s1">)</span>

    <span class="s0"># Compute the differences between pairs of successive values of u and v.</span>
    <span class="s1">deltas = np.diff(all_values)</span>

    <span class="s0"># Get the respective positions of the values of u and v among the values of</span>
    <span class="s0"># both distributions.</span>
    <span class="s1">u_cdf_indices = u_values[u_sorter].searchsorted(all_values[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'right'</span><span class="s1">)</span>
    <span class="s1">v_cdf_indices = v_values[v_sorter].searchsorted(all_values[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'right'</span><span class="s1">)</span>

    <span class="s0"># Calculate the CDFs of u and v using their weights, if specified.</span>
    <span class="s3">if </span><span class="s1">u_weights </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">u_cdf = u_cdf_indices / u_values.size</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">u_sorted_cumweights = np.concatenate(([</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
                                              <span class="s1">np.cumsum(u_weights[u_sorter])))</span>
        <span class="s1">u_cdf = u_sorted_cumweights[u_cdf_indices] / u_sorted_cumweights[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">v_weights </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">v_cdf = v_cdf_indices / v_values.size</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">v_sorted_cumweights = np.concatenate(([</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
                                              <span class="s1">np.cumsum(v_weights[v_sorter])))</span>
        <span class="s1">v_cdf = v_sorted_cumweights[v_cdf_indices] / v_sorted_cumweights[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s0"># Compute the value of the integral based on the CDFs.</span>
    <span class="s0"># If p = 1 or p = 2, we avoid using np.power, which introduces an overhead</span>
    <span class="s0"># of about 15%.</span>
    <span class="s3">if </span><span class="s1">p == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.sum(np.multiply(np.abs(u_cdf - v_cdf)</span><span class="s3">, </span><span class="s1">deltas))</span>
    <span class="s3">if </span><span class="s1">p == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.sqrt(np.sum(np.multiply(np.square(u_cdf - v_cdf)</span><span class="s3">, </span><span class="s1">deltas)))</span>
    <span class="s3">return </span><span class="s1">np.power(np.sum(np.multiply(np.power(np.abs(u_cdf - v_cdf)</span><span class="s3">, </span><span class="s1">p)</span><span class="s3">,</span>
                                       <span class="s1">deltas))</span><span class="s3">, </span><span class="s5">1</span><span class="s1">/p)</span>


<span class="s3">def </span><span class="s1">_validate_distribution(values</span><span class="s3">, </span><span class="s1">weights):</span>
    <span class="s2">&quot;&quot;&quot; 
    Validate the values and weights from a distribution input of `cdf_distance` 
    and return them as ndarray objects. 
 
    Parameters 
    ---------- 
    values : array_like 
        Values observed in the (empirical) distribution. 
    weights : array_like 
        Weight for each value. 
 
    Returns 
    ------- 
    values : ndarray 
        Values as ndarray. 
    weights : ndarray 
        Weights as ndarray. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Validate the value array.</span>
    <span class="s1">values = np.asarray(values</span><span class="s3">, </span><span class="s1">dtype=float)</span>
    <span class="s3">if </span><span class="s1">len(values) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Distribution can't be empty.&quot;</span><span class="s1">)</span>

    <span class="s0"># Validate the weight array, if specified.</span>
    <span class="s3">if </span><span class="s1">weights </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">weights = np.asarray(weights</span><span class="s3">, </span><span class="s1">dtype=float)</span>
        <span class="s3">if </span><span class="s1">len(weights) != len(values):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Value and weight array-likes for the same '</span>
                             <span class="s4">'empirical distribution must be of the same size.'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">np.any(weights &lt; </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'All weights must be non-negative.'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s5">0 </span><span class="s1">&lt; np.sum(weights) &lt; np.inf:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Weight array-like sum must be positive and '</span>
                             <span class="s4">'finite. Set as None for an equal distribution of '</span>
                             <span class="s4">'weight.'</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">values</span><span class="s3">, </span><span class="s1">weights</span>

    <span class="s3">return </span><span class="s1">values</span><span class="s3">, None</span>


<span class="s0">#####################################</span>
<span class="s0">#         SUPPORT FUNCTIONS         #</span>
<span class="s0">#####################################</span>

<span class="s1">RepeatedResults = namedtuple(</span><span class="s4">'RepeatedResults'</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'values'</span><span class="s3">, </span><span class="s4">'counts'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">find_repeats(arr):</span>
    <span class="s2">&quot;&quot;&quot;Find repeats and repeat counts. 
 
    Parameters 
    ---------- 
    arr : array_like 
        Input array. This is cast to float64. 
 
    Returns 
    ------- 
    values : ndarray 
        The unique values from the (flattened) input that are repeated. 
 
    counts : ndarray 
        Number of times the corresponding 'value' is repeated. 
 
    Notes 
    ----- 
    In numpy &gt;= 1.9 `numpy.unique` provides similar functionality. The main 
    difference is that `find_repeats` only returns repeated values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; stats.find_repeats([2, 1, 2, 3, 2, 2, 5]) 
    RepeatedResults(values=array([2.]), counts=array([4])) 
 
    &gt;&gt;&gt; stats.find_repeats([[10, 20, 1, 2], [5, 5, 4, 4]]) 
    RepeatedResults(values=array([4.,  5.]), counts=array([2, 2])) 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Note: always copies.</span>
    <span class="s3">return </span><span class="s1">RepeatedResults(*_find_repeats(np.array(arr</span><span class="s3">, </span><span class="s1">dtype=np.float64)))</span>


<span class="s3">def </span><span class="s1">_sum_of_squares(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Square each element of the input array, and return the sum(s) of that. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    axis : int or None, optional 
        Axis along which to calculate. Default is 0. If None, compute over 
        the whole array `a`. 
 
    Returns 
    ------- 
    sum_of_squares : ndarray 
        The sum along the given axis for (a**2). 
 
    See Also 
    -------- 
    _square_of_sums : The square(s) of the sum(s) (the opposite of 
        `_sum_of_squares`). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s3">return </span><span class="s1">np.sum(a*a</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s3">def </span><span class="s1">_square_of_sums(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Sum elements of the input array, and return the square(s) of that sum. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    axis : int or None, optional 
        Axis along which to calculate. Default is 0. If None, compute over 
        the whole array `a`. 
 
    Returns 
    ------- 
    square_of_sums : float or ndarray 
        The square of the sum over `axis`. 
 
    See Also 
    -------- 
    _sum_of_squares : The sum of squares (the opposite of `square_of_sums`). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis = _chk_asarray(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">s = np.sum(a</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s3">if not </span><span class="s1">np.isscalar(s):</span>
        <span class="s3">return </span><span class="s1">s.astype(float) * s</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">float(s) * s</span>


<span class="s3">def </span><span class="s1">rankdata(a</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'average'</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None, </span><span class="s1">nan_policy=</span><span class="s4">'propagate'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Assign ranks to data, dealing with ties appropriately. 
 
    By default (``axis=None``), the data array is first flattened, and a flat 
    array of ranks is returned. Separately reshape the rank array to the 
    shape of the data array if desired (see Examples). 
 
    Ranks begin at 1.  The `method` argument controls how ranks are assigned 
    to equal values.  See [1]_ for further discussion of ranking methods. 
 
    Parameters 
    ---------- 
    a : array_like 
        The array of values to be ranked. 
    method : {'average', 'min', 'max', 'dense', 'ordinal'}, optional 
        The method used to assign ranks to tied elements. 
        The following methods are available (default is 'average'): 
 
          * 'average': The average of the ranks that would have been assigned to 
            all the tied values is assigned to each value. 
          * 'min': The minimum of the ranks that would have been assigned to all 
            the tied values is assigned to each value.  (This is also 
            referred to as &quot;competition&quot; ranking.) 
          * 'max': The maximum of the ranks that would have been assigned to all 
            the tied values is assigned to each value. 
          * 'dense': Like 'min', but the rank of the next highest element is 
            assigned the rank immediately after those assigned to the tied 
            elements. 
          * 'ordinal': All values are given a distinct rank, corresponding to 
            the order that the values occur in `a`. 
    axis : {None, int}, optional 
        Axis along which to perform the ranking. If ``None``, the data array 
        is first flattened. 
    nan_policy : {'propagate', 'omit', 'raise'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': propagates nans through the rank calculation 
          * 'omit': performs the calculations ignoring nan values 
          * 'raise': raises an error 
 
        .. note:: 
 
            When `nan_policy` is 'propagate', the output is an array of *all* 
            nans because ranks relative to nans in the input are undefined. 
            When `nan_policy` is 'omit', nans in `a` are ignored when ranking 
            the other values, and the corresponding locations of the output 
            are nan. 
 
        .. versionadded:: 1.10 
 
    Returns 
    ------- 
    ranks : ndarray 
         An array of size equal to the size of `a`, containing rank 
         scores. 
 
    References 
    ---------- 
    .. [1] &quot;Ranking&quot;, https://en.wikipedia.org/wiki/Ranking 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import rankdata 
    &gt;&gt;&gt; rankdata([0, 2, 3, 2]) 
    array([ 1. ,  2.5,  4. ,  2.5]) 
    &gt;&gt;&gt; rankdata([0, 2, 3, 2], method='min') 
    array([ 1,  2,  4,  2]) 
    &gt;&gt;&gt; rankdata([0, 2, 3, 2], method='max') 
    array([ 1,  3,  4,  3]) 
    &gt;&gt;&gt; rankdata([0, 2, 3, 2], method='dense') 
    array([ 1,  2,  3,  2]) 
    &gt;&gt;&gt; rankdata([0, 2, 3, 2], method='ordinal') 
    array([ 1,  2,  4,  3]) 
    &gt;&gt;&gt; rankdata([[0, 2], [3, 2]]).reshape(2,2) 
    array([[1. , 2.5], 
          [4. , 2.5]]) 
    &gt;&gt;&gt; rankdata([[0, 2, 2], [3, 2, 5]], axis=1) 
    array([[1. , 2.5, 2.5], 
           [2. , 1. , 3. ]]) 
    &gt;&gt;&gt; rankdata([0, 2, 3, np.nan, -2, np.nan], nan_policy=&quot;propagate&quot;) 
    array([nan, nan, nan, nan, nan, nan]) 
    &gt;&gt;&gt; rankdata([0, 2, 3, np.nan, -2, np.nan], nan_policy=&quot;omit&quot;) 
    array([ 2.,  3.,  4., nan,  1., nan]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">method </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">'average'</span><span class="s3">, </span><span class="s4">'min'</span><span class="s3">, </span><span class="s4">'max'</span><span class="s3">, </span><span class="s4">'dense'</span><span class="s3">, </span><span class="s4">'ordinal'</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f'unknown method &quot;</span><span class="s3">{</span><span class="s1">method</span><span class="s3">}</span><span class="s4">&quot;'</span><span class="s1">)</span>

    <span class="s1">a = np.asarray(a)</span>

    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0"># The return values of `normalize_axis_index` are ignored.  The</span>
            <span class="s0"># call validates `axis`, even though we won't use it.</span>
            <span class="s0"># use scipy._lib._util._normalize_axis_index when available</span>
            <span class="s1">np.core.multiarray.normalize_axis_index(axis</span><span class="s3">, </span><span class="s1">a.ndim)</span>
            <span class="s1">dt = np.float64 </span><span class="s3">if </span><span class="s1">method == </span><span class="s4">'average' </span><span class="s3">else </span><span class="s1">np.int_</span>
            <span class="s3">return </span><span class="s1">np.empty(a.shape</span><span class="s3">, </span><span class="s1">dtype=dt)</span>
        <span class="s3">return </span><span class="s1">np.apply_along_axis(rankdata</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">method</span><span class="s3">,</span>
                                   <span class="s1">nan_policy=nan_policy)</span>

    <span class="s1">arr = np.ravel(a)</span>
    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy = _contains_nan(arr</span><span class="s3">, </span><span class="s1">nan_policy)</span>
    <span class="s1">nan_indexes = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">contains_nan:</span>
        <span class="s3">if </span><span class="s1">nan_policy == </span><span class="s4">'omit'</span><span class="s1">:</span>
            <span class="s1">nan_indexes = np.isnan(arr)</span>
        <span class="s3">if </span><span class="s1">nan_policy == </span><span class="s4">'propagate'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.full_like(arr</span><span class="s3">, </span><span class="s1">np.nan)</span>

    <span class="s1">algo = </span><span class="s4">'mergesort' </span><span class="s3">if </span><span class="s1">method == </span><span class="s4">'ordinal' </span><span class="s3">else </span><span class="s4">'quicksort'</span>
    <span class="s1">sorter = np.argsort(arr</span><span class="s3">, </span><span class="s1">kind=algo)</span>

    <span class="s1">inv = np.empty(sorter.size</span><span class="s3">, </span><span class="s1">dtype=np.intp)</span>
    <span class="s1">inv[sorter] = np.arange(sorter.size</span><span class="s3">, </span><span class="s1">dtype=np.intp)</span>

    <span class="s3">if </span><span class="s1">method == </span><span class="s4">'ordinal'</span><span class="s1">:</span>
        <span class="s1">result = inv + </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">arr = arr[sorter]</span>
        <span class="s1">obs = np.r_[</span><span class="s3">True, </span><span class="s1">arr[</span><span class="s5">1</span><span class="s1">:] != arr[:-</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s1">dense = obs.cumsum()[inv]</span>

        <span class="s3">if </span><span class="s1">method == </span><span class="s4">'dense'</span><span class="s1">:</span>
            <span class="s1">result = dense</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># cumulative counts of each unique value</span>
            <span class="s1">count = np.r_[np.nonzero(obs)[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">len(obs)]</span>

            <span class="s3">if </span><span class="s1">method == </span><span class="s4">'max'</span><span class="s1">:</span>
                <span class="s1">result = count[dense]</span>

            <span class="s3">if </span><span class="s1">method == </span><span class="s4">'min'</span><span class="s1">:</span>
                <span class="s1">result = count[dense - </span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span>

            <span class="s3">if </span><span class="s1">method == </span><span class="s4">'average'</span><span class="s1">:</span>
                <span class="s1">result = </span><span class="s5">.5 </span><span class="s1">* (count[dense] + count[dense - </span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">nan_indexes </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">result = result.astype(</span><span class="s4">'float64'</span><span class="s1">)</span>
        <span class="s1">result[nan_indexes] = np.nan</span>

    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">expectile(a</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">weights=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Compute the expectile at the specified level. 
 
    Expectiles are a generalization of the expectation in the same way as 
    quantiles are a generalization of the median. The expectile at level 
    `alpha = 0.5` is the mean (average). See Notes for more details. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array containing numbers whose expectile is desired. 
    alpha : float, default: 0.5 
        The level of the expectile; e.g., `alpha=0.5` gives the mean. 
    weights : array_like, optional 
        An array of weights associated with the values in `a`. 
        The `weights` must be broadcastable to the same shape as `a`. 
        Default is None, which gives each value a weight of 1.0. 
        An integer valued weight element acts like repeating the corresponding 
        observation in `a` that many times. See Notes for more details. 
 
    Returns 
    ------- 
    expectile : ndarray 
        The empirical expectile at level `alpha`. 
 
    See Also 
    -------- 
    numpy.mean : Arithmetic average 
    numpy.quantile : Quantile 
 
    Notes 
    ----- 
    In general, the expectile at level :math:`\alpha` of a random variable 
    :math:`X` with cumulative distribution function (CDF) :math:`F` is given 
    by the unique solution :math:`t` of: 
 
    .. math:: 
 
        \alpha E((X - t)_+) = (1 - \alpha) E((t - X)_+) \,. 
 
    Here, :math:`(x)_+ = \max(0, x)` is the positive part of :math:`x`. 
    This equation can be equivalently written as: 
 
    .. math:: 
 
        \alpha \int_t^\infty (x - t)\mathrm{d}F(x) 
        = (1 - \alpha) \int_{-\infty}^t (t - x)\mathrm{d}F(x) \,. 
 
    The empirical expectile at level :math:`\alpha` (`alpha`) of a sample 
    :math:`a_i` (the array `a`) is defined by plugging in the empirical CDF of 
    `a`. Given sample or case weights :math:`w` (the array `weights`), it 
    reads :math:`F_a(x) = \frac{1}{\sum_i w_i} \sum_i w_i 1_{a_i \leq x}` 
    with indicator function :math:`1_{A}`. This leads to the definition of the 
    empirical expectile at level `alpha` as the unique solution :math:`t` of: 
 
    .. math:: 
 
        \alpha \sum_{i=1}^n w_i (a_i - t)_+ = 
            (1 - \alpha) \sum_{i=1}^n w_i (t - a_i)_+ \,. 
 
    For :math:`\alpha=0.5`, this simplifies to the weighted average. 
    Furthermore, the larger :math:`\alpha`, the larger the value of the 
    expectile. 
 
    As a final remark, the expectile at level :math:`\alpha` can also be 
    written as a minimization problem. One often used choice is 
 
    .. math:: 
 
        \operatorname{argmin}_t 
        E(\lvert 1_{t\geq X} - \alpha\rvert(t - X)^2) \,. 
 
    References 
    ---------- 
    .. [1] W. K. Newey and J. L. Powell (1987), &quot;Asymmetric Least Squares 
           Estimation and Testing,&quot; Econometrica, 55, 819-847. 
    .. [2] T. Gneiting (2009). &quot;Making and Evaluating Point Forecasts,&quot; 
           Journal of the American Statistical Association, 106, 746 - 762. 
           :doi:`10.48550/arXiv.0912.0902` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import expectile 
    &gt;&gt;&gt; a = [1, 4, 2, -1] 
    &gt;&gt;&gt; expectile(a, alpha=0.5) == np.mean(a) 
    True 
    &gt;&gt;&gt; expectile(a, alpha=0.2) 
    0.42857142857142855 
    &gt;&gt;&gt; expectile(a, alpha=0.8) 
    2.5714285714285716 
    &gt;&gt;&gt; weights = [1, 3, 1, 1] 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">alpha &lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">alpha &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;The expectile level alpha must be in the range [0, 1].&quot;</span>
        <span class="s1">)</span>
    <span class="s1">a = np.asarray(a)</span>

    <span class="s3">if </span><span class="s1">weights </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">weights = np.broadcast_to(weights</span><span class="s3">, </span><span class="s1">a.shape)</span>

    <span class="s0"># This is the empirical equivalent of Eq. (13) with identification</span>
    <span class="s0"># function from Table 9 (omitting a factor of 2) in [2] (their y is our</span>
    <span class="s0"># data a, their x is our t)</span>
    <span class="s3">def </span><span class="s1">first_order(t):</span>
        <span class="s3">return </span><span class="s1">np.average(np.abs((a &lt;= t) - alpha) * (t - a)</span><span class="s3">, </span><span class="s1">weights=weights)</span>

    <span class="s3">if </span><span class="s1">alpha &gt;= </span><span class="s5">0.5</span><span class="s1">:</span>
        <span class="s1">x0 = np.average(a</span><span class="s3">, </span><span class="s1">weights=weights)</span>
        <span class="s1">x1 = np.amax(a)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">x1 = np.average(a</span><span class="s3">, </span><span class="s1">weights=weights)</span>
        <span class="s1">x0 = np.amin(a)</span>

    <span class="s3">if </span><span class="s1">x0 == x1:</span>
        <span class="s0"># a has a single unique element</span>
        <span class="s3">return </span><span class="s1">x0</span>

    <span class="s0"># Note that the expectile is the unique solution, so no worries about</span>
    <span class="s0"># finding a wrong root.</span>
    <span class="s1">res = root_scalar(first_order</span><span class="s3">, </span><span class="s1">x0=x0</span><span class="s3">, </span><span class="s1">x1=x1)</span>
    <span class="s3">return </span><span class="s1">res.root</span>
</pre>
</body>
</html>