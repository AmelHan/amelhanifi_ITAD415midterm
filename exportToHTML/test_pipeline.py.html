<html>
<head>
<title>test_pipeline.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_pipeline.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test the pipeline module. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">mkdtemp</span>

<span class="s2">import </span><span class="s1">joblib</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">sparse</span>

<span class="s2">from </span><span class="s1">sklearn.base </span><span class="s2">import </span><span class="s1">BaseEstimator</span><span class="s2">, </span><span class="s1">TransformerMixin</span><span class="s2">, </span><span class="s1">clone</span><span class="s2">, </span><span class="s1">is_classifier</span>
<span class="s2">from </span><span class="s1">sklearn.cluster </span><span class="s2">import </span><span class="s1">KMeans</span>
<span class="s2">from </span><span class="s1">sklearn.datasets </span><span class="s2">import </span><span class="s1">load_iris</span>
<span class="s2">from </span><span class="s1">sklearn.decomposition </span><span class="s2">import </span><span class="s1">PCA</span><span class="s2">, </span><span class="s1">TruncatedSVD</span>
<span class="s2">from </span><span class="s1">sklearn.dummy </span><span class="s2">import </span><span class="s1">DummyRegressor</span>
<span class="s2">from </span><span class="s1">sklearn.ensemble </span><span class="s2">import </span><span class="s1">HistGradientBoostingClassifier</span>
<span class="s2">from </span><span class="s1">sklearn.exceptions </span><span class="s2">import </span><span class="s1">NotFittedError</span>
<span class="s2">from </span><span class="s1">sklearn.feature_extraction.text </span><span class="s2">import </span><span class="s1">CountVectorizer</span>
<span class="s2">from </span><span class="s1">sklearn.feature_selection </span><span class="s2">import </span><span class="s1">SelectKBest</span><span class="s2">, </span><span class="s1">f_classif</span>
<span class="s2">from </span><span class="s1">sklearn.impute </span><span class="s2">import </span><span class="s1">SimpleImputer</span>
<span class="s2">from </span><span class="s1">sklearn.linear_model </span><span class="s2">import </span><span class="s1">Lasso</span><span class="s2">, </span><span class="s1">LinearRegression</span><span class="s2">, </span><span class="s1">LogisticRegression</span>
<span class="s2">from </span><span class="s1">sklearn.metrics </span><span class="s2">import </span><span class="s1">accuracy_score</span><span class="s2">, </span><span class="s1">r2_score</span>
<span class="s2">from </span><span class="s1">sklearn.model_selection </span><span class="s2">import </span><span class="s1">train_test_split</span>
<span class="s2">from </span><span class="s1">sklearn.neighbors </span><span class="s2">import </span><span class="s1">LocalOutlierFactor</span>
<span class="s2">from </span><span class="s1">sklearn.pipeline </span><span class="s2">import </span><span class="s1">FeatureUnion</span><span class="s2">, </span><span class="s1">Pipeline</span><span class="s2">, </span><span class="s1">make_pipeline</span><span class="s2">, </span><span class="s1">make_union</span>
<span class="s2">from </span><span class="s1">sklearn.preprocessing </span><span class="s2">import </span><span class="s1">StandardScaler</span>
<span class="s2">from </span><span class="s1">sklearn.svm </span><span class="s2">import </span><span class="s1">SVC</span>
<span class="s2">from </span><span class="s1">sklearn.utils._testing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">MinimalClassifier</span><span class="s2">,</span>
    <span class="s1">MinimalRegressor</span><span class="s2">,</span>
    <span class="s1">MinimalTransformer</span><span class="s2">,</span>
    <span class="s1">assert_allclose</span><span class="s2">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s2">,</span>
    <span class="s1">assert_array_equal</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">sklearn.utils.validation </span><span class="s2">import </span><span class="s1">check_is_fitted</span>

<span class="s1">iris = load_iris()</span>

<span class="s1">JUNK_FOOD_DOCS = (</span>
    <span class="s3">&quot;the pizza pizza beer copyright&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;the pizza burger beer copyright&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;the the pizza beer beer copyright&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;the burger beer beer copyright&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;the coke burger coke copyright&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;the coke burger burger&quot;</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">class </span><span class="s1">NoFit:</span>
    <span class="s0">&quot;&quot;&quot;Small class to test parameter dispatching.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">a=</span><span class="s2">None, </span><span class="s1">b=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.b = b</span>


<span class="s2">class </span><span class="s1">NoTrans(NoFit):</span>
    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">get_params(self</span><span class="s2">, </span><span class="s1">deep=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">{</span><span class="s3">&quot;a&quot;</span><span class="s1">: self.a</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: self.b}</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">**params):</span>
        <span class="s1">self.a = params[</span><span class="s3">&quot;a&quot;</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">class </span><span class="s1">NoInvTransf(NoTrans):</span>
    <span class="s2">def </span><span class="s1">transform(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">return </span><span class="s1">X</span>


<span class="s2">class </span><span class="s1">Transf(NoInvTransf):</span>
    <span class="s2">def </span><span class="s1">transform(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">inverse_transform(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">return </span><span class="s1">X</span>


<span class="s2">class </span><span class="s1">TransfFitParams(Transf):</span>
    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">**fit_params):</span>
        <span class="s1">self.fit_params = fit_params</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">class </span><span class="s1">Mult(BaseEstimator):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">mult=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">self.mult = mult</span>

    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">return </span><span class="s1">np.asarray(X) * self.mult</span>

    <span class="s2">def </span><span class="s1">inverse_transform(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">return </span><span class="s1">np.asarray(X) / self.mult</span>

    <span class="s2">def </span><span class="s1">predict(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">return </span><span class="s1">(np.asarray(X) * self.mult).sum(axis=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">predict_proba = predict_log_proba = decision_function = predict</span>

    <span class="s2">def </span><span class="s1">score(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">np.sum(X)</span>


<span class="s2">class </span><span class="s1">FitParamT(BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;Mock classifier&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.successful = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">should_succeed=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.successful = should_succeed</span>

    <span class="s2">def </span><span class="s1">predict(self</span><span class="s2">, </span><span class="s1">X):</span>
        <span class="s2">return </span><span class="s1">self.successful</span>

    <span class="s2">def </span><span class="s1">fit_predict(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">should_succeed=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.fit(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">should_succeed=should_succeed)</span>
        <span class="s2">return </span><span class="s1">self.predict(X)</span>

    <span class="s2">def </span><span class="s1">score(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">sample_weight=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">X = X * sample_weight</span>
        <span class="s2">return </span><span class="s1">np.sum(X)</span>


<span class="s2">class </span><span class="s1">DummyTransf(Transf):</span>
    <span class="s0">&quot;&quot;&quot;Transformer which store the column means&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s1">self.means_ = np.mean(X</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s5"># store timestamp to figure out whether the result of 'fit' has been</span>
        <span class="s5"># cached or not</span>
        <span class="s1">self.timestamp_ = time.time()</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">class </span><span class="s1">DummyEstimatorParams(BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;Mock classifier that takes params on predict&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">predict(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">got_attribute=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.got_attribute = got_attribute</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">predict_proba(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">got_attribute=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.got_attribute = got_attribute</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">predict_log_proba(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">got_attribute=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.got_attribute = got_attribute</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">test_pipeline_invalid_parameters():</span>
    <span class="s5"># Test the various init parameters of the pipeline in fit</span>
    <span class="s5"># method</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">pipeline.fit([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Check that we can't fit pipelines with objects without fit</span>
    <span class="s5"># method</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;Last step of Pipeline should implement fit &quot;</span>
        <span class="s3">&quot;or be the string 'passthrough'&quot;</span>
        <span class="s3">&quot;.*NoFit.*&quot;</span>
    <span class="s1">)</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">NoFit())])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipeline.fit([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Smoke test with only an estimator</span>
    <span class="s1">clf = NoTrans()</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;svc&quot;</span><span class="s2">, </span><span class="s1">clf)])</span>
    <span class="s2">assert </span><span class="s1">pipe.get_params(deep=</span><span class="s2">True</span><span class="s1">) == dict(</span>
        <span class="s1">svc__a=</span><span class="s2">None, </span><span class="s1">svc__b=</span><span class="s2">None, </span><span class="s1">svc=clf</span><span class="s2">, </span><span class="s1">**pipe.get_params(deep=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s5"># Check that params are set</span>
    <span class="s1">pipe.set_params(svc__a=</span><span class="s4">0.1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">clf.a == </span><span class="s4">0.1</span>
    <span class="s2">assert </span><span class="s1">clf.b </span><span class="s2">is None</span>
    <span class="s5"># Smoke test the repr:</span>
    <span class="s1">repr(pipe)</span>

    <span class="s5"># Test with two objects</span>
    <span class="s1">clf = SVC()</span>
    <span class="s1">filter1 = SelectKBest(f_classif)</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;anova&quot;</span><span class="s2">, </span><span class="s1">filter1)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;svc&quot;</span><span class="s2">, </span><span class="s1">clf)])</span>

    <span class="s5"># Check that estimators are not cloned on pipeline construction</span>
    <span class="s2">assert </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;anova&quot;</span><span class="s1">] </span><span class="s2">is </span><span class="s1">filter1</span>
    <span class="s2">assert </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;svc&quot;</span><span class="s1">] </span><span class="s2">is </span><span class="s1">clf</span>

    <span class="s5"># Check that we can't fit with non-transformers on the way</span>
    <span class="s5"># Note that NoTrans implements fit, but not transform</span>
    <span class="s1">msg = </span><span class="s3">&quot;All intermediate steps should be transformers.*</span><span class="s2">\\</span><span class="s3">bNoTrans</span><span class="s2">\\</span><span class="s3">b.*&quot;</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;t&quot;</span><span class="s2">, </span><span class="s1">NoTrans())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;svc&quot;</span><span class="s2">, </span><span class="s1">clf)])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipeline.fit([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s5"># Check that params are set</span>
    <span class="s1">pipe.set_params(svc__C=</span><span class="s4">0.1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">clf.C == </span><span class="s4">0.1</span>
    <span class="s5"># Smoke test the repr:</span>
    <span class="s1">repr(pipe)</span>

    <span class="s5"># Check that params are not set when naming them wrong</span>
    <span class="s1">msg = re.escape(</span>
        <span class="s3">&quot;Invalid parameter 'C' for estimator SelectKBest(). Valid parameters are: ['k',&quot;</span>
        <span class="s3">&quot; 'score_func'].&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipe.set_params(anova__C=</span><span class="s4">0.1</span><span class="s1">)</span>

    <span class="s5"># Test clone</span>
    <span class="s1">pipe2 = clone(pipe)</span>
    <span class="s2">assert </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;svc&quot;</span><span class="s1">] </span><span class="s2">is not </span><span class="s1">pipe2.named_steps[</span><span class="s3">&quot;svc&quot;</span><span class="s1">]</span>

    <span class="s5"># Check that apart from estimators, the parameters are the same</span>
    <span class="s1">params = pipe.get_params(deep=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">params2 = pipe2.get_params(deep=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">pipe.get_params(deep=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">params.pop(x)</span>

    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">pipe2.get_params(deep=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">params2.pop(x)</span>

    <span class="s5"># Remove estimators that where copied</span>
    <span class="s1">params.pop(</span><span class="s3">&quot;svc&quot;</span><span class="s1">)</span>
    <span class="s1">params.pop(</span><span class="s3">&quot;anova&quot;</span><span class="s1">)</span>
    <span class="s1">params2.pop(</span><span class="s3">&quot;svc&quot;</span><span class="s1">)</span>
    <span class="s1">params2.pop(</span><span class="s3">&quot;anova&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">params == params2</span>


<span class="s2">def </span><span class="s1">test_pipeline_init_tuple():</span>
    <span class="s5"># Pipeline accepts steps as tuple</span>
    <span class="s1">X = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]])</span>
    <span class="s1">pipe = Pipeline(((</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">FitParamT())))</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">pipe.score(X)</span>

    <span class="s1">pipe.set_params(transf=</span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">pipe.score(X)</span>


<span class="s2">def </span><span class="s1">test_pipeline_methods_anova():</span>
    <span class="s5"># Test the various methods of the pipeline (anova).</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">y = iris.target</span>
    <span class="s5"># Test with Anova + LogisticRegression</span>
    <span class="s1">clf = LogisticRegression()</span>
    <span class="s1">filter1 = SelectKBest(f_classif</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;anova&quot;</span><span class="s2">, </span><span class="s1">filter1)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;logistic&quot;</span><span class="s2">, </span><span class="s1">clf)])</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">pipe.predict(X)</span>
    <span class="s1">pipe.predict_proba(X)</span>
    <span class="s1">pipe.predict_log_proba(X)</span>
    <span class="s1">pipe.score(X</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s2">def </span><span class="s1">test_pipeline_fit_params():</span>
    <span class="s5"># Test that the pipeline can take fit parameters</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">FitParamT())])</span>
    <span class="s1">pipe.fit(X=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">clf__should_succeed=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s5"># classifier should return True</span>
    <span class="s2">assert </span><span class="s1">pipe.predict(</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s5"># and transformer params should not be changed</span>
    <span class="s2">assert </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].a </span><span class="s2">is None</span>
    <span class="s2">assert </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].b </span><span class="s2">is None</span>
    <span class="s5"># invalid parameters should raise an error message</span>

    <span class="s1">msg = re.escape(</span><span class="s3">&quot;fit() got an unexpected keyword argument 'bad'&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipe.fit(</span><span class="s2">None, None, </span><span class="s1">clf__bad=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_pipeline_sample_weight_supported():</span>
    <span class="s5"># Pipeline should pass sample_weight</span>
    <span class="s1">X = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]])</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">FitParamT())])</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">pipe.score(X) == </span><span class="s4">3</span>
    <span class="s2">assert </span><span class="s1">pipe.score(X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">) == </span><span class="s4">3</span>
    <span class="s2">assert </span><span class="s1">pipe.score(X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">sample_weight=</span><span class="s2">None</span><span class="s1">) == </span><span class="s4">3</span>
    <span class="s2">assert </span><span class="s1">pipe.score(X</span><span class="s2">, </span><span class="s1">sample_weight=np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])) == </span><span class="s4">8</span>


<span class="s2">def </span><span class="s1">test_pipeline_sample_weight_unsupported():</span>
    <span class="s5"># When sample_weight is None it shouldn't be passed</span>
    <span class="s1">X = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]])</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">Mult())])</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">pipe.score(X) == </span><span class="s4">3</span>
    <span class="s2">assert </span><span class="s1">pipe.score(X</span><span class="s2">, </span><span class="s1">sample_weight=</span><span class="s2">None</span><span class="s1">) == </span><span class="s4">3</span>

    <span class="s1">msg = re.escape(</span><span class="s3">&quot;score() got an unexpected keyword argument 'sample_weight'&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipe.score(X</span><span class="s2">, </span><span class="s1">sample_weight=np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]))</span>


<span class="s2">def </span><span class="s1">test_pipeline_raise_set_params_error():</span>
    <span class="s5"># Test pipeline raises set params error message for nested models.</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;cls&quot;</span><span class="s2">, </span><span class="s1">LinearRegression())])</span>

    <span class="s5"># expected error message</span>
    <span class="s1">error_msg = re.escape(</span>
        <span class="s3">&quot;Invalid parameter 'fake' for estimator Pipeline(steps=[('cls',&quot;</span>
        <span class="s3">&quot; LinearRegression())]). Valid parameters are: ['memory', 'steps', 'verbose'].&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_msg):</span>
        <span class="s1">pipe.set_params(fake=</span><span class="s3">&quot;nope&quot;</span><span class="s1">)</span>

    <span class="s5"># invalid outer parameter name for compound parameter: the expected error message</span>
    <span class="s5"># is the same as above.</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_msg):</span>
        <span class="s1">pipe.set_params(fake__estimator=</span><span class="s3">&quot;nope&quot;</span><span class="s1">)</span>

    <span class="s5"># expected error message for invalid inner parameter</span>
    <span class="s1">error_msg = re.escape(</span>
        <span class="s3">&quot;Invalid parameter 'invalid_param' for estimator LinearRegression(). Valid&quot;</span>
        <span class="s3">&quot; parameters are: ['copy_X', 'fit_intercept', 'n_jobs', 'positive'].&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=error_msg):</span>
        <span class="s1">pipe.set_params(cls__invalid_param=</span><span class="s3">&quot;nope&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_pipeline_methods_pca_svm():</span>
    <span class="s5"># Test the various methods of the pipeline (pca + svm).</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">y = iris.target</span>
    <span class="s5"># Test with PCA + SVC</span>
    <span class="s1">clf = SVC(probability=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">pca = PCA(svd_solver=</span><span class="s3">&quot;full&quot;</span><span class="s2">, </span><span class="s1">n_components=</span><span class="s3">&quot;mle&quot;</span><span class="s2">, </span><span class="s1">whiten=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;svc&quot;</span><span class="s2">, </span><span class="s1">clf)])</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">pipe.predict(X)</span>
    <span class="s1">pipe.predict_proba(X)</span>
    <span class="s1">pipe.predict_log_proba(X)</span>
    <span class="s1">pipe.score(X</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s2">def </span><span class="s1">test_pipeline_score_samples_pca_lof():</span>
    <span class="s1">X = iris.data</span>
    <span class="s5"># Test that the score_samples method is implemented on a pipeline.</span>
    <span class="s5"># Test that the score_samples method on pipeline yields same results as</span>
    <span class="s5"># applying transform and score_samples steps separately.</span>
    <span class="s1">pca = PCA(svd_solver=</span><span class="s3">&quot;full&quot;</span><span class="s2">, </span><span class="s1">n_components=</span><span class="s3">&quot;mle&quot;</span><span class="s2">, </span><span class="s1">whiten=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">lof = LocalOutlierFactor(novelty=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;lof&quot;</span><span class="s2">, </span><span class="s1">lof)])</span>
    <span class="s1">pipe.fit(X)</span>
    <span class="s5"># Check the shapes</span>
    <span class="s2">assert </span><span class="s1">pipe.score_samples(X).shape == (X.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s5"># Check the values</span>
    <span class="s1">lof.fit(pca.fit_transform(X))</span>
    <span class="s1">assert_allclose(pipe.score_samples(X)</span><span class="s2">, </span><span class="s1">lof.score_samples(pca.transform(X)))</span>


<span class="s2">def </span><span class="s1">test_score_samples_on_pipeline_without_score_samples():</span>
    <span class="s1">X = np.array([[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]])</span>
    <span class="s1">y = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s5"># Test that a pipeline does not have score_samples method when the final</span>
    <span class="s5"># step of the pipeline does not have score_samples defined.</span>
    <span class="s1">pipe = make_pipeline(LogisticRegression())</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">AttributeError</span><span class="s2">,</span>
        <span class="s1">match=</span><span class="s3">&quot;'LogisticRegression' object has no attribute 'score_samples'&quot;</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">pipe.score_samples(X)</span>


<span class="s2">def </span><span class="s1">test_pipeline_methods_preprocessing_svm():</span>
    <span class="s5"># Test the various methods of the pipeline (preprocessing + svm).</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">y = iris.target</span>
    <span class="s1">n_samples = X.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">n_classes = len(np.unique(y))</span>
    <span class="s1">scaler = StandardScaler()</span>
    <span class="s1">pca = PCA(n_components=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">svd_solver=</span><span class="s3">&quot;randomized&quot;</span><span class="s2">, </span><span class="s1">whiten=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">clf = SVC(probability=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">decision_function_shape=</span><span class="s3">&quot;ovr&quot;</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">preprocessing </span><span class="s2">in </span><span class="s1">[scaler</span><span class="s2">, </span><span class="s1">pca]:</span>
        <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;preprocess&quot;</span><span class="s2">, </span><span class="s1">preprocessing)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;svc&quot;</span><span class="s2">, </span><span class="s1">clf)])</span>
        <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>

        <span class="s5"># check shapes of various prediction functions</span>
        <span class="s1">predict = pipe.predict(X)</span>
        <span class="s2">assert </span><span class="s1">predict.shape == (n_samples</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s1">proba = pipe.predict_proba(X)</span>
        <span class="s2">assert </span><span class="s1">proba.shape == (n_samples</span><span class="s2">, </span><span class="s1">n_classes)</span>

        <span class="s1">log_proba = pipe.predict_log_proba(X)</span>
        <span class="s2">assert </span><span class="s1">log_proba.shape == (n_samples</span><span class="s2">, </span><span class="s1">n_classes)</span>

        <span class="s1">decision_function = pipe.decision_function(X)</span>
        <span class="s2">assert </span><span class="s1">decision_function.shape == (n_samples</span><span class="s2">, </span><span class="s1">n_classes)</span>

        <span class="s1">pipe.score(X</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s2">def </span><span class="s1">test_fit_predict_on_pipeline():</span>
    <span class="s5"># test that the fit_predict method is implemented on a pipeline</span>
    <span class="s5"># test that the fit_predict on pipeline yields same results as applying</span>
    <span class="s5"># transform and clustering steps separately</span>
    <span class="s1">scaler = StandardScaler()</span>
    <span class="s1">km = KMeans(random_state=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n_init=</span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span>
    <span class="s5"># As pipeline doesn't clone estimators on construction,</span>
    <span class="s5"># it must have its own estimators</span>
    <span class="s1">scaler_for_pipeline = StandardScaler()</span>
    <span class="s1">km_for_pipeline = KMeans(random_state=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n_init=</span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span>

    <span class="s5"># first compute the transform and clustering step separately</span>
    <span class="s1">scaled = scaler.fit_transform(iris.data)</span>
    <span class="s1">separate_pred = km.fit_predict(scaled)</span>

    <span class="s5"># use a pipeline to do the transform and clustering in one step</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;scaler&quot;</span><span class="s2">, </span><span class="s1">scaler_for_pipeline)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Kmeans&quot;</span><span class="s2">, </span><span class="s1">km_for_pipeline)])</span>
    <span class="s1">pipeline_pred = pipe.fit_predict(iris.data)</span>

    <span class="s1">assert_array_almost_equal(pipeline_pred</span><span class="s2">, </span><span class="s1">separate_pred)</span>


<span class="s2">def </span><span class="s1">test_fit_predict_on_pipeline_without_fit_predict():</span>
    <span class="s5"># tests that a pipeline does not have fit_predict method when final</span>
    <span class="s5"># step of pipeline does not have fit_predict defined</span>
    <span class="s1">scaler = StandardScaler()</span>
    <span class="s1">pca = PCA(svd_solver=</span><span class="s3">&quot;full&quot;</span><span class="s1">)</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;scaler&quot;</span><span class="s2">, </span><span class="s1">scaler)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)])</span>

    <span class="s1">msg = </span><span class="s3">&quot;'PCA' object has no attribute 'fit_predict'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">getattr(pipe</span><span class="s2">, </span><span class="s3">&quot;fit_predict&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_fit_predict_with_intermediate_fit_params():</span>
    <span class="s5"># tests that Pipeline passes fit_params to intermediate steps</span>
    <span class="s5"># when fit_predict is invoked</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">TransfFitParams())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">FitParamT())])</span>
    <span class="s1">pipe.fit_predict(</span>
        <span class="s1">X=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">transf__should_get_this=</span><span class="s2">True, </span><span class="s1">clf__should_succeed=</span><span class="s2">True</span>
    <span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].fit_params[</span><span class="s3">&quot;should_get_this&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;clf&quot;</span><span class="s1">].successful</span>
    <span class="s2">assert </span><span class="s3">&quot;should_succeed&quot; </span><span class="s2">not in </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].fit_params</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;method_name&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;predict&quot;</span><span class="s2">, </span><span class="s3">&quot;predict_proba&quot;</span><span class="s2">, </span><span class="s3">&quot;predict_log_proba&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_predict_methods_with_predict_params(method_name):</span>
    <span class="s5"># tests that Pipeline passes predict_* to the final estimator</span>
    <span class="s5"># when predict_* is invoked</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">DummyEstimatorParams())])</span>
    <span class="s1">pipe.fit(</span><span class="s2">None, None</span><span class="s1">)</span>
    <span class="s1">method = getattr(pipe</span><span class="s2">, </span><span class="s1">method_name)</span>
    <span class="s1">method(X=</span><span class="s2">None, </span><span class="s1">got_attribute=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">pipe.named_steps[</span><span class="s3">&quot;clf&quot;</span><span class="s1">].got_attribute</span>


<span class="s2">def </span><span class="s1">test_feature_union():</span>
    <span class="s5"># basic sanity check for feature union</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">X -= X.mean(axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">y = iris.target</span>
    <span class="s1">svd = TruncatedSVD(n_components=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">select = SelectKBest(k=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">fs = FeatureUnion([(</span><span class="s3">&quot;svd&quot;</span><span class="s2">, </span><span class="s1">svd)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;select&quot;</span><span class="s2">, </span><span class="s1">select)])</span>
    <span class="s1">fs.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">X_transformed = fs.transform(X)</span>
    <span class="s2">assert </span><span class="s1">X_transformed.shape == (X.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>

    <span class="s5"># check if it does the expected thing</span>
    <span class="s1">assert_array_almost_equal(X_transformed[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">svd.fit_transform(X))</span>
    <span class="s1">assert_array_equal(X_transformed[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">select.fit_transform(X</span><span class="s2">, </span><span class="s1">y).ravel())</span>

    <span class="s5"># test if it also works for sparse input</span>
    <span class="s5"># We use a different svd object to control the random_state stream</span>
    <span class="s1">fs = FeatureUnion([(</span><span class="s3">&quot;svd&quot;</span><span class="s2">, </span><span class="s1">svd)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;select&quot;</span><span class="s2">, </span><span class="s1">select)])</span>
    <span class="s1">X_sp = sparse.csr_matrix(X)</span>
    <span class="s1">X_sp_transformed = fs.fit_transform(X_sp</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">assert_array_almost_equal(X_transformed</span><span class="s2">, </span><span class="s1">X_sp_transformed.toarray())</span>

    <span class="s5"># Test clone</span>
    <span class="s1">fs2 = clone(fs)</span>
    <span class="s2">assert </span><span class="s1">fs.transformer_list[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] </span><span class="s2">is not </span><span class="s1">fs2.transformer_list[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s5"># test setting parameters</span>
    <span class="s1">fs.set_params(select__k=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">fs.fit_transform(X</span><span class="s2">, </span><span class="s1">y).shape == (X.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>

    <span class="s5"># test it works with transformers missing fit_transform</span>
    <span class="s1">fs = FeatureUnion([(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;svd&quot;</span><span class="s2">, </span><span class="s1">svd)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;select&quot;</span><span class="s2">, </span><span class="s1">select)])</span>
    <span class="s1">X_transformed = fs.fit_transform(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">assert </span><span class="s1">X_transformed.shape == (X.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>

    <span class="s5"># test error if some elements do not support transform</span>
    <span class="s1">msg = </span><span class="s3">&quot;All estimators should implement fit and transform.*</span><span class="s2">\\</span><span class="s3">bNoTrans</span><span class="s2">\\</span><span class="s3">b&quot;</span>
    <span class="s1">fs = FeatureUnion([(</span><span class="s3">&quot;transform&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;no_transform&quot;</span><span class="s2">, </span><span class="s1">NoTrans())])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">fs.fit(X)</span>

    <span class="s5"># test that init accepts tuples</span>
    <span class="s1">fs = FeatureUnion(((</span><span class="s3">&quot;svd&quot;</span><span class="s2">, </span><span class="s1">svd)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;select&quot;</span><span class="s2">, </span><span class="s1">select)))</span>
    <span class="s1">fs.fit(X</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s2">def </span><span class="s1">test_feature_union_named_transformers():</span>
    <span class="s0">&quot;&quot;&quot;Check the behaviour of `named_transformers` attribute.&quot;&quot;&quot;</span>
    <span class="s1">transf = Transf()</span>
    <span class="s1">noinvtransf = NoInvTransf()</span>
    <span class="s1">fs = FeatureUnion([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">transf)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;noinvtransf&quot;</span><span class="s2">, </span><span class="s1">noinvtransf)])</span>
    <span class="s2">assert </span><span class="s1">fs.named_transformers[</span><span class="s3">&quot;transf&quot;</span><span class="s1">] == transf</span>
    <span class="s2">assert </span><span class="s1">fs.named_transformers[</span><span class="s3">&quot;noinvtransf&quot;</span><span class="s1">] == noinvtransf</span>

    <span class="s5"># test named attribute</span>
    <span class="s2">assert </span><span class="s1">fs.named_transformers.transf == transf</span>
    <span class="s2">assert </span><span class="s1">fs.named_transformers.noinvtransf == noinvtransf</span>


<span class="s2">def </span><span class="s1">test_make_union():</span>
    <span class="s1">pca = PCA(svd_solver=</span><span class="s3">&quot;full&quot;</span><span class="s1">)</span>
    <span class="s1">mock = Transf()</span>
    <span class="s1">fu = make_union(pca</span><span class="s2">, </span><span class="s1">mock)</span>
    <span class="s1">names</span><span class="s2">, </span><span class="s1">transformers = zip(*fu.transformer_list)</span>
    <span class="s2">assert </span><span class="s1">names == (</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s3">&quot;transf&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">transformers == (pca</span><span class="s2">, </span><span class="s1">mock)</span>


<span class="s2">def </span><span class="s1">test_make_union_kwargs():</span>
    <span class="s1">pca = PCA(svd_solver=</span><span class="s3">&quot;full&quot;</span><span class="s1">)</span>
    <span class="s1">mock = Transf()</span>
    <span class="s1">fu = make_union(pca</span><span class="s2">, </span><span class="s1">mock</span><span class="s2">, </span><span class="s1">n_jobs=</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">fu.transformer_list == make_union(pca</span><span class="s2">, </span><span class="s1">mock).transformer_list</span>
    <span class="s2">assert </span><span class="s4">3 </span><span class="s1">== fu.n_jobs</span>

    <span class="s5"># invalid keyword parameters should raise an error message</span>
    <span class="s1">msg = re.escape(</span>
        <span class="s3">&quot;make_union() got an unexpected keyword argument 'transformer_weights'&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">make_union(pca</span><span class="s2">, </span><span class="s1">mock</span><span class="s2">, </span><span class="s1">transformer_weights={</span><span class="s3">&quot;pca&quot;</span><span class="s1">: </span><span class="s4">10</span><span class="s2">, </span><span class="s3">&quot;Transf&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">})</span>


<span class="s2">def </span><span class="s1">test_pipeline_transform():</span>
    <span class="s5"># Test whether pipeline works with a transformer at the end.</span>
    <span class="s5"># Also test pipeline.transform and pipeline.inverse_transform</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">pca = PCA(n_components=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">svd_solver=</span><span class="s3">&quot;full&quot;</span><span class="s1">)</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)])</span>

    <span class="s5"># test transform and fit_transform:</span>
    <span class="s1">X_trans = pipeline.fit(X).transform(X)</span>
    <span class="s1">X_trans2 = pipeline.fit_transform(X)</span>
    <span class="s1">X_trans3 = pca.fit_transform(X)</span>
    <span class="s1">assert_array_almost_equal(X_trans</span><span class="s2">, </span><span class="s1">X_trans2)</span>
    <span class="s1">assert_array_almost_equal(X_trans</span><span class="s2">, </span><span class="s1">X_trans3)</span>

    <span class="s1">X_back = pipeline.inverse_transform(X_trans)</span>
    <span class="s1">X_back2 = pca.inverse_transform(X_trans)</span>
    <span class="s1">assert_array_almost_equal(X_back</span><span class="s2">, </span><span class="s1">X_back2)</span>


<span class="s2">def </span><span class="s1">test_pipeline_fit_transform():</span>
    <span class="s5"># Test whether pipeline works with a transformer missing fit_transform</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">y = iris.target</span>
    <span class="s1">transf = Transf()</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">transf)])</span>

    <span class="s5"># test fit_transform:</span>
    <span class="s1">X_trans = pipeline.fit_transform(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">X_trans2 = transf.fit(X</span><span class="s2">, </span><span class="s1">y).transform(X)</span>
    <span class="s1">assert_array_almost_equal(X_trans</span><span class="s2">, </span><span class="s1">X_trans2)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;start, end&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, None</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_pipeline_slice(start</span><span class="s2">, </span><span class="s1">end):</span>
    <span class="s1">pipe = Pipeline(</span>
        <span class="s1">[(</span><span class="s3">&quot;transf1&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;transf2&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">FitParamT())]</span><span class="s2">,</span>
        <span class="s1">memory=</span><span class="s3">&quot;123&quot;</span><span class="s2">,</span>
        <span class="s1">verbose=</span><span class="s2">True,</span>
    <span class="s1">)</span>
    <span class="s1">pipe_slice = pipe[start:end]</span>
    <span class="s5"># Test class</span>
    <span class="s2">assert </span><span class="s1">isinstance(pipe_slice</span><span class="s2">, </span><span class="s1">Pipeline)</span>
    <span class="s5"># Test steps</span>
    <span class="s2">assert </span><span class="s1">pipe_slice.steps == pipe.steps[start:end]</span>
    <span class="s5"># Test named_steps attribute</span>
    <span class="s2">assert </span><span class="s1">(</span>
        <span class="s1">list(pipe_slice.named_steps.items())</span>
        <span class="s1">== list(pipe.named_steps.items())[start:end]</span>
    <span class="s1">)</span>
    <span class="s5"># Test the rest of the parameters</span>
    <span class="s1">pipe_params = pipe.get_params(deep=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">pipe_slice_params = pipe_slice.get_params(deep=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">del </span><span class="s1">pipe_params[</span><span class="s3">&quot;steps&quot;</span><span class="s1">]</span>
    <span class="s2">del </span><span class="s1">pipe_slice_params[</span><span class="s3">&quot;steps&quot;</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">pipe_params == pipe_slice_params</span>
    <span class="s5"># Test exception</span>
    <span class="s1">msg = </span><span class="s3">&quot;Pipeline slicing only supports a step of 1&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipe[start:end:-</span><span class="s4">1</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">test_pipeline_index():</span>
    <span class="s1">transf = Transf()</span>
    <span class="s1">clf = FitParamT()</span>
    <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">transf)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">clf)])</span>
    <span class="s2">assert </span><span class="s1">pipe[</span><span class="s4">0</span><span class="s1">] == transf</span>
    <span class="s2">assert </span><span class="s1">pipe[</span><span class="s3">&quot;transf&quot;</span><span class="s1">] == transf</span>
    <span class="s2">assert </span><span class="s1">pipe[-</span><span class="s4">1</span><span class="s1">] == clf</span>
    <span class="s2">assert </span><span class="s1">pipe[</span><span class="s3">&quot;clf&quot;</span><span class="s1">] == clf</span>

    <span class="s5"># should raise an error if slicing out of range</span>
    <span class="s2">with </span><span class="s1">pytest.raises(IndexError):</span>
        <span class="s1">pipe[</span><span class="s4">3</span><span class="s1">]</span>

    <span class="s5"># should raise an error if indexing with wrong element name</span>
    <span class="s2">with </span><span class="s1">pytest.raises(KeyError):</span>
        <span class="s1">pipe[</span><span class="s3">&quot;foobar&quot;</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">test_set_pipeline_steps():</span>
    <span class="s1">transf1 = Transf()</span>
    <span class="s1">transf2 = Transf()</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">transf1)])</span>
    <span class="s2">assert </span><span class="s1">pipeline.named_steps[</span><span class="s3">&quot;mock&quot;</span><span class="s1">] </span><span class="s2">is </span><span class="s1">transf1</span>

    <span class="s5"># Directly setting attr</span>
    <span class="s1">pipeline.steps = [(</span><span class="s3">&quot;mock2&quot;</span><span class="s2">, </span><span class="s1">transf2)]</span>
    <span class="s2">assert </span><span class="s3">&quot;mock&quot; </span><span class="s2">not in </span><span class="s1">pipeline.named_steps</span>
    <span class="s2">assert </span><span class="s1">pipeline.named_steps[</span><span class="s3">&quot;mock2&quot;</span><span class="s1">] </span><span class="s2">is </span><span class="s1">transf2</span>
    <span class="s2">assert </span><span class="s1">[(</span><span class="s3">&quot;mock2&quot;</span><span class="s2">, </span><span class="s1">transf2)] == pipeline.steps</span>

    <span class="s5"># Using set_params</span>
    <span class="s1">pipeline.set_params(steps=[(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">transf1)])</span>
    <span class="s2">assert </span><span class="s1">[(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">transf1)] == pipeline.steps</span>

    <span class="s5"># Using set_params to replace single step</span>
    <span class="s1">pipeline.set_params(mock=transf2)</span>
    <span class="s2">assert </span><span class="s1">[(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">transf2)] == pipeline.steps</span>

    <span class="s5"># With invalid data</span>
    <span class="s1">pipeline.set_params(steps=[(</span><span class="s3">&quot;junk&quot;</span><span class="s2">, </span><span class="s1">())])</span>
    <span class="s1">msg = re.escape(</span>
        <span class="s3">&quot;Last step of Pipeline should implement fit or be the string 'passthrough'.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipeline.fit([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">msg = </span><span class="s3">&quot;This 'Pipeline' has no attribute 'fit_transform'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipeline.fit_transform([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_pipeline_named_steps():</span>
    <span class="s1">transf = Transf()</span>
    <span class="s1">mult2 = Mult(mult=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">transf)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;mult&quot;</span><span class="s2">, </span><span class="s1">mult2)])</span>

    <span class="s5"># Test access via named_steps bunch object</span>
    <span class="s2">assert </span><span class="s3">&quot;mock&quot; </span><span class="s2">in </span><span class="s1">pipeline.named_steps</span>
    <span class="s2">assert </span><span class="s3">&quot;mock2&quot; </span><span class="s2">not in </span><span class="s1">pipeline.named_steps</span>
    <span class="s2">assert </span><span class="s1">pipeline.named_steps.mock </span><span class="s2">is </span><span class="s1">transf</span>
    <span class="s2">assert </span><span class="s1">pipeline.named_steps.mult </span><span class="s2">is </span><span class="s1">mult2</span>

    <span class="s5"># Test bunch with conflict attribute of dict</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;values&quot;</span><span class="s2">, </span><span class="s1">transf)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;mult&quot;</span><span class="s2">, </span><span class="s1">mult2)])</span>
    <span class="s2">assert </span><span class="s1">pipeline.named_steps.values </span><span class="s2">is not </span><span class="s1">transf</span>
    <span class="s2">assert </span><span class="s1">pipeline.named_steps.mult </span><span class="s2">is </span><span class="s1">mult2</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;passthrough&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_pipeline_correctly_adjusts_steps(passthrough):</span>
    <span class="s1">X = np.array([[</span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">y = np.array([</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">mult2 = Mult(mult=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mult3 = Mult(mult=</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">mult5 = Mult(mult=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s1">pipeline = Pipeline(</span>
        <span class="s1">[(</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s1">mult2)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;bad&quot;</span><span class="s2">, </span><span class="s1">passthrough)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s1">mult3)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m5&quot;</span><span class="s2">, </span><span class="s1">mult5)]</span>
    <span class="s1">)</span>

    <span class="s1">pipeline.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">expected_names = [</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s3">&quot;bad&quot;</span><span class="s2">, </span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s3">&quot;m5&quot;</span><span class="s1">]</span>
    <span class="s1">actual_names = [name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">pipeline.steps]</span>
    <span class="s2">assert </span><span class="s1">expected_names == actual_names</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;passthrough&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_set_pipeline_step_passthrough(passthrough):</span>
    <span class="s1">X = np.array([[</span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">y = np.array([</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">mult2 = Mult(mult=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mult3 = Mult(mult=</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">mult5 = Mult(mult=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">make():</span>
        <span class="s2">return </span><span class="s1">Pipeline([(</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s1">mult2)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s1">mult3)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;last&quot;</span><span class="s2">, </span><span class="s1">mult5)])</span>

    <span class="s1">pipeline = make()</span>

    <span class="s1">exp = </span><span class="s4">2 </span><span class="s1">* </span><span class="s4">3 </span><span class="s1">* </span><span class="s4">5</span>
    <span class="s1">assert_array_equal([[exp]]</span><span class="s2">, </span><span class="s1">pipeline.fit_transform(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s1">assert_array_equal([exp]</span><span class="s2">, </span><span class="s1">pipeline.fit(X).predict(X))</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">pipeline.inverse_transform([[exp]]))</span>

    <span class="s1">pipeline.set_params(m3=passthrough)</span>
    <span class="s1">exp = </span><span class="s4">2 </span><span class="s1">* </span><span class="s4">5</span>
    <span class="s1">assert_array_equal([[exp]]</span><span class="s2">, </span><span class="s1">pipeline.fit_transform(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s1">assert_array_equal([exp]</span><span class="s2">, </span><span class="s1">pipeline.fit(X).predict(X))</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">pipeline.inverse_transform([[exp]]))</span>
    <span class="s2">assert </span><span class="s1">pipeline.get_params(deep=</span><span class="s2">True</span><span class="s1">) == {</span>
        <span class="s3">&quot;steps&quot;</span><span class="s1">: pipeline.steps</span><span class="s2">,</span>
        <span class="s3">&quot;m2&quot;</span><span class="s1">: mult2</span><span class="s2">,</span>
        <span class="s3">&quot;m3&quot;</span><span class="s1">: passthrough</span><span class="s2">,</span>
        <span class="s3">&quot;last&quot;</span><span class="s1">: mult5</span><span class="s2">,</span>
        <span class="s3">&quot;memory&quot;</span><span class="s1">: </span><span class="s2">None,</span>
        <span class="s3">&quot;m2__mult&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s2">,</span>
        <span class="s3">&quot;last__mult&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s2">,</span>
        <span class="s3">&quot;verbose&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s1">}</span>

    <span class="s1">pipeline.set_params(m2=passthrough)</span>
    <span class="s1">exp = </span><span class="s4">5</span>
    <span class="s1">assert_array_equal([[exp]]</span><span class="s2">, </span><span class="s1">pipeline.fit_transform(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s1">assert_array_equal([exp]</span><span class="s2">, </span><span class="s1">pipeline.fit(X).predict(X))</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">pipeline.inverse_transform([[exp]]))</span>

    <span class="s5"># for other methods, ensure no AttributeErrors on None:</span>
    <span class="s1">other_methods = [</span>
        <span class="s3">&quot;predict_proba&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;predict_log_proba&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;decision_function&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;transform&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;score&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">other_methods:</span>
        <span class="s1">getattr(pipeline</span><span class="s2">, </span><span class="s1">method)(X)</span>

    <span class="s1">pipeline.set_params(m2=mult2)</span>
    <span class="s1">exp = </span><span class="s4">2 </span><span class="s1">* </span><span class="s4">5</span>
    <span class="s1">assert_array_equal([[exp]]</span><span class="s2">, </span><span class="s1">pipeline.fit_transform(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s1">assert_array_equal([exp]</span><span class="s2">, </span><span class="s1">pipeline.fit(X).predict(X))</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">pipeline.inverse_transform([[exp]]))</span>

    <span class="s1">pipeline = make()</span>
    <span class="s1">pipeline.set_params(last=passthrough)</span>
    <span class="s5"># mult2 and mult3 are active</span>
    <span class="s1">exp = </span><span class="s4">6</span>
    <span class="s1">assert_array_equal([[exp]]</span><span class="s2">, </span><span class="s1">pipeline.fit(X</span><span class="s2">, </span><span class="s1">y).transform(X))</span>
    <span class="s1">assert_array_equal([[exp]]</span><span class="s2">, </span><span class="s1">pipeline.fit_transform(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">pipeline.inverse_transform([[exp]]))</span>

    <span class="s1">msg = </span><span class="s3">&quot;'str' object has no attribute 'predict'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">getattr(pipeline</span><span class="s2">, </span><span class="s3">&quot;predict&quot;</span><span class="s1">)</span>

    <span class="s5"># Check 'passthrough' step at construction time</span>
    <span class="s1">exp = </span><span class="s4">2 </span><span class="s1">* </span><span class="s4">5</span>
    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s1">mult2)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s1">passthrough)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;last&quot;</span><span class="s2">, </span><span class="s1">mult5)])</span>
    <span class="s1">assert_array_equal([[exp]]</span><span class="s2">, </span><span class="s1">pipeline.fit_transform(X</span><span class="s2">, </span><span class="s1">y))</span>
    <span class="s1">assert_array_equal([exp]</span><span class="s2">, </span><span class="s1">pipeline.fit(X).predict(X))</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">pipeline.inverse_transform([[exp]]))</span>


<span class="s2">def </span><span class="s1">test_pipeline_ducktyping():</span>
    <span class="s1">pipeline = make_pipeline(Mult(</span><span class="s4">5</span><span class="s1">))</span>
    <span class="s1">pipeline.predict</span>
    <span class="s1">pipeline.transform</span>
    <span class="s1">pipeline.inverse_transform</span>

    <span class="s1">pipeline = make_pipeline(Transf())</span>
    <span class="s2">assert not </span><span class="s1">hasattr(pipeline</span><span class="s2">, </span><span class="s3">&quot;predict&quot;</span><span class="s1">)</span>
    <span class="s1">pipeline.transform</span>
    <span class="s1">pipeline.inverse_transform</span>

    <span class="s1">pipeline = make_pipeline(</span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">pipeline.steps[</span><span class="s4">0</span><span class="s1">] == (</span><span class="s3">&quot;passthrough&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span>
    <span class="s2">assert not </span><span class="s1">hasattr(pipeline</span><span class="s2">, </span><span class="s3">&quot;predict&quot;</span><span class="s1">)</span>
    <span class="s1">pipeline.transform</span>
    <span class="s1">pipeline.inverse_transform</span>

    <span class="s1">pipeline = make_pipeline(Transf()</span><span class="s2">, </span><span class="s1">NoInvTransf())</span>
    <span class="s2">assert not </span><span class="s1">hasattr(pipeline</span><span class="s2">, </span><span class="s3">&quot;predict&quot;</span><span class="s1">)</span>
    <span class="s1">pipeline.transform</span>
    <span class="s2">assert not </span><span class="s1">hasattr(pipeline</span><span class="s2">, </span><span class="s3">&quot;inverse_transform&quot;</span><span class="s1">)</span>

    <span class="s1">pipeline = make_pipeline(NoInvTransf()</span><span class="s2">, </span><span class="s1">Transf())</span>
    <span class="s2">assert not </span><span class="s1">hasattr(pipeline</span><span class="s2">, </span><span class="s3">&quot;predict&quot;</span><span class="s1">)</span>
    <span class="s1">pipeline.transform</span>
    <span class="s2">assert not </span><span class="s1">hasattr(pipeline</span><span class="s2">, </span><span class="s3">&quot;inverse_transform&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_make_pipeline():</span>
    <span class="s1">t1 = Transf()</span>
    <span class="s1">t2 = Transf()</span>
    <span class="s1">pipe = make_pipeline(t1</span><span class="s2">, </span><span class="s1">t2)</span>
    <span class="s2">assert </span><span class="s1">isinstance(pipe</span><span class="s2">, </span><span class="s1">Pipeline)</span>
    <span class="s2">assert </span><span class="s1">pipe.steps[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;transf-1&quot;</span>
    <span class="s2">assert </span><span class="s1">pipe.steps[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;transf-2&quot;</span>

    <span class="s1">pipe = make_pipeline(t1</span><span class="s2">, </span><span class="s1">t2</span><span class="s2">, </span><span class="s1">FitParamT())</span>
    <span class="s2">assert </span><span class="s1">isinstance(pipe</span><span class="s2">, </span><span class="s1">Pipeline)</span>
    <span class="s2">assert </span><span class="s1">pipe.steps[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;transf-1&quot;</span>
    <span class="s2">assert </span><span class="s1">pipe.steps[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;transf-2&quot;</span>
    <span class="s2">assert </span><span class="s1">pipe.steps[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;fitparamt&quot;</span>


<span class="s2">def </span><span class="s1">test_feature_union_weights():</span>
    <span class="s5"># test feature union with transformer weights</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">y = iris.target</span>
    <span class="s1">pca = PCA(n_components=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">svd_solver=</span><span class="s3">&quot;randomized&quot;</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">select = SelectKBest(k=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s5"># test using fit followed by transform</span>
    <span class="s1">fs = FeatureUnion(</span>
        <span class="s1">[(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;select&quot;</span><span class="s2">, </span><span class="s1">select)]</span><span class="s2">, </span><span class="s1">transformer_weights={</span><span class="s3">&quot;pca&quot;</span><span class="s1">: </span><span class="s4">10</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">fs.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">X_transformed = fs.transform(X)</span>
    <span class="s5"># test using fit_transform</span>
    <span class="s1">fs = FeatureUnion(</span>
        <span class="s1">[(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;select&quot;</span><span class="s2">, </span><span class="s1">select)]</span><span class="s2">, </span><span class="s1">transformer_weights={</span><span class="s3">&quot;pca&quot;</span><span class="s1">: </span><span class="s4">10</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">X_fit_transformed = fs.fit_transform(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s5"># test it works with transformers missing fit_transform</span>
    <span class="s1">fs = FeatureUnion(</span>
        <span class="s1">[(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;select&quot;</span><span class="s2">, </span><span class="s1">select)]</span><span class="s2">,</span>
        <span class="s1">transformer_weights={</span><span class="s3">&quot;mock&quot;</span><span class="s1">: </span><span class="s4">10</span><span class="s1">}</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">X_fit_transformed_wo_method = fs.fit_transform(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s5"># check against expected result</span>

    <span class="s5"># We use a different pca object to control the random_state stream</span>
    <span class="s1">assert_array_almost_equal(X_transformed[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">10 </span><span class="s1">* pca.fit_transform(X))</span>
    <span class="s1">assert_array_equal(X_transformed[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">select.fit_transform(X</span><span class="s2">, </span><span class="s1">y).ravel())</span>
    <span class="s1">assert_array_almost_equal(X_fit_transformed[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">10 </span><span class="s1">* pca.fit_transform(X))</span>
    <span class="s1">assert_array_equal(X_fit_transformed[:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">select.fit_transform(X</span><span class="s2">, </span><span class="s1">y).ravel())</span>
    <span class="s2">assert </span><span class="s1">X_fit_transformed_wo_method.shape == (X.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_feature_union_parallel():</span>
    <span class="s5"># test that n_jobs work for FeatureUnion</span>
    <span class="s1">X = JUNK_FOOD_DOCS</span>

    <span class="s1">fs = FeatureUnion(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;words&quot;</span><span class="s2">, </span><span class="s1">CountVectorizer(analyzer=</span><span class="s3">&quot;word&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;chars&quot;</span><span class="s2">, </span><span class="s1">CountVectorizer(analyzer=</span><span class="s3">&quot;char&quot;</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">fs_parallel = FeatureUnion(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;words&quot;</span><span class="s2">, </span><span class="s1">CountVectorizer(analyzer=</span><span class="s3">&quot;word&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;chars&quot;</span><span class="s2">, </span><span class="s1">CountVectorizer(analyzer=</span><span class="s3">&quot;char&quot;</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">n_jobs=</span><span class="s4">2</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">fs_parallel2 = FeatureUnion(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;words&quot;</span><span class="s2">, </span><span class="s1">CountVectorizer(analyzer=</span><span class="s3">&quot;word&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;chars&quot;</span><span class="s2">, </span><span class="s1">CountVectorizer(analyzer=</span><span class="s3">&quot;char&quot;</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">n_jobs=</span><span class="s4">2</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">fs.fit(X)</span>
    <span class="s1">X_transformed = fs.transform(X)</span>
    <span class="s2">assert </span><span class="s1">X_transformed.shape[</span><span class="s4">0</span><span class="s1">] == len(X)</span>

    <span class="s1">fs_parallel.fit(X)</span>
    <span class="s1">X_transformed_parallel = fs_parallel.transform(X)</span>
    <span class="s2">assert </span><span class="s1">X_transformed.shape == X_transformed_parallel.shape</span>
    <span class="s1">assert_array_equal(X_transformed.toarray()</span><span class="s2">, </span><span class="s1">X_transformed_parallel.toarray())</span>

    <span class="s5"># fit_transform should behave the same</span>
    <span class="s1">X_transformed_parallel2 = fs_parallel2.fit_transform(X)</span>
    <span class="s1">assert_array_equal(X_transformed.toarray()</span><span class="s2">, </span><span class="s1">X_transformed_parallel2.toarray())</span>

    <span class="s5"># transformers should stay fit after fit_transform</span>
    <span class="s1">X_transformed_parallel2 = fs_parallel2.transform(X)</span>
    <span class="s1">assert_array_equal(X_transformed.toarray()</span><span class="s2">, </span><span class="s1">X_transformed_parallel2.toarray())</span>


<span class="s2">def </span><span class="s1">test_feature_union_feature_names():</span>
    <span class="s1">word_vect = CountVectorizer(analyzer=</span><span class="s3">&quot;word&quot;</span><span class="s1">)</span>
    <span class="s1">char_vect = CountVectorizer(analyzer=</span><span class="s3">&quot;char_wb&quot;</span><span class="s2">, </span><span class="s1">ngram_range=(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;chars&quot;</span><span class="s2">, </span><span class="s1">char_vect)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;words&quot;</span><span class="s2">, </span><span class="s1">word_vect)])</span>
    <span class="s1">ft.fit(JUNK_FOOD_DOCS)</span>
    <span class="s1">feature_names = ft.get_feature_names_out()</span>
    <span class="s2">for </span><span class="s1">feat </span><span class="s2">in </span><span class="s1">feature_names:</span>
        <span class="s2">assert </span><span class="s3">&quot;chars__&quot; </span><span class="s2">in </span><span class="s1">feat </span><span class="s2">or </span><span class="s3">&quot;words__&quot; </span><span class="s2">in </span><span class="s1">feat</span>
    <span class="s2">assert </span><span class="s1">len(feature_names) == </span><span class="s4">35</span>

    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;tr1&quot;</span><span class="s2">, </span><span class="s1">Transf())]).fit([[</span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s1">msg = re.escape(</span>
        <span class="s3">&quot;Transformer tr1 (type Transf) does not provide get_feature_names_out&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">ft.get_feature_names_out()</span>


<span class="s2">def </span><span class="s1">test_classes_property():</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">y = iris.target</span>

    <span class="s1">reg = make_pipeline(SelectKBest(k=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">LinearRegression())</span>
    <span class="s1">reg.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError):</span>
        <span class="s1">getattr(reg</span><span class="s2">, </span><span class="s3">&quot;classes_&quot;</span><span class="s1">)</span>

    <span class="s1">clf = make_pipeline(SelectKBest(k=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">LogisticRegression(random_state=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError):</span>
        <span class="s1">getattr(clf</span><span class="s2">, </span><span class="s3">&quot;classes_&quot;</span><span class="s1">)</span>
    <span class="s1">clf.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">assert_array_equal(clf.classes_</span><span class="s2">, </span><span class="s1">np.unique(y))</span>


<span class="s2">def </span><span class="s1">test_set_feature_union_steps():</span>
    <span class="s1">mult2 = Mult(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mult3 = Mult(</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">mult5 = Mult(</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s1">mult3.get_feature_names_out = </span><span class="s2">lambda </span><span class="s1">input_features: [</span><span class="s3">&quot;x3&quot;</span><span class="s1">]</span>
    <span class="s1">mult2.get_feature_names_out = </span><span class="s2">lambda </span><span class="s1">input_features: [</span><span class="s3">&quot;x2&quot;</span><span class="s1">]</span>
    <span class="s1">mult5.get_feature_names_out = </span><span class="s2">lambda </span><span class="s1">input_features: [</span><span class="s3">&quot;x5&quot;</span><span class="s1">]</span>

    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s1">mult2)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s1">mult3)])</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.transform(np.asarray([[</span><span class="s4">1</span><span class="s1">]])))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m2__x2&quot;</span><span class="s2">, </span><span class="s3">&quot;m3__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>

    <span class="s5"># Directly setting attr</span>
    <span class="s1">ft.transformer_list = [(</span><span class="s3">&quot;m5&quot;</span><span class="s2">, </span><span class="s1">mult5)]</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.transform(np.asarray([[</span><span class="s4">1</span><span class="s1">]])))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m5__x5&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>

    <span class="s5"># Using set_params</span>
    <span class="s1">ft.set_params(transformer_list=[(</span><span class="s3">&quot;mock&quot;</span><span class="s2">, </span><span class="s1">mult3)])</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.transform(np.asarray([[</span><span class="s4">1</span><span class="s1">]])))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;mock__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>

    <span class="s5"># Using set_params to replace single step</span>
    <span class="s1">ft.set_params(mock=mult5)</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.transform(np.asarray([[</span><span class="s4">1</span><span class="s1">]])))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;mock__x5&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>


<span class="s2">def </span><span class="s1">test_set_feature_union_step_drop():</span>
    <span class="s1">mult2 = Mult(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mult3 = Mult(</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s1">mult2.get_feature_names_out = </span><span class="s2">lambda </span><span class="s1">input_features: [</span><span class="s3">&quot;x2&quot;</span><span class="s1">]</span>
    <span class="s1">mult3.get_feature_names_out = </span><span class="s2">lambda </span><span class="s1">input_features: [</span><span class="s3">&quot;x3&quot;</span><span class="s1">]</span>

    <span class="s1">X = np.asarray([[</span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s1">mult2)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s1">mult3)])</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m2__x2&quot;</span><span class="s2">, </span><span class="s3">&quot;m3__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>

    <span class="s1">ft.set_params(m2=</span><span class="s3">&quot;drop&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m3__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>

    <span class="s1">ft.set_params(m3=</span><span class="s3">&quot;drop&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal([[]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal([]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>

    <span class="s5"># check we can change back</span>
    <span class="s1">ft.set_params(m3=mult3)</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>

    <span class="s5"># Check 'drop' step at construction time</span>
    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s3">&quot;drop&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s1">mult3)])</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m3__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>


<span class="s2">def </span><span class="s1">test_set_feature_union_passthrough():</span>
    <span class="s0">&quot;&quot;&quot;Check the behaviour of setting a transformer to `&quot;passthrough&quot;`.&quot;&quot;&quot;</span>
    <span class="s1">mult2 = Mult(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">mult3 = Mult(</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s5"># We only test get_features_names_out, as get_feature_names is unsupported by</span>
    <span class="s5"># FunctionTransformer, and hence unsupported by FeatureUnion passthrough.</span>
    <span class="s1">mult2.get_feature_names_out = </span><span class="s2">lambda </span><span class="s1">input_features: [</span><span class="s3">&quot;x2&quot;</span><span class="s1">]</span>
    <span class="s1">mult3.get_feature_names_out = </span><span class="s2">lambda </span><span class="s1">input_features: [</span><span class="s3">&quot;x3&quot;</span><span class="s1">]</span>

    <span class="s1">X = np.asarray([[</span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s1">mult2)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s1">mult3)])</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m2__x2&quot;</span><span class="s2">, </span><span class="s3">&quot;m3__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out())</span>

    <span class="s1">ft.set_params(m2=</span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m2__myfeat&quot;</span><span class="s2">, </span><span class="s3">&quot;m3__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out([</span><span class="s3">&quot;myfeat&quot;</span><span class="s1">]))</span>

    <span class="s1">ft.set_params(m3=</span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span><span class="s3">&quot;m2__myfeat&quot;</span><span class="s2">, </span><span class="s3">&quot;m3__myfeat&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out([</span><span class="s3">&quot;myfeat&quot;</span><span class="s1">])</span>
    <span class="s1">)</span>

    <span class="s5"># check we can change back</span>
    <span class="s1">ft.set_params(m3=mult3)</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m2__myfeat&quot;</span><span class="s2">, </span><span class="s3">&quot;m3__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out([</span><span class="s3">&quot;myfeat&quot;</span><span class="s1">]))</span>

    <span class="s5"># Check 'passthrough' step at construction time</span>
    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;m2&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;m3&quot;</span><span class="s2">, </span><span class="s1">mult3)])</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X))</span>
    <span class="s1">assert_array_equal([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">ft.fit_transform(X))</span>
    <span class="s1">assert_array_equal([</span><span class="s3">&quot;m2__myfeat&quot;</span><span class="s2">, </span><span class="s3">&quot;m3__x3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ft.get_feature_names_out([</span><span class="s3">&quot;myfeat&quot;</span><span class="s1">]))</span>

    <span class="s1">X = iris.data</span>
    <span class="s1">columns = X.shape[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">pca = PCA(n_components=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">svd_solver=</span><span class="s3">&quot;randomized&quot;</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;passthrough&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)])</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X)[:</span><span class="s2">, </span><span class="s1">:columns])</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">ft.fit_transform(X)[:</span><span class="s2">, </span><span class="s1">:columns])</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span>
            <span class="s3">&quot;passthrough__f0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f2&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f3&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__pca0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__pca1&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ft.get_feature_names_out([</span><span class="s3">&quot;f0&quot;</span><span class="s2">, </span><span class="s3">&quot;f1&quot;</span><span class="s2">, </span><span class="s3">&quot;f2&quot;</span><span class="s2">, </span><span class="s3">&quot;f3&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">ft.set_params(pca=</span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span>
    <span class="s1">X_ft = ft.fit(X).transform(X)</span>
    <span class="s1">assert_array_equal(X_ft</span><span class="s2">, </span><span class="s1">np.hstack([X</span><span class="s2">, </span><span class="s1">X]))</span>
    <span class="s1">X_ft = ft.fit_transform(X)</span>
    <span class="s1">assert_array_equal(X_ft</span><span class="s2">, </span><span class="s1">np.hstack([X</span><span class="s2">, </span><span class="s1">X]))</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span>
            <span class="s3">&quot;passthrough__f0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f2&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f3&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__f0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__f1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__f2&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__f3&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ft.get_feature_names_out([</span><span class="s3">&quot;f0&quot;</span><span class="s2">, </span><span class="s3">&quot;f1&quot;</span><span class="s2">, </span><span class="s3">&quot;f2&quot;</span><span class="s2">, </span><span class="s3">&quot;f3&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">ft.set_params(passthrough=pca)</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X)[:</span><span class="s2">, </span><span class="s1">-columns:])</span>
    <span class="s1">assert_array_equal(X</span><span class="s2">, </span><span class="s1">ft.fit_transform(X)[:</span><span class="s2">, </span><span class="s1">-columns:])</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span>
            <span class="s3">&quot;passthrough__pca0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__pca1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__f0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__f1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__f2&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__f3&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ft.get_feature_names_out([</span><span class="s3">&quot;f0&quot;</span><span class="s2">, </span><span class="s3">&quot;f1&quot;</span><span class="s2">, </span><span class="s3">&quot;f2&quot;</span><span class="s2">, </span><span class="s3">&quot;f3&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">ft = FeatureUnion(</span>
        <span class="s1">[(</span><span class="s3">&quot;passthrough&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)]</span><span class="s2">,</span>
        <span class="s1">transformer_weights={</span><span class="s3">&quot;passthrough&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(X * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">ft.fit(X).transform(X)[:</span><span class="s2">, </span><span class="s1">:columns])</span>
    <span class="s1">assert_array_equal(X * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">ft.fit_transform(X)[:</span><span class="s2">, </span><span class="s1">:columns])</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span>
            <span class="s3">&quot;passthrough__f0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f2&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__f3&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__pca0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__pca1&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ft.get_feature_names_out([</span><span class="s3">&quot;f0&quot;</span><span class="s2">, </span><span class="s3">&quot;f1&quot;</span><span class="s2">, </span><span class="s3">&quot;f2&quot;</span><span class="s2">, </span><span class="s3">&quot;f3&quot;</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_feature_union_passthrough_get_feature_names_out():</span>
    <span class="s0">&quot;&quot;&quot;Check that get_feature_names_out works with passthrough without 
    passing input_features. 
    &quot;&quot;&quot;</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">pca = PCA(n_components=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">svd_solver=</span><span class="s3">&quot;randomized&quot;</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">ft = FeatureUnion([(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;passthrough&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)])</span>
    <span class="s1">ft.fit(X)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">[</span>
            <span class="s3">&quot;pca__pca0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;pca__pca1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__x0&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__x1&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__x2&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;passthrough__x3&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ft.get_feature_names_out()</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_step_name_validation():</span>
    <span class="s1">error_message_1 = </span><span class="s3">r&quot;Estimator names must not contain __: got \['a__q'\]&quot;</span>
    <span class="s1">error_message_2 = </span><span class="s3">r&quot;Names provided are not unique: \['a', 'a'\]&quot;</span>
    <span class="s1">error_message_3 = </span><span class="s3">r&quot;Estimator names conflict with constructor arguments: \['%s'\]&quot;</span>
    <span class="s1">bad_steps1 = [(</span><span class="s3">&quot;a__q&quot;</span><span class="s2">, </span><span class="s1">Mult(</span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">Mult(</span><span class="s4">3</span><span class="s1">))]</span>
    <span class="s1">bad_steps2 = [(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">Mult(</span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">Mult(</span><span class="s4">3</span><span class="s1">))]</span>
    <span class="s2">for </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">param </span><span class="s2">in </span><span class="s1">[(Pipeline</span><span class="s2">, </span><span class="s3">&quot;steps&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(FeatureUnion</span><span class="s2">, </span><span class="s3">&quot;transformer_list&quot;</span><span class="s1">)]:</span>
        <span class="s5"># we validate in construction (despite scikit-learn convention)</span>
        <span class="s1">bad_steps3 = [(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">Mult(</span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(param</span><span class="s2">, </span><span class="s1">Mult(</span><span class="s4">3</span><span class="s1">))]</span>
        <span class="s2">for </span><span class="s1">bad_steps</span><span class="s2">, </span><span class="s1">message </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s1">(bad_steps1</span><span class="s2">, </span><span class="s1">error_message_1)</span><span class="s2">,</span>
            <span class="s1">(bad_steps2</span><span class="s2">, </span><span class="s1">error_message_2)</span><span class="s2">,</span>
            <span class="s1">(bad_steps3</span><span class="s2">, </span><span class="s1">error_message_3 % param)</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s5"># three ways to make invalid:</span>
            <span class="s5"># - construction</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
                <span class="s1">cls(**{param: bad_steps}).fit([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s5"># - setattr</span>
            <span class="s1">est = cls(**{param: [(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">Mult(</span><span class="s4">1</span><span class="s1">))]})</span>
            <span class="s1">setattr(est</span><span class="s2">, </span><span class="s1">param</span><span class="s2">, </span><span class="s1">bad_steps)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
                <span class="s1">est.fit([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
                <span class="s1">est.fit_transform([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s5"># - set_params</span>
            <span class="s1">est = cls(**{param: [(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">Mult(</span><span class="s4">1</span><span class="s1">))]})</span>
            <span class="s1">est.set_params(**{param: bad_steps})</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
                <span class="s1">est.fit([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=message):</span>
                <span class="s1">est.fit_transform([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_set_params_nested_pipeline():</span>
    <span class="s1">estimator = Pipeline([(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">Pipeline([(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">DummyRegressor())]))])</span>
    <span class="s1">estimator.set_params(a__b__alpha=</span><span class="s4">0.001</span><span class="s2">, </span><span class="s1">a__b=Lasso())</span>
    <span class="s1">estimator.set_params(a__steps=[(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">LogisticRegression())]</span><span class="s2">, </span><span class="s1">a__b__C=</span><span class="s4">5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_pipeline_memory():</span>
    <span class="s1">X = iris.data</span>
    <span class="s1">y = iris.target</span>
    <span class="s1">cachedir = mkdtemp()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">memory = joblib.Memory(location=cachedir</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s5"># Test with Transformer + SVC</span>
        <span class="s1">clf = SVC(probability=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">transf = DummyTransf()</span>
        <span class="s1">pipe = Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">clone(transf))</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;svc&quot;</span><span class="s2">, </span><span class="s1">clf)])</span>
        <span class="s1">cached_pipe = Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">transf)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;svc&quot;</span><span class="s2">, </span><span class="s1">clf)]</span><span class="s2">, </span><span class="s1">memory=memory)</span>

        <span class="s5"># Memoize the transformer at the first fit</span>
        <span class="s1">cached_pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s5"># Get the time stamp of the transformer in the cached pipeline</span>
        <span class="s1">ts = cached_pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].timestamp_</span>
        <span class="s5"># Check that cached_pipe and pipe yield identical results</span>
        <span class="s1">assert_array_equal(pipe.predict(X)</span><span class="s2">, </span><span class="s1">cached_pipe.predict(X))</span>
        <span class="s1">assert_array_equal(pipe.predict_proba(X)</span><span class="s2">, </span><span class="s1">cached_pipe.predict_proba(X))</span>
        <span class="s1">assert_array_equal(pipe.predict_log_proba(X)</span><span class="s2">, </span><span class="s1">cached_pipe.predict_log_proba(X))</span>
        <span class="s1">assert_array_equal(pipe.score(X</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">cached_pipe.score(X</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].means_</span><span class="s2">, </span><span class="s1">cached_pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].means_</span>
        <span class="s1">)</span>
        <span class="s2">assert not </span><span class="s1">hasattr(transf</span><span class="s2">, </span><span class="s3">&quot;means_&quot;</span><span class="s1">)</span>
        <span class="s5"># Check that we are reading the cache while fitting</span>
        <span class="s5"># a second time</span>
        <span class="s1">cached_pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s5"># Check that cached_pipe and pipe yield identical results</span>
        <span class="s1">assert_array_equal(pipe.predict(X)</span><span class="s2">, </span><span class="s1">cached_pipe.predict(X))</span>
        <span class="s1">assert_array_equal(pipe.predict_proba(X)</span><span class="s2">, </span><span class="s1">cached_pipe.predict_proba(X))</span>
        <span class="s1">assert_array_equal(pipe.predict_log_proba(X)</span><span class="s2">, </span><span class="s1">cached_pipe.predict_log_proba(X))</span>
        <span class="s1">assert_array_equal(pipe.score(X</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">cached_pipe.score(X</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].means_</span><span class="s2">, </span><span class="s1">cached_pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].means_</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts == cached_pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].timestamp_</span>
        <span class="s5"># Create a new pipeline with cloned estimators</span>
        <span class="s5"># Check that even changing the name step does not affect the cache hit</span>
        <span class="s1">clf_2 = SVC(probability=</span><span class="s2">True, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">transf_2 = DummyTransf()</span>
        <span class="s1">cached_pipe_2 = Pipeline(</span>
            <span class="s1">[(</span><span class="s3">&quot;transf_2&quot;</span><span class="s2">, </span><span class="s1">transf_2)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;svc&quot;</span><span class="s2">, </span><span class="s1">clf_2)]</span><span class="s2">, </span><span class="s1">memory=memory</span>
        <span class="s1">)</span>
        <span class="s1">cached_pipe_2.fit(X</span><span class="s2">, </span><span class="s1">y)</span>

        <span class="s5"># Check that cached_pipe and pipe yield identical results</span>
        <span class="s1">assert_array_equal(pipe.predict(X)</span><span class="s2">, </span><span class="s1">cached_pipe_2.predict(X))</span>
        <span class="s1">assert_array_equal(pipe.predict_proba(X)</span><span class="s2">, </span><span class="s1">cached_pipe_2.predict_proba(X))</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">pipe.predict_log_proba(X)</span><span class="s2">, </span><span class="s1">cached_pipe_2.predict_log_proba(X)</span>
        <span class="s1">)</span>
        <span class="s1">assert_array_equal(pipe.score(X</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">cached_pipe_2.score(X</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">pipe.named_steps[</span><span class="s3">&quot;transf&quot;</span><span class="s1">].means_</span><span class="s2">,</span>
            <span class="s1">cached_pipe_2.named_steps[</span><span class="s3">&quot;transf_2&quot;</span><span class="s1">].means_</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts == cached_pipe_2.named_steps[</span><span class="s3">&quot;transf_2&quot;</span><span class="s1">].timestamp_</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">shutil.rmtree(cachedir)</span>


<span class="s2">def </span><span class="s1">test_make_pipeline_memory():</span>
    <span class="s1">cachedir = mkdtemp()</span>
    <span class="s1">memory = joblib.Memory(location=cachedir</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">pipeline = make_pipeline(DummyTransf()</span><span class="s2">, </span><span class="s1">SVC()</span><span class="s2">, </span><span class="s1">memory=memory)</span>
    <span class="s2">assert </span><span class="s1">pipeline.memory </span><span class="s2">is </span><span class="s1">memory</span>
    <span class="s1">pipeline = make_pipeline(DummyTransf()</span><span class="s2">, </span><span class="s1">SVC())</span>
    <span class="s2">assert </span><span class="s1">pipeline.memory </span><span class="s2">is None</span>
    <span class="s2">assert </span><span class="s1">len(pipeline) == </span><span class="s4">2</span>

    <span class="s1">shutil.rmtree(cachedir)</span>


<span class="s2">class </span><span class="s1">FeatureNameSaver(BaseEstimator):</span>
    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._check_feature_names(X</span><span class="s2">, </span><span class="s1">reset=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">get_feature_names_out(self</span><span class="s2">, </span><span class="s1">input_features=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">input_features</span>


<span class="s2">def </span><span class="s1">test_features_names_passthrough():</span>
    <span class="s0">&quot;&quot;&quot;Check pipeline.get_feature_names_out with passthrough&quot;&quot;&quot;</span>
    <span class="s1">pipe = Pipeline(</span>
        <span class="s1">steps=[</span>
            <span class="s1">(</span><span class="s3">&quot;names&quot;</span><span class="s2">, </span><span class="s1">FeatureNameSaver())</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;pass&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">LogisticRegression())</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">iris = load_iris()</span>
    <span class="s1">pipe.fit(iris.data</span><span class="s2">, </span><span class="s1">iris.target)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">pipe[:-</span><span class="s4">1</span><span class="s1">].get_feature_names_out(iris.feature_names)</span><span class="s2">, </span><span class="s1">iris.feature_names</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_feature_names_count_vectorizer():</span>
    <span class="s0">&quot;&quot;&quot;Check pipeline.get_feature_names_out with vectorizers&quot;&quot;&quot;</span>
    <span class="s1">pipe = Pipeline(steps=[(</span><span class="s3">&quot;vect&quot;</span><span class="s2">, </span><span class="s1">CountVectorizer())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">LogisticRegression())])</span>
    <span class="s1">y = [</span><span class="s3">&quot;pizza&quot; </span><span class="s2">in </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">JUNK_FOOD_DOCS]</span>
    <span class="s1">pipe.fit(JUNK_FOOD_DOCS</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">pipe[:-</span><span class="s4">1</span><span class="s1">].get_feature_names_out()</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;beer&quot;</span><span class="s2">, </span><span class="s3">&quot;burger&quot;</span><span class="s2">, </span><span class="s3">&quot;coke&quot;</span><span class="s2">, </span><span class="s3">&quot;copyright&quot;</span><span class="s2">, </span><span class="s3">&quot;pizza&quot;</span><span class="s2">, </span><span class="s3">&quot;the&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">pipe[:-</span><span class="s4">1</span><span class="s1">].get_feature_names_out(</span><span class="s3">&quot;nonsense_is_ignored&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;beer&quot;</span><span class="s2">, </span><span class="s3">&quot;burger&quot;</span><span class="s2">, </span><span class="s3">&quot;coke&quot;</span><span class="s2">, </span><span class="s3">&quot;copyright&quot;</span><span class="s2">, </span><span class="s3">&quot;pizza&quot;</span><span class="s2">, </span><span class="s3">&quot;the&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_pipeline_feature_names_out_error_without_definition():</span>
    <span class="s0">&quot;&quot;&quot;Check that error is raised when a transformer does not define 
    `get_feature_names_out`.&quot;&quot;&quot;</span>
    <span class="s1">pipe = Pipeline(steps=[(</span><span class="s3">&quot;notrans&quot;</span><span class="s2">, </span><span class="s1">NoTrans())])</span>
    <span class="s1">iris = load_iris()</span>
    <span class="s1">pipe.fit(iris.data</span><span class="s2">, </span><span class="s1">iris.target)</span>

    <span class="s1">msg = </span><span class="s3">&quot;does not provide get_feature_names_out&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pipe.get_feature_names_out()</span>


<span class="s2">def </span><span class="s1">test_pipeline_param_error():</span>
    <span class="s1">clf = make_pipeline(LogisticRegression())</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Pipeline.fit does not accept the sample_weight parameter&quot;</span>
    <span class="s1">):</span>
        <span class="s1">clf.fit([[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sample_weight=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>


<span class="s1">parameter_grid_test_verbose = (</span>
    <span class="s1">(est</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">method)</span>
    <span class="s2">for </span><span class="s1">(est</span><span class="s2">, </span><span class="s1">pattern)</span><span class="s2">, </span><span class="s1">method </span><span class="s2">in </span><span class="s1">itertools.product(</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">FitParamT())])</span><span class="s2">,</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 1 of 2\) Processing transf.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 2 of 2\) Processing clf.* total=.*\n$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;noop&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">FitParamT())])</span><span class="s2">,</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 1 of 3\) Processing transf.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 2 of 3\) Processing noop.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 3 of 3\) Processing clf.* total=.*\n$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Pipeline(</span>
                    <span class="s1">[</span>
                        <span class="s1">(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s3">&quot;noop&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">FitParamT())</span><span class="s2">,</span>
                    <span class="s1">]</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 1 of 3\) Processing transf.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 2 of 3\) Processing noop.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 3 of 3\) Processing clf.* total=.*\n$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, None</span><span class="s1">)])</span><span class="s2">,</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 1 of 2\) Processing transf.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 2 of 2\) Processing clf.* total=.*\n$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;mult&quot;</span><span class="s2">, </span><span class="s1">Mult())])</span><span class="s2">,</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 1 of 2\) Processing transf.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 2 of 2\) Processing mult.* total=.*\n$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Pipeline([(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;mult&quot;</span><span class="s2">, </span><span class="s1">Mult())])</span><span class="s2">,</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 1 of 2\) Processing transf.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[Pipeline\].*\(step 2 of 2\) Processing mult.* total=.*\n$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">FeatureUnion([(</span><span class="s3">&quot;mult1&quot;</span><span class="s2">, </span><span class="s1">Mult())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;mult2&quot;</span><span class="s2">, </span><span class="s1">Mult())])</span><span class="s2">,</span>
                <span class="s3">r&quot;\[FeatureUnion\].*\(step 1 of 2\) Processing mult1.* total=.*\n&quot;</span>
                <span class="s3">r&quot;\[FeatureUnion\].*\(step 2 of 2\) Processing mult2.* total=.*\n$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">FeatureUnion([(</span><span class="s3">&quot;mult1&quot;</span><span class="s2">, </span><span class="s3">&quot;drop&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;mult2&quot;</span><span class="s2">, </span><span class="s1">Mult())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;mult3&quot;</span><span class="s2">, </span><span class="s3">&quot;drop&quot;</span><span class="s1">)])</span><span class="s2">,</span>
                <span class="s3">r&quot;\[FeatureUnion\].*\(step 1 of 1\) Processing mult2.* total=.*\n$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;fit&quot;</span><span class="s2">, </span><span class="s3">&quot;fit_transform&quot;</span><span class="s2">, </span><span class="s3">&quot;fit_predict&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">hasattr(est</span><span class="s2">, </span><span class="s1">method)</span>
    <span class="s2">and not </span><span class="s1">(</span>
        <span class="s1">method == </span><span class="s3">&quot;fit_transform&quot;</span>
        <span class="s2">and </span><span class="s1">hasattr(est</span><span class="s2">, </span><span class="s3">&quot;steps&quot;</span><span class="s1">)</span>
        <span class="s2">and </span><span class="s1">isinstance(est.steps[-</span><span class="s4">1</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">FitParamT)</span>
    <span class="s1">)</span>
<span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;est, pattern, method&quot;</span><span class="s2">, </span><span class="s1">parameter_grid_test_verbose)</span>
<span class="s2">def </span><span class="s1">test_verbose(est</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">capsys):</span>
    <span class="s1">func = getattr(est</span><span class="s2">, </span><span class="s1">method)</span>

    <span class="s1">X = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]]</span>
    <span class="s1">y = [[</span><span class="s4">7</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">8</span><span class="s1">]]</span>

    <span class="s1">est.set_params(verbose=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">func(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">assert not </span><span class="s1">capsys.readouterr().out</span><span class="s2">, </span><span class="s3">&quot;Got output for verbose=False&quot;</span>

    <span class="s1">est.set_params(verbose=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">func(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">assert </span><span class="s1">re.match(pattern</span><span class="s2">, </span><span class="s1">capsys.readouterr().out)</span>


<span class="s2">def </span><span class="s1">test_n_features_in_pipeline():</span>
    <span class="s5"># make sure pipelines delegate n_features_in to the first step</span>

    <span class="s1">X = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]]</span>
    <span class="s1">y = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

    <span class="s1">ss = StandardScaler()</span>
    <span class="s1">gbdt = HistGradientBoostingClassifier()</span>
    <span class="s1">pipe = make_pipeline(ss</span><span class="s2">, </span><span class="s1">gbdt)</span>
    <span class="s2">assert not </span><span class="s1">hasattr(pipe</span><span class="s2">, </span><span class="s3">&quot;n_features_in_&quot;</span><span class="s1">)</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">assert </span><span class="s1">pipe.n_features_in_ == ss.n_features_in_ == </span><span class="s4">2</span>

    <span class="s5"># if the first step has the n_features_in attribute then the pipeline also</span>
    <span class="s5"># has it, even though it isn't fitted.</span>
    <span class="s1">ss = StandardScaler()</span>
    <span class="s1">gbdt = HistGradientBoostingClassifier()</span>
    <span class="s1">pipe = make_pipeline(ss</span><span class="s2">, </span><span class="s1">gbdt)</span>
    <span class="s1">ss.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">assert </span><span class="s1">pipe.n_features_in_ == ss.n_features_in_ == </span><span class="s4">2</span>
    <span class="s2">assert not </span><span class="s1">hasattr(gbdt</span><span class="s2">, </span><span class="s3">&quot;n_features_in_&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_n_features_in_feature_union():</span>
    <span class="s5"># make sure FeatureUnion delegates n_features_in to the first transformer</span>

    <span class="s1">X = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]]</span>
    <span class="s1">y = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

    <span class="s1">ss = StandardScaler()</span>
    <span class="s1">fu = make_union(ss)</span>
    <span class="s2">assert not </span><span class="s1">hasattr(fu</span><span class="s2">, </span><span class="s3">&quot;n_features_in_&quot;</span><span class="s1">)</span>
    <span class="s1">fu.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">assert </span><span class="s1">fu.n_features_in_ == ss.n_features_in_ == </span><span class="s4">2</span>

    <span class="s5"># if the first step has the n_features_in attribute then the feature_union</span>
    <span class="s5"># also has it, even though it isn't fitted.</span>
    <span class="s1">ss = StandardScaler()</span>
    <span class="s1">fu = make_union(ss)</span>
    <span class="s1">ss.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s2">assert </span><span class="s1">fu.n_features_in_ == ss.n_features_in_ == </span><span class="s4">2</span>


<span class="s2">def </span><span class="s1">test_feature_union_fit_params():</span>
    <span class="s5"># Regression test for issue: #15117</span>
    <span class="s2">class </span><span class="s1">Dummy(TransformerMixin</span><span class="s2">, </span><span class="s1">BaseEstimator):</span>
        <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">**fit_params):</span>
            <span class="s2">if </span><span class="s1">fit_params != {</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s2">def </span><span class="s1">transform(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">X</span>

    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = iris.data</span><span class="s2">, </span><span class="s1">iris.target</span>
    <span class="s1">t = FeatureUnion([(</span><span class="s3">&quot;dummy0&quot;</span><span class="s2">, </span><span class="s1">Dummy())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;dummy1&quot;</span><span class="s2">, </span><span class="s1">Dummy())])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">t.fit(X</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">t.fit_transform(X</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s1">t.fit(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">t.fit_transform(X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_pipeline_missing_values_leniency():</span>
    <span class="s5"># check that pipeline let the missing values validation to</span>
    <span class="s5"># the underlying transformers and predictors.</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = iris.data</span><span class="s2">, </span><span class="s1">iris.target</span>
    <span class="s1">mask = np.random.choice([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">X.shape</span><span class="s2">, </span><span class="s1">p=[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">]).astype(bool)</span>
    <span class="s1">X[mask] = np.nan</span>
    <span class="s1">pipe = make_pipeline(SimpleImputer()</span><span class="s2">, </span><span class="s1">LogisticRegression())</span>
    <span class="s2">assert </span><span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y).score(X</span><span class="s2">, </span><span class="s1">y) &gt; </span><span class="s4">0.4</span>


<span class="s2">def </span><span class="s1">test_feature_union_warns_unknown_transformer_weight():</span>
    <span class="s5"># Warn user when transformer_weights containers a key not present in</span>
    <span class="s5"># transformer_list</span>
    <span class="s1">X = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]]</span>
    <span class="s1">y = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

    <span class="s1">transformer_list = [(</span><span class="s3">&quot;transf&quot;</span><span class="s2">, </span><span class="s1">Transf())]</span>
    <span class="s5"># Transformer weights dictionary with incorrect name</span>
    <span class="s1">weights = {</span><span class="s3">&quot;transformer&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span>
    <span class="s1">expected_msg = (</span>
        <span class="s3">'Attempting to weight transformer &quot;transformer&quot;, '</span>
        <span class="s3">&quot;but it is not present in transformer_list.&quot;</span>
    <span class="s1">)</span>
    <span class="s1">union = FeatureUnion(transformer_list</span><span class="s2">, </span><span class="s1">transformer_weights=weights)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=expected_msg):</span>
        <span class="s1">union.fit(X</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;passthrough&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_pipeline_get_tags_none(passthrough):</span>
    <span class="s5"># Checks that tags are set correctly when the first transformer is None or</span>
    <span class="s5"># 'passthrough'</span>
    <span class="s5"># Non-regression test for:</span>
    <span class="s5"># https://github.com/scikit-learn/scikit-learn/issues/18815</span>
    <span class="s1">pipe = make_pipeline(passthrough</span><span class="s2">, </span><span class="s1">SVC())</span>
    <span class="s2">assert not </span><span class="s1">pipe._get_tags()[</span><span class="s3">&quot;pairwise&quot;</span><span class="s1">]</span>


<span class="s5"># FIXME: Replace this test with a full `check_estimator` once we have API only</span>
<span class="s5"># checks.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;Predictor&quot;</span><span class="s2">, </span><span class="s1">[MinimalRegressor</span><span class="s2">, </span><span class="s1">MinimalClassifier])</span>
<span class="s2">def </span><span class="s1">test_search_cv_using_minimal_compatible_estimator(Predictor):</span>
    <span class="s5"># Check that third-party library estimators can be part of a pipeline</span>
    <span class="s5"># and tuned by grid-search without inheriting from BaseEstimator.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = rng.randn(</span><span class="s4">25</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">5 </span><span class="s1">+ [</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">20</span><span class="s1">)</span>

    <span class="s1">model = Pipeline(</span>
        <span class="s1">[(</span><span class="s3">&quot;transformer&quot;</span><span class="s2">, </span><span class="s1">MinimalTransformer())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;predictor&quot;</span><span class="s2">, </span><span class="s1">Predictor())]</span>
    <span class="s1">)</span>
    <span class="s1">model.fit(X</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s1">y_pred = model.predict(X)</span>
    <span class="s2">if </span><span class="s1">is_classifier(model):</span>
        <span class="s1">assert_array_equal(y_pred</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">model.score(X</span><span class="s2">, </span><span class="s1">y) == pytest.approx(accuracy_score(y</span><span class="s2">, </span><span class="s1">y_pred))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">assert_allclose(y_pred</span><span class="s2">, </span><span class="s1">y.mean())</span>
        <span class="s2">assert </span><span class="s1">model.score(X</span><span class="s2">, </span><span class="s1">y) == pytest.approx(r2_score(y</span><span class="s2">, </span><span class="s1">y_pred))</span>


<span class="s2">def </span><span class="s1">test_pipeline_check_if_fitted():</span>
    <span class="s2">class </span><span class="s1">Estimator(BaseEstimator):</span>
        <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y):</span>
            <span class="s1">self.fitted_ = </span><span class="s2">True</span>
            <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">pipeline = Pipeline([(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">Estimator())])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotFittedError):</span>
        <span class="s1">check_is_fitted(pipeline)</span>
    <span class="s1">pipeline.fit(iris.data</span><span class="s2">, </span><span class="s1">iris.target)</span>
    <span class="s1">check_is_fitted(pipeline)</span>


<span class="s2">def </span><span class="s1">test_feature_union_check_if_fitted():</span>
    <span class="s0">&quot;&quot;&quot;Check __sklearn_is_fitted__ is defined correctly.&quot;&quot;&quot;</span>

    <span class="s1">X = [[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]]</span>
    <span class="s1">y = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

    <span class="s1">union = FeatureUnion([(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">MinimalTransformer())])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotFittedError):</span>
        <span class="s1">check_is_fitted(union)</span>

    <span class="s1">union.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">check_is_fitted(union)</span>

    <span class="s5"># passthrough is stateless</span>
    <span class="s1">union = FeatureUnion([(</span><span class="s3">&quot;pass&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)])</span>
    <span class="s1">check_is_fitted(union)</span>

    <span class="s1">union = FeatureUnion([(</span><span class="s3">&quot;clf&quot;</span><span class="s2">, </span><span class="s1">MinimalTransformer())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;pass&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotFittedError):</span>
        <span class="s1">check_is_fitted(union)</span>

    <span class="s1">union.fit(X</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">check_is_fitted(union)</span>


<span class="s2">def </span><span class="s1">test_pipeline_get_feature_names_out_passes_names_through():</span>
    <span class="s0">&quot;&quot;&quot;Check that pipeline passes names through. 
 
    Non-regresion test for #21349. 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = iris.data</span><span class="s2">, </span><span class="s1">iris.target</span>

    <span class="s2">class </span><span class="s1">AddPrefixStandardScalar(StandardScaler):</span>
        <span class="s2">def </span><span class="s1">get_feature_names_out(self</span><span class="s2">, </span><span class="s1">input_features=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s1">names = super().get_feature_names_out(input_features=input_features)</span>
            <span class="s2">return </span><span class="s1">np.asarray([</span><span class="s3">f&quot;my_prefix_</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

    <span class="s1">pipe = make_pipeline(AddPrefixStandardScalar()</span><span class="s2">, </span><span class="s1">StandardScaler())</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s1">input_names = iris.feature_names</span>
    <span class="s1">feature_names_out = pipe.get_feature_names_out(input_names)</span>

    <span class="s1">assert_array_equal(feature_names_out</span><span class="s2">, </span><span class="s1">[</span><span class="s3">f&quot;my_prefix_</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">input_names])</span>


<span class="s2">def </span><span class="s1">test_pipeline_set_output_integration():</span>
    <span class="s0">&quot;&quot;&quot;Test pipeline's set_output with feature names.&quot;&quot;&quot;</span>
    <span class="s1">pytest.importorskip(</span><span class="s3">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">X</span><span class="s2">, </span><span class="s1">y = load_iris(as_frame=</span><span class="s2">True, </span><span class="s1">return_X_y=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">pipe = make_pipeline(StandardScaler()</span><span class="s2">, </span><span class="s1">LogisticRegression())</span>
    <span class="s1">pipe.set_output(transform=</span><span class="s3">&quot;pandas&quot;</span><span class="s1">)</span>
    <span class="s1">pipe.fit(X</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s1">feature_names_in_ = pipe[:-</span><span class="s4">1</span><span class="s1">].get_feature_names_out()</span>
    <span class="s1">log_reg_feature_names = pipe[-</span><span class="s4">1</span><span class="s1">].feature_names_in_</span>

    <span class="s1">assert_array_equal(feature_names_in_</span><span class="s2">, </span><span class="s1">log_reg_feature_names)</span>


<span class="s2">def </span><span class="s1">test_feature_union_set_output():</span>
    <span class="s0">&quot;&quot;&quot;Test feature union with set_output API.&quot;&quot;&quot;</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s3">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">X</span><span class="s2">, </span><span class="s1">_ = load_iris(as_frame=</span><span class="s2">True, </span><span class="s1">return_X_y=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_test = train_test_split(X</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">union = FeatureUnion([(</span><span class="s3">&quot;scalar&quot;</span><span class="s2">, </span><span class="s1">StandardScaler())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">PCA())])</span>
    <span class="s1">union.set_output(transform=</span><span class="s3">&quot;pandas&quot;</span><span class="s1">)</span>
    <span class="s1">union.fit(X_train)</span>

    <span class="s1">X_trans = union.transform(X_test)</span>
    <span class="s2">assert </span><span class="s1">isinstance(X_trans</span><span class="s2">, </span><span class="s1">pd.DataFrame)</span>
    <span class="s1">assert_array_equal(X_trans.columns</span><span class="s2">, </span><span class="s1">union.get_feature_names_out())</span>
    <span class="s1">assert_array_equal(X_trans.index</span><span class="s2">, </span><span class="s1">X_test.index)</span>


<span class="s2">def </span><span class="s1">test_feature_union_getitem():</span>
    <span class="s0">&quot;&quot;&quot;Check FeatureUnion.__getitem__ returns expected results.&quot;&quot;&quot;</span>
    <span class="s1">scalar = StandardScaler()</span>
    <span class="s1">pca = PCA()</span>
    <span class="s1">union = FeatureUnion(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;scalar&quot;</span><span class="s2">, </span><span class="s1">scalar)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">pca)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;pass&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;drop_me&quot;</span><span class="s2">, </span><span class="s3">&quot;drop&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">union[</span><span class="s3">&quot;scalar&quot;</span><span class="s1">] </span><span class="s2">is </span><span class="s1">scalar</span>
    <span class="s2">assert </span><span class="s1">union[</span><span class="s3">&quot;pca&quot;</span><span class="s1">] </span><span class="s2">is </span><span class="s1">pca</span>
    <span class="s2">assert </span><span class="s1">union[</span><span class="s3">&quot;pass&quot;</span><span class="s1">] == </span><span class="s3">&quot;passthrough&quot;</span>
    <span class="s2">assert </span><span class="s1">union[</span><span class="s3">&quot;drop_me&quot;</span><span class="s1">] == </span><span class="s3">&quot;drop&quot;</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;key&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_feature_union_getitem_error(key):</span>
    <span class="s0">&quot;&quot;&quot;Raise error when __getitem__ gets a non-string input.&quot;&quot;&quot;</span>

    <span class="s1">union = FeatureUnion([(</span><span class="s3">&quot;scalar&quot;</span><span class="s2">, </span><span class="s1">StandardScaler())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;pca&quot;</span><span class="s2">, </span><span class="s1">PCA())])</span>

    <span class="s1">msg = </span><span class="s3">&quot;Only string keys are supported&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(KeyError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">union[key]</span>


<span class="s2">def </span><span class="s1">test_feature_union_feature_names_in_():</span>
    <span class="s0">&quot;&quot;&quot;Ensure feature union has `.feature_names_in_` attribute if `X` has a 
    `columns` attribute. 
 
    Test for #24754. 
    &quot;&quot;&quot;</span>
    <span class="s1">pytest.importorskip(</span><span class="s3">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">X</span><span class="s2">, </span><span class="s1">_ = load_iris(as_frame=</span><span class="s2">True, </span><span class="s1">return_X_y=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s5"># FeatureUnion should have the feature_names_in_ attribute if the</span>
    <span class="s5"># first transformer also has it</span>
    <span class="s1">scaler = StandardScaler()</span>
    <span class="s1">scaler.fit(X)</span>
    <span class="s1">union = FeatureUnion([(</span><span class="s3">&quot;scale&quot;</span><span class="s2">, </span><span class="s1">scaler)])</span>
    <span class="s2">assert </span><span class="s1">hasattr(union</span><span class="s2">, </span><span class="s3">&quot;feature_names_in_&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(X.columns</span><span class="s2">, </span><span class="s1">union.feature_names_in_)</span>
    <span class="s1">assert_array_equal(scaler.feature_names_in_</span><span class="s2">, </span><span class="s1">union.feature_names_in_)</span>

    <span class="s5"># fit with pandas.DataFrame</span>
    <span class="s1">union = FeatureUnion([(</span><span class="s3">&quot;pass&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)])</span>
    <span class="s1">union.fit(X)</span>
    <span class="s2">assert </span><span class="s1">hasattr(union</span><span class="s2">, </span><span class="s3">&quot;feature_names_in_&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(X.columns</span><span class="s2">, </span><span class="s1">union.feature_names_in_)</span>

    <span class="s5"># fit with numpy array</span>
    <span class="s1">X_array = X.to_numpy()</span>
    <span class="s1">union = FeatureUnion([(</span><span class="s3">&quot;pass&quot;</span><span class="s2">, </span><span class="s3">&quot;passthrough&quot;</span><span class="s1">)])</span>
    <span class="s1">union.fit(X_array)</span>
    <span class="s2">assert not </span><span class="s1">hasattr(union</span><span class="s2">, </span><span class="s3">&quot;feature_names_in_&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>