<html>
<head>
<title>test_multivariate_switch_univariate.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_multivariate_switch_univariate.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for automatic switching of the filter method from multivariate to 
univariate when the forecast error covariance matrix is singular. 
 
Author: Chad Fulton 
License: Simplified-BSD 
 
References 
---------- 
 
Kim, Chang-Jin, and Charles R. Nelson. 1999. 
&quot;State-Space Models with Regime Switching: 
Classical and Gibbs-Sampling Approaches with Applications&quot;. 
MIT Press Books. The MIT Press. 
 
Hamilton, James D. 1994. 
Time Series Analysis. 
Princeton, N.J.: Princeton University Press. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">mlemodel</span><span class="s2">, </span><span class="s1">sarimax</span><span class="s2">, </span><span class="s1">structural</span><span class="s2">, </span><span class="s1">varmax</span><span class="s2">, </span><span class="s1">dynamic_factor)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.tests.test_impulse_responses </span><span class="s2">import </span><span class="s1">TVSS</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_allclose</span>


<span class="s2">def </span><span class="s1">get_model(univariate</span><span class="s2">, </span><span class="s1">missing=</span><span class="s2">None, </span><span class="s1">init=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">univariate:</span>
        <span class="s1">endog = np.array([</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">1.4</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'init'</span><span class="s1">:</span>
            <span class="s1">endog[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
            <span class="s1">endog[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">4</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'all'</span><span class="s1">:</span>
            <span class="s1">endog[:] = np.nan</span>

        <span class="s1">mod = mlemodel.MLEModel(endog</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.</span>
        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0.5</span>
        <span class="s1">mod[</span><span class="s4">'selection'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.</span>
        <span class="s1">mod[</span><span class="s4">'state_cov'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.</span>
        <span class="s1">mod[</span><span class="s4">'state_intercept'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog = np.array([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">1.4</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.01</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.13</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]]).T</span>

        <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'init'</span><span class="s1">:</span>
            <span class="s1">endog[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
        <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
            <span class="s1">endog[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">4</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = np.nan</span>
            <span class="s1">endog[</span><span class="s3">3</span><span class="s1">:</span><span class="s3">6</span><span class="s2">, </span><span class="s3">1</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'all'</span><span class="s1">:</span>
            <span class="s1">endog[:] = np.nan</span>

        <span class="s1">mod = mlemodel.MLEModel(endog</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'obs_intercept'</span><span class="s1">] = np.array([</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.2</span><span class="s1">])</span>
        <span class="s1">mod[</span><span class="s4">'design'</span><span class="s1">] = np.array([[</span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'obs_cov'</span><span class="s1">] = np.array([[</span><span class="s3">5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">,</span>
                                   <span class="s1">[-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">3.</span><span class="s1">]])</span>

        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1</span>
        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] = np.array([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">,</span>
                                              <span class="s1">[</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'selection'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">] = np.eye(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'state_cov'</span><span class="s1">] = np.array([[</span><span class="s3">1.2</span><span class="s2">, </span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">2.5</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'state_intercept'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">] = np.array([</span><span class="s3">1.</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1.</span><span class="s1">])</span>

    <span class="s2">if </span><span class="s1">init == </span><span class="s4">'diffuse'</span><span class="s1">:</span>
        <span class="s1">mod.ssm.initialize_diffuse()</span>
    <span class="s2">elif </span><span class="s1">init == </span><span class="s4">'approximate_diffuse'</span><span class="s1">:</span>
        <span class="s1">mod.ssm.initialize_approximate_diffuse()</span>
    <span class="s2">elif </span><span class="s1">init == </span><span class="s4">'stationary'</span><span class="s1">:</span>
        <span class="s1">mod.ssm.initialize_stationary()</span>

    <span class="s2">return </span><span class="s1">mod</span>


<span class="s2">def </span><span class="s1">check_filter_output(mod</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">isinstance(mod</span><span class="s2">, </span><span class="s1">mlemodel.MLEModel):</span>
        <span class="s5"># Multivariate filter</span>
        <span class="s1">res_mv = mod.ssm.filter()</span>

        <span class="s5"># Manually perform filtering with a switch</span>
        <span class="s1">mod.ssm.filter()</span>
        <span class="s1">kfilter = mod.ssm._kalman_filter</span>
        <span class="s1">kfilter.seek(</span><span class="s3">0</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">kfilter.univariate_filter[periods] = </span><span class="s3">1</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(mod.nobs):</span>
            <span class="s1">next(kfilter)</span>
        <span class="s5"># Create the results object</span>
        <span class="s1">res_switch = mod.ssm.results_class(mod.ssm)</span>
        <span class="s1">res_switch.update_representation(mod.ssm)</span>
        <span class="s1">res_switch.update_filter(kfilter)</span>

        <span class="s5"># Univariate filter</span>
        <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">res_uv = mod.ssm.filter()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">res_mv</span><span class="s2">, </span><span class="s1">res_switch</span><span class="s2">, </span><span class="s1">res_uv = mod</span>

    <span class="s5"># Test attributes that are the same regardless of the univariate or</span>
    <span class="s5"># multivariate method</span>
    <span class="s1">assert_allclose(res_switch.llf</span><span class="s2">, </span><span class="s1">res_mv.llf)</span>
    <span class="s1">assert_allclose(res_switch.llf</span><span class="s2">, </span><span class="s1">res_uv.llf)</span>
    <span class="s1">assert_allclose(res_switch.scale</span><span class="s2">, </span><span class="s1">res_mv.scale)</span>
    <span class="s1">assert_allclose(res_switch.scale</span><span class="s2">, </span><span class="s1">res_uv.scale)</span>

    <span class="s1">attrs = [</span><span class="s4">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s4">'predicted_state'</span><span class="s2">,</span>
             <span class="s4">'predicted_state_cov'</span><span class="s2">, </span><span class="s4">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
             <span class="s4">'filtered_state'</span><span class="s2">, </span><span class="s4">'filtered_state_cov'</span><span class="s2">, </span><span class="s4">'llf_obs'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">attr_mv = getattr(res_mv</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">attr_uv = getattr(res_uv</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">attr_switch = getattr(res_switch</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">attr_mv </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">continue</span>
        <span class="s1">assert_allclose(attr_switch</span><span class="s2">, </span><span class="s1">attr_mv</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(attr_switch</span><span class="s2">, </span><span class="s1">attr_uv</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s5"># Test attributes that can differ for the univariate vs multivariate method</span>
    <span class="s1">attrs = [</span><span class="s4">'forecasts_error'</span><span class="s2">, </span><span class="s4">'forecasts_error_cov'</span><span class="s2">, </span><span class="s4">'kalman_gain'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s5"># Test all periods against the multivariate filter, except for periods</span>
        <span class="s5"># that were switched (it's easiest to just set those values to zero)</span>
        <span class="s1">actual = getattr(res_switch</span><span class="s2">, </span><span class="s1">attr).copy()</span>
        <span class="s1">desired = getattr(res_mv</span><span class="s2">, </span><span class="s1">attr).copy()</span>
        <span class="s1">actual[...</span><span class="s2">, </span><span class="s1">periods] = </span><span class="s3">0</span>
        <span class="s1">desired[...</span><span class="s2">, </span><span class="s1">periods] = </span><span class="s3">0</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s5"># Test switched periods against the univariate filter</span>
        <span class="s1">actual = getattr(res_switch</span><span class="s2">, </span><span class="s1">attr)[...</span><span class="s2">, </span><span class="s1">periods]</span>
        <span class="s1">desired = getattr(res_uv</span><span class="s2">, </span><span class="s1">attr)[...</span><span class="s2">, </span><span class="s1">periods]</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s2">def </span><span class="s1">check_smoother_output(mod</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">isinstance(mod</span><span class="s2">, </span><span class="s1">mlemodel.MLEModel):</span>
        <span class="s5"># Multivariate filter / smoother</span>
        <span class="s1">res_mv = mod.ssm.smooth()</span>

        <span class="s5"># Manually perform filtering / smoothing with a switch</span>
        <span class="s1">kfilter = mod.ssm._kalman_filter</span>
        <span class="s1">kfilter.seek(</span><span class="s3">0</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">kfilter.univariate_filter[periods] = </span><span class="s3">1</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(mod.nobs):</span>
            <span class="s1">next(kfilter)</span>
        <span class="s5"># Create the results object</span>
        <span class="s1">res_switch = mod.ssm.results_class(mod.ssm)</span>
        <span class="s1">res_switch.update_representation(mod.ssm)</span>
        <span class="s1">res_switch.update_filter(kfilter)</span>
        <span class="s1">mod.ssm._kalman_smoother.reset(</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">smoother = mod.ssm._smooth()</span>
        <span class="s1">res_switch.update_smoother(smoother)</span>

        <span class="s5"># Univariate filter / smoother</span>
        <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">res_uv = mod.ssm.smooth()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">res_mv</span><span class="s2">, </span><span class="s1">res_switch</span><span class="s2">, </span><span class="s1">res_uv = mod</span>

    <span class="s5"># Test attributes that are the same regardless of the univariate or</span>
    <span class="s5"># multivariate method</span>
    <span class="s1">attrs = [</span><span class="s4">'scaled_smoothed_estimator'</span><span class="s2">, </span><span class="s4">'scaled_smoothed_estimator_cov'</span><span class="s2">,</span>
             <span class="s4">'smoothed_state'</span><span class="s2">, </span><span class="s4">'smoothed_state_cov'</span><span class="s2">, </span><span class="s4">'smoothed_state_autocov'</span><span class="s2">,</span>
             <span class="s4">'smoothed_state_disturbance'</span><span class="s2">, </span><span class="s4">'smoothed_state_disturbance_cov'</span><span class="s2">,</span>
             <span class="s4">'innovations_transition'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">attr_mv = getattr(res_mv</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">attr_uv = getattr(res_uv</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">attr_switch = getattr(res_switch</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">attr_mv </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">continue</span>
        <span class="s1">assert_allclose(attr_uv</span><span class="s2">, </span><span class="s1">attr_mv</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(attr_switch</span><span class="s2">, </span><span class="s1">attr_mv</span><span class="s2">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(attr_switch</span><span class="s2">, </span><span class="s1">attr_uv</span><span class="s2">, </span><span class="s1">atol=atol)</span>

    <span class="s5"># Test attributes that can differ for the univariate vs multivariate method</span>
    <span class="s1">attrs = [</span><span class="s4">'smoothing_error'</span><span class="s2">, </span><span class="s4">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
             <span class="s4">'smoothed_measurement_disturbance_cov'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">attr_mv = getattr(res_mv</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">attr_uv = getattr(res_uv</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">attr_switch = getattr(res_switch</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">attr_mv </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">continue</span>

        <span class="s5"># Test all periods against the multivariate filter, except for periods</span>
        <span class="s5"># that were switched (it's easiest to just set those values to zero)</span>
        <span class="s1">actual = attr_switch.copy()</span>
        <span class="s1">desired = attr_mv.copy()</span>
        <span class="s1">actual[...</span><span class="s2">, </span><span class="s1">periods] = </span><span class="s3">0</span>
        <span class="s1">desired[...</span><span class="s2">, </span><span class="s1">periods] = </span><span class="s3">0</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'missing'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'init'</span><span class="s2">, </span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s4">'all'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_basic(missing):</span>
    <span class="s5"># Test that the multivariate filter switches to the univariate filter</span>
    <span class="s5"># when it runs into problems</span>
    <span class="s1">mod = get_model(univariate=</span><span class="s2">True, </span><span class="s1">missing=missing)</span>

    <span class="s5"># Here, because of the known initialization with P_0 = [[0]], we will also</span>
    <span class="s5"># have F_0 = 0.</span>
    <span class="s5"># Then the Kalman filter gives P_0|0 = 0, and P_1 = Q = [[1.]]</span>
    <span class="s5"># so that F_1 != 0, and the rest of the periods do not have a singular</span>
    <span class="s5"># forecast error covariance matrix.</span>
    <span class="s1">mod.initialize_known([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">mod.ssm.filter()</span>
    <span class="s1">uf = np.array(mod.ssm._kalman_filter.univariate_filter)</span>

    <span class="s5"># As a result, we expect that in the period t=0, we had to fall back to the</span>
    <span class="s5"># univariate filter, while in the periods t &gt;= 1, the multivariate filter</span>
    <span class="s5"># works as usual.</span>
    <span class="s5"># However, if the first period is missing (as in init and all), then we</span>
    <span class="s5"># essentially skip the forecast error and forecast error cov computation.</span>
    <span class="s5"># As a result, we don't need to switch to the univariate methods</span>
    <span class="s2">if </span><span class="s1">missing </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'init'</span><span class="s2">, </span><span class="s4">'all'</span><span class="s1">]:</span>
        <span class="s1">assert_allclose(uf</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">assert_allclose(uf[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(uf[</span><span class="s3">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'univariate'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'missing'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'init'</span><span class="s2">, </span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s4">'all'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">'init'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">'stationary'</span><span class="s2">, </span><span class="s4">'diffuse'</span><span class="s2">, </span><span class="s4">'approximate_diffuse'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'periods'</span><span class="s2">, </span><span class="s1">[np.s_[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[:]])</span>
<span class="s2">def </span><span class="s1">test_filter_output(univariate</span><span class="s2">, </span><span class="s1">missing</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">periods):</span>
    <span class="s5"># Test the output when the multivariate filter switches to the univariate</span>
    <span class="s5"># filter</span>
    <span class="s1">mod = get_model(univariate</span><span class="s2">, </span><span class="s1">missing</span><span class="s2">, </span><span class="s1">init)</span>
    <span class="s1">check_filter_output(mod</span><span class="s2">, </span><span class="s1">periods)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'univariate'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'missing'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'init'</span><span class="s2">, </span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s4">'all'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'init'</span><span class="s2">,</span>
                         <span class="s1">[</span><span class="s4">'stationary'</span><span class="s2">, </span><span class="s4">'diffuse'</span><span class="s2">, </span><span class="s4">'approximate_diffuse'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'periods'</span><span class="s2">, </span><span class="s1">[np.s_[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[:]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'option'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'alternate_timing'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_smoother_output(univariate</span><span class="s2">, </span><span class="s1">missing</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">option):</span>
    <span class="s5"># Test the output when the multivariate filter switches to the univariate</span>
    <span class="s5"># filter</span>

    <span class="s1">mod = get_model(univariate</span><span class="s2">, </span><span class="s1">missing</span><span class="s2">, </span><span class="s1">init)</span>
    <span class="s2">if </span><span class="s1">option == </span><span class="s4">'alternate_timing'</span><span class="s1">:</span>
        <span class="s5"># Can't use diffuse initialization with alternate timing</span>
        <span class="s2">if </span><span class="s1">init == </span><span class="s4">'diffuse'</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">mod.ssm.timing_init_filtered = </span><span class="s2">True</span>
    <span class="s1">atol = </span><span class="s3">1e-12</span>
    <span class="s5"># Tolerance is lower for approximate diffuse for one attribute in this case</span>
    <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'init' </span><span class="s2">and </span><span class="s1">init == </span><span class="s4">'approximate_diffuse'</span><span class="s1">:</span>
        <span class="s1">atol = </span><span class="s3">1e-6</span>
    <span class="s1">check_smoother_output(mod</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s2">def </span><span class="s1">test_invalid_options():</span>
    <span class="s1">mod = get_model(univariate=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod.initialize_known([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s1">]])</span>

    <span class="s1">mod.ssm.set_inversion_method(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">solve_lu=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">msg = (</span><span class="s4">'Singular forecast error covariance matrix detected, but'</span>
           <span class="s4">' multivariate filter cannot fall back to univariate'</span>
           <span class="s4">' filter when the inversion method is set to anything'</span>
           <span class="s4">' other than INVERT_UNIVARIATE or SOLVE_CHOLESKY.'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">mod.ssm.filter()</span>

    <span class="s1">mod = get_model(univariate=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod.initialize_known([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">mod.ssm.smooth_classical = </span><span class="s2">True</span>
    <span class="s1">msg = (</span><span class="s4">'Cannot use classical smoothing when the multivariate filter has'</span>
           <span class="s4">' fallen back to univariate filtering.'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">mod.ssm.smooth()</span>

    <span class="s1">mod = get_model(univariate=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod.initialize_known([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">mod.ssm.smooth_alternative = </span><span class="s2">True</span>
    <span class="s1">msg = (</span><span class="s4">'Cannot use alternative smoothing when the multivariate filter has'</span>
           <span class="s4">' fallen back to univariate filtering.'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">mod.ssm.smooth()</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'missing'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'init'</span><span class="s2">, </span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s4">'all'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'periods'</span><span class="s2">, </span><span class="s1">[np.s_[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[:]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'use_exact_diffuse'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_sarimax(missing</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">use_exact_diffuse):</span>
    <span class="s1">endog = np.array([</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">1.4</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">])</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'init'</span><span class="s1">:</span>
        <span class="s1">endog[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s1">] = np.nan</span>
    <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
        <span class="s1">endog[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">4</span><span class="s1">] = np.nan</span>
    <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'all'</span><span class="s1">:</span>
        <span class="s1">endog[:] = np.nan</span>

    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'t'</span><span class="s2">,</span>
                          <span class="s1">seasonal_order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                          <span class="s1">use_exact_diffuse=use_exact_diffuse)</span>
    <span class="s1">mod.update([</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">])</span>
    <span class="s1">check_filter_output(mod</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>
    <span class="s1">check_smoother_output(mod</span><span class="s2">, </span><span class="s1">periods)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'missing'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'init'</span><span class="s2">, </span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s4">'all'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'periods'</span><span class="s2">, </span><span class="s1">[np.s_[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[:]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'use_exact_diffuse'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_unobserved_components(missing</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">use_exact_diffuse):</span>
    <span class="s1">endog = np.array([</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">1.4</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">])</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'init'</span><span class="s1">:</span>
        <span class="s1">endog[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s1">] = np.nan</span>
    <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
        <span class="s1">endog[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">4</span><span class="s1">] = np.nan</span>
    <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'all'</span><span class="s1">:</span>
        <span class="s1">endog[:] = np.nan</span>

    <span class="s1">mod = structural.UnobservedComponents(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s4">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">autoregressive=</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">use_exact_diffuse=use_exact_diffuse)</span>
    <span class="s1">mod.update([</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s3">0.15</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">])</span>
    <span class="s1">check_filter_output(mod</span><span class="s2">, </span><span class="s1">periods)</span>
    <span class="s1">check_smoother_output(mod</span><span class="s2">, </span><span class="s1">periods)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'missing'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'init'</span><span class="s2">, </span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s4">'all'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'periods'</span><span class="s2">, </span><span class="s1">[np.s_[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[:]])</span>
<span class="s2">def </span><span class="s1">test_varmax(missing</span><span class="s2">, </span><span class="s1">periods):</span>
    <span class="s1">endog = np.array([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">1.4</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.01</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.13</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]]).T</span>
    <span class="s1">exog = np.ones_like(endog[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'init'</span><span class="s1">:</span>
        <span class="s1">endog[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
        <span class="s1">endog[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">4</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = np.nan</span>
        <span class="s1">endog[</span><span class="s3">3</span><span class="s1">:</span><span class="s3">6</span><span class="s2">, </span><span class="s3">1</span><span class="s1">] = np.nan</span>
    <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'all'</span><span class="s1">:</span>
        <span class="s1">endog[:] = np.nan</span>

    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'t'</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">mod.update([</span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.05</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.25</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">2.3</span><span class="s1">])</span>
    <span class="s1">check_filter_output(mod</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s1">)</span>
    <span class="s1">check_smoother_output(mod</span><span class="s2">, </span><span class="s1">periods)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'missing'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'init'</span><span class="s2">, </span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s4">'all'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'periods'</span><span class="s2">, </span><span class="s1">[np.s_[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.s_[:]])</span>
<span class="s2">def </span><span class="s1">test_dynamic_factor(missing</span><span class="s2">, </span><span class="s1">periods):</span>
    <span class="s1">endog = np.array([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">1.4</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.01</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.13</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]]).T</span>
    <span class="s1">exog = np.ones_like(endog[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'init'</span><span class="s1">:</span>
        <span class="s1">endog[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
        <span class="s1">endog[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">4</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = np.nan</span>
        <span class="s1">endog[</span><span class="s3">3</span><span class="s1">:</span><span class="s3">6</span><span class="s2">, </span><span class="s3">1</span><span class="s1">] = np.nan</span>
    <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'all'</span><span class="s1">:</span>
        <span class="s1">endog[:] = np.nan</span>

    <span class="s1">mod = dynamic_factor.DynamicFactor(endog</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s3">2</span><span class="s2">,</span>
                                       <span class="s1">exog=exog)</span>
    <span class="s1">mod.update([</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s3">2.3</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">])</span>
    <span class="s1">check_filter_output(mod</span><span class="s2">, </span><span class="s1">periods)</span>
    <span class="s1">check_smoother_output(mod</span><span class="s2">, </span><span class="s1">periods)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'missing'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s4">'mixed'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_simulation_smoothing(missing):</span>
    <span class="s5"># Test that the simulation smoother works when the multivariate filter</span>
    <span class="s5"># switches to the univariate filter when it runs into problems</span>
    <span class="s5"># (see test_basic for a description of the model used here)</span>

    <span class="s5"># Get the model where switching will occur</span>
    <span class="s1">mod_switch = get_model(univariate=</span><span class="s2">True, </span><span class="s1">missing=missing)</span>
    <span class="s1">mod_switch.initialize_known([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">sim_switch = mod_switch.simulation_smoother()</span>

    <span class="s5"># Get the model where we have specified univariate filtering (so there is</span>
    <span class="s5"># no need to switch)</span>
    <span class="s1">mod_uv = get_model(univariate=</span><span class="s2">True, </span><span class="s1">missing=missing)</span>
    <span class="s1">mod_uv.initialize_known([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">mod_uv.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">sim_uv = mod_uv.simulation_smoother()</span>

    <span class="s5"># Test for basic simulationg of a new observed series</span>
    <span class="s1">simulate_switch = mod_switch.simulate([]</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">simulate_uv = mod_uv.simulate([]</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">assert_allclose(simulate_switch</span><span class="s2">, </span><span class="s1">simulate_uv)</span>

    <span class="s5"># Perform simulation smoothing</span>
    <span class="s1">sim_switch.simulate(random_state=</span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">sim_uv.simulate(random_state=</span><span class="s3">1234</span><span class="s1">)</span>

    <span class="s5"># Make sure that switching happened in the first model but not the second</span>
    <span class="s1">kfilter = sim_switch._simulation_smoother.simulated_kfilter</span>
    <span class="s1">uf_switch = np.array(kfilter.univariate_filter</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(uf_switch[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(uf_switch[</span><span class="s3">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">kfilter = sim_uv._simulation_smoother.simulated_kfilter.univariate_filter</span>
    <span class="s1">uf_uv = np.array(kfilter</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(uf_uv</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
        <span class="s1">kfilter = (sim_switch._simulation_smoother</span>
                             <span class="s1">.secondary_simulated_kfilter.univariate_filter)</span>
        <span class="s1">uf_switch = np.array(kfilter</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(uf_switch[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(uf_switch[</span><span class="s3">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">kfilter = (sim_uv._simulation_smoother</span>
                         <span class="s1">.secondary_simulated_kfilter.univariate_filter)</span>
        <span class="s1">uf_uv = np.array(kfilter</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(uf_uv</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s5"># Test all simulation smoothing output</span>
    <span class="s1">attrs = [</span><span class="s4">'generated_measurement_disturbance'</span><span class="s2">,</span>
             <span class="s4">'generated_state_disturbance'</span><span class="s2">, </span><span class="s4">'generated_obs'</span><span class="s2">, </span><span class="s4">'generated_state'</span><span class="s2">,</span>
             <span class="s4">'simulated_state'</span><span class="s2">, </span><span class="s4">'simulated_measurement_disturbance'</span><span class="s2">,</span>
             <span class="s4">'simulated_state_disturbance'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">assert_allclose(getattr(sim_switch</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(sim_uv</span><span class="s2">, </span><span class="s1">attr))</span>


<span class="s2">def </span><span class="s1">test_time_varying_model(reset_randomstate):</span>
    <span class="s1">endog = np.array([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">1.4</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.01</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.13</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]]).T</span>

    <span class="s5"># The basic model switches to the univariate method at observation 3,</span>
    <span class="s5"># because the forecast error covariance matrix will have a singular</span>
    <span class="s5"># component corresponding to the first endog variable</span>
    <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">mod_switch = TVSS(endog)</span>
    <span class="s1">mod_switch[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">0</span>
    <span class="s1">mod_switch[</span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">0</span>
    <span class="s1">mod_switch[</span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">1.</span>
    <span class="s1">res_switch = mod_switch.ssm.smooth()</span>
    <span class="s1">kfilter = mod_switch.ssm._kalman_filter</span>
    <span class="s1">uf_switch = np.array(kfilter.univariate_filter</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s5"># Next, this model only uses the univariate method</span>
    <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">mod_uv = TVSS(endog)</span>
    <span class="s1">mod_uv[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">0</span>
    <span class="s1">mod_uv[</span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">0</span>
    <span class="s1">mod_uv[</span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">1.</span>
    <span class="s1">mod_uv.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res_uv = mod_uv.ssm.smooth()</span>
    <span class="s1">kfilter = mod_uv.ssm._kalman_filter</span>
    <span class="s1">uf_uv = np.array(kfilter.univariate_filter</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s5"># Finally, this model uses the multivariate method and gets around the</span>
    <span class="s5"># issue by setting the endog variable to NaN that would have contributed</span>
    <span class="s5"># to the singular part of the forecast error covariance matrix</span>
    <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">endog_mv = endog.copy()</span>
    <span class="s1">endog_mv[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = np.nan</span>
    <span class="s1">mod_mv = TVSS(endog_mv)</span>
    <span class="s1">mod_mv[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">0</span>
    <span class="s1">mod_mv[</span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">0</span>
    <span class="s1">mod_mv[</span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">] = </span><span class="s3">1.</span>
    <span class="s1">res_mv = mod_mv.ssm.smooth()</span>
    <span class="s1">kfilter = mod_mv.ssm._kalman_filter</span>
    <span class="s1">uf_mv = np.array(kfilter.univariate_filter</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s5"># Make sure that switching happened in the switch model but not in the</span>
    <span class="s5"># other two models</span>
    <span class="s1">assert_allclose(uf_switch[:</span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(uf_switch[</span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(uf_switch[</span><span class="s3">4</span><span class="s1">:]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(uf_uv</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(uf_mv</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s5"># Check filter and smoother output</span>
    <span class="s1">check_filter_output([res_mv</span><span class="s2">, </span><span class="s1">res_switch</span><span class="s2">, </span><span class="s1">res_uv]</span><span class="s2">, </span><span class="s1">np.s_[</span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">check_smoother_output([res_mv</span><span class="s2">, </span><span class="s1">res_switch</span><span class="s2">, </span><span class="s1">res_uv]</span><span class="s2">, </span><span class="s1">np.s_[</span><span class="s3">3</span><span class="s1">])</span>
</pre>
</body>
</html>