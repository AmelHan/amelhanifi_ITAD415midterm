<html>
<head>
<title>parse_jmulti_vecm_output.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parse_jmulti_vecm_output.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">open</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">re</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s1">debug_mode = </span><span class="s0">False</span>

<span class="s1">here = os.path.dirname(os.path.realpath(__file__))</span>


<span class="s0">def </span><span class="s1">print_debug_output(results</span><span class="s0">, </span><span class="s1">dt):</span>
    <span class="s1">print(</span><span class="s2">&quot;</span><span class="s0">\n\n\n</span><span class="s2">DETERMINISTIC TERMS: &quot; </span><span class="s1">+ dt)</span>
    <span class="s1">alpha = results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;alpha&quot;</span><span class="s1">]</span>
    <span class="s1">print(</span><span class="s2">&quot;alpha:&quot;</span><span class="s1">)</span>
    <span class="s1">print(str(type(alpha)) + str(alpha.shape))</span>
    <span class="s1">print(alpha)</span>
    <span class="s1">print(</span><span class="s2">&quot;se: &quot;</span><span class="s1">)</span>
    <span class="s1">print(results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;alpha&quot;</span><span class="s1">])</span>
    <span class="s1">print(</span><span class="s2">&quot;t: &quot;</span><span class="s1">)</span>
    <span class="s1">print(results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][</span><span class="s2">&quot;alpha&quot;</span><span class="s1">])</span>
    <span class="s1">print(</span><span class="s2">&quot;p: &quot;</span><span class="s1">)</span>
    <span class="s1">print(results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][</span><span class="s2">&quot;alpha&quot;</span><span class="s1">])</span>
    <span class="s1">beta = results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span>
    <span class="s1">print(</span><span class="s2">&quot;beta:&quot;</span><span class="s1">)</span>
    <span class="s1">print(str(type(beta)) + str(beta.shape))</span>
    <span class="s1">print(beta)</span>
    <span class="s1">gamma = results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;Gamma&quot;</span><span class="s1">]</span>
    <span class="s1">print(</span><span class="s2">&quot;Gamma:&quot;</span><span class="s1">)</span>
    <span class="s1">print(str(type(gamma)) + str(gamma.shape))</span>
    <span class="s1">print(gamma)</span>
    <span class="s0">if </span><span class="s2">&quot;co&quot; </span><span class="s0">in </span><span class="s1">dt </span><span class="s0">or </span><span class="s2">&quot;s&quot; </span><span class="s0">in </span><span class="s1">dt </span><span class="s0">or </span><span class="s2">&quot;lo&quot; </span><span class="s0">in </span><span class="s1">dt:</span>
        <span class="s1">c = results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;C&quot;</span><span class="s1">]</span>
        <span class="s1">print(</span><span class="s2">&quot;C:&quot;</span><span class="s1">)</span>
        <span class="s1">print(str(type(c)) + str(c.shape))</span>
        <span class="s1">print(c)</span>
        <span class="s1">print(</span><span class="s2">&quot;se: &quot;</span><span class="s1">)</span>
        <span class="s1">print(results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">dt_s_tup_to_string(dt_s_tup):</span>
    <span class="s1">dt_string = dt_s_tup[</span><span class="s3">0</span><span class="s1">]  </span><span class="s4"># string for identifying the file to parse.</span>
    <span class="s0">if </span><span class="s1">dt_s_tup[</span><span class="s3">1</span><span class="s1">] &gt; </span><span class="s3">0</span><span class="s1">:  </span><span class="s4"># if there are seasons in the model</span>
        <span class="s0">if </span><span class="s2">&quot;co&quot; </span><span class="s0">in </span><span class="s1">dt_string </span><span class="s0">or </span><span class="s2">&quot;ci&quot; </span><span class="s0">in </span><span class="s1">dt_string </span><span class="s0">or </span><span class="s2">&quot;nc&quot; </span><span class="s0">in </span><span class="s1">dt_string:</span>
            <span class="s1">dt_string = dt_string[:</span><span class="s3">2</span><span class="s1">] + </span><span class="s2">&quot;s&quot; </span><span class="s1">+ dt_string[</span><span class="s3">2</span><span class="s1">:]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dt_string = </span><span class="s2">&quot;s&quot; </span><span class="s1">+ dt_string</span>
    <span class="s0">return </span><span class="s1">dt_string</span>


<span class="s0">def </span><span class="s1">sublists(lst</span><span class="s0">, </span><span class="s1">min_elmts=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">max_elmts=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Build a list of all possible sublists of a given list. Restrictions 
    on the length of the sublists can be posed via the min_elmts and max_elmts 
    parameters. 
    All sublists 
    have will have at least min_elmts elements and not more than max_elmts 
    elements. 
 
    Parameters 
    ---------- 
    lst : list 
        Original list from which sublists are generated. 
    min_elmts : int 
        Lower bound for the length of sublists. 
    max_elmts : int or None 
        If int, then max_elmts are the upper bound for the length of sublists. 
        If None, sublists' length is not restricted. In this case the longest 
        sublist will be of the same length as the original list lst. 
 
    Returns 
    ------- 
    result : list 
        A list of all sublists of lst fulfilling the length restrictions. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">max_elmts </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">max_elmts = len(lst)</span>
    <span class="s4"># for the following see also the definition of powerset() in</span>
    <span class="s4"># https://docs.python.org/dev/library/itertools.html#itertools-recipes</span>
    <span class="s1">result = itertools.chain.from_iterable(</span>
                <span class="s1">itertools.combinations(lst</span><span class="s0">, </span><span class="s1">sublist_len)</span>
                <span class="s0">for </span><span class="s1">sublist_len </span><span class="s0">in </span><span class="s1">range(min_elmts</span><span class="s0">, </span><span class="s1">max_elmts+</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">if </span><span class="s1">type(result) != list:</span>
        <span class="s1">result = list(result)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">stringify_var_names(var_list</span><span class="s0">, </span><span class="s1">delimiter=</span><span class="s2">&quot;&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
 
    Parameters 
    ---------- 
    var_list : list[str] 
        Each list element is the name of a variable. 
 
    Returns 
    ------- 
    result : str 
        Concatenated variable names. 
    &quot;&quot;&quot;</span>
    <span class="s1">result = var_list[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">var_name </span><span class="s0">in </span><span class="s1">var_list[</span><span class="s3">1</span><span class="s1">:]:</span>
        <span class="s1">result += delimiter + var_name</span>
    <span class="s0">return </span><span class="s1">result.lower()</span>


<span class="s0">def </span><span class="s1">load_results_jmulti(dataset):</span>
    <span class="s5">&quot;&quot;&quot; 
 
    Parameters 
    ---------- 
    dataset : module 
        A data module in the statsmodels/datasets directory that defines a 
        __str__() method returning the dataset's name. 
    dt_s_list : list 
        A list of strings where each string represents a combination of 
        deterministic terms. 
 
    Returns 
    ------- 
    result : dict 
        A dict (keys: tuples of deterministic terms and seasonal terms) 
        of dicts (keys: strings &quot;est&quot; (for estimators), 
                              &quot;se&quot; (for standard errors), 
                              &quot;t&quot; (for t-values), 
                              &quot;p&quot; (for p-values)) 
        of dicts (keys: strings &quot;alpha&quot;, &quot;beta&quot;, &quot;Gamma&quot; and other results) 
    &quot;&quot;&quot;</span>
    <span class="s1">source = </span><span class="s2">&quot;jmulti&quot;</span>

    <span class="s1">results_dict_per_det_terms = dict.fromkeys(dataset.dt_s_list)</span>

    <span class="s0">for </span><span class="s1">dt_s </span><span class="s0">in </span><span class="s1">dataset.dt_s_list:</span>
        <span class="s1">dt_string = dt_s_tup_to_string(dt_s)</span>
        <span class="s1">params_file = </span><span class="s2">&quot;vecm_&quot;</span><span class="s1">+dataset.__str__()+</span><span class="s2">&quot;_&quot;</span><span class="s1">+source+</span><span class="s2">&quot;_&quot;</span><span class="s1">+dt_string+</span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">params_file = os.path.join(here</span><span class="s0">, </span><span class="s1">params_file)</span>
        <span class="s4"># sections in jmulti output:</span>
        <span class="s1">section_header = [</span><span class="s2">&quot;Lagged endogenous term&quot;</span><span class="s0">,  </span><span class="s4"># Gamma</span>
                          <span class="s2">&quot;Deterministic term&quot;</span><span class="s0">,      </span><span class="s4"># co, s, lo</span>
                          <span class="s2">&quot;Loading coefficients&quot;</span><span class="s0">,    </span><span class="s4"># alpha</span>
                          <span class="s2">&quot;Estimated cointegration relation&quot;</span><span class="s0">,  </span><span class="s4"># beta</span>
                          <span class="s2">&quot;Legend&quot;</span><span class="s0">,</span>
                          <span class="s2">&quot;Lagged endogenous term&quot;</span><span class="s0">,  </span><span class="s4"># VAR representation</span>
                          <span class="s2">&quot;Deterministic term&quot;</span><span class="s1">]      </span><span class="s4"># VAR representation</span>
        <span class="s4"># the following &quot;sections&quot; will serve as key for the corresponding</span>
        <span class="s4"># result values</span>
        <span class="s1">sections = [</span><span class="s2">&quot;Gamma&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;C&quot;</span><span class="s0">,     </span><span class="s4"># Here all deterministic term coefficients are</span>
                             <span class="s4"># collected. (const and linear trend which belong</span>
                             <span class="s4"># to cointegration relation as well as seasonal</span>
                             <span class="s4"># components which are outside the cointegration</span>
                             <span class="s4"># relation. Later, we will strip the terms related</span>
                             <span class="s4"># to the cointegration relation from C.</span>
                    <span class="s2">&quot;alpha&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;beta&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;Legend&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;VAR A&quot;</span><span class="s0">,  </span><span class="s4"># VAR parameter matrices</span>
                    <span class="s2">&quot;VAR deterministic&quot;</span><span class="s1">]  </span><span class="s4"># VAR deterministic terms</span>
        <span class="s0">if </span><span class="s2">&quot;co&quot; </span><span class="s0">not in </span><span class="s1">dt_string </span><span class="s0">and </span><span class="s2">&quot;lo&quot; </span><span class="s0">not in </span><span class="s1">dt_string \</span>
                <span class="s0">and </span><span class="s2">&quot;s&quot; </span><span class="s0">not in </span><span class="s1">dt_string:</span>
            <span class="s4"># JMulTi: no deterministic terms section in VEC representation</span>
            <span class="s0">del </span><span class="s1">section_header[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s0">del </span><span class="s1">sections[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s2">&quot;ci&quot; </span><span class="s0">not in </span><span class="s1">dt_string </span><span class="s0">and </span><span class="s2">&quot;li&quot; </span><span class="s0">not in </span><span class="s1">dt_string:</span>
                <span class="s4"># JMulTi: no deterministic section in VAR repr.</span>
                <span class="s0">del </span><span class="s1">section_header[-</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s0">del </span><span class="s1">sections[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">results = dict()</span>
        <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">] = dict.fromkeys(sections)</span>
        <span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">] = dict.fromkeys(sections)</span>
        <span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">] = dict.fromkeys(sections)</span>
        <span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">] = dict.fromkeys(sections)</span>
        <span class="s1">section = -</span><span class="s3">1</span>
        <span class="s1">result = []</span>
        <span class="s1">result_se = []</span>
        <span class="s1">result_t = []</span>
        <span class="s1">result_p = []</span>

        <span class="s1">rows = </span><span class="s3">0</span>
        <span class="s1">started_reading_section = </span><span class="s0">False</span>
        <span class="s1">start_end_mark = </span><span class="s2">&quot;-----&quot;</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse information about \alpha, \beta, \Gamma, deterministic of VECM</span>
        <span class="s4"># and A_i and deterministic of corresponding VAR:</span>
        <span class="s1">params_file = open(params_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;latin_1&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">params_file:</span>
            <span class="s0">if </span><span class="s1">section == -</span><span class="s3">1 </span><span class="s0">and </span><span class="s1">section_header[section+</span><span class="s3">1</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">line:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">section &lt; len(section_header)-</span><span class="s3">1 </span><span class="s1">\</span>
                    <span class="s0">and </span><span class="s1">section_header[section+</span><span class="s3">1</span><span class="s1">] </span><span class="s0">in </span><span class="s1">line:  </span><span class="s4"># new section</span>
                <span class="s1">section += </span><span class="s3">1</span>
                <span class="s0">continue</span>
            <span class="s0">if not </span><span class="s1">started_reading_section:</span>
                <span class="s0">if </span><span class="s1">line.startswith(start_end_mark):</span>
                    <span class="s1">started_reading_section = </span><span class="s0">True</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">started_reading_section:</span>
                <span class="s0">if </span><span class="s1">line.startswith(start_end_mark):</span>
                    <span class="s0">if </span><span class="s1">result == []:  </span><span class="s4"># no values collected in section &quot;Legend&quot;</span>
                        <span class="s1">started_reading_section = </span><span class="s0">False</span>
                        <span class="s0">continue</span>
                    <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][sections[section]] = np.column_stack(</span>
                                                                    <span class="s1">result)</span>
                    <span class="s1">result = []</span>
                    <span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][sections[section]] = np.column_stack(</span>
                                                                    <span class="s1">result_se)</span>
                    <span class="s1">result_se = []</span>
                    <span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][sections[section]] = np.column_stack(</span>
                                                                    <span class="s1">result_t)</span>
                    <span class="s1">result_t = []</span>
                    <span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][sections[section]] = np.column_stack(</span>
                                                                    <span class="s1">result_p)</span>
                    <span class="s1">result_p = []</span>
                    <span class="s1">started_reading_section = </span><span class="s0">False</span>
                    <span class="s0">continue</span>
                <span class="s1">str_number = </span><span class="s2">r&quot;-?\d+\.\d{3}&quot;</span>
                <span class="s1">regex_est = re.compile(str_number + </span><span class="s2">r&quot;[^\)\]\}]&quot;</span><span class="s1">)</span>
                <span class="s1">est_col = re.findall(regex_est</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s4"># standard errors in parantheses in JMulTi output:</span>
                <span class="s1">regex_se = re.compile(</span><span class="s2">r&quot;\(&quot; </span><span class="s1">+ str_number + </span><span class="s2">r&quot;\)&quot;</span><span class="s1">)</span>
                <span class="s1">se_col = re.findall(regex_se</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s4"># t-values in brackets in JMulTi output:</span>
                <span class="s1">regex_t_value = re.compile(</span><span class="s2">r&quot;\[&quot; </span><span class="s1">+ str_number + </span><span class="s2">r&quot;\]&quot;</span><span class="s1">)</span>
                <span class="s1">t_col = re.findall(regex_t_value</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s4"># p-values in braces in JMulTi output:</span>
                <span class="s1">regex_p_value = re.compile(</span><span class="s2">r&quot;\{&quot; </span><span class="s1">+ str_number + </span><span class="s2">r&quot;\}&quot;</span><span class="s1">)</span>
                <span class="s1">p_col = re.findall(regex_p_value</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s0">if </span><span class="s1">result == [] </span><span class="s0">and </span><span class="s1">est_col != []:</span>
                    <span class="s1">rows = len(est_col)</span>
                <span class="s0">if </span><span class="s1">est_col != []:</span>
                    <span class="s1">est_col = [float(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">est_col]</span>
                    <span class="s1">result.append(est_col)</span>
                <span class="s0">elif </span><span class="s1">se_col != []:</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(rows):</span>
                        <span class="s1">se_col[i] = se_col[i].replace(</span><span class="s2">&quot;(&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">).replace(</span><span class="s2">&quot;)&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                    <span class="s1">se_col = [float(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">se_col]</span>
                    <span class="s1">result_se.append(se_col)</span>
                <span class="s0">elif </span><span class="s1">t_col != []:</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(rows):</span>
                        <span class="s1">t_col[i] = t_col[i].replace(</span><span class="s2">&quot;[&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">).replace(</span><span class="s2">&quot;]&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                    <span class="s1">t_col = [float(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">t_col]</span>
                    <span class="s1">result_t.append(t_col)</span>
                <span class="s0">elif </span><span class="s1">p_col != []:</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(rows):</span>
                        <span class="s1">p_col[i] = p_col[i].replace(</span><span class="s2">&quot;{&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">).replace(</span><span class="s2">&quot;}&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                    <span class="s1">p_col = [float(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">p_col]</span>
                    <span class="s1">result_p.append(p_col)</span>
        <span class="s1">params_file.close()</span>
        <span class="s4"># delete &quot;Legend&quot;-section of JMulTi:</span>
        <span class="s0">del </span><span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;Legend&quot;</span><span class="s1">]</span>
        <span class="s0">del </span><span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;Legend&quot;</span><span class="s1">]</span>
        <span class="s0">del </span><span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][</span><span class="s2">&quot;Legend&quot;</span><span class="s1">]</span>
        <span class="s0">del </span><span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][</span><span class="s2">&quot;Legend&quot;</span><span class="s1">]</span>
        <span class="s4"># JMulTi outputs beta.T</span>
        <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">] = results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">].T</span>
        <span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">] = results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">].T</span>
        <span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">] = results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">].T</span>
        <span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">] = results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">].T</span>
        <span class="s4"># split information about beta and deterministic terms inside coint.</span>
        <span class="s1">alpha = results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;alpha&quot;</span><span class="s1">]</span>
        <span class="s1">beta = results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span>
        <span class="s1">alpha_rows = alpha.shape[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">beta.shape[</span><span class="s3">0</span><span class="s1">] &gt; alpha_rows:</span>
            <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;det_coint&quot;</span><span class="s1">] = np.vsplit(</span>
                <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[alpha_rows])</span>
            <span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;det_coint&quot;</span><span class="s1">] = np.vsplit(</span>
                <span class="s1">results[</span><span class="s2">&quot;se&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[alpha_rows])</span>
            <span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][</span><span class="s2">&quot;det_coint&quot;</span><span class="s1">] = np.vsplit(</span>
                <span class="s1">results[</span><span class="s2">&quot;t&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[alpha_rows])</span>
            <span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][</span><span class="s2">&quot;det_coint&quot;</span><span class="s1">] = np.vsplit(</span>
                <span class="s1">results[</span><span class="s2">&quot;p&quot;</span><span class="s1">][</span><span class="s2">&quot;beta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[alpha_rows])</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse information regarding \Sigma_u</span>
        <span class="s1">sigmau_file = </span><span class="s2">&quot;vecm_&quot; </span><span class="s1">+ dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ \</span>
                      <span class="s1">dt_string + </span><span class="s2">&quot;_Sigmau&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">sigmau_file = os.path.join(here</span><span class="s0">, </span><span class="s1">sigmau_file)</span>
        <span class="s1">rows_to_parse = </span><span class="s3">0</span>
        <span class="s4"># all numbers of Sigma_u in notation with e (e.g. 2.283862e-05)</span>
        <span class="s1">regex_est = re.compile(</span><span class="s2">r&quot;\s+\S+e\S+&quot;</span><span class="s1">)</span>
        <span class="s1">sigmau_section_reached = </span><span class="s0">False</span>
        <span class="s1">sigmau_file = open(sigmau_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;latin_1&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">sigmau_file:</span>
            <span class="s0">if </span><span class="s1">line.startswith(</span><span class="s2">&quot;Log Likelihood:&quot;</span><span class="s1">):</span>
                <span class="s1">line = line.split(</span><span class="s2">&quot;Log Likelihood:&quot;</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">results[</span><span class="s2">&quot;log_like&quot;</span><span class="s1">] = float(re.findall(regex_est</span><span class="s0">, </span><span class="s1">line)[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s0">if not </span><span class="s1">sigmau_section_reached </span><span class="s0">and </span><span class="s2">&quot;Covariance:&quot; </span><span class="s0">not in </span><span class="s1">line:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s2">&quot;Covariance:&quot; </span><span class="s0">in </span><span class="s1">line:</span>
                <span class="s1">sigmau_section_reached = </span><span class="s0">True</span>
                <span class="s1">row = re.findall(regex_est</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s1">rows_to_parse = len(row)  </span><span class="s4"># Sigma_u quadratic ==&gt; #rows==#cols</span>
                <span class="s1">sigma_u = np.empty((rows_to_parse</span><span class="s0">, </span><span class="s1">rows_to_parse))</span>
            <span class="s1">row = re.findall(regex_est</span><span class="s0">, </span><span class="s1">line)</span>
            <span class="s1">rows_to_parse -= </span><span class="s3">1</span>
            <span class="s1">sigma_u[rows_to_parse] = row  </span><span class="s4"># rows are added in reverse order</span>
            <span class="s0">if </span><span class="s1">rows_to_parse == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">break</span>
        <span class="s1">sigmau_file.close()</span>
        <span class="s1">results[</span><span class="s2">&quot;est&quot;</span><span class="s1">][</span><span class="s2">&quot;Sigma_u&quot;</span><span class="s1">] = sigma_u[::-</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse forecast related output:</span>
        <span class="s1">fc_file = </span><span class="s2">&quot;vecm_&quot; </span><span class="s1">+ dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ \</span>
                  <span class="s1">dt_string + </span><span class="s2">&quot;_fc5&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">fc_file = os.path.join(here</span><span class="s0">, </span><span class="s1">fc_file)</span>
        <span class="s1">fc</span><span class="s0">, </span><span class="s1">lower</span><span class="s0">, </span><span class="s1">upper</span><span class="s0">, </span><span class="s1">plu_min = []</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span>
        <span class="s1">fc_file = open(fc_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">fc_file:</span>
            <span class="s1">str_number = </span><span class="s2">r&quot;(\s+-?\d+\.\d{4}\s*?)&quot;</span>
            <span class="s1">regex_number = re.compile(str_number)</span>
            <span class="s1">numbers = re.findall(regex_number</span><span class="s0">, </span><span class="s1">line)</span>
            <span class="s0">if </span><span class="s1">numbers == []:</span>
                <span class="s0">continue</span>
            <span class="s1">fc.append(float(numbers[</span><span class="s3">0</span><span class="s1">]))</span>
            <span class="s1">lower.append(float(numbers[</span><span class="s3">1</span><span class="s1">]))</span>
            <span class="s1">upper.append(float(numbers[</span><span class="s3">2</span><span class="s1">]))</span>
            <span class="s1">plu_min.append(float(numbers[</span><span class="s3">3</span><span class="s1">]))</span>
        <span class="s1">fc_file.close()</span>
        <span class="s1">variables = alpha.shape[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">fc = np.hstack(np.vsplit(np.array(fc)[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">variables))</span>
        <span class="s1">lower = np.hstack(np.vsplit(np.array(lower)[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">variables))</span>
        <span class="s1">upper = np.hstack(np.vsplit(np.array(upper)[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">variables))</span>
        <span class="s4"># plu_min = np.hstack(np.vsplit(np.array(plu_min)[:, None], variables))</span>
        <span class="s1">results[</span><span class="s2">&quot;fc&quot;</span><span class="s1">] = dict.fromkeys([</span><span class="s2">&quot;fc&quot;</span><span class="s0">, </span><span class="s2">&quot;lower&quot;</span><span class="s0">, </span><span class="s2">&quot;upper&quot;</span><span class="s1">])</span>
        <span class="s1">results[</span><span class="s2">&quot;fc&quot;</span><span class="s1">][</span><span class="s2">&quot;fc&quot;</span><span class="s1">] = fc</span>
        <span class="s1">results[</span><span class="s2">&quot;fc&quot;</span><span class="s1">][</span><span class="s2">&quot;lower&quot;</span><span class="s1">] = lower</span>
        <span class="s1">results[</span><span class="s2">&quot;fc&quot;</span><span class="s1">][</span><span class="s2">&quot;upper&quot;</span><span class="s1">] = upper</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse output related to Granger-causality:</span>
        <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">] = dict.fromkeys([</span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s2">&quot;test_stat&quot;</span><span class="s1">])</span>
        <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;p&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;test_stat&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">vn = dataset.variable_names</span>
        <span class="s4"># all possible combinations of potentially causing variables</span>
        <span class="s4"># (at least 1 variable and not all variables together):</span>
        <span class="s1">var_combs = sublists(vn</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">len(vn)-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">causing </span><span class="s0">in </span><span class="s1">var_combs:</span>
            <span class="s1">caused = tuple(el </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">vn </span><span class="s0">if </span><span class="s1">el </span><span class="s0">not in </span><span class="s1">causing)</span>
            <span class="s1">granger_file = </span><span class="s2">&quot;vecm_&quot; </span><span class="s1">+ dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">\</span>
                <span class="s1">+ dt_string + </span><span class="s2">&quot;_granger_causality_&quot; </span><span class="s1">\</span>
                <span class="s1">+ stringify_var_names(causing) + </span><span class="s2">&quot;_&quot; </span><span class="s1">\</span>
                <span class="s1">+ stringify_var_names(caused) + </span><span class="s2">&quot;.txt&quot;</span>
            <span class="s1">granger_file = os.path.join(here</span><span class="s0">, </span><span class="s1">granger_file)</span>
            <span class="s1">granger_file = open(granger_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;latin_1&quot;</span><span class="s1">)</span>
            <span class="s1">granger_results = []</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">granger_file:</span>
                <span class="s1">str_number = </span><span class="s2">r&quot;\d+\.\d{4}&quot;</span>
                <span class="s1">regex_number = re.compile(str_number)</span>
                <span class="s1">number = re.search(regex_number</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s0">if </span><span class="s1">number </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">continue</span>
                <span class="s1">number = float(number.group(</span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">granger_results.append(number)</span>
            <span class="s1">granger_file.close()</span>
            <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;test_stat&quot;</span><span class="s1">][(causing</span><span class="s0">, </span><span class="s1">caused)] = \</span>
                <span class="s1">granger_results[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">results[</span><span class="s2">&quot;granger_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;p&quot;</span><span class="s1">][(causing</span><span class="s0">, </span><span class="s1">caused)] =\</span>
                <span class="s1">granger_results[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse output related to instant causality:</span>
        <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">] = dict.fromkeys([</span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s2">&quot;test_stat&quot;</span><span class="s1">])</span>
        <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;p&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;test_stat&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">vn = dataset.variable_names</span>
        <span class="s4"># all possible combinations of potentially causing variables</span>
        <span class="s4"># (at least 1 variable and not all variables together):</span>
        <span class="s1">var_combs = sublists(vn</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">len(vn)-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">causing </span><span class="s0">in </span><span class="s1">var_combs:</span>
            <span class="s1">caused = tuple(el </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">vn </span><span class="s0">if </span><span class="s1">el </span><span class="s0">not in </span><span class="s1">causing)</span>
            <span class="s4"># Though Granger- and instantaneous causality results are in the</span>
            <span class="s4"># same file we use two separate files, since JMulTi is basing both</span>
            <span class="s4"># tests on a VAR(p+1) model (where p is the number of lags in</span>
            <span class="s4"># levels). According to Lutkepohl, Granger-causality tests are</span>
            <span class="s4"># based on VAR(p+1) *but* tests for instantaneous causality are</span>
            <span class="s4"># based on VAR(p)! Thus we have this separate file with JMulTi</span>
            <span class="s4"># results for a VECM with the lag order reduced by one.</span>
            <span class="s1">inst_file = </span><span class="s2">&quot;vecm_&quot; </span><span class="s1">+ dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">\</span>
                <span class="s1">+ dt_string + </span><span class="s2">&quot;_inst_causality_&quot; </span><span class="s1">\</span>
                <span class="s1">+ stringify_var_names(causing) + </span><span class="s2">&quot;_&quot; </span><span class="s1">\</span>
                <span class="s1">+ stringify_var_names(caused) + </span><span class="s2">&quot;.txt&quot;</span>
            <span class="s1">inst_file = os.path.join(here</span><span class="s0">, </span><span class="s1">inst_file)</span>
            <span class="s1">inst_file = open(inst_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;latin_1&quot;</span><span class="s1">)</span>
            <span class="s1">inst_results = []</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">inst_file:</span>
                <span class="s1">str_number = </span><span class="s2">r&quot;\d+\.\d{4}&quot;</span>
                <span class="s1">regex_number = re.compile(str_number)</span>
                <span class="s1">number = re.search(regex_number</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s0">if </span><span class="s1">number </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">continue</span>
                <span class="s1">number = float(number.group(</span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">inst_results.append(number)</span>
            <span class="s1">inst_file.close()</span>
            <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;test_stat&quot;</span><span class="s1">][(causing</span><span class="s0">, </span><span class="s1">caused)] = \</span>
                <span class="s1">inst_results[</span><span class="s3">2</span><span class="s1">]</span>
            <span class="s1">results[</span><span class="s2">&quot;inst_caus&quot;</span><span class="s1">][</span><span class="s2">&quot;p&quot;</span><span class="s1">][(causing</span><span class="s0">, </span><span class="s1">caused)] = \</span>
                <span class="s1">inst_results[</span><span class="s3">3</span><span class="s1">]</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse output related to impulse-response analysis:</span>
        <span class="s1">ir_file = </span><span class="s2">&quot;vecm_&quot; </span><span class="s1">+ dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ \</span>
                  <span class="s1">dt_string + </span><span class="s2">&quot;_ir&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">ir_file = os.path.join(here</span><span class="s0">, </span><span class="s1">ir_file)</span>
        <span class="s1">ir_file = open(ir_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s1">causing = </span><span class="s0">None</span>
        <span class="s1">caused = </span><span class="s0">None</span>
        <span class="s1">data = </span><span class="s0">None</span>
        <span class="s1">regex_vars = re.compile(</span><span class="s2">r&quot;\w+&quot;</span><span class="s1">)</span>
        <span class="s1">regex_vals = re.compile(</span><span class="s2">r&quot;-?\d+\.\d{4}&quot;</span><span class="s1">)</span>
        <span class="s1">line_start_causing = </span><span class="s2">&quot;time&quot;</span>
        <span class="s1">data_line_indicator = </span><span class="s2">&quot;point estimate&quot;</span>
        <span class="s1">data_rows_read = </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">ir_file:</span>
            <span class="s0">if </span><span class="s1">causing </span><span class="s0">is None and not </span><span class="s1">line.startswith(line_start_causing):</span>
                <span class="s0">continue  </span><span class="s4"># no relevant info in the header</span>
            <span class="s0">if </span><span class="s1">line.startswith(line_start_causing):</span>
                <span class="s1">line = line[</span><span class="s3">4</span><span class="s1">:]</span>
                <span class="s1">causing = re.findall(regex_vars</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s4"># 21 periods shown in JMulTi output</span>
                <span class="s1">data = np.empty((</span><span class="s3">21</span><span class="s0">, </span><span class="s1">len(causing)))</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">caused </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">caused = re.findall(regex_vars</span><span class="s0">, </span><span class="s1">line)</span>
                <span class="s0">continue</span>
            <span class="s4"># now start collecting the values:</span>
            <span class="s0">if </span><span class="s1">data_line_indicator </span><span class="s0">not in </span><span class="s1">line:</span>
                <span class="s0">continue</span>
            <span class="s1">start = line.find(data_line_indicator) + len(data_line_indicator)</span>
            <span class="s1">line = line[start:]</span>
            <span class="s1">data[data_rows_read] = re.findall(regex_vals</span><span class="s0">, </span><span class="s1">line)</span>
            <span class="s1">data_rows_read += </span><span class="s3">1</span>
        <span class="s1">ir_file.close()</span>
        <span class="s1">results[</span><span class="s2">&quot;ir&quot;</span><span class="s1">] = data</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse output related to lag order selection:</span>
        <span class="s1">lagorder_file = </span><span class="s2">&quot;vecm_&quot; </span><span class="s1">+ dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ \</span>
                        <span class="s1">dt_string + </span><span class="s2">&quot;_lagorder&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">lagorder_file = os.path.join(here</span><span class="s0">, </span><span class="s1">lagorder_file)</span>
        <span class="s1">lagorder_file = open(lagorder_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">aic_start = </span><span class="s2">&quot;Akaike Info Criterion:&quot;</span>
        <span class="s1">fpe_start = </span><span class="s2">&quot;Final Prediction Error:&quot;</span>
        <span class="s1">hqic_start = </span><span class="s2">&quot;Hannan-Quinn Criterion:&quot;</span>
        <span class="s1">bic_start = </span><span class="s2">&quot;Schwarz Criterion:&quot;</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lagorder_file:</span>
            <span class="s0">if </span><span class="s1">line.startswith(aic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">][</span><span class="s2">&quot;aic&quot;</span><span class="s1">] = int(line[len(aic_start):])</span>
            <span class="s0">elif </span><span class="s1">line.startswith(fpe_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">][</span><span class="s2">&quot;fpe&quot;</span><span class="s1">] = int(line[len(fpe_start):])</span>
            <span class="s0">elif </span><span class="s1">line.startswith(hqic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">][</span><span class="s2">&quot;hqic&quot;</span><span class="s1">] = int(line[len(hqic_start):])</span>
            <span class="s0">elif </span><span class="s1">line.startswith(bic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;lagorder&quot;</span><span class="s1">][</span><span class="s2">&quot;bic&quot;</span><span class="s1">] = int(line[len(bic_start):])</span>
        <span class="s1">lagorder_file.close()</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse output related to non-normality-test:</span>
        <span class="s1">test_norm_file = </span><span class="s2">&quot;vecm_&quot; </span><span class="s1">+ dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ \</span>
                         <span class="s1">dt_string + </span><span class="s2">&quot;_diag&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">test_norm_file = os.path.join(here</span><span class="s0">, </span><span class="s1">test_norm_file)</span>
        <span class="s1">test_norm_file = open(test_norm_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s1">results[</span><span class="s2">&quot;test_norm&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">reading_values = </span><span class="s0">False</span>
        <span class="s1">line_start_statistic = </span><span class="s2">&quot;joint test statistic:&quot;</span>
        <span class="s1">line_start_pvalue = </span><span class="s2">&quot; p-value:&quot;</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">test_norm_file:</span>
            <span class="s0">if not </span><span class="s1">reading_values:</span>
                <span class="s0">if </span><span class="s2">&quot;Introduction to Multiple Time Series Analysis&quot; </span><span class="s0">in </span><span class="s1">line:</span>
                    <span class="s1">reading_values = </span><span class="s0">True  </span><span class="s4"># section w/ relevant results found</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s2">&quot;joint_pvalue&quot; </span><span class="s0">in </span><span class="s1">results[</span><span class="s2">&quot;test_norm&quot;</span><span class="s1">].keys():</span>
                <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">line.startswith(line_start_statistic):</span>
                <span class="s1">line_end = line[len(line_start_statistic):]</span>
                <span class="s1">results[</span><span class="s2">&quot;test_norm&quot;</span><span class="s1">][</span><span class="s2">&quot;joint_test_statistic&quot;</span><span class="s1">] = float(line_end)</span>
            <span class="s0">if </span><span class="s1">line.startswith(line_start_pvalue):</span>
                <span class="s1">line_end = line[len(line_start_pvalue):]</span>
                <span class="s1">results[</span><span class="s2">&quot;test_norm&quot;</span><span class="s1">][</span><span class="s2">&quot;joint_pvalue&quot;</span><span class="s1">] = float(line_end)</span>
        <span class="s1">test_norm_file.close()</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s4"># parse output related to testing the whiteness of the residuals:</span>
        <span class="s1">whiteness_file = </span><span class="s2">&quot;vecm_&quot; </span><span class="s1">+ dataset.__str__() + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ source + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ \</span>
                         <span class="s1">dt_string + </span><span class="s2">&quot;_diag&quot; </span><span class="s1">+ </span><span class="s2">&quot;.txt&quot;</span>
        <span class="s1">whiteness_file = os.path.join(here</span><span class="s0">, </span><span class="s1">whiteness_file)</span>
        <span class="s1">whiteness_file = open(whiteness_file</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">'latin_1'</span><span class="s1">)</span>
        <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">] = dict()</span>
        <span class="s1">section_start_marker = </span><span class="s2">&quot;PORTMANTEAU TEST&quot;</span>
        <span class="s1">order_start = </span><span class="s2">&quot;tested order:&quot;</span>
        <span class="s1">statistic_start = </span><span class="s2">&quot;test statistic:&quot;</span>
        <span class="s1">p_start = </span><span class="s2">&quot; p-value:&quot;</span>
        <span class="s1">adj_statistic_start = </span><span class="s2">&quot;adjusted test statistic:&quot;</span>
        <span class="s1">unadjusted_finished = </span><span class="s0">False</span>

        <span class="s1">in_section = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">whiteness_file:</span>
            <span class="s0">if not </span><span class="s1">in_section </span><span class="s0">and </span><span class="s1">section_start_marker </span><span class="s0">not in </span><span class="s1">line:</span>
                <span class="s0">continue</span>
            <span class="s0">if not </span><span class="s1">in_section </span><span class="s0">and </span><span class="s1">section_start_marker </span><span class="s0">in </span><span class="s1">line:</span>
                <span class="s1">in_section = </span><span class="s0">True</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">line.startswith(order_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;tested order&quot;</span><span class="s1">] = int(</span>
                        <span class="s1">line[len(order_start):])</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">line.startswith(statistic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;test statistic&quot;</span><span class="s1">] = float(</span>
                        <span class="s1">line[len(statistic_start):])</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">line.startswith(adj_statistic_start):</span>
                <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;test statistic adj.&quot;</span><span class="s1">] = float(</span>
                        <span class="s1">line[len(adj_statistic_start):])</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">line.startswith(p_start):  </span><span class="s4"># same for unadjusted and adjusted</span>
                <span class="s0">if not </span><span class="s1">unadjusted_finished:</span>
                    <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;p-value&quot;</span><span class="s1">] = \</span>
                        <span class="s1">float(line[len(p_start):])</span>
                    <span class="s1">unadjusted_finished = </span><span class="s0">True</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">results[</span><span class="s2">&quot;whiteness&quot;</span><span class="s1">][</span><span class="s2">&quot;p-value adjusted&quot;</span><span class="s1">] = \</span>
                        <span class="s1">float(line[len(p_start):])</span>
                    <span class="s0">break</span>
        <span class="s1">whiteness_file.close()</span>

        <span class="s4"># ---------------------------------------------------------------------</span>
        <span class="s0">if </span><span class="s1">debug_mode:</span>
            <span class="s1">print_debug_output(results</span><span class="s0">, </span><span class="s1">dt_string)</span>

        <span class="s1">results_dict_per_det_terms[dt_s] = results</span>

    <span class="s0">return </span><span class="s1">results_dict_per_det_terms</span>
</pre>
</body>
</html>