<html>
<head>
<title>test_sarimax.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_sarimax.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for SARIMAX models 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">statsmodels.compat.platform </span><span class="s2">import </span><span class="s1">PLATFORM_WIN</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">sarimax</span><span class="s2">, </span><span class="s1">tools</span>
<span class="s2">from </span><span class="s1">.results </span><span class="s2">import </span><span class="s1">results_sarimax</span>
<span class="s2">from </span><span class="s1">statsmodels.tools </span><span class="s2">import </span><span class="s1">add_constant</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.tools </span><span class="s2">import </span><span class="s1">Bunch</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_raises</span><span class="s2">, </span><span class="s1">assert_allclose</span>
<span class="s1">)</span>


<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>

<span class="s1">realgdp_path = os.path.join(</span><span class="s3">'results'</span><span class="s2">, </span><span class="s3">'results_realgdpar_stata.csv'</span><span class="s1">)</span>
<span class="s1">realgdp_results = pd.read_csv(current_path + os.sep + realgdp_path)</span>

<span class="s1">coverage_path = os.path.join(</span><span class="s3">'results'</span><span class="s2">, </span><span class="s3">'results_sarimax_coverage.csv'</span><span class="s1">)</span>
<span class="s1">coverage_results = pd.read_csv(os.path.join(current_path</span><span class="s2">, </span><span class="s1">coverage_path))</span>


<span class="s2">class </span><span class="s1">TestSARIMAXStatsmodels:</span>
    <span class="s0">&quot;&quot;&quot; 
    Test ARIMA model using SARIMAX class against statsmodels ARIMA class 
 
    Notes 
    ----- 
 
    Standard errors are quite good for the OPG case. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">cls.true = results_sarimax.wpi1_stationary</span>
        <span class="s1">endog = cls.true[</span><span class="s3">'data'</span><span class="s1">]</span>
        <span class="s4"># Old results from statsmodels.arima.ARIMA taken before it was removed</span>
        <span class="s4"># to let test continue to run. On old statsmodels, can run</span>
        <span class="s4"># result_a = arima.ARIMA(endog, order=(1, 1, 1)).fit(disp=-1)</span>
        <span class="s1">result_a = Bunch()</span>
        <span class="s1">result_a.llf = -</span><span class="s5">135.3513139733829</span>
        <span class="s1">result_a.aic = </span><span class="s5">278.7026279467658</span>
        <span class="s1">result_a.bic = </span><span class="s5">289.9513653682555</span>
        <span class="s1">result_a.hqic = </span><span class="s5">283.27183681851653</span>
        <span class="s1">result_a.params = np.array([</span><span class="s5">0.74982449</span><span class="s2">, </span><span class="s5">0.87421135</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.41202195</span><span class="s1">])</span>
        <span class="s1">result_a.bse = np.array([</span><span class="s5">0.29207409</span><span class="s2">, </span><span class="s5">0.06377779</span><span class="s2">, </span><span class="s5">0.12208469</span><span class="s1">])</span>
        <span class="s1">cls.result_a = result_a</span>
        <span class="s1">cls.model_b = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s2">,</span>
                                      <span class="s1">simple_differencing=</span><span class="s2">True,</span>
                                      <span class="s1">hamilton_representation=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">cls.result_b = cls.model_b.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(self.result_b.llf</span><span class="s2">, </span><span class="s1">self.result_a.llf)</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s1">assert_allclose(self.result_b.aic</span><span class="s2">, </span><span class="s1">self.result_a.aic)</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s1">assert_allclose(self.result_b.bic</span><span class="s2">, </span><span class="s1">self.result_a.bic)</span>

    <span class="s2">def </span><span class="s1">test_hqic(self):</span>
        <span class="s1">assert_allclose(self.result_b.hqic</span><span class="s2">, </span><span class="s1">self.result_a.hqic)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s4"># ARIMA estimates the mean of the process, whereas SARIMAX estimates</span>
        <span class="s4"># the intercept. Convert the mean to intercept to compare</span>
        <span class="s1">params_a = self.result_a.params.copy()</span>
        <span class="s1">params_a[</span><span class="s5">0</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- params_a[</span><span class="s5">1</span><span class="s1">]) * params_a[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">assert_allclose(self.result_b.params[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params_a</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">5e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># Test the complex step approximated BSE values</span>
        <span class="s1">cpa = self.result_b._cov_params_approx(approx_complex_step=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">bse = cpa.diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.result_a.bse[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_t_test(self):</span>
        <span class="s2">import </span><span class="s1">statsmodels.tools._testing </span><span class="s2">as </span><span class="s1">smt</span>
        <span class="s4"># to trigger failure, un-comment the following:</span>
        <span class="s4">#  self.result_b._cache['pvalues'] += 1</span>
        <span class="s1">smt.check_ttest_tvalues(self.result_b)</span>
        <span class="s1">smt.check_ftest_pvalues(self.result_b)</span>


<span class="s2">class </span><span class="s1">TestRealGDPARStata:</span>
    <span class="s0">&quot;&quot;&quot; 
    Includes tests of filtered states and standardized forecast errors. 
 
    Notes 
    ----- 
    Could also test the usual things like standard errors, etc. but those are 
    well-tested elsewhere. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">dlgdp = np.log(realgdp_results[</span><span class="s3">'value'</span><span class="s1">]).diff()[</span><span class="s5">1</span><span class="s1">:].values</span>
        <span class="s1">cls.model = sarimax.SARIMAX(dlgdp</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">12</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">,</span>
                                    <span class="s1">hamilton_representation=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s4"># Estimated by Stata</span>
        <span class="s1">params = [</span>
            <span class="s5">.40725515</span><span class="s2">, </span><span class="s5">.18782621</span><span class="s2">, </span><span class="s1">-</span><span class="s5">.01514009</span><span class="s2">, </span><span class="s1">-</span><span class="s5">.01027267</span><span class="s2">, </span><span class="s1">-</span><span class="s5">.03642297</span><span class="s2">,</span>
            <span class="s5">.11576416</span><span class="s2">, </span><span class="s5">.02573029</span><span class="s2">, </span><span class="s1">-</span><span class="s5">.00766572</span><span class="s2">, </span><span class="s5">.13506498</span><span class="s2">, </span><span class="s5">.08649569</span><span class="s2">, </span><span class="s5">.06942822</span><span class="s2">,</span>
            <span class="s1">-</span><span class="s5">.10685783</span><span class="s2">, </span><span class="s5">.00007999607</span>
        <span class="s1">]</span>
        <span class="s1">cls.results = cls.model.filter(params)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">12</span><span class="s1">):</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">realgdp_results.iloc[</span><span class="s5">1</span><span class="s1">:][</span><span class="s3">'u%d' </span><span class="s1">% (i+</span><span class="s5">1</span><span class="s1">)]</span><span class="s2">,</span>
                <span class="s1">self.results.filter_results.filtered_state[i]</span><span class="s2">,</span>
                <span class="s1">atol=</span><span class="s5">1e-6</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_standardized_forecasts_error(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">realgdp_results.iloc[</span><span class="s5">1</span><span class="s1">:][</span><span class="s3">'rstd'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.results.filter_results.standardized_forecasts_error[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-3</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">SARIMAXStataTests:</span>
    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.llf</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">4</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.aic</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'aic'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">3</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.bic</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'bic'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">3</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_hqic(self):</span>
        <span class="s1">hqic = (</span>
            <span class="s1">-</span><span class="s5">2</span><span class="s1">*self.result.llf +</span>
            <span class="s5">2</span><span class="s1">*np.log(np.log(self.result.nobs_effective)) *</span>
            <span class="s1">self.result.params.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.hqic</span><span class="s2">,</span>
            <span class="s1">hqic</span><span class="s2">, </span><span class="s5">3</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_standardized_forecasts_error(self):</span>
        <span class="s1">cython_sfe = self.result.standardized_forecasts_error</span>
        <span class="s1">self.result._standardized_forecasts_error = </span><span class="s2">None</span>
        <span class="s1">python_sfe = self.result.standardized_forecasts_error</span>
        <span class="s1">assert_allclose(cython_sfe</span><span class="s2">, </span><span class="s1">python_sfe)</span>


<span class="s2">class </span><span class="s1">ARIMA(SARIMAXStataTests):</span>
    <span class="s0">&quot;&quot;&quot; 
    ARIMA model 
 
    Stata arima documentation, Example 1 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">cls.true = true</span>
        <span class="s1">endog = true[</span><span class="s3">'data'</span><span class="s1">]</span>

        <span class="s1">kwargs.setdefault(</span><span class="s3">'simple_differencing'</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'hamilton_representation'</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">cls.model = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s2">,</span>
                                    <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Stata estimates the mean of the process, whereas SARIMAX estimates</span>
        <span class="s4"># the intercept of the process. Get the intercept.</span>
        <span class="s1">intercept = (</span><span class="s5">1 </span><span class="s1">- true[</span><span class="s3">'params_ar'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]) * true[</span><span class="s3">'params_mean'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">params = np.r_[intercept</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_ar'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_ma'</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">true[</span><span class="s3">'params_variance'</span><span class="s1">]]</span>

        <span class="s1">cls.result = cls.model.filter(params)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s1">result = self.model.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.params</span><span class="s2">, </span><span class="s1">self.result.params</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-3</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestARIMAStationary(ARIMA):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
 
    Standard errors are very good for the OPG and complex step approximation 
    cases. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestARIMAStationary</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">results_sarimax.wpi1_stationary</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># test defaults</span>
        <span class="s1">assert_equal(self.result.cov_type</span><span class="s2">, </span><span class="s3">'opg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_complex_step</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_centered</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s4"># default covariance type (opg)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># complex step</span>
        <span class="s1">bse = self.result._cov_params_approx(</span>
            <span class="s1">approx_complex_step=</span><span class="s2">True</span><span class="s1">).diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

        <span class="s4"># The below tests pass irregularly; they give a sense of the precision</span>
        <span class="s4"># available with finite differencing</span>
        <span class="s4"># finite difference, non-centered</span>
        <span class="s4"># with warnings.catch_warnings():</span>
        <span class="s4">#     warnings.simplefilter(&quot;ignore&quot;)</span>
        <span class="s4">#     bse = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False).diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_ar_oim'], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[2], self.true['se_ma_oim'], atol=1e-1)</span>

        <span class="s4">#     # finite difference, centered</span>
        <span class="s4">#     cpa = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False, approx_centered=True)</span>
        <span class="s4">#     bse = cpa.diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_ar_oim'], atol=1e-3)</span>
        <span class="s4">#     assert_allclose(bse[2], self.true['se_ma_oim'], atol=1e-3)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># OIM covariance type</span>
        <span class="s1">oim_bse = self.result.cov_params_oim.diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(oim_bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(oim_bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_robust(self):</span>
        <span class="s1">robust_oim_bse = self.result.cov_params_robust_oim.diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">cpra = self.result.cov_params_robust_approx</span>
        <span class="s1">robust_approx_bse = cpra.diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">true_robust_bse = np.r_[</span>
            <span class="s1">self.true[</span><span class="s3">'se_ar_robust'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_robust'</span><span class="s1">]</span>
        <span class="s1">]</span>

        <span class="s1">assert_allclose(robust_oim_bse[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true_robust_bse</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(robust_approx_bse[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true_robust_bse</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-3</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestARIMADiffuse(ARIMA):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
 
    Standard errors are very good for the OPG and quite good for the complex 
    step approximation cases. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'initialization'</span><span class="s1">] = </span><span class="s3">'approximate_diffuse'</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = (</span>
            <span class="s1">results_sarimax.wpi1_diffuse[</span><span class="s3">'initial_variance'</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">super(TestARIMADiffuse</span><span class="s2">, </span><span class="s1">cls).setup_class(results_sarimax.wpi1_diffuse</span><span class="s2">,</span>
                                                 <span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># test defaults</span>
        <span class="s1">assert_equal(self.result.cov_type</span><span class="s2">, </span><span class="s3">'opg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_complex_step</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_centered</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s4"># default covariance type (opg)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># complex step</span>
        <span class="s1">bse = self.result._cov_params_approx(</span>
            <span class="s1">approx_complex_step=</span><span class="s2">True</span><span class="s1">).diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

        <span class="s4"># The below tests do not pass</span>
        <span class="s4"># with warnings.catch_warnings():</span>
        <span class="s4">#     warnings.simplefilter(&quot;ignore&quot;)</span>

        <span class="s4">#     # finite difference, non-centered : failure</span>
        <span class="s4">#     bse = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False).diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_ar_oim'], atol=1e-4)</span>
        <span class="s4">#     assert_allclose(bse[2], self.true['se_ma_oim'], atol=1e-4)</span>

        <span class="s4">#     # finite difference, centered : failure</span>
        <span class="s4">#     cpa = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False, approx_centered=True)</span>
        <span class="s4">#     bse = cpa.diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_ar_oim'], atol=1e-4)</span>
        <span class="s4">#     assert_allclose(bse[2], self.true['se_ma_oim'], atol=1e-4)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># OIM covariance type</span>
        <span class="s1">bse = self.result._cov_params_oim().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">AdditiveSeasonal(SARIMAXStataTests):</span>
    <span class="s0">&quot;&quot;&quot; 
    ARIMA model with additive seasonal effects 
 
    Stata arima documentation, Example 2 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">cls.true = true</span>
        <span class="s1">endog = np.log(true[</span><span class="s3">'data'</span><span class="s1">])</span>

        <span class="s1">kwargs.setdefault(</span><span class="s3">'simple_differencing'</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'hamilton_representation'</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">cls.model = sarimax.SARIMAX(</span>
            <span class="s1">endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s4"># Stata estimates the mean of the process, whereas SARIMAX estimates</span>
        <span class="s4"># the intercept of the process. Get the intercept.</span>
        <span class="s1">intercept = (</span><span class="s5">1 </span><span class="s1">- true[</span><span class="s3">'params_ar'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]) * true[</span><span class="s3">'params_mean'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">params = np.r_[intercept</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_ar'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_ma'</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">true[</span><span class="s3">'params_variance'</span><span class="s1">]]</span>

        <span class="s1">cls.result = cls.model.filter(params)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s1">result = self.model.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.params</span><span class="s2">, </span><span class="s1">self.result.params</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-3</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestAdditiveSeasonal(AdditiveSeasonal):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
 
    Standard errors are very good for the OPG and quite good for the complex 
    step approximation cases. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestAdditiveSeasonal</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">results_sarimax.wpi1_seasonal</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># test defaults</span>
        <span class="s1">assert_equal(self.result.cov_type</span><span class="s2">, </span><span class="s3">'opg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_complex_step</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_centered</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s4"># default covariance type (opg)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_opg'</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># complex step</span>
        <span class="s1">bse = self.result._cov_params_approx(</span>
            <span class="s1">approx_complex_step=</span><span class="s2">True</span><span class="s1">).diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

        <span class="s4"># The below tests pass irregularly; they give a sense of the precision</span>
        <span class="s4"># available with finite differencing</span>
        <span class="s4"># with warnings.catch_warnings():</span>
        <span class="s4">#     warnings.simplefilter(&quot;ignore&quot;)</span>

        <span class="s4">#     # finite difference, non-centered</span>
        <span class="s4">#     bse = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False).diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_ar_oim'], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[2:4], self.true['se_ma_oim'], atol=1e-2)</span>

        <span class="s4">#     # finite difference, centered</span>
        <span class="s4">#     cpa = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False, approx_centered=True)</span>
        <span class="s4">#     bse = cpa.diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_ar_oim'], atol=1e-3)</span>
        <span class="s4">#     assert_allclose(bse[2:4], self.true['se_ma_oim'], atol=1e-3)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># OIM covariance type</span>
        <span class="s1">bse = self.result._cov_params_oim().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Airline(SARIMAXStataTests):</span>
    <span class="s0">&quot;&quot;&quot; 
    Multiplicative SARIMA model: &quot;Airline&quot; model 
 
    Stata arima documentation, Example 3 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">cls.true = true</span>
        <span class="s1">endog = np.log(true[</span><span class="s3">'data'</span><span class="s1">])</span>

        <span class="s1">kwargs.setdefault(</span><span class="s3">'simple_differencing'</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'hamilton_representation'</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">cls.model = sarimax.SARIMAX(</span>
            <span class="s1">endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s1">params = np.r_[true[</span><span class="s3">'params_ma'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_seasonal_ma'</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">true[</span><span class="s3">'params_variance'</span><span class="s1">]]</span>

        <span class="s1">cls.result = cls.model.filter(params)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>

            <span class="s1">result = self.model.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">result.params</span><span class="s2">, </span><span class="s1">self.result.params</span><span class="s2">,</span>
                <span class="s1">atol=</span><span class="s5">1e-4</span>
            <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestAirlineHamilton(Airline):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
 
    Standard errors are very good for the OPG and complex step approximation 
    cases. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestAirlineHamilton</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">results_sarimax.air2_stationary</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># test defaults</span>
        <span class="s1">assert_equal(self.result.cov_type</span><span class="s2">, </span><span class="s3">'opg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_complex_step</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_centered</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s4"># default covariance type (opg)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_opg'</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># complex step</span>
        <span class="s1">bse = self.result._cov_params_approx(</span>
            <span class="s1">approx_complex_step=</span><span class="s2">True</span><span class="s1">).diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

        <span class="s4"># The below tests pass irregularly; they give a sense of the precision</span>
        <span class="s4"># available with finite differencing</span>
        <span class="s4"># with warnings.catch_warnings():</span>
        <span class="s4">#     warnings.simplefilter(&quot;ignore&quot;)</span>

        <span class="s4">#     # finite difference, non-centered</span>
        <span class="s4">#     bse = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False).diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_ma_oim'], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_seasonal_ma_oim'],</span>
        <span class="s4">#                     atol=1e-2)</span>

        <span class="s4">#     # finite difference, centered</span>
        <span class="s4">#     cpa = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False, approx_centered=True)</span>
        <span class="s4">#     bse = cpa.diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_ma_oim'], atol=1e-4)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_seasonal_ma_oim'],</span>
        <span class="s4">#                     atol=1e-4)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># OIM covariance type</span>
        <span class="s1">oim_bse = self.result.cov_params_oim.diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(oim_bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(oim_bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestAirlineHarvey(Airline):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
 
    Standard errors are very good for the OPG and complex step approximation 
    cases. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestAirlineHarvey</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">results_sarimax.air2_stationary</span><span class="s2">, </span><span class="s1">hamilton_representation=</span><span class="s2">False</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># test defaults</span>
        <span class="s1">assert_equal(self.result.cov_type</span><span class="s2">, </span><span class="s3">'opg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_complex_step</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_centered</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s4"># default covariance type (opg)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_opg'</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># complex step</span>
        <span class="s1">bse = self.result._cov_params_approx(</span>
            <span class="s1">approx_complex_step=</span><span class="s2">True</span><span class="s1">).diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

        <span class="s4"># The below tests pass irregularly; they give a sense of the precision</span>
        <span class="s4"># available with finite differencing</span>
        <span class="s4"># with warnings.catch_warnings():</span>
        <span class="s4">#     warnings.simplefilter(&quot;ignore&quot;)</span>

        <span class="s4">#     # finite difference, non-centered</span>
        <span class="s4">#     bse = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False).diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_ma_oim'], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_seasonal_ma_oim'],</span>
        <span class="s4">#                     atol=1e-2)</span>

        <span class="s4">#     # finite difference, centered</span>
        <span class="s4">#     cpa = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False, approx_centered=True)</span>
        <span class="s4">#     bse = cpa.diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_ma_oim'], atol=1e-4)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_seasonal_ma_oim'],</span>
        <span class="s4">#                     atol=1e-4)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># OIM covariance type</span>
        <span class="s1">oim_bse = self.result.cov_params_oim.diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(oim_bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(oim_bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestAirlineStateDifferencing(Airline):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
 
    Standard errors are very good for the OPG and quite good for the complex 
    step approximation cases. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestAirlineStateDifferencing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">results_sarimax.air2_stationary</span><span class="s2">, </span><span class="s1">simple_differencing=</span><span class="s2">False,</span>
            <span class="s1">hamilton_representation=</span><span class="s2">False</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># Due to diffuse component of the state (which technically changes the</span>
        <span class="s4"># BIC calculation - see Durbin and Koopman section 7.4), this is the</span>
        <span class="s4"># best we can do for BIC</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.bic</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'bic'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s1">result = self.model.fit(method=</span><span class="s3">'nm'</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">1000</span><span class="s2">, </span><span class="s1">disp=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.params</span><span class="s2">, </span><span class="s1">self.result.params</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># test defaults</span>
        <span class="s1">assert_equal(self.result.cov_type</span><span class="s2">, </span><span class="s3">'opg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_complex_step</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_centered</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s4"># default covariance type (opg)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_opg'</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># complex step</span>
        <span class="s1">bse = self.result._cov_params_approx(</span>
            <span class="s1">approx_complex_step=</span><span class="s2">True</span><span class="s1">).diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

        <span class="s4"># The below tests do not pass</span>
        <span class="s4"># with warnings.catch_warnings():</span>
        <span class="s4">#     warnings.simplefilter(&quot;ignore&quot;)</span>

        <span class="s4">#     # finite difference, non-centered : failure with NaNs</span>
        <span class="s4">#     bse = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False).diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_ma_oim'], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_seasonal_ma_oim'],</span>
        <span class="s4">#                     atol=1e-2)</span>

        <span class="s4">#     # finite difference, centered : failure with NaNs</span>
        <span class="s4">#     cpa = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False, approx_centered=True)</span>
        <span class="s4">#     bse = cpa.diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_ma_oim'], atol=1e-4)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_seasonal_ma_oim'],</span>
        <span class="s4">#                     atol=1e-4)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># OIM covariance type</span>
        <span class="s1">oim_bse = self.result.cov_params_oim.diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(oim_bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(oim_bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_seasonal_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Friedman(SARIMAXStataTests):</span>
    <span class="s0">&quot;&quot;&quot; 
    ARMAX model: Friedman quantity theory of money 
 
    Stata arima documentation, Example 4 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">exog=</span><span class="s2">None, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">cls.true = true</span>
        <span class="s1">endog = np.r_[true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'consump'</span><span class="s1">]]</span>
        <span class="s2">if </span><span class="s1">exog </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">exog = add_constant(true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'m2'</span><span class="s1">])</span>

        <span class="s1">kwargs.setdefault(</span><span class="s3">'simple_differencing'</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'hamilton_representation'</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">cls.model = sarimax.SARIMAX(</span>
            <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s1">params = np.r_[true[</span><span class="s3">'params_exog'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_ar'</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">true[</span><span class="s3">'params_ma'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_variance'</span><span class="s1">]]</span>

        <span class="s1">cls.result = cls.model.filter(params)</span>


<span class="s2">class </span><span class="s1">TestFriedmanMLERegression(Friedman):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
 
    Standard errors are very good for the OPG and complex step approximation 
    cases. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestFriedmanMLERegression</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">results_sarimax.friedman2_mle</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s1">result = self.model.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4"># Use ratio to make atol more meaningful parameter scale differs</span>
        <span class="s1">ratio = result.params / self.result.params</span>
        <span class="s1">assert_allclose(ratio</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s5">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># test defaults</span>
        <span class="s1">assert_equal(self.result.cov_type</span><span class="s2">, </span><span class="s3">'opg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_complex_step</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_centered</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s4"># default covariance type (opg)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_exog_opg'</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># complex step</span>
        <span class="s1">bse = self.result._cov_params_approx(</span>
            <span class="s1">approx_complex_step=</span><span class="s2">True</span><span class="s1">).diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_exog_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

        <span class="s4"># The below tests pass irregularly; they give a sense of the precision</span>
        <span class="s4"># available with finite differencing</span>
        <span class="s4"># with warnings.catch_warnings():</span>
        <span class="s4">#     warnings.simplefilter(&quot;ignore&quot;)</span>

        <span class="s4">#     # finite difference, non-centered</span>
        <span class="s4">#     bse = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False).diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_exog_oim'][0], rtol=1)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_exog_oim'][1], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[2], self.true['se_ar_oim'], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[3], self.true['se_ma_oim'], atol=1e-2)</span>

        <span class="s4">#     # finite difference, centered</span>
        <span class="s4">#     cpa = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False, approx_centered=True)</span>
        <span class="s4">#     bse = cpa.diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_exog_oim'][0], rtol=1)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_exog_oim'][1], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[2], self.true['se_ar_oim'], atol=1e-2)</span>
        <span class="s4">#     assert_allclose(bse[3], self.true['se_ma_oim'], atol=1e-2)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># OIM covariance type</span>
        <span class="s1">bse = self.result.cov_params_oim.diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_exog_oim'</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_exog_oim'</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestFriedmanStateRegression(Friedman):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
 
    MLE is not very close and standard errors are not very close for any set of 
    parameters. 
 
    This is likely because we're comparing against the model where the 
    regression coefficients are also estimated by MLE. So this test should be 
    considered just a very basic &quot;sanity&quot; test. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s4"># Remove the regression coefficients from the parameters, since they</span>
        <span class="s4"># will be estimated as part of the state vector</span>
        <span class="s1">true = dict(results_sarimax.friedman2_mle)</span>
        <span class="s1">exog = add_constant(true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'m2'</span><span class="s1">]) / </span><span class="s5">10.</span>

        <span class="s1">true[</span><span class="s3">'mle_params_exog'</span><span class="s1">] = true[</span><span class="s3">'params_exog'</span><span class="s1">][:]</span>
        <span class="s1">true[</span><span class="s3">'mle_se_exog'</span><span class="s1">] = true[</span><span class="s3">'se_exog_opg'</span><span class="s1">][:]</span>

        <span class="s1">true[</span><span class="s3">'params_exog'</span><span class="s1">] = []</span>
        <span class="s1">true[</span><span class="s3">'se_exog'</span><span class="s1">] = []</span>

        <span class="s1">super(TestFriedmanStateRegression</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">mle_regression=</span><span class="s2">False</span>
        <span class="s1">)</span>

        <span class="s1">cls.true_params = np.r_[true[</span><span class="s3">'params_exog'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_ar'</span><span class="s1">]</span><span class="s2">,</span>
                                <span class="s1">true[</span><span class="s3">'params_ma'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s3">'params_variance'</span><span class="s1">]]</span>

        <span class="s1">cls.result = cls.model.filter(cls.true_params)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s1">result = self.model.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.params</span><span class="s2">, </span><span class="s1">self.result.params</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">2e-1</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_regression_parameters(self):</span>
        <span class="s4"># The regression effects are integrated into the state vector as</span>
        <span class="s4"># the last two states (thus the index [-2:]). The filtered</span>
        <span class="s4"># estimates of the state vector produced by the Kalman filter and</span>
        <span class="s4"># stored in `filtered_state` for these state elements give the</span>
        <span class="s4"># recursive least squares estimates of the regression coefficients</span>
        <span class="s4"># at each time period. To get the estimates conditional on the</span>
        <span class="s4"># entire dataset, use the filtered states from the last time</span>
        <span class="s4"># period (thus the index [-1]).</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.filter_results.filtered_state[-</span><span class="s5">2</span><span class="s1">:</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">] / </span><span class="s5">10.</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'mle_params_exog'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span>
        <span class="s1">)</span>

    <span class="s4"># Loglikelihood (and so aic, bic) is slightly different when states are</span>
    <span class="s4"># integrated into the state vector</span>
    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s4"># test defaults</span>
        <span class="s1">assert_equal(self.result.cov_type</span><span class="s2">, </span><span class="s3">'opg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_complex_step</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(self.result._cov_approx_centered</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s4"># default covariance type (opg)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.result.bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_opg'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># complex step</span>
        <span class="s1">bse = self.result._cov_params_approx(</span>
            <span class="s1">approx_complex_step=</span><span class="s2">True</span><span class="s1">).diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>

        <span class="s4"># The below tests do not pass</span>
        <span class="s4"># with warnings.catch_warnings():</span>
        <span class="s4">#     warnings.simplefilter(&quot;ignore&quot;)</span>

        <span class="s4">#     # finite difference, non-centered :</span>
        <span class="s4">#     #  failure (catastrophic cancellation)</span>
        <span class="s4">#     bse = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False).diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_ar_oim'], atol=1e-3)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_ma_oim'], atol=1e-2)</span>

        <span class="s4">#     # finite difference, centered : failure (nan)</span>
        <span class="s4">#     cpa = self.result._cov_params_approx(</span>
        <span class="s4">#         approx_complex_step=False, approx_centered=True)</span>
        <span class="s4">#     bse = cpa.diagonal()**0.5</span>
        <span class="s4">#     assert_allclose(bse[0], self.true['se_ar_oim'], atol=1e-3)</span>
        <span class="s4">#     assert_allclose(bse[1], self.true['se_ma_oim'], atol=1e-3)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># OIM covariance type</span>
        <span class="s1">bse = self.result._cov_params_oim().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ar_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(bse[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'se_ma_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestFriedmanPredict(Friedman):</span>
    <span class="s0">&quot;&quot;&quot; 
    ARMAX model: Friedman quantity theory of money, prediction 
 
    Stata arima postestimation documentation, Example 1 - Dynamic forecasts 
 
    This follows the given Stata example, although it is not truly forecasting 
    because it compares using the actual data (which is available in the 
    example but just not used in the parameter MLE estimation) against dynamic 
    prediction of that data. Here `test_predict` matches the first case, and 
    `test_dynamic_predict` matches the second. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestFriedmanPredict</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">results_sarimax.friedman2_predict</span>
        <span class="s1">)</span>

    <span class="s4"># loglike, aic, bic are not the point of this test (they could pass, but we</span>
    <span class="s4"># would have to modify the data so that they were calculated to</span>
    <span class="s4"># exclude the last 15 observations)</span>
    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.predict()</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'predict'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">3</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s1">dynamic = len(self.true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'consump'</span><span class="s1">])-</span><span class="s5">15</span><span class="s1">-</span><span class="s5">1</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.predict(dynamic=dynamic)</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'dynamic_predict'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">3</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestFriedmanForecast(Friedman):</span>
    <span class="s0">&quot;&quot;&quot; 
    ARMAX model: Friedman quantity theory of money, forecasts 
 
    Variation on: 
    Stata arima postestimation documentation, Example 1 - Dynamic forecasts 
 
    This is a variation of the Stata example, in which the endogenous data is 
    actually made to be missing so that the predict command must forecast. 
 
    As another unit test, we also compare against the case in State when 
    predict is used against missing data (so forecasting) with the dynamic 
    option also included. Note, however, that forecasting in State space models 
    amounts to running the Kalman filter against missing datapoints, so it is 
    not clear whether &quot;dynamic&quot; forecasting (where instead of missing 
    datapoints for lags, we plug in previous forecasted endog values) is 
    meaningful. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = dict(results_sarimax.friedman2_predict)</span>

        <span class="s1">true[</span><span class="s3">'forecast_data'</span><span class="s1">] = {</span>
            <span class="s3">'consump'</span><span class="s1">: true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'consump'</span><span class="s1">][-</span><span class="s5">15</span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s3">'m2'</span><span class="s1">: true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'m2'</span><span class="s1">][-</span><span class="s5">15</span><span class="s1">:]</span>
        <span class="s1">}</span>
        <span class="s1">true[</span><span class="s3">'data'</span><span class="s1">] = {</span>
            <span class="s3">'consump'</span><span class="s1">: true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'consump'</span><span class="s1">][:-</span><span class="s5">15</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s3">'m2'</span><span class="s1">: true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'m2'</span><span class="s1">][:-</span><span class="s5">15</span><span class="s1">]</span>
        <span class="s1">}</span>

        <span class="s1">super(TestFriedmanForecast</span><span class="s2">, </span><span class="s1">cls).setup_class(true)</span>

        <span class="s1">cls.result = cls.model.filter(cls.result.params)</span>

    <span class="s4"># loglike, aic, bic are not the point of this test (they could pass, but we</span>
    <span class="s4"># would have to modify the data so that they were calculated to</span>
    <span class="s4"># exclude the last 15 observations)</span>
    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_forecast(self):</span>
        <span class="s1">end = len(self.true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'consump'</span><span class="s1">])+</span><span class="s5">15</span><span class="s1">-</span><span class="s5">1</span>
        <span class="s1">exog = add_constant(self.true[</span><span class="s3">'forecast_data'</span><span class="s1">][</span><span class="s3">'m2'</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.predict(end=end</span><span class="s2">, </span><span class="s1">exog=exog)</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'forecast'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">3</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_forecast(self):</span>
        <span class="s1">end = len(self.true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'consump'</span><span class="s1">])+</span><span class="s5">15</span><span class="s1">-</span><span class="s5">1</span>
        <span class="s1">dynamic = len(self.true[</span><span class="s3">'data'</span><span class="s1">][</span><span class="s3">'consump'</span><span class="s1">])-</span><span class="s5">1</span>
        <span class="s1">exog = add_constant(self.true[</span><span class="s3">'forecast_data'</span><span class="s1">][</span><span class="s3">'m2'</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.result.predict(end=end</span><span class="s2">, </span><span class="s1">dynamic=dynamic</span><span class="s2">, </span><span class="s1">exog=exog)</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'dynamic_forecast'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">3</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">SARIMAXCoverageTest:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">endog=</span><span class="s2">None, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Dataset</span>
        <span class="s2">if </span><span class="s1">endog </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">endog = results_sarimax.wpi1_data</span>

        <span class="s4"># Loglikelihood, parameters</span>
        <span class="s1">cls.true_loglike = coverage_results.loc[i][</span><span class="s3">'llf'</span><span class="s1">]</span>
        <span class="s1">cls.true_params = np.array([</span>
            <span class="s1">float(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">coverage_results.loc[i][</span><span class="s3">'parameters'</span><span class="s1">].split(</span><span class="s3">','</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s4"># Stata reports the standard deviation; make it the variance</span>
        <span class="s1">cls.true_params[-</span><span class="s5">1</span><span class="s1">] = cls.true_params[-</span><span class="s5">1</span><span class="s1">]**</span><span class="s5">2</span>

        <span class="s4"># Test parameters</span>
        <span class="s1">cls.decimal = decimal</span>

        <span class="s4"># Compare using the Hamilton representation and simple differencing</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'simple_differencing'</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'hamilton_representation'</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">cls.model = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">self.result = self.model.filter(self.true_params)</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result.llf</span><span class="s2">,</span>
            <span class="s1">self.true_loglike</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">0.7 </span><span class="s1">* </span><span class="s5">10</span><span class="s1">**(-self.decimal)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_start_params(self):</span>
        <span class="s4"># just a quick test that start_params is not throwing an exception</span>
        <span class="s4"># (other than related to invertibility)</span>
        <span class="s1">stat = self.model.enforce_stationarity</span>
        <span class="s1">inv = self.model.enforce_invertibility</span>
        <span class="s1">self.model.enforce_stationarity = </span><span class="s2">False</span>
        <span class="s1">self.model.enforce_invertibility = </span><span class="s2">False</span>
        <span class="s1">self.model.start_params</span>
        <span class="s1">self.model.enforce_stationarity = stat</span>
        <span class="s1">self.model.enforce_invertibility = inv</span>

    <span class="s2">def </span><span class="s1">test_transform_untransform(self):</span>
        <span class="s1">model = self.model</span>
        <span class="s1">stat</span><span class="s2">, </span><span class="s1">inv = model.enforce_stationarity</span><span class="s2">, </span><span class="s1">model.enforce_invertibility</span>
        <span class="s1">true_constrained = self.true_params</span>

        <span class="s4"># Sometimes the parameters given by Stata are not stationary and / or</span>
        <span class="s4"># invertible, so we need to skip those transformations for those</span>
        <span class="s4"># parameter sets</span>
        <span class="s1">model.update(self.true_params)</span>

        <span class="s1">par = model.polynomial_ar</span>
        <span class="s1">psar = model.polynomial_seasonal_ar</span>
        <span class="s1">contracted_psar = psar[psar.nonzero()]</span>
        <span class="s1">model.enforce_stationarity = (</span>
            <span class="s1">(model.k_ar == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">tools.is_invertible(np.r_[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-par[</span><span class="s5">1</span><span class="s1">:]])) </span><span class="s2">and</span>
            <span class="s1">(len(contracted_psar) &lt;= </span><span class="s5">1 </span><span class="s2">or</span>
                <span class="s1">tools.is_invertible(np.r_[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-contracted_psar[</span><span class="s5">1</span><span class="s1">:]]))</span>
        <span class="s1">)</span>

        <span class="s1">pma = model.polynomial_ma</span>
        <span class="s1">psma = model.polynomial_seasonal_ma</span>
        <span class="s1">contracted_psma = psma[psma.nonzero()]</span>
        <span class="s1">model.enforce_invertibility = (</span>
            <span class="s1">(model.k_ma == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">tools.is_invertible(np.r_[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">pma[</span><span class="s5">1</span><span class="s1">:]])) </span><span class="s2">and</span>
            <span class="s1">(len(contracted_psma) &lt;= </span><span class="s5">1 </span><span class="s2">or</span>
                <span class="s1">tools.is_invertible(np.r_[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">contracted_psma[</span><span class="s5">1</span><span class="s1">:]]))</span>
        <span class="s1">)</span>

        <span class="s1">unconstrained = model.untransform_params(true_constrained)</span>
        <span class="s1">constrained = model.transform_params(unconstrained)</span>

        <span class="s1">assert_almost_equal(constrained</span><span class="s2">, </span><span class="s1">true_constrained</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">model.enforce_stationarity = stat</span>
        <span class="s1">model.enforce_invertibility = inv</span>

    <span class="s2">def </span><span class="s1">test_results(self):</span>
        <span class="s1">self.result = self.model.filter(self.true_params)</span>

        <span class="s4"># Just make sure that no exceptions are thrown during summary</span>
        <span class="s1">self.result.summary()</span>

        <span class="s4"># Make sure no expections are thrown calculating any of the</span>
        <span class="s4"># covariance matrix types</span>
        <span class="s1">self.result.cov_params_default</span>
        <span class="s1">self.result.cov_params_approx</span>
        <span class="s1">self.result.cov_params_oim</span>
        <span class="s1">self.result.cov_params_opg</span>
        <span class="s1">self.result.cov_params_robust_oim</span>
        <span class="s1">self.result.cov_params_robust_approx</span>

    <span class="s1">@pytest.mark.matplotlib</span>
    <span class="s2">def </span><span class="s1">test_plot_diagnostics(self</span><span class="s2">, </span><span class="s1">close_figures):</span>
        <span class="s4"># Make sure that no exceptions are thrown during plot_diagnostics</span>
        <span class="s1">self.result = self.model.filter(self.true_params)</span>
        <span class="s1">self.result.plot_diagnostics()</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">result = self.model.filter(self.true_params)</span>
        <span class="s4"># Test predict does not throw exceptions, and produces the right shaped</span>
        <span class="s4"># output</span>
        <span class="s1">predict = result.predict()</span>
        <span class="s1">assert_equal(predict.shape</span><span class="s2">, </span><span class="s1">(self.model.nobs</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s1">predict = result.predict(start=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">end=</span><span class="s5">20</span><span class="s1">)</span>
        <span class="s1">assert_equal(predict.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">11</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s1">predict = result.predict(start=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">end=</span><span class="s5">20</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">assert_equal(predict.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">11</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s4"># Test forecasts</span>
        <span class="s2">if </span><span class="s1">self.model.k_exog == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">predict = result.predict(start=self.model.nobs</span><span class="s2">,</span>
                                     <span class="s1">end=self.model.nobs+</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dynamic=-</span><span class="s5">10</span><span class="s1">)</span>
            <span class="s1">assert_equal(predict.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">11</span><span class="s2">,</span><span class="s1">))</span>

            <span class="s1">predict = result.predict(start=self.model.nobs</span><span class="s2">,</span>
                                     <span class="s1">end=self.model.nobs+</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dynamic=-</span><span class="s5">10</span><span class="s1">)</span>

            <span class="s1">forecast = result.forecast()</span>
            <span class="s1">assert_equal(forecast.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">))</span>

            <span class="s1">forecast = result.forecast(</span><span class="s5">10</span><span class="s1">)</span>
            <span class="s1">assert_equal(forecast.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">10</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">k_exog = self.model.k_exog</span>
            <span class="s1">exog = np.r_[[</span><span class="s5">0</span><span class="s1">]*k_exog*</span><span class="s5">11</span><span class="s1">].reshape(</span><span class="s5">11</span><span class="s2">, </span><span class="s1">k_exog)</span>

            <span class="s1">predict = result.predict(start=self.model.nobs</span><span class="s2">,</span>
                                     <span class="s1">end=self.model.nobs+</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dynamic=-</span><span class="s5">10</span><span class="s2">,</span>
                                     <span class="s1">exog=exog)</span>
            <span class="s1">assert_equal(predict.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">11</span><span class="s2">,</span><span class="s1">))</span>

            <span class="s1">predict = result.predict(start=self.model.nobs</span><span class="s2">,</span>
                                     <span class="s1">end=self.model.nobs+</span><span class="s5">10</span><span class="s2">, </span><span class="s1">dynamic=-</span><span class="s5">10</span><span class="s2">,</span>
                                     <span class="s1">exog=exog)</span>

            <span class="s1">exog = np.r_[[</span><span class="s5">0</span><span class="s1">]*k_exog].reshape(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">k_exog)</span>
            <span class="s1">forecast = result.forecast(exog=exog)</span>
            <span class="s1">assert_equal(forecast.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_init_keys_replicate(self):</span>
        <span class="s1">mod1 = self.model</span>

        <span class="s1">kwargs = self.model._get_init_kwds()</span>
        <span class="s1">endog = mod1.data.orig_endog</span>
        <span class="s1">exog = mod1.data.orig_exog</span>

        <span class="s1">model2 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">res1 = self.model.filter(self.true_params)</span>
        <span class="s1">res2 = model2.filter(self.true_params)</span>
        <span class="s1">rtol = </span><span class="s5">1e-6 </span><span class="s2">if </span><span class="s1">PLATFORM_WIN </span><span class="s2">else </span><span class="s5">1e-13</span>
        <span class="s1">assert_allclose(res2.llf</span><span class="s2">, </span><span class="s1">res1.llf</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>


<span class="s2">class </span><span class="s1">Test_ar(SARIMAXCoverageTest):</span>
    <span class="s4"># // AR: (p, 0, 0) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(3, 0, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 1</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">super(Test_ar</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ar_as_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // AR: (p, 0, 0) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(3, 0, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 1</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = ([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">super(Test_ar_as_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ar_trend_c(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'c'</span>
    <span class="s4"># arima wpi c, arima(3, 0, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 2</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'c'</span>
        <span class="s1">super(Test_ar_trend_c</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[</span><span class="s5">0</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">].sum()) * tps[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_ar_trend_ct(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'ct'</span>
    <span class="s4"># arima wpi c t, arima(3, 0, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 3</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'ct'</span>
        <span class="s1">super(Test_ar_trend_ct</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">2</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[:</span><span class="s5">2</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_ar_trend_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // polynomial [1, 0, 0, 1]</span>
    <span class="s4"># arima wpi c t3, arima(3, 0, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 4</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">super(Test_ar_trend_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">2</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[:</span><span class="s5">2</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_ar_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // AR and I(d): (p, d, 0) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(3, 2, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 5</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">super(Test_ar_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">4</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ar_seasonal_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // AR and I(D): (p, 0, 0) x (0, D, 0, s)</span>
    <span class="s4"># arima wpi, arima(3, 0, 0) sarima(0, 2, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 6</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_ar_seasonal_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">5</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ar_diffuse(SARIMAXCoverageTest):</span>
    <span class="s4"># // AR and diffuse initialization</span>
    <span class="s4"># arima wpi, arima(3, 0, 0) noconstant vce(oim) diffuse</span>
    <span class="s4"># save_results 7</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'initialization'</span><span class="s1">] = </span><span class="s3">'approximate_diffuse'</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = </span><span class="s5">1e9</span>
        <span class="s1">super(Test_ar_diffuse</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">6</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ar_no_enforce(SARIMAXCoverageTest):</span>
    <span class="s4"># // AR: (p, 0, 0) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(3, 0, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 1</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'enforce_stationarity'</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s1">kwargs[</span><span class="s3">'enforce_invertibility'</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = </span><span class="s5">1e9</span>
        <span class="s1">kwargs[</span><span class="s3">'loglikelihood_burn'</span><span class="s1">] = </span><span class="s5">0</span>
        <span class="s1">super(Test_ar_no_enforce</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">6</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s4"># Reset loglikelihood burn, which gets automatically set to the number</span>
        <span class="s4"># of states if enforce_stationarity = False</span>
        <span class="s1">cls.model.ssm.loglikelihood_burn = </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">test_init_keys_replicate(self):</span>
        <span class="s1">mod1 = self.model</span>

        <span class="s1">kwargs = self.model._get_init_kwds()</span>
        <span class="s1">endog = mod1.data.orig_endog</span>
        <span class="s1">exog = mod1.data.orig_exog</span>

        <span class="s1">model2 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s4"># Fixes needed for edge case model</span>
        <span class="s1">model2.ssm.initialization = mod1.ssm.initialization</span>

        <span class="s1">res1 = self.model.filter(self.true_params)</span>
        <span class="s1">res2 = model2.filter(self.true_params)</span>
        <span class="s1">rtol = </span><span class="s5">1e-6 </span><span class="s2">if </span><span class="s1">PLATFORM_WIN </span><span class="s2">else </span><span class="s5">1e-13</span>
        <span class="s1">assert_allclose(res2.llf</span><span class="s2">, </span><span class="s1">res1.llf</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>


<span class="s2">class </span><span class="s1">Test_ar_exogenous(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARX</span>
    <span class="s4"># arima wpi x, arima(3, 0, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 8</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">super(Test_ar_exogenous</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">7</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ar_exogenous_in_state(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARX</span>
    <span class="s4"># arima wpi x, arima(3, 0, 0) noconstant vce(oim)</span>
    <span class="s4"># save_results 8</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">kwargs[</span><span class="s3">'mle_regression'</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s1">super(Test_ar_exogenous_in_state</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">7</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">cls.true_regression_coefficient = cls.true_params[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">cls.true_params = cls.true_params[</span><span class="s5">1</span><span class="s1">:]</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s4"># Regression in the state vector gives a different loglikelihood, so</span>
        <span class="s4"># just check that it's approximately the same</span>
        <span class="s1">self.result = self.model.filter(self.true_params)</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result.llf</span><span class="s2">,</span>
            <span class="s1">self.true_loglike</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">2</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_regression_coefficient(self):</span>
        <span class="s4"># Test that the regression coefficient (estimated as the last filtered</span>
        <span class="s4"># state estimate for the regression state) is the same as the Stata</span>
        <span class="s4"># MLE state</span>
        <span class="s1">self.result = self.model.filter(self.true_params)</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">self.result.filter_results.filtered_state[</span><span class="s5">3</span><span class="s1">][-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">self.true_regression_coefficient</span><span class="s2">,</span>
            <span class="s1">self.decimal</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Test_ma(SARIMAXCoverageTest):</span>
    <span class="s4"># // MA: (0, 0, q) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(0, 0, 3) noconstant vce(oim)</span>
    <span class="s4"># save_results 9</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">super(Test_ma</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">8</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ma_as_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // MA: (0, 0, q) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(0, 0, 3) noconstant vce(oim)</span>
    <span class="s4"># save_results 9</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">super(Test_ma_as_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">8</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ma_trend_c(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'c'</span>
    <span class="s4"># arima wpi c, arima(0, 0, 3) noconstant vce(oim)</span>
    <span class="s4"># save_results 10</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'c'</span>
        <span class="s1">super(Test_ma_trend_c</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">9</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ma_trend_ct(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'ct'</span>
    <span class="s4"># arima wpi c t, arima(0, 0, 3) noconstant vce(oim)</span>
    <span class="s4"># save_results 11</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'ct'</span>
        <span class="s1">super(Test_ma_trend_ct</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ma_trend_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // polynomial [1, 0, 0, 1]</span>
    <span class="s4"># arima wpi c t3, arima(0, 0, 3) noconstant vce(oim)</span>
    <span class="s4"># save_results 12</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">super(Test_ma_trend_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">11</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ma_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // MA and I(d): (0, d, q) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(0, 2, 3) noconstant vce(oim)</span>
    <span class="s4"># save_results 13</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">super(Test_ma_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">12</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ma_seasonal_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // MA and I(D): (p, 0, 0) x (0, D, 0, s)</span>
    <span class="s4"># arima wpi, arima(0, 0, 3) sarima(0, 2, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 14</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_ma_seasonal_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">13</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ma_diffuse(SARIMAXCoverageTest):</span>
    <span class="s4"># // MA and diffuse initialization</span>
    <span class="s4"># arima wpi, arima(0, 0, 3) noconstant vce(oim) diffuse</span>
    <span class="s4"># save_results 15</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'initialization'</span><span class="s1">] = </span><span class="s3">'approximate_diffuse'</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = </span><span class="s5">1e9</span>
        <span class="s1">super(Test_ma_diffuse</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">14</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_ma_exogenous(SARIMAXCoverageTest):</span>
    <span class="s4"># // MAX</span>
    <span class="s4"># arima wpi x, arima(0, 0, 3) noconstant vce(oim)</span>
    <span class="s4"># save_results 16</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">super(Test_ma_exogenous</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">15</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_arma(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARMA: (p, 0, q) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(3, 0, 3) noconstant vce(oim)</span>
    <span class="s4"># save_results 17</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">super(Test_arma</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">16</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_arma_trend_c(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'c'</span>
    <span class="s4"># arima wpi c, arima(3, 0, 2) noconstant vce(oim)</span>
    <span class="s4"># save_results 18</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'c'</span>
        <span class="s1">super(Test_arma_trend_c</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">17</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">1</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">].sum()) * tps[:</span><span class="s5">1</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_arma_trend_ct(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'ct'</span>
    <span class="s4"># arima wpi c t, arima(3, 0, 2) noconstant vce(oim)</span>
    <span class="s4"># save_results 19</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'ct'</span>
        <span class="s1">super(Test_arma_trend_ct</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">18</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">2</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[:</span><span class="s5">2</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_arma_trend_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // polynomial [1, 0, 0, 1]</span>
    <span class="s4"># arima wpi c t3, arima(3, 0, 2) noconstant vce(oim)</span>
    <span class="s4"># save_results 20</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">super(Test_arma_trend_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">19</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">2</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[:</span><span class="s5">2</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_arma_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARMA and I(d): (p, d, q) x (0, 0, 0, 0)</span>
    <span class="s4"># arima wpi, arima(3, 2, 2) noconstant vce(oim)</span>
    <span class="s4"># save_results 21</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">super(Test_arma_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">20</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_arma_seasonal_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARMA and I(D): (p, 0, q) x (0, D, 0, s)</span>
    <span class="s4"># arima wpi, arima(3, 0, 2) sarima(0, 2, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 22</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_arma_seasonal_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">21</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_arma_diff_seasonal_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARMA and I(d) and I(D): (p, d, q) x (0, D, 0, s)</span>
    <span class="s4"># arima wpi, arima(3, 2, 2) sarima(0, 2, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 23</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_arma_diff_seasonal_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">22</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_arma_diffuse(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARMA and diffuse initialization</span>
    <span class="s4"># arima wpi, arima(3, 0, 2) noconstant vce(oim) diffuse</span>
    <span class="s4"># save_results 24</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'initialization'</span><span class="s1">] = </span><span class="s3">'approximate_diffuse'</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = </span><span class="s5">1e9</span>
        <span class="s1">super(Test_arma_diffuse</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">23</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_arma_exogenous(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARMAX</span>
    <span class="s4"># arima wpi x, arima(3, 0, 2) noconstant vce(oim)</span>
    <span class="s4"># save_results 25</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">super(Test_arma_exogenous</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">24</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar(SARIMAXCoverageTest):</span>
    <span class="s4"># // SAR: (0, 0, 0) x (P, 0, 0, s)</span>
    <span class="s4"># arima wpi, sarima(3, 0, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 26</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_ar</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">25</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar_as_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // SAR: (0, 0, 0) x (P, 0, 0, s)</span>
    <span class="s4"># arima wpi, sarima(3, 0, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 26</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = ([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_ar_as_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">25</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar_trend_c(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'c'</span>
    <span class="s4"># arima wpi c, sarima(3, 0, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 27</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'c'</span>
        <span class="s1">super(Test_seasonal_ar_trend_c</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">26</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">1</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">].sum()) * tps[:</span><span class="s5">1</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar_trend_ct(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'ct'</span>
    <span class="s4"># arima wpi c t, sarima(3, 0, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 28</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'ct'</span>
        <span class="s1">super(Test_seasonal_ar_trend_ct</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">27</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">2</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[:</span><span class="s5">2</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar_trend_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // polynomial [1, 0, 0, 1]</span>
    <span class="s4"># arima wpi c t3, sarima(3, 0, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 29</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">super(Test_seasonal_ar_trend_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">28</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">2</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[:</span><span class="s5">2</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // SAR and I(d): (0, d, 0) x (P, 0, 0, s)</span>
    <span class="s4"># arima wpi, arima(0, 2, 0) sarima(3, 0, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 30</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_ar_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">29</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar_seasonal_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // SAR and I(D): (0, 0, 0) x (P, D, 0, s)</span>
    <span class="s4"># arima wpi, sarima(3, 2, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 31</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_ar_seasonal_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">30</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar_diffuse(SARIMAXCoverageTest):</span>
    <span class="s4"># // SAR and diffuse initialization</span>
    <span class="s4"># arima wpi, sarima(3, 0, 0, 4) noconstant vce(oim) diffuse</span>
    <span class="s4"># save_results 32</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'initialization'</span><span class="s1">] = </span><span class="s3">'approximate_diffuse'</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = </span><span class="s5">1e9</span>
        <span class="s1">super(Test_seasonal_ar_diffuse</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">31</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ar_exogenous(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARX</span>
    <span class="s4"># arima wpi x, sarima(3, 0, 0, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 33</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">super(Test_seasonal_ar_exogenous</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">32</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma(SARIMAXCoverageTest):</span>
    <span class="s4"># // SMA</span>
    <span class="s4"># arima wpi, sarima(0, 0, 3, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 34</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_ma</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">33</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma_as_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // SMA</span>
    <span class="s4"># arima wpi, sarima(0, 0, 3, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 34</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_ma_as_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">33</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma_trend_c(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'c'</span>
    <span class="s4"># arima wpi c, sarima(0, 0, 3, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 35</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'c'</span>
        <span class="s1">kwargs[</span><span class="s3">'decimal'</span><span class="s1">] = </span><span class="s5">3</span>
        <span class="s1">super(Test_seasonal_ma_trend_c</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">34</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma_trend_ct(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'ct'</span>
    <span class="s4"># arima wpi c t, sarima(0, 0, 3, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 36</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'ct'</span>
        <span class="s1">super(Test_seasonal_ma_trend_ct</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">35</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma_trend_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // polynomial [1, 0, 0, 1]</span>
    <span class="s4"># arima wpi c t3, sarima(0, 0, 3, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 37</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">kwargs[</span><span class="s3">'decimal'</span><span class="s1">] = </span><span class="s5">3</span>
        <span class="s1">super(Test_seasonal_ma_trend_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">36</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // SMA and I(d): (0, d, 0) x (0, 0, Q, s)</span>
    <span class="s4"># arima wpi, arima(0, 2, 0) sarima(0, 0, 3, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 38</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_ma_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">37</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma_seasonal_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // SMA and I(D): (0, 0, 0) x (0, D, Q, s)</span>
    <span class="s4"># arima wpi, sarima(0, 2, 3, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 39</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_ma_seasonal_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">38</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma_diffuse(SARIMAXCoverageTest):</span>
    <span class="s4"># // SMA and diffuse initialization</span>
    <span class="s4"># arima wpi, sarima(0, 0, 3, 4) noconstant vce(oim) diffuse</span>
    <span class="s4"># save_results 40</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'initialization'</span><span class="s1">] = </span><span class="s3">'approximate_diffuse'</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = </span><span class="s5">1e9</span>
        <span class="s1">super(Test_seasonal_ma_diffuse</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">39</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_ma_exogenous(SARIMAXCoverageTest):</span>
    <span class="s4"># // SMAX</span>
    <span class="s4"># arima wpi x, sarima(0, 0, 3, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 41</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">super(Test_seasonal_ma_exogenous</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">40</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARMA: (0, 0, 0) x (P, 0, Q, s)</span>
    <span class="s4"># arima wpi, sarima(3, 0, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 42</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_arma</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">41</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma_trend_c(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'c'</span>
    <span class="s4"># arima wpi c, sarima(3, 0, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 43</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'c'</span>
        <span class="s1">super(Test_seasonal_arma_trend_c</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">42</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">1</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">].sum()) * tps[:</span><span class="s5">1</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma_trend_ct(SARIMAXCoverageTest):</span>
    <span class="s4"># // 'ct'</span>
    <span class="s4"># arima wpi c t, sarima(3, 0, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 44</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = </span><span class="s3">'ct'</span>
        <span class="s1">super(Test_seasonal_arma_trend_ct</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">43</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">2</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[:</span><span class="s5">2</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma_trend_polynomial(SARIMAXCoverageTest):</span>
    <span class="s4"># // polynomial [1, 0, 0, 1]</span>
    <span class="s4"># arima wpi c t3, sarima(3, 0, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 45</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">kwargs[</span><span class="s3">'decimal'</span><span class="s1">] = </span><span class="s5">3</span>
        <span class="s1">super(Test_seasonal_arma_trend_polynomial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">44</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[:</span><span class="s5">2</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[:</span><span class="s5">2</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_results(self):</span>
        <span class="s1">self.result = self.model.filter(self.true_params)</span>

        <span class="s4"># Just make sure that no exceptions are thrown during summary</span>
        <span class="s1">self.result.summary()</span>

        <span class="s4"># Make sure no expections are thrown calculating any of the</span>
        <span class="s4"># covariance matrix types</span>
        <span class="s1">self.result.cov_params_default</span>
        <span class="s4"># Known failure due to the complex step inducing non-stationary</span>
        <span class="s4"># parameters, causing a failure in the solve_discrete_lyapunov call</span>
        <span class="s4"># self.result.cov_params_approx</span>
        <span class="s1">self.result.cov_params_oim</span>
        <span class="s1">self.result.cov_params_opg</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARMA and I(d): (0, d, 0) x (P, 0, Q, s)</span>
    <span class="s4"># arima wpi, arima(0, 2, 0) sarima(3, 0, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 46</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_arma_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">45</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma_seasonal_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARMA and I(D): (0, 0, 0) x (P, D, Q, s)</span>
    <span class="s4"># arima wpi, sarima(3, 2, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 47</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_arma_seasonal_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">46</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma_diff_seasonal_diff(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARMA and I(d) and I(D): (0, d, 0) x (P, D, Q, s)</span>
    <span class="s4"># arima wpi, arima(0, 2, 0) sarima(3, 2, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 48</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">super(Test_seasonal_arma_diff_seasonal_diff</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">47</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_results(self):</span>
        <span class="s1">self.result = self.model.filter(self.true_params)</span>

        <span class="s4"># Just make sure that no exceptions are thrown during summary</span>
        <span class="s1">self.result.summary()</span>

        <span class="s4"># Make sure no expections are thrown calculating any of the</span>
        <span class="s4"># covariance matrix types</span>
        <span class="s1">self.result.cov_params_default</span>
        <span class="s4"># Known failure due to the complex step inducing non-stationary</span>
        <span class="s4"># parameters, causing a failure in the solve_discrete_lyapunov call</span>
        <span class="s4"># self.result.cov_params_approx</span>
        <span class="s1">self.result.cov_params_oim</span>
        <span class="s1">self.result.cov_params_opg</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma_diffuse(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARMA and diffuse initialization</span>
    <span class="s4"># arima wpi, sarima(3, 0, 2, 4) noconstant vce(oim) diffuse</span>
    <span class="s4"># save_results 49</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'decimal'</span><span class="s1">] = </span><span class="s5">3</span>
        <span class="s1">kwargs[</span><span class="s3">'initialization'</span><span class="s1">] = </span><span class="s3">'approximate_diffuse'</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = </span><span class="s5">1e9</span>
        <span class="s1">super(Test_seasonal_arma_diffuse</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">48</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_seasonal_arma_exogenous(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARMAX</span>
    <span class="s4"># arima wpi x, sarima(3, 0, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 50</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">super(Test_seasonal_arma_exogenous</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">49</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_sarimax_exogenous(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARIMAX and exogenous</span>
    <span class="s4"># arima wpi x, arima(3, 2, 2) sarima(3, 2, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 51</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">super(Test_sarimax_exogenous</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s5">50</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_results_params(self):</span>
        <span class="s1">result = self.model.filter(self.true_params)</span>
        <span class="s1">assert_allclose(self.true_params[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">result.arparams)</span>
        <span class="s1">assert_allclose(self.true_params[</span><span class="s5">4</span><span class="s1">:</span><span class="s5">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">result.maparams)</span>
        <span class="s1">assert_allclose(self.true_params[</span><span class="s5">6</span><span class="s1">:</span><span class="s5">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">result.seasonalarparams)</span>
        <span class="s1">assert_allclose(self.true_params[</span><span class="s5">9</span><span class="s1">:</span><span class="s5">11</span><span class="s1">]</span><span class="s2">, </span><span class="s1">result.seasonalmaparams)</span>


<span class="s2">class </span><span class="s1">Test_sarimax_exogenous_not_hamilton(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARIMAX and exogenous</span>
    <span class="s4"># arima wpi x, arima(3, 2, 2) sarima(3, 2, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># save_results 51</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">kwargs[</span><span class="s3">'hamilton_representation'</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s1">kwargs[</span><span class="s3">'simple_differencing'</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s1">super(Test_sarimax_exogenous_not_hamilton</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">50</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_sarimax_exogenous_diffuse(SARIMAXCoverageTest):</span>
    <span class="s4"># // SARIMAX and exogenous diffuse</span>
    <span class="s4"># arima wpi x, arima(3, 2, 2) sarima(3, 2, 2, 4) noconstant vce(oim)</span>
    <span class="s4"># diffuse</span>
    <span class="s4"># save_results 52</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'seasonal_order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">endog = results_sarimax.wpi1_data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = (endog - np.floor(endog))**</span><span class="s5">2</span>
        <span class="s1">kwargs[</span><span class="s3">'decimal'</span><span class="s1">] = </span><span class="s5">2</span>
        <span class="s1">kwargs[</span><span class="s3">'initialization'</span><span class="s1">] = </span><span class="s3">'approximate_diffuse'</span>
        <span class="s1">kwargs[</span><span class="s3">'initial_variance'</span><span class="s1">] = </span><span class="s5">1e9</span>
        <span class="s1">super(Test_sarimax_exogenous_diffuse</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">51</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Test_arma_exog_trend_polynomial_missing(SARIMAXCoverageTest):</span>
    <span class="s4"># // ARMA and exogenous and trend polynomial and missing</span>
    <span class="s4"># gen wpi2 = wpi</span>
    <span class="s4"># replace wpi2 = . in 10/19</span>
    <span class="s4"># arima wpi2 x c t3, arima(3, 0, 2) noconstant vce(oim)</span>
    <span class="s4"># save_results 53</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">endog = np.r_[results_sarimax.wpi1_data]</span>
        <span class="s4"># Note we're using the non-missing exog data</span>
        <span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] = ((endog - np.floor(endog))**</span><span class="s5">2</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">endog[</span><span class="s5">9</span><span class="s1">:</span><span class="s5">19</span><span class="s1">] = np.nan</span>
        <span class="s1">endog = endog[</span><span class="s5">1</span><span class="s1">:] - endog[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">endog[</span><span class="s5">9</span><span class="s1">] = np.nan</span>
        <span class="s1">kwargs[</span><span class="s3">'order'</span><span class="s1">] = (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'trend'</span><span class="s1">] = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">kwargs[</span><span class="s3">'decimal'</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">super(Test_arma_exog_trend_polynomial_missing</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s5">52</span><span class="s2">, </span><span class="s1">endog=endog</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># Modify true params to convert from mean to intercept form</span>
        <span class="s1">tps = cls.true_params</span>
        <span class="s1">cls.true_params[</span><span class="s5">0</span><span class="s1">] = (</span><span class="s5">1 </span><span class="s1">- tps[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">5</span><span class="s1">].sum()) * tps[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s4"># Miscellaneous coverage tests</span>
<span class="s2">def </span><span class="s1">test_simple_time_varying():</span>
    <span class="s4"># This tests time-varying parameters regression when in fact the parameters</span>
    <span class="s4"># are not time-varying, and in fact the regression fit is perfect</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)*</span><span class="s5">1.0</span>
    <span class="s1">exog = </span><span class="s5">2</span><span class="s1">*endog</span>
    <span class="s1">mod = sarimax.SARIMAX(</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">exog=exog</span><span class="s2">,</span>
        <span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">time_varying_regression=</span><span class="s2">True,</span>
        <span class="s1">mle_regression=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s4"># Ignore the warning that MLE does not converge</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">res = mod.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># Test that the estimated variances of the errors are essentially zero</span>
    <span class="s4"># 5 digits necessary to accommodate 32-bit numpy/scipy with OpenBLAS 0.2.18</span>
    <span class="s1">assert_almost_equal(res.params</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span>

    <span class="s4"># Test that the time-varying coefficients are all 0.5 (except the first</span>
    <span class="s4"># one)</span>
    <span class="s1">assert_almost_equal(res.filter_results.filtered_state[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s1">]*</span><span class="s5">99</span><span class="s2">, </span><span class="s5">9</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_invalid_time_varying():</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">sarimax.SARIMAX</span><span class="s2">,</span>
        <span class="s1">endog=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">mle_regression=</span><span class="s2">True,</span>
        <span class="s1">time_varying_regression=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_manual_stationary_initialization():</span>
    <span class="s1">endog = results_sarimax.wpi1_data</span>

    <span class="s4"># Create the first model to compare against</span>
    <span class="s1">mod1 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">res1 = mod1.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># Create a second model with &quot;known&quot; initialization</span>
    <span class="s1">mod2 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">mod2.ssm.initialize_known(res1.filter_results.initial_state</span><span class="s2">,</span>
                              <span class="s1">res1.filter_results.initial_state_cov)</span>
    <span class="s1">res2 = mod2.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># Create a third model with &quot;known&quot; initialization, but specified in kwargs</span>
    <span class="s1">mod3 = sarimax.SARIMAX(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">initialization=</span><span class="s3">'known'</span><span class="s2">,</span>
        <span class="s1">initial_state=res1.filter_results.initial_state</span><span class="s2">,</span>
        <span class="s1">initial_state_cov=res1.filter_results.initial_state_cov)</span>
    <span class="s1">res3 = mod3.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># Create the forth model with stationary initialization specified in kwargs</span>
    <span class="s1">mod4 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">initialization=</span><span class="s3">'stationary'</span><span class="s1">)</span>
    <span class="s1">res4 = mod4.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># Just test a couple of things to make sure the results are the same</span>
    <span class="s1">assert_almost_equal(res1.llf</span><span class="s2">, </span><span class="s1">res2.llf)</span>
    <span class="s1">assert_almost_equal(res1.filter_results.filtered_state</span><span class="s2">,</span>
                        <span class="s1">res2.filter_results.filtered_state)</span>

    <span class="s1">assert_almost_equal(res1.llf</span><span class="s2">, </span><span class="s1">res3.llf)</span>
    <span class="s1">assert_almost_equal(res1.filter_results.filtered_state</span><span class="s2">,</span>
                        <span class="s1">res3.filter_results.filtered_state)</span>

    <span class="s1">assert_almost_equal(res1.llf</span><span class="s2">, </span><span class="s1">res4.llf)</span>
    <span class="s1">assert_almost_equal(res1.filter_results.filtered_state</span><span class="s2">,</span>
                        <span class="s1">res4.filter_results.filtered_state)</span>


<span class="s2">def </span><span class="s1">test_manual_approximate_diffuse_initialization():</span>
    <span class="s1">endog = results_sarimax.wpi1_data</span>

    <span class="s4"># Create the first model to compare against</span>
    <span class="s1">mod1 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">mod1.ssm.initialize_approximate_diffuse(</span><span class="s5">1e9</span><span class="s1">)</span>
    <span class="s1">res1 = mod1.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># Create a second model with &quot;known&quot; initialization</span>
    <span class="s1">mod2 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">mod2.ssm.initialize_known(res1.filter_results.initial_state</span><span class="s2">,</span>
                              <span class="s1">res1.filter_results.initial_state_cov)</span>
    <span class="s1">res2 = mod2.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># Create a third model with &quot;known&quot; initialization, but specified in kwargs</span>
    <span class="s1">mod3 = sarimax.SARIMAX(</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">initialization=</span><span class="s3">'known'</span><span class="s2">,</span>
        <span class="s1">initial_state=res1.filter_results.initial_state</span><span class="s2">,</span>
        <span class="s1">initial_state_cov=res1.filter_results.initial_state_cov)</span>
    <span class="s1">res3 = mod3.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># Create the forth model with approximate diffuse initialization specified</span>
    <span class="s4"># in kwargs</span>
    <span class="s1">mod4 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">initialization=</span><span class="s3">'approximate_diffuse'</span><span class="s2">,</span>
                           <span class="s1">initial_variance=</span><span class="s5">1e9</span><span class="s1">)</span>
    <span class="s1">res4 = mod4.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># Just test a couple of things to make sure the results are the same</span>
    <span class="s1">assert_almost_equal(res1.llf</span><span class="s2">, </span><span class="s1">res2.llf)</span>
    <span class="s1">assert_almost_equal(res1.filter_results.filtered_state</span><span class="s2">,</span>
                        <span class="s1">res2.filter_results.filtered_state)</span>

    <span class="s1">assert_almost_equal(res1.llf</span><span class="s2">, </span><span class="s1">res3.llf)</span>
    <span class="s1">assert_almost_equal(res1.filter_results.filtered_state</span><span class="s2">,</span>
                        <span class="s1">res3.filter_results.filtered_state)</span>

    <span class="s1">assert_almost_equal(res1.llf</span><span class="s2">, </span><span class="s1">res4.llf)</span>
    <span class="s1">assert_almost_equal(res1.filter_results.filtered_state</span><span class="s2">,</span>
                        <span class="s1">res4.filter_results.filtered_state)</span>


<span class="s2">def </span><span class="s1">test_results():</span>
    <span class="s1">endog = results_sarimax.wpi1_data</span>

    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">res = mod.filter([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cov_type=</span><span class="s3">'oim'</span><span class="s1">)</span>

    <span class="s1">assert_almost_equal(res.arroots</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(res.maroots</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s1">assert_almost_equal(res.arfreq</span><span class="s2">, </span><span class="s1">np.arctan2(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">) / (</span><span class="s5">2</span><span class="s1">*np.pi))</span>
    <span class="s1">assert_almost_equal(res.mafreq</span><span class="s2">, </span><span class="s1">np.arctan2(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">) / (</span><span class="s5">2</span><span class="s1">*np.pi))</span>

    <span class="s1">assert_almost_equal(res.arparams</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s1">])</span>
    <span class="s1">assert_almost_equal(res.maparams</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">0.5</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_misc_exog():</span>
    <span class="s4"># Tests for missing data</span>
    <span class="s1">nobs = </span><span class="s5">20</span>
    <span class="s1">k_endog = </span><span class="s5">1</span>
    <span class="s1">np.random.seed(</span><span class="s5">1208</span><span class="s1">)</span>
    <span class="s1">endog = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s1">k_endog))</span>
    <span class="s1">endog[:</span><span class="s5">4</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
    <span class="s1">exog1 = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">exog2 = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s1">index = pd.date_range(</span><span class="s3">'1970-01-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s2">, </span><span class="s1">periods=nobs)</span>
    <span class="s1">endog_pd = pd.DataFrame(endog</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">exog1_pd = pd.Series(exog1.squeeze()</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">exog2_pd = pd.DataFrame(exog2</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s1">models = [</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog1</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog2</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog2</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">simple_differencing=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sarimax.SARIMAX(endog_pd</span><span class="s2">, </span><span class="s1">exog=exog1_pd</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">sarimax.SARIMAX(endog_pd</span><span class="s2">, </span><span class="s1">exog=exog2_pd</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">sarimax.SARIMAX(endog_pd</span><span class="s2">, </span><span class="s1">exog=exog2_pd</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">simple_differencing=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">models:</span>
        <span class="s4"># Smoke tests</span>
        <span class="s1">mod.start_params</span>
        <span class="s1">res = mod.fit(disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">res.summary()</span>
        <span class="s1">res.predict()</span>
        <span class="s1">res.predict(dynamic=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">res.get_prediction()</span>

        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">mod.k_exog))</span>
        <span class="s1">res.forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>
        <span class="s1">res.get_forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

        <span class="s4"># Smoke tests for invalid exog</span>
        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">mod.k_exog))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">mod.k_exog + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

    <span class="s4"># Test invalid model specifications</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">sarimax.SARIMAX</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=np.zeros((</span><span class="s5">10</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span><span class="s2">,</span>
                  <span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_datasets():</span>
    <span class="s4"># Test that some unusual types of datasets work</span>

    <span class="s1">np.random.seed(</span><span class="s5">232849</span><span class="s1">)</span>
    <span class="s1">endog = np.random.binomial(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">exog = np.random.binomial(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">mod.fit(disp=-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_predict_custom_index():</span>
    <span class="s1">np.random.seed(</span><span class="s5">328423</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.random.normal(size=</span><span class="s5">50</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">res = mod.smooth(mod.start_params)</span>
    <span class="s1">out = res.predict(start=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">end=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">'a'</span><span class="s1">])</span>
    <span class="s1">assert_equal(out.index.equals(pd.Index([</span><span class="s3">'a'</span><span class="s1">]))</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_arima000():</span>
    <span class="s4"># Test an ARIMA(0, 0, 0) with measurement error model (i.e. just estimating</span>
    <span class="s4"># a variance term)</span>
    <span class="s1">np.random.seed(</span><span class="s5">328423</span><span class="s1">)</span>
    <span class="s1">nobs = </span><span class="s5">50</span>
    <span class="s1">endog = pd.DataFrame(np.random.normal(size=nobs))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">measurement_error=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth(mod.start_params)</span>
    <span class="s1">assert_allclose(res.smoothed_state</span><span class="s2">, </span><span class="s1">endog.T)</span>

    <span class="s4"># ARIMA(0, 1, 0)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">measurement_error=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth(mod.start_params)</span>
    <span class="s1">assert_allclose(res.smoothed_state[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">endog.diff()[</span><span class="s5">1</span><span class="s1">:].T)</span>

    <span class="s4"># Exogenous variables</span>
    <span class="s1">error = np.random.normal(size=nobs)</span>
    <span class="s1">endog = np.ones(nobs) * </span><span class="s5">10 </span><span class="s1">+ error</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s4"># OLS</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">10.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>
    <span class="s1">assert_allclose(res.smoothed_state[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">error</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s4"># RLS</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                          <span class="s1">mle_regression=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">mod.initialize_known([</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">10.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.diag([</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">]))</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">1.</span><span class="s1">])</span>
    <span class="s1">assert_allclose(res.smoothed_state[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">error</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.smoothed_state[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s4"># RLS + TVP</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">,</span>
                          <span class="s1">mle_regression=</span><span class="s2">False, </span><span class="s1">time_varying_regression=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">mod.initialize_known([</span><span class="s5">10.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.diag([</span><span class="s5">0.</span><span class="s1">]))</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>
    <span class="s1">assert_allclose(res.smoothed_state[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">check_concentrated_scale(filter_univariate=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s4"># Test that concentrating the scale out of the likelihood function works</span>
    <span class="s1">endog = np.diff(results_sarimax.wpi1_data)</span>

    <span class="s1">orders = [(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)]</span>
    <span class="s1">seasonal_orders = [(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)]</span>

    <span class="s1">simple_differencings = [</span><span class="s2">True, False</span><span class="s1">]</span>
    <span class="s1">exogs = [</span><span class="s2">None, </span><span class="s1">np.ones_like(endog)]</span>
    <span class="s1">trends = [</span><span class="s2">None, </span><span class="s3">'t'</span><span class="s1">]</span>
    <span class="s4"># Disabled, see discussion below in setting k_snr for details</span>
    <span class="s1">time_varying_regressions = [</span><span class="s2">True, False</span><span class="s1">]</span>
    <span class="s1">measurement_errors = [</span><span class="s2">True, False</span><span class="s1">]</span>

    <span class="s2">import </span><span class="s1">itertools</span>
    <span class="s1">names = [</span><span class="s3">'exog'</span><span class="s2">, </span><span class="s3">'order'</span><span class="s2">, </span><span class="s3">'seasonal_order'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s2">, </span><span class="s3">'measurement_error'</span><span class="s2">,</span>
             <span class="s3">'time_varying_regression'</span><span class="s2">, </span><span class="s3">'simple_differencing'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">itertools.product(exogs</span><span class="s2">, </span><span class="s1">orders</span><span class="s2">, </span><span class="s1">seasonal_orders</span><span class="s2">, </span><span class="s1">trends</span><span class="s2">,</span>
                                     <span class="s1">measurement_errors</span><span class="s2">,</span>
                                     <span class="s1">time_varying_regressions</span><span class="s2">,</span>
                                     <span class="s1">simple_differencings):</span>
        <span class="s1">kwargs = dict(zip(names</span><span class="s2">, </span><span class="s1">element))</span>
        <span class="s2">if </span><span class="s1">kwargs.get(</span><span class="s3">'time_varying_regression'</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s1">kwargs[</span><span class="s3">'mle_regression'</span><span class="s1">] = </span><span class="s2">False</span>

        <span class="s4"># Sometimes we can have slight differences if the Kalman filters</span>
        <span class="s4"># converge at different observations, so disable convergence.</span>
        <span class="s1">kwargs[</span><span class="s3">'tolerance'</span><span class="s1">] = </span><span class="s5">0</span>

        <span class="s1">mod_orig = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod_conc = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">concentrate_scale=</span><span class="s2">True, </span><span class="s1">**kwargs)</span>

        <span class="s1">mod_orig.ssm.filter_univariate = filter_univariate</span>
        <span class="s1">mod_conc.ssm.filter_univariate = filter_univariate</span>

        <span class="s4"># The base parameters are the starting parameters from the concentrated</span>
        <span class="s4"># model</span>
        <span class="s1">conc_params = mod_conc.start_params</span>
        <span class="s1">res_conc = mod_conc.smooth(conc_params)</span>

        <span class="s4"># We need to map the concentrated parameters to the non-concentrated</span>
        <span class="s4"># model</span>
        <span class="s4"># The first thing is to add an additional parameter for the scale</span>
        <span class="s4"># (here set to 1 because we will multiply by res_conc.scale below, but</span>
        <span class="s4"># because the scale is factored out of the entire obs_cov and state_cov</span>
        <span class="s4"># matrices we may need to multiply more parameters by res_conc.scale</span>
        <span class="s4"># also)</span>
        <span class="s1">orig_params = np.r_[conc_params</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">k_snr = </span><span class="s5">1</span>

        <span class="s4"># If we have time-varying regressions, then in the concentrated model</span>
        <span class="s4"># we actually are computing signal-to-noise ratios, and we</span>
        <span class="s4"># need to multiply it by the scale to get the variances</span>
        <span class="s4"># the non-concentrated model will expect as parameters</span>
        <span class="s2">if </span><span class="s1">kwargs[</span><span class="s3">'time_varying_regression'</span><span class="s1">] </span><span class="s2">and </span><span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">k_snr += </span><span class="s5">1</span>
        <span class="s4"># Note: the log-likelihood is not exactly the same between concentrated</span>
        <span class="s4"># and non-concentrated models with time-varying regression, so this</span>
        <span class="s4"># combinations raises NotImplementedError.</span>

        <span class="s4"># If we have measurement error, then in the concentrated model</span>
        <span class="s4"># we actually are computing the signal-to-noise ratio, and we</span>
        <span class="s4"># need to multiply it by the scale to get the measurement error</span>
        <span class="s4"># variance that the non-concentrated model will expect as a</span>
        <span class="s4"># parameter</span>
        <span class="s2">if </span><span class="s1">kwargs[</span><span class="s3">'measurement_error'</span><span class="s1">]:</span>
            <span class="s1">k_snr += </span><span class="s5">1</span>

        <span class="s1">atol = </span><span class="s5">1e-5</span>
        <span class="s2">if </span><span class="s1">kwargs[</span><span class="s3">'measurement_error'</span><span class="s1">] </span><span class="s2">or </span><span class="s1">kwargs[</span><span class="s3">'time_varying_regression'</span><span class="s1">]:</span>
            <span class="s1">atol = </span><span class="s5">1e-3</span>

        <span class="s1">orig_params = np.r_[orig_params[:-k_snr]</span><span class="s2">,</span>
                            <span class="s1">res_conc.scale * orig_params[-k_snr:]]</span>
        <span class="s1">res_orig = mod_orig.smooth(orig_params)</span>

        <span class="s4"># Test loglike</span>
        <span class="s4"># Need to reduce the tolerance when we have measurement error.</span>
        <span class="s1">assert_allclose(res_conc.llf</span><span class="s2">, </span><span class="s1">res_orig.llf</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s4"># Test state space representation matrices</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">mod_conc.ssm.shapes:</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s3">'obs'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">assert_allclose(getattr(res_conc.filter_results</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">,</span>
                            <span class="s1">getattr(res_orig.filter_results</span><span class="s2">, </span><span class="s1">name))</span>

        <span class="s4"># Test filter / smoother output</span>
        <span class="s1">d = res_conc.loglikelihood_burn</span>

        <span class="s1">filter_attr = [</span><span class="s3">'predicted_state'</span><span class="s2">, </span><span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">,</span>
                       <span class="s3">'forecasts_error'</span><span class="s2">, </span><span class="s3">'kalman_gain'</span><span class="s1">]</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">filter_attr:</span>
            <span class="s1">actual = getattr(res_conc.filter_results</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s1">desired = getattr(res_orig.filter_results</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s4"># Note: do not want to compare the elements from any diffuse</span>
        <span class="s4"># initialization for things like covariances, so only compare for</span>
        <span class="s4"># periods past the loglikelihood_burn period</span>
        <span class="s1">filter_attr_burn = [</span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
                            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">,</span>
                            <span class="s3">'tmp1'</span><span class="s2">, </span><span class="s3">'tmp2'</span><span class="s2">, </span><span class="s3">'tmp3'</span><span class="s2">, </span><span class="s3">'tmp4'</span><span class="s1">]</span>
        <span class="s4"># Also need to ignore covariances of states with diffuse initialization</span>
        <span class="s4"># when time_varying_regression is True</span>
        <span class="s1">diffuse_mask = (res_orig.filter_results.initial_state_cov.diagonal() ==</span>
                        <span class="s1">mod_orig.ssm.initial_variance)</span>
        <span class="s1">ix = np.s_[~diffuse_mask</span><span class="s2">, </span><span class="s1">~diffuse_mask</span><span class="s2">, </span><span class="s1">:]</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">filter_attr_burn:</span>
            <span class="s1">actual = getattr(res_conc.filter_results</span><span class="s2">, </span><span class="s1">name)[...</span><span class="s2">, </span><span class="s1">d:]</span>
            <span class="s1">desired = getattr(res_orig.filter_results</span><span class="s2">, </span><span class="s1">name)[...</span><span class="s2">, </span><span class="s1">d:]</span>
            <span class="s4"># Note: Cannot compare predicted or filtered cov for the time</span>
            <span class="s4"># varying regression state due to effects of approximate diffuse</span>
            <span class="s4"># initialization</span>
            <span class="s2">if </span><span class="s1">(name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s1">] </span><span class="s2">and</span>
                    <span class="s1">kwargs[</span><span class="s3">'time_varying_regression'</span><span class="s1">]):</span>
                <span class="s1">assert_allclose(actual[ix]</span><span class="s2">, </span><span class="s1">desired[ix]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s1">smoothed_attr = [</span><span class="s3">'smoothed_state'</span><span class="s2">, </span><span class="s3">'smoothed_state_cov'</span><span class="s2">,</span>
                         <span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
                         <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
                         <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s2">,</span>
                         <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
                         <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
                         <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
                         <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
                         <span class="s3">'smoothed_forecasts'</span><span class="s2">, </span><span class="s3">'smoothed_forecasts_error'</span><span class="s2">,</span>
                         <span class="s3">'smoothed_forecasts_error_cov'</span><span class="s1">]</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">smoothed_attr:</span>
            <span class="s1">actual = getattr(res_conc.filter_results</span><span class="s2">, </span><span class="s1">name)[...</span><span class="s2">, </span><span class="s1">d:]</span>
            <span class="s1">desired = getattr(res_orig.filter_results</span><span class="s2">, </span><span class="s1">name)[...</span><span class="s2">, </span><span class="s1">d:]</span>
            <span class="s2">if </span><span class="s1">(name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s1">] </span><span class="s2">and</span>
                    <span class="s1">kwargs[</span><span class="s3">'time_varying_regression'</span><span class="s1">]):</span>
                <span class="s1">assert_allclose(actual[ix]</span><span class="s2">, </span><span class="s1">desired[ix]</span><span class="s2">, </span><span class="s1">atol=atol)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s4"># Test non-covariance-matrix MLEResults output</span>
        <span class="s1">output = [</span><span class="s3">'aic'</span><span class="s2">, </span><span class="s3">'bic'</span><span class="s2">, </span><span class="s3">'hqic'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">output:</span>
            <span class="s1">actual = getattr(res_conc</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s1">desired = getattr(res_orig</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s4"># Test diagnostic output</span>
        <span class="s1">actual = res_conc.test_normality(method=</span><span class="s3">'jarquebera'</span><span class="s1">)</span>
        <span class="s1">desired = res_orig.test_normality(method=</span><span class="s3">'jarquebera'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s1">actual = res_conc.test_heteroskedasticity(method=</span><span class="s3">'breakvar'</span><span class="s1">)</span>
        <span class="s1">desired = res_orig.test_heteroskedasticity(method=</span><span class="s3">'breakvar'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s1">actual = res_conc.test_serial_correlation(method=</span><span class="s3">'ljungbox'</span><span class="s1">)</span>
        <span class="s1">desired = res_orig.test_serial_correlation(method=</span><span class="s3">'ljungbox'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s4"># Test predict</span>
        <span class="s1">exog = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">kwargs[</span><span class="s3">'exog'</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">exog = np.ones((</span><span class="s5">130 </span><span class="s1">- mod_conc.nobs + </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">actual = res_conc.get_prediction(start=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">end=</span><span class="s5">130</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s5">10</span><span class="s2">,</span>
                                         <span class="s1">exog=exog)</span>
        <span class="s1">desired = res_orig.get_prediction(start=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">end=</span><span class="s5">130</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s5">10</span><span class="s2">,</span>
                                          <span class="s1">exog=exog)</span>
        <span class="s1">assert_allclose(actual.predicted_mean</span><span class="s2">, </span><span class="s1">desired.predicted_mean</span><span class="s2">,</span>
                        <span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(actual.se_mean</span><span class="s2">, </span><span class="s1">desired.se_mean</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s4"># Test simulate</span>
        <span class="s4"># Simulate is currently broken for time-varying models, so do not try</span>
        <span class="s4"># to test it here</span>
        <span class="s1">np.random.seed(</span><span class="s5">13847</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">mod_conc.ssm.time_invariant:</span>
            <span class="s1">measurement_shocks = np.random.normal(size=</span><span class="s5">10</span><span class="s1">)</span>
            <span class="s1">state_shocks = np.random.normal(size=</span><span class="s5">10</span><span class="s1">)</span>
            <span class="s1">initial_state = np.random.normal(size=(mod_conc.k_states</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">actual = res_conc.simulate(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">measurement_shocks</span><span class="s2">, </span><span class="s1">state_shocks</span><span class="s2">,</span>
                                       <span class="s1">initial_state)</span>
            <span class="s1">desired = res_orig.simulate(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">measurement_shocks</span><span class="s2">, </span><span class="s1">state_shocks</span><span class="s2">,</span>
                                        <span class="s1">initial_state)</span>
            <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=atol)</span>

        <span class="s4"># Test impulse responses</span>
        <span class="s2">if </span><span class="s1">mod_conc.ssm.time_invariant:</span>
            <span class="s1">actual = res_conc.impulse_responses(</span><span class="s5">10</span><span class="s1">)</span>
            <span class="s1">desired = res_orig.impulse_responses(</span><span class="s5">10</span><span class="s1">)</span>
            <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=atol)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_concentrated_scale():</span>
    <span class="s1">check_concentrated_scale(filter_univariate=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">check_concentrated_scale(filter_univariate=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_forecast_exog():</span>
    <span class="s4"># Test forecasting with various shapes of `exog`</span>
    <span class="s1">nobs = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones(nobs) * </span><span class="s5">2.0</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s4"># 1-step-ahead, valid</span>
    <span class="s1">exog_fcast_scalar = </span><span class="s5">1.</span>
    <span class="s1">exog_fcast_1dim = np.ones(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">exog_fcast_2dim = np.ones((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_scalar)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_1dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_2dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s4"># h-steps-ahead, valid</span>
    <span class="s1">h = </span><span class="s5">10</span>
    <span class="s1">exog_fcast_1dim = np.ones(h)</span>
    <span class="s1">exog_fcast_2dim = np.ones((h</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">assert_allclose(res.forecast(h</span><span class="s2">, </span><span class="s1">exog=exog_fcast_1dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(h</span><span class="s2">, </span><span class="s1">exog=exog_fcast_2dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s4"># h-steps-ahead, invalid</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=</span><span class="s5">1.</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=np.ones((h</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2):</span>
    <span class="s1">attrs = [</span>
        <span class="s3">'measurement_error'</span><span class="s2">, </span><span class="s3">'state_error'</span><span class="s2">, </span><span class="s3">'mle_regression'</span><span class="s2">,</span>
        <span class="s3">'state_regression'</span><span class="s2">, </span><span class="s3">'time_varying_regression'</span><span class="s2">, </span><span class="s3">'simple_differencing'</span><span class="s2">,</span>
        <span class="s3">'enforce_stationarity'</span><span class="s2">, </span><span class="s3">'enforce_invertibility'</span><span class="s2">,</span>
        <span class="s3">'hamilton_representation'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s2">, </span><span class="s3">'polynomial_ar'</span><span class="s2">, </span><span class="s3">'polynomial_ma'</span><span class="s2">,</span>
        <span class="s3">'polynomial_seasonal_ar'</span><span class="s2">, </span><span class="s3">'polynomial_seasonal_ma'</span><span class="s2">, </span><span class="s3">'polynomial_trend'</span><span class="s2">,</span>
        <span class="s3">'k_ar'</span><span class="s2">, </span><span class="s3">'k_ar_params'</span><span class="s2">, </span><span class="s3">'k_diff'</span><span class="s2">, </span><span class="s3">'k_ma'</span><span class="s2">, </span><span class="s3">'k_ma_params'</span><span class="s2">,</span>
        <span class="s3">'seasonal_periods'</span><span class="s2">, </span><span class="s3">'k_seasonal_ar'</span><span class="s2">, </span><span class="s3">'k_seasonal_ar_params'</span><span class="s2">,</span>
        <span class="s3">'k_seasonal_diff'</span><span class="s2">, </span><span class="s3">'k_seasonal_ma'</span><span class="s2">, </span><span class="s3">'k_seasonal_ma_params'</span><span class="s2">,</span>
        <span class="s3">'k_trend'</span><span class="s2">, </span><span class="s3">'k_exog'</span><span class="s1">]</span>

    <span class="s1">ssm_attrs = [</span>
        <span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'k_endog'</span><span class="s2">, </span><span class="s3">'k_states'</span><span class="s2">, </span><span class="s3">'k_posdef'</span><span class="s2">, </span><span class="s3">'obs_intercept'</span><span class="s2">, </span><span class="s3">'design'</span><span class="s2">,</span>
        <span class="s3">'obs_cov'</span><span class="s2">, </span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s3">'transition'</span><span class="s2">, </span><span class="s3">'selection'</span><span class="s2">, </span><span class="s3">'state_cov'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">print(attr)</span>
        <span class="s1">assert_equal(getattr(mod2</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(mod</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">ssm_attrs:</span>
        <span class="s1">assert_equal(getattr(mod2.ssm</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(mod.ssm</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_equal(mod2._get_init_kwds()</span><span class="s2">, </span><span class="s1">mod._get_init_kwds())</span>


<span class="s2">def </span><span class="s1">test_recreate_model():</span>
    <span class="s1">nobs = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones(nobs) * </span><span class="s5">2.0</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s1">orders = [(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)]</span>
    <span class="s1">seasonal_orders = [(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)]</span>

    <span class="s1">simple_differencings = [</span><span class="s2">True, False</span><span class="s1">]</span>
    <span class="s1">exogs = [</span><span class="s2">None, </span><span class="s1">np.ones_like(endog)]</span>
    <span class="s1">trends = [</span><span class="s2">None, </span><span class="s3">'t'</span><span class="s1">]</span>
    <span class="s4"># Disabled, see discussion below in setting k_snr for details</span>
    <span class="s1">time_varying_regressions = [</span><span class="s2">True, False</span><span class="s1">]</span>
    <span class="s1">measurement_errors = [</span><span class="s2">True, False</span><span class="s1">]</span>

    <span class="s2">import </span><span class="s1">itertools</span>
    <span class="s1">names = [</span><span class="s3">'exog'</span><span class="s2">, </span><span class="s3">'order'</span><span class="s2">, </span><span class="s3">'seasonal_order'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s2">, </span><span class="s3">'measurement_error'</span><span class="s2">,</span>
             <span class="s3">'time_varying_regression'</span><span class="s2">, </span><span class="s3">'simple_differencing'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">itertools.product(exogs</span><span class="s2">, </span><span class="s1">orders</span><span class="s2">, </span><span class="s1">seasonal_orders</span><span class="s2">, </span><span class="s1">trends</span><span class="s2">,</span>
                                     <span class="s1">measurement_errors</span><span class="s2">,</span>
                                     <span class="s1">time_varying_regressions</span><span class="s2">,</span>
                                     <span class="s1">simple_differencings):</span>
        <span class="s1">kwargs = dict(zip(names</span><span class="s2">, </span><span class="s1">element))</span>
        <span class="s2">if </span><span class="s1">kwargs.get(</span><span class="s3">'time_varying_regression'</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s1">kwargs[</span><span class="s3">'mle_regression'</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s1">exog = kwargs.pop(</span><span class="s3">'exog'</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod2 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**mod._get_init_kwds())</span>

        <span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2)</span>


<span class="s2">def </span><span class="s1">test_append_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s1">params = [</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = sarimax.SARIMAX(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s1">res3 = res2.append(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_equal(res1.specification</span><span class="s2">, </span><span class="s1">res3.specification)</span>

    <span class="s1">assert_allclose(res3.cov_params_default</span><span class="s2">, </span><span class="s1">res2.cov_params_default)</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'llf'</span><span class="s2">, </span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>

    <span class="s4"># Check that we get an error if we try to append without exog</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">'Cloning a model with an exogenous'</span><span class="s1">):</span>
        <span class="s1">res2.append(endog[</span><span class="s5">50</span><span class="s1">:])</span>


<span class="s2">def </span><span class="s1">test_extend_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s1">params = [</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = sarimax.SARIMAX(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.smooth(params)</span>

    <span class="s1">res3 = res2.extend(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_allclose(res3.llf_obs</span><span class="s2">, </span><span class="s1">res1.llf_obs[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">desired = getattr(res1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">desired </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">desired = desired[...</span><span class="s2">, </span><span class="s5">50</span><span class="s1">:]</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>

    <span class="s4"># Check that we get an error if we try to extend without exog</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">'Cloning a model with an exogenous'</span><span class="s1">):</span>
        <span class="s1">res2.extend(endog[</span><span class="s5">50</span><span class="s1">:])</span>


<span class="s2">def </span><span class="s1">test_extend_by_one():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s1">params = [</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = sarimax.SARIMAX(endog[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.smooth(params)</span>

    <span class="s1">res3 = res2.extend(endog[-</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[-</span><span class="s5">1</span><span class="s1">:])</span>

    <span class="s1">assert_allclose(res3.llf_obs</span><span class="s2">, </span><span class="s1">res1.llf_obs[-</span><span class="s5">1</span><span class="s1">:])</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">desired = getattr(res1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">desired </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">desired = desired[...</span><span class="s2">, </span><span class="s5">99</span><span class="s1">:]</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">) * </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">) * </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s4"># Check that we get an error if we try to extend without exog</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">'Cloning a model with an exogenous'</span><span class="s1">):</span>
        <span class="s1">res2.extend(endog[-</span><span class="s5">1</span><span class="s1">:])</span>


<span class="s2">def </span><span class="s1">test_apply_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">exog = np.ones_like(endog)</span>
    <span class="s1">params = [</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = sarimax.SARIMAX(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = sarimax.SARIMAX(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">trend=</span><span class="s3">'t'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.smooth(params)</span>

    <span class="s1">res3 = res2.apply(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>

    <span class="s1">assert_equal(res1.specification</span><span class="s2">, </span><span class="s1">res3.specification)</span>

    <span class="s1">assert_allclose(res3.cov_params_default</span><span class="s2">, </span><span class="s1">res2.cov_params_default)</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'llf'</span><span class="s2">, </span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>

    <span class="s4"># Check that we get an error if we try to apply without exog</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">'Cloning a model with an exogenous'</span><span class="s1">):</span>
        <span class="s1">res2.apply(endog[</span><span class="s5">50</span><span class="s1">:])</span>


<span class="s2">def </span><span class="s1">test_start_params_small_nobs():</span>
    <span class="s4"># Test that starting parameters work even when nobs is very small, but</span>
    <span class="s4"># issues a warning.</span>
    <span class="s1">endog = np.log(realgdp_results[</span><span class="s3">'value'</span><span class="s1">]).diff()[</span><span class="s5">1</span><span class="s1">:].values</span>

    <span class="s4"># Regular ARMA</span>
    <span class="s1">mod = sarimax.SARIMAX(endog[:</span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">match = (</span><span class="s3">'Too few observations to estimate starting parameters for ARMA'</span>
             <span class="s3">' and trend.'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">start_params = mod.start_params</span>
        <span class="s1">assert_allclose(start_params</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.var(endog[:</span><span class="s5">4</span><span class="s1">])])</span>

    <span class="s4"># Seasonal ARMA</span>
    <span class="s1">mod = sarimax.SARIMAX(endog[:</span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span>
    <span class="s1">match = (</span><span class="s3">'Too few observations to estimate starting parameters for'</span>
             <span class="s3">' seasonal ARMA.'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">start_params = mod.start_params</span>
        <span class="s1">assert_allclose(start_params</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.var(endog[:</span><span class="s5">4</span><span class="s1">])])</span>


<span class="s2">def </span><span class="s1">test_simple_differencing_int64index():</span>
    <span class="s1">values = np.log(realgdp_results[</span><span class="s3">'value'</span><span class="s1">]).values</span>
    <span class="s1">endog = pd.Series(values</span><span class="s2">, </span><span class="s1">index=pd.Index(range(len(values))))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">assert_(mod._index.equals(endog.index[</span><span class="s5">1</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_simple_differencing_rangeindex():</span>
    <span class="s1">values = np.log(realgdp_results[</span><span class="s3">'value'</span><span class="s1">]).values</span>
    <span class="s1">endog = pd.Series(values</span><span class="s2">, </span><span class="s1">index=pd.RangeIndex(start=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">stop=len(values)))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">assert_(mod._index.equals(endog.index[</span><span class="s5">1</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_simple_differencing_dateindex():</span>
    <span class="s1">values = np.log(realgdp_results[</span><span class="s3">'value'</span><span class="s1">]).values</span>
    <span class="s1">endog = pd.Series(values</span><span class="s2">, </span><span class="s1">index=pd.period_range(</span>
        <span class="s1">start=</span><span class="s3">'2000'</span><span class="s2">, </span><span class="s1">periods=len(values)</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'M'</span><span class="s1">))</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">assert_(mod._index.equals(endog.index[</span><span class="s5">1</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_simple_differencing_strindex():</span>
    <span class="s1">values = np.log(realgdp_results[</span><span class="s3">'value'</span><span class="s1">]).values</span>
    <span class="s1">index = pd.Index(range(len(values))).map(str)</span>
    <span class="s1">endog = pd.Series(values</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning):</span>
        <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">simple_differencing=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">assert_(mod._index.equals(pd.RangeIndex(start=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">stop=len(values) - </span><span class="s5">1</span><span class="s1">)))</span>
    <span class="s1">assert_(mod.data.row_labels.equals(index[</span><span class="s5">1</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">test_invalid_order():</span>
    <span class="s1">endog = np.zeros(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_invalid_seasonal_order():</span>
    <span class="s1">endog = np.zeros(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_dynamic_str():</span>
    <span class="s1">data = results_sarimax.wpi1_stationary[</span><span class="s3">&quot;data&quot;</span><span class="s1">]</span>
    <span class="s1">index = pd.date_range(</span><span class="s3">&quot;1980-1-1&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;MS&quot;</span><span class="s2">, </span><span class="s1">periods=len(data))</span>
    <span class="s1">series = pd.Series(data</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">mod = sarimax.SARIMAX(series</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">dynamic = index[-</span><span class="s5">12</span><span class="s1">]</span>
    <span class="s1">desired = res.get_prediction(index[-</span><span class="s5">24</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s5">12</span><span class="s1">)</span>
    <span class="s1">actual = res.get_prediction(index[-</span><span class="s5">24</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=dynamic)</span>
    <span class="s1">assert_allclose(actual.predicted_mean</span><span class="s2">, </span><span class="s1">desired.predicted_mean)</span>
    <span class="s1">actual = res.get_prediction(index[-</span><span class="s5">24</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=dynamic.to_pydatetime())</span>
    <span class="s1">assert_allclose(actual.predicted_mean</span><span class="s2">, </span><span class="s1">desired.predicted_mean)</span>
    <span class="s1">actual = res.get_prediction(index[-</span><span class="s5">24</span><span class="s1">]</span><span class="s2">,</span>
                                <span class="s1">dynamic=dynamic.strftime(</span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">))</span>
    <span class="s1">assert_allclose(actual.predicted_mean</span><span class="s2">, </span><span class="s1">desired.predicted_mean)</span>


<span class="s1">@pytest.mark.matplotlib</span>
<span class="s2">def </span><span class="s1">test_plot_too_few_obs(reset_randomstate):</span>
    <span class="s4"># GH 6173</span>
    <span class="s4"># SO https://stackoverflow.com/questions/55930880/</span>
    <span class="s4">#    arima-models-plot-diagnostics-share-error/58051895#58051895</span>
    <span class="s1">mod = sarimax.SARIMAX(</span>
        <span class="s1">np.random.normal(size=</span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">enforce_stationarity=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Too few&quot;</span><span class="s1">):</span>
        <span class="s1">results = mod.fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Length of endogenous&quot;</span><span class="s1">):</span>
        <span class="s1">results.plot_diagnostics(figsize=(</span><span class="s5">15</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s1">y = np.random.standard_normal(</span><span class="s5">9</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(</span>
        <span class="s1">y</span><span class="s2">,</span>
        <span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">seasonal_order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">enforce_stationarity=</span><span class="s2">False,</span>
        <span class="s1">enforce_invertibility=</span><span class="s2">False,</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Too few&quot;</span><span class="s1">):</span>
        <span class="s1">results = mod.fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Length of endogenous&quot;</span><span class="s1">):</span>
        <span class="s1">results.plot_diagnostics(figsize=(</span><span class="s5">30</span><span class="s2">, </span><span class="s5">15</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_sarimax_starting_values_few_obsevations(reset_randomstate):</span>
    <span class="s4"># GH 6396, 6801</span>
    <span class="s1">y = np.random.standard_normal(</span><span class="s5">17</span><span class="s1">)</span>

    <span class="s1">sarimax_model = sarimax.SARIMAX(</span>
        <span class="s1">endog=y</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">seasonal_order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">&quot;n&quot;</span>
    <span class="s1">).fit(disp=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">np.all(</span>
        <span class="s1">np.isfinite(sarimax_model.predict(start=len(y)</span><span class="s2">, </span><span class="s1">end=len(y) + </span><span class="s5">11</span><span class="s1">))</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sarimax_starting_values_few_obsevations_long_ma(reset_randomstate):</span>
    <span class="s4"># GH 8232</span>
    <span class="s1">y = np.random.standard_normal(</span><span class="s5">9</span><span class="s1">)</span>
    <span class="s1">y = [</span>
        <span class="s5">3066.3</span><span class="s2">, </span><span class="s5">3260.2</span><span class="s2">, </span><span class="s5">3573.7</span><span class="s2">, </span><span class="s5">3423.6</span><span class="s2">, </span><span class="s5">3598.5</span><span class="s2">, </span><span class="s5">3802.8</span><span class="s2">, </span><span class="s5">3353.4</span><span class="s2">, </span><span class="s5">4026.1</span><span class="s2">,</span>
        <span class="s5">4684. </span><span class="s2">, </span><span class="s5">4099.1</span><span class="s2">, </span><span class="s5">3883.1</span><span class="s2">, </span><span class="s5">3801.5</span><span class="s2">, </span><span class="s5">3104. </span><span class="s2">, </span><span class="s5">3574. </span><span class="s2">, </span><span class="s5">3397.2</span><span class="s2">, </span><span class="s5">3092.9</span><span class="s2">,</span>
        <span class="s5">3083.8</span><span class="s2">, </span><span class="s5">3106.7</span><span class="s2">, </span><span class="s5">2939.6</span>
    <span class="s1">]</span>

    <span class="s1">sarimax_model = sarimax.SARIMAX(</span>
        <span class="s1">endog=y</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">&quot;n&quot;</span>
    <span class="s1">).fit(disp=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">np.all(</span>
        <span class="s1">np.isfinite(sarimax_model.predict(start=len(y)</span><span class="s2">, </span><span class="s1">end=len(y) + </span><span class="s5">11</span><span class="s1">))</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sarimax_forecast_exog_trend(reset_randomstate):</span>
    <span class="s4"># Test that an error is not raised that the given `exog` for the forecast</span>
    <span class="s4"># period is a constant when forecating with an intercept</span>
    <span class="s4"># GH 7019</span>
    <span class="s1">y = np.zeros(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">x = np.zeros(</span><span class="s5">10</span><span class="s1">)</span>

    <span class="s1">mod = sarimax.SARIMAX(endog=y</span><span class="s2">, </span><span class="s1">exog=x</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.4</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s4"># Test for h=1</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">0.2 </span><span class="s1">+ </span><span class="s5">0.4</span><span class="s1">)</span>

    <span class="s4"># Test for h=2</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">exog=[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0.2 </span><span class="s1">+ </span><span class="s5">0.4</span><span class="s2">, </span><span class="s5">0.2 </span><span class="s1">+ </span><span class="s5">0.4 </span><span class="s1">+ </span><span class="s5">0.5</span><span class="s1">)</span>
</pre>
</body>
</html>