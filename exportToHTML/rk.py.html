<html>
<head>
<title>rk.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rk.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">.base </span><span class="s0">import </span><span class="s1">OdeSolver</span><span class="s0">, </span><span class="s1">DenseOutput</span>
<span class="s0">from </span><span class="s1">.common </span><span class="s0">import </span><span class="s1">(validate_max_step</span><span class="s0">, </span><span class="s1">validate_tol</span><span class="s0">, </span><span class="s1">select_initial_step</span><span class="s0">,</span>
                     <span class="s1">norm</span><span class="s0">, </span><span class="s1">warn_extraneous</span><span class="s0">, </span><span class="s1">validate_first_step)</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">dop853_coefficients</span>

<span class="s2"># Multiply steps computed from asymptotic behaviour of errors by this.</span>
<span class="s1">SAFETY = </span><span class="s3">0.9</span>

<span class="s1">MIN_FACTOR = </span><span class="s3">0.2  </span><span class="s2"># Minimum allowed decrease in a step size.</span>
<span class="s1">MAX_FACTOR = </span><span class="s3">10  </span><span class="s2"># Maximum allowed increase in a step size.</span>


<span class="s0">def </span><span class="s1">rk_step(fun</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">K):</span>
    <span class="s4">&quot;&quot;&quot;Perform a single Runge-Kutta step. 
 
    This function computes a prediction of an explicit Runge-Kutta method and 
    also estimates the error of a less accurate method. 
 
    Notation for Butcher tableau is as in [1]_. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system. 
    t : float 
        Current time. 
    y : ndarray, shape (n,) 
        Current state. 
    f : ndarray, shape (n,) 
        Current value of the derivative, i.e., ``fun(x, y)``. 
    h : float 
        Step to use. 
    A : ndarray, shape (n_stages, n_stages) 
        Coefficients for combining previous RK stages to compute the next 
        stage. For explicit methods the coefficients at and above the main 
        diagonal are zeros. 
    B : ndarray, shape (n_stages,) 
        Coefficients for combining RK stages for computing the final 
        prediction. 
    C : ndarray, shape (n_stages,) 
        Coefficients for incrementing time for consecutive RK stages. 
        The value for the first stage is always zero. 
    K : ndarray, shape (n_stages + 1, n) 
        Storage array for putting RK stages here. Stages are stored in rows. 
        The last row is a linear combination of the previous rows with 
        coefficients 
 
    Returns 
    ------- 
    y_new : ndarray, shape (n,) 
        Solution at t + h computed with a higher accuracy. 
    f_new : ndarray, shape (n,) 
        Derivative ``fun(t + h, y_new)``. 
 
    References 
    ---------- 
    .. [1] E. Hairer, S. P. Norsett G. Wanner, &quot;Solving Ordinary Differential 
           Equations I: Nonstiff Problems&quot;, Sec. II.4. 
    &quot;&quot;&quot;</span>
    <span class="s1">K[</span><span class="s3">0</span><span class="s1">] = f</span>
    <span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">c) </span><span class="s0">in </span><span class="s1">enumerate(zip(A[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">C[</span><span class="s3">1</span><span class="s1">:])</span><span class="s0">, </span><span class="s1">start=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">dy = np.dot(K[:s].T</span><span class="s0">, </span><span class="s1">a[:s]) * h</span>
        <span class="s1">K[s] = fun(t + c * h</span><span class="s0">, </span><span class="s1">y + dy)</span>

    <span class="s1">y_new = y + h * np.dot(K[:-</span><span class="s3">1</span><span class="s1">].T</span><span class="s0">, </span><span class="s1">B)</span>
    <span class="s1">f_new = fun(t + h</span><span class="s0">, </span><span class="s1">y_new)</span>

    <span class="s1">K[-</span><span class="s3">1</span><span class="s1">] = f_new</span>

    <span class="s0">return </span><span class="s1">y_new</span><span class="s0">, </span><span class="s1">f_new</span>


<span class="s0">class </span><span class="s1">RungeKutta(OdeSolver):</span>
    <span class="s4">&quot;&quot;&quot;Base class for explicit Runge-Kutta methods.&quot;&quot;&quot;</span>
    <span class="s1">C: np.ndarray = NotImplemented</span>
    <span class="s1">A: np.ndarray = NotImplemented</span>
    <span class="s1">B: np.ndarray = NotImplemented</span>
    <span class="s1">E: np.ndarray = NotImplemented</span>
    <span class="s1">P: np.ndarray = NotImplemented</span>
    <span class="s1">order: int = NotImplemented</span>
    <span class="s1">error_estimator_order: int = NotImplemented</span>
    <span class="s1">n_stages: int = NotImplemented</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">fun</span><span class="s0">, </span><span class="s1">t0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">t_bound</span><span class="s0">, </span><span class="s1">max_step=np.inf</span><span class="s0">,</span>
                 <span class="s1">rtol=</span><span class="s3">1e-3</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s0">, </span><span class="s1">vectorized=</span><span class="s0">False,</span>
                 <span class="s1">first_step=</span><span class="s0">None, </span><span class="s1">**extraneous):</span>
        <span class="s1">warn_extraneous(extraneous)</span>
        <span class="s1">super().__init__(fun</span><span class="s0">, </span><span class="s1">t0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">t_bound</span><span class="s0">, </span><span class="s1">vectorized</span><span class="s0">,</span>
                         <span class="s1">support_complex=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self.y_old = </span><span class="s0">None</span>
        <span class="s1">self.max_step = validate_max_step(max_step)</span>
        <span class="s1">self.rtol</span><span class="s0">, </span><span class="s1">self.atol = validate_tol(rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">, </span><span class="s1">self.n)</span>
        <span class="s1">self.f = self.fun(self.t</span><span class="s0">, </span><span class="s1">self.y)</span>
        <span class="s0">if </span><span class="s1">first_step </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.h_abs = select_initial_step(</span>
                <span class="s1">self.fun</span><span class="s0">, </span><span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.y</span><span class="s0">, </span><span class="s1">self.f</span><span class="s0">, </span><span class="s1">self.direction</span><span class="s0">,</span>
                <span class="s1">self.error_estimator_order</span><span class="s0">, </span><span class="s1">self.rtol</span><span class="s0">, </span><span class="s1">self.atol)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.h_abs = validate_first_step(first_step</span><span class="s0">, </span><span class="s1">t0</span><span class="s0">, </span><span class="s1">t_bound)</span>
        <span class="s1">self.K = np.empty((self.n_stages + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">self.n)</span><span class="s0">, </span><span class="s1">dtype=self.y.dtype)</span>
        <span class="s1">self.error_exponent = -</span><span class="s3">1 </span><span class="s1">/ (self.error_estimator_order + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self.h_previous = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_estimate_error(self</span><span class="s0">, </span><span class="s1">K</span><span class="s0">, </span><span class="s1">h):</span>
        <span class="s0">return </span><span class="s1">np.dot(K.T</span><span class="s0">, </span><span class="s1">self.E) * h</span>

    <span class="s0">def </span><span class="s1">_estimate_error_norm(self</span><span class="s0">, </span><span class="s1">K</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">scale):</span>
        <span class="s0">return </span><span class="s1">norm(self._estimate_error(K</span><span class="s0">, </span><span class="s1">h) / scale)</span>

    <span class="s0">def </span><span class="s1">_step_impl(self):</span>
        <span class="s1">t = self.t</span>
        <span class="s1">y = self.y</span>

        <span class="s1">max_step = self.max_step</span>
        <span class="s1">rtol = self.rtol</span>
        <span class="s1">atol = self.atol</span>

        <span class="s1">min_step = </span><span class="s3">10 </span><span class="s1">* np.abs(np.nextafter(t</span><span class="s0">, </span><span class="s1">self.direction * np.inf) - t)</span>

        <span class="s0">if </span><span class="s1">self.h_abs &gt; max_step:</span>
            <span class="s1">h_abs = max_step</span>
        <span class="s0">elif </span><span class="s1">self.h_abs &lt; min_step:</span>
            <span class="s1">h_abs = min_step</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">h_abs = self.h_abs</span>

        <span class="s1">step_accepted = </span><span class="s0">False</span>
        <span class="s1">step_rejected = </span><span class="s0">False</span>

        <span class="s0">while not </span><span class="s1">step_accepted:</span>
            <span class="s0">if </span><span class="s1">h_abs &lt; min_step:</span>
                <span class="s0">return False, </span><span class="s1">self.TOO_SMALL_STEP</span>

            <span class="s1">h = h_abs * self.direction</span>
            <span class="s1">t_new = t + h</span>

            <span class="s0">if </span><span class="s1">self.direction * (t_new - self.t_bound) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">t_new = self.t_bound</span>

            <span class="s1">h = t_new - t</span>
            <span class="s1">h_abs = np.abs(h)</span>

            <span class="s1">y_new</span><span class="s0">, </span><span class="s1">f_new = rk_step(self.fun</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">self.f</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">self.A</span><span class="s0">,</span>
                                   <span class="s1">self.B</span><span class="s0">, </span><span class="s1">self.C</span><span class="s0">, </span><span class="s1">self.K)</span>
            <span class="s1">scale = atol + np.maximum(np.abs(y)</span><span class="s0">, </span><span class="s1">np.abs(y_new)) * rtol</span>
            <span class="s1">error_norm = self._estimate_error_norm(self.K</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">scale)</span>

            <span class="s0">if </span><span class="s1">error_norm &lt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">error_norm == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">factor = MAX_FACTOR</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">factor = min(MAX_FACTOR</span><span class="s0">,</span>
                                 <span class="s1">SAFETY * error_norm ** self.error_exponent)</span>

                <span class="s0">if </span><span class="s1">step_rejected:</span>
                    <span class="s1">factor = min(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">factor)</span>

                <span class="s1">h_abs *= factor</span>

                <span class="s1">step_accepted = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">h_abs *= max(MIN_FACTOR</span><span class="s0">,</span>
                             <span class="s1">SAFETY * error_norm ** self.error_exponent)</span>
                <span class="s1">step_rejected = </span><span class="s0">True</span>

        <span class="s1">self.h_previous = h</span>
        <span class="s1">self.y_old = y</span>

        <span class="s1">self.t = t_new</span>
        <span class="s1">self.y = y_new</span>

        <span class="s1">self.h_abs = h_abs</span>
        <span class="s1">self.f = f_new</span>

        <span class="s0">return True, None</span>

    <span class="s0">def </span><span class="s1">_dense_output_impl(self):</span>
        <span class="s1">Q = self.K.T.dot(self.P)</span>
        <span class="s0">return </span><span class="s1">RkDenseOutput(self.t_old</span><span class="s0">, </span><span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.y_old</span><span class="s0">, </span><span class="s1">Q)</span>


<span class="s0">class </span><span class="s1">RK23(RungeKutta):</span>
    <span class="s4">&quot;&quot;&quot;Explicit Runge-Kutta method of order 3(2). 
 
    This uses the Bogacki-Shampine pair of formulas [1]_. The error is controlled 
    assuming accuracy of the second-order method, but steps are taken using the 
    third-order accurate formula (local extrapolation is done). A cubic Hermite 
    polynomial is used for the dense output. 
 
    Can be applied in the complex domain. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system: the time derivative of the state ``y`` 
        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a 
        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. ``fun`` must 
        return an array of the same shape as ``y``. See `vectorized` for more 
        information. 
    t0 : float 
        Initial time. 
    y0 : array_like, shape (n,) 
        Initial state. 
    t_bound : float 
        Boundary time - the integration won't continue beyond it. It also 
        determines the direction of the integration. 
    first_step : float or None, optional 
        Initial step size. Default is ``None`` which means that the algorithm 
        should choose. 
    max_step : float, optional 
        Maximum allowed step size. Default is np.inf, i.e., the step size is not 
        bounded and determined solely by the solver. 
    rtol, atol : float and array_like, optional 
        Relative and absolute tolerances. The solver keeps the local error 
        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a 
        relative accuracy (number of correct digits), while `atol` controls 
        absolute accuracy (number of correct decimal places). To achieve the 
        desired `rtol`, set `atol` to be smaller than the smallest value that 
        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the 
        allowable error. If `atol` is larger than ``rtol * abs(y)`` the 
        number of correct digits is not guaranteed. Conversely, to achieve the 
        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller 
        than `atol`. If components of y have different scales, it might be 
        beneficial to set different `atol` values for different components by 
        passing array_like with shape (n,) for `atol`. Default values are 
        1e-3 for `rtol` and 1e-6 for `atol`. 
    vectorized : bool, optional 
        Whether `fun` may be called in a vectorized fashion. False (default) 
        is recommended for this solver. 
 
        If ``vectorized`` is False, `fun` will always be called with ``y`` of 
        shape ``(n,)``, where ``n = len(y0)``. 
 
        If ``vectorized`` is True, `fun` may be called with ``y`` of shape 
        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave 
        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of 
        the returned array is the time derivative of the state corresponding 
        with a column of ``y``). 
 
        Setting ``vectorized=True`` allows for faster finite difference 
        approximation of the Jacobian by methods 'Radau' and 'BDF', but 
        will result in slower execution for this solver. 
 
    Attributes 
    ---------- 
    n : int 
        Number of equations. 
    status : string 
        Current status of the solver: 'running', 'finished' or 'failed'. 
    t_bound : float 
        Boundary time. 
    direction : float 
        Integration direction: +1 or -1. 
    t : float 
        Current time. 
    y : ndarray 
        Current state. 
    t_old : float 
        Previous time. None if no steps were made yet. 
    step_size : float 
        Size of the last successful step. None if no steps were made yet. 
    nfev : int 
        Number evaluations of the system's right-hand side. 
    njev : int 
        Number of evaluations of the Jacobian. Is always 0 for this solver as it does not use the Jacobian. 
    nlu : int 
        Number of LU decompositions. Is always 0 for this solver. 
 
    References 
    ---------- 
    .. [1] P. Bogacki, L.F. Shampine, &quot;A 3(2) Pair of Runge-Kutta Formulas&quot;, 
           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989. 
    &quot;&quot;&quot;</span>
    <span class="s1">order = </span><span class="s3">3</span>
    <span class="s1">error_estimator_order = </span><span class="s3">2</span>
    <span class="s1">n_stages = </span><span class="s3">3</span>
    <span class="s1">C = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">/</span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">A = np.array([</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">/</span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">])</span>
    <span class="s1">B = np.array([</span><span class="s3">2</span><span class="s1">/</span><span class="s3">9</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">/</span><span class="s3">9</span><span class="s1">])</span>
    <span class="s1">E = np.array([</span><span class="s3">5</span><span class="s1">/</span><span class="s3">72</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">/</span><span class="s3">12</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">/</span><span class="s3">9</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/</span><span class="s3">8</span><span class="s1">])</span>
    <span class="s1">P = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">4 </span><span class="s1">/ </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5 </span><span class="s1">/ </span><span class="s3">9</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s1">/</span><span class="s3">3</span><span class="s0">, </span><span class="s1">-</span><span class="s3">8</span><span class="s1">/</span><span class="s3">9</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>


<span class="s0">class </span><span class="s1">RK45(RungeKutta):</span>
    <span class="s4">&quot;&quot;&quot;Explicit Runge-Kutta method of order 5(4). 
 
    This uses the Dormand-Prince pair of formulas [1]_. The error is controlled 
    assuming accuracy of the fourth-order method accuracy, but steps are taken 
    using the fifth-order accurate formula (local extrapolation is done). 
    A quartic interpolation polynomial is used for the dense output [2]_. 
 
    Can be applied in the complex domain. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system. The calling signature is ``fun(t, y)``. 
        Here ``t`` is a scalar, and there are two options for the ndarray ``y``: 
        It can either have shape (n,); then ``fun`` must return array_like with 
        shape (n,). Alternatively it can have shape (n, k); then ``fun`` 
        must return an array_like with shape (n, k), i.e., each column 
        corresponds to a single column in ``y``. The choice between the two 
        options is determined by `vectorized` argument (see below). 
    t0 : float 
        Initial time. 
    y0 : array_like, shape (n,) 
        Initial state. 
    t_bound : float 
        Boundary time - the integration won't continue beyond it. It also 
        determines the direction of the integration. 
    first_step : float or None, optional 
        Initial step size. Default is ``None`` which means that the algorithm 
        should choose. 
    max_step : float, optional 
        Maximum allowed step size. Default is np.inf, i.e., the step size is not 
        bounded and determined solely by the solver. 
    rtol, atol : float and array_like, optional 
        Relative and absolute tolerances. The solver keeps the local error 
        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a 
        relative accuracy (number of correct digits), while `atol` controls 
        absolute accuracy (number of correct decimal places). To achieve the 
        desired `rtol`, set `atol` to be smaller than the smallest value that 
        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the 
        allowable error. If `atol` is larger than ``rtol * abs(y)`` the 
        number of correct digits is not guaranteed. Conversely, to achieve the 
        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller 
        than `atol`. If components of y have different scales, it might be 
        beneficial to set different `atol` values for different components by 
        passing array_like with shape (n,) for `atol`. Default values are 
        1e-3 for `rtol` and 1e-6 for `atol`. 
    vectorized : bool, optional 
        Whether `fun` is implemented in a vectorized fashion. Default is False. 
 
    Attributes 
    ---------- 
    n : int 
        Number of equations. 
    status : string 
        Current status of the solver: 'running', 'finished' or 'failed'. 
    t_bound : float 
        Boundary time. 
    direction : float 
        Integration direction: +1 or -1. 
    t : float 
        Current time. 
    y : ndarray 
        Current state. 
    t_old : float 
        Previous time. None if no steps were made yet. 
    step_size : float 
        Size of the last successful step. None if no steps were made yet. 
    nfev : int 
        Number evaluations of the system's right-hand side. 
    njev : int 
        Number of evaluations of the Jacobian. Is always 0 for this solver as it does not use the Jacobian. 
    nlu : int 
        Number of LU decompositions. Is always 0 for this solver. 
 
    References 
    ---------- 
    .. [1] J. R. Dormand, P. J. Prince, &quot;A family of embedded Runge-Kutta 
           formulae&quot;, Journal of Computational and Applied Mathematics, Vol. 6, 
           No. 1, pp. 19-26, 1980. 
    .. [2] L. W. Shampine, &quot;Some Practical Runge-Kutta Formulas&quot;, Mathematics 
           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986. 
    &quot;&quot;&quot;</span>
    <span class="s1">order = </span><span class="s3">5</span>
    <span class="s1">error_estimator_order = </span><span class="s3">4</span>
    <span class="s1">n_stages = </span><span class="s3">6</span>
    <span class="s1">C = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">/</span><span class="s3">10</span><span class="s0">, </span><span class="s3">4</span><span class="s1">/</span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s1">/</span><span class="s3">9</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">A = np.array([</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s1">/</span><span class="s3">5</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">3</span><span class="s1">/</span><span class="s3">40</span><span class="s0">, </span><span class="s3">9</span><span class="s1">/</span><span class="s3">40</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">44</span><span class="s1">/</span><span class="s3">45</span><span class="s0">, </span><span class="s1">-</span><span class="s3">56</span><span class="s1">/</span><span class="s3">15</span><span class="s0">, </span><span class="s3">32</span><span class="s1">/</span><span class="s3">9</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">19372</span><span class="s1">/</span><span class="s3">6561</span><span class="s0">, </span><span class="s1">-</span><span class="s3">25360</span><span class="s1">/</span><span class="s3">2187</span><span class="s0">, </span><span class="s3">64448</span><span class="s1">/</span><span class="s3">6561</span><span class="s0">, </span><span class="s1">-</span><span class="s3">212</span><span class="s1">/</span><span class="s3">729</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">9017</span><span class="s1">/</span><span class="s3">3168</span><span class="s0">, </span><span class="s1">-</span><span class="s3">355</span><span class="s1">/</span><span class="s3">33</span><span class="s0">, </span><span class="s3">46732</span><span class="s1">/</span><span class="s3">5247</span><span class="s0">, </span><span class="s3">49</span><span class="s1">/</span><span class="s3">176</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5103</span><span class="s1">/</span><span class="s3">18656</span><span class="s1">]</span>
    <span class="s1">])</span>
    <span class="s1">B = np.array([</span><span class="s3">35</span><span class="s1">/</span><span class="s3">384</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">500</span><span class="s1">/</span><span class="s3">1113</span><span class="s0">, </span><span class="s3">125</span><span class="s1">/</span><span class="s3">192</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2187</span><span class="s1">/</span><span class="s3">6784</span><span class="s0">, </span><span class="s3">11</span><span class="s1">/</span><span class="s3">84</span><span class="s1">])</span>
    <span class="s1">E = np.array([-</span><span class="s3">71</span><span class="s1">/</span><span class="s3">57600</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">71</span><span class="s1">/</span><span class="s3">16695</span><span class="s0">, </span><span class="s1">-</span><span class="s3">71</span><span class="s1">/</span><span class="s3">1920</span><span class="s0">, </span><span class="s3">17253</span><span class="s1">/</span><span class="s3">339200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">22</span><span class="s1">/</span><span class="s3">525</span><span class="s0">,</span>
                  <span class="s3">1</span><span class="s1">/</span><span class="s3">40</span><span class="s1">])</span>
    <span class="s2"># Corresponds to the optimum value of c_6 from [2]_.</span>
    <span class="s1">P = np.array([</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">8048581381</span><span class="s1">/</span><span class="s3">2820520608</span><span class="s0">, </span><span class="s3">8663915743</span><span class="s1">/</span><span class="s3">2820520608</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s3">12715105075</span><span class="s1">/</span><span class="s3">11282082432</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">131558114200</span><span class="s1">/</span><span class="s3">32700410799</span><span class="s0">, </span><span class="s1">-</span><span class="s3">68118460800</span><span class="s1">/</span><span class="s3">10900136933</span><span class="s0">,</span>
         <span class="s3">87487479700</span><span class="s1">/</span><span class="s3">32700410799</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1754552775</span><span class="s1">/</span><span class="s3">470086768</span><span class="s0">, </span><span class="s3">14199869525</span><span class="s1">/</span><span class="s3">1410260304</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s3">10690763975</span><span class="s1">/</span><span class="s3">1880347072</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">127303824393</span><span class="s1">/</span><span class="s3">49829197408</span><span class="s0">, </span><span class="s1">-</span><span class="s3">318862633887</span><span class="s1">/</span><span class="s3">49829197408</span><span class="s0">,</span>
         <span class="s3">701980252875 </span><span class="s1">/ </span><span class="s3">199316789632</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">282668133</span><span class="s1">/</span><span class="s3">205662961</span><span class="s0">, </span><span class="s3">2019193451</span><span class="s1">/</span><span class="s3">616988883</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1453857185</span><span class="s1">/</span><span class="s3">822651844</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">40617522</span><span class="s1">/</span><span class="s3">29380423</span><span class="s0">, </span><span class="s1">-</span><span class="s3">110615467</span><span class="s1">/</span><span class="s3">29380423</span><span class="s0">, </span><span class="s3">69997945</span><span class="s1">/</span><span class="s3">29380423</span><span class="s1">]])</span>


<span class="s0">class </span><span class="s1">DOP853(RungeKutta):</span>
    <span class="s4">&quot;&quot;&quot;Explicit Runge-Kutta method of order 8. 
 
    This is a Python implementation of &quot;DOP853&quot; algorithm originally written 
    in Fortran [1]_, [2]_. Note that this is not a literate translation, but 
    the algorithmic core and coefficients are the same. 
 
    Can be applied in the complex domain. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system. The calling signature is ``fun(t, y)``. 
        Here, ``t`` is a scalar, and there are two options for the ndarray ``y``: 
        It can either have shape (n,); then ``fun`` must return array_like with 
        shape (n,). Alternatively it can have shape (n, k); then ``fun`` 
        must return an array_like with shape (n, k), i.e. each column 
        corresponds to a single column in ``y``. The choice between the two 
        options is determined by `vectorized` argument (see below). 
    t0 : float 
        Initial time. 
    y0 : array_like, shape (n,) 
        Initial state. 
    t_bound : float 
        Boundary time - the integration won't continue beyond it. It also 
        determines the direction of the integration. 
    first_step : float or None, optional 
        Initial step size. Default is ``None`` which means that the algorithm 
        should choose. 
    max_step : float, optional 
        Maximum allowed step size. Default is np.inf, i.e. the step size is not 
        bounded and determined solely by the solver. 
    rtol, atol : float and array_like, optional 
        Relative and absolute tolerances. The solver keeps the local error 
        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a 
        relative accuracy (number of correct digits), while `atol` controls 
        absolute accuracy (number of correct decimal places). To achieve the 
        desired `rtol`, set `atol` to be smaller than the smallest value that 
        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the 
        allowable error. If `atol` is larger than ``rtol * abs(y)`` the 
        number of correct digits is not guaranteed. Conversely, to achieve the 
        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller 
        than `atol`. If components of y have different scales, it might be 
        beneficial to set different `atol` values for different components by 
        passing array_like with shape (n,) for `atol`. Default values are 
        1e-3 for `rtol` and 1e-6 for `atol`. 
    vectorized : bool, optional 
        Whether `fun` is implemented in a vectorized fashion. Default is False. 
 
    Attributes 
    ---------- 
    n : int 
        Number of equations. 
    status : string 
        Current status of the solver: 'running', 'finished' or 'failed'. 
    t_bound : float 
        Boundary time. 
    direction : float 
        Integration direction: +1 or -1. 
    t : float 
        Current time. 
    y : ndarray 
        Current state. 
    t_old : float 
        Previous time. None if no steps were made yet. 
    step_size : float 
        Size of the last successful step. None if no steps were made yet. 
    nfev : int 
        Number evaluations of the system's right-hand side. 
    njev : int 
        Number of evaluations of the Jacobian. Is always 0 for this solver 
        as it does not use the Jacobian. 
    nlu : int 
        Number of LU decompositions. Is always 0 for this solver. 
 
    References 
    ---------- 
    .. [1] E. Hairer, S. P. Norsett G. Wanner, &quot;Solving Ordinary Differential 
           Equations I: Nonstiff Problems&quot;, Sec. II. 
    .. [2] `Page with original Fortran code of DOP853 
            &lt;http://www.unige.ch/~hairer/software.html&gt;`_. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_stages = dop853_coefficients.N_STAGES</span>
    <span class="s1">order = </span><span class="s3">8</span>
    <span class="s1">error_estimator_order = </span><span class="s3">7</span>
    <span class="s1">A = dop853_coefficients.A[:n_stages</span><span class="s0">, </span><span class="s1">:n_stages]</span>
    <span class="s1">B = dop853_coefficients.B</span>
    <span class="s1">C = dop853_coefficients.C[:n_stages]</span>
    <span class="s1">E3 = dop853_coefficients.E3</span>
    <span class="s1">E5 = dop853_coefficients.E5</span>
    <span class="s1">D = dop853_coefficients.D</span>

    <span class="s1">A_EXTRA = dop853_coefficients.A[n_stages + </span><span class="s3">1</span><span class="s1">:]</span>
    <span class="s1">C_EXTRA = dop853_coefficients.C[n_stages + </span><span class="s3">1</span><span class="s1">:]</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">fun</span><span class="s0">, </span><span class="s1">t0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">t_bound</span><span class="s0">, </span><span class="s1">max_step=np.inf</span><span class="s0">,</span>
                 <span class="s1">rtol=</span><span class="s3">1e-3</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s0">, </span><span class="s1">vectorized=</span><span class="s0">False,</span>
                 <span class="s1">first_step=</span><span class="s0">None, </span><span class="s1">**extraneous):</span>
        <span class="s1">super().__init__(fun</span><span class="s0">, </span><span class="s1">t0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">t_bound</span><span class="s0">, </span><span class="s1">max_step</span><span class="s0">, </span><span class="s1">rtol</span><span class="s0">, </span><span class="s1">atol</span><span class="s0">,</span>
                         <span class="s1">vectorized</span><span class="s0">, </span><span class="s1">first_step</span><span class="s0">, </span><span class="s1">**extraneous)</span>
        <span class="s1">self.K_extended = np.empty((dop853_coefficients.N_STAGES_EXTENDED</span><span class="s0">,</span>
                                    <span class="s1">self.n)</span><span class="s0">, </span><span class="s1">dtype=self.y.dtype)</span>
        <span class="s1">self.K = self.K_extended[:self.n_stages + </span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">_estimate_error(self</span><span class="s0">, </span><span class="s1">K</span><span class="s0">, </span><span class="s1">h):  </span><span class="s2"># Left for testing purposes.</span>
        <span class="s1">err5 = np.dot(K.T</span><span class="s0">, </span><span class="s1">self.E5)</span>
        <span class="s1">err3 = np.dot(K.T</span><span class="s0">, </span><span class="s1">self.E3)</span>
        <span class="s1">denom = np.hypot(np.abs(err5)</span><span class="s0">, </span><span class="s3">0.1 </span><span class="s1">* np.abs(err3))</span>
        <span class="s1">correction_factor = np.ones_like(err5)</span>
        <span class="s1">mask = denom &gt; </span><span class="s3">0</span>
        <span class="s1">correction_factor[mask] = np.abs(err5[mask]) / denom[mask]</span>
        <span class="s0">return </span><span class="s1">h * err5 * correction_factor</span>

    <span class="s0">def </span><span class="s1">_estimate_error_norm(self</span><span class="s0">, </span><span class="s1">K</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">scale):</span>
        <span class="s1">err5 = np.dot(K.T</span><span class="s0">, </span><span class="s1">self.E5) / scale</span>
        <span class="s1">err3 = np.dot(K.T</span><span class="s0">, </span><span class="s1">self.E3) / scale</span>
        <span class="s1">err5_norm_2 = np.linalg.norm(err5)**</span><span class="s3">2</span>
        <span class="s1">err3_norm_2 = np.linalg.norm(err3)**</span><span class="s3">2</span>
        <span class="s0">if </span><span class="s1">err5_norm_2 == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">err3_norm_2 == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">0.0</span>
        <span class="s1">denom = err5_norm_2 + </span><span class="s3">0.01 </span><span class="s1">* err3_norm_2</span>
        <span class="s0">return </span><span class="s1">np.abs(h) * err5_norm_2 / np.sqrt(denom * len(scale))</span>

    <span class="s0">def </span><span class="s1">_dense_output_impl(self):</span>
        <span class="s1">K = self.K_extended</span>
        <span class="s1">h = self.h_previous</span>
        <span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">c) </span><span class="s0">in </span><span class="s1">enumerate(zip(self.A_EXTRA</span><span class="s0">, </span><span class="s1">self.C_EXTRA)</span><span class="s0">,</span>
                                   <span class="s1">start=self.n_stages + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">dy = np.dot(K[:s].T</span><span class="s0">, </span><span class="s1">a[:s]) * h</span>
            <span class="s1">K[s] = self.fun(self.t_old + c * h</span><span class="s0">, </span><span class="s1">self.y_old + dy)</span>

        <span class="s1">F = np.empty((dop853_coefficients.INTERPOLATOR_POWER</span><span class="s0">, </span><span class="s1">self.n)</span><span class="s0">,</span>
                     <span class="s1">dtype=self.y_old.dtype)</span>

        <span class="s1">f_old = K[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">delta_y = self.y - self.y_old</span>

        <span class="s1">F[</span><span class="s3">0</span><span class="s1">] = delta_y</span>
        <span class="s1">F[</span><span class="s3">1</span><span class="s1">] = h * f_old - delta_y</span>
        <span class="s1">F[</span><span class="s3">2</span><span class="s1">] = </span><span class="s3">2 </span><span class="s1">* delta_y - h * (self.f + f_old)</span>
        <span class="s1">F[</span><span class="s3">3</span><span class="s1">:] = h * np.dot(self.D</span><span class="s0">, </span><span class="s1">K)</span>

        <span class="s0">return </span><span class="s1">Dop853DenseOutput(self.t_old</span><span class="s0">, </span><span class="s1">self.t</span><span class="s0">, </span><span class="s1">self.y_old</span><span class="s0">, </span><span class="s1">F)</span>


<span class="s0">class </span><span class="s1">RkDenseOutput(DenseOutput):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">t_old</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">y_old</span><span class="s0">, </span><span class="s1">Q):</span>
        <span class="s1">super().__init__(t_old</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s1">self.h = t - t_old</span>
        <span class="s1">self.Q = Q</span>
        <span class="s1">self.order = Q.shape[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span>
        <span class="s1">self.y_old = y_old</span>

    <span class="s0">def </span><span class="s1">_call_impl(self</span><span class="s0">, </span><span class="s1">t):</span>
        <span class="s1">x = (t - self.t_old) / self.h</span>
        <span class="s0">if </span><span class="s1">t.ndim == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">p = np.tile(x</span><span class="s0">, </span><span class="s1">self.order + </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">p = np.cumprod(p)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">p = np.tile(x</span><span class="s0">, </span><span class="s1">(self.order + </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
            <span class="s1">p = np.cumprod(p</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">y = self.h * np.dot(self.Q</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s0">if </span><span class="s1">y.ndim == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">y += self.y_old[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">y += self.y_old</span>

        <span class="s0">return </span><span class="s1">y</span>


<span class="s0">class </span><span class="s1">Dop853DenseOutput(DenseOutput):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">t_old</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">y_old</span><span class="s0">, </span><span class="s1">F):</span>
        <span class="s1">super().__init__(t_old</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s1">self.h = t - t_old</span>
        <span class="s1">self.F = F</span>
        <span class="s1">self.y_old = y_old</span>

    <span class="s0">def </span><span class="s1">_call_impl(self</span><span class="s0">, </span><span class="s1">t):</span>
        <span class="s1">x = (t - self.t_old) / self.h</span>

        <span class="s0">if </span><span class="s1">t.ndim == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">y = np.zeros_like(self.y_old)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x = x[:</span><span class="s0">, None</span><span class="s1">]</span>
            <span class="s1">y = np.zeros((len(x)</span><span class="s0">, </span><span class="s1">len(self.y_old))</span><span class="s0">, </span><span class="s1">dtype=self.y_old.dtype)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">f </span><span class="s0">in </span><span class="s1">enumerate(reversed(self.F)):</span>
            <span class="s1">y += f</span>
            <span class="s0">if </span><span class="s1">i % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">y *= x</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">y *= </span><span class="s3">1 </span><span class="s1">- x</span>
        <span class="s1">y += self.y_old</span>

        <span class="s0">return </span><span class="s1">y.T</span>
</pre>
</body>
</html>