<html>
<head>
<title>interpolatable.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interpolatable.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tool to find wrong contour order between different masters, and 
other interpolatability (or lack thereof) issues. 
 
Call as: 
$ fonttools varLib.interpolatable font1 font2 ... 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">fontTools.pens.basePen </span><span class="s2">import </span><span class="s1">AbstractPen</span><span class="s2">, </span><span class="s1">BasePen</span>
<span class="s2">from </span><span class="s1">fontTools.pens.pointPen </span><span class="s2">import </span><span class="s1">AbstractPointPen</span><span class="s2">, </span><span class="s1">SegmentToPointPen</span>
<span class="s2">from </span><span class="s1">fontTools.pens.recordingPen </span><span class="s2">import </span><span class="s1">RecordingPen</span>
<span class="s2">from </span><span class="s1">fontTools.pens.statisticsPen </span><span class="s2">import </span><span class="s1">StatisticsPen</span>
<span class="s2">from </span><span class="s1">fontTools.pens.momentsPen </span><span class="s2">import </span><span class="s1">OpenContourError</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">sys</span>


<span class="s2">def </span><span class="s1">_rot_list(l</span><span class="s2">, </span><span class="s1">k):</span>
    <span class="s0">&quot;&quot;&quot;Rotate list by k items forward.  Ie. item at position 0 will be 
    at position k in returned list.  Negative k is allowed.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">l[-k:] + l[:-k]</span>


<span class="s2">class </span><span class="s1">PerContourPen(BasePen):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">Pen</span><span class="s2">, </span><span class="s1">glyphset=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">BasePen.__init__(self</span><span class="s2">, </span><span class="s1">glyphset)</span>
        <span class="s1">self._glyphset = glyphset</span>
        <span class="s1">self._Pen = Pen</span>
        <span class="s1">self._pen = </span><span class="s2">None</span>
        <span class="s1">self.value = []</span>

    <span class="s2">def </span><span class="s1">_moveTo(self</span><span class="s2">, </span><span class="s1">p0):</span>
        <span class="s1">self._newItem()</span>
        <span class="s1">self._pen.moveTo(p0)</span>

    <span class="s2">def </span><span class="s1">_lineTo(self</span><span class="s2">, </span><span class="s1">p1):</span>
        <span class="s1">self._pen.lineTo(p1)</span>

    <span class="s2">def </span><span class="s1">_qCurveToOne(self</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2):</span>
        <span class="s1">self._pen.qCurveTo(p1</span><span class="s2">, </span><span class="s1">p2)</span>

    <span class="s2">def </span><span class="s1">_curveToOne(self</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">, </span><span class="s1">p3):</span>
        <span class="s1">self._pen.curveTo(p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">, </span><span class="s1">p3)</span>

    <span class="s2">def </span><span class="s1">_closePath(self):</span>
        <span class="s1">self._pen.closePath()</span>
        <span class="s1">self._pen = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_endPath(self):</span>
        <span class="s1">self._pen.endPath()</span>
        <span class="s1">self._pen = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_newItem(self):</span>
        <span class="s1">self._pen = pen = self._Pen()</span>
        <span class="s1">self.value.append(pen)</span>


<span class="s2">class </span><span class="s1">PerContourOrComponentPen(PerContourPen):</span>
    <span class="s2">def </span><span class="s1">addComponent(self</span><span class="s2">, </span><span class="s1">glyphName</span><span class="s2">, </span><span class="s1">transformation):</span>
        <span class="s1">self._newItem()</span>
        <span class="s1">self.value[-</span><span class="s3">1</span><span class="s1">].addComponent(glyphName</span><span class="s2">, </span><span class="s1">transformation)</span>


<span class="s2">class </span><span class="s1">RecordingPointPen(AbstractPointPen):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.value = []</span>

    <span class="s2">def </span><span class="s1">beginPath(self</span><span class="s2">, </span><span class="s1">identifier=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">endPath(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">addPoint(self</span><span class="s2">, </span><span class="s1">pt</span><span class="s2">, </span><span class="s1">segmentType=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.value.append((pt</span><span class="s2">, False if </span><span class="s1">segmentType </span><span class="s2">is None else True</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_vdiff_hypot2(v0</span><span class="s2">, </span><span class="s1">v1):</span>
    <span class="s1">s = </span><span class="s3">0</span>
    <span class="s2">for </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 </span><span class="s2">in </span><span class="s1">zip(v0</span><span class="s2">, </span><span class="s1">v1):</span>
        <span class="s1">d = x1 - x0</span>
        <span class="s1">s += d * d</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">_vdiff_hypot2_complex(v0</span><span class="s2">, </span><span class="s1">v1):</span>
    <span class="s1">s = </span><span class="s3">0</span>
    <span class="s2">for </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 </span><span class="s2">in </span><span class="s1">zip(v0</span><span class="s2">, </span><span class="s1">v1):</span>
        <span class="s1">d = x1 - x0</span>
        <span class="s1">s += d.real * d.real + d.imag * d.imag</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">_matching_cost(G</span><span class="s2">, </span><span class="s1">matching):</span>
    <span class="s2">return </span><span class="s1">sum(G[i][j] </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">enumerate(matching))</span>


<span class="s2">def </span><span class="s1">min_cost_perfect_bipartite_matching_scipy(G):</span>
    <span class="s1">n = len(G)</span>
    <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = linear_sum_assignment(G)</span>
    <span class="s2">assert </span><span class="s1">(rows == list(range(n))).all()</span>
    <span class="s2">return </span><span class="s1">list(cols)</span><span class="s2">, </span><span class="s1">_matching_cost(G</span><span class="s2">, </span><span class="s1">cols)</span>


<span class="s2">def </span><span class="s1">min_cost_perfect_bipartite_matching_munkres(G):</span>
    <span class="s1">n = len(G)</span>
    <span class="s1">cols = [</span><span class="s2">None</span><span class="s1">] * n</span>
    <span class="s2">for </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">Munkres().compute(G):</span>
        <span class="s1">cols[row] = col</span>
    <span class="s2">return </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">_matching_cost(G</span><span class="s2">, </span><span class="s1">cols)</span>


<span class="s2">def </span><span class="s1">min_cost_perfect_bipartite_matching_bruteforce(G):</span>
    <span class="s1">n = len(G)</span>

    <span class="s2">if </span><span class="s1">n &gt; </span><span class="s3">6</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">&quot;Install Python module 'munkres' or 'scipy &gt;= 0.17.0'&quot;</span><span class="s1">)</span>

    <span class="s5"># Otherwise just brute-force</span>
    <span class="s1">permutations = itertools.permutations(range(n))</span>
    <span class="s1">best = list(next(permutations))</span>
    <span class="s1">best_cost = _matching_cost(G</span><span class="s2">, </span><span class="s1">best)</span>
    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">permutations:</span>
        <span class="s1">cost = _matching_cost(G</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s2">if </span><span class="s1">cost &lt; best_cost:</span>
            <span class="s1">best</span><span class="s2">, </span><span class="s1">best_cost = list(p)</span><span class="s2">, </span><span class="s1">cost</span>
    <span class="s2">return </span><span class="s1">best</span><span class="s2">, </span><span class="s1">best_cost</span>


<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">linear_sum_assignment</span>

    <span class="s1">min_cost_perfect_bipartite_matching = min_cost_perfect_bipartite_matching_scipy</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">munkres </span><span class="s2">import </span><span class="s1">Munkres</span>

        <span class="s1">min_cost_perfect_bipartite_matching = (</span>
            <span class="s1">min_cost_perfect_bipartite_matching_munkres</span>
        <span class="s1">)</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s1">min_cost_perfect_bipartite_matching = (</span>
            <span class="s1">min_cost_perfect_bipartite_matching_bruteforce</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_gen(glyphsets</span><span class="s2">, </span><span class="s1">glyphs=</span><span class="s2">None, </span><span class="s1">names=</span><span class="s2">None, </span><span class="s1">ignore_missing=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">names = glyphsets</span>
    <span class="s2">if </span><span class="s1">glyphs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s5"># `glyphs = glyphsets[0].keys()` is faster, certainly, but doesn't allow for sparse TTFs/OTFs given out of order</span>
        <span class="s5"># ... risks the sparse master being the first one, and only processing a subset of the glyphs</span>
        <span class="s1">glyphs = {g </span><span class="s2">for </span><span class="s1">glyphset </span><span class="s2">in </span><span class="s1">glyphsets </span><span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">glyphset.keys()}</span>

    <span class="s1">hist = []</span>

    <span class="s2">for </span><span class="s1">glyph_name </span><span class="s2">in </span><span class="s1">glyphs:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">m0idx = </span><span class="s3">0</span>
            <span class="s1">allVectors = []</span>
            <span class="s1">allNodeTypes = []</span>
            <span class="s1">allContourIsomorphisms = []</span>
            <span class="s1">allGlyphs = [glyphset[glyph_name] </span><span class="s2">for </span><span class="s1">glyphset </span><span class="s2">in </span><span class="s1">glyphsets]</span>
            <span class="s2">if </span><span class="s1">len([</span><span class="s3">1 </span><span class="s2">for </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">allGlyphs </span><span class="s2">if </span><span class="s1">glyph </span><span class="s2">is not None</span><span class="s1">]) &lt;= </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">for </span><span class="s1">glyph</span><span class="s2">, </span><span class="s1">glyphset</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">zip(allGlyphs</span><span class="s2">, </span><span class="s1">glyphsets</span><span class="s2">, </span><span class="s1">names):</span>
                <span class="s2">if </span><span class="s1">glyph </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">if not </span><span class="s1">ignore_missing:</span>
                        <span class="s2">yield </span><span class="s1">(glyph_name</span><span class="s2">, </span><span class="s1">{</span><span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;missing&quot;</span><span class="s2">, </span><span class="s4">&quot;master&quot;</span><span class="s1">: name})</span>
                    <span class="s1">allNodeTypes.append(</span><span class="s2">None</span><span class="s1">)</span>
                    <span class="s1">allVectors.append(</span><span class="s2">None</span><span class="s1">)</span>
                    <span class="s1">allContourIsomorphisms.append(</span><span class="s2">None</span><span class="s1">)</span>
                    <span class="s2">continue</span>

                <span class="s1">perContourPen = PerContourOrComponentPen(</span>
                    <span class="s1">RecordingPen</span><span class="s2">, </span><span class="s1">glyphset=glyphset</span>
                <span class="s1">)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">glyph.draw(perContourPen</span><span class="s2">, </span><span class="s1">outputImpliedClosingLine=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">except </span><span class="s1">TypeError:</span>
                    <span class="s1">glyph.draw(perContourPen)</span>
                <span class="s1">contourPens = perContourPen.value</span>
                <span class="s2">del </span><span class="s1">perContourPen</span>

                <span class="s1">contourVectors = []</span>
                <span class="s1">contourIsomorphisms = []</span>
                <span class="s1">nodeTypes = []</span>
                <span class="s1">allNodeTypes.append(nodeTypes)</span>
                <span class="s1">allVectors.append(contourVectors)</span>
                <span class="s1">allContourIsomorphisms.append(contourIsomorphisms)</span>
                <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">contour </span><span class="s2">in </span><span class="s1">enumerate(contourPens):</span>
                    <span class="s1">nodeVecs = tuple(instruction[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">instruction </span><span class="s2">in </span><span class="s1">contour.value)</span>
                    <span class="s1">nodeTypes.append(nodeVecs)</span>

                    <span class="s1">stats = StatisticsPen(glyphset=glyphset)</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">contour.replay(stats)</span>
                    <span class="s2">except </span><span class="s1">OpenContourError </span><span class="s2">as </span><span class="s1">e:</span>
                        <span class="s2">yield </span><span class="s1">(</span>
                            <span class="s1">glyph_name</span><span class="s2">,</span>
                            <span class="s1">{</span><span class="s4">&quot;master&quot;</span><span class="s1">: name</span><span class="s2">, </span><span class="s4">&quot;contour&quot;</span><span class="s1">: ix</span><span class="s2">, </span><span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;open_path&quot;</span><span class="s1">}</span><span class="s2">,</span>
                        <span class="s1">)</span>
                        <span class="s2">continue</span>
                    <span class="s1">size = math.sqrt(abs(stats.area)) * </span><span class="s3">0.5</span>
                    <span class="s1">vector = (</span>
                        <span class="s1">int(size)</span><span class="s2">,</span>
                        <span class="s1">int(stats.meanX)</span><span class="s2">,</span>
                        <span class="s1">int(stats.meanY)</span><span class="s2">,</span>
                        <span class="s1">int(stats.stddevX * </span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">int(stats.stddevY * </span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">int(stats.correlation * size)</span><span class="s2">,</span>
                    <span class="s1">)</span>
                    <span class="s1">contourVectors.append(vector)</span>
                    <span class="s5"># print(vector)</span>

                    <span class="s5"># Check starting point</span>
                    <span class="s2">if </span><span class="s1">nodeVecs[</span><span class="s3">0</span><span class="s1">] == </span><span class="s4">&quot;addComponent&quot;</span><span class="s1">:</span>
                        <span class="s2">continue</span>
                    <span class="s2">assert </span><span class="s1">nodeVecs[</span><span class="s3">0</span><span class="s1">] == </span><span class="s4">&quot;moveTo&quot;</span>
                    <span class="s2">assert </span><span class="s1">nodeVecs[-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;closePath&quot;</span><span class="s2">, </span><span class="s4">&quot;endPath&quot;</span><span class="s1">)</span>
                    <span class="s1">points = RecordingPointPen()</span>
                    <span class="s1">converter = SegmentToPointPen(points</span><span class="s2">, False</span><span class="s1">)</span>
                    <span class="s1">contour.replay(converter)</span>
                    <span class="s5"># points.value is a list of pt,bool where bool is true if on-curve and false if off-curve;</span>
                    <span class="s5"># now check all rotations and mirror-rotations of the contour and build list of isomorphic</span>
                    <span class="s5"># possible starting points.</span>
                    <span class="s1">bits = </span><span class="s3">0</span>
                    <span class="s2">for </span><span class="s1">pt</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">points.value:</span>
                        <span class="s1">bits = (bits &lt;&lt; </span><span class="s3">1</span><span class="s1">) | b</span>
                    <span class="s1">n = len(points.value)</span>
                    <span class="s1">mask = (</span><span class="s3">1 </span><span class="s1">&lt;&lt; n) - </span><span class="s3">1</span>
                    <span class="s1">isomorphisms = []</span>
                    <span class="s1">contourIsomorphisms.append(isomorphisms)</span>
                    <span class="s1">complexPoints = [complex(*pt) </span><span class="s2">for </span><span class="s1">pt</span><span class="s2">, </span><span class="s1">bl </span><span class="s2">in </span><span class="s1">points.value]</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
                        <span class="s1">b = ((bits &lt;&lt; i) &amp; mask) | ((bits &gt;&gt; (n - i)))</span>
                        <span class="s2">if </span><span class="s1">b == bits:</span>
                            <span class="s1">isomorphisms.append(_rot_list(complexPoints</span><span class="s2">, </span><span class="s1">i))</span>
                    <span class="s5"># Add mirrored rotations</span>
                    <span class="s1">mirrored = list(reversed(points.value))</span>
                    <span class="s1">reversed_bits = </span><span class="s3">0</span>
                    <span class="s2">for </span><span class="s1">pt</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">mirrored:</span>
                        <span class="s1">reversed_bits = (reversed_bits &lt;&lt; </span><span class="s3">1</span><span class="s1">) | b</span>
                    <span class="s1">complexPoints = list(reversed(complexPoints))</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
                        <span class="s1">b = ((reversed_bits &lt;&lt; i) &amp; mask) | ((reversed_bits &gt;&gt; (n - i)))</span>
                        <span class="s2">if </span><span class="s1">b == bits:</span>
                            <span class="s1">isomorphisms.append(_rot_list(complexPoints</span><span class="s2">, </span><span class="s1">i))</span>

            <span class="s5"># m0idx should be the index of the first non-None item in allNodeTypes,</span>
            <span class="s5"># else give it the last item.</span>
            <span class="s1">m0idx = next(</span>
                <span class="s1">(i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(allNodeTypes) </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">len(allNodeTypes) - </span><span class="s3">1</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s5"># m0 is the first non-None item in allNodeTypes, or last one if all None</span>
            <span class="s1">m0 = allNodeTypes[m0idx]</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">m1 </span><span class="s2">in </span><span class="s1">enumerate(allNodeTypes[m0idx + </span><span class="s3">1 </span><span class="s1">:]):</span>
                <span class="s2">if </span><span class="s1">m1 </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">len(m0) != len(m1):</span>
                    <span class="s2">yield </span><span class="s1">(</span>
                        <span class="s1">glyph_name</span><span class="s2">,</span>
                        <span class="s1">{</span>
                            <span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;path_count&quot;</span><span class="s2">,</span>
                            <span class="s4">&quot;master_1&quot;</span><span class="s1">: names[m0idx]</span><span class="s2">,</span>
                            <span class="s4">&quot;master_2&quot;</span><span class="s1">: names[m0idx + i + </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s4">&quot;value_1&quot;</span><span class="s1">: len(m0)</span><span class="s2">,</span>
                            <span class="s4">&quot;value_2&quot;</span><span class="s1">: len(m1)</span><span class="s2">,</span>
                        <span class="s1">}</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">m0 == m1:</span>
                    <span class="s2">continue</span>
                <span class="s2">for </span><span class="s1">pathIx</span><span class="s2">, </span><span class="s1">(nodes1</span><span class="s2">, </span><span class="s1">nodes2) </span><span class="s2">in </span><span class="s1">enumerate(zip(m0</span><span class="s2">, </span><span class="s1">m1)):</span>
                    <span class="s2">if </span><span class="s1">nodes1 == nodes2:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">len(nodes1) != len(nodes2):</span>
                        <span class="s2">yield </span><span class="s1">(</span>
                            <span class="s1">glyph_name</span><span class="s2">,</span>
                            <span class="s1">{</span>
                                <span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;node_count&quot;</span><span class="s2">,</span>
                                <span class="s4">&quot;path&quot;</span><span class="s1">: pathIx</span><span class="s2">,</span>
                                <span class="s4">&quot;master_1&quot;</span><span class="s1">: names[m0idx]</span><span class="s2">,</span>
                                <span class="s4">&quot;master_2&quot;</span><span class="s1">: names[m0idx + i + </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                                <span class="s4">&quot;value_1&quot;</span><span class="s1">: len(nodes1)</span><span class="s2">,</span>
                                <span class="s4">&quot;value_2&quot;</span><span class="s1">: len(nodes2)</span><span class="s2">,</span>
                            <span class="s1">}</span><span class="s2">,</span>
                        <span class="s1">)</span>
                        <span class="s2">continue</span>
                    <span class="s2">for </span><span class="s1">nodeIx</span><span class="s2">, </span><span class="s1">(n1</span><span class="s2">, </span><span class="s1">n2) </span><span class="s2">in </span><span class="s1">enumerate(zip(nodes1</span><span class="s2">, </span><span class="s1">nodes2)):</span>
                        <span class="s2">if </span><span class="s1">n1 != n2:</span>
                            <span class="s2">yield </span><span class="s1">(</span>
                                <span class="s1">glyph_name</span><span class="s2">,</span>
                                <span class="s1">{</span>
                                    <span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;node_incompatibility&quot;</span><span class="s2">,</span>
                                    <span class="s4">&quot;path&quot;</span><span class="s1">: pathIx</span><span class="s2">,</span>
                                    <span class="s4">&quot;node&quot;</span><span class="s1">: nodeIx</span><span class="s2">,</span>
                                    <span class="s4">&quot;master_1&quot;</span><span class="s1">: names[m0idx]</span><span class="s2">,</span>
                                    <span class="s4">&quot;master_2&quot;</span><span class="s1">: names[m0idx + i + </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s4">&quot;value_1&quot;</span><span class="s1">: n1</span><span class="s2">,</span>
                                    <span class="s4">&quot;value_2&quot;</span><span class="s1">: n2</span><span class="s2">,</span>
                                <span class="s1">}</span><span class="s2">,</span>
                            <span class="s1">)</span>
                            <span class="s2">continue</span>

            <span class="s5"># m0idx should be the index of the first non-None item in allVectors,</span>
            <span class="s5"># else give it the last item.</span>
            <span class="s1">m0idx = next(</span>
                <span class="s1">(i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(allVectors) </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">len(allVectors) - </span><span class="s3">1</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s5"># m0 is the first non-None item in allVectors, or last one if all None</span>
            <span class="s1">m0 = allVectors[m0idx]</span>
            <span class="s2">if </span><span class="s1">m0 </span><span class="s2">is not None and </span><span class="s1">len(m0) &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">m1 </span><span class="s2">in </span><span class="s1">enumerate(allVectors[m0idx + </span><span class="s3">1 </span><span class="s1">:]):</span>
                    <span class="s2">if </span><span class="s1">m1 </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">len(m0) != len(m1):</span>
                        <span class="s5"># We already reported this</span>
                        <span class="s2">continue</span>
                    <span class="s1">costs = [[_vdiff_hypot2(v0</span><span class="s2">, </span><span class="s1">v1) </span><span class="s2">for </span><span class="s1">v1 </span><span class="s2">in </span><span class="s1">m1] </span><span class="s2">for </span><span class="s1">v0 </span><span class="s2">in </span><span class="s1">m0]</span>
                    <span class="s1">matching</span><span class="s2">, </span><span class="s1">matching_cost = min_cost_perfect_bipartite_matching(costs)</span>
                    <span class="s1">identity_matching = list(range(len(m0)))</span>
                    <span class="s1">identity_cost = sum(costs[i][i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(m0)))</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">matching != identity_matching</span>
                        <span class="s2">and </span><span class="s1">matching_cost &lt; identity_cost * </span><span class="s3">0.95</span>
                    <span class="s1">):</span>
                        <span class="s2">yield </span><span class="s1">(</span>
                            <span class="s1">glyph_name</span><span class="s2">,</span>
                            <span class="s1">{</span>
                                <span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;contour_order&quot;</span><span class="s2">,</span>
                                <span class="s4">&quot;master_1&quot;</span><span class="s1">: names[m0idx]</span><span class="s2">,</span>
                                <span class="s4">&quot;master_2&quot;</span><span class="s1">: names[m0idx + i + </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                                <span class="s4">&quot;value_1&quot;</span><span class="s1">: list(range(len(m0)))</span><span class="s2">,</span>
                                <span class="s4">&quot;value_2&quot;</span><span class="s1">: matching</span><span class="s2">,</span>
                            <span class="s1">}</span><span class="s2">,</span>
                        <span class="s1">)</span>
                        <span class="s2">break</span>

            <span class="s5"># m0idx should be the index of the first non-None item in allContourIsomorphisms,</span>
            <span class="s5"># else give it the last item.</span>
            <span class="s1">m0idx = next(</span>
                <span class="s1">(i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(allContourIsomorphisms) </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">len(allVectors) - </span><span class="s3">1</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s5"># m0 is the first non-None item in allContourIsomorphisms, or last one if all None</span>
            <span class="s1">m0 = allContourIsomorphisms[m0idx]</span>
            <span class="s2">if </span><span class="s1">m0:</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">m1 </span><span class="s2">in </span><span class="s1">enumerate(allContourIsomorphisms[m0idx + </span><span class="s3">1 </span><span class="s1">:]):</span>
                    <span class="s2">if </span><span class="s1">m1 </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">len(m0) != len(m1):</span>
                        <span class="s5"># We already reported this</span>
                        <span class="s2">continue</span>
                    <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">(contour0</span><span class="s2">, </span><span class="s1">contour1) </span><span class="s2">in </span><span class="s1">enumerate(zip(m0</span><span class="s2">, </span><span class="s1">m1)):</span>
                        <span class="s1">c0 = contour0[</span><span class="s3">0</span><span class="s1">]</span>
                        <span class="s1">costs = [_vdiff_hypot2_complex(c0</span><span class="s2">, </span><span class="s1">c1) </span><span class="s2">for </span><span class="s1">c1 </span><span class="s2">in </span><span class="s1">contour1]</span>
                        <span class="s1">min_cost = min(costs)</span>
                        <span class="s1">first_cost = costs[</span><span class="s3">0</span><span class="s1">]</span>
                        <span class="s2">if </span><span class="s1">min_cost &lt; first_cost * </span><span class="s3">0.95</span><span class="s1">:</span>
                            <span class="s2">yield </span><span class="s1">(</span>
                                <span class="s1">glyph_name</span><span class="s2">,</span>
                                <span class="s1">{</span>
                                    <span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;wrong_start_point&quot;</span><span class="s2">,</span>
                                    <span class="s4">&quot;contour&quot;</span><span class="s1">: ix</span><span class="s2">,</span>
                                    <span class="s4">&quot;master_1&quot;</span><span class="s1">: names[m0idx]</span><span class="s2">,</span>
                                    <span class="s4">&quot;master_2&quot;</span><span class="s1">: names[m0idx + i + </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                                <span class="s1">}</span><span class="s2">,</span>
                            <span class="s1">)</span>

        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">yield </span><span class="s1">(</span>
                <span class="s1">glyph_name</span><span class="s2">,</span>
                <span class="s1">{</span><span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;math_error&quot;</span><span class="s2">, </span><span class="s4">&quot;master&quot;</span><span class="s1">: name</span><span class="s2">, </span><span class="s4">&quot;error&quot;</span><span class="s1">: e}</span><span class="s2">,</span>
            <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test(glyphsets</span><span class="s2">, </span><span class="s1">glyphs=</span><span class="s2">None, </span><span class="s1">names=</span><span class="s2">None, </span><span class="s1">ignore_missing=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">problems = defaultdict(list)</span>
    <span class="s2">for </span><span class="s1">glyphname</span><span class="s2">, </span><span class="s1">problem </span><span class="s2">in </span><span class="s1">test_gen(glyphsets</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">ignore_missing):</span>
        <span class="s1">problems[glyphname].append(problem)</span>
    <span class="s2">return </span><span class="s1">problems</span>


<span class="s2">def </span><span class="s1">recursivelyAddGlyph(glyphname</span><span class="s2">, </span><span class="s1">glyphset</span><span class="s2">, </span><span class="s1">ttGlyphSet</span><span class="s2">, </span><span class="s1">glyf):</span>
    <span class="s2">if </span><span class="s1">glyphname </span><span class="s2">in </span><span class="s1">glyphset:</span>
        <span class="s2">return</span>
    <span class="s1">glyphset[glyphname] = ttGlyphSet[glyphname]</span>

    <span class="s2">for </span><span class="s1">component </span><span class="s2">in </span><span class="s1">getattr(glyf[glyphname]</span><span class="s2">, </span><span class="s4">&quot;components&quot;</span><span class="s2">, </span><span class="s1">[]):</span>
        <span class="s1">recursivelyAddGlyph(component.glyphName</span><span class="s2">, </span><span class="s1">glyphset</span><span class="s2">, </span><span class="s1">ttGlyphSet</span><span class="s2">, </span><span class="s1">glyf)</span>


<span class="s2">def </span><span class="s1">main(args=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Test for interpolatability issues between fonts&quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">argparse</span>

    <span class="s1">parser = argparse.ArgumentParser(</span>
        <span class="s4">&quot;fonttools varLib.interpolatable&quot;</span><span class="s2">,</span>
        <span class="s1">description=main.__doc__</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s4">&quot;--glyphs&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s4">&quot;Space-separate name of glyphs to check&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s4">&quot;--json&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s4">&quot;Output report in JSON format&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s4">&quot;--quiet&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s4">&quot;Only exit with code 1 or 0, no output&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s4">&quot;--ignore-missing&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s4">&quot;Will not report glyphs missing from sparse masters as errors&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s4">&quot;inputs&quot;</span><span class="s2">,</span>
        <span class="s1">metavar=</span><span class="s4">&quot;FILE&quot;</span><span class="s2">,</span>
        <span class="s1">type=str</span><span class="s2">,</span>
        <span class="s1">nargs=</span><span class="s4">&quot;+&quot;</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s4">&quot;Input a single variable font / DesignSpace / Glyphs file, or multiple TTF/UFO files&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">args = parser.parse_args(args)</span>

    <span class="s1">glyphs = args.glyphs.split() </span><span class="s2">if </span><span class="s1">args.glyphs </span><span class="s2">else None</span>

    <span class="s2">from </span><span class="s1">os.path </span><span class="s2">import </span><span class="s1">basename</span>

    <span class="s1">fonts = []</span>
    <span class="s1">names = []</span>

    <span class="s2">if </span><span class="s1">len(args.inputs) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">args.inputs[</span><span class="s3">0</span><span class="s1">].endswith(</span><span class="s4">&quot;.designspace&quot;</span><span class="s1">):</span>
            <span class="s2">from </span><span class="s1">fontTools.designspaceLib </span><span class="s2">import </span><span class="s1">DesignSpaceDocument</span>

            <span class="s1">designspace = DesignSpaceDocument.fromfile(args.inputs[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">args.inputs = [master.path </span><span class="s2">for </span><span class="s1">master </span><span class="s2">in </span><span class="s1">designspace.sources]</span>

        <span class="s2">elif </span><span class="s1">args.inputs[</span><span class="s3">0</span><span class="s1">].endswith(</span><span class="s4">&quot;.glyphs&quot;</span><span class="s1">):</span>
            <span class="s2">from </span><span class="s1">glyphsLib </span><span class="s2">import </span><span class="s1">GSFont</span><span class="s2">, </span><span class="s1">to_ufos</span>

            <span class="s1">gsfont = GSFont(args.inputs[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">fonts.extend(to_ufos(gsfont))</span>
            <span class="s1">names = [</span><span class="s4">&quot;%s-%s&quot; </span><span class="s1">% (f.info.familyName</span><span class="s2">, </span><span class="s1">f.info.styleName) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fonts]</span>
            <span class="s1">args.inputs = []</span>

        <span class="s2">elif </span><span class="s1">args.inputs[</span><span class="s3">0</span><span class="s1">].endswith(</span><span class="s4">&quot;.ttf&quot;</span><span class="s1">):</span>
            <span class="s2">from </span><span class="s1">fontTools.ttLib </span><span class="s2">import </span><span class="s1">TTFont</span>

            <span class="s1">font = TTFont(args.inputs[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s4">&quot;gvar&quot; </span><span class="s2">in </span><span class="s1">font:</span>
                <span class="s5"># Is variable font</span>
                <span class="s1">gvar = font[</span><span class="s4">&quot;gvar&quot;</span><span class="s1">]</span>
                <span class="s1">glyf = font[</span><span class="s4">&quot;glyf&quot;</span><span class="s1">]</span>
                <span class="s5"># Gather all glyphs at their &quot;master&quot; locations</span>
                <span class="s1">ttGlyphSets = {}</span>
                <span class="s1">glyphsets = defaultdict(dict)</span>

                <span class="s2">if </span><span class="s1">glyphs </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">glyphs = sorted(gvar.variations.keys())</span>
                <span class="s2">for </span><span class="s1">glyphname </span><span class="s2">in </span><span class="s1">glyphs:</span>
                    <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">gvar.variations[glyphname]:</span>
                        <span class="s1">locDict = {}</span>
                        <span class="s1">loc = []</span>
                        <span class="s2">for </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">sorted(var.axes.items()):</span>
                            <span class="s1">locDict[tag] = val[</span><span class="s3">1</span><span class="s1">]</span>
                            <span class="s1">loc.append((tag</span><span class="s2">, </span><span class="s1">val[</span><span class="s3">1</span><span class="s1">]))</span>

                        <span class="s1">locTuple = tuple(loc)</span>
                        <span class="s2">if </span><span class="s1">locTuple </span><span class="s2">not in </span><span class="s1">ttGlyphSets:</span>
                            <span class="s1">ttGlyphSets[locTuple] = font.getGlyphSet(</span>
                                <span class="s1">location=locDict</span><span class="s2">, </span><span class="s1">normalized=</span><span class="s2">True</span>
                            <span class="s1">)</span>

                        <span class="s1">recursivelyAddGlyph(</span>
                            <span class="s1">glyphname</span><span class="s2">, </span><span class="s1">glyphsets[locTuple]</span><span class="s2">, </span><span class="s1">ttGlyphSets[locTuple]</span><span class="s2">, </span><span class="s1">glyf</span>
                        <span class="s1">)</span>

                <span class="s1">names = [</span><span class="s4">&quot;()&quot;</span><span class="s1">]</span>
                <span class="s1">fonts = [font.getGlyphSet()]</span>
                <span class="s2">for </span><span class="s1">locTuple </span><span class="s2">in </span><span class="s1">sorted(glyphsets.keys()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">v: (len(v)</span><span class="s2">, </span><span class="s1">v)):</span>
                    <span class="s1">names.append(str(locTuple))</span>
                    <span class="s1">fonts.append(glyphsets[locTuple])</span>
                <span class="s1">args.ignore_missing = </span><span class="s2">True</span>
                <span class="s1">args.inputs = []</span>

    <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">args.inputs:</span>
        <span class="s2">if </span><span class="s1">filename.endswith(</span><span class="s4">&quot;.ufo&quot;</span><span class="s1">):</span>
            <span class="s2">from </span><span class="s1">fontTools.ufoLib </span><span class="s2">import </span><span class="s1">UFOReader</span>

            <span class="s1">fonts.append(UFOReader(filename))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">fontTools.ttLib </span><span class="s2">import </span><span class="s1">TTFont</span>

            <span class="s1">fonts.append(TTFont(filename))</span>

        <span class="s1">names.append(basename(filename).rsplit(</span><span class="s4">&quot;.&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s1">glyphsets = []</span>
    <span class="s2">for </span><span class="s1">font </span><span class="s2">in </span><span class="s1">fonts:</span>
        <span class="s2">if </span><span class="s1">hasattr(font</span><span class="s2">, </span><span class="s4">&quot;getGlyphSet&quot;</span><span class="s1">):</span>
            <span class="s1">glyphset = font.getGlyphSet()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">glyphset = font</span>
        <span class="s1">glyphsets.append({k: glyphset[k] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">glyphset.keys()})</span>

    <span class="s2">if not </span><span class="s1">glyphs:</span>
        <span class="s1">glyphs = sorted(set([gn </span><span class="s2">for </span><span class="s1">glyphset </span><span class="s2">in </span><span class="s1">glyphsets </span><span class="s2">for </span><span class="s1">gn </span><span class="s2">in </span><span class="s1">glyphset.keys()]))</span>

    <span class="s1">glyphsSet = set(glyphs)</span>
    <span class="s2">for </span><span class="s1">glyphset </span><span class="s2">in </span><span class="s1">glyphsets:</span>
        <span class="s1">glyphSetGlyphNames = set(glyphset.keys())</span>
        <span class="s1">diff = glyphsSet - glyphSetGlyphNames</span>
        <span class="s2">if </span><span class="s1">diff:</span>
            <span class="s2">for </span><span class="s1">gn </span><span class="s2">in </span><span class="s1">diff:</span>
                <span class="s1">glyphset[gn] = </span><span class="s2">None</span>

    <span class="s1">problems_gen = test_gen(</span>
        <span class="s1">glyphsets</span><span class="s2">, </span><span class="s1">glyphs=glyphs</span><span class="s2">, </span><span class="s1">names=names</span><span class="s2">, </span><span class="s1">ignore_missing=args.ignore_missing</span>
    <span class="s1">)</span>
    <span class="s1">problems = defaultdict(list)</span>

    <span class="s2">if not </span><span class="s1">args.quiet:</span>
        <span class="s2">if </span><span class="s1">args.json:</span>
            <span class="s2">import </span><span class="s1">json</span>

            <span class="s2">for </span><span class="s1">glyphname</span><span class="s2">, </span><span class="s1">problem </span><span class="s2">in </span><span class="s1">problems_gen:</span>
                <span class="s1">problems[glyphname].append(problem)</span>

            <span class="s1">print(json.dumps(problems))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">last_glyphname = </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">glyphname</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">problems_gen:</span>
                <span class="s1">problems[glyphname].append(p)</span>

                <span class="s2">if </span><span class="s1">glyphname != last_glyphname:</span>
                    <span class="s1">print(</span><span class="s4">f&quot;Glyph </span><span class="s2">{</span><span class="s1">glyphname</span><span class="s2">} </span><span class="s4">was not compatible: &quot;</span><span class="s1">)</span>
                    <span class="s1">last_glyphname = glyphname</span>

                <span class="s2">if </span><span class="s1">p[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;missing&quot;</span><span class="s1">:</span>
                    <span class="s1">print(</span><span class="s4">&quot;    Glyph was missing in master %s&quot; </span><span class="s1">% p[</span><span class="s4">&quot;master&quot;</span><span class="s1">])</span>
                <span class="s2">if </span><span class="s1">p[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;open_path&quot;</span><span class="s1">:</span>
                    <span class="s1">print(</span><span class="s4">&quot;    Glyph has an open path in master %s&quot; </span><span class="s1">% p[</span><span class="s4">&quot;master&quot;</span><span class="s1">])</span>
                <span class="s2">if </span><span class="s1">p[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;path_count&quot;</span><span class="s1">:</span>
                    <span class="s1">print(</span>
                        <span class="s4">&quot;    Path count differs: %i in %s, %i in %s&quot;</span>
                        <span class="s1">% (p[</span><span class="s4">&quot;value_1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p[</span><span class="s4">&quot;master_1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p[</span><span class="s4">&quot;value_2&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p[</span><span class="s4">&quot;master_2&quot;</span><span class="s1">])</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">p[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;node_count&quot;</span><span class="s1">:</span>
                    <span class="s1">print(</span>
                        <span class="s4">&quot;    Node count differs in path %i: %i in %s, %i in %s&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">p[</span><span class="s4">&quot;path&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;value_1&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;master_1&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;value_2&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;master_2&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">p[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;node_incompatibility&quot;</span><span class="s1">:</span>
                    <span class="s1">print(</span>
                        <span class="s4">&quot;    Node %o incompatible in path %i: %s in %s, %s in %s&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">p[</span><span class="s4">&quot;node&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;path&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;value_1&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;master_1&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;value_2&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;master_2&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">p[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;contour_order&quot;</span><span class="s1">:</span>
                    <span class="s1">print(</span>
                        <span class="s4">&quot;    Contour order differs: %s in %s, %s in %s&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">p[</span><span class="s4">&quot;value_1&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;master_1&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;value_2&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;master_2&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">p[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;wrong_start_point&quot;</span><span class="s1">:</span>
                    <span class="s1">print(</span>
                        <span class="s4">&quot;    Contour %d start point differs: %s, %s&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">p[</span><span class="s4">&quot;contour&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;master_1&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;master_2&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">p[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;math_error&quot;</span><span class="s1">:</span>
                    <span class="s1">print(</span>
                        <span class="s4">&quot;    Miscellaneous error in %s: %s&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">p[</span><span class="s4">&quot;master&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">p[</span><span class="s4">&quot;error&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">glyphname</span><span class="s2">, </span><span class="s1">problem </span><span class="s2">in </span><span class="s1">problems_gen:</span>
            <span class="s1">problems[glyphname].append(problem)</span>

    <span class="s2">if </span><span class="s1">problems:</span>
        <span class="s2">return </span><span class="s1">problems</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">sys</span>

    <span class="s1">problems = main()</span>
    <span class="s1">sys.exit(int(bool(problems)))</span>
</pre>
</body>
</html>