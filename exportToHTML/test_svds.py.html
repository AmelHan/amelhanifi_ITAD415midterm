<html>
<head>
<title>test_svds.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_svds.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_array_equal</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">scipy.linalg </span><span class="s0">import </span><span class="s1">svd</span><span class="s0">, </span><span class="s1">null_space</span>
<span class="s0">from </span><span class="s1">scipy.sparse </span><span class="s0">import </span><span class="s1">csc_matrix</span><span class="s0">, </span><span class="s1">issparse</span><span class="s0">, </span><span class="s1">spdiags</span><span class="s0">, </span><span class="s1">random</span>
<span class="s0">from </span><span class="s1">scipy.sparse.linalg </span><span class="s0">import </span><span class="s1">LinearOperator</span><span class="s0">, </span><span class="s1">aslinearoperator</span>
<span class="s0">if </span><span class="s1">os.environ.get(</span><span class="s2">&quot;SCIPY_USE_PROPACK&quot;</span><span class="s1">):</span>
    <span class="s1">has_propack = </span><span class="s0">True</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">has_propack = </span><span class="s0">False</span>
<span class="s0">from </span><span class="s1">scipy.sparse.linalg </span><span class="s0">import </span><span class="s1">svds</span>
<span class="s0">from </span><span class="s1">scipy.sparse.linalg._eigen.arpack </span><span class="s0">import </span><span class="s1">ArpackNoConvergence</span>


<span class="s3"># --- Helper Functions / Classes ---</span>


<span class="s0">def </span><span class="s1">sorted_svd(m</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">'LM'</span><span class="s1">):</span>
    <span class="s3"># Compute svd of a dense matrix m, and return singular vectors/values</span>
    <span class="s3"># sorted.</span>
    <span class="s0">if </span><span class="s1">issparse(m):</span>
        <span class="s1">m = m.toarray()</span>
    <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = svd(m)</span>
    <span class="s0">if </span><span class="s1">which == </span><span class="s2">'LM'</span><span class="s1">:</span>
        <span class="s1">ii = np.argsort(s)[-k:]</span>
    <span class="s0">elif </span><span class="s1">which == </span><span class="s2">'SM'</span><span class="s1">:</span>
        <span class="s1">ii = np.argsort(s)[:k]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;unknown which=</span><span class="s0">{</span><span class="s1">which</span><span class="s0">!r}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">u[:</span><span class="s0">, </span><span class="s1">ii]</span><span class="s0">, </span><span class="s1">s[ii]</span><span class="s0">, </span><span class="s1">vh[ii]</span>


<span class="s0">def </span><span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;LM&quot;</span><span class="s0">, </span><span class="s1">check_usvh_A=</span><span class="s0">False,</span>
                <span class="s1">check_svd=</span><span class="s0">True, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">):</span>
    <span class="s1">n</span><span class="s0">, </span><span class="s1">m = A.shape</span>

    <span class="s3"># Check shapes.</span>
    <span class="s1">assert_equal(u.shape</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">, </span><span class="s1">k))</span>
    <span class="s1">assert_equal(s.shape</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">assert_equal(vh.shape</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">m))</span>

    <span class="s3"># Check that the original matrix can be reconstituted.</span>
    <span class="s1">A_rebuilt = (u*s).dot(vh)</span>
    <span class="s1">assert_equal(A_rebuilt.shape</span><span class="s0">, </span><span class="s1">A.shape)</span>
    <span class="s0">if </span><span class="s1">check_usvh_A:</span>
        <span class="s1">assert_allclose(A_rebuilt</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># Check that u is a semi-orthogonal matrix.</span>
    <span class="s1">uh_u = np.dot(u.T.conj()</span><span class="s0">, </span><span class="s1">u)</span>
    <span class="s1">assert_equal(uh_u.shape</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">k))</span>
    <span class="s1">assert_allclose(uh_u</span><span class="s0">, </span><span class="s1">np.identity(k)</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># Check that vh is a semi-orthogonal matrix.</span>
    <span class="s1">vh_v = np.dot(vh</span><span class="s0">, </span><span class="s1">vh.T.conj())</span>
    <span class="s1">assert_equal(vh_v.shape</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">k))</span>
    <span class="s1">assert_allclose(vh_v</span><span class="s0">, </span><span class="s1">np.identity(k)</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># Check that scipy.sparse.linalg.svds ~ scipy.linalg.svd</span>
    <span class="s0">if </span><span class="s1">check_svd:</span>
        <span class="s1">u2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">vh2 = sorted_svd(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which)</span>
        <span class="s1">assert_allclose(np.abs(u)</span><span class="s0">, </span><span class="s1">np.abs(u2)</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">assert_allclose(s</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">assert_allclose(np.abs(vh)</span><span class="s0">, </span><span class="s1">np.abs(vh2)</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>


<span class="s0">def </span><span class="s1">_check_svds_n(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;LM&quot;</span><span class="s0">, </span><span class="s1">check_res=</span><span class="s0">True,</span>
                  <span class="s1">check_svd=</span><span class="s0">True, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">):</span>
    <span class="s1">n</span><span class="s0">, </span><span class="s1">m = A.shape</span>

    <span class="s3"># Check shapes.</span>
    <span class="s1">assert_equal(u.shape</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">, </span><span class="s1">k))</span>
    <span class="s1">assert_equal(s.shape</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">assert_equal(vh.shape</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">m))</span>

    <span class="s3"># Check that u is a semi-orthogonal matrix.</span>
    <span class="s1">uh_u = np.dot(u.T.conj()</span><span class="s0">, </span><span class="s1">u)</span>
    <span class="s1">assert_equal(uh_u.shape</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">k))</span>
    <span class="s1">error = np.sum(np.abs(uh_u - np.identity(k))) / (k * k)</span>
    <span class="s1">assert_allclose(error</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># Check that vh is a semi-orthogonal matrix.</span>
    <span class="s1">vh_v = np.dot(vh</span><span class="s0">, </span><span class="s1">vh.T.conj())</span>
    <span class="s1">assert_equal(vh_v.shape</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">k))</span>
    <span class="s1">error = np.sum(np.abs(vh_v - np.identity(k))) / (k * k)</span>
    <span class="s1">assert_allclose(error</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># Check residuals</span>
    <span class="s0">if </span><span class="s1">check_res:</span>
        <span class="s1">ru = A.T.conj() @ u - vh.T.conj() * s</span>
        <span class="s1">rus = np.sum(np.abs(ru)) / (n * k)</span>
        <span class="s1">rvh = A @ vh.T.conj() - u * s</span>
        <span class="s1">rvhs = np.sum(np.abs(rvh)) / (m * k)</span>
        <span class="s1">assert_allclose(rus</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">assert_allclose(rvhs</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># Check that scipy.sparse.linalg.svds ~ scipy.linalg.svd</span>
    <span class="s0">if </span><span class="s1">check_svd:</span>
        <span class="s1">u2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">vh2 = sorted_svd(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which)</span>
        <span class="s1">assert_allclose(s</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">A_rebuilt_svd = (u2*s2).dot(vh2)</span>
        <span class="s1">A_rebuilt = (u*s).dot(vh)</span>
        <span class="s1">assert_equal(A_rebuilt.shape</span><span class="s0">, </span><span class="s1">A.shape)</span>
        <span class="s1">error = np.sum(np.abs(A_rebuilt_svd - A_rebuilt)) / (k * k)</span>
        <span class="s1">assert_allclose(error</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>


<span class="s0">class </span><span class="s1">CheckingLinearOperator(LinearOperator):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">A):</span>
        <span class="s1">self.A = A</span>
        <span class="s1">self.dtype = A.dtype</span>
        <span class="s1">self.shape = A.shape</span>

    <span class="s0">def </span><span class="s1">_matvec(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">assert_equal(max(x.shape)</span><span class="s0">, </span><span class="s1">np.size(x))</span>
        <span class="s0">return </span><span class="s1">self.A.dot(x)</span>

    <span class="s0">def </span><span class="s1">_rmatvec(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">assert_equal(max(x.shape)</span><span class="s0">, </span><span class="s1">np.size(x))</span>
        <span class="s0">return </span><span class="s1">self.A.T.conjugate().dot(x)</span>


<span class="s3"># --- Test Input Validation ---</span>
<span class="s3"># Tests input validation on parameters `k` and `which`.</span>
<span class="s3"># Needs better input validation checks for all other parameters.</span>

<span class="s0">class </span><span class="s1">SVDSCommonTests:</span>

    <span class="s1">solver = </span><span class="s0">None</span>

    <span class="s3"># some of these IV tests could run only once, say with solver=None</span>

    <span class="s1">_A_empty_msg = </span><span class="s2">&quot;`A` must not be empty.&quot;</span>
    <span class="s1">_A_dtype_msg = </span><span class="s2">&quot;`A` must be of floating or complex floating data type&quot;</span>
    <span class="s1">_A_type_msg = </span><span class="s2">&quot;type not understood&quot;</span>
    <span class="s1">_A_ndim_msg = </span><span class="s2">&quot;array must have ndim &lt;= 2&quot;</span>
    <span class="s1">_A_validation_inputs = [</span>
        <span class="s1">(np.asarray([[]])</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s1">_A_empty_msg)</span><span class="s0">,</span>
        <span class="s1">(np.asarray([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s1">_A_dtype_msg)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;hi&quot;</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">_A_type_msg)</span><span class="s0">,</span>
        <span class="s1">(np.asarray([[[</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s0">, </span><span class="s4">4.</span><span class="s1">]]])</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s1">_A_ndim_msg)]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;args&quot;</span><span class="s0">, </span><span class="s1">_A_validation_inputs)</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_A(self</span><span class="s0">, </span><span class="s1">args):</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">error_type</span><span class="s0">, </span><span class="s1">message = args</span>
        <span class="s0">with </span><span class="s1">pytest.raises(error_type</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;k&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_k_1(self</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((</span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s1">))</span>

        <span class="s3"># propack can do complete SVD</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack' </span><span class="s0">and </span><span class="s1">k == </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not enabled&quot;</span><span class="s1">)</span>
            <span class="s1">res = svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
            <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res</span><span class="s0">, </span><span class="s1">check_usvh_A=</span><span class="s0">True, </span><span class="s1">check_svd=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return</span>

        <span class="s1">message = (</span><span class="s2">&quot;`k` must be an integer satisfying&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s0">def </span><span class="s1">test_svds_input_validation_k_2(self):</span>
        <span class="s3"># I think the stack trace is reasonable when `k` can't be converted</span>
        <span class="s3"># to an int.</span>
        <span class="s1">message = </span><span class="s2">&quot;int() argument must be a&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=re.escape(message)):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">k=[]</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

        <span class="s1">message = </span><span class="s2">&quot;invalid literal for int()&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">k=</span><span class="s2">&quot;hi&quot;</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;tol&quot;</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan))</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_tol_1(self</span><span class="s0">, </span><span class="s1">tol):</span>
        <span class="s1">message = </span><span class="s2">&quot;`tol` must be a non-negative floating point value.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">tol=tol</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;tol&quot;</span><span class="s0">, </span><span class="s1">([]</span><span class="s0">, </span><span class="s2">'hi'</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_tol_2(self</span><span class="s0">, </span><span class="s1">tol):</span>
        <span class="s3"># I think the stack trace is reasonable here</span>
        <span class="s1">message = </span><span class="s2">&quot;'&lt;' not supported between instances&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">tol=tol</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;which&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'LA'</span><span class="s0">, </span><span class="s2">'SA'</span><span class="s0">, </span><span class="s2">'ekki'</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_which(self</span><span class="s0">, </span><span class="s1">which):</span>
        <span class="s3"># Regression test for a github issue.</span>
        <span class="s3"># https://github.com/scipy/scipy/issues/4590</span>
        <span class="s3"># Function was not checking for eigenvalue type and unintended</span>
        <span class="s3"># values could be returned.</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;`which` must be in&quot;</span><span class="s1">):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">which=which</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;transpose&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;n&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">9</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_v0_1(self</span><span class="s0">, </span><span class="s1">transpose</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">))</span>
        <span class="s1">v0 = rng.random(n)</span>
        <span class="s0">if </span><span class="s1">transpose:</span>
            <span class="s1">A = A.T</span>
        <span class="s1">k = </span><span class="s4">2</span>
        <span class="s1">message = </span><span class="s2">&quot;`v0` must have shape&quot;</span>

        <span class="s1">required_length = (A.shape[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span>
                           <span class="s0">else </span><span class="s1">min(A.shape))</span>
        <span class="s0">if </span><span class="s1">n != required_length:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
                <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">v0=v0</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s0">def </span><span class="s1">test_svds_input_validation_v0_2(self):</span>
        <span class="s1">A = np.ones((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">v0 = np.ones((</span><span class="s4">1</span><span class="s0">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">message = </span><span class="s2">&quot;`v0` must have shape&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">v0=v0</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;v0&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;hi&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s4">10</span><span class="s0">, </span><span class="s1">dtype=int)))</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_v0_3(self</span><span class="s0">, </span><span class="s1">v0):</span>
        <span class="s1">A = np.ones((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">message = </span><span class="s2">&quot;`v0` must be of floating or complex floating data type.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">v0=v0</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;maxiter&quot;</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">5.5</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_maxiter_1(self</span><span class="s0">, </span><span class="s1">maxiter):</span>
        <span class="s1">message = (</span><span class="s2">&quot;`maxiter` must be a positive integer.&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">maxiter=maxiter</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s0">def </span><span class="s1">test_svds_input_validation_maxiter_2(self):</span>
        <span class="s3"># I think the stack trace is reasonable when `k` can't be converted</span>
        <span class="s3"># to an int.</span>
        <span class="s1">message = </span><span class="s2">&quot;int() argument must be a&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=re.escape(message)):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">maxiter=[]</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

        <span class="s1">message = </span><span class="s2">&quot;invalid literal for int()&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">&quot;hi&quot;</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;rsv&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'ekki'</span><span class="s0">, </span><span class="s4">10</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_return_singular_vectors(self</span><span class="s0">, </span><span class="s1">rsv):</span>
        <span class="s1">message = </span><span class="s2">&quot;`return_singular_vectors` must be in&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s3"># --- Test Parameters ---</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;k&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;which&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;LM&quot;</span><span class="s0">, </span><span class="s2">&quot;SM&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_svds_parameter_k_which(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which):</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>
        <span class="s3"># check that the `k` parameter sets the number of eigenvalues/</span>
        <span class="s3"># eigenvectors returned.</span>
        <span class="s3"># Also check that the `which` parameter sets whether the largest or</span>
        <span class="s3"># smallest eigenvalues are returned</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((</span><span class="s4">10</span><span class="s0">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The problem size&quot;</span><span class="s1">):</span>
                <span class="s1">res = svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">which=which</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">,</span>
                           <span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">res = svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">which=which</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">,</span>
                       <span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res</span><span class="s0">, </span><span class="s1">which=which</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">8e-10</span><span class="s1">)</span>

    <span class="s3"># loop instead of parametrize for simplicity</span>
    <span class="s0">def </span><span class="s1">test_svds_parameter_tol(self):</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>
        <span class="s0">return  </span><span class="s3"># TODO: needs work, disabling for now</span>
        <span class="s3"># check the effect of the `tol` parameter on solver accuracy by solving</span>
        <span class="s3"># the same problem with varying `tol` and comparing the eigenvalues</span>
        <span class="s3"># against ground truth computed</span>
        <span class="s1">n = </span><span class="s4">100  </span><span class="s3"># matrix size</span>
        <span class="s1">k = </span><span class="s4">3    </span><span class="s3"># number of eigenvalues to check</span>

        <span class="s3"># generate a random, sparse-ish matrix</span>
        <span class="s3"># effect isn't apparent for matrices that are too small</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((n</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">A[A &gt; </span><span class="s4">.1</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">A = A @ A.T</span>

        <span class="s1">_</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">_ = svd(A)  </span><span class="s3"># calculate ground truth</span>

        <span class="s3"># calculate the error as a function of `tol`</span>
        <span class="s1">A = csc_matrix(A)</span>

        <span class="s0">def </span><span class="s1">err(tol):</span>
            <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'lobpcg' </span><span class="s0">and </span><span class="s1">tol == </span><span class="s4">1e-4</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Exited at iteration&quot;</span><span class="s1">):</span>
                    <span class="s1">_</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">_ = svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">v0=np.ones(n)</span><span class="s0">,</span>
                                    <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">tol=tol)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">_</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">_ = svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">v0=np.ones(n)</span><span class="s0">,</span>
                                <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">tol=tol)</span>
            <span class="s0">return </span><span class="s1">np.linalg.norm((s2 - s[k-</span><span class="s4">1</span><span class="s1">::-</span><span class="s4">1</span><span class="s1">])/s[k-</span><span class="s4">1</span><span class="s1">::-</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">tols = [</span><span class="s4">1e-4</span><span class="s0">, </span><span class="s4">1e-2</span><span class="s0">, </span><span class="s4">1e0</span><span class="s1">]  </span><span class="s3"># tolerance levels to check</span>
        <span class="s3"># for 'arpack' and 'propack', accuracies make discrete steps</span>
        <span class="s1">accuracies = {</span><span class="s2">'propack'</span><span class="s1">: [</span><span class="s4">1e-12</span><span class="s0">, </span><span class="s4">1e-6</span><span class="s0">, </span><span class="s4">1e-4</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s2">'arpack'</span><span class="s1">: [</span><span class="s4">2e-15</span><span class="s0">, </span><span class="s4">1e-10</span><span class="s0">, </span><span class="s4">1e-10</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s2">'lobpcg'</span><span class="s1">: [</span><span class="s4">1e-11</span><span class="s0">, </span><span class="s4">1e-3</span><span class="s0">, </span><span class="s4">10</span><span class="s1">]}</span>

        <span class="s0">for </span><span class="s1">tol</span><span class="s0">, </span><span class="s1">accuracy </span><span class="s0">in </span><span class="s1">zip(tols</span><span class="s0">, </span><span class="s1">accuracies[self.solver]):</span>
            <span class="s1">error = err(tol)</span>
            <span class="s0">assert </span><span class="s1">error &lt; accuracy</span>
            <span class="s0">assert </span><span class="s1">error &gt; accuracy/</span><span class="s4">10</span>

    <span class="s0">def </span><span class="s1">test_svd_v0(self):</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>
        <span class="s3"># check that the `v0` parameter affects the solution</span>
        <span class="s1">n = </span><span class="s4">100</span>
        <span class="s1">k = </span><span class="s4">1</span>
        <span class="s3"># If k != 1, LOBPCG needs more initial vectors, which are generated</span>
        <span class="s3"># with random_state, so it does not pass w/ k &gt;= 2.</span>
        <span class="s3"># For some other values of `n`, the AssertionErrors are not raised</span>
        <span class="s3"># with different v0s, which is reasonable.</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((n</span><span class="s0">, </span><span class="s1">n))</span>

        <span class="s3"># with the same v0, solutions are the same, and they are accurate</span>
        <span class="s3"># v0 takes precedence over random_state</span>
        <span class="s1">v0a = rng.random(n)</span>
        <span class="s1">res1a = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v0=v0a</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">res2a = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v0=v0a</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">assert_allclose(res1a[idx]</span><span class="s0">, </span><span class="s1">res2a[idx]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">2e-16</span><span class="s1">)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res1a)</span>

        <span class="s3"># with the same v0, solutions are the same, and they are accurate</span>
        <span class="s1">v0b = rng.random(n)</span>
        <span class="s1">res1b = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v0=v0b</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">res2b = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v0=v0b</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">assert_allclose(res1b[idx]</span><span class="s0">, </span><span class="s1">res2b[idx]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">2e-16</span><span class="s1">)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res1b)</span>

        <span class="s3"># with different v0, solutions can be numerically different</span>
        <span class="s1">message = </span><span class="s2">&quot;Arrays are not equal&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">assert_equal(res1a</span><span class="s0">, </span><span class="s1">res1b)</span>

    <span class="s0">def </span><span class="s1">test_svd_random_state(self):</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>
        <span class="s3"># check that the `random_state` parameter affects the solution</span>
        <span class="s3"># Admittedly, `n` and `k` are chosen so that all solver pass all</span>
        <span class="s3"># these checks. That's a tall order, since LOBPCG doesn't want to</span>
        <span class="s3"># achieve the desired accuracy and ARPACK often returns the same</span>
        <span class="s3"># singular values/vectors for different v0.</span>
        <span class="s1">n = </span><span class="s4">100</span>
        <span class="s1">k = </span><span class="s4">1</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((n</span><span class="s0">, </span><span class="s1">n))</span>

        <span class="s3"># with the same random_state, solutions are the same and accurate</span>
        <span class="s1">res1a = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">res2a = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">assert_allclose(res1a[idx]</span><span class="s0">, </span><span class="s1">res2a[idx]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">2e-16</span><span class="s1">)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res1a)</span>

        <span class="s3"># with the same random_state, solutions are the same and accurate</span>
        <span class="s1">res1b = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">res2b = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">assert_allclose(res1b[idx]</span><span class="s0">, </span><span class="s1">res2b[idx]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">2e-16</span><span class="s1">)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res1b)</span>

        <span class="s3"># with different random_state, solutions can be numerically different</span>
        <span class="s1">message = </span><span class="s2">&quot;Arrays are not equal&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">assert_equal(res1a</span><span class="s0">, </span><span class="s1">res1b)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;random_state&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">,</span>
                                              <span class="s1">np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                                              <span class="s1">np.random.default_rng(</span><span class="s4">0</span><span class="s1">)))</span>
    <span class="s0">def </span><span class="s1">test_svd_random_state_2(self</span><span class="s0">, </span><span class="s1">random_state):</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>

        <span class="s1">n = </span><span class="s4">100</span>
        <span class="s1">k = </span><span class="s4">1</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((n</span><span class="s0">, </span><span class="s1">n))</span>

        <span class="s1">random_state_2 = copy.deepcopy(random_state)</span>

        <span class="s3"># with the same random_state, solutions are the same and accurate</span>
        <span class="s1">res1a = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=random_state)</span>
        <span class="s1">res2a = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=random_state_2)</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s1">assert_allclose(res1a[idx]</span><span class="s0">, </span><span class="s1">res2a[idx]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">2e-16</span><span class="s1">)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res1a)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;random_state&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None,</span>
                                              <span class="s1">np.random.RandomState(</span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                                              <span class="s1">np.random.default_rng(</span><span class="s4">0</span><span class="s1">)))</span>
    <span class="s0">def </span><span class="s1">test_svd_random_state_3(self</span><span class="s0">, </span><span class="s1">random_state):</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>

        <span class="s1">n = </span><span class="s4">100</span>
        <span class="s1">k = </span><span class="s4">5</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((n</span><span class="s0">, </span><span class="s1">n))</span>

        <span class="s3"># random_state in different state produces accurate - but not</span>
        <span class="s3"># not necessarily identical - results</span>
        <span class="s1">res1a = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=random_state)</span>
        <span class="s1">res2a = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=random_state)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res1a</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">2e-10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">*res2a</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">2e-10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

        <span class="s1">message = </span><span class="s2">&quot;Arrays are not equal&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">assert_equal(res1a</span><span class="s0">, </span><span class="s1">res2a)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:Exited postprocessing&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_svd_maxiter(self):</span>
        <span class="s3"># check that maxiter works as expected: should not return accurate</span>
        <span class="s3"># solution after 1 iteration, but should with default `maxiter`</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>
        <span class="s1">A = np.diag(np.arange(</span><span class="s4">9</span><span class="s1">)).astype(np.float64)</span>
        <span class="s1">k = </span><span class="s4">1</span>
        <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = sorted_svd(A</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'arpack'</span><span class="s1">:</span>
            <span class="s1">message = </span><span class="s2">&quot;ARPACK error -1: No convergence&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ArpackNoConvergence</span><span class="s0">, </span><span class="s1">match=message):</span>
                <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">ncv=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
        <span class="s0">elif </span><span class="s1">self.solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Exited at iteration&quot;</span><span class="s1">):</span>
                <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
        <span class="s0">elif </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s1">message = </span><span class="s2">&quot;k=1 singular triplets did not converge within&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(np.linalg.LinAlgError</span><span class="s0">, </span><span class="s1">match=message):</span>
                <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

        <span class="s1">ud</span><span class="s0">, </span><span class="s1">sd</span><span class="s0">, </span><span class="s1">vhd = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver)  </span><span class="s3"># default maxiter</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">ud</span><span class="s0">, </span><span class="s1">sd</span><span class="s0">, </span><span class="s1">vhd</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.abs(ud)</span><span class="s0">, </span><span class="s1">np.abs(u)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.abs(vhd)</span><span class="s0">, </span><span class="s1">np.abs(vh)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.abs(sd)</span><span class="s0">, </span><span class="s1">np.abs(s)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-9</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;rsv&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, False, </span><span class="s2">'u'</span><span class="s0">, </span><span class="s2">'vh'</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;shape&quot;</span><span class="s0">, </span><span class="s1">((</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">6</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">7</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)))</span>
    <span class="s0">def </span><span class="s1">test_svd_return_singular_vectors(self</span><span class="s0">, </span><span class="s1">rsv</span><span class="s0">, </span><span class="s1">shape):</span>
        <span class="s3"># check that the return_singular_vectors parameter works as expected</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random(shape)</span>
        <span class="s1">k = </span><span class="s4">2</span>
        <span class="s1">M</span><span class="s0">, </span><span class="s1">N = shape</span>
        <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = sorted_svd(A</span><span class="s0">, </span><span class="s1">k)</span>

        <span class="s1">respect_u = </span><span class="s0">True if </span><span class="s1">self.solver == </span><span class="s2">'propack' </span><span class="s0">else </span><span class="s1">M &lt;= N</span>
        <span class="s1">respect_vh = </span><span class="s0">True if </span><span class="s1">self.solver == </span><span class="s2">'propack' </span><span class="s0">else </span><span class="s1">M &gt; N</span>

        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The problem size&quot;</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">rsv </span><span class="s0">is False</span><span class="s1">:</span>
                    <span class="s1">s2 = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">,</span>
                              <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
                    <span class="s1">assert_allclose(s2</span><span class="s0">, </span><span class="s1">s)</span>
                <span class="s0">elif </span><span class="s1">rsv == </span><span class="s2">'u' </span><span class="s0">and </span><span class="s1">respect_u:</span>
                    <span class="s1">u2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">vh2 = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">,</span>
                                       <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
                    <span class="s1">assert_allclose(np.abs(u2)</span><span class="s0">, </span><span class="s1">np.abs(u))</span>
                    <span class="s1">assert_allclose(s2</span><span class="s0">, </span><span class="s1">s)</span>
                    <span class="s0">assert </span><span class="s1">vh2 </span><span class="s0">is None</span>
                <span class="s0">elif </span><span class="s1">rsv == </span><span class="s2">'vh' </span><span class="s0">and </span><span class="s1">respect_vh:</span>
                    <span class="s1">u2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">vh2 = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">,</span>
                                       <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
                    <span class="s0">assert </span><span class="s1">u2 </span><span class="s0">is None</span>
                    <span class="s1">assert_allclose(s2</span><span class="s0">, </span><span class="s1">s)</span>
                    <span class="s1">assert_allclose(np.abs(vh2)</span><span class="s0">, </span><span class="s1">np.abs(vh))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">u2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">vh2 = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">,</span>
                                       <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
                    <span class="s0">if </span><span class="s1">u2 </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">assert_allclose(np.abs(u2)</span><span class="s0">, </span><span class="s1">np.abs(u))</span>
                    <span class="s1">assert_allclose(s2</span><span class="s0">, </span><span class="s1">s)</span>
                    <span class="s0">if </span><span class="s1">vh2 </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">assert_allclose(np.abs(vh2)</span><span class="s0">, </span><span class="s1">np.abs(vh))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">rsv </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s1">s2 = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">,</span>
                          <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
                <span class="s1">assert_allclose(s2</span><span class="s0">, </span><span class="s1">s)</span>
            <span class="s0">elif </span><span class="s1">rsv == </span><span class="s2">'u' </span><span class="s0">and </span><span class="s1">respect_u:</span>
                <span class="s1">u2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">vh2 = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">,</span>
                                   <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
                <span class="s1">assert_allclose(np.abs(u2)</span><span class="s0">, </span><span class="s1">np.abs(u))</span>
                <span class="s1">assert_allclose(s2</span><span class="s0">, </span><span class="s1">s)</span>
                <span class="s0">assert </span><span class="s1">vh2 </span><span class="s0">is None</span>
            <span class="s0">elif </span><span class="s1">rsv == </span><span class="s2">'vh' </span><span class="s0">and </span><span class="s1">respect_vh:</span>
                <span class="s1">u2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">vh2 = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">,</span>
                                   <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
                <span class="s0">assert </span><span class="s1">u2 </span><span class="s0">is None</span>
                <span class="s1">assert_allclose(s2</span><span class="s0">, </span><span class="s1">s)</span>
                <span class="s1">assert_allclose(np.abs(vh2)</span><span class="s0">, </span><span class="s1">np.abs(vh))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">u2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">vh2 = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">return_singular_vectors=rsv</span><span class="s0">,</span>
                                   <span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
                <span class="s0">if </span><span class="s1">u2 </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">assert_allclose(np.abs(u2)</span><span class="s0">, </span><span class="s1">np.abs(u))</span>
                <span class="s1">assert_allclose(s2</span><span class="s0">, </span><span class="s1">s)</span>
                <span class="s0">if </span><span class="s1">vh2 </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">assert_allclose(np.abs(vh2)</span><span class="s0">, </span><span class="s1">np.abs(vh))</span>

    <span class="s3"># --- Test Basic Functionality ---</span>
    <span class="s3"># Tests the accuracy of each solver for real and complex matrices provided</span>
    <span class="s3"># as list, dense array, sparse matrix, and LinearOperator.</span>

    <span class="s1">A1 = [[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s1">A2 = [[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">8 </span><span class="s1">+ </span><span class="s4">5j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3 </span><span class="s1">- </span><span class="s4">2j</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:k &gt;= N - 1&quot;</span><span class="s0">,</span>
                                <span class="s1">reason=</span><span class="s2">&quot;needed to demonstrate #16725&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'A'</span><span class="s0">, </span><span class="s1">(A1</span><span class="s0">, </span><span class="s1">A2))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'k'</span><span class="s0">, </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">5</span><span class="s1">))</span>
    <span class="s3"># PROPACK fails a lot if @pytest.mark.parametrize('which', (&quot;SM&quot;, &quot;LM&quot;))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'real'</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'transpose'</span><span class="s0">, </span><span class="s1">(</span><span class="s0">False, True</span><span class="s1">))</span>
    <span class="s3"># In gh-14299, it was suggested the `svds` should _not_ work with lists</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'lo_type'</span><span class="s0">, </span><span class="s1">(np.asarray</span><span class="s0">, </span><span class="s1">csc_matrix</span><span class="s0">,</span>
                                         <span class="s1">aslinearoperator))</span>
    <span class="s0">def </span><span class="s1">test_svd_simple(self</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">real</span><span class="s0">, </span><span class="s1">transpose</span><span class="s0">, </span><span class="s1">lo_type):</span>

        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>

        <span class="s1">A = np.asarray(A)</span>
        <span class="s1">A = np.real(A) </span><span class="s0">if </span><span class="s1">real </span><span class="s0">else </span><span class="s1">A</span>
        <span class="s1">A = A.T </span><span class="s0">if </span><span class="s1">transpose </span><span class="s0">else </span><span class="s1">A</span>
        <span class="s1">A2 = lo_type(A)</span>

        <span class="s3"># could check for the appropriate errors, but that is tested above</span>
        <span class="s0">if </span><span class="s1">k &gt; min(A.shape):</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;`k` cannot be greater than `min(A.shape)`&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.solver != </span><span class="s2">'propack' </span><span class="s0">and </span><span class="s1">k &gt;= min(A.shape):</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;Only PROPACK supports complete SVD&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'arpack' </span><span class="s0">and not </span><span class="s1">real </span><span class="s0">and </span><span class="s1">k == min(A.shape) - </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;#16725&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack' </span><span class="s0">and </span><span class="s1">(np.intp(</span><span class="s4">0</span><span class="s1">).itemsize &lt; </span><span class="s4">8 </span><span class="s0">and not </span><span class="s1">real):</span>
            <span class="s1">pytest.skip(</span><span class="s2">'PROPACK complex-valued SVD methods not available '</span>
                        <span class="s2">'for 32-bit builds'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The problem size&quot;</span><span class="s1">):</span>
                <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = svds(A2</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = svds(A2</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">3e-10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_svd_linop(self):</span>
        <span class="s1">solver = self.solver</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not available&quot;</span><span class="s1">)</span>

        <span class="s1">nmks = [(</span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">9</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">reorder(args):</span>
            <span class="s1">U</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">VH = args</span>
            <span class="s1">j = np.argsort(s)</span>
            <span class="s0">return </span><span class="s1">U[:</span><span class="s0">, </span><span class="s1">j]</span><span class="s0">, </span><span class="s1">s[j]</span><span class="s0">, </span><span class="s1">VH[j</span><span class="s0">, </span><span class="s1">:]</span>

        <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">k </span><span class="s0">in </span><span class="s1">nmks:</span>
            <span class="s3"># Test svds on a LinearOperator.</span>
            <span class="s1">A = np.random.RandomState(</span><span class="s4">52</span><span class="s1">).randn(n</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s1">L = CheckingLinearOperator(A)</span>

            <span class="s0">if </span><span class="s1">solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
                <span class="s1">v0 = np.ones(n)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">v0 = np.ones(min(A.shape))</span>
            <span class="s0">if </span><span class="s1">solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The problem size&quot;</span><span class="s1">):</span>
                    <span class="s1">U1</span><span class="s0">, </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">VH1 = reorder(svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v0=v0</span><span class="s0">, </span><span class="s1">solver=solver))</span>
                    <span class="s1">U2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">VH2 = reorder(svds(L</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v0=v0</span><span class="s0">, </span><span class="s1">solver=solver))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">U1</span><span class="s0">, </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">VH1 = reorder(svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v0=v0</span><span class="s0">, </span><span class="s1">solver=solver))</span>
                <span class="s1">U2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">VH2 = reorder(svds(L</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v0=v0</span><span class="s0">, </span><span class="s1">solver=solver))</span>

            <span class="s1">assert_allclose(np.abs(U1)</span><span class="s0">, </span><span class="s1">np.abs(U2))</span>
            <span class="s1">assert_allclose(s1</span><span class="s0">, </span><span class="s1">s2)</span>
            <span class="s1">assert_allclose(np.abs(VH1)</span><span class="s0">, </span><span class="s1">np.abs(VH2))</span>
            <span class="s1">assert_allclose(np.dot(U1</span><span class="s0">, </span><span class="s1">np.dot(np.diag(s1)</span><span class="s0">, </span><span class="s1">VH1))</span><span class="s0">,</span>
                            <span class="s1">np.dot(U2</span><span class="s0">, </span><span class="s1">np.dot(np.diag(s2)</span><span class="s0">, </span><span class="s1">VH2)))</span>

            <span class="s3"># Try again with which=&quot;SM&quot;.</span>
            <span class="s1">A = np.random.RandomState(</span><span class="s4">1909</span><span class="s1">).randn(n</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s1">L = CheckingLinearOperator(A)</span>

            <span class="s3"># TODO: arpack crashes when v0=v0, which=&quot;SM&quot;</span>
            <span class="s1">kwargs = {</span><span class="s2">'v0'</span><span class="s1">: v0} </span><span class="s0">if </span><span class="s1">solver </span><span class="s0">not in </span><span class="s1">{</span><span class="s0">None, </span><span class="s2">'arpack'</span><span class="s1">} </span><span class="s0">else </span><span class="s1">{}</span>
            <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The problem size&quot;</span><span class="s1">):</span>
                    <span class="s1">U1</span><span class="s0">, </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">VH1 = reorder(svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;SM&quot;</span><span class="s0">, </span><span class="s1">solver=solver</span><span class="s0">,</span>
                                               <span class="s1">**kwargs))</span>
                    <span class="s1">U2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">VH2 = reorder(svds(L</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;SM&quot;</span><span class="s0">, </span><span class="s1">solver=solver</span><span class="s0">,</span>
                                               <span class="s1">**kwargs))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">U1</span><span class="s0">, </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">VH1 = reorder(svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;SM&quot;</span><span class="s0">, </span><span class="s1">solver=solver</span><span class="s0">,</span>
                                           <span class="s1">**kwargs))</span>
                <span class="s1">U2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">VH2 = reorder(svds(L</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;SM&quot;</span><span class="s0">, </span><span class="s1">solver=solver</span><span class="s0">,</span>
                                           <span class="s1">**kwargs))</span>

            <span class="s1">assert_allclose(np.abs(U1)</span><span class="s0">, </span><span class="s1">np.abs(U2))</span>
            <span class="s1">assert_allclose(s1 + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">s2 + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_allclose(np.abs(VH1)</span><span class="s0">, </span><span class="s1">np.abs(VH2))</span>
            <span class="s1">assert_allclose(np.dot(U1</span><span class="s0">, </span><span class="s1">np.dot(np.diag(s1)</span><span class="s0">, </span><span class="s1">VH1))</span><span class="s0">,</span>
                            <span class="s1">np.dot(U2</span><span class="s0">, </span><span class="s1">np.dot(np.diag(s2)</span><span class="s0">, </span><span class="s1">VH2)))</span>

            <span class="s0">if </span><span class="s1">k &lt; min(n</span><span class="s0">, </span><span class="s1">m) - </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3"># Complex input and explicit which=&quot;LM&quot;.</span>
                <span class="s0">for </span><span class="s1">(dt</span><span class="s0">, </span><span class="s1">eps) </span><span class="s0">in </span><span class="s1">[(complex</span><span class="s0">, </span><span class="s4">1e-7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(np.complex64</span><span class="s0">, </span><span class="s4">1e-3</span><span class="s1">)]:</span>
                    <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack' </span><span class="s0">and </span><span class="s1">np.intp(</span><span class="s4">0</span><span class="s1">).itemsize &lt; </span><span class="s4">8</span><span class="s1">:</span>
                        <span class="s1">pytest.skip(</span><span class="s2">'PROPACK complex-valued SVD methods '</span>
                                    <span class="s2">'not available for 32-bit builds'</span><span class="s1">)</span>
                    <span class="s1">rng = np.random.RandomState(</span><span class="s4">1648</span><span class="s1">)</span>
                    <span class="s1">A = (rng.randn(n</span><span class="s0">, </span><span class="s1">m) + </span><span class="s4">1j </span><span class="s1">* rng.randn(n</span><span class="s0">, </span><span class="s1">m)).astype(dt)</span>
                    <span class="s1">L = CheckingLinearOperator(A)</span>

                    <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
                        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">,</span>
                                          <span class="s1">match=</span><span class="s2">&quot;The problem size&quot;</span><span class="s1">):</span>
                            <span class="s1">U1</span><span class="s0">, </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">VH1 = reorder(svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;LM&quot;</span><span class="s0">,</span>
                                                       <span class="s1">solver=solver))</span>
                            <span class="s1">U2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">VH2 = reorder(svds(L</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;LM&quot;</span><span class="s0">,</span>
                                                       <span class="s1">solver=solver))</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">U1</span><span class="s0">, </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">VH1 = reorder(svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;LM&quot;</span><span class="s0">,</span>
                                                   <span class="s1">solver=solver))</span>
                        <span class="s1">U2</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">VH2 = reorder(svds(L</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;LM&quot;</span><span class="s0">,</span>
                                                   <span class="s1">solver=solver))</span>

                    <span class="s1">assert_allclose(np.abs(U1)</span><span class="s0">, </span><span class="s1">np.abs(U2)</span><span class="s0">, </span><span class="s1">rtol=eps)</span>
                    <span class="s1">assert_allclose(s1</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">rtol=eps)</span>
                    <span class="s1">assert_allclose(np.abs(VH1)</span><span class="s0">, </span><span class="s1">np.abs(VH2)</span><span class="s0">, </span><span class="s1">rtol=eps)</span>
                    <span class="s1">assert_allclose(np.dot(U1</span><span class="s0">, </span><span class="s1">np.dot(np.diag(s1)</span><span class="s0">, </span><span class="s1">VH1))</span><span class="s0">,</span>
                                    <span class="s1">np.dot(U2</span><span class="s0">, </span><span class="s1">np.dot(np.diag(s2)</span><span class="s0">, </span><span class="s1">VH2))</span><span class="s0">,</span>
                                    <span class="s1">rtol=eps)</span>

    <span class="s1">SHAPES = ((</span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">100</span><span class="s0">, </span><span class="s4">101</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">101</span><span class="s0">, </span><span class="s4">100</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:Exited at iteration&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:Exited postprocessing&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;shape&quot;</span><span class="s0">, </span><span class="s1">SHAPES)</span>
    <span class="s3"># ARPACK supports only dtype float, complex, or np.float32</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(float</span><span class="s0">, </span><span class="s1">complex</span><span class="s0">, </span><span class="s1">np.float32))</span>
    <span class="s0">def </span><span class="s1">test_small_sigma_sparse(self</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s3"># https://github.com/scipy/scipy/pull/11829</span>
        <span class="s1">solver = self.solver</span>
        <span class="s3"># 2do: PROPACK fails orthogonality of singular vectors</span>
        <span class="s3"># if dtype == complex and self.solver == 'propack':</span>
        <span class="s3">#    pytest.skip(&quot;PROPACK unsupported for complex dtype&quot;)</span>
        <span class="s0">if </span><span class="s1">solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK failures unrelated to PR&quot;</span><span class="s1">)</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">k = </span><span class="s4">5</span>
        <span class="s1">(m</span><span class="s0">, </span><span class="s1">n) = shape</span>
        <span class="s1">S = random(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">density=</span><span class="s4">0.1</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
        <span class="s0">if </span><span class="s1">dtype == complex:</span>
            <span class="s1">S = + </span><span class="s4">1j </span><span class="s1">* random(m</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">density=</span><span class="s4">0.1</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">e = np.ones(m)</span>
        <span class="s1">e[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">5</span><span class="s1">] *= </span><span class="s4">1e1 </span><span class="s1">** np.arange(-</span><span class="s4">5</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">S = spdiags(e</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">m) @ S</span>
        <span class="s1">S = S.astype(dtype)</span>
        <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = svds(S</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">'SM'</span><span class="s0">, </span><span class="s1">solver=solver</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s1">c_svd = </span><span class="s0">False  </span><span class="s3"># partial SVD can be different from full SVD</span>
        <span class="s1">_check_svds_n(S</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">&quot;SM&quot;</span><span class="s0">, </span><span class="s1">check_svd=c_svd</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-1</span><span class="s1">)</span>

    <span class="s3"># --- Test Edge Cases ---</span>
    <span class="s3"># Checks a few edge cases.</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;shape&quot;</span><span class="s0">, </span><span class="s1">((</span><span class="s4">6</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(float</span><span class="s0">, </span><span class="s1">complex))</span>
    <span class="s0">def </span><span class="s1">test_svd_LM_ones_matrix(self</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s3"># Check that svds can deal with matrix_rank less than k in LM mode.</span>
        <span class="s1">k = </span><span class="s4">3</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">m = shape</span>
        <span class="s1">A = np.ones((n</span><span class="s0">, </span><span class="s1">m)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The problem size&quot;</span><span class="s1">):</span>
                <span class="s1">U</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">VH = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">U</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">VH = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">VH</span><span class="s0">, </span><span class="s1">check_usvh_A=</span><span class="s0">True, </span><span class="s1">check_svd=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s3"># Check that the largest singular value is near sqrt(n*m)</span>
        <span class="s3"># and the other singular values have been forced to zero.</span>
        <span class="s1">assert_allclose(np.max(s)</span><span class="s0">, </span><span class="s1">np.sqrt(n*m))</span>
        <span class="s1">s = np.array(sorted(s)[:-</span><span class="s4">1</span><span class="s1">]) + </span><span class="s4">1</span>
        <span class="s1">z = np.ones_like(s)</span>
        <span class="s1">assert_allclose(s</span><span class="s0">, </span><span class="s1">z)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:k &gt;= N - 1&quot;</span><span class="s0">,</span>
                                <span class="s1">reason=</span><span class="s2">&quot;needed to demonstrate #16725&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;shape&quot;</span><span class="s0">, </span><span class="s1">((</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(float</span><span class="s0">, </span><span class="s1">complex))</span>
    <span class="s0">def </span><span class="s1">test_zero_matrix(self</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s3"># Check that svds can deal with matrices containing only zeros;</span>
        <span class="s3"># see https://github.com/scipy/scipy/issues/3452/</span>
        <span class="s3"># shape = (4, 2) is included because it is the particular case</span>
        <span class="s3"># reported in the issue</span>
        <span class="s1">k = </span><span class="s4">1</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">m = shape</span>
        <span class="s1">A = np.zeros((n</span><span class="s0">, </span><span class="s1">m)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

        <span class="s0">if </span><span class="s1">(self.solver == </span><span class="s2">'arpack' </span><span class="s0">and </span><span class="s1">dtype </span><span class="s0">is </span><span class="s1">complex</span>
                <span class="s0">and </span><span class="s1">k == min(A.shape) - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;#16725&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK failures unrelated to PR #16712&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'lobpcg'</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The problem size&quot;</span><span class="s1">):</span>
                <span class="s1">U</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">VH = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">U</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">VH = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

        <span class="s3"># Check some generic properties of svd.</span>
        <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">U</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">VH</span><span class="s0">, </span><span class="s1">check_usvh_A=</span><span class="s0">True, </span><span class="s1">check_svd=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s3"># Check that the singular values are zero.</span>
        <span class="s1">assert_array_equal(s</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;shape&quot;</span><span class="s0">, </span><span class="s1">((</span><span class="s4">20</span><span class="s0">, </span><span class="s4">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">20</span><span class="s0">, </span><span class="s4">21</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">21</span><span class="s0">, </span><span class="s4">20</span><span class="s1">)))</span>
    <span class="s3"># ARPACK supports only dtype float, complex, or np.float32</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(float</span><span class="s0">, </span><span class="s1">complex</span><span class="s0">, </span><span class="s1">np.float32))</span>
    <span class="s0">def </span><span class="s1">test_small_sigma(self</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s0">if not </span><span class="s1">has_propack:</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not enabled&quot;</span><span class="s1">)</span>
        <span class="s3"># https://github.com/scipy/scipy/pull/11829</span>
        <span class="s0">if </span><span class="s1">dtype == complex </span><span class="s0">and </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK unsupported for complex dtype&quot;</span><span class="s1">)</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">179847540</span><span class="s1">)</span>
        <span class="s1">A = rng.random(shape).astype(dtype)</span>
        <span class="s1">u</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">vh = svd(A</span><span class="s0">, </span><span class="s1">full_matrices=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">dtype == np.float32:</span>
            <span class="s1">e = </span><span class="s4">10.0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">e = </span><span class="s4">100.0</span>
        <span class="s1">t = e**(-np.arange(len(vh))).astype(dtype)</span>
        <span class="s1">A = (u*t).dot(vh)</span>
        <span class="s1">k = </span><span class="s4">4</span>
        <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">solver=self.solver</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">t = np.sum(s &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(t</span><span class="s0">, </span><span class="s1">k)</span>
        <span class="s3"># LOBPCG needs larger atol and rtol to pass</span>
        <span class="s1">_check_svds_n(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e0</span><span class="s0">, </span><span class="s1">check_svd=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s3"># ARPACK supports only dtype float, complex, or np.float32</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:The problem size&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(float</span><span class="s0">, </span><span class="s1">complex</span><span class="s0">, </span><span class="s1">np.float32))</span>
    <span class="s0">def </span><span class="s1">test_small_sigma2(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s0">if </span><span class="s1">self.solver == </span><span class="s2">'propack'</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">has_propack:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK not enabled&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">dtype == np.float32:</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;Test failures in CI, see gh-17004&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">dtype == complex:</span>
                <span class="s3"># https://github.com/scipy/scipy/issues/11406</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;PROPACK unsupported for complex dtype&quot;</span><span class="s1">)</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">179847540</span><span class="s1">)</span>
        <span class="s3"># create a 10x10 singular matrix with a 4-dim null space</span>
        <span class="s1">dim = </span><span class="s4">4</span>
        <span class="s1">size = </span><span class="s4">10</span>
        <span class="s1">x = rng.random((size</span><span class="s0">, </span><span class="s1">size-dim))</span>
        <span class="s1">y = x[:</span><span class="s0">, </span><span class="s1">:dim] * rng.random(dim)</span>
        <span class="s1">mat = np.hstack((x</span><span class="s0">, </span><span class="s1">y))</span>
        <span class="s1">mat = mat.astype(dtype)</span>

        <span class="s1">nz = null_space(mat)</span>
        <span class="s1">assert_equal(nz.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dim)</span>

        <span class="s3"># Tolerances atol and rtol adjusted to pass np.float32</span>
        <span class="s3"># Use non-sparse svd</span>
        <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = svd(mat)</span>
        <span class="s3"># Singular values are 0:</span>
        <span class="s1">assert_allclose(s[-dim:]</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e0</span><span class="s1">)</span>
        <span class="s3"># Smallest right singular vectors in null space:</span>
        <span class="s1">assert_allclose(mat @ vh[-dim:</span><span class="s0">, </span><span class="s1">:].T</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e0</span><span class="s1">)</span>

        <span class="s3"># Smallest singular values should be 0</span>
        <span class="s1">sp_mat = csc_matrix(mat)</span>
        <span class="s1">su</span><span class="s0">, </span><span class="s1">ss</span><span class="s0">, </span><span class="s1">svh = svds(sp_mat</span><span class="s0">, </span><span class="s1">k=dim</span><span class="s0">, </span><span class="s1">which=</span><span class="s2">'SM'</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
        <span class="s3"># Smallest dim singular values are 0:</span>
        <span class="s1">assert_allclose(ss</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e0</span><span class="s1">)</span>
        <span class="s3"># Smallest singular vectors via svds in null space:</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">m = mat.shape</span>
        <span class="s0">if </span><span class="s1">n &lt; m:  </span><span class="s3"># else the assert fails with some libraries unclear why</span>
            <span class="s1">assert_allclose(sp_mat.transpose() @ su</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sp_mat @ svh.T</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e0</span><span class="s1">)</span>

<span class="s3"># --- Perform tests with each solver ---</span>


<span class="s0">class </span><span class="s1">Test_SVDS_once():</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;solver&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'ekki'</span><span class="s0">, </span><span class="s1">object])</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_solver(self</span><span class="s0">, </span><span class="s1">solver):</span>
        <span class="s1">message = </span><span class="s2">&quot;solver must be one of&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(np.ones((</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">solver=solver)</span>


<span class="s0">class </span><span class="s1">Test_SVDS_ARPACK(SVDSCommonTests):</span>

    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.solver = </span><span class="s2">'arpack'</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ncv&quot;</span><span class="s0">, </span><span class="s1">list(range(-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)) + [</span><span class="s4">4.5</span><span class="s0">, </span><span class="s2">&quot;5&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_svds_input_validation_ncv_1(self</span><span class="s0">, </span><span class="s1">ncv):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">A = rng.random((</span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s1">))</span>
        <span class="s1">k = </span><span class="s4">3</span>
        <span class="s0">if </span><span class="s1">ncv </span><span class="s0">in </span><span class="s1">{</span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">}:</span>
            <span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh = svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">ncv=ncv</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>
        <span class="s3"># partial decomposition, so don't check that u@diag(s)@vh=A;</span>
        <span class="s3"># do check that scipy.sparse.linalg.svds ~ scipy.linalg.svd</span>
            <span class="s1">_check_svds(A</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">vh)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">message = (</span><span class="s2">&quot;`ncv` must be an integer satisfying&quot;</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
                <span class="s1">svds(A</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">ncv=ncv</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s0">def </span><span class="s1">test_svds_input_validation_ncv_2(self):</span>
        <span class="s3"># I think the stack trace is reasonable when `ncv` can't be converted</span>
        <span class="s3"># to an int.</span>
        <span class="s1">message = </span><span class="s2">&quot;int() argument must be a&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=re.escape(message)):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncv=[]</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

        <span class="s1">message = </span><span class="s2">&quot;invalid literal for int()&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">svds(np.eye(</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncv=</span><span class="s2">&quot;hi&quot;</span><span class="s0">, </span><span class="s1">solver=self.solver)</span>

    <span class="s3"># I can't see a robust relationship between `ncv` and relevant outputs</span>
    <span class="s3"># (e.g. accuracy, time), so no test of the parameter.</span>


<span class="s0">class </span><span class="s1">Test_SVDS_LOBPCG(SVDSCommonTests):</span>

    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.solver = </span><span class="s2">'lobpcg'</span>

    <span class="s0">def </span><span class="s1">test_svd_random_state_3(self):</span>
        <span class="s1">pytest.xfail(</span><span class="s2">&quot;LOBPCG is having trouble with accuracy.&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">Test_SVDS_PROPACK(SVDSCommonTests):</span>

    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.solver = </span><span class="s2">'propack'</span>

    <span class="s0">def </span><span class="s1">test_svd_LM_ones_matrix(self):</span>
        <span class="s1">message = (</span><span class="s2">&quot;PROPACK does not return orthonormal singular vectors &quot;</span>
                   <span class="s2">&quot;associated with zero singular values.&quot;</span><span class="s1">)</span>
        <span class="s3"># There are some other issues with this matrix of all ones, e.g.</span>
        <span class="s3"># `which='sm'` and `k=1` returns the largest singular value</span>
        <span class="s1">pytest.xfail(message)</span>

    <span class="s0">def </span><span class="s1">test_svd_LM_zeros_matrix(self):</span>
        <span class="s1">message = (</span><span class="s2">&quot;PROPACK does not return orthonormal singular vectors &quot;</span>
                   <span class="s2">&quot;associated with zero singular values.&quot;</span><span class="s1">)</span>
        <span class="s1">pytest.xfail(message)</span>
</pre>
</body>
</html>