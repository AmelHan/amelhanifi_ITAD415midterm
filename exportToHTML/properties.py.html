<html>
<head>
<title>properties.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
properties.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>
<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib.colors </span><span class="s0">import </span><span class="s1">to_rgb</span><span class="s0">, </span><span class="s1">to_rgba</span><span class="s0">, </span><span class="s1">to_rgba_array</span>
<span class="s0">from </span><span class="s1">matplotlib.path </span><span class="s0">import </span><span class="s1">Path</span>

<span class="s0">from </span><span class="s1">seaborn._core.scales </span><span class="s0">import </span><span class="s1">Scale</span><span class="s0">, </span><span class="s1">Boolean</span><span class="s0">, </span><span class="s1">Continuous</span><span class="s0">, </span><span class="s1">Nominal</span><span class="s0">, </span><span class="s1">Temporal</span>
<span class="s0">from </span><span class="s1">seaborn._core.rules </span><span class="s0">import </span><span class="s1">categorical_order</span><span class="s0">, </span><span class="s1">variable_type</span>
<span class="s0">from </span><span class="s1">seaborn._compat </span><span class="s0">import </span><span class="s1">MarkerStyle</span>
<span class="s0">from </span><span class="s1">seaborn.palettes </span><span class="s0">import </span><span class="s1">QUAL_PALETTES</span><span class="s0">, </span><span class="s1">color_palette</span><span class="s0">, </span><span class="s1">blend_palette</span>
<span class="s0">from </span><span class="s1">seaborn.utils </span><span class="s0">import </span><span class="s1">get_color_cycle</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span><span class="s0">, </span><span class="s1">Callable</span><span class="s0">, </span><span class="s1">Tuple</span><span class="s0">, </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Union</span><span class="s0">, </span><span class="s1">Optional</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">numpy.typing </span><span class="s0">import </span><span class="s1">ArrayLike</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s2"># numpy&lt;1.20.0 (Jan 2021)</span>
    <span class="s1">ArrayLike = Any</span>

<span class="s1">RGBTuple = Tuple[float</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">float]</span>
<span class="s1">RGBATuple = Tuple[float</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">float]</span>
<span class="s1">ColorSpec = Union[RGBTuple</span><span class="s0">, </span><span class="s1">RGBATuple</span><span class="s0">, </span><span class="s1">str]</span>

<span class="s1">DashPattern = Tuple[float</span><span class="s0">, </span><span class="s1">...]</span>
<span class="s1">DashPatternWithOffset = Tuple[float</span><span class="s0">, </span><span class="s1">Optional[DashPattern]]</span>

<span class="s1">MarkerPattern = Union[</span>
    <span class="s1">float</span><span class="s0">,</span>
    <span class="s1">str</span><span class="s0">,</span>
    <span class="s1">Tuple[int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">float]</span><span class="s0">,</span>
    <span class="s1">List[Tuple[float</span><span class="s0">, </span><span class="s1">float]]</span><span class="s0">,</span>
    <span class="s1">Path</span><span class="s0">,</span>
    <span class="s1">MarkerStyle</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s1">Mapping = Callable[[ArrayLike]</span><span class="s0">, </span><span class="s1">ArrayLike]</span>


<span class="s2"># =================================================================================== #</span>
<span class="s2"># Base classes</span>
<span class="s2"># =================================================================================== #</span>


<span class="s0">class </span><span class="s1">Property:</span>
    <span class="s3">&quot;&quot;&quot;Base class for visual properties that can be set directly or be data scaling.&quot;&quot;&quot;</span>

    <span class="s2"># When True, scales for this property will populate the legend by default</span>
    <span class="s1">legend = </span><span class="s0">False</span>

    <span class="s2"># When True, scales for this property normalize data to [0, 1] before mapping</span>
    <span class="s1">normed = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">variable: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Initialize the property with the name of the corresponding plot variable.&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">variable:</span>
            <span class="s1">variable = self.__class__.__name__.lower()</span>
        <span class="s1">self.variable = variable</span>

    <span class="s0">def </span><span class="s1">default_scale(self</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Scale:</span>
        <span class="s3">&quot;&quot;&quot;Given data, initialize appropriate scale class.&quot;&quot;&quot;</span>

        <span class="s1">var_type = variable_type(data</span><span class="s0">, </span><span class="s1">boolean_type=</span><span class="s4">&quot;boolean&quot;</span><span class="s0">, </span><span class="s1">strict_boolean=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">var_type == </span><span class="s4">&quot;numeric&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Continuous()</span>
        <span class="s0">elif </span><span class="s1">var_type == </span><span class="s4">&quot;datetime&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Temporal()</span>
        <span class="s0">elif </span><span class="s1">var_type == </span><span class="s4">&quot;boolean&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Boolean()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Nominal()</span>

    <span class="s0">def </span><span class="s1">infer_scale(self</span><span class="s0">, </span><span class="s1">arg: Any</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Scale:</span>
        <span class="s3">&quot;&quot;&quot;Given data and a scaling argument, initialize appropriate scale class.&quot;&quot;&quot;</span>
        <span class="s2"># TODO put these somewhere external for validation</span>
        <span class="s2"># TODO putting this here won't pick it up if subclasses define infer_scale</span>
        <span class="s2"># (e.g. color). How best to handle that? One option is to call super after</span>
        <span class="s2"># handling property-specific possibilities (e.g. for color check that the</span>
        <span class="s2"># arg is not a valid palette name) but that could get tricky.</span>
        <span class="s1">trans_args = [</span><span class="s4">&quot;log&quot;</span><span class="s0">, </span><span class="s4">&quot;symlog&quot;</span><span class="s0">, </span><span class="s4">&quot;logit&quot;</span><span class="s0">, </span><span class="s4">&quot;pow&quot;</span><span class="s0">, </span><span class="s4">&quot;sqrt&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">if </span><span class="s1">any(arg.startswith(k) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">trans_args):</span>
                <span class="s2"># TODO validate numeric type? That should happen centrally somewhere</span>
                <span class="s0">return </span><span class="s1">Continuous(trans=arg)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s4">f&quot;Unknown magic arg for </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">scale: '</span><span class="s0">{</span><span class="s1">arg</span><span class="s0">}</span><span class="s4">'.&quot;</span>
                <span class="s0">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">arg_type = type(arg).__name__</span>
            <span class="s1">msg = </span><span class="s4">f&quot;Magic arg for </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">scale must be str, not </span><span class="s0">{</span><span class="s1">arg_type</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s0">def </span><span class="s1">get_mapping(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>
        <span class="s3">&quot;&quot;&quot;Return a function that maps from data domain to property range.&quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">identity(x):</span>
            <span class="s0">return </span><span class="s1">x</span>
        <span class="s0">return </span><span class="s1">identity</span>

    <span class="s0">def </span><span class="s1">standardize(self</span><span class="s0">, </span><span class="s1">val: Any) -&gt; Any:</span>
        <span class="s3">&quot;&quot;&quot;Coerce flexible property value to standardized representation.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">val</span>

    <span class="s0">def </span><span class="s1">_check_dict_entries(self</span><span class="s0">, </span><span class="s1">levels: list</span><span class="s0">, </span><span class="s1">values: dict) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Input check when values are provided as a dictionary.&quot;&quot;&quot;</span>
        <span class="s1">missing = set(levels) - set(values)</span>
        <span class="s0">if </span><span class="s1">missing:</span>
            <span class="s1">formatted = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(map(repr</span><span class="s0">, </span><span class="s1">sorted(missing</span><span class="s0">, </span><span class="s1">key=str)))</span>
            <span class="s1">err = </span><span class="s4">f&quot;No entry in </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">dictionary for </span><span class="s0">{</span><span class="s1">formatted</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError(err)</span>

    <span class="s0">def </span><span class="s1">_check_list_length(self</span><span class="s0">, </span><span class="s1">levels: list</span><span class="s0">, </span><span class="s1">values: list) -&gt; list:</span>
        <span class="s3">&quot;&quot;&quot;Input check when values are provided as a list.&quot;&quot;&quot;</span>
        <span class="s1">message = </span><span class="s4">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(levels) &gt; len(values):</span>
            <span class="s1">message = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;</span><span class="s0">\n</span><span class="s4">The </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">list has fewer values (</span><span class="s0">{</span><span class="s1">len(values)</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;than needed (</span><span class="s0">{</span><span class="s1">len(levels)</span><span class="s0">}</span><span class="s4">) and will cycle, which may&quot;</span><span class="s0">,</span>
                <span class="s4">&quot;produce an uninterpretable plot.&quot;</span>
            <span class="s1">])</span>
            <span class="s1">values = [x </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">zip(levels</span><span class="s0">, </span><span class="s1">itertools.cycle(values))]</span>

        <span class="s0">elif </span><span class="s1">len(values) &gt; len(levels):</span>
            <span class="s1">message = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;The </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">list has more values (</span><span class="s0">{</span><span class="s1">len(values)</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;than needed (</span><span class="s0">{</span><span class="s1">len(levels)</span><span class="s0">}</span><span class="s4">), which may not be intended.&quot;</span><span class="s0">,</span>
            <span class="s1">])</span>
            <span class="s1">values = values[:len(levels)]</span>

        <span class="s2"># TODO look into custom PlotSpecWarning with better formatting</span>
        <span class="s0">if </span><span class="s1">message:</span>
            <span class="s1">warnings.warn(message</span><span class="s0">, </span><span class="s1">UserWarning)</span>

        <span class="s0">return </span><span class="s1">values</span>


<span class="s2"># =================================================================================== #</span>
<span class="s2"># Properties relating to spatial position of marks on the plotting axes</span>
<span class="s2"># =================================================================================== #</span>


<span class="s0">class </span><span class="s1">Coordinate(Property):</span>
    <span class="s3">&quot;&quot;&quot;The position of visual marks with respect to the axes of the plot.&quot;&quot;&quot;</span>
    <span class="s1">legend = </span><span class="s0">False</span>
    <span class="s1">normed = </span><span class="s0">False</span>


<span class="s2"># =================================================================================== #</span>
<span class="s2"># Properties with numeric values where scale range can be defined as an interval</span>
<span class="s2"># =================================================================================== #</span>


<span class="s0">class </span><span class="s1">IntervalProperty(Property):</span>
    <span class="s3">&quot;&quot;&quot;A numeric property where scale range can be defined as an interval.&quot;&quot;&quot;</span>
    <span class="s1">legend = </span><span class="s0">True</span>
    <span class="s1">normed = </span><span class="s0">True</span>

    <span class="s1">_default_range: tuple[float</span><span class="s0">, </span><span class="s1">float] = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">default_range(self) -&gt; tuple[float</span><span class="s0">, </span><span class="s1">float]:</span>
        <span class="s3">&quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._default_range</span>

    <span class="s0">def </span><span class="s1">_forward(self</span><span class="s0">, </span><span class="s1">values: ArrayLike) -&gt; ArrayLike:</span>
        <span class="s3">&quot;&quot;&quot;Transform applied to native values before linear mapping into interval.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s0">def </span><span class="s1">_inverse(self</span><span class="s0">, </span><span class="s1">values: ArrayLike) -&gt; ArrayLike:</span>
        <span class="s3">&quot;&quot;&quot;Transform applied to results of mapping that returns to native values.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s0">def </span><span class="s1">infer_scale(self</span><span class="s0">, </span><span class="s1">arg: Any</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Scale:</span>
        <span class="s3">&quot;&quot;&quot;Given data and a scaling argument, initialize appropriate scale class.&quot;&quot;&quot;</span>

        <span class="s2"># TODO infer continuous based on log/sqrt etc?</span>

        <span class="s1">var_type = variable_type(data</span><span class="s0">, </span><span class="s1">boolean_type=</span><span class="s4">&quot;boolean&quot;</span><span class="s0">, </span><span class="s1">strict_boolean=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">var_type == </span><span class="s4">&quot;boolean&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Boolean(arg)</span>
        <span class="s0">elif </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">dict)):</span>
            <span class="s0">return </span><span class="s1">Nominal(arg)</span>
        <span class="s0">elif </span><span class="s1">var_type == </span><span class="s4">&quot;categorical&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Nominal(arg)</span>
        <span class="s0">elif </span><span class="s1">var_type == </span><span class="s4">&quot;datetime&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Temporal(arg)</span>
        <span class="s2"># TODO other variable types</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Continuous(arg)</span>

    <span class="s0">def </span><span class="s1">get_mapping(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>
        <span class="s3">&quot;&quot;&quot;Return a function that maps from data domain to property range.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(scale</span><span class="s0">, </span><span class="s1">Nominal):</span>
            <span class="s0">return </span><span class="s1">self._get_nominal_mapping(scale</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s0">elif </span><span class="s1">isinstance(scale</span><span class="s0">, </span><span class="s1">Boolean):</span>
            <span class="s0">return </span><span class="s1">self._get_boolean_mapping(scale</span><span class="s0">, </span><span class="s1">data)</span>

        <span class="s0">if </span><span class="s1">scale.values </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = self._forward(self.default_range)</span>
        <span class="s0">elif </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">len(scale.values) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = self._forward(scale.values)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">actual = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">len(scale.values)</span><span class="s0">}</span><span class="s4">-tuple&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">actual = str(type(scale.values))</span>
            <span class="s1">scale_class = scale.__class__.__name__</span>
            <span class="s1">err = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;Values for </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">variables with </span><span class="s0">{</span><span class="s1">scale_class</span><span class="s0">} </span><span class="s4">scale&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;must be 2-tuple; not </span><span class="s0">{</span><span class="s1">actual</span><span class="s0">}</span><span class="s4">.&quot;</span><span class="s0">,</span>
            <span class="s1">])</span>
            <span class="s0">raise </span><span class="s1">TypeError(err)</span>

        <span class="s0">def </span><span class="s1">mapping(x):</span>
            <span class="s0">return </span><span class="s1">self._inverse(np.multiply(x</span><span class="s0">, </span><span class="s1">vmax - vmin) + vmin)</span>

        <span class="s0">return </span><span class="s1">mapping</span>

    <span class="s0">def </span><span class="s1">_get_nominal_mapping(self</span><span class="s0">, </span><span class="s1">scale: Nominal</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>
        <span class="s3">&quot;&quot;&quot;Identify evenly-spaced values using interval or explicit mapping.&quot;&quot;&quot;</span>
        <span class="s1">levels = categorical_order(data</span><span class="s0">, </span><span class="s1">scale.order)</span>
        <span class="s1">values = self._get_values(scale</span><span class="s0">, </span><span class="s1">levels)</span>

        <span class="s0">def </span><span class="s1">mapping(x):</span>
            <span class="s1">ixs = np.asarray(x</span><span class="s0">, </span><span class="s1">np.intp)</span>
            <span class="s1">out = np.full(len(x)</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">use = np.isfinite(x)</span>
            <span class="s1">out[use] = np.take(values</span><span class="s0">, </span><span class="s1">ixs[use])</span>
            <span class="s0">return </span><span class="s1">out</span>

        <span class="s0">return </span><span class="s1">mapping</span>

    <span class="s0">def </span><span class="s1">_get_boolean_mapping(self</span><span class="s0">, </span><span class="s1">scale: Boolean</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>
        <span class="s3">&quot;&quot;&quot;Identify evenly-spaced values using interval or explicit mapping.&quot;&quot;&quot;</span>
        <span class="s1">values = self._get_values(scale</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>

        <span class="s0">def </span><span class="s1">mapping(x):</span>
            <span class="s1">out = np.full(len(x)</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">use = np.isfinite(x)</span>
            <span class="s1">out[use] = np.where(x[use]</span><span class="s0">, </span><span class="s1">*values)</span>
            <span class="s0">return </span><span class="s1">out</span>

        <span class="s0">return </span><span class="s1">mapping</span>

    <span class="s0">def </span><span class="s1">_get_values(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">levels: list) -&gt; list:</span>
        <span class="s3">&quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">self._check_dict_entries(levels</span><span class="s0">, </span><span class="s1">scale.values)</span>
            <span class="s1">values = [scale.values[x] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">levels]</span>
        <span class="s0">elif </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">values = self._check_list_length(levels</span><span class="s0">, </span><span class="s1">scale.values)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">scale.values </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = self.default_range</span>
            <span class="s0">elif </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = scale.values</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">scale_class = scale.__class__.__name__</span>
                <span class="s1">err = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                    <span class="s4">f&quot;Values for </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">variables with </span><span class="s0">{</span><span class="s1">scale_class</span><span class="s0">} </span><span class="s4">scale&quot;</span><span class="s0">,</span>
                    <span class="s4">f&quot;must be a dict, list or tuple; not </span><span class="s0">{</span><span class="s1">type(scale.values)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s0">,</span>
                <span class="s1">])</span>
                <span class="s0">raise </span><span class="s1">TypeError(err)</span>

            <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = self._forward([vmin</span><span class="s0">, </span><span class="s1">vmax])</span>
            <span class="s1">values = list(self._inverse(np.linspace(vmax</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">len(levels))))</span>

        <span class="s0">return </span><span class="s1">values</span>


<span class="s0">class </span><span class="s1">PointSize(IntervalProperty):</span>
    <span class="s3">&quot;&quot;&quot;Size (diameter) of a point mark, in points, with scaling by area.&quot;&quot;&quot;</span>
    <span class="s1">_default_range = </span><span class="s5">2</span><span class="s0">, </span><span class="s5">8  </span><span class="s2"># TODO use rcparams?</span>

    <span class="s0">def </span><span class="s1">_forward(self</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s3">&quot;&quot;&quot;Square native values to implement linear scaling of point area.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.square(values)</span>

    <span class="s0">def </span><span class="s1">_inverse(self</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s3">&quot;&quot;&quot;Invert areal values back to point diameter.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.sqrt(values)</span>


<span class="s0">class </span><span class="s1">LineWidth(IntervalProperty):</span>
    <span class="s3">&quot;&quot;&quot;Thickness of a line mark, in points.&quot;&quot;&quot;</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">default_range(self) -&gt; tuple[float</span><span class="s0">, </span><span class="s1">float]:</span>
        <span class="s3">&quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;</span>
        <span class="s1">base = mpl.rcParams[</span><span class="s4">&quot;lines.linewidth&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">base * </span><span class="s5">.5</span><span class="s0">, </span><span class="s1">base * </span><span class="s5">2</span>


<span class="s0">class </span><span class="s1">EdgeWidth(IntervalProperty):</span>
    <span class="s3">&quot;&quot;&quot;Thickness of the edges on a patch mark, in points.&quot;&quot;&quot;</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">default_range(self) -&gt; tuple[float</span><span class="s0">, </span><span class="s1">float]:</span>
        <span class="s3">&quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;</span>
        <span class="s1">base = mpl.rcParams[</span><span class="s4">&quot;patch.linewidth&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">base * </span><span class="s5">.5</span><span class="s0">, </span><span class="s1">base * </span><span class="s5">2</span>


<span class="s0">class </span><span class="s1">Stroke(IntervalProperty):</span>
    <span class="s3">&quot;&quot;&quot;Thickness of lines that define point glyphs.&quot;&quot;&quot;</span>
    <span class="s1">_default_range = </span><span class="s5">.25</span><span class="s0">, </span><span class="s5">2.5</span>


<span class="s0">class </span><span class="s1">Alpha(IntervalProperty):</span>
    <span class="s3">&quot;&quot;&quot;Opacity of the color values for an arbitrary mark.&quot;&quot;&quot;</span>
    <span class="s1">_default_range = </span><span class="s5">.3</span><span class="s0">, </span><span class="s5">.95</span>
    <span class="s2"># TODO validate / enforce that output is in [0, 1]</span>


<span class="s0">class </span><span class="s1">Offset(IntervalProperty):</span>
    <span class="s3">&quot;&quot;&quot;Offset for edge-aligned text, in point units.&quot;&quot;&quot;</span>
    <span class="s1">_default_range = </span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span>
    <span class="s1">_legend = </span><span class="s0">False</span>


<span class="s0">class </span><span class="s1">FontSize(IntervalProperty):</span>
    <span class="s3">&quot;&quot;&quot;Font size for textual marks, in points.&quot;&quot;&quot;</span>
    <span class="s1">_legend = </span><span class="s0">False</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">default_range(self) -&gt; tuple[float</span><span class="s0">, </span><span class="s1">float]:</span>
        <span class="s3">&quot;&quot;&quot;Min and max values used by default for semantic mapping.&quot;&quot;&quot;</span>
        <span class="s1">base = mpl.rcParams[</span><span class="s4">&quot;font.size&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">base * </span><span class="s5">.5</span><span class="s0">, </span><span class="s1">base * </span><span class="s5">2</span>


<span class="s2"># =================================================================================== #</span>
<span class="s2"># Properties defined by arbitrary objects with inherently nominal scaling</span>
<span class="s2"># =================================================================================== #</span>


<span class="s0">class </span><span class="s1">ObjectProperty(Property):</span>
    <span class="s3">&quot;&quot;&quot;A property defined by arbitrary an object, with inherently nominal scaling.&quot;&quot;&quot;</span>
    <span class="s1">legend = </span><span class="s0">True</span>
    <span class="s1">normed = </span><span class="s0">False</span>

    <span class="s2"># Object representing null data, should appear invisible when drawn by matplotlib</span>
    <span class="s2"># Note that we now drop nulls in Plot._plot_layer and thus may not need this</span>
    <span class="s1">null_value: Any = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_default_values(self</span><span class="s0">, </span><span class="s1">n: int) -&gt; list:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">default_scale(self</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Scale:</span>
        <span class="s1">var_type = variable_type(data</span><span class="s0">, </span><span class="s1">boolean_type=</span><span class="s4">&quot;boolean&quot;</span><span class="s0">, </span><span class="s1">strict_boolean=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">Boolean() </span><span class="s0">if </span><span class="s1">var_type == </span><span class="s4">&quot;boolean&quot; </span><span class="s0">else </span><span class="s1">Nominal()</span>

    <span class="s0">def </span><span class="s1">infer_scale(self</span><span class="s0">, </span><span class="s1">arg: Any</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Scale:</span>
        <span class="s1">var_type = variable_type(data</span><span class="s0">, </span><span class="s1">boolean_type=</span><span class="s4">&quot;boolean&quot;</span><span class="s0">, </span><span class="s1">strict_boolean=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">Boolean(arg) </span><span class="s0">if </span><span class="s1">var_type == </span><span class="s4">&quot;boolean&quot; </span><span class="s0">else </span><span class="s1">Nominal(arg)</span>

    <span class="s0">def </span><span class="s1">get_mapping(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>
        <span class="s3">&quot;&quot;&quot;Define mapping as lookup into list of object values.&quot;&quot;&quot;</span>
        <span class="s1">boolean_scale = isinstance(scale</span><span class="s0">, </span><span class="s1">Boolean)</span>
        <span class="s1">order = getattr(scale</span><span class="s0">, </span><span class="s4">&quot;order&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">] </span><span class="s0">if </span><span class="s1">boolean_scale </span><span class="s0">else None</span><span class="s1">)</span>
        <span class="s1">levels = categorical_order(data</span><span class="s0">, </span><span class="s1">order)</span>
        <span class="s1">values = self._get_values(scale</span><span class="s0">, </span><span class="s1">levels)</span>

        <span class="s0">if </span><span class="s1">boolean_scale:</span>
            <span class="s1">values = values[::-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s0">def </span><span class="s1">mapping(x):</span>
            <span class="s1">ixs = np.asarray(np.nan_to_num(x)</span><span class="s0">, </span><span class="s1">np.intp)</span>
            <span class="s0">return </span><span class="s1">[</span>
                <span class="s1">values[ix] </span><span class="s0">if </span><span class="s1">np.isfinite(x_i) </span><span class="s0">else </span><span class="s1">self.null_value</span>
                <span class="s0">for </span><span class="s1">x_i</span><span class="s0">, </span><span class="s1">ix </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">ixs)</span>
            <span class="s1">]</span>

        <span class="s0">return </span><span class="s1">mapping</span>

    <span class="s0">def </span><span class="s1">_get_values(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">levels: list) -&gt; list:</span>
        <span class="s3">&quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;</span>
        <span class="s1">n = len(levels)</span>
        <span class="s0">if </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">self._check_dict_entries(levels</span><span class="s0">, </span><span class="s1">scale.values)</span>
            <span class="s1">values = [scale.values[x] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">levels]</span>
        <span class="s0">elif </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">values = self._check_list_length(levels</span><span class="s0">, </span><span class="s1">scale.values)</span>
        <span class="s0">elif </span><span class="s1">scale.values </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">values = self._default_values(n)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;Scale values for a </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">variable must be provided&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;in a dict or list; not </span><span class="s0">{</span><span class="s1">type(scale.values)</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s1">])</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">values = [self.standardize(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">values]</span>
        <span class="s0">return </span><span class="s1">values</span>


<span class="s0">class </span><span class="s1">Marker(ObjectProperty):</span>
    <span class="s3">&quot;&quot;&quot;Shape of points in scatter-type marks or lines with data points marked.&quot;&quot;&quot;</span>
    <span class="s1">null_value = MarkerStyle(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

    <span class="s2"># TODO should we have named marker &quot;palettes&quot;? (e.g. see d3 options)</span>

    <span class="s2"># TODO need some sort of &quot;require_scale&quot; functionality</span>
    <span class="s2"># to raise when we get the wrong kind explicitly specified</span>

    <span class="s0">def </span><span class="s1">standardize(self</span><span class="s0">, </span><span class="s1">val: MarkerPattern) -&gt; MarkerStyle:</span>
        <span class="s0">return </span><span class="s1">MarkerStyle(val)</span>

    <span class="s0">def </span><span class="s1">_default_values(self</span><span class="s0">, </span><span class="s1">n: int) -&gt; list[MarkerStyle]:</span>
        <span class="s3">&quot;&quot;&quot;Build an arbitrarily long list of unique marker styles. 
 
        Parameters 
        ---------- 
        n : int 
            Number of unique marker specs to generate. 
 
        Returns 
        ------- 
        markers : list of string or tuples 
            Values for defining :class:`matplotlib.markers.MarkerStyle` objects. 
            All markers will be filled. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Start with marker specs that are well distinguishable</span>
        <span class="s1">markers = [</span>
            <span class="s4">&quot;o&quot;</span><span class="s0">, </span><span class="s4">&quot;X&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">45</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;P&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;^&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">45</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;v&quot;</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s2"># Now generate more from regular polygons of increasing order</span>
        <span class="s1">s = </span><span class="s5">5</span>
        <span class="s0">while </span><span class="s1">len(markers) &lt; n:</span>
            <span class="s1">a = </span><span class="s5">360 </span><span class="s1">/ (s + </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span>
            <span class="s1">markers.extend([(s + </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">(s + </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">(s</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(s</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)])</span>
            <span class="s1">s += </span><span class="s5">1</span>

        <span class="s1">markers = [MarkerStyle(m) </span><span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">markers[:n]]</span>

        <span class="s0">return </span><span class="s1">markers</span>


<span class="s0">class </span><span class="s1">LineStyle(ObjectProperty):</span>
    <span class="s3">&quot;&quot;&quot;Dash pattern for line-type marks.&quot;&quot;&quot;</span>
    <span class="s1">null_value = </span><span class="s4">&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">standardize(self</span><span class="s0">, </span><span class="s1">val: str | DashPattern) -&gt; DashPatternWithOffset:</span>
        <span class="s0">return </span><span class="s1">self._get_dash_pattern(val)</span>

    <span class="s0">def </span><span class="s1">_default_values(self</span><span class="s0">, </span><span class="s1">n: int) -&gt; list[DashPatternWithOffset]:</span>
        <span class="s3">&quot;&quot;&quot;Build an arbitrarily long list of unique dash styles for lines. 
 
        Parameters 
        ---------- 
        n : int 
            Number of unique dash specs to generate. 
 
        Returns 
        ------- 
        dashes : list of strings or tuples 
            Valid arguments for the ``dashes`` parameter on 
            :class:`matplotlib.lines.Line2D`. The first spec is a solid 
            line (``&quot;&quot;``), the remainder are sequences of long and short 
            dashes. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Start with dash specs that are well distinguishable</span>
        <span class="s1">dashes: list[str | DashPattern] = [</span>
            <span class="s4">&quot;-&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1.25</span><span class="s0">, </span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">1.25</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s2"># Now programmatically build as many as we need</span>
        <span class="s1">p = </span><span class="s5">3</span>
        <span class="s0">while </span><span class="s1">len(dashes) &lt; n:</span>

            <span class="s2"># Take combinations of long and short dashes</span>
            <span class="s1">a = itertools.combinations_with_replacement([</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1.25</span><span class="s1">]</span><span class="s0">, </span><span class="s1">p)</span>
            <span class="s1">b = itertools.combinations_with_replacement([</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">p)</span>

            <span class="s2"># Interleave the combinations, reversing one of the streams</span>
            <span class="s1">segment_list = itertools.chain(*zip(list(a)[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">][::-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(b)[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]))</span>

            <span class="s2"># Now insert the gaps</span>
            <span class="s0">for </span><span class="s1">segments </span><span class="s0">in </span><span class="s1">segment_list:</span>
                <span class="s1">gap = min(segments)</span>
                <span class="s1">spec = tuple(itertools.chain(*((seg</span><span class="s0">, </span><span class="s1">gap) </span><span class="s0">for </span><span class="s1">seg </span><span class="s0">in </span><span class="s1">segments)))</span>
                <span class="s1">dashes.append(spec)</span>

            <span class="s1">p += </span><span class="s5">1</span>

        <span class="s0">return </span><span class="s1">[self._get_dash_pattern(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dashes]</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_get_dash_pattern(style: str | DashPattern) -&gt; DashPatternWithOffset:</span>
        <span class="s3">&quot;&quot;&quot;Convert linestyle arguments to dash pattern with offset.&quot;&quot;&quot;</span>
        <span class="s2"># Copied and modified from Matplotlib 3.4</span>
        <span class="s2"># go from short hand -&gt; full strings</span>
        <span class="s1">ls_mapper = {</span><span class="s4">&quot;-&quot;</span><span class="s1">: </span><span class="s4">&quot;solid&quot;</span><span class="s0">, </span><span class="s4">&quot;--&quot;</span><span class="s1">: </span><span class="s4">&quot;dashed&quot;</span><span class="s0">, </span><span class="s4">&quot;-.&quot;</span><span class="s1">: </span><span class="s4">&quot;dashdot&quot;</span><span class="s0">, </span><span class="s4">&quot;:&quot;</span><span class="s1">: </span><span class="s4">&quot;dotted&quot;</span><span class="s1">}</span>
        <span class="s0">if </span><span class="s1">isinstance(style</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">style = ls_mapper.get(style</span><span class="s0">, </span><span class="s1">style)</span>
            <span class="s2"># un-dashed styles</span>
            <span class="s0">if </span><span class="s1">style </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;solid&quot;</span><span class="s0">, </span><span class="s4">&quot;none&quot;</span><span class="s0">, </span><span class="s4">&quot;None&quot;</span><span class="s1">]:</span>
                <span class="s1">offset = </span><span class="s5">0</span>
                <span class="s1">dashes = </span><span class="s0">None</span>
            <span class="s2"># dashed styles</span>
            <span class="s0">elif </span><span class="s1">style </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;dashed&quot;</span><span class="s0">, </span><span class="s4">&quot;dashdot&quot;</span><span class="s0">, </span><span class="s4">&quot;dotted&quot;</span><span class="s1">]:</span>
                <span class="s1">offset = </span><span class="s5">0</span>
                <span class="s1">dashes = tuple(mpl.rcParams[</span><span class="s4">f&quot;lines.</span><span class="s0">{</span><span class="s1">style</span><span class="s0">}</span><span class="s4">_pattern&quot;</span><span class="s1">])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">options = [*ls_mapper.values()</span><span class="s0">, </span><span class="s1">*ls_mapper.keys()]</span>
                <span class="s1">msg = </span><span class="s4">f&quot;Linestyle string must be one of </span><span class="s0">{</span><span class="s1">options</span><span class="s0">}</span><span class="s4">, not </span><span class="s0">{</span><span class="s1">repr(style)</span><span class="s0">}</span><span class="s4">.&quot;</span>
                <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s0">elif </span><span class="s1">isinstance(style</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s0">if </span><span class="s1">len(style) &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">isinstance(style[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">offset</span><span class="s0">, </span><span class="s1">dashes = style</span>
            <span class="s0">elif </span><span class="s1">len(style) &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">style[</span><span class="s5">1</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">offset</span><span class="s0">, </span><span class="s1">dashes = style</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">offset = </span><span class="s5">0</span>
                <span class="s1">dashes = style</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">val_type = type(style).__name__</span>
            <span class="s1">msg = </span><span class="s4">f&quot;Linestyle must be str or tuple, not </span><span class="s0">{</span><span class="s1">val_type</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s2"># Normalize offset to be positive and shorter than the dash cycle</span>
        <span class="s0">if </span><span class="s1">dashes </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">dsum = sum(dashes)</span>
            <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s1">msg = </span><span class="s4">f&quot;Invalid dash pattern: </span><span class="s0">{</span><span class="s1">dashes</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s0">raise </span><span class="s1">TypeError(msg) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s0">if </span><span class="s1">dsum:</span>
                <span class="s1">offset %= dsum</span>

        <span class="s0">return </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">dashes</span>


<span class="s0">class </span><span class="s1">TextAlignment(ObjectProperty):</span>
    <span class="s1">legend = </span><span class="s0">False</span>


<span class="s0">class </span><span class="s1">HorizontalAlignment(TextAlignment):</span>

    <span class="s0">def </span><span class="s1">_default_values(self</span><span class="s0">, </span><span class="s1">n: int) -&gt; list:</span>
        <span class="s1">vals = itertools.cycle([</span><span class="s4">&quot;left&quot;</span><span class="s0">, </span><span class="s4">&quot;right&quot;</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">[next(vals) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(n)]</span>


<span class="s0">class </span><span class="s1">VerticalAlignment(TextAlignment):</span>

    <span class="s0">def </span><span class="s1">_default_values(self</span><span class="s0">, </span><span class="s1">n: int) -&gt; list:</span>
        <span class="s1">vals = itertools.cycle([</span><span class="s4">&quot;top&quot;</span><span class="s0">, </span><span class="s4">&quot;bottom&quot;</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">[next(vals) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(n)]</span>


<span class="s2"># =================================================================================== #</span>
<span class="s2"># Properties with  RGB(A) color values</span>
<span class="s2"># =================================================================================== #</span>


<span class="s0">class </span><span class="s1">Color(Property):</span>
    <span class="s3">&quot;&quot;&quot;Color, as RGB(A), scalable with nominal palettes or continuous gradients.&quot;&quot;&quot;</span>
    <span class="s1">legend = </span><span class="s0">True</span>
    <span class="s1">normed = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">standardize(self</span><span class="s0">, </span><span class="s1">val: ColorSpec) -&gt; RGBTuple | RGBATuple:</span>
        <span class="s2"># Return color with alpha channel only if the input spec has it</span>
        <span class="s2"># This is so that RGBA colors can override the Alpha property</span>
        <span class="s0">if </span><span class="s1">to_rgba(val) != to_rgba(val</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">to_rgba(val)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">to_rgb(val)</span>

    <span class="s0">def </span><span class="s1">_standardize_color_sequence(self</span><span class="s0">, </span><span class="s1">colors: ArrayLike) -&gt; ArrayLike:</span>
        <span class="s3">&quot;&quot;&quot;Convert color sequence to RGB(A) array, preserving but not adding alpha.&quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">has_alpha(x):</span>
            <span class="s0">return </span><span class="s1">to_rgba(x) != to_rgba(x</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(colors</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">needs_alpha = colors.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">4</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">needs_alpha = any(has_alpha(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">colors)</span>

        <span class="s0">if </span><span class="s1">needs_alpha:</span>
            <span class="s0">return </span><span class="s1">to_rgba_array(colors)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">to_rgba_array(colors)[:</span><span class="s0">, </span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">infer_scale(self</span><span class="s0">, </span><span class="s1">arg: Any</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Scale:</span>
        <span class="s2"># TODO when inferring Continuous without data, verify type</span>

        <span class="s2"># TODO need to rethink the variable type system</span>
        <span class="s2"># (e.g. boolean, ordered categories as Ordinal, etc)..</span>
        <span class="s1">var_type = variable_type(data</span><span class="s0">, </span><span class="s1">boolean_type=</span><span class="s4">&quot;boolean&quot;</span><span class="s0">, </span><span class="s1">strict_boolean=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">var_type == </span><span class="s4">&quot;boolean&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Boolean(arg)</span>

        <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">, </span><span class="s1">list)):</span>
            <span class="s0">return </span><span class="s1">Nominal(arg)</span>

        <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s0">if </span><span class="s1">var_type == </span><span class="s4">&quot;categorical&quot;</span><span class="s1">:</span>
                <span class="s2"># TODO It seems reasonable to allow a gradient mapping for nominal</span>
                <span class="s2"># scale but it also feels &quot;technically&quot; wrong. Should this infer</span>
                <span class="s2"># Ordinal with categorical data and, if so, verify orderedness?</span>
                <span class="s0">return </span><span class="s1">Nominal(arg)</span>
            <span class="s0">return </span><span class="s1">Continuous(arg)</span>

        <span class="s0">if </span><span class="s1">callable(arg):</span>
            <span class="s0">return </span><span class="s1">Continuous(arg)</span>

        <span class="s2"># TODO Do we accept str like &quot;log&quot;, &quot;pow&quot;, etc. for semantics?</span>

        <span class="s0">if not </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">msg = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;A single scale argument for </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">variables must be&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;a string, dict, tuple, list, or callable, not </span><span class="s0">{</span><span class="s1">type(arg)</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s1">])</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s0">if </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">QUAL_PALETTES:</span>
            <span class="s0">return </span><span class="s1">Nominal(arg)</span>
        <span class="s0">elif </span><span class="s1">var_type == </span><span class="s4">&quot;numeric&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Continuous(arg)</span>
        <span class="s2"># TODO implement scales for date variables and any others.</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Nominal(arg)</span>

    <span class="s0">def </span><span class="s1">get_mapping(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>
        <span class="s3">&quot;&quot;&quot;Return a function that maps from data domain to color values.&quot;&quot;&quot;</span>
        <span class="s2"># TODO what is best way to do this conditional?</span>
        <span class="s2"># Should it be class-based or should classes have behavioral attributes?</span>
        <span class="s0">if </span><span class="s1">isinstance(scale</span><span class="s0">, </span><span class="s1">Nominal):</span>
            <span class="s0">return </span><span class="s1">self._get_nominal_mapping(scale</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s0">elif </span><span class="s1">isinstance(scale</span><span class="s0">, </span><span class="s1">Boolean):</span>
            <span class="s0">return </span><span class="s1">self._get_boolean_mapping(scale</span><span class="s0">, </span><span class="s1">data)</span>

        <span class="s0">if </span><span class="s1">scale.values </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s2"># TODO Rethink best default continuous color gradient</span>
            <span class="s1">mapping = color_palette(</span><span class="s4">&quot;ch:&quot;</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s2"># TODO blend_palette will strip alpha, but we should support</span>
            <span class="s2"># interpolation on all four channels</span>
            <span class="s1">mapping = blend_palette(scale.values</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s2"># TODO for matplotlib colormaps this will clip extremes, which is</span>
            <span class="s2"># different from what using the named colormap directly would do</span>
            <span class="s2"># This may or may not be desireable.</span>
            <span class="s1">mapping = color_palette(scale.values</span><span class="s0">, </span><span class="s1">as_cmap=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">callable(scale.values):</span>
            <span class="s1">mapping = scale.values</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">scale_class = scale.__class__.__name__</span>
            <span class="s1">msg = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;Scale values for </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">with a </span><span class="s0">{</span><span class="s1">scale_class</span><span class="s0">} </span><span class="s4">mapping&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;must be string, tuple, or callable; not </span><span class="s0">{</span><span class="s1">type(scale.values)</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s1">])</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s0">def </span><span class="s1">_mapping(x):</span>
            <span class="s2"># Remove alpha channel so it does not override alpha property downstream</span>
            <span class="s2"># TODO this will need to be more flexible to support RGBA tuples (see above)</span>
            <span class="s1">invalid = ~np.isfinite(x)</span>
            <span class="s1">out = mapping(x)[:</span><span class="s0">, </span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span>
            <span class="s1">out[invalid] = np.nan</span>
            <span class="s0">return </span><span class="s1">out</span>

        <span class="s0">return </span><span class="s1">_mapping</span>

    <span class="s0">def </span><span class="s1">_get_nominal_mapping(self</span><span class="s0">, </span><span class="s1">scale: Nominal</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>

        <span class="s1">levels = categorical_order(data</span><span class="s0">, </span><span class="s1">scale.order)</span>
        <span class="s1">colors = self._get_values(scale</span><span class="s0">, </span><span class="s1">levels)</span>

        <span class="s0">def </span><span class="s1">mapping(x):</span>
            <span class="s1">ixs = np.asarray(np.nan_to_num(x)</span><span class="s0">, </span><span class="s1">np.intp)</span>
            <span class="s1">use = np.isfinite(x)</span>
            <span class="s1">out = np.full((len(ixs)</span><span class="s0">, </span><span class="s1">colors.shape[</span><span class="s5">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">out[use] = np.take(colors</span><span class="s0">, </span><span class="s1">ixs[use]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">out</span>

        <span class="s0">return </span><span class="s1">mapping</span>

    <span class="s0">def </span><span class="s1">_get_boolean_mapping(self</span><span class="s0">, </span><span class="s1">scale: Boolean</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>

        <span class="s1">colors = self._get_values(scale</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>

        <span class="s0">def </span><span class="s1">mapping(x):</span>

            <span class="s1">use = np.isfinite(x)</span>
            <span class="s1">x = np.asarray(np.nan_to_num(x)).astype(bool)</span>
            <span class="s1">out = np.full((len(x)</span><span class="s0">, </span><span class="s1">colors.shape[</span><span class="s5">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">out[x &amp; use] = colors[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">out[~x &amp; use] = colors[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">out</span>

        <span class="s0">return </span><span class="s1">mapping</span>

    <span class="s0">def </span><span class="s1">_get_values(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">levels: list) -&gt; ArrayLike:</span>
        <span class="s3">&quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;</span>
        <span class="s1">n = len(levels)</span>
        <span class="s1">values = scale.values</span>
        <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">self._check_dict_entries(levels</span><span class="s0">, </span><span class="s1">values)</span>
            <span class="s1">colors = [values[x] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">levels]</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">colors = self._check_list_length(levels</span><span class="s0">, </span><span class="s1">values)</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">colors = blend_palette(values</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">colors = color_palette(values</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">elif </span><span class="s1">values </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">n &lt;= len(get_color_cycle()):</span>
                <span class="s2"># Use current (global) default palette</span>
                <span class="s1">colors = color_palette(n_colors=n)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">colors = color_palette(</span><span class="s4">&quot;husl&quot;</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">scale_class = scale.__class__.__name__</span>
            <span class="s1">msg = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;Scale values for </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">with a </span><span class="s0">{</span><span class="s1">scale_class</span><span class="s0">} </span><span class="s4">mapping&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;must be string, list, tuple, or dict; not </span><span class="s0">{</span><span class="s1">type(scale.values)</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s1">])</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s0">return </span><span class="s1">self._standardize_color_sequence(colors)</span>


<span class="s2"># =================================================================================== #</span>
<span class="s2"># Properties that can take only two states</span>
<span class="s2"># =================================================================================== #</span>


<span class="s0">class </span><span class="s1">Fill(Property):</span>
    <span class="s3">&quot;&quot;&quot;Boolean property of points/bars/patches that can be solid or outlined.&quot;&quot;&quot;</span>
    <span class="s1">legend = </span><span class="s0">True</span>
    <span class="s1">normed = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">default_scale(self</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Scale:</span>
        <span class="s1">var_type = variable_type(data</span><span class="s0">, </span><span class="s1">boolean_type=</span><span class="s4">&quot;boolean&quot;</span><span class="s0">, </span><span class="s1">strict_boolean=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">Boolean() </span><span class="s0">if </span><span class="s1">var_type == </span><span class="s4">&quot;boolean&quot; </span><span class="s0">else </span><span class="s1">Nominal()</span>

    <span class="s0">def </span><span class="s1">infer_scale(self</span><span class="s0">, </span><span class="s1">arg: Any</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Scale:</span>
        <span class="s1">var_type = variable_type(data</span><span class="s0">, </span><span class="s1">boolean_type=</span><span class="s4">&quot;boolean&quot;</span><span class="s0">, </span><span class="s1">strict_boolean=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">Boolean(arg) </span><span class="s0">if </span><span class="s1">var_type == </span><span class="s4">&quot;boolean&quot; </span><span class="s0">else </span><span class="s1">Nominal(arg)</span>

    <span class="s0">def </span><span class="s1">standardize(self</span><span class="s0">, </span><span class="s1">val: Any) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">bool(val)</span>

    <span class="s0">def </span><span class="s1">_default_values(self</span><span class="s0">, </span><span class="s1">n: int) -&gt; list:</span>
        <span class="s3">&quot;&quot;&quot;Return a list of n values, alternating True and False.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">n &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;The variable assigned to </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">has more than two levels,&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;so </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">values will cycle and may be uninterpretable&quot;</span><span class="s0">,</span>
            <span class="s1">])</span>
            <span class="s2"># TODO fire in a &quot;nice&quot; way (see above)</span>
            <span class="s1">warnings.warn(msg</span><span class="s0">, </span><span class="s1">UserWarning)</span>
        <span class="s0">return </span><span class="s1">[x </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">zip(itertools.cycle([</span><span class="s0">True, False</span><span class="s1">])</span><span class="s0">, </span><span class="s1">range(n))]</span>

    <span class="s0">def </span><span class="s1">get_mapping(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">data: Series) -&gt; Mapping:</span>
        <span class="s3">&quot;&quot;&quot;Return a function that maps each data value to True or False.&quot;&quot;&quot;</span>
        <span class="s1">boolean_scale = isinstance(scale</span><span class="s0">, </span><span class="s1">Boolean)</span>
        <span class="s1">order = getattr(scale</span><span class="s0">, </span><span class="s4">&quot;order&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">] </span><span class="s0">if </span><span class="s1">boolean_scale </span><span class="s0">else None</span><span class="s1">)</span>
        <span class="s1">levels = categorical_order(data</span><span class="s0">, </span><span class="s1">order)</span>
        <span class="s1">values = self._get_values(scale</span><span class="s0">, </span><span class="s1">levels)</span>

        <span class="s0">if </span><span class="s1">boolean_scale:</span>
            <span class="s1">values = values[::-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s0">def </span><span class="s1">mapping(x):</span>
            <span class="s1">ixs = np.asarray(np.nan_to_num(x)</span><span class="s0">, </span><span class="s1">np.intp)</span>
            <span class="s0">return </span><span class="s1">[</span>
                <span class="s1">values[ix] </span><span class="s0">if </span><span class="s1">np.isfinite(x_i) </span><span class="s0">else False</span>
                <span class="s0">for </span><span class="s1">x_i</span><span class="s0">, </span><span class="s1">ix </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">ixs)</span>
            <span class="s1">]</span>

        <span class="s0">return </span><span class="s1">mapping</span>

    <span class="s0">def </span><span class="s1">_get_values(self</span><span class="s0">, </span><span class="s1">scale: Scale</span><span class="s0">, </span><span class="s1">levels: list) -&gt; list:</span>
        <span class="s3">&quot;&quot;&quot;Validate scale.values and identify a value for each level.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">values = [bool(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">scale.values]</span>
        <span class="s0">elif </span><span class="s1">isinstance(scale.values</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">values = [bool(scale.values[x]) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">levels]</span>
        <span class="s0">elif </span><span class="s1">scale.values </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">values = self._default_values(len(levels))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
                <span class="s4">f&quot;Scale values for </span><span class="s0">{</span><span class="s1">self.variable</span><span class="s0">} </span><span class="s4">must be passed in&quot;</span><span class="s0">,</span>
                <span class="s4">f&quot;a list or dict; not </span><span class="s0">{</span><span class="s1">type(scale.values)</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s1">])</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s0">return </span><span class="s1">values</span>


<span class="s2"># =================================================================================== #</span>
<span class="s2"># Enumeration of properties for use by Plot and Mark classes</span>
<span class="s2"># =================================================================================== #</span>
<span class="s2"># TODO turn this into a property registry with hooks, etc.</span>
<span class="s2"># TODO Users do not interact directly with properties, so how to document them?</span>


<span class="s1">PROPERTY_CLASSES = {</span>
    <span class="s4">&quot;x&quot;</span><span class="s1">: Coordinate</span><span class="s0">,</span>
    <span class="s4">&quot;y&quot;</span><span class="s1">: Coordinate</span><span class="s0">,</span>
    <span class="s4">&quot;color&quot;</span><span class="s1">: Color</span><span class="s0">,</span>
    <span class="s4">&quot;alpha&quot;</span><span class="s1">: Alpha</span><span class="s0">,</span>
    <span class="s4">&quot;fill&quot;</span><span class="s1">: Fill</span><span class="s0">,</span>
    <span class="s4">&quot;marker&quot;</span><span class="s1">: Marker</span><span class="s0">,</span>
    <span class="s4">&quot;pointsize&quot;</span><span class="s1">: PointSize</span><span class="s0">,</span>
    <span class="s4">&quot;stroke&quot;</span><span class="s1">: Stroke</span><span class="s0">,</span>
    <span class="s4">&quot;linewidth&quot;</span><span class="s1">: LineWidth</span><span class="s0">,</span>
    <span class="s4">&quot;linestyle&quot;</span><span class="s1">: LineStyle</span><span class="s0">,</span>
    <span class="s4">&quot;fillcolor&quot;</span><span class="s1">: Color</span><span class="s0">,</span>
    <span class="s4">&quot;fillalpha&quot;</span><span class="s1">: Alpha</span><span class="s0">,</span>
    <span class="s4">&quot;edgewidth&quot;</span><span class="s1">: EdgeWidth</span><span class="s0">,</span>
    <span class="s4">&quot;edgestyle&quot;</span><span class="s1">: LineStyle</span><span class="s0">,</span>
    <span class="s4">&quot;edgecolor&quot;</span><span class="s1">: Color</span><span class="s0">,</span>
    <span class="s4">&quot;edgealpha&quot;</span><span class="s1">: Alpha</span><span class="s0">,</span>
    <span class="s4">&quot;text&quot;</span><span class="s1">: Property</span><span class="s0">,</span>
    <span class="s4">&quot;halign&quot;</span><span class="s1">: HorizontalAlignment</span><span class="s0">,</span>
    <span class="s4">&quot;valign&quot;</span><span class="s1">: VerticalAlignment</span><span class="s0">,</span>
    <span class="s4">&quot;offset&quot;</span><span class="s1">: Offset</span><span class="s0">,</span>
    <span class="s4">&quot;fontsize&quot;</span><span class="s1">: FontSize</span><span class="s0">,</span>
    <span class="s4">&quot;xmin&quot;</span><span class="s1">: Coordinate</span><span class="s0">,</span>
    <span class="s4">&quot;xmax&quot;</span><span class="s1">: Coordinate</span><span class="s0">,</span>
    <span class="s4">&quot;ymin&quot;</span><span class="s1">: Coordinate</span><span class="s0">,</span>
    <span class="s4">&quot;ymax&quot;</span><span class="s1">: Coordinate</span><span class="s0">,</span>
    <span class="s4">&quot;group&quot;</span><span class="s1">: Property</span><span class="s0">,</span>
    <span class="s2"># TODO pattern?</span>
    <span class="s2"># TODO gradient?</span>
<span class="s1">}</span>

<span class="s1">PROPERTIES = {var: cls(var) </span><span class="s0">for </span><span class="s1">var</span><span class="s0">, </span><span class="s1">cls </span><span class="s0">in </span><span class="s1">PROPERTY_CLASSES.items()}</span>
</pre>
</body>
</html>