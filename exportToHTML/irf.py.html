<html>
<head>
<title>irf.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
irf.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
Impulse reponse-related code 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">numpy.linalg </span><span class="s3">as </span><span class="s1">la</span>
<span class="s3">import </span><span class="s1">scipy.linalg </span><span class="s3">as </span><span class="s1">L</span>

<span class="s3">from </span><span class="s1">statsmodels.tools.decorators </span><span class="s3">import </span><span class="s1">cache_readonly</span>
<span class="s3">import </span><span class="s1">statsmodels.tsa.tsatools </span><span class="s3">as </span><span class="s1">tsa</span>
<span class="s3">import </span><span class="s1">statsmodels.tsa.vector_ar.plotting </span><span class="s3">as </span><span class="s1">plotting</span>
<span class="s3">import </span><span class="s1">statsmodels.tsa.vector_ar.util </span><span class="s3">as </span><span class="s1">util</span>

<span class="s1">mat = np.array</span>


<span class="s3">class </span><span class="s1">BaseIRAnalysis:</span>
    <span class="s2">&quot;&quot;&quot; 
    Base class for plotting and computing IRF-related statistics, want to be 
    able to handle known and estimated processes 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">P=</span><span class="s3">None, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None, </span><span class="s1">svar=</span><span class="s3">False,</span>
                 <span class="s1">vecm=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self.model = model</span>
        <span class="s1">self.periods = periods</span>
        <span class="s1">self.neqs</span><span class="s3">, </span><span class="s1">self.lags</span><span class="s3">, </span><span class="s1">self.T = model.neqs</span><span class="s3">, </span><span class="s1">model.k_ar</span><span class="s3">, </span><span class="s1">model.nobs</span>

        <span class="s1">self.order = order</span>

        <span class="s3">if </span><span class="s1">P </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">sigma = model.sigma_u</span>

            <span class="s0"># TODO, may be difficult at the moment</span>
            <span class="s0"># if order is not None:</span>
            <span class="s0">#     indexer = [model.get_eq_index(name) for name in order]</span>
            <span class="s0">#     sigma = sigma[:, indexer][indexer, :]</span>

            <span class="s0">#     if sigma.shape != model.sigma_u.shape:</span>
            <span class="s0">#         raise ValueError('variable order is wrong length')</span>

            <span class="s1">P = la.cholesky(sigma)</span>

        <span class="s1">self.P = P</span>

        <span class="s1">self.svar = svar</span>

        <span class="s1">self.irfs = model.ma_rep(periods)</span>
        <span class="s3">if </span><span class="s1">svar:</span>
            <span class="s1">self.svar_irfs = model.svar_ma_rep(periods</span><span class="s3">, </span><span class="s1">P=P)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.orth_irfs = model.orth_ma_rep(periods</span><span class="s3">, </span><span class="s1">P=P)</span>

        <span class="s1">self.cum_effects = self.irfs.cumsum(axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">svar:</span>
            <span class="s1">self.svar_cum_effects = self.svar_irfs.cumsum(axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.orth_cum_effects = self.orth_irfs.cumsum(axis=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># long-run effects may be infinite for VECMs.</span>
        <span class="s3">if not </span><span class="s1">vecm:</span>
            <span class="s1">self.lr_effects = model.long_run_effects()</span>
            <span class="s3">if </span><span class="s1">svar:</span>
                <span class="s1">self.svar_lr_effects = np.dot(model.long_run_effects()</span><span class="s3">, </span><span class="s1">P)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.orth_lr_effects = np.dot(model.long_run_effects()</span><span class="s3">, </span><span class="s1">P)</span>

        <span class="s0"># auxiliary stuff</span>
        <span class="s3">if </span><span class="s1">vecm:</span>
            <span class="s1">self._A = util.comp_matrix(model.var_rep)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._A = util.comp_matrix(model.coefs)</span>

    <span class="s3">def </span><span class="s1">_choose_irfs(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False, </span><span class="s1">svar=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">orth:</span>
            <span class="s3">return </span><span class="s1">self.orth_irfs</span>
        <span class="s3">elif </span><span class="s1">svar:</span>
            <span class="s3">return </span><span class="s1">self.svar_irfs</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.irfs</span>

    <span class="s3">def </span><span class="s1">cov(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">cum_effect_cov(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">plot(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">impulse=</span><span class="s3">None, </span><span class="s1">response=</span><span class="s3">None,</span>
             <span class="s1">signif=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">plot_params=</span><span class="s3">None, </span><span class="s1">figsize=(</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s1">subplot_params=</span><span class="s3">None, </span><span class="s1">plot_stderr=</span><span class="s3">True, </span><span class="s1">stderr_type=</span><span class="s5">'asym'</span><span class="s3">,</span>
             <span class="s1">repl=</span><span class="s4">1000</span><span class="s3">, </span><span class="s1">seed=</span><span class="s3">None, </span><span class="s1">component=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Plot impulse responses 
 
        Parameters 
        ---------- 
        orth : bool, default False 
            Compute orthogonalized impulse responses 
        impulse : {str, int} 
            variable providing the impulse 
        response : {str, int} 
            variable affected by the impulse 
        signif : float (0 &lt; signif &lt; 1) 
            Significance level for error bars, defaults to 95% CI 
        subplot_params : dict 
            To pass to subplot plotting funcions. Example: if fonts are too big, 
            pass {'fontsize' : 8} or some number to your taste. 
        plot_params : dict 
 
        figsize : (float, float), default (10, 10) 
            Figure size (width, height in inches) 
        plot_stderr : bool, default True 
            Plot standard impulse response error bands 
        stderr_type : str 
            'asym': default, computes asymptotic standard errors 
            'mc': monte carlo standard errors (use rpl) 
        repl : int, default 1000 
            Number of replications for Monte Carlo and Sims-Zha standard errors 
        seed : int 
            np.random.seed for Monte Carlo replications 
        component: array or vector of principal component indices 
        &quot;&quot;&quot;</span>
        <span class="s1">periods = self.periods</span>
        <span class="s1">model = self.model</span>
        <span class="s1">svar = self.svar</span>

        <span class="s3">if </span><span class="s1">orth </span><span class="s3">and </span><span class="s1">svar:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;For SVAR system, set orth=False&quot;</span><span class="s1">)</span>

        <span class="s1">irfs = self._choose_irfs(orth</span><span class="s3">, </span><span class="s1">svar)</span>
        <span class="s3">if </span><span class="s1">orth:</span>
            <span class="s1">title = </span><span class="s5">'Impulse responses (orthogonalized)'</span>
        <span class="s3">elif </span><span class="s1">svar:</span>
            <span class="s1">title = </span><span class="s5">'Impulse responses (structural)'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">title = </span><span class="s5">'Impulse responses'</span>

        <span class="s3">if </span><span class="s1">plot_stderr </span><span class="s3">is False</span><span class="s1">:</span>
            <span class="s1">stderr = </span><span class="s3">None</span>

        <span class="s3">elif </span><span class="s1">stderr_type </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'asym'</span><span class="s3">, </span><span class="s5">'mc'</span><span class="s3">, </span><span class="s5">'sz1'</span><span class="s3">, </span><span class="s5">'sz2'</span><span class="s3">,</span><span class="s5">'sz3'</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Error type must be either 'asym', 'mc','sz1','sz2', or 'sz3'&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">stderr_type == </span><span class="s5">'asym'</span><span class="s1">:</span>
                <span class="s1">stderr = self.cov(orth=orth)</span>
            <span class="s3">if </span><span class="s1">stderr_type == </span><span class="s5">'mc'</span><span class="s1">:</span>
                <span class="s1">stderr = self.errband_mc(orth=orth</span><span class="s3">, </span><span class="s1">svar=svar</span><span class="s3">,</span>
                                         <span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">signif=signif</span><span class="s3">,</span>
                                         <span class="s1">seed=seed)</span>
            <span class="s3">if </span><span class="s1">stderr_type == </span><span class="s5">'sz1'</span><span class="s1">:</span>
                <span class="s1">stderr = self.err_band_sz1(orth=orth</span><span class="s3">, </span><span class="s1">svar=svar</span><span class="s3">,</span>
                                           <span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">signif=signif</span><span class="s3">,</span>
                                           <span class="s1">seed=seed</span><span class="s3">,</span>
                                           <span class="s1">component=component)</span>
            <span class="s3">if </span><span class="s1">stderr_type == </span><span class="s5">'sz2'</span><span class="s1">:</span>
                <span class="s1">stderr = self.err_band_sz2(orth=orth</span><span class="s3">, </span><span class="s1">svar=svar</span><span class="s3">,</span>
                                           <span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">signif=signif</span><span class="s3">,</span>
                                           <span class="s1">seed=seed</span><span class="s3">,</span>
                                           <span class="s1">component=component)</span>
            <span class="s3">if </span><span class="s1">stderr_type == </span><span class="s5">'sz3'</span><span class="s1">:</span>
                <span class="s1">stderr = self.err_band_sz3(orth=orth</span><span class="s3">, </span><span class="s1">svar=svar</span><span class="s3">,</span>
                                           <span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">signif=signif</span><span class="s3">,</span>
                                           <span class="s1">seed=seed</span><span class="s3">,</span>
                                           <span class="s1">component=component)</span>

        <span class="s1">fig = plotting.irf_grid_plot(irfs</span><span class="s3">, </span><span class="s1">stderr</span><span class="s3">, </span><span class="s1">impulse</span><span class="s3">, </span><span class="s1">response</span><span class="s3">,</span>
                                     <span class="s1">self.model.names</span><span class="s3">, </span><span class="s1">title</span><span class="s3">, </span><span class="s1">signif=signif</span><span class="s3">,</span>
                                     <span class="s1">subplot_params=subplot_params</span><span class="s3">,</span>
                                     <span class="s1">plot_params=plot_params</span><span class="s3">,</span>
                                     <span class="s1">figsize=figsize</span><span class="s3">,</span>
                                     <span class="s1">stderr_type=stderr_type)</span>
        <span class="s3">return </span><span class="s1">fig</span>

    <span class="s3">def </span><span class="s1">plot_cum_effects(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">impulse=</span><span class="s3">None, </span><span class="s1">response=</span><span class="s3">None,</span>
                         <span class="s1">signif=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">plot_params=</span><span class="s3">None, </span><span class="s1">figsize=(</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)</span><span class="s3">,</span>
                         <span class="s1">subplot_params=</span><span class="s3">None, </span><span class="s1">plot_stderr=</span><span class="s3">True,</span>
                         <span class="s1">stderr_type=</span><span class="s5">'asym'</span><span class="s3">, </span><span class="s1">repl=</span><span class="s4">1000</span><span class="s3">, </span><span class="s1">seed=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Plot cumulative impulse response functions 
 
        Parameters 
        ---------- 
        orth : bool, default False 
            Compute orthogonalized impulse responses 
        impulse : {str, int} 
            variable providing the impulse 
        response : {str, int} 
            variable affected by the impulse 
        signif : float (0 &lt; signif &lt; 1) 
            Significance level for error bars, defaults to 95% CI 
        subplot_params : dict 
            To pass to subplot plotting funcions. Example: if fonts are too big, 
            pass {'fontsize' : 8} or some number to your taste. 
        plot_params : dict 
 
        figsize: (float, float), default (10, 10) 
            Figure size (width, height in inches) 
        plot_stderr : bool, default True 
            Plot standard impulse response error bands 
        stderr_type : str 
            'asym': default, computes asymptotic standard errors 
            'mc': monte carlo standard errors (use rpl) 
        repl : int, default 1000 
            Number of replications for monte carlo standard errors 
        seed : int 
            np.random.seed for Monte Carlo replications 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">orth:</span>
            <span class="s1">title = </span><span class="s5">'Cumulative responses responses (orthogonalized)'</span>
            <span class="s1">cum_effects = self.orth_cum_effects</span>
            <span class="s1">lr_effects = self.orth_lr_effects</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">title = </span><span class="s5">'Cumulative responses'</span>
            <span class="s1">cum_effects = self.cum_effects</span>
            <span class="s1">lr_effects = self.lr_effects</span>

        <span class="s3">if </span><span class="s1">stderr_type </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'asym'</span><span class="s3">, </span><span class="s5">'mc'</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;`stderr_type` must be one of 'asym', 'mc'&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">stderr_type == </span><span class="s5">'asym'</span><span class="s1">:</span>
                <span class="s1">stderr = self.cum_effect_cov(orth=orth)</span>
            <span class="s3">if </span><span class="s1">stderr_type == </span><span class="s5">'mc'</span><span class="s1">:</span>
                <span class="s1">stderr = self.cum_errband_mc(orth=orth</span><span class="s3">, </span><span class="s1">repl=repl</span><span class="s3">,</span>
                                             <span class="s1">signif=signif</span><span class="s3">, </span><span class="s1">seed=seed)</span>
        <span class="s3">if not </span><span class="s1">plot_stderr:</span>
            <span class="s1">stderr = </span><span class="s3">None</span>

        <span class="s1">fig = plotting.irf_grid_plot(cum_effects</span><span class="s3">, </span><span class="s1">stderr</span><span class="s3">, </span><span class="s1">impulse</span><span class="s3">, </span><span class="s1">response</span><span class="s3">,</span>
                                     <span class="s1">self.model.names</span><span class="s3">, </span><span class="s1">title</span><span class="s3">, </span><span class="s1">signif=signif</span><span class="s3">,</span>
                                     <span class="s1">hlines=lr_effects</span><span class="s3">,</span>
                                     <span class="s1">subplot_params=subplot_params</span><span class="s3">,</span>
                                     <span class="s1">plot_params=plot_params</span><span class="s3">,</span>
                                     <span class="s1">figsize=figsize</span><span class="s3">,</span>
                                     <span class="s1">stderr_type=stderr_type)</span>
        <span class="s3">return </span><span class="s1">fig</span>


<span class="s3">class </span><span class="s1">IRAnalysis(BaseIRAnalysis):</span>
    <span class="s2">&quot;&quot;&quot; 
    Impulse response analysis class. Computes impulse responses, asymptotic 
    standard errors, and produces relevant plots 
 
    Parameters 
    ---------- 
    model : VAR instance 
 
    Notes 
    ----- 
    Using Lütkepohl (2005) notation 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">P=</span><span class="s3">None, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None, </span><span class="s1">svar=</span><span class="s3">False,</span>
                 <span class="s1">vecm=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">BaseIRAnalysis.__init__(self</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">P=P</span><span class="s3">, </span><span class="s1">periods=periods</span><span class="s3">,</span>
                                <span class="s1">order=order</span><span class="s3">, </span><span class="s1">svar=svar</span><span class="s3">, </span><span class="s1">vecm=vecm)</span>

        <span class="s3">if </span><span class="s1">vecm:</span>
            <span class="s1">self.cov_a = model.cov_var_repr</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.cov_a = model._cov_alpha</span>
        <span class="s1">self.cov_sig = model._cov_sigma</span>

        <span class="s0"># memoize dict for G matrix function</span>
        <span class="s1">self._g_memo = {}</span>

    <span class="s3">def </span><span class="s1">cov(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Compute asymptotic standard errors for impulse response coefficients 
 
        Notes 
        ----- 
        Lütkepohl eq 3.7.5 
 
        Returns 
        ------- 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">orth:</span>
            <span class="s3">return </span><span class="s1">self._orth_cov()</span>

        <span class="s1">covs = self._empty_covm(self.periods + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">covs[</span><span class="s4">0</span><span class="s1">] = np.zeros((self.neqs ** </span><span class="s4">2</span><span class="s3">, </span><span class="s1">self.neqs ** </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.periods + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">Gi = self.G[i - </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">covs[i] = Gi @ self.cov_a @ Gi.T</span>

        <span class="s3">return </span><span class="s1">covs</span>

    <span class="s3">def </span><span class="s1">errband_mc(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False, </span><span class="s1">svar=</span><span class="s3">False, </span><span class="s1">repl=</span><span class="s4">1000</span><span class="s3">,</span>
                   <span class="s1">signif=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">seed=</span><span class="s3">None, </span><span class="s1">burn=</span><span class="s4">100</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        IRF Monte Carlo integrated error bands 
        &quot;&quot;&quot;</span>
        <span class="s1">model = self.model</span>
        <span class="s1">periods = self.periods</span>
        <span class="s3">if </span><span class="s1">svar:</span>
            <span class="s3">return </span><span class="s1">model.sirf_errband_mc(orth=orth</span><span class="s3">, </span><span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">steps=periods</span><span class="s3">,</span>
                                         <span class="s1">signif=signif</span><span class="s3">, </span><span class="s1">seed=seed</span><span class="s3">,</span>
                                         <span class="s1">burn=burn</span><span class="s3">, </span><span class="s1">cum=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">model.irf_errband_mc(orth=orth</span><span class="s3">, </span><span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">steps=periods</span><span class="s3">,</span>
                                        <span class="s1">signif=signif</span><span class="s3">, </span><span class="s1">seed=seed</span><span class="s3">,</span>
                                        <span class="s1">burn=burn</span><span class="s3">, </span><span class="s1">cum=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">err_band_sz1(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False, </span><span class="s1">svar=</span><span class="s3">False, </span><span class="s1">repl=</span><span class="s4">1000</span><span class="s3">,</span>
                     <span class="s1">signif=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">seed=</span><span class="s3">None, </span><span class="s1">burn=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">component=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        IRF Sims-Zha error band method 1. Assumes symmetric error bands around 
        mean. 
 
        Parameters 
        ---------- 
        orth : bool, default False 
            Compute orthogonalized impulse responses 
        repl : int, default 1000 
            Number of MC replications 
        signif : float (0 &lt; signif &lt; 1) 
            Significance level for error bars, defaults to 95% CI 
        seed : int, default None 
            np.random seed 
        burn : int, default 100 
            Number of initial simulated obs to discard 
        component : neqs x neqs array, default to largest for each 
            Index of column of eigenvector/value to use for each error band 
            Note: period of impulse (t=0) is not included when computing 
            principle component 
 
        References 
        ---------- 
        Sims, Christopher A., and Tao Zha. 1999. &quot;Error Bands for Impulse 
        Response&quot;. Econometrica 67: 1113-1155. 
        &quot;&quot;&quot;</span>

        <span class="s1">model = self.model</span>
        <span class="s1">periods = self.periods</span>
        <span class="s1">irfs = self._choose_irfs(orth</span><span class="s3">, </span><span class="s1">svar)</span>
        <span class="s1">neqs = self.neqs</span>
        <span class="s1">irf_resim = model.irf_resim(orth=orth</span><span class="s3">, </span><span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">steps=periods</span><span class="s3">,</span>
                                    <span class="s1">seed=seed</span><span class="s3">, </span><span class="s1">burn=burn)</span>
        <span class="s1">q = util.norm_signif_level(signif)</span>

        <span class="s1">W</span><span class="s3">, </span><span class="s1">eigva</span><span class="s3">, </span><span class="s1">k =self._eigval_decomp_SZ(irf_resim)</span>

        <span class="s3">if </span><span class="s1">component </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">np.shape(component) != (neqs</span><span class="s3">,</span><span class="s1">neqs):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Component array must be &quot; </span><span class="s1">+ str(neqs) + </span><span class="s5">&quot; x &quot; </span><span class="s1">+ str(neqs))</span>
            <span class="s3">if </span><span class="s1">np.argmax(component) &gt;= neqs*periods:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Atleast one of the components does not exist&quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">k = component</span>

        <span class="s0"># here take the kth column of W, which we determine by finding the largest eigenvalue of the covaraince matrix</span>
        <span class="s1">lower = np.copy(irfs)</span>
        <span class="s1">upper = np.copy(irfs)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                <span class="s1">lower[</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = irfs[</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] + W[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">k[i</span><span class="s3">,</span><span class="s1">j]]*q*np.sqrt(eigva[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">k[i</span><span class="s3">,</span><span class="s1">j]])</span>
                <span class="s1">upper[</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = irfs[</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] - W[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">k[i</span><span class="s3">,</span><span class="s1">j]]*q*np.sqrt(eigva[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">k[i</span><span class="s3">,</span><span class="s1">j]])</span>

        <span class="s3">return </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span>

    <span class="s3">def </span><span class="s1">err_band_sz2(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False, </span><span class="s1">svar=</span><span class="s3">False, </span><span class="s1">repl=</span><span class="s4">1000</span><span class="s3">, </span><span class="s1">signif=</span><span class="s4">0.05</span><span class="s3">,</span>
                     <span class="s1">seed=</span><span class="s3">None, </span><span class="s1">burn=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">component=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        IRF Sims-Zha error band method 2. 
 
        This method Does not assume symmetric error bands around mean. 
 
        Parameters 
        ---------- 
        orth : bool, default False 
            Compute orthogonalized impulse responses 
        repl : int, default 1000 
            Number of MC replications 
        signif : float (0 &lt; signif &lt; 1) 
            Significance level for error bars, defaults to 95% CI 
        seed : int, default None 
            np.random seed 
        burn : int, default 100 
            Number of initial simulated obs to discard 
        component : neqs x neqs array, default to largest for each 
            Index of column of eigenvector/value to use for each error band 
            Note: period of impulse (t=0) is not included when computing 
            principle component 
 
        References 
        ---------- 
        Sims, Christopher A., and Tao Zha. 1999. &quot;Error Bands for Impulse 
        Response&quot;. Econometrica 67: 1113-1155. 
        &quot;&quot;&quot;</span>
        <span class="s1">model = self.model</span>
        <span class="s1">periods = self.periods</span>
        <span class="s1">irfs = self._choose_irfs(orth</span><span class="s3">, </span><span class="s1">svar)</span>
        <span class="s1">neqs = self.neqs</span>
        <span class="s1">irf_resim = model.irf_resim(orth=orth</span><span class="s3">, </span><span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">steps=periods</span><span class="s3">, </span><span class="s1">seed=seed</span><span class="s3">,</span>
                                    <span class="s1">burn=</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s1">W</span><span class="s3">, </span><span class="s1">eigva</span><span class="s3">, </span><span class="s1">k = self._eigval_decomp_SZ(irf_resim)</span>

        <span class="s3">if </span><span class="s1">component </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">np.shape(component) != (neqs</span><span class="s3">,</span><span class="s1">neqs):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Component array must be &quot; </span><span class="s1">+ str(neqs) + </span><span class="s5">&quot; x &quot; </span><span class="s1">+ str(neqs))</span>
            <span class="s3">if </span><span class="s1">np.argmax(component) &gt;= neqs*periods:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Atleast one of the components does not exist&quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">k = component</span>

        <span class="s1">gamma = np.zeros((repl</span><span class="s3">, </span><span class="s1">periods+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">neqs</span><span class="s3">, </span><span class="s1">neqs))</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">range(repl):</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                    <span class="s1">gamma[p</span><span class="s3">,</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = W[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">k[i</span><span class="s3">,</span><span class="s1">j]</span><span class="s3">,</span><span class="s1">:] * irf_resim[p</span><span class="s3">,</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j]</span>

        <span class="s1">gamma_sort = np.sort(gamma</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">) </span><span class="s0">#sort to get quantiles</span>
        <span class="s1">indx = round(signif/</span><span class="s4">2</span><span class="s1">*repl)-</span><span class="s4">1</span><span class="s3">,</span><span class="s1">round((</span><span class="s4">1</span><span class="s1">-signif/</span><span class="s4">2</span><span class="s1">)*repl)-</span><span class="s4">1</span>

        <span class="s1">lower = np.copy(irfs)</span>
        <span class="s1">upper = np.copy(irfs)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                <span class="s1">lower[:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = irfs[:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] + gamma_sort[indx[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j]</span>
                <span class="s1">upper[:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = irfs[:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] + gamma_sort[indx[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j]</span>

        <span class="s3">return </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span>

    <span class="s3">def </span><span class="s1">err_band_sz3(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False, </span><span class="s1">svar=</span><span class="s3">False, </span><span class="s1">repl=</span><span class="s4">1000</span><span class="s3">, </span><span class="s1">signif=</span><span class="s4">0.05</span><span class="s3">,</span>
                     <span class="s1">seed=</span><span class="s3">None, </span><span class="s1">burn=</span><span class="s4">100</span><span class="s3">, </span><span class="s1">component=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        IRF Sims-Zha error band method 3. Does not assume symmetric error bands around mean. 
 
        Parameters 
        ---------- 
        orth : bool, default False 
            Compute orthogonalized impulse responses 
        repl : int, default 1000 
            Number of MC replications 
        signif : float (0 &lt; signif &lt; 1) 
            Significance level for error bars, defaults to 95% CI 
        seed : int, default None 
            np.random seed 
        burn : int, default 100 
            Number of initial simulated obs to discard 
        component : vector length neqs, default to largest for each 
            Index of column of eigenvector/value to use for each error band 
            Note: period of impulse (t=0) is not included when computing 
            principle component 
 
        References 
        ---------- 
        Sims, Christopher A., and Tao Zha. 1999. &quot;Error Bands for Impulse 
        Response&quot;. Econometrica 67: 1113-1155. 
        &quot;&quot;&quot;</span>

        <span class="s1">model = self.model</span>
        <span class="s1">periods = self.periods</span>
        <span class="s1">irfs = self._choose_irfs(orth</span><span class="s3">, </span><span class="s1">svar)</span>
        <span class="s1">neqs = self.neqs</span>
        <span class="s1">irf_resim = model.irf_resim(orth=orth</span><span class="s3">, </span><span class="s1">repl=repl</span><span class="s3">, </span><span class="s1">steps=periods</span><span class="s3">,</span>
                                    <span class="s1">seed=seed</span><span class="s3">, </span><span class="s1">burn=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">stack = np.zeros((neqs</span><span class="s3">, </span><span class="s1">repl</span><span class="s3">, </span><span class="s1">periods*neqs))</span>

        <span class="s0">#stack left to right, up and down</span>

        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">range(repl):</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                <span class="s1">stack[i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">,</span><span class="s1">:] = np.ravel(irf_resim[p</span><span class="s3">,</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i].T)</span>

        <span class="s1">stack_cov=np.zeros((neqs</span><span class="s3">, </span><span class="s1">periods*neqs</span><span class="s3">, </span><span class="s1">periods*neqs))</span>
        <span class="s1">W = np.zeros((neqs</span><span class="s3">, </span><span class="s1">periods*neqs</span><span class="s3">, </span><span class="s1">periods*neqs))</span>
        <span class="s1">eigva = np.zeros((neqs</span><span class="s3">, </span><span class="s1">periods*neqs))</span>
        <span class="s1">k = np.zeros(neqs</span><span class="s3">, </span><span class="s1">dtype=int)</span>

        <span class="s3">if </span><span class="s1">component </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">np.size(component) != (neqs):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Component array must be of length &quot; </span><span class="s1">+ str(neqs))</span>
            <span class="s3">if </span><span class="s1">np.argmax(component) &gt;= neqs*periods:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Atleast one of the components does not exist&quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">k = component</span>

        <span class="s0">#compute for eigen decomp for each stack</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
            <span class="s1">stack_cov[i] = np.cov(stack[i]</span><span class="s3">,</span><span class="s1">rowvar=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">W[i]</span><span class="s3">, </span><span class="s1">eigva[i]</span><span class="s3">, </span><span class="s1">k[i] = util.eigval_decomp(stack_cov[i])</span>

        <span class="s1">gamma = np.zeros((repl</span><span class="s3">, </span><span class="s1">periods+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">neqs</span><span class="s3">, </span><span class="s1">neqs))</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">range(repl):</span>
            <span class="s1">c = </span><span class="s4">0</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                    <span class="s1">gamma[p</span><span class="s3">,</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = W[j</span><span class="s3">,</span><span class="s1">k[j]</span><span class="s3">,</span><span class="s1">i*periods:(i+</span><span class="s4">1</span><span class="s1">)*periods] * irf_resim[p</span><span class="s3">,</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j]</span>
                    <span class="s3">if </span><span class="s1">i == neqs-</span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s1">gamma[p</span><span class="s3">,</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = W[j</span><span class="s3">,</span><span class="s1">k[j]</span><span class="s3">,</span><span class="s1">i*periods:] * irf_resim[p</span><span class="s3">,</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j]</span>

        <span class="s1">gamma_sort = np.sort(gamma</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">) </span><span class="s0">#sort to get quantiles</span>
        <span class="s1">indx = round(signif/</span><span class="s4">2</span><span class="s1">*repl)-</span><span class="s4">1</span><span class="s3">,</span><span class="s1">round((</span><span class="s4">1</span><span class="s1">-signif/</span><span class="s4">2</span><span class="s1">)*repl)-</span><span class="s4">1</span>

        <span class="s1">lower = np.copy(irfs)</span>
        <span class="s1">upper = np.copy(irfs)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                <span class="s1">lower[:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = irfs[:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] + gamma_sort[indx[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j]</span>
                <span class="s1">upper[:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] = irfs[:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j] + gamma_sort[indx[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j]</span>

        <span class="s3">return </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">upper</span>

    <span class="s3">def </span><span class="s1">_eigval_decomp_SZ(self</span><span class="s3">, </span><span class="s1">irf_resim):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        W: array of eigenvectors 
        eigva: list of eigenvalues 
        k: matrix indicating column # of largest eigenvalue for each c_i,j 
        &quot;&quot;&quot;</span>
        <span class="s1">neqs = self.neqs</span>
        <span class="s1">periods = self.periods</span>

        <span class="s1">cov_hold = np.zeros((neqs</span><span class="s3">, </span><span class="s1">neqs</span><span class="s3">, </span><span class="s1">periods</span><span class="s3">, </span><span class="s1">periods))</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                <span class="s1">cov_hold[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:] = np.cov(irf_resim[:</span><span class="s3">,</span><span class="s4">1</span><span class="s1">:</span><span class="s3">,</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j]</span><span class="s3">,</span><span class="s1">rowvar=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">W = np.zeros((neqs</span><span class="s3">, </span><span class="s1">neqs</span><span class="s3">, </span><span class="s1">periods</span><span class="s3">, </span><span class="s1">periods))</span>
        <span class="s1">eigva = np.zeros((neqs</span><span class="s3">, </span><span class="s1">neqs</span><span class="s3">, </span><span class="s1">periods</span><span class="s3">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">k = np.zeros((neqs</span><span class="s3">, </span><span class="s1">neqs)</span><span class="s3">, </span><span class="s1">dtype=int)</span>

        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(neqs):</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(neqs):</span>
                <span class="s1">W[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">eigva[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">k[i</span><span class="s3">,</span><span class="s1">j] = util.eigval_decomp(cov_hold[i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:])</span>
        <span class="s3">return </span><span class="s1">W</span><span class="s3">, </span><span class="s1">eigva</span><span class="s3">, </span><span class="s1">k</span>

    <span class="s1">@cache_readonly</span>
    <span class="s3">def </span><span class="s1">G(self):</span>
        <span class="s0"># Gi matrices as defined on p. 111</span>

        <span class="s1">K = self.neqs</span>

        <span class="s0"># nlags = self.model.p</span>
        <span class="s0"># J = np.hstack((np.eye(K),) + (np.zeros((K, K)),) * (nlags - 1))</span>

        <span class="s3">def </span><span class="s1">_make_g(i):</span>
            <span class="s0"># p. 111 Lutkepohl</span>
            <span class="s1">G = </span><span class="s4">0.</span>
            <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">range(i):</span>
                <span class="s0"># be a bit cute to go faster</span>
                <span class="s1">idx = i - </span><span class="s4">1 </span><span class="s1">- m</span>
                <span class="s3">if </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">self._g_memo:</span>
                    <span class="s1">apow = self._g_memo[idx]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">apow = la.matrix_power(self._A.T</span><span class="s3">, </span><span class="s1">idx)</span>
                    <span class="s0"># apow = np.dot(J, apow)</span>
                    <span class="s1">apow = apow[:K]</span>
                    <span class="s1">self._g_memo[idx] = apow</span>

                <span class="s0"># take first K rows</span>
                <span class="s1">piece = np.kron(apow</span><span class="s3">, </span><span class="s1">self.irfs[m])</span>
                <span class="s1">G = G + piece</span>

            <span class="s3">return </span><span class="s1">G</span>

        <span class="s3">return </span><span class="s1">[_make_g(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.periods + </span><span class="s4">1</span><span class="s1">)]</span>

    <span class="s3">def </span><span class="s1">_orth_cov(self):</span>
        <span class="s0"># Lutkepohl 3.7.8</span>

        <span class="s1">Ik = np.eye(self.neqs)</span>
        <span class="s1">PIk = np.kron(self.P.T</span><span class="s3">, </span><span class="s1">Ik)</span>
        <span class="s1">H = self.H</span>

        <span class="s1">covs = self._empty_covm(self.periods + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.periods + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">apiece = </span><span class="s4">0</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">Ci = np.dot(PIk</span><span class="s3">, </span><span class="s1">self.G[i-</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">apiece = Ci @ self.cov_a @ Ci.T</span>

            <span class="s1">Cibar = np.dot(np.kron(Ik</span><span class="s3">, </span><span class="s1">self.irfs[i])</span><span class="s3">, </span><span class="s1">H)</span>
            <span class="s1">bpiece = (Cibar @ self.cov_sig @ Cibar.T) / self.T</span>

            <span class="s0"># Lutkepohl typo, cov_sig correct</span>
            <span class="s1">covs[i] = apiece + bpiece</span>

        <span class="s3">return </span><span class="s1">covs</span>

    <span class="s3">def </span><span class="s1">cum_effect_cov(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Compute asymptotic standard errors for cumulative impulse response 
        coefficients 
 
        Parameters 
        ---------- 
        orth : bool 
 
        Notes 
        ----- 
        eq. 3.7.7 (non-orth), 3.7.10 (orth) 
 
        Returns 
        ------- 
        &quot;&quot;&quot;</span>
        <span class="s1">Ik = np.eye(self.neqs)</span>
        <span class="s1">PIk = np.kron(self.P.T</span><span class="s3">, </span><span class="s1">Ik)</span>

        <span class="s1">F = </span><span class="s4">0.</span>
        <span class="s1">covs = self._empty_covm(self.periods + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.periods + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">i &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">F = F + self.G[i - </span><span class="s4">1</span><span class="s1">]</span>

            <span class="s3">if </span><span class="s1">orth:</span>
                <span class="s3">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">apiece = </span><span class="s4">0</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">Bn = np.dot(PIk</span><span class="s3">, </span><span class="s1">F)</span>
                    <span class="s1">apiece = Bn @ self.cov_a @ Bn.T</span>

                <span class="s1">Bnbar = np.dot(np.kron(Ik</span><span class="s3">, </span><span class="s1">self.cum_effects[i])</span><span class="s3">, </span><span class="s1">self.H)</span>
                <span class="s1">bpiece = (Bnbar @ self.cov_sig @ Bnbar.T) / self.T</span>

                <span class="s1">covs[i] = apiece + bpiece</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">covs[i] = np.zeros((self.neqs**</span><span class="s4">2</span><span class="s3">, </span><span class="s1">self.neqs**</span><span class="s4">2</span><span class="s1">))</span>
                    <span class="s3">continue</span>

                <span class="s1">covs[i] = F @ self.cov_a @ F.T</span>

        <span class="s3">return </span><span class="s1">covs</span>

    <span class="s3">def </span><span class="s1">cum_errband_mc(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False, </span><span class="s1">repl=</span><span class="s4">1000</span><span class="s3">,</span>
                       <span class="s1">signif=</span><span class="s4">0.05</span><span class="s3">, </span><span class="s1">seed=</span><span class="s3">None, </span><span class="s1">burn=</span><span class="s4">100</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        IRF Monte Carlo integrated error bands of cumulative effect 
        &quot;&quot;&quot;</span>
        <span class="s1">model = self.model</span>
        <span class="s1">periods = self.periods</span>
        <span class="s3">return </span><span class="s1">model.irf_errband_mc(orth=orth</span><span class="s3">, </span><span class="s1">repl=repl</span><span class="s3">,</span>
                                    <span class="s1">steps=periods</span><span class="s3">, </span><span class="s1">signif=signif</span><span class="s3">,</span>
                                    <span class="s1">seed=seed</span><span class="s3">, </span><span class="s1">burn=burn</span><span class="s3">, </span><span class="s1">cum=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">lr_effect_cov(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        &quot;&quot;&quot;</span>
        <span class="s1">lre = self.lr_effects</span>
        <span class="s1">Finfty = np.kron(np.tile(lre.T</span><span class="s3">, </span><span class="s1">self.lags)</span><span class="s3">, </span><span class="s1">lre)</span>
        <span class="s1">Ik = np.eye(self.neqs)</span>

        <span class="s3">if </span><span class="s1">orth:</span>
            <span class="s1">Binf = np.dot(np.kron(self.P.T</span><span class="s3">, </span><span class="s1">np.eye(self.neqs))</span><span class="s3">, </span><span class="s1">Finfty)</span>
            <span class="s1">Binfbar = np.dot(np.kron(Ik</span><span class="s3">, </span><span class="s1">lre)</span><span class="s3">, </span><span class="s1">self.H)</span>

            <span class="s3">return </span><span class="s1">(Binf @ self.cov_a @ Binf.T +</span>
                    <span class="s1">Binfbar @ self.cov_sig @ Binfbar.T)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">Finfty @ self.cov_a @ Finfty.T</span>

    <span class="s3">def </span><span class="s1">stderr(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">np.array([tsa.unvec(np.sqrt(np.diag(c)))</span>
                         <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.cov(orth=orth)])</span>

    <span class="s3">def </span><span class="s1">cum_effect_stderr(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">np.array([tsa.unvec(np.sqrt(np.diag(c)))</span>
                         <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.cum_effect_cov(orth=orth)])</span>

    <span class="s3">def </span><span class="s1">lr_effect_stderr(self</span><span class="s3">, </span><span class="s1">orth=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">cov = self.lr_effect_cov(orth=orth)</span>
        <span class="s3">return </span><span class="s1">tsa.unvec(np.sqrt(np.diag(cov)))</span>

    <span class="s3">def </span><span class="s1">_empty_covm(self</span><span class="s3">, </span><span class="s1">periods):</span>
        <span class="s3">return </span><span class="s1">np.zeros((periods</span><span class="s3">, </span><span class="s1">self.neqs ** </span><span class="s4">2</span><span class="s3">, </span><span class="s1">self.neqs ** </span><span class="s4">2</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">dtype=float)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s3">def </span><span class="s1">H(self):</span>
        <span class="s1">k = self.neqs</span>
        <span class="s1">Lk = tsa.elimination_matrix(k)</span>
        <span class="s1">Kkk = tsa.commutation_matrix(k</span><span class="s3">, </span><span class="s1">k)</span>
        <span class="s1">Ik = np.eye(k)</span>

        <span class="s0"># B = Lk @ (np.eye(k**2) + commutation_matrix(k, k)) @ \</span>
        <span class="s0">#     np.kron(self.P, np.eye(k)) @ Lk.T</span>
        <span class="s0"># return Lk.T @ L.inv(B)</span>

        <span class="s1">B = Lk @ (np.kron(Ik</span><span class="s3">, </span><span class="s1">self.P) @ Kkk + np.kron(self.P</span><span class="s3">, </span><span class="s1">Ik)) @ Lk.T</span>

        <span class="s3">return </span><span class="s1">np.dot(Lk.T</span><span class="s3">, </span><span class="s1">L.inv(B))</span>

    <span class="s3">def </span><span class="s1">fevd_table(self):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>
</pre>
</body>
</html>