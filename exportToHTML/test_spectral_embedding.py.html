<html>
<head>
<title>test_spectral_embedding.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_spectral_embedding.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">unittest.mock </span><span class="s0">import </span><span class="s1">Mock</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">sparse</span>
<span class="s0">from </span><span class="s1">scipy.linalg </span><span class="s0">import </span><span class="s1">eigh</span>
<span class="s0">from </span><span class="s1">scipy.sparse </span><span class="s0">import </span><span class="s1">csgraph</span>
<span class="s0">from </span><span class="s1">scipy.sparse.linalg </span><span class="s0">import </span><span class="s1">eigsh</span><span class="s0">, </span><span class="s1">lobpcg</span>

<span class="s0">from </span><span class="s1">sklearn.cluster </span><span class="s0">import </span><span class="s1">KMeans</span>
<span class="s0">from </span><span class="s1">sklearn.datasets </span><span class="s0">import </span><span class="s1">make_blobs</span>
<span class="s0">from </span><span class="s1">sklearn.manifold </span><span class="s0">import </span><span class="s1">SpectralEmbedding</span><span class="s0">, </span><span class="s1">_spectral_embedding</span><span class="s0">, </span><span class="s1">spectral_embedding</span>
<span class="s0">from </span><span class="s1">sklearn.manifold._spectral_embedding </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_graph_connected_component</span><span class="s0">,</span>
    <span class="s1">_graph_is_connected</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.metrics </span><span class="s0">import </span><span class="s1">normalized_mutual_info_score</span><span class="s0">, </span><span class="s1">pairwise_distances</span>
<span class="s0">from </span><span class="s1">sklearn.metrics.pairwise </span><span class="s0">import </span><span class="s1">rbf_kernel</span>
<span class="s0">from </span><span class="s1">sklearn.neighbors </span><span class="s0">import </span><span class="s1">NearestNeighbors</span>
<span class="s0">from </span><span class="s1">sklearn.utils._testing </span><span class="s0">import </span><span class="s1">assert_array_almost_equal</span><span class="s0">, </span><span class="s1">assert_array_equal</span>
<span class="s0">from </span><span class="s1">sklearn.utils.extmath </span><span class="s0">import </span><span class="s1">_deterministic_vector_sign_flip</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">pyamg </span><span class="s0">import </span><span class="s1">smoothed_aggregation_solver  </span><span class="s2"># noqa</span>

    <span class="s1">pyamg_available = </span><span class="s0">True</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s1">pyamg_available = </span><span class="s0">False</span>
<span class="s1">skip_if_no_pyamg = pytest.mark.skipif(</span>
    <span class="s0">not </span><span class="s1">pyamg_available</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;PyAMG is required for the tests in this function.&quot;</span>
<span class="s1">)</span>

<span class="s2"># non centered, sparse centers to check the</span>
<span class="s1">centers = np.array(</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">n_samples = </span><span class="s4">1000</span>
<span class="s1">n_clusters</span><span class="s0">, </span><span class="s1">n_features = centers.shape</span>
<span class="s1">S</span><span class="s0">, </span><span class="s1">true_labels = make_blobs(</span>
    <span class="s1">n_samples=n_samples</span><span class="s0">, </span><span class="s1">centers=centers</span><span class="s0">, </span><span class="s1">cluster_std=</span><span class="s4">1.0</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">42</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">_assert_equal_with_sign_flipping(A</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">0.0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Check array A and B are equal with possible sign flipping on 
    each columns&quot;&quot;&quot;</span>
    <span class="s1">tol_squared = tol**</span><span class="s4">2</span>
    <span class="s0">for </span><span class="s1">A_col</span><span class="s0">, </span><span class="s1">B_col </span><span class="s0">in </span><span class="s1">zip(A.T</span><span class="s0">, </span><span class="s1">B.T):</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">np.max((A_col - B_col) ** </span><span class="s4">2</span><span class="s1">) &lt;= tol_squared</span>
            <span class="s0">or </span><span class="s1">np.max((A_col + B_col) ** </span><span class="s4">2</span><span class="s1">) &lt;= tol_squared</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_sparse_graph_connected_component():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s1">n_samples = </span><span class="s4">300</span>
    <span class="s1">boundaries = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">42</span><span class="s0">, </span><span class="s4">121</span><span class="s0">, </span><span class="s4">200</span><span class="s0">, </span><span class="s1">n_samples]</span>
    <span class="s1">p = rng.permutation(n_samples)</span>
    <span class="s1">connections = []</span>

    <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop </span><span class="s0">in </span><span class="s1">zip(boundaries[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">boundaries[</span><span class="s4">1</span><span class="s1">:]):</span>
        <span class="s1">group = p[start:stop]</span>
        <span class="s2"># Connect all elements within the group at least once via an</span>
        <span class="s2"># arbitrary path that spans the group.</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(group) - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">connections.append((group[i]</span><span class="s0">, </span><span class="s1">group[i + </span><span class="s4">1</span><span class="s1">]))</span>

        <span class="s2"># Add some more random connections within the group</span>
        <span class="s1">min_idx</span><span class="s0">, </span><span class="s1">max_idx = </span><span class="s4">0</span><span class="s0">, </span><span class="s1">len(group) - </span><span class="s4">1</span>
        <span class="s1">n_random_connections = </span><span class="s4">1000</span>
        <span class="s1">source = rng.randint(min_idx</span><span class="s0">, </span><span class="s1">max_idx</span><span class="s0">, </span><span class="s1">size=n_random_connections)</span>
        <span class="s1">target = rng.randint(min_idx</span><span class="s0">, </span><span class="s1">max_idx</span><span class="s0">, </span><span class="s1">size=n_random_connections)</span>
        <span class="s1">connections.extend(zip(group[source]</span><span class="s0">, </span><span class="s1">group[target]))</span>

    <span class="s2"># Build a symmetric affinity matrix</span>
    <span class="s1">row_idx</span><span class="s0">, </span><span class="s1">column_idx = tuple(np.array(connections).T)</span>
    <span class="s1">data = rng.uniform(</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">42</span><span class="s0">, </span><span class="s1">size=len(connections))</span>
    <span class="s1">affinity = sparse.coo_matrix((data</span><span class="s0">, </span><span class="s1">(row_idx</span><span class="s0">, </span><span class="s1">column_idx)))</span>
    <span class="s1">affinity = </span><span class="s4">0.5 </span><span class="s1">* (affinity + affinity.T)</span>

    <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop </span><span class="s0">in </span><span class="s1">zip(boundaries[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">boundaries[</span><span class="s4">1</span><span class="s1">:]):</span>
        <span class="s1">component_1 = _graph_connected_component(affinity</span><span class="s0">, </span><span class="s1">p[start])</span>
        <span class="s1">component_size = stop - start</span>
        <span class="s0">assert </span><span class="s1">component_1.sum() == component_size</span>

        <span class="s2"># We should retrieve the same component mask by starting by both ends</span>
        <span class="s2"># of the group</span>
        <span class="s1">component_2 = _graph_connected_component(affinity</span><span class="s0">, </span><span class="s1">p[stop - </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">component_2.sum() == component_size</span>
        <span class="s1">assert_array_equal(component_1</span><span class="s0">, </span><span class="s1">component_2)</span>


<span class="s2"># TODO: investigate why this test is seed-sensitive on 32-bit Python</span>
<span class="s2"># runtimes. Is this revealing a numerical stability problem ? Or is it</span>
<span class="s2"># expected from the test numerical design ? In the latter case the test</span>
<span class="s2"># should be made less seed-sensitive instead.</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;eigen_solver&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s3">&quot;arpack&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;lobpcg&quot;</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span><span class="s3">&quot;amg&quot;</span><span class="s0">, </span><span class="s1">marks=skip_if_no_pyamg)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
<span class="s0">def </span><span class="s1">test_spectral_embedding_two_components(eigen_solver</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">seed=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s2"># Test spectral embedding with two components</span>
    <span class="s1">random_state = np.random.RandomState(seed)</span>
    <span class="s1">n_sample = </span><span class="s4">100</span>
    <span class="s1">affinity = np.zeros(shape=[n_sample * </span><span class="s4">2</span><span class="s0">, </span><span class="s1">n_sample * </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s2"># first component</span>
    <span class="s1">affinity[</span><span class="s4">0</span><span class="s1">:n_sample</span><span class="s0">, </span><span class="s4">0</span><span class="s1">:n_sample] = (</span>
        <span class="s1">np.abs(random_state.randn(n_sample</span><span class="s0">, </span><span class="s1">n_sample)) + </span><span class="s4">2</span>
    <span class="s1">)</span>
    <span class="s2"># second component</span>
    <span class="s1">affinity[n_sample::</span><span class="s0">, </span><span class="s1">n_sample::] = (</span>
        <span class="s1">np.abs(random_state.randn(n_sample</span><span class="s0">, </span><span class="s1">n_sample)) + </span><span class="s4">2</span>
    <span class="s1">)</span>

    <span class="s2"># Test of internal _graph_connected_component before connection</span>
    <span class="s1">component = _graph_connected_component(affinity</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">component[:n_sample].all()</span>
    <span class="s0">assert not </span><span class="s1">component[n_sample:].any()</span>
    <span class="s1">component = _graph_connected_component(affinity</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">component[:n_sample].any()</span>
    <span class="s0">assert </span><span class="s1">component[n_sample:].all()</span>

    <span class="s2"># connection</span>
    <span class="s1">affinity[</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n_sample + </span><span class="s4">1</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s1">affinity[n_sample + </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s1">affinity.flat[:: </span><span class="s4">2 </span><span class="s1">* n_sample + </span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">affinity = </span><span class="s4">0.5 </span><span class="s1">* (affinity + affinity.T)</span>

    <span class="s1">true_label = np.zeros(shape=</span><span class="s4">2 </span><span class="s1">* n_sample)</span>
    <span class="s1">true_label[</span><span class="s4">0</span><span class="s1">:n_sample] = </span><span class="s4">1</span>

    <span class="s1">se_precomp = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">affinity=</span><span class="s3">&quot;precomputed&quot;</span><span class="s0">,</span>
        <span class="s1">random_state=np.random.RandomState(seed)</span><span class="s0">,</span>
        <span class="s1">eigen_solver=eigen_solver</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">embedded_coordinate = se_precomp.fit_transform(affinity.astype(dtype))</span>
    <span class="s2"># thresholding on the first components using 0.</span>
    <span class="s1">label_ = np.array(embedded_coordinate.ravel() &lt; </span><span class="s4">0</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
    <span class="s0">assert </span><span class="s1">normalized_mutual_info_score(true_label</span><span class="s0">, </span><span class="s1">label_) == pytest.approx(</span><span class="s4">1.0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;X&quot;</span><span class="s0">, </span><span class="s1">[S</span><span class="s0">, </span><span class="s1">sparse.csr_matrix(S)]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s3">&quot;dense&quot;</span><span class="s0">, </span><span class="s3">&quot;sparse&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;eigen_solver&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s3">&quot;arpack&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;lobpcg&quot;</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span><span class="s3">&quot;amg&quot;</span><span class="s0">, </span><span class="s1">marks=skip_if_no_pyamg)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(np.float32</span><span class="s0">, </span><span class="s1">np.float64))</span>
<span class="s0">def </span><span class="s1">test_spectral_embedding_precomputed_affinity(X</span><span class="s0">, </span><span class="s1">eigen_solver</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">seed=</span><span class="s4">36</span><span class="s1">):</span>
    <span class="s2"># Test spectral embedding with precomputed kernel</span>
    <span class="s1">gamma = </span><span class="s4">1.0</span>
    <span class="s1">se_precomp = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">affinity=</span><span class="s3">&quot;precomputed&quot;</span><span class="s0">,</span>
        <span class="s1">random_state=np.random.RandomState(seed)</span><span class="s0">,</span>
        <span class="s1">eigen_solver=eigen_solver</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">se_rbf = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">affinity=</span><span class="s3">&quot;rbf&quot;</span><span class="s0">,</span>
        <span class="s1">gamma=gamma</span><span class="s0">,</span>
        <span class="s1">random_state=np.random.RandomState(seed)</span><span class="s0">,</span>
        <span class="s1">eigen_solver=eigen_solver</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">embed_precomp = se_precomp.fit_transform(rbf_kernel(X.astype(dtype)</span><span class="s0">, </span><span class="s1">gamma=gamma))</span>
    <span class="s1">embed_rbf = se_rbf.fit_transform(X.astype(dtype))</span>
    <span class="s1">assert_array_almost_equal(se_precomp.affinity_matrix_</span><span class="s0">, </span><span class="s1">se_rbf.affinity_matrix_)</span>
    <span class="s1">_assert_equal_with_sign_flipping(embed_precomp</span><span class="s0">, </span><span class="s1">embed_rbf</span><span class="s0">, </span><span class="s4">0.05</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_precomputed_nearest_neighbors_filtering():</span>
    <span class="s2"># Test precomputed graph filtering when containing too many neighbors</span>
    <span class="s1">n_neighbors = </span><span class="s4">2</span>
    <span class="s1">results = []</span>
    <span class="s0">for </span><span class="s1">additional_neighbors </span><span class="s0">in </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">10</span><span class="s1">]:</span>
        <span class="s1">nn = NearestNeighbors(n_neighbors=n_neighbors + additional_neighbors).fit(S)</span>
        <span class="s1">graph = nn.kneighbors_graph(S</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">&quot;connectivity&quot;</span><span class="s1">)</span>
        <span class="s1">embedding = (</span>
            <span class="s1">SpectralEmbedding(</span>
                <span class="s1">random_state=</span><span class="s4">0</span><span class="s0">,</span>
                <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">,</span>
                <span class="s1">affinity=</span><span class="s3">&quot;precomputed_nearest_neighbors&quot;</span><span class="s0">,</span>
                <span class="s1">n_neighbors=n_neighbors</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">.fit(graph)</span>
            <span class="s1">.embedding_</span>
        <span class="s1">)</span>
        <span class="s1">results.append(embedding)</span>

    <span class="s1">assert_array_equal(results[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results[</span><span class="s4">1</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;X&quot;</span><span class="s0">, </span><span class="s1">[S</span><span class="s0">, </span><span class="s1">sparse.csr_matrix(S)]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s3">&quot;dense&quot;</span><span class="s0">, </span><span class="s3">&quot;sparse&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_spectral_embedding_callable_affinity(X</span><span class="s0">, </span><span class="s1">seed=</span><span class="s4">36</span><span class="s1">):</span>
    <span class="s2"># Test spectral embedding with callable affinity</span>
    <span class="s1">gamma = </span><span class="s4">0.9</span>
    <span class="s1">kern = rbf_kernel(S</span><span class="s0">, </span><span class="s1">gamma=gamma)</span>
    <span class="s1">se_callable = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">affinity=(</span><span class="s0">lambda </span><span class="s1">x: rbf_kernel(x</span><span class="s0">, </span><span class="s1">gamma=gamma))</span><span class="s0">,</span>
        <span class="s1">gamma=gamma</span><span class="s0">,</span>
        <span class="s1">random_state=np.random.RandomState(seed)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">se_rbf = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">affinity=</span><span class="s3">&quot;rbf&quot;</span><span class="s0">,</span>
        <span class="s1">gamma=gamma</span><span class="s0">,</span>
        <span class="s1">random_state=np.random.RandomState(seed)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">embed_rbf = se_rbf.fit_transform(X)</span>
    <span class="s1">embed_callable = se_callable.fit_transform(X)</span>
    <span class="s1">assert_array_almost_equal(se_callable.affinity_matrix_</span><span class="s0">, </span><span class="s1">se_rbf.affinity_matrix_)</span>
    <span class="s1">assert_array_almost_equal(kern</span><span class="s0">, </span><span class="s1">se_rbf.affinity_matrix_)</span>
    <span class="s1">_assert_equal_with_sign_flipping(embed_rbf</span><span class="s0">, </span><span class="s1">embed_callable</span><span class="s0">, </span><span class="s4">0.05</span><span class="s1">)</span>


<span class="s2"># TODO: Remove when pyamg does replaces sp.rand call with np.random.rand</span>
<span class="s2"># https://github.com/scikit-learn/scikit-learn/issues/15913</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:scipy.rand is deprecated:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s2"># TODO: Remove when pyamg removes the use of np.float</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:`np.float` is a deprecated alias:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s2"># TODO: Remove when pyamg removes the use of pinv2</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:scipy.linalg.pinv2 is deprecated:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:np.find_common_type is deprecated:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.skipif(</span>
    <span class="s0">not </span><span class="s1">pyamg_available</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;PyAMG is required for the tests in this function.&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(np.float32</span><span class="s0">, </span><span class="s1">np.float64))</span>
<span class="s0">def </span><span class="s1">test_spectral_embedding_amg_solver(dtype</span><span class="s0">, </span><span class="s1">seed=</span><span class="s4">36</span><span class="s1">):</span>
    <span class="s1">se_amg = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">affinity=</span><span class="s3">&quot;nearest_neighbors&quot;</span><span class="s0">,</span>
        <span class="s1">eigen_solver=</span><span class="s3">&quot;amg&quot;</span><span class="s0">,</span>
        <span class="s1">n_neighbors=</span><span class="s4">5</span><span class="s0">,</span>
        <span class="s1">random_state=np.random.RandomState(seed)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">se_arpack = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">affinity=</span><span class="s3">&quot;nearest_neighbors&quot;</span><span class="s0">,</span>
        <span class="s1">eigen_solver=</span><span class="s3">&quot;arpack&quot;</span><span class="s0">,</span>
        <span class="s1">n_neighbors=</span><span class="s4">5</span><span class="s0">,</span>
        <span class="s1">random_state=np.random.RandomState(seed)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">embed_amg = se_amg.fit_transform(S.astype(dtype))</span>
    <span class="s1">embed_arpack = se_arpack.fit_transform(S.astype(dtype))</span>
    <span class="s1">_assert_equal_with_sign_flipping(embed_amg</span><span class="s0">, </span><span class="s1">embed_arpack</span><span class="s0">, </span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2"># same with special case in which amg is not actually used</span>
    <span class="s2"># regression test for #10715</span>
    <span class="s2"># affinity between nodes</span>
    <span class="s1">row = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span>
    <span class="s1">col = [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]</span>
    <span class="s1">val = [</span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">100</span><span class="s1">]</span>

    <span class="s1">affinity = sparse.coo_matrix(</span>
        <span class="s1">(val + val</span><span class="s0">, </span><span class="s1">(row + col</span><span class="s0">, </span><span class="s1">col + row))</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s4">6</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span>
    <span class="s1">).toarray()</span>
    <span class="s1">se_amg.affinity = </span><span class="s3">&quot;precomputed&quot;</span>
    <span class="s1">se_arpack.affinity = </span><span class="s3">&quot;precomputed&quot;</span>
    <span class="s1">embed_amg = se_amg.fit_transform(affinity.astype(dtype))</span>
    <span class="s1">embed_arpack = se_arpack.fit_transform(affinity.astype(dtype))</span>
    <span class="s1">_assert_equal_with_sign_flipping(embed_amg</span><span class="s0">, </span><span class="s1">embed_arpack</span><span class="s0">, </span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2"># TODO: Remove filterwarnings when pyamg does replaces sp.rand call with</span>
<span class="s2"># np.random.rand:</span>
<span class="s2"># https://github.com/scikit-learn/scikit-learn/issues/15913</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:scipy.rand is deprecated:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s2"># TODO: Remove when pyamg removes the use of np.float</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:`np.float` is a deprecated alias:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s2"># TODO: Remove when pyamg removes the use of pinv2</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:scipy.linalg.pinv2 is deprecated:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.skipif(</span>
    <span class="s0">not </span><span class="s1">pyamg_available</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;PyAMG is required for the tests in this function.&quot;</span>
<span class="s1">)</span>
<span class="s2"># TODO: Remove when pyamg removes the use of np.find_common_type</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:np.find_common_type is deprecated:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">(np.float32</span><span class="s0">, </span><span class="s1">np.float64))</span>
<span class="s0">def </span><span class="s1">test_spectral_embedding_amg_solver_failure(dtype</span><span class="s0">, </span><span class="s1">seed=</span><span class="s4">36</span><span class="s1">):</span>
    <span class="s2"># Non-regression test for amg solver failure (issue #13393 on github)</span>
    <span class="s1">num_nodes = </span><span class="s4">100</span>
    <span class="s1">X = sparse.rand(num_nodes</span><span class="s0">, </span><span class="s1">num_nodes</span><span class="s0">, </span><span class="s1">density=</span><span class="s4">0.1</span><span class="s0">, </span><span class="s1">random_state=seed)</span>
    <span class="s1">X = X.astype(dtype)</span>
    <span class="s1">upper = sparse.triu(X) - sparse.diags(X.diagonal())</span>
    <span class="s1">sym_matrix = upper + upper.T</span>
    <span class="s1">embedding = spectral_embedding(</span>
        <span class="s1">sym_matrix</span><span class="s0">, </span><span class="s1">n_components=</span><span class="s4">10</span><span class="s0">, </span><span class="s1">eigen_solver=</span><span class="s3">&quot;amg&quot;</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">0</span>
    <span class="s1">)</span>

    <span class="s2"># Check that the learned embedding is stable w.r.t. random solver init:</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
        <span class="s1">new_embedding = spectral_embedding(</span>
            <span class="s1">sym_matrix</span><span class="s0">, </span><span class="s1">n_components=</span><span class="s4">10</span><span class="s0">, </span><span class="s1">eigen_solver=</span><span class="s3">&quot;amg&quot;</span><span class="s0">, </span><span class="s1">random_state=i + </span><span class="s4">1</span>
        <span class="s1">)</span>
        <span class="s1">_assert_equal_with_sign_flipping(embedding</span><span class="s0">, </span><span class="s1">new_embedding</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">0.05</span><span class="s1">)</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:the behavior of nmi will change in version 0.22&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_pipeline_spectral_clustering(seed=</span><span class="s4">36</span><span class="s1">):</span>
    <span class="s2"># Test using pipeline to do spectral clustering</span>
    <span class="s1">random_state = np.random.RandomState(seed)</span>
    <span class="s1">se_rbf = SpectralEmbedding(</span>
        <span class="s1">n_components=n_clusters</span><span class="s0">, </span><span class="s1">affinity=</span><span class="s3">&quot;rbf&quot;</span><span class="s0">, </span><span class="s1">random_state=random_state</span>
    <span class="s1">)</span>
    <span class="s1">se_knn = SpectralEmbedding(</span>
        <span class="s1">n_components=n_clusters</span><span class="s0">,</span>
        <span class="s1">affinity=</span><span class="s3">&quot;nearest_neighbors&quot;</span><span class="s0">,</span>
        <span class="s1">n_neighbors=</span><span class="s4">5</span><span class="s0">,</span>
        <span class="s1">random_state=random_state</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">for </span><span class="s1">se </span><span class="s0">in </span><span class="s1">[se_rbf</span><span class="s0">, </span><span class="s1">se_knn]:</span>
        <span class="s1">km = KMeans(n_clusters=n_clusters</span><span class="s0">, </span><span class="s1">random_state=random_state</span><span class="s0">, </span><span class="s1">n_init=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">km.fit(se.fit_transform(S))</span>
        <span class="s1">assert_array_almost_equal(</span>
            <span class="s1">normalized_mutual_info_score(km.labels_</span><span class="s0">, </span><span class="s1">true_labels)</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_connectivity(seed=</span><span class="s4">36</span><span class="s1">):</span>
    <span class="s2"># Test that graph connectivity test works as expected</span>
    <span class="s1">graph = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">_graph_is_connected(graph)</span>
    <span class="s0">assert not </span><span class="s1">_graph_is_connected(sparse.csr_matrix(graph))</span>
    <span class="s0">assert not </span><span class="s1">_graph_is_connected(sparse.csc_matrix(graph))</span>
    <span class="s1">graph = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">_graph_is_connected(graph)</span>
    <span class="s0">assert </span><span class="s1">_graph_is_connected(sparse.csr_matrix(graph))</span>
    <span class="s0">assert </span><span class="s1">_graph_is_connected(sparse.csc_matrix(graph))</span>


<span class="s0">def </span><span class="s1">test_spectral_embedding_deterministic():</span>
    <span class="s2"># Test that Spectral Embedding is deterministic</span>
    <span class="s1">random_state = np.random.RandomState(</span><span class="s4">36</span><span class="s1">)</span>
    <span class="s1">data = random_state.randn(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
    <span class="s1">sims = rbf_kernel(data)</span>
    <span class="s1">embedding_1 = spectral_embedding(sims)</span>
    <span class="s1">embedding_2 = spectral_embedding(sims)</span>
    <span class="s1">assert_array_almost_equal(embedding_1</span><span class="s0">, </span><span class="s1">embedding_2)</span>


<span class="s0">def </span><span class="s1">test_spectral_embedding_unnormalized():</span>
    <span class="s2"># Test that spectral_embedding is also processing unnormalized laplacian</span>
    <span class="s2"># correctly</span>
    <span class="s1">random_state = np.random.RandomState(</span><span class="s4">36</span><span class="s1">)</span>
    <span class="s1">data = random_state.randn(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
    <span class="s1">sims = rbf_kernel(data)</span>
    <span class="s1">n_components = </span><span class="s4">8</span>
    <span class="s1">embedding_1 = spectral_embedding(</span>
        <span class="s1">sims</span><span class="s0">, </span><span class="s1">norm_laplacian=</span><span class="s0">False, </span><span class="s1">n_components=n_components</span><span class="s0">, </span><span class="s1">drop_first=</span><span class="s0">False</span>
    <span class="s1">)</span>

    <span class="s2"># Verify using manual computation with dense eigh</span>
    <span class="s1">laplacian</span><span class="s0">, </span><span class="s1">dd = csgraph.laplacian(sims</span><span class="s0">, </span><span class="s1">normed=</span><span class="s0">False, </span><span class="s1">return_diag=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">_</span><span class="s0">, </span><span class="s1">diffusion_map = eigh(laplacian)</span>
    <span class="s1">embedding_2 = diffusion_map.T[:n_components]</span>
    <span class="s1">embedding_2 = _deterministic_vector_sign_flip(embedding_2).T</span>

    <span class="s1">assert_array_almost_equal(embedding_1</span><span class="s0">, </span><span class="s1">embedding_2)</span>


<span class="s0">def </span><span class="s1">test_spectral_embedding_first_eigen_vector():</span>
    <span class="s2"># Test that the first eigenvector of spectral_embedding</span>
    <span class="s2"># is constant and that the second is not (for a connected graph)</span>
    <span class="s1">random_state = np.random.RandomState(</span><span class="s4">36</span><span class="s1">)</span>
    <span class="s1">data = random_state.randn(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">30</span><span class="s1">)</span>
    <span class="s1">sims = rbf_kernel(data)</span>
    <span class="s1">n_components = </span><span class="s4">2</span>

    <span class="s0">for </span><span class="s1">seed </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s1">embedding = spectral_embedding(</span>
            <span class="s1">sims</span><span class="s0">,</span>
            <span class="s1">norm_laplacian=</span><span class="s0">False,</span>
            <span class="s1">n_components=n_components</span><span class="s0">,</span>
            <span class="s1">drop_first=</span><span class="s0">False,</span>
            <span class="s1">random_state=seed</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">np.std(embedding[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]) == pytest.approx(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.std(embedding[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]) &gt; </span><span class="s4">1e-3</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;eigen_solver&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s3">&quot;arpack&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;lobpcg&quot;</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span><span class="s3">&quot;amg&quot;</span><span class="s0">, </span><span class="s1">marks=skip_if_no_pyamg)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
<span class="s0">def </span><span class="s1">test_spectral_embedding_preserves_dtype(eigen_solver</span><span class="s0">, </span><span class="s1">dtype):</span>
    <span class="s5">&quot;&quot;&quot;Check that `SpectralEmbedding is preserving the dtype of the fitted 
    attribute and transformed data. 
 
    Ideally, this test should be covered by the common test 
    `check_transformer_preserve_dtypes`. However, this test only run 
    with transformers implementing `transform` while `SpectralEmbedding` 
    implements only `fit_transform`. 
    &quot;&quot;&quot;</span>
    <span class="s1">X = S.astype(dtype)</span>
    <span class="s1">se = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">affinity=</span><span class="s3">&quot;rbf&quot;</span><span class="s0">, </span><span class="s1">eigen_solver=eigen_solver</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">0</span>
    <span class="s1">)</span>
    <span class="s1">X_trans = se.fit_transform(X)</span>

    <span class="s0">assert </span><span class="s1">X_trans.dtype == dtype</span>
    <span class="s0">assert </span><span class="s1">se.embedding_.dtype == dtype</span>
    <span class="s0">assert </span><span class="s1">se.affinity_matrix_.dtype == dtype</span>


<span class="s1">@pytest.mark.skipif(</span>
    <span class="s1">pyamg_available</span><span class="s0">,</span>
    <span class="s1">reason=</span><span class="s3">&quot;PyAMG is installed and we should not test for an error.&quot;</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_error_pyamg_not_available():</span>
    <span class="s1">se_precomp = SpectralEmbedding(</span>
        <span class="s1">n_components=</span><span class="s4">2</span><span class="s0">,</span>
        <span class="s1">affinity=</span><span class="s3">&quot;rbf&quot;</span><span class="s0">,</span>
        <span class="s1">eigen_solver=</span><span class="s3">&quot;amg&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">err_msg = </span><span class="s3">&quot;The eigen_solver was set to 'amg', but pyamg is not available.&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">se_precomp.fit_transform(S)</span>


<span class="s2"># TODO: Remove when pyamg removes the use of np.find_common_type</span>
<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s3">&quot;ignore:np.find_common_type is deprecated:DeprecationWarning:pyamg.*&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;solver&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;arpack&quot;</span><span class="s0">, </span><span class="s3">&quot;amg&quot;</span><span class="s0">, </span><span class="s3">&quot;lobpcg&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_spectral_eigen_tol_auto(monkeypatch</span><span class="s0">, </span><span class="s1">solver):</span>
    <span class="s5">&quot;&quot;&quot;Test that `eigen_tol=&quot;auto&quot;` is resolved correctly&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">solver == </span><span class="s3">&quot;amg&quot; </span><span class="s0">and not </span><span class="s1">pyamg_available:</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;PyAMG is not available.&quot;</span><span class="s1">)</span>
    <span class="s1">X</span><span class="s0">, </span><span class="s1">_ = make_blobs(</span>
        <span class="s1">n_samples=</span><span class="s4">200</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">centers=[[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">cluster_std=</span><span class="s4">0.01</span>
    <span class="s1">)</span>
    <span class="s1">D = pairwise_distances(X)  </span><span class="s2"># Distance matrix</span>
    <span class="s1">S = np.max(D) - D  </span><span class="s2"># Similarity matrix</span>

    <span class="s1">solver_func = eigsh </span><span class="s0">if </span><span class="s1">solver == </span><span class="s3">&quot;arpack&quot; </span><span class="s0">else </span><span class="s1">lobpcg</span>
    <span class="s1">default_value = </span><span class="s4">0 </span><span class="s0">if </span><span class="s1">solver == </span><span class="s3">&quot;arpack&quot; </span><span class="s0">else None</span>
    <span class="s0">if </span><span class="s1">solver == </span><span class="s3">&quot;amg&quot;</span><span class="s1">:</span>
        <span class="s1">S = sparse.csr_matrix(S)</span>

    <span class="s1">mocked_solver = Mock(side_effect=solver_func)</span>

    <span class="s1">monkeypatch.setattr(_spectral_embedding</span><span class="s0">, </span><span class="s1">solver_func.__qualname__</span><span class="s0">, </span><span class="s1">mocked_solver)</span>

    <span class="s1">spectral_embedding(S</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s4">42</span><span class="s0">, </span><span class="s1">eigen_solver=solver</span><span class="s0">, </span><span class="s1">eigen_tol=</span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span>
    <span class="s1">mocked_solver.assert_called()</span>

    <span class="s1">_</span><span class="s0">, </span><span class="s1">kwargs = mocked_solver.call_args</span>
    <span class="s0">assert </span><span class="s1">kwargs[</span><span class="s3">&quot;tol&quot;</span><span class="s1">] == default_value</span>
</pre>
</body>
</html>