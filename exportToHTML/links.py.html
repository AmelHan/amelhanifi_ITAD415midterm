<html>
<head>
<title>links.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
links.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Defines the link functions to be used with GLM and GEE families. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">scipy.stats</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s1">FLOAT_EPS = np.finfo(float).eps</span>


<span class="s2">def </span><span class="s1">_link_deprecation_warning(old</span><span class="s2">, </span><span class="s1">new):</span>
    <span class="s1">warnings.warn(</span>
        <span class="s3">f&quot;The </span><span class="s2">{</span><span class="s1">old</span><span class="s2">} </span><span class="s3">link alias is deprecated. Use </span><span class="s2">{</span><span class="s1">new</span><span class="s2">} </span><span class="s3">instead. The </span><span class="s2">{</span><span class="s1">old</span><span class="s2">} </span><span class="s3">&quot;</span>
        <span class="s3">f&quot;link alias will be removed after the 0.15.0 release.&quot;</span><span class="s2">,</span>
        <span class="s1">FutureWarning</span>
    <span class="s1">)</span>
    <span class="s4"># raise</span>


<span class="s2">class </span><span class="s1">Link:</span>
    <span class="s0">&quot;&quot;&quot; 
    A generic link function for one-parameter exponential family. 
 
    `Link` does nothing, but lays out the methods expected of any subclass. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the value of the link function.  This is just a placeholder. 
 
        Parameters 
        ---------- 
        p : array_like 
            Probabilities 
 
        Returns 
        ------- 
        g(p) : array_like 
            The value of the link function g(p) = z 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Inverse of the link function.  Just a placeholder. 
 
        Parameters 
        ---------- 
        z : array_like 
            `z` is usually the linear predictor of the transformed variable 
            in the IRLS algorithm for GLM. 
 
        Returns 
        ------- 
        g^(-1)(z) : ndarray 
            The value of the inverse of the link function g^(-1)(z) = p 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the link function g'(p).  Just a placeholder. 
 
        Parameters 
        ---------- 
        p : array_like 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            The value of the derivative of the link function g'(p) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot;Second derivative of the link function g''(p) 
 
        implemented through numerical differentiation 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">statsmodels.tools.numdiff </span><span class="s2">import </span><span class="s1">_approx_fprime_cs_scalar</span>
        <span class="s2">return </span><span class="s1">_approx_fprime_cs_scalar(p</span><span class="s2">, </span><span class="s1">self.deriv)</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse link function g^(-1)(z). 
 
        Parameters 
        ---------- 
        z : array_like 
            `z` is usually the linear predictor for a GLM or GEE model. 
 
        Returns 
        ------- 
        g'^(-1)(z) : ndarray 
            The value of the derivative of the inverse of the link function 
 
        Notes 
        ----- 
        This reference implementation gives the correct result but is 
        inefficient, so it can be overridden in subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">1 </span><span class="s1">/ self.deriv(self.inverse(z))</span>

    <span class="s2">def </span><span class="s1">inverse_deriv2(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the inverse link function g^(-1)(z). 
 
        Parameters 
        ---------- 
        z : array_like 
            `z` is usually the linear predictor for a GLM or GEE model. 
 
        Returns 
        ------- 
        g'^(-1)(z) : ndarray 
            The value of the second derivative of the inverse of the link 
            function 
 
        Notes 
        ----- 
        This reference implementation gives the correct result but is 
        inefficient, so it can be overridden in subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s1">iz = self.inverse(z)</span>
        <span class="s2">return </span><span class="s1">-self.deriv2(iz) / self.deriv(iz) ** </span><span class="s5">3</span>


<span class="s2">class </span><span class="s1">Logit(Link):</span>
    <span class="s0">&quot;&quot;&quot; 
    The logit transform 
 
    Notes 
    ----- 
    call and derivative use a private method _clean to make trim p by 
    machine epsilon so that p is in (0,1) 
 
    Alias of Logit: 
    logit = Logit() 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_clean(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Clip logistic values to range (eps, 1-eps) 
 
        Parameters 
        ---------- 
        p : array_like 
            Probabilities 
 
        Returns 
        ------- 
        pclip : ndarray 
            Clipped probabilities 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.clip(p</span><span class="s2">, </span><span class="s1">FLOAT_EPS</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">- FLOAT_EPS)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        The logit transform 
 
        Parameters 
        ---------- 
        p : array_like 
            Probabilities 
 
        Returns 
        ------- 
        z : ndarray 
            Logit transform of `p` 
 
        Notes 
        ----- 
        g(p) = log(p / (1 - p)) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">np.log(p / (</span><span class="s5">1. </span><span class="s1">- p))</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Inverse of the logit transform 
 
        Parameters 
        ---------- 
        z : array_like 
            The value of the logit transform at `p` 
 
        Returns 
        ------- 
        p : ndarray 
            Probabilities 
 
        Notes 
        ----- 
        g^(-1)(z) = exp(z)/(1+exp(z)) 
        &quot;&quot;&quot;</span>
        <span class="s1">z = np.asarray(z)</span>
        <span class="s1">t = np.exp(-z)</span>
        <span class="s2">return </span><span class="s5">1. </span><span class="s1">/ (</span><span class="s5">1. </span><span class="s1">+ t)</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the logit transform 
 
        Parameters 
        ---------- 
        p : array_like 
            Probabilities 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            Value of the derivative of logit transform at `p` 
 
        Notes 
        ----- 
        g'(p) = 1 / (p * (1 - p)) 
 
        Alias for `Logit`: 
        logit = Logit() 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s5">1. </span><span class="s1">/ (p * (</span><span class="s5">1 </span><span class="s1">- p))</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse of the logit transform 
 
        Parameters 
        ---------- 
        z : array_like 
            `z` is usually the linear predictor for a GLM or GEE model. 
 
        Returns 
        ------- 
        g'^(-1)(z) : ndarray 
            The value of the derivative of the inverse of the logit function 
        &quot;&quot;&quot;</span>
        <span class="s1">t = np.exp(z)</span>
        <span class="s2">return </span><span class="s1">t / (</span><span class="s5">1 </span><span class="s1">+ t) ** </span><span class="s5">2</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the logit function. 
 
        Parameters 
        ---------- 
        p : array_like 
            probabilities 
 
        Returns 
        ------- 
        g''(z) : ndarray 
            The value of the second derivative of the logit function 
        &quot;&quot;&quot;</span>
        <span class="s1">v = p * (</span><span class="s5">1 </span><span class="s1">- p)</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s5">2 </span><span class="s1">* p - </span><span class="s5">1</span><span class="s1">) / v ** </span><span class="s5">2</span>


<span class="s2">class </span><span class="s1">Power(Link):</span>
    <span class="s0">&quot;&quot;&quot; 
    The power transform 
 
    Parameters 
    ---------- 
    power : float 
        The exponent of the power transform 
 
    Notes 
    ----- 
    Aliases of Power: 
    Inverse = Power(power=-1) 
    Sqrt = Power(power=.5) 
    InverseSquared = Power(power=-2.) 
    Identity = Power(power=1.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">power=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s1">self.power = power</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Power transform link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        z : array_like 
            Power transform of x 
 
        Notes 
        ----- 
        g(p) = x**self.power 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.power == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">p</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.power(p</span><span class="s2">, </span><span class="s1">self.power)</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Inverse of the power transform link function 
 
        Parameters 
        ---------- 
        `z` : array_like 
            Value of the transformed mean parameters at `p` 
 
        Returns 
        ------- 
        `p` : ndarray 
            Mean parameters 
 
        Notes 
        ----- 
        g^(-1)(z`) = `z`**(1/`power`) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.power == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">z</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.power(z</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">/ self.power)</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the power transform 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            Derivative of power transform of `p` 
 
        Notes 
        ----- 
        g'(`p`) = `power` * `p`**(`power` - 1) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.power == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.ones_like(p)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.power * np.power(p</span><span class="s2">, </span><span class="s1">self.power - </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the power transform 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g''(p) : ndarray 
            Second derivative of the power transform of `p` 
 
        Notes 
        ----- 
        g''(`p`) = `power` * (`power` - 1) * `p`**(`power` - 2) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.power == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.zeros_like(p)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.power * (self.power - </span><span class="s5">1</span><span class="s1">) * np.power(p</span><span class="s2">, </span><span class="s1">self.power - </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse of the power transform 
 
        Parameters 
        ---------- 
        z : array_like 
            `z` is usually the linear predictor for a GLM or GEE model. 
 
        Returns 
        ------- 
        g^(-1)'(z) : ndarray 
            The value of the derivative of the inverse of the power transform 
        function 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.power == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.ones_like(z)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.power(z</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- self.power) / self.power) / self.power</span>

    <span class="s2">def </span><span class="s1">inverse_deriv2(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the inverse of the power transform 
 
        Parameters 
        ---------- 
        z : array_like 
            `z` is usually the linear predictor for a GLM or GEE model. 
 
        Returns 
        ------- 
        g^(-1)'(z) : ndarray 
            The value of the derivative of the inverse of the power transform 
        function 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.power == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.zeros_like(z)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">((</span><span class="s5">1 </span><span class="s1">- self.power) *</span>
                    <span class="s1">np.power(z</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- </span><span class="s5">2</span><span class="s1">*self.power)/self.power) / self.power**</span><span class="s5">2</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">InversePower(Power):</span>
    <span class="s0">&quot;&quot;&quot; 
    The inverse transform 
 
    Notes 
    ----- 
    g(p) = 1/p 
 
    Alias of statsmodels.family.links.Power(power=-1.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__(power=-</span><span class="s5">1.</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Sqrt(Power):</span>
    <span class="s0">&quot;&quot;&quot; 
    The square-root transform 
 
    Notes 
    ----- 
    g(`p`) = sqrt(`p`) 
 
    Alias of statsmodels.family.links.Power(power=.5) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__(power=</span><span class="s5">.5</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">InverseSquared(Power):</span>
    <span class="s0">r&quot;&quot;&quot; 
    The inverse squared transform 
 
    Notes 
    ----- 
    g(`p`) = 1/(`p`\*\*2) 
 
    Alias of statsmodels.family.links.Power(power=2.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__(power=-</span><span class="s5">2.</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Identity(Power):</span>
    <span class="s0">&quot;&quot;&quot; 
    The identity transform 
 
    Notes 
    ----- 
    g(`p`) = `p` 
 
    Alias of statsmodels.family.links.Power(power=1.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__(power=</span><span class="s5">1.</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Log(Link):</span>
    <span class="s0">&quot;&quot;&quot; 
    The log transform 
 
    Notes 
    ----- 
    call and derivative call a private method _clean to trim the data by 
    machine epsilon so that p is in (0,1). log is an alias of Log. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_clean(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.clip(x</span><span class="s2">, </span><span class="s1">FLOAT_EPS</span><span class="s2">, </span><span class="s1">np.inf)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">**extra):</span>
        <span class="s0">&quot;&quot;&quot; 
        Log transform link function 
 
        Parameters 
        ---------- 
        x : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        z : ndarray 
            log(x) 
 
        Notes 
        ----- 
        g(p) = log(p) 
        &quot;&quot;&quot;</span>
        <span class="s1">x = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">np.log(x)</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Inverse of log transform link function 
 
        Parameters 
        ---------- 
        z : ndarray 
            The inverse of the link function at `p` 
 
        Returns 
        ------- 
        p : ndarray 
            The mean probabilities given the value of the inverse `z` 
 
        Notes 
        ----- 
        g^{-1}(z) = exp(z) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.exp(z)</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of log transform link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            derivative of log transform of x 
 
        Notes 
        ----- 
        g'(x) = 1/x 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s5">1. </span><span class="s1">/ p</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the log transform link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g''(p) : ndarray 
            Second derivative of log transform of x 
 
        Notes 
        ----- 
        g''(x) = -1/x^2 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1. </span><span class="s1">/ p ** </span><span class="s5">2</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse of the log transform link function 
 
        Parameters 
        ---------- 
        z : ndarray 
            The inverse of the link function at `p` 
 
        Returns 
        ------- 
        g^(-1)'(z) : ndarray 
            The value of the derivative of the inverse of the log function, 
            the exponential function 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.exp(z)</span>


<span class="s2">class </span><span class="s1">LogC(Link):</span>
    <span class="s0">&quot;&quot;&quot; 
    The log-complement transform 
 
    Notes 
    ----- 
    call and derivative call a private method _clean to trim the data by 
    machine epsilon so that p is in (0,1). logc is an alias of LogC. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_clean(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.clip(x</span><span class="s2">, </span><span class="s1">FLOAT_EPS</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">- FLOAT_EPS)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">**extra):</span>
        <span class="s0">&quot;&quot;&quot; 
        Log-complement transform link function 
 
        Parameters 
        ---------- 
        x : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        z : ndarray 
            log(1 - x) 
 
        Notes 
        ----- 
        g(p) = log(1-p) 
        &quot;&quot;&quot;</span>
        <span class="s1">x = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">np.log(</span><span class="s5">1 </span><span class="s1">- x)</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Inverse of log-complement transform link function 
 
        Parameters 
        ---------- 
        z : ndarray 
            The inverse of the link function at `p` 
 
        Returns 
        ------- 
        p : ndarray 
            The mean probabilities given the value of the inverse `z` 
 
        Notes 
        ----- 
        g^{-1}(z) = 1 - exp(z) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">1 </span><span class="s1">- np.exp(z)</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of log-complement transform link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            derivative of log-complement transform of x 
 
        Notes 
        ----- 
        g'(x) = -1/(1 - x) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1. </span><span class="s1">/ (</span><span class="s5">1. </span><span class="s1">- p)</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the log-complement transform link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g''(p) : ndarray 
            Second derivative of log-complement transform of x 
 
        Notes 
        ----- 
        g''(x) = -(-1/(1 - x))^2 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1 </span><span class="s1">* np.power(-</span><span class="s5">1. </span><span class="s1">/ (</span><span class="s5">1. </span><span class="s1">- p)</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse of the log-complement transform link 
        function 
 
        Parameters 
        ---------- 
        z : ndarray 
            The inverse of the link function at `p` 
 
        Returns 
        ------- 
        g^(-1)'(z) : ndarray 
            The value of the derivative of the inverse of the log-complement 
            function. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">-np.exp(z)</span>

    <span class="s2">def </span><span class="s1">inverse_deriv2(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the inverse link function g^(-1)(z). 
 
        Parameters 
        ---------- 
        z : array_like 
            The inverse of the link function at `p` 
 
        Returns 
        ------- 
        g^(-1)''(z) : ndarray 
            The value of the second derivative of the inverse of the 
            log-complement function. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">-np.exp(z)</span>


<span class="s4"># TODO: the CDFLink is untested</span>
<span class="s2">class </span><span class="s1">CDFLink(Logit):</span>
    <span class="s0">&quot;&quot;&quot; 
    The use the CDF of a scipy.stats distribution 
 
    CDFLink is a subclass of logit in order to use its _clean method 
    for the link and its derivative. 
 
    Parameters 
    ---------- 
    dbn : scipy.stats distribution 
        Default is dbn=scipy.stats.norm 
 
    Notes 
    ----- 
    The CDF link is untested. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dbn=scipy.stats.norm):</span>
        <span class="s1">self.dbn = dbn</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        CDF link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        z : ndarray 
            (ppf) inverse of CDF transform of p 
 
        Notes 
        ----- 
        g(`p`) = `dbn`.ppf(`p`) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">self.dbn.ppf(p)</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        The inverse of the CDF link 
 
        Parameters 
        ---------- 
        z : array_like 
            The value of the inverse of the link function at `p` 
 
        Returns 
        ------- 
        p : ndarray 
            Mean probabilities.  The value of the inverse of CDF link of `z` 
 
        Notes 
        ----- 
        g^(-1)(`z`) = `dbn`.cdf(`z`) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.dbn.cdf(z)</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of CDF link 
 
        Parameters 
        ---------- 
        p : array_like 
            mean parameters 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            The derivative of CDF transform at `p` 
 
        Notes 
        ----- 
        g'(`p`) = 1./ `dbn`.pdf(`dbn`.ppf(`p`)) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s5">1. </span><span class="s1">/ self.dbn.pdf(self.dbn.ppf(p))</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the link function g''(p) 
 
        implemented through numerical differentiation 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s1">linpred = self.dbn.ppf(p)</span>
        <span class="s2">return </span><span class="s1">- self.inverse_deriv2(linpred) / self.dbn.pdf(linpred) ** </span><span class="s5">3</span>

    <span class="s2">def </span><span class="s1">deriv2_numdiff(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the link function g''(p) 
 
        implemented through numerical differentiation 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">statsmodels.tools.numdiff </span><span class="s2">import </span><span class="s1">_approx_fprime_scalar</span>
        <span class="s1">p = np.atleast_1d(p)</span>
        <span class="s4"># Note: special function for norm.ppf does not support complex</span>
        <span class="s2">return </span><span class="s1">_approx_fprime_scalar(p</span><span class="s2">, </span><span class="s1">self.deriv</span><span class="s2">, </span><span class="s1">centered=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse link function 
 
        Parameters 
        ---------- 
        z : ndarray 
            The inverse of the link function at `p` 
 
        Returns 
        ------- 
        g^(-1)'(z) : ndarray 
            The value of the derivative of the inverse of the logit function. 
            This is just the pdf in a CDFLink, 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.dbn.pdf(z)</span>

    <span class="s2">def </span><span class="s1">inverse_deriv2(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the inverse link function g^(-1)(z). 
 
        Parameters 
        ---------- 
        z : array_like 
            `z` is usually the linear predictor for a GLM or GEE model. 
 
        Returns 
        ------- 
        g^(-1)''(z) : ndarray 
            The value of the second derivative of the inverse of the link 
            function 
 
        Notes 
        ----- 
        This method should be overwritten by subclasses. 
 
        The inherited method is implemented through numerical differentiation. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">statsmodels.tools.numdiff </span><span class="s2">import </span><span class="s1">_approx_fprime_scalar</span>
        <span class="s1">z = np.atleast_1d(z)</span>

        <span class="s4"># Note: special function for norm.ppf does not support complex</span>
        <span class="s2">return </span><span class="s1">_approx_fprime_scalar(z</span><span class="s2">, </span><span class="s1">self.inverse_deriv</span><span class="s2">, </span><span class="s1">centered=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Probit(CDFLink):</span>
    <span class="s0">&quot;&quot;&quot; 
    The probit (standard normal CDF) transform 
 
    Notes 
    ----- 
    g(p) = scipy.stats.norm.ppf(p) 
 
    probit is an alias of CDFLink. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">inverse_deriv2(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the inverse link function 
 
        This is the derivative of the pdf in a CDFLink 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">- z * self.dbn.pdf(z)</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the link function g''(p) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s1">linpred = self.dbn.ppf(p)</span>
        <span class="s2">return </span><span class="s1">linpred / self.dbn.pdf(linpred) ** </span><span class="s5">2</span>


<span class="s2">class </span><span class="s1">Cauchy(CDFLink):</span>
    <span class="s0">&quot;&quot;&quot; 
    The Cauchy (standard Cauchy CDF) transform 
 
    Notes 
    ----- 
    g(p) = scipy.stats.cauchy.ppf(p) 
 
    cauchy is an alias of CDFLink with dbn=scipy.stats.cauchy 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__(dbn=scipy.stats.cauchy)</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the Cauchy link function. 
 
        Parameters 
        ---------- 
        p : array_like 
            Probabilities 
 
        Returns 
        ------- 
        g''(p) : ndarray 
            Value of the second derivative of Cauchy link function at `p` 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s1">a = np.pi * (p - </span><span class="s5">0.5</span><span class="s1">)</span>
        <span class="s1">d2 = </span><span class="s5">2 </span><span class="s1">* np.pi ** </span><span class="s5">2 </span><span class="s1">* np.sin(a) / np.cos(a) ** </span><span class="s5">3</span>
        <span class="s2">return </span><span class="s1">d2</span>

    <span class="s2">def </span><span class="s1">inverse_deriv2(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s2">return </span><span class="s1">- </span><span class="s5">2 </span><span class="s1">* z / (np.pi * (z ** </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">) ** </span><span class="s5">2</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">CLogLog(Logit):</span>
    <span class="s0">&quot;&quot;&quot; 
    The complementary log-log transform 
 
    CLogLog inherits from Logit in order to have access to its _clean method 
    for the link and its derivative. 
 
    Notes 
    ----- 
    CLogLog is untested. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        C-Log-Log transform link function 
 
        Parameters 
        ---------- 
        p : ndarray 
            Mean parameters 
 
        Returns 
        ------- 
        z : ndarray 
            The CLogLog transform of `p` 
 
        Notes 
        ----- 
        g(p) = log(-log(1-p)) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">np.log(-np.log(</span><span class="s5">1 </span><span class="s1">- p))</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Inverse of C-Log-Log transform link function 
 
 
        Parameters 
        ---------- 
        z : array_like 
            The value of the inverse of the CLogLog link function at `p` 
 
        Returns 
        ------- 
        p : ndarray 
            Mean parameters 
 
        Notes 
        ----- 
        g^(-1)(`z`) = 1-exp(-exp(`z`)) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">1 </span><span class="s1">- np.exp(-np.exp(z))</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of C-Log-Log transform link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            The derivative of the CLogLog transform link function 
 
        Notes 
        ----- 
        g'(p) = - 1 / ((p-1)*log(1-p)) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s5">1. </span><span class="s1">/ ((p - </span><span class="s5">1</span><span class="s1">) * (np.log(</span><span class="s5">1 </span><span class="s1">- p)))</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the C-Log-Log ink function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g''(p) : ndarray 
            The second derivative of the CLogLog link function 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s1">fl = np.log(</span><span class="s5">1 </span><span class="s1">- p)</span>
        <span class="s1">d2 = -</span><span class="s5">1 </span><span class="s1">/ ((</span><span class="s5">1 </span><span class="s1">- p) ** </span><span class="s5">2 </span><span class="s1">* fl)</span>
        <span class="s1">d2 *= </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">/ fl</span>
        <span class="s2">return </span><span class="s1">d2</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse of the C-Log-Log transform link function 
 
        Parameters 
        ---------- 
        z : array_like 
            The value of the inverse of the CLogLog link function at `p` 
 
        Returns 
        ------- 
        g^(-1)'(z) : ndarray 
            The derivative of the inverse of the CLogLog link function 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.exp(z - np.exp(z))</span>


<span class="s2">class </span><span class="s1">LogLog(Logit):</span>
    <span class="s0">&quot;&quot;&quot; 
    The log-log transform 
 
    LogLog inherits from Logit in order to have access to its _clean method 
    for the link and its derivative. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Log-Log transform link function 
 
        Parameters 
        ---------- 
        p : ndarray 
            Mean parameters 
 
        Returns 
        ------- 
        z : ndarray 
            The LogLog transform of `p` 
 
        Notes 
        ----- 
        g(p) = -log(-log(p)) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">-np.log(-np.log(p))</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Inverse of Log-Log transform link function 
 
 
        Parameters 
        ---------- 
        z : array_like 
            The value of the inverse of the LogLog link function at `p` 
 
        Returns 
        ------- 
        p : ndarray 
            Mean parameters 
 
        Notes 
        ----- 
        g^(-1)(`z`) = exp(-exp(-`z`)) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.exp(-np.exp(-z))</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of Log-Log transform link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            The derivative of the LogLog transform link function 
 
        Notes 
        ----- 
        g'(p) = - 1 /(p * log(p)) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1. </span><span class="s1">/ (p * (np.log(p)))</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the Log-Log link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g''(p) : ndarray 
            The second derivative of the LogLog link function 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s1">d2 = (</span><span class="s5">1 </span><span class="s1">+ np.log(p)) / (p * (np.log(p))) ** </span><span class="s5">2</span>
        <span class="s2">return </span><span class="s1">d2</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse of the Log-Log transform link function 
 
        Parameters 
        ---------- 
        z : array_like 
            The value of the inverse of the LogLog link function at `p` 
 
        Returns 
        ------- 
        g^(-1)'(z) : ndarray 
            The derivative of the inverse of the LogLog link function 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.exp(-np.exp(-z) - z)</span>

    <span class="s2">def </span><span class="s1">inverse_deriv2(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the inverse of the Log-Log transform link function 
 
        Parameters 
        ---------- 
        z : array_like 
            The value of the inverse of the LogLog link function at `p` 
 
        Returns 
        ------- 
        g^(-1)''(z) : ndarray 
            The second derivative of the inverse of the LogLog link function 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.inverse_deriv(z) * (np.exp(-z) - </span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">NegativeBinomial(Link):</span>
    <span class="s0">&quot;&quot;&quot; 
    The negative binomial link function 
 
    Parameters 
    ---------- 
    alpha : float, optional 
        Alpha is the ancillary parameter of the Negative Binomial link 
        function. It is assumed to be nonstochastic.  The default value is 1. 
        Permissible values are usually assumed to be in (.01, 2). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s1">self.alpha = alpha</span>

    <span class="s2">def </span><span class="s1">_clean(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.clip(x</span><span class="s2">, </span><span class="s1">FLOAT_EPS</span><span class="s2">, </span><span class="s1">np.inf)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Negative Binomial transform link function 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        z : ndarray 
            The negative binomial transform of `p` 
 
        Notes 
        ----- 
        g(p) = log(p/(p + 1/alpha)) 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self._clean(p)</span>
        <span class="s2">return </span><span class="s1">np.log(p / (p + </span><span class="s5">1 </span><span class="s1">/ self.alpha))</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Inverse of the negative binomial transform 
 
        Parameters 
        ---------- 
        z : array_like 
            The value of the inverse of the negative binomial link at `p`. 
 
        Returns 
        ------- 
        p : ndarray 
            Mean parameters 
 
        Notes 
        ----- 
        g^(-1)(z) = exp(z)/(alpha*(1-exp(z))) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1 </span><span class="s1">/ (self.alpha * (</span><span class="s5">1 </span><span class="s1">- np.exp(-z)))</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the negative binomial transform 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g'(p) : ndarray 
            The derivative of the negative binomial transform link function 
 
        Notes 
        ----- 
        g'(x) = 1/(x+alpha*x^2) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">1 </span><span class="s1">/ (p + self.alpha * p ** </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">deriv2(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Second derivative of the negative binomial link function. 
 
        Parameters 
        ---------- 
        p : array_like 
            Mean parameters 
 
        Returns 
        ------- 
        g''(p) : ndarray 
            The second derivative of the negative binomial transform link 
            function 
 
        Notes 
        ----- 
        g''(x) = -(1+2*alpha*x)/(x+alpha*x^2)^2 
        &quot;&quot;&quot;</span>
        <span class="s1">numer = -(</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">* self.alpha * p)</span>
        <span class="s1">denom = (p + self.alpha * p ** </span><span class="s5">2</span><span class="s1">) ** </span><span class="s5">2</span>
        <span class="s2">return </span><span class="s1">numer / denom</span>

    <span class="s2">def </span><span class="s1">inverse_deriv(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derivative of the inverse of the negative binomial transform 
 
        Parameters 
        ---------- 
        z : array_like 
            Usually the linear predictor for a GLM or GEE model 
 
        Returns 
        ------- 
        g^(-1)'(z) : ndarray 
            The value of the derivative of the inverse of the negative 
            binomial link 
        &quot;&quot;&quot;</span>
        <span class="s1">t = np.exp(z)</span>
        <span class="s2">return </span><span class="s1">t / (self.alpha * (</span><span class="s5">1 </span><span class="s1">- t) ** </span><span class="s5">2</span><span class="s1">)</span>


<span class="s4"># TODO: Deprecated aliases, remove after 0.15</span>
<span class="s2">class </span><span class="s1">logit(Logit):</span>
    <span class="s0">&quot;&quot;&quot; 
    Alias of Logit 
 
    .. deprecated: 0.14.0 
 
       Use Logit instead. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'logit'</span><span class="s2">, </span><span class="s3">'Logit'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">inverse_power(InversePower):</span>
    <span class="s0">&quot;&quot;&quot; 
    Deprecated alias of InversePower. 
 
    .. deprecated: 0.14.0 
 
        Use InversePower instead. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'inverse_power'</span><span class="s2">, </span><span class="s3">'InversePower'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">sqrt(Sqrt):</span>
    <span class="s0">&quot;&quot;&quot; 
    Deprecated alias of Sqrt. 
 
    .. deprecated: 0.14.0 
 
        Use Sqrt instead. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'sqrt'</span><span class="s2">, </span><span class="s3">'Sqrt'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">inverse_squared(InverseSquared):</span>
    <span class="s0">&quot;&quot;&quot; 
    Deprecated alias of InverseSquared. 
 
    .. deprecated: 0.14.0 
 
        Use InverseSquared instead. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'inverse_squared'</span><span class="s2">, </span><span class="s3">'InverseSquared'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">identity(Identity):</span>
    <span class="s0">&quot;&quot;&quot; 
    Deprecated alias of Identity. 
 
    .. deprecated: 0.14.0 
 
        Use Identity instead. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'identity'</span><span class="s2">, </span><span class="s3">'Identity'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">log(Log):</span>
    <span class="s0">&quot;&quot;&quot; 
    The log transform 
 
    .. deprecated: 0.14.0 
 
       Use Log instead. 
 
    Notes 
    ----- 
    log is a an alias of Log. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'log'</span><span class="s2">, </span><span class="s3">'Log'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">logc(LogC):</span>
    <span class="s0">&quot;&quot;&quot; 
    The log-complement transform 
 
    .. deprecated: 0.14.0 
 
       Use LogC instead. 
 
    Notes 
    ----- 
    logc is a an alias of LogC. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'logc'</span><span class="s2">, </span><span class="s3">'LogC'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">probit(Probit):</span>
    <span class="s0">&quot;&quot;&quot; 
    The probit (standard normal CDF) transform 
 
    .. deprecated: 0.14.0 
 
       Use Probit instead. 
 
    Notes 
    ----- 
    probit is an alias of Probit. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'probit'</span><span class="s2">, </span><span class="s3">'Probit'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">cauchy(Cauchy):</span>
    <span class="s0">&quot;&quot;&quot; 
    The Cauchy (standard Cauchy CDF) transform 
 
    .. deprecated: 0.14.0 
 
       Use Cauchy instead. 
 
    Notes 
    ----- 
    cauchy is an alias of Cauchy. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'cauchy'</span><span class="s2">, </span><span class="s3">'Cauchy'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">cloglog(CLogLog):</span>
    <span class="s0">&quot;&quot;&quot; 
    The CLogLog transform link function. 
 
    .. deprecated: 0.14.0 
 
       Use CLogLog instead. 
 
    Notes 
    ----- 
    g(`p`) = log(-log(1-`p`)) 
 
    cloglog is an alias for CLogLog 
    cloglog = CLogLog() 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'cloglog'</span><span class="s2">, </span><span class="s3">'CLogLog'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">loglog(LogLog):</span>
    <span class="s0">&quot;&quot;&quot; 
    The LogLog transform link function. 
 
    .. deprecated: 0.14.0 
 
       Use LogLog instead. 
 
    Notes 
    ----- 
    g(`p`) = -log(-log(`p`)) 
 
    loglog is an alias for LogLog 
    loglog = LogLog() 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'loglog'</span><span class="s2">, </span><span class="s3">'LogLog'</span><span class="s1">)</span>
        <span class="s1">super().__init__()</span>


<span class="s2">class </span><span class="s1">nbinom(NegativeBinomial):</span>
    <span class="s0">&quot;&quot;&quot; 
    The negative binomial link function. 
 
    .. deprecated: 0.14.0 
 
       Use NegativeBinomial instead. 
 
    Notes 
    ----- 
    g(p) = log(p/(p + 1/alpha)) 
 
    nbinom is an alias of NegativeBinomial. 
    nbinom = NegativeBinomial(alpha=1.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s1">_link_deprecation_warning(</span><span class="s3">'nbinom'</span><span class="s2">, </span><span class="s3">'NegativeBinomial'</span><span class="s1">)</span>
        <span class="s1">super().__init__(alpha=alpha)</span>
</pre>
</body>
</html>